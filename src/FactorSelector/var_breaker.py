#! /usr/bin/env python
# coding=utf-8

import argparse
import os
import numpy as np

from LatencyAggregator import LatencyAggregator

# Note for TODO. Filter by semantic interval ID AFTER we get critical path.
# Thus, when checking whether a factor should be in the variance tree, first
# check if it's the correct semantic interval ID, then check whether it's part
# of the critical path.  In other words, we don't need to check whether a factor
# is part of the critical path when building the critical path, only after it is
# constructed.
from CriticalPathBuilder import CriticalPathBuilder


def cov(var1, var2):
    """ Return the covariance of two lists """
    cov_matrix = np.cov(np.vstack((var1, var2)))
    return cov_matrix[0, 1]


def collect_exec_time(function_file, path):
    """ Read function execution time data from file """
    functions = open(path + function_file, 'r')
    functions.readline()
    function_names = [function.strip() for function in functions]

    latency_aggregator = LatencyAggregator(path)
    function_exec_time = latency_aggregator.GetLatencies(path, len(function_names))

    function_names.insert(0, function_file)
    function_names.append('synchronization wait time')
    function_names.append('latency')
    return function_names, function_exec_time

def break_down(function_file, path, var_tree_file):
    """ Break down variance into variances and covariances """
    function_names, function_exec_time = collect_exec_time(function_file, path)
    caller = function_names[0]
    function_names[0] = 'img_' + function_names[0]

    latency_data = function_exec_time[0]
    imaginary_records = function_exec_time[-2]
    variance_of_latency = np.var(latency_data)
    size = len(imaginary_records)
    for index in range(size):
        imaginary = imaginary_records[index]
        for i in range(1, len(function_names) - 1):
            records = function_exec_time[i]
            imaginary -= records[index]
            if imaginary < 0:
                for exec_time in function_exec_time:
                    print exec_time[index]
                print imaginary
            assert imaginary >= 0
        imaginary_records[index] = imaginary

    if not os.path.exists(var_tree_file):
        tree_file = open(var_tree_file, 'w')
    else:
        tree_file = open(var_tree_file, 'a')
    tree_file.write('\n\n')

    variance_break_down = []
    length = len(function_names)
    sum_of_variance = 0
    for index1 in range(length - 1):
        for index2 in range(index1 + 1):
            function_name1 = function_names[index1]
            function_name2 = function_names[index2]
            if index1 == index2:
                variance = np.var(function_exec_time[index1])
                sum_of_variance += variance
                variance_break_down.append((function_name1, variance))
                if variance / variance_of_latency > 2e-3:
                    tree_file.write('"' + caller + '" -> "' + function_name1 +
                                    '" -> "' + str(variance / variance_of_latency) + '"\n')
            else:
                covariance = cov(function_exec_time[index1],
                                 function_exec_time[index2])
                sum_of_variance += covariance
                variance_break_down.append(
                    (function_name1 + ',' + function_name2, 2 * covariance))
                if 2 * covariance / variance_of_latency > 1e-3:
                    tree_file.write('"' + caller + '" -> "' + function_name1 + '",' +
                                    function_name2 + '" -> "' +
                                    str(2 * covariance / variance_of_latency) + '"\n')


def main():
    """ Main function """
    parser = argparse.ArgumentParser()
    parser.add_argument('-f', '--funclist', help='File containing list of function names')
    parser.add_argument('-d', '--dir', help='Direcoty of trace files generated by trace_tool')
    parser.add_argument('-v', '--vartree', help='Variance tree file')
    args = parser.parse_args()
    break_down(args.funclist, args.dir, args.vartree)


if __name__ == '__main__':
    main()
