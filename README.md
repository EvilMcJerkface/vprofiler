# VProfiler

VProfiler is a profiling tool that can efficiently and rigorously decompose the variance of the overall execution time of an application by automatically instrumenting its source code, and identifying the major functions that contribute the most to the overall variance. This tool is still at an early version, and it supports only MySQL (C++) and Postgres (C). Depending on the exact setting of the software system, a script can be used to connect the three parts of this tool to make it fully automatic.

This tool currently supports only Linux.

### Compilation:
Run script `compile.sh` to compile the code.
```
chmod +x compile.sh
./compile.sh
```
The compiled files reside in each of the three folders. `cd` in the corresponding folder before using them.

This tool contains three parts:

1. ExecutionTimeTracer: the tracer collects execution time data for a certain function and all the function called in that function. It also collects latency data. Appropriate functions should be called in order to mark the start and end of a query and transaction. Data files will be generated after each run with all the execution time data for further analysis. The current version of this tool supports only MySQL and Postgres. 

   Usage: Add the files to the code base of the application so that the defined functions can be called.

   In MySQL, call function `TraceTool::get_instance()->start_new_query()`, `TraceTool::get_instance()->query_end()` and `TraceTool::get_instance()->end_transaction()` at the appropriate location to mark the start, end of a query and end of a transaction. Set `TraceTool::is_commit` to true if the query is a commit query.

   In Postgres, call function `TRX_START()`, `TRX_END()` at the appropriate location to mark the start and end of a transaction. Call `COMMIT()` if the query is a commit query.

   The data files will be put in folder `latency`. The exact location of this folder depends on the software system being profiled. Make sure that this folder exists before running experiments.

2. SourceAnnotator: the annotator instruments the source code of the software application. It inserts appropriate function calls to call the functions defined in ExectuionTimeTracer to mark the start and end of a function call.

   Usage:
   ```
   ./annotate.sh <source code file> <function name> <location of trace_tool.cc file>
   ```

   This tool updates file `trace_tool.cc`. Use it for further experiments.

   This tool will generate another file with `function name` as its name, which contains the names of each child function of `function name`. This file is used in FactorSelector.

3. FactorSelector: Given the data files generated by the ExecutionTimeTracer, the selector breaks down the variance and performs a selections on the variance tree to select the top k most interesting functions. Note that this tool requires a pre-generated static call graph for the software application. Such call graph can be generated using tools like [CodeViz](http://www.csn.ul.ie/~mel/projects/codeviz/). A file containing the heights of each function in the call graph needs to be generated, each line in the form `func_name,height`.

   Usage:
   ```
   ./select_factor.sh <function name file> <dir of data files generated from ExectuionTimeTracer> <heights file> <k> <root function> [selected functions]
   ```

   Here `k` is the number of sources of variance you want to find. `root function` is entry point function for query or transaction processing. `selected functions` are functions that you want to mark as selected major sources of variance if they already provide enough information on why variance occurs, separated by commas.
