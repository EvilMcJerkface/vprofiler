"dispatch_command(enum_server_command,THD*,char*,uint)" -> "calc_sum_of_all_status(STATUS_VAR*)"
"dispatch_command(enum_server_command,THD*,char*,uint)" -> "lex_start(THD*)"
"dispatch_command(enum_server_command,THD*,char*,uint)" -> "THD::enter_stage(const PSI_stage_info*,PSI_stage_info*,const char*,const char*,unsigned int)"
"dispatch_command(enum_server_command,THD*,char*,uint)" -> "my_eof(THD*)"
"dispatch_command(enum_server_command,THD*,char*,uint)" -> "THD::set_command(enum_server_command)"
"dispatch_command(enum_server_command,THD*,char*,uint)" -> "mysql_stmt_get_longdata(THD*,char*,ulong)"
"dispatch_command(enum_server_command,THD*,char*,uint)" -> "my_ok(THD*,ulonglong,ulonglong,const char*)"
"dispatch_command(enum_server_command,THD*,char*,uint)" -> "THD::get_user_connect()"
"dispatch_command(enum_server_command,THD*,char*,uint)" -> "THD::set_query_and_id(char*,uint32,const CHARSET_INFO*,query_id_t)"
"dispatch_command(enum_server_command,THD*,char*,uint)" -> "alloc_query(THD*,const char*,uint)"
"dispatch_command(enum_server_command,THD*,char*,uint)" -> "is_infoschema_db(const char*,size_t)"
"dispatch_command(enum_server_command,THD*,char*,uint)" -> "TABLE_LIST::init_one_table(const char*,size_t,const char*,size_t,const char*,thr_lock_type)"
"dispatch_command(enum_server_command,THD*,char*,uint)" -> "TraceTool::end_query()"
"dispatch_command(enum_server_command,THD*,char*,uint)" -> "THD::change_user()"
"dispatch_command(enum_server_command,THD*,char*,uint)" -> "Query_tables_list::add_to_query_tables(TABLE_LIST*)"
"dispatch_command(enum_server_command,THD*,char*,uint)" -> "mysqld_stmt_close(THD*,char*,uint)"
"dispatch_command(enum_server_command,THD*,char*,uint)" -> "PROFILING::start_new_query(const char*)"
"dispatch_command(enum_server_command,THD*,char*,uint)" -> "Diagnostics_area::is_error() const"
"dispatch_command(enum_server_command,THD*,char*,uint)" -> "sql_kill(THD*,ulong,bool)"
"dispatch_command(enum_server_command,THD*,char*,uint)" -> "THD::set_query_id(query_id_t)"
"dispatch_command(enum_server_command,THD*,char*,uint)" -> "my_error(int,myf,...)"
"dispatch_command(enum_server_command,THD*,char*,uint)" -> "SQL_I_List<T>::link_in_list(T*,T**) [with T = TABLE_LIST]"
"dispatch_command(enum_server_command,THD*,char*,uint)" -> "TraceTool::get_instance()"
"dispatch_command(enum_server_command,THD*,char*,uint)" -> "dec_thread_running()"
"dispatch_command(enum_server_command,THD*,char*,uint)" -> "Diagnostics_area::sql_errno() const"
"dispatch_command(enum_server_command,THD*,char*,uint)" -> "trans_rollback_implicit(THD*)"
"dispatch_command(enum_server_command,THD*,char*,uint)" -> "find_schema_table(THD*,const char*)"
"dispatch_command(enum_server_command,THD*,char*,uint)" -> "THD::cleanup_after_query()"
"dispatch_command(enum_server_command,THD*,char*,uint)" -> "THD::update_server_status()"
"dispatch_command(enum_server_command,THD*,char*,uint)" -> "strcmp(const char*,const char*)"
"dispatch_command(enum_server_command,THD*,char*,uint)" -> "TraceTool::start_new_query()"
"dispatch_command(enum_server_command,THD*,char*,uint)" -> "_current_thd()"
"dispatch_command(enum_server_command,THD*,char*,uint)" -> "Statement::query_length() const"
"dispatch_command(enum_server_command,THD*,char*,uint)" -> "TABLE_LIST::TABLE_LIST()"
"dispatch_command(enum_server_command,THD*,char*,uint)" -> "mysql_print_status()"
"dispatch_command(enum_server_command,THD*,char*,uint)" -> "mysql_audit_general(THD*,uint,int,const char*)"
"dispatch_command(enum_server_command,THD*,char*,uint)" -> "THD::is_valid_time()"
"dispatch_command(enum_server_command,THD*,char*,uint)" -> "my_free(void*)"
"dispatch_command(enum_server_command,THD*,char*,uint)" -> "PROFILING::finish_current_query()"
"dispatch_command(enum_server_command,THD*,char*,uint)" -> "mysqld_stmt_reset(THD*,char*,uint)"
"dispatch_command(enum_server_command,THD*,char*,uint)" -> "PROFILING::set_query_source(char*,uint)"
"dispatch_command(enum_server_command,THD*,char*,uint)" -> "THD::killed_errno() const"
"dispatch_command(enum_server_command,THD*,char*,uint)" -> "THD::reset_query()"
"dispatch_command(enum_server_command,THD*,char*,uint)" -> "__builtin_expect(long int,long int)"
"dispatch_command(enum_server_command,THD*,char*,uint)" -> "String::shrink(uint32)"
"dispatch_command(enum_server_command,THD*,char*,uint)" -> "MDL_context::mdl_savepoint()"
"dispatch_command(enum_server_command,THD*,char*,uint)" -> "Parser_state::Parser_state()"
"dispatch_command(enum_server_command,THD*,char*,uint)" -> "next_query_id()"
"dispatch_command(enum_server_command,THD*,char*,uint)" -> "check_table_access(THD*,ulong,TABLE_LIST*,bool,uint,bool)"
"dispatch_command(enum_server_command,THD*,char*,uint)" -> "my_snprintf(char*,size_t,const char*,...)"
"dispatch_command(enum_server_command,THD*,char*,uint)" -> "reload_acl_and_cache(THD*,long unsigned int,TABLE_LIST*,int*)"
"dispatch_command(enum_server_command,THD*,char*,uint)" -> "THD::set_query(char*,uint32)"
"dispatch_command(enum_server_command,THD*,char*,uint)" -> "mysqld_stmt_prepare(THD*,const char*,uint)"
"dispatch_command(enum_server_command,THD*,char*,uint)" -> "trans_commit_implicit(THD*)"
"dispatch_command(enum_server_command,THD*,char*,uint)" -> "mysql_parse(THD*,char*,uint,Parser_state*)"
"dispatch_command(enum_server_command,THD*,char*,uint)" -> "open_temporary_tables(THD*,TABLE_LIST*)"
"dispatch_command(enum_server_command,THD*,char*,uint)" -> "mysqld_stmt_fetch(THD*,char*,uint)"
"dispatch_command(enum_server_command,THD*,char*,uint)" -> "log_slow_statement(THD*)"
"dispatch_command(enum_server_command,THD*,char*,uint)" -> "mysql_change_db(THD*,const LEX_STRING*,bool)"
"dispatch_command(enum_server_command,THD*,char*,uint)" -> "THD::reset_db(char*,size_t)"
"dispatch_command(enum_server_command,THD*,char*,uint)" -> "Security_context::Security_context(const Security_context&)"
"dispatch_command(enum_server_command,THD*,char*,uint)" -> "inline_mysql_mutex_unlock(mysql_mutex_t*)"
"dispatch_command(enum_server_command,THD*,char*,uint)" -> "mysqld_stmt_execute(THD*,char*,uint)"
"dispatch_command(enum_server_command,THD*,char*,uint)" -> "Parser_state::init(THD*,char*,unsigned int)"
"dispatch_command(enum_server_command,THD*,char*,uint)" -> "general_log_write(THD*,enum_server_command,const char*,uint)"
"dispatch_command(enum_server_command,THD*,char*,uint)" -> "Diagnostics_area::disable_status()"
"dispatch_command(enum_server_command,THD*,char*,uint)" -> "strend(const char*)"
"dispatch_command(enum_server_command,THD*,char*,uint)" -> "Query_arena::memdup(const void*,size_t)"
"dispatch_command(enum_server_command,THD*,char*,uint)" -> "close_thread_tables(THD*)"
"dispatch_command(enum_server_command,THD*,char*,uint)" -> "Parser_state::reset(char*,unsigned int)"
"dispatch_command(enum_server_command,THD*,char*,uint)" -> "Security_context::operator=(const Security_context&)"
"dispatch_command(enum_server_command,THD*,char*,uint)" -> "my_message(uint,const char*,myf)"
"dispatch_command(enum_server_command,THD*,char*,uint)" -> "MDL_context::rollback_to_savepoint(const MDL_savepoint&)"
"dispatch_command(enum_server_command,THD*,char*,uint)" -> "Protocol::end_statement()"
"dispatch_command(enum_server_command,THD*,char*,uint)" -> "THD::copy_db_to(char**,size_t*)"
"dispatch_command(enum_server_command,THD*,char*,uint)" -> "mysqld_list_fields(THD*,TABLE_LIST*,const char*)"
"dispatch_command(enum_server_command,THD*,char*,uint)" -> "mysql_reset_thd_for_next_command(THD*)"
"dispatch_command(enum_server_command,THD*,char*,uint)" -> "THD::set_user_connect(USER_CONN*)"
"dispatch_command(enum_server_command,THD*,char*,uint)" -> "THD::convert_string(LEX_STRING*,const CHARSET_INFO*,const char*,uint,const CHARSET_INFO*)"
"dispatch_command(enum_server_command,THD*,char*,uint)" -> "acl_authenticate(THD*,uint)"
"dispatch_command(enum_server_command,THD*,char*,uint)" -> "THD::get_stmt_da()"
"dispatch_command(enum_server_command,THD*,char*,uint)" -> "free_root(MEM_ROOT*,myf)"
"dispatch_command(enum_server_command,THD*,char*,uint)" -> "MDL_context::release_transactional_locks()"
"dispatch_command(enum_server_command,THD*,char*,uint)" -> "get_thread_count()"
"dispatch_command(enum_server_command,THD*,char*,uint)" -> "general_log_print(THD*,enum_server_command,const char*,...)"
"dispatch_command(enum_server_command,THD*,char*,uint)" -> "mysqld_list_processes(THD*,const char*,bool)"
"dispatch_command(enum_server_command,THD*,char*,uint)" -> "Statement::query() const"
"dispatch_command(enum_server_command,THD*,char*,uint)" -> "THD::set_time()"
"dispatch_command(enum_server_command,THD*,char*,uint)" -> "inc_thread_running()"
"dispatch_command(enum_server_command,THD*,char*,uint)" -> "THD::clear_error()"
"dispatch_command(enum_server_command,THD*,char*,uint)" -> "THD::charset()"
"dispatch_command(enum_server_command,THD*,char*,uint)" -> "Query_cache::end_of_result(THD*)"
"dispatch_command(enum_server_command,THD*,char*,uint)" -> "check_table_name(const char*,size_t,bool)"
"dispatch_command(enum_server_command,THD*,char*,uint)" -> "THD::is_error() const"
"dispatch_command(enum_server_command,THD*,char*,uint)" -> "inline_mysql_mutex_lock(mysql_mutex_t*)"
"dispatch_command(enum_server_command,THD*,char*,uint)" -> "Opt_trace_start::Opt_trace_start(THD*,TABLE_LIST*,enum_sql_command,List<set_var_base>*,const char*,size_t,sp_printable*,const CHARSET_INFO*)"
"dispatch_command(enum_server_command,THD*,char*,uint)" -> "THD::send_kill_message() const"
"dispatch_command(enum_server_command,THD*,char*,uint)" -> "TraceTool::end_transaction()"
"dispatch_command(enum_server_command,THD*,char*,uint)" -> "check_global_access(THD*,ulong)"
"dispatch_command(enum_server_command,THD*,char*,uint)" -> "Table_cache_manager::cached_tables()"
"dispatch_command(enum_server_command,THD*,char*,uint)" -> "st_select_lex_unit::cleanup()"
"calc_sum_of_all_status(STATUS_VAR*)" -> "std::_Rb_tree_const_iterator<_Tp>::operator++() [with _Tp = THD*,std::_Rb_tree_const_iterator<_Tp>::_Self = std::_Rb_tree_const_iterator<THD*>]"
"calc_sum_of_all_status(STATUS_VAR*)" -> "std::_Rb_tree_const_iterator<_Tp>::operator!=(const _Self&) const [with _Tp = THD*,std::_Rb_tree_const_iterator<_Tp>::_Self = std::_Rb_tree_const_iterator<THD*>]"
"calc_sum_of_all_status(STATUS_VAR*)" -> "add_to_status(STATUS_VAR*,STATUS_VAR*)"
"calc_sum_of_all_status(STATUS_VAR*)" -> "global_thread_list_begin()"
"calc_sum_of_all_status(STATUS_VAR*)" -> "std::_Rb_tree_const_iterator<_Tp>::operator*() const [with _Tp = THD*,std::_Rb_tree_const_iterator<_Tp>::reference = THD* const&]"
"calc_sum_of_all_status(STATUS_VAR*)" -> "global_thread_list_end()"
"calc_sum_of_all_status(STATUS_VAR*)" -> "inline_mysql_mutex_lock(mysql_mutex_t*)"
"calc_sum_of_all_status(STATUS_VAR*)" -> "inline_mysql_mutex_unlock(mysql_mutex_t*)"
"std::_Rb_tree_const_iterator<_Tp>::operator++() [with _Tp = THD*,std::_Rb_tree_const_iterator<_Tp>::_Self = std::_Rb_tree_const_iterator<THD*>]" -> "std::_Rb_tree_increment(const std::_Rb_tree_node_base*)"
"global_thread_list_begin()" -> "_Alloc>::begin() const [with _Key = THD*,_Compare = std::less<THD*>,_Alloc = std::allocator<THD*>,std::set<_Key,_Compare,_Alloc>::iterator = std::_Rb_tree_const_iterator<THD*>]"
"_Alloc>::begin() const [with _Key = THD*,_Compare = std::less<THD*>,_Alloc = std::allocator<THD*>,std::set<_Key,_Compare,_Alloc>::iterator = std::_Rb_tree_const_iterator<THD*>]" -> "_Alloc>::begin() const [with _Key = THD*,_Val = THD*,_KeyOfValue = std::_Identity<THD*>,_Compare = std::less<THD*>,_Alloc = std::allocator<THD*>,std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::const_iterator = std::_Rb_tree_const_iterator<THD*>]"
"_Alloc>::begin() const [with _Key = THD*,_Val = THD*,_KeyOfValue = std::_Identity<THD*>,_Compare = std::less<THD*>,_Alloc = std::allocator<THD*>,std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::const_iterator = std::_Rb_tree_const_iterator<THD*>]" -> "std::_Rb_tree_const_iterator<_Tp>::_Rb_tree_const_iterator(std::_Rb_tree_const_iterator<_Tp>::_Link_type) [with _Tp = THD*,std::_Rb_tree_const_iterator<_Tp>::_Link_type = const std::_Rb_tree_node<THD*>*]"
"global_thread_list_end()" -> "_Alloc>::end() const [with _Key = THD*,_Compare = std::less<THD*>,_Alloc = std::allocator<THD*>,std::set<_Key,_Compare,_Alloc>::iterator = std::_Rb_tree_const_iterator<THD*>]"
"_Alloc>::end() const [with _Key = THD*,_Compare = std::less<THD*>,_Alloc = std::allocator<THD*>,std::set<_Key,_Compare,_Alloc>::iterator = std::_Rb_tree_const_iterator<THD*>]" -> "_Alloc>::end() const [with _Key = THD*,_Val = THD*,_KeyOfValue = std::_Identity<THD*>,_Compare = std::less<THD*>,_Alloc = std::allocator<THD*>,std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::const_iterator = std::_Rb_tree_const_iterator<THD*>]"
"_Alloc>::end() const [with _Key = THD*,_Val = THD*,_KeyOfValue = std::_Identity<THD*>,_Compare = std::less<THD*>,_Alloc = std::allocator<THD*>,std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::const_iterator = std::_Rb_tree_const_iterator<THD*>]" -> "std::_Rb_tree_const_iterator<_Tp>::_Rb_tree_const_iterator(std::_Rb_tree_const_iterator<_Tp>::_Link_type) [with _Tp = THD*,std::_Rb_tree_const_iterator<_Tp>::_Link_type = const std::_Rb_tree_node<THD*>*]"
"inline_mysql_mutex_lock(mysql_mutex_t*)" -> "pthread_mutex_lock(pthread_mutex_t*)"
"inline_mysql_mutex_unlock(mysql_mutex_t*)" -> "pthread_mutex_unlock(pthread_mutex_t*)"
"lex_start(THD*)" -> "st_parsing_options::reset()"
"lex_start(THD*)" -> "LEX::mark_broken(bool)"
"lex_start(THD*)" -> "has_trivial_destructor>::clear() [with Element_type = st_order*,bool has_trivial_destructor = true]"
"lex_start(THD*)" -> "Query_tables_list::reset_query_tables_list(bool)"
"lex_start(THD*)" -> "st_select_lex_node::init_select()"
"lex_start(THD*)" -> "st_select_lex_unit::init_query()"
"lex_start(THD*)" -> "base_list::empty()"
"lex_start(THD*)" -> "SQL_I_List<T>::empty() [with T = TABLE_LIST]"
"lex_start(THD*)" -> "st_select_lex::init_order()"
"lex_start(THD*)" -> "SQL_I_List<T>::empty() [with T = st_order]"
"lex_start(THD*)" -> "LEX::set_sp_current_parsing_ctx(sp_pcontext*)"
"lex_start(THD*)" -> "st_select_lex::init_query()"
"LEX::mark_broken(bool)" -> "LEX::is_metadata_used() const"
"has_trivial_destructor>::clear() [with Element_type = st_order*,bool has_trivial_destructor = true]" -> "has_trivial_destructor>::empty() const [with Element_type = st_order*,bool has_trivial_destructor = true]"
"has_trivial_destructor>::clear() [with Element_type = st_order*,bool has_trivial_destructor = true]" -> "has_trivial_destructor>::chop(size_t) [with Element_type = st_order*,bool has_trivial_destructor = true,size_t = long unsigned int]"
"has_trivial_destructor>::empty() const [with Element_type = st_order*,bool has_trivial_destructor = true]" -> "has_trivial_destructor>::size() const [with Element_type = st_order*,bool has_trivial_destructor = true,size_t = long unsigned int]"
"Query_tables_list::reset_query_tables_list(bool)" -> "memset(void*,int,size_t)"
"Query_tables_list::reset_query_tables_list(bool)" -> "my_hash_reset(HASH*)"
"Query_tables_list::reset_query_tables_list(bool)" -> "SQL_I_List<T>::empty() [with T = Sroutine_hash_entry]"
"st_select_lex_unit::init_query()" -> "st_select_lex_unit::first_select()"
"st_select_lex_unit::init_query()" -> "base_list::empty()"
"st_select_lex_unit::init_query()" -> "st_select_lex_node::init_query()"
"st_select_lex::init_query()" -> "SQL_I_List<T>::empty() [with T = TABLE_LIST]"
"st_select_lex::init_query()" -> "Bounds_checked_array<Element_type>::reset() [with Element_type = Item*]"
"st_select_lex::init_query()" -> "Name_resolution_context::init()"
"st_select_lex::init_query()" -> "base_list::empty()"
"st_select_lex::init_query()" -> "st_select_lex_node::init_query()"
"st_select_lex::init_query()" -> "LEX::push_context(Name_resolution_context*)"
"LEX::push_context(Name_resolution_context*)" -> "List<T>::push_front(T*) [with T = Name_resolution_context]"
"List<T>::push_front(T*) [with T = Name_resolution_context]" -> "base_list::push_front(void*)"
"base_list::push_front(void*)" -> "list_node::list_node(void*,list_node*)"
"list_node::list_node(void*,list_node*)" -> "Sql_alloc::Sql_alloc()"
"THD::enter_stage(const PSI_stage_info*,PSI_stage_info*,const char*,const char*,unsigned int)" -> "PROFILING::status_change(const char*,const char*,const char*,unsigned int)"
"PROFILING::status_change(const char*,const char*,const char*,unsigned int)" -> "QUERY_PROFILE::new_status(const char*,const char*,const char*,unsigned int)"
"PROFILING::status_change(const char*,const char*,const char*,unsigned int)" -> "__builtin_expect(long int,long int)"
"QUERY_PROFILE::new_status(const char*,const char*,const char*,unsigned int)" -> "Queue<T>::pop() [with T = PROF_MEASUREMENT]"
"QUERY_PROFILE::new_status(const char*,const char*,const char*,unsigned int)" -> "dirname_length(const char*)"
"QUERY_PROFILE::new_status(const char*,const char*,const char*,unsigned int)" -> "PROF_MEASUREMENT::PROF_MEASUREMENT(QUERY_PROFILE*,const char*,const char*,const char*,unsigned int)"
"QUERY_PROFILE::new_status(const char*,const char*,const char*,unsigned int)" -> "Queue<T>::push_back(T*) [with T = PROF_MEASUREMENT]"
"QUERY_PROFILE::new_status(const char*,const char*,const char*,unsigned int)" -> "PROF_MEASUREMENT::PROF_MEASUREMENT(QUERY_PROFILE*,const char*)"
"Queue<T>::pop() [with T = PROF_MEASUREMENT]" -> "my_free(void*)"
"PROF_MEASUREMENT::PROF_MEASUREMENT(QUERY_PROFILE*,const char*,const char*,const char*,unsigned int)" -> "PROF_MEASUREMENT::collect()"
"PROF_MEASUREMENT::PROF_MEASUREMENT(QUERY_PROFILE*,const char*,const char*,const char*,unsigned int)" -> "PROF_MEASUREMENT::set_label(const char*,const char*,const char*,unsigned int)"
"PROF_MEASUREMENT::collect()" -> "getrusage(__rusage_who_t,rusage*)"
"PROF_MEASUREMENT::collect()" -> "my_getsystime()"
"PROF_MEASUREMENT::set_label(const char*,const char*,const char*,unsigned int)" -> "strcpy(char*,const char*)"
"PROF_MEASUREMENT::set_label(const char*,const char*,const char*,unsigned int)" -> "my_malloc(size_t,myf)"
"PROF_MEASUREMENT::set_label(const char*,const char*,const char*,unsigned int)" -> "strlen(const char*)"
"Queue<T>::push_back(T*) [with T = PROF_MEASUREMENT]" -> "my_malloc(size_t,myf)"
"PROF_MEASUREMENT::PROF_MEASUREMENT(QUERY_PROFILE*,const char*)" -> "PROF_MEASUREMENT::set_label(const char*,const char*,const char*,unsigned int)"
"PROF_MEASUREMENT::PROF_MEASUREMENT(QUERY_PROFILE*,const char*)" -> "PROF_MEASUREMENT::collect()"
"my_eof(THD*)" -> "THD::set_row_count_func(longlong)"
"my_eof(THD*)" -> "THD::get_stmt_da()"
"my_eof(THD*)" -> "Diagnostics_area::set_eof_status(THD*)"
"Diagnostics_area::set_eof_status(THD*)" -> "Diagnostics_area::is_disabled() const"
"Diagnostics_area::set_eof_status(THD*)" -> "Diagnostics_area::current_statement_warn_count() const"
"Diagnostics_area::set_eof_status(THD*)" -> "Diagnostics_area::is_error() const"
"Diagnostics_area::current_statement_warn_count() const" -> "Diagnostics_area::get_warning_info() const"
"Diagnostics_area::current_statement_warn_count() const" -> "Warning_info::current_statement_warn_count() const"
"Diagnostics_area::get_warning_info() const" -> "I>::front() const [with T = Warning_info,B = I_P_List_adapter<Warning_info,&Warning_info::m_next_in_da,&Warning_info::m_prev_in_da>,C = I_P_List_counter,I = I_P_List_fast_push_back<Warning_info>]"
"mysql_stmt_get_longdata(THD*,char*,ulong)" -> "Diagnostics_area::sql_errno() const"
"mysql_stmt_get_longdata(THD*,char*,ulong)" -> "THD::get_stmt_da()"
"mysql_stmt_get_longdata(THD*,char*,ulong)" -> "Diagnostics_area::Diagnostics_area(ulonglong,bool)"
"mysql_stmt_get_longdata(THD*,char*,ulong)" -> "THD::set_stmt_da(Diagnostics_area*)"
"mysql_stmt_get_longdata(THD*,char*,ulong)" -> "THD::get_command() const"
"mysql_stmt_get_longdata(THD*,char*,ulong)" -> "Diagnostics_area::message() const"
"mysql_stmt_get_longdata(THD*,char*,ulong)" -> "Diagnostics_area::disable_status()"
"mysql_stmt_get_longdata(THD*,char*,ulong)" -> "find_prepared_statement(THD*,ulong)"
"mysql_stmt_get_longdata(THD*,char*,ulong)" -> "general_log_print(THD*,enum_server_command,const char*,...)"
"mysql_stmt_get_longdata(THD*,char*,ulong)" -> "strncpy(char*,const char*,size_t)"
"mysql_stmt_get_longdata(THD*,char*,ulong)" -> "Item_param::set_longdata(const char*,ulong)"
"mysql_stmt_get_longdata(THD*,char*,ulong)" -> "Diagnostics_area::is_error() const"
"Diagnostics_area::Diagnostics_area(ulonglong,bool)" -> "Warning_info::Warning_info(ulonglong,bool)"
"Diagnostics_area::Diagnostics_area(ulonglong,bool)" -> "Diagnostics_area::push_warning_info(Warning_info*)"
"Diagnostics_area::Diagnostics_area(ulonglong,bool)" -> "Diagnostics_area::reset_diagnostics_area()"
"Diagnostics_area::Diagnostics_area(ulonglong,bool)" -> "I>::I_P_List() [with T = Warning_info,B = I_P_List_adapter<Warning_info,&Warning_info::m_next_in_da,&Warning_info::m_prev_in_da>,C = I_P_List_counter,I = I_P_List_fast_push_back<Warning_info>]"
"Warning_info::Warning_info(ulonglong,bool)" -> "I>::I_P_List() [with T = Sql_condition,B = I_P_List_adapter<Sql_condition,&Sql_condition::next_in_wi,&Sql_condition::prev_in_wi>,C = I_P_List_counter,I = I_P_List_fast_push_back<Sql_condition>]"
"Warning_info::Warning_info(ulonglong,bool)" -> "init_sql_alloc(MEM_ROOT*,uint,uint)"
"Warning_info::Warning_info(ulonglong,bool)" -> "List<T>::List() [with T = Sql_condition]"
"Warning_info::Warning_info(ulonglong,bool)" -> "memset(void*,int,size_t)"
"Warning_info::Warning_info(ulonglong,bool)" -> "I>::empty() [with T = Sql_condition,B = I_P_List_adapter<Sql_condition,&Sql_condition::next_in_wi,&Sql_condition::prev_in_wi>,C = I_P_List_counter,I = I_P_List_fast_push_back<Sql_condition>]"
"I>::I_P_List() [with T = Sql_condition,B = I_P_List_adapter<Sql_condition,&Sql_condition::next_in_wi,&Sql_condition::prev_in_wi>,C = I_P_List_counter,I = I_P_List_fast_push_back<Sql_condition>]" -> "I_P_List_counter::I_P_List_counter()"
"I>::I_P_List() [with T = Sql_condition,B = I_P_List_adapter<Sql_condition,&Sql_condition::next_in_wi,&Sql_condition::prev_in_wi>,C = I_P_List_counter,I = I_P_List_fast_push_back<Sql_condition>]" -> "I_P_List_fast_push_back<T>::I_P_List_fast_push_back(T**) [with T = Sql_condition]"
"init_sql_alloc(MEM_ROOT*,uint,uint)" -> "init_alloc_root(MEM_ROOT*,size_t,size_t)"
"List<T>::List() [with T = Sql_condition]" -> "base_list::base_list()"
"base_list::base_list()" -> "Sql_alloc::Sql_alloc()"
"base_list::base_list()" -> "base_list::empty()"
"I>::empty() [with T = Sql_condition,B = I_P_List_adapter<Sql_condition,&Sql_condition::next_in_wi,&Sql_condition::prev_in_wi>,C = I_P_List_counter,I = I_P_List_fast_push_back<Sql_condition>]" -> "I_P_List_counter::reset()"
"I>::empty() [with T = Sql_condition,B = I_P_List_adapter<Sql_condition,&Sql_condition::next_in_wi,&Sql_condition::prev_in_wi>,C = I_P_List_counter,I = I_P_List_fast_push_back<Sql_condition>]" -> "I_P_List_fast_push_back<T>::set_last(T**) [with T = Sql_condition]"
"Diagnostics_area::push_warning_info(Warning_info*)" -> "I>::push_front(T*) [with T = Warning_info,B = I_P_List_adapter<Warning_info,&Warning_info::m_next_in_da,&Warning_info::m_prev_in_da>,C = I_P_List_counter,I = I_P_List_fast_push_back<Warning_info>]"
"I>::push_front(T*) [with T = Warning_info,B = I_P_List_adapter<Warning_info,&Warning_info::m_next_in_da,&Warning_info::m_prev_in_da>,C = I_P_List_counter,I = I_P_List_fast_push_back<Warning_info>]" -> "I_P_List_fast_push_back<T>::set_last(T**) [with T = Warning_info]"
"I>::push_front(T*) [with T = Warning_info,B = I_P_List_adapter<Warning_info,&Warning_info::m_next_in_da,&Warning_info::m_prev_in_da>,C = I_P_List_counter,I = I_P_List_fast_push_back<Warning_info>]" -> "prev>::next_ptr(T*) [with T = Warning_info,T* T::* next = &Warning_info::m_next_in_da,T** T::* prev = &Warning_info::m_prev_in_da]"
"I>::push_front(T*) [with T = Warning_info,B = I_P_List_adapter<Warning_info,&Warning_info::m_next_in_da,&Warning_info::m_prev_in_da>,C = I_P_List_counter,I = I_P_List_fast_push_back<Warning_info>]" -> "I_P_List_counter::inc()"
"I>::push_front(T*) [with T = Warning_info,B = I_P_List_adapter<Warning_info,&Warning_info::m_next_in_da,&Warning_info::m_prev_in_da>,C = I_P_List_counter,I = I_P_List_fast_push_back<Warning_info>]" -> "prev>::prev_ptr(T*) [with T = Warning_info,T* T::* next = &Warning_info::m_next_in_da,T** T::* prev = &Warning_info::m_prev_in_da]"
"Diagnostics_area::reset_diagnostics_area()" -> "Warning_info::clear_error_condition()"
"Diagnostics_area::reset_diagnostics_area()" -> "Diagnostics_area::get_warning_info()"
"Diagnostics_area::reset_diagnostics_area()" -> "Diagnostics_area::set_is_sent(bool)"
"Diagnostics_area::reset_diagnostics_area()" -> "Diagnostics_area::set_overwrite_status(bool)"
"Diagnostics_area::get_warning_info()" -> "I>::front() [with T = Warning_info,B = I_P_List_adapter<Warning_info,&Warning_info::m_next_in_da,&Warning_info::m_prev_in_da>,C = I_P_List_counter,I = I_P_List_fast_push_back<Warning_info>]"
"I>::I_P_List() [with T = Warning_info,B = I_P_List_adapter<Warning_info,&Warning_info::m_next_in_da,&Warning_info::m_prev_in_da>,C = I_P_List_counter,I = I_P_List_fast_push_back<Warning_info>]" -> "I_P_List_fast_push_back<T>::I_P_List_fast_push_back(T**) [with T = Warning_info]"
"I>::I_P_List() [with T = Warning_info,B = I_P_List_adapter<Warning_info,&Warning_info::m_next_in_da,&Warning_info::m_prev_in_da>,C = I_P_List_counter,I = I_P_List_fast_push_back<Warning_info>]" -> "I_P_List_counter::I_P_List_counter()"
"find_prepared_statement(THD*,ulong)" -> "Statement_map::find(ulong)"
"Statement_map::find(ulong)" -> "my_hash_search(const HASH*,const uchar*,size_t)"
"general_log_print(THD*,enum_server_command,const char*,...)" -> "LOGGER::general_log_print(THD*,enum_server_command,const char*,__va_list_tag*)"
"general_log_print(THD*,enum_server_command,const char*,...)" -> "LOGGER::log_command(THD*,enum_server_command)"
"general_log_print(THD*,enum_server_command,const char*,...)" -> "__builtin_va_end(__va_list_tag*)"
"general_log_print(THD*,enum_server_command,const char*,...)" -> "__builtin_va_start(__va_list_tag*,...)"
"LOGGER::general_log_print(THD*,enum_server_command,const char*,__va_list_tag*)" -> "my_vsnprintf(char*,size_t,const char*,__va_list_tag*)"
"LOGGER::general_log_print(THD*,enum_server_command,const char*,__va_list_tag*)" -> "LOGGER::general_log_write(THD*,enum_server_command,const char*,uint)"
"LOGGER::general_log_write(THD*,enum_server_command,const char*,uint)" -> "mysql_audit_general_log(THD*,time_t,const char*,uint,const char*,uint,const char*,uint)"
"LOGGER::general_log_write(THD*,enum_server_command,const char*,uint)" -> "LOGGER::unlock()"
"LOGGER::general_log_write(THD*,enum_server_command,const char*,uint)" -> "my_time(myf)"
"LOGGER::general_log_write(THD*,enum_server_command,const char*,uint)" -> "make_user_name(THD*,char*)"
"LOGGER::general_log_write(THD*,enum_server_command,const char*,uint)" -> "LOGGER::lock_shared()"
"LOGGER::unlock()" -> "inline_mysql_rwlock_unlock(mysql_rwlock_t*)"
"inline_mysql_rwlock_unlock(mysql_rwlock_t*)" -> "pthread_rwlock_unlock(pthread_rwlock_t*)"
"make_user_name(THD*,char*)" -> "String::ptr() const"
"make_user_name(THD*,char*)" -> "strxnmov(char*,size_t,const char*,...)"
"make_user_name(THD*,char*)" -> "Security_context::get_host()"
"make_user_name(THD*,char*)" -> "String::length() const"
"make_user_name(THD*,char*)" -> "Security_context::get_ip()"
"LOGGER::lock_shared()" -> "inline_mysql_rwlock_rdlock(mysql_rwlock_t*)"
"inline_mysql_rwlock_rdlock(mysql_rwlock_t*)" -> "pthread_rwlock_rdlock(pthread_rwlock_t*)"
"Item_param::set_longdata(const char*,ulong)" -> "String::length() const"
"Item_param::set_longdata(const char*,ulong)" -> "_current_thd()"
"Item_param::set_longdata(const char*,ulong)" -> "my_message(uint,const char*,myf)"
"Item_param::set_longdata(const char*,ulong)" -> "String::append(const char*,uint32,const CHARSET_INFO*)"
"_current_thd()" -> "pthread_getspecific(pthread_key_t)"
"String::append(const char*,uint32,const CHARSET_INFO*)" -> "String::realloc(uint32)"
"String::append(const char*,uint32,const CHARSET_INFO*)" -> "copy_and_convert(char*,uint32,const CHARSET_INFO*,const char*,uint32,const CHARSET_INFO*,uint*)"
"String::append(const char*,uint32,const CHARSET_INFO*)" -> "String::needs_conversion(uint32,const CHARSET_INFO*,const CHARSET_INFO*,uint32*)"
"String::append(const char*,uint32,const CHARSET_INFO*)" -> "memcpy(void*,const void*,size_t)"
"String::append(const char*,uint32,const CHARSET_INFO*)" -> "memset(void*,int,size_t)"
"String::realloc(uint32)" -> "my_realloc(void*,size_t,myf)"
"String::realloc(uint32)" -> "my_malloc(size_t,myf)"
"String::realloc(uint32)" -> "memcpy(void*,const void*,size_t)"
"copy_and_convert(char*,uint32,const CHARSET_INFO*,const char*,uint32,const CHARSET_INFO*,uint*)" -> "my_convert(char*,uint32,const CHARSET_INFO*,const char*,uint32,const CHARSET_INFO*,uint*)"
"String::needs_conversion(uint32,const CHARSET_INFO*,const CHARSET_INFO*,uint32*)" -> "my_charset_same(const CHARSET_INFO*,const CHARSET_INFO*)"
"my_ok(THD*,ulonglong,ulonglong,const char*)" -> "THD::get_stmt_da()"
"my_ok(THD*,ulonglong,ulonglong,const char*)" -> "THD::set_row_count_func(longlong)"
"my_ok(THD*,ulonglong,ulonglong,const char*)" -> "Diagnostics_area::set_ok_status(ulonglong,ulonglong,const char*)"
"Diagnostics_area::set_ok_status(ulonglong,ulonglong,const char*)" -> "Diagnostics_area::is_error() const"
"Diagnostics_area::set_ok_status(ulonglong,ulonglong,const char*)" -> "strmake(char*,const char*,size_t)"
"Diagnostics_area::set_ok_status(ulonglong,ulonglong,const char*)" -> "Diagnostics_area::is_disabled() const"
"Diagnostics_area::set_ok_status(ulonglong,ulonglong,const char*)" -> "Diagnostics_area::current_statement_warn_count() const"
"THD::set_query_and_id(char*,uint32,const CHARSET_INFO*,query_id_t)" -> "inline_mysql_mutex_unlock(mysql_mutex_t*)"
"THD::set_query_and_id(char*,uint32,const CHARSET_INFO*,query_id_t)" -> "Statement::set_query_inner(char*,uint32,const CHARSET_INFO*)"
"THD::set_query_and_id(char*,uint32,const CHARSET_INFO*,query_id_t)" -> "inline_mysql_mutex_lock(mysql_mutex_t*)"
"Statement::set_query_inner(char*,uint32,const CHARSET_INFO*)" -> "CSET_STRING::CSET_STRING(char*,size_t,const CHARSET_INFO*)"
"Statement::set_query_inner(char*,uint32,const CHARSET_INFO*)" -> "Statement::set_query_inner(const CSET_STRING&)"
"alloc_query(THD*,const char*,uint)" -> "Query_arena::memdup_w_gap(const void*,size_t,uint)"
"alloc_query(THD*,const char*,uint)" -> "String::shrink(uint32)"
"alloc_query(THD*,const char*,uint)" -> "THD::set_query(char*,uint32)"
"alloc_query(THD*,const char*,uint)" -> "THD::charset()"
"alloc_query(THD*,const char*,uint)" -> "memcpy(void*,const void*,size_t)"
"alloc_query(THD*,const char*,uint)" -> "String::free()"
"Query_arena::memdup_w_gap(const void*,size_t,uint)" -> "alloc_root(MEM_ROOT*,size_t)"
"Query_arena::memdup_w_gap(const void*,size_t,uint)" -> "memcpy(void*,const void*,size_t)"
"String::shrink(uint32)" -> "my_realloc(void*,size_t,myf)"
"String::shrink(uint32)" -> "String::real_alloc(uint32)"
"String::shrink(uint32)" -> "String::is_alloced() const"
"String::real_alloc(uint32)" -> "my_malloc(size_t,myf)"
"String::real_alloc(uint32)" -> "String::free()"
"String::free()" -> "my_free(void*)"
"THD::set_query(char*,uint32)" -> "THD::charset()"
"THD::set_query(char*,uint32)" -> "THD::set_query(const CSET_STRING&)"
"THD::set_query(char*,uint32)" -> "CSET_STRING::CSET_STRING(char*,size_t,const CHARSET_INFO*)"
"THD::set_query(const CSET_STRING&)" -> "Statement::query() const"
"THD::set_query(const CSET_STRING&)" -> "Statement::query_length() const"
"THD::set_query(const CSET_STRING&)" -> "inline_mysql_mutex_lock(mysql_mutex_t*)"
"THD::set_query(const CSET_STRING&)" -> "Statement::set_query_inner(const CSET_STRING&)"
"THD::set_query(const CSET_STRING&)" -> "inline_mysql_mutex_unlock(mysql_mutex_t*)"
"Statement::query() const" -> "CSET_STRING::str() const"
"Statement::query_length() const" -> "CSET_STRING::length() const"
"TABLE_LIST::init_one_table(const char*,size_t,const char*,size_t,const char*,thr_lock_type)" -> "MDL_request::init(MDL_key::enum_mdl_namespace,const char*,const char*,enum_mdl_type,enum_mdl_duration)"
"TABLE_LIST::init_one_table(const char*,size_t,const char*,size_t,const char*,thr_lock_type)" -> "memset(void*,int,size_t)"
"MDL_request::init(MDL_key::enum_mdl_namespace,const char*,const char*,enum_mdl_type,enum_mdl_duration)" -> "MDL_key::mdl_key_init(MDL_key::enum_mdl_namespace,const char*,const char*)"
"MDL_key::mdl_key_init(MDL_key::enum_mdl_namespace,const char*,const char*)" -> "strmake(char*,const char*,size_t)"
"TraceTool::end_query()" -> "_Alloc>::operator[](std::vector<_Tp,_Alloc>::size_type) [with _Tp = long int,_Alloc = std::allocator<long int>,std::vector<_Tp,_Alloc>::reference = long int&,std::vector<_Tp,_Alloc>::size_type = long unsigned int]"
"TraceTool::end_query()" -> "TraceTool::get_time()"
"TraceTool::end_query()" -> "TraceTool::difftime(timespec,timespec)"
"TraceTool::end_query()" -> "_Alloc>::size() const [with _Tp = long int,_Alloc = std::allocator<long int>,std::vector<_Tp,_Alloc>::size_type = long unsigned int]"
"TraceTool::end_query()" -> "_Alloc>::back() [with _Tp = std::vector<long int>,_Alloc = std::allocator<std::vector<long int> >,std::vector<_Tp,_Alloc>::reference = std::vector<long int>&]"
"TraceTool::get_time()" -> "clock_gettime(clockid_t,timespec*)"
"_Alloc>::back() [with _Tp = std::vector<long int>,_Alloc = std::allocator<std::vector<long int> >,std::vector<_Tp,_Alloc>::reference = std::vector<long int>&]" -> "_Container>::operator-(const difference_type&) const [with _Iterator = std::vector<long int>*,_Container = std::vector<std::vector<long int> >,__gnu_cxx::__normal_iterator<_Iterator,_Container> = __gnu_cxx::__normal_iterator<std::vector<long int>*,std::vector<std::vector<long int> > >,__gnu_cxx::__normal_iterator<_Iterator,_Container>::difference_type = long int]"
"_Alloc>::back() [with _Tp = std::vector<long int>,_Alloc = std::allocator<std::vector<long int> >,std::vector<_Tp,_Alloc>::reference = std::vector<long int>&]" -> "_Container>::operator*() const [with _Iterator = std::vector<long int>*,_Container = std::vector<std::vector<long int> >,__gnu_cxx::__normal_iterator<_Iterator,_Container>::reference = std::vector<long int>&]"
"_Alloc>::back() [with _Tp = std::vector<long int>,_Alloc = std::allocator<std::vector<long int> >,std::vector<_Tp,_Alloc>::reference = std::vector<long int>&]" -> "_Alloc>::end() [with _Tp = std::vector<long int>,_Alloc = std::allocator<std::vector<long int> >,std::vector<_Tp,_Alloc>::iterator = __gnu_cxx::__normal_iterator<std::vector<long int>*,std::vector<std::vector<long int> > >,typename std::_Vector_base<_Tp,_Alloc>::_Tp_alloc_type::pointer = std::vector<long int>*]"
"_Container>::operator-(const difference_type&) const [with _Iterator = std::vector<long int>*,_Container = std::vector<std::vector<long int> >,__gnu_cxx::__normal_iterator<_Iterator,_Container> = __gnu_cxx::__normal_iterator<std::vector<long int>*,std::vector<std::vector<long int> > >,__gnu_cxx::__normal_iterator<_Iterator,_Container>::difference_type = long int]" -> "_Container>::__normal_iterator(const _Iterator&) [with _Iterator = std::vector<long int>*,_Container = std::vector<std::vector<long int> >]"
"_Alloc>::end() [with _Tp = std::vector<long int>,_Alloc = std::allocator<std::vector<long int> >,std::vector<_Tp,_Alloc>::iterator = __gnu_cxx::__normal_iterator<std::vector<long int>*,std::vector<std::vector<long int> > >,typename std::_Vector_base<_Tp,_Alloc>::_Tp_alloc_type::pointer = std::vector<long int>*]" -> "_Container>::__normal_iterator(const _Iterator&) [with _Iterator = std::vector<long int>*,_Container = std::vector<std::vector<long int> >]"
"THD::change_user()" -> "THD::init()"
"THD::change_user()" -> "inline_mysql_mutex_unlock(mysql_mutex_t*)"
"THD::change_user()" -> "_my_hash_init(HASH*,uint,CHARSET_INFO*,my_hash_function,ulong,size_t,size_t,my_hash_get_key,void (*)(void*),uint)"
"THD::change_user()" -> "sp_cache_clear(sp_cache**)"
"THD::change_user()" -> "inline_mysql_mutex_lock(mysql_mutex_t*)"
"THD::change_user()" -> "THD::cleanup()"
"THD::change_user()" -> "Statement_map::reset()"
"THD::change_user()" -> "add_to_status(STATUS_VAR*,STATUS_VAR*)"
"THD::init()" -> "THD::reset_current_stmt_binlog_format_row()"
"THD::init()" -> "inline_mysql_mutex_unlock(mysql_mutex_t*)"
"THD::init()" -> "THD_TRANS::reset_unsafe_rollback_flags()"
"THD::init()" -> "THD::reset_binlog_local_stmt_filter()"
"THD::init()" -> "memset(void*,int,size_t)"
"THD::init()" -> "plugin_thdvar_init(THD*,bool)"
"THD::init()" -> "inline_mysql_mutex_lock(mysql_mutex_t*)"
"THD::init()" -> "THD::update_charset()"
"THD::reset_current_stmt_binlog_format_row()" -> "THD::clear_current_stmt_binlog_format_row()"
"THD::reset_current_stmt_binlog_format_row()" -> "THD::set_current_stmt_binlog_format_row()"
"plugin_thdvar_init(THD*,bool)" -> "cleanup_variables(THD*,system_variables*)"
"plugin_thdvar_init(THD*,bool)" -> "inline_mysql_mutex_lock(mysql_mutex_t*)"
"plugin_thdvar_init(THD*,bool)" -> "intern_plugin_lock(LEX*,plugin_ref)"
"plugin_thdvar_init(THD*,bool)" -> "inline_mysql_mutex_unlock(mysql_mutex_t*)"
"plugin_thdvar_init(THD*,bool)" -> "intern_plugin_unlock(LEX*,plugin_ref)"
"cleanup_variables(THD*,system_variables*)" -> "my_free(void*)"
"cleanup_variables(THD*,system_variables*)" -> "plugin_var_memalloc_free(system_variables*)"
"plugin_var_memalloc_free(system_variables*)" -> "my_free(void*)"
"intern_plugin_lock(LEX*,plugin_ref)" -> "insert_dynamic(DYNAMIC_ARRAY*,const void*)"
"intern_plugin_unlock(LEX*,plugin_ref)" -> "delete_dynamic_element(DYNAMIC_ARRAY*,uint)"
"THD::update_charset()" -> "String::needs_conversion(uint32,const CHARSET_INFO*,const CHARSET_INFO*,uint32*)"
"THD::cleanup()" -> "item_user_lock_release(User_level_lock*)"
"THD::cleanup()" -> "my_hash_free(HASH*)"
"THD::cleanup()" -> "sp_cache_clear(sp_cache**)"
"THD::cleanup()" -> "Global_read_lock::unlock_global_read_lock(THD*)"
"THD::cleanup()" -> "trans_rollback(THD*)"
"THD::cleanup()" -> "mysql_ha_cleanup(THD*)"
"THD::cleanup()" -> "inline_mysql_mutex_unlock(mysql_mutex_t*)"
"THD::cleanup()" -> "MDL_context::release_transactional_locks()"
"THD::cleanup()" -> "Global_read_lock::is_acquired() const"
"THD::cleanup()" -> "Locked_tables_list::unlock_locked_tables(THD*)"
"THD::cleanup()" -> "close_temporary_tables(THD*)"
"THD::cleanup()" -> "inline_mysql_mutex_lock(mysql_mutex_t*)"
"THD::cleanup()" -> "delete_dynamic(DYNAMIC_ARRAY*)"
"THD::cleanup()" -> "xid_cache_delete(XID_STATE*)"
"item_user_lock_release(User_level_lock*)" -> "inline_mysql_cond_signal(mysql_cond_t*)"
"inline_mysql_cond_signal(mysql_cond_t*)" -> "pthread_cond_signal(pthread_cond_t*)"
"Global_read_lock::unlock_global_read_lock(THD*)" -> "MDL_context::release_lock(MDL_ticket*)"
"MDL_context::release_lock(MDL_ticket*)" -> "MDL_context::release_lock(enum_mdl_duration,MDL_ticket*)"
"MDL_context::release_lock(enum_mdl_duration,MDL_ticket*)" -> "MDL_ticket::destroy(MDL_ticket*)"
"MDL_context::release_lock(enum_mdl_duration,MDL_ticket*)" -> "I>::remove(T*) [with T = MDL_ticket,B = I_P_List_adapter<MDL_ticket,&MDL_ticket::next_in_context,&MDL_ticket::prev_in_context>,C = I_P_List_null_counter,I = I_P_List_no_push_back<MDL_ticket>]"
"MDL_context::release_lock(enum_mdl_duration,MDL_ticket*)" -> "MDL_lock::remove_ticket(MDL_lock::Ticket_list MDL_lock::*,MDL_ticket*)"
"I>::remove(T*) [with T = MDL_ticket,B = I_P_List_adapter<MDL_ticket,&MDL_ticket::next_in_context,&MDL_ticket::prev_in_context>,C = I_P_List_null_counter,I = I_P_List_no_push_back<MDL_ticket>]" -> "prev>::prev_ptr(T*) [with T = MDL_ticket,T* T::* next = &MDL_ticket::next_in_context,T** T::* prev = &MDL_ticket::prev_in_context]"
"I>::remove(T*) [with T = MDL_ticket,B = I_P_List_adapter<MDL_ticket,&MDL_ticket::next_in_context,&MDL_ticket::prev_in_context>,C = I_P_List_null_counter,I = I_P_List_no_push_back<MDL_ticket>]" -> "I_P_List_no_push_back<T>::set_last(T**) [with T = MDL_ticket]"
"I>::remove(T*) [with T = MDL_ticket,B = I_P_List_adapter<MDL_ticket,&MDL_ticket::next_in_context,&MDL_ticket::prev_in_context>,C = I_P_List_null_counter,I = I_P_List_no_push_back<MDL_ticket>]" -> "I_P_List_null_counter::dec()"
"I>::remove(T*) [with T = MDL_ticket,B = I_P_List_adapter<MDL_ticket,&MDL_ticket::next_in_context,&MDL_ticket::prev_in_context>,C = I_P_List_null_counter,I = I_P_List_no_push_back<MDL_ticket>]" -> "prev>::next_ptr(T*) [with T = MDL_ticket,T* T::* next = &MDL_ticket::next_in_context,T** T::* prev = &MDL_ticket::prev_in_context]"
"MDL_lock::remove_ticket(MDL_lock::Ticket_list MDL_lock::*,MDL_ticket*)" -> "inline_mysql_prlock_wrlock(mysql_prlock_t*)"
"MDL_lock::remove_ticket(MDL_lock::Ticket_list MDL_lock::*,MDL_ticket*)" -> "MDL_lock::reschedule_waiters()"
"MDL_lock::remove_ticket(MDL_lock::Ticket_list MDL_lock::*,MDL_ticket*)" -> "MDL_lock::Ticket_list::remove_ticket(MDL_ticket*)"
"MDL_lock::remove_ticket(MDL_lock::Ticket_list MDL_lock::*,MDL_ticket*)" -> "MDL_map::remove(MDL_lock*)"
"MDL_lock::remove_ticket(MDL_lock::Ticket_list MDL_lock::*,MDL_ticket*)" -> "MDL_lock::is_empty() const"
"MDL_lock::remove_ticket(MDL_lock::Ticket_list MDL_lock::*,MDL_ticket*)" -> "inline_mysql_prlock_unlock(mysql_prlock_t*)"
"inline_mysql_prlock_wrlock(mysql_prlock_t*)" -> "rw_pr_wrlock(rw_pr_lock_t*)"
"MDL_lock::reschedule_waiters()" -> "MDL_lock::Ticket_list::remove_ticket(MDL_ticket*)"
"MDL_lock::reschedule_waiters()" -> "MDL_ticket::get_ctx() const"
"MDL_lock::reschedule_waiters()" -> "MDL_lock::Ticket_list::bitmap() const"
"MDL_lock::reschedule_waiters()" -> "L>::operator++(int) [with T = MDL_ticket,L = I_P_List<MDL_ticket,I_P_List_adapter<MDL_ticket,&MDL_ticket::next_in_lock,&MDL_ticket::prev_in_lock>,I_P_List_null_counter,I_P_List_fast_push_back<MDL_ticket> >]"
"MDL_lock::reschedule_waiters()" -> "MDL_ticket::get_type() const"
"MDL_lock::reschedule_waiters()" -> "MDL_lock::Ticket_list::operator const List&() const"
"MDL_lock::reschedule_waiters()" -> "MDL_lock::Ticket_list::add_ticket(MDL_ticket*)"
"MDL_lock::reschedule_waiters()" -> "L>::I_P_List_iterator(const L&) [with T = MDL_ticket,L = I_P_List<MDL_ticket,I_P_List_adapter<MDL_ticket,&MDL_ticket::next_in_lock,&MDL_ticket::prev_in_lock>,I_P_List_null_counter,I_P_List_fast_push_back<MDL_ticket> >]"
"MDL_lock::reschedule_waiters()" -> "MDL_lock::can_grant_lock(enum_mdl_type,MDL_context*,bool) const"
"MDL_lock::reschedule_waiters()" -> "MDL_wait::set_status(MDL_wait::enum_wait_status)"
"MDL_lock::Ticket_list::remove_ticket(MDL_ticket*)" -> "I>::remove(T*) [with T = MDL_ticket,B = I_P_List_adapter<MDL_ticket,&MDL_ticket::next_in_lock,&MDL_ticket::prev_in_lock>,C = I_P_List_null_counter,I = I_P_List_fast_push_back<MDL_ticket>]"
"MDL_lock::Ticket_list::remove_ticket(MDL_ticket*)" -> "MDL_ticket::get_type() const"
"MDL_lock::Ticket_list::remove_ticket(MDL_ticket*)" -> "MDL_lock::Ticket_list::clear_bit_if_not_in_list(enum_mdl_type)"
"I>::remove(T*) [with T = MDL_ticket,B = I_P_List_adapter<MDL_ticket,&MDL_ticket::next_in_lock,&MDL_ticket::prev_in_lock>,C = I_P_List_null_counter,I = I_P_List_fast_push_back<MDL_ticket>]" -> "prev>::next_ptr(T*) [with T = MDL_ticket,T* T::* next = &MDL_ticket::next_in_lock,T** T::* prev = &MDL_ticket::prev_in_lock]"
"I>::remove(T*) [with T = MDL_ticket,B = I_P_List_adapter<MDL_ticket,&MDL_ticket::next_in_lock,&MDL_ticket::prev_in_lock>,C = I_P_List_null_counter,I = I_P_List_fast_push_back<MDL_ticket>]" -> "I_P_List_fast_push_back<T>::set_last(T**) [with T = MDL_ticket]"
"I>::remove(T*) [with T = MDL_ticket,B = I_P_List_adapter<MDL_ticket,&MDL_ticket::next_in_lock,&MDL_ticket::prev_in_lock>,C = I_P_List_null_counter,I = I_P_List_fast_push_back<MDL_ticket>]" -> "prev>::prev_ptr(T*) [with T = MDL_ticket,T* T::* next = &MDL_ticket::next_in_lock,T** T::* prev = &MDL_ticket::prev_in_lock]"
"I>::remove(T*) [with T = MDL_ticket,B = I_P_List_adapter<MDL_ticket,&MDL_ticket::next_in_lock,&MDL_ticket::prev_in_lock>,C = I_P_List_null_counter,I = I_P_List_fast_push_back<MDL_ticket>]" -> "I_P_List_null_counter::dec()"
"MDL_lock::Ticket_list::clear_bit_if_not_in_list(enum_mdl_type)" -> "L>::operator++(int) [with T = MDL_ticket,L = I_P_List<MDL_ticket,I_P_List_adapter<MDL_ticket,&MDL_ticket::next_in_lock,&MDL_ticket::prev_in_lock>,I_P_List_null_counter,I_P_List_fast_push_back<MDL_ticket> >]"
"MDL_lock::Ticket_list::clear_bit_if_not_in_list(enum_mdl_type)" -> "L>::I_P_List_iterator(const L&) [with T = MDL_ticket,L = I_P_List<MDL_ticket,I_P_List_adapter<MDL_ticket,&MDL_ticket::next_in_lock,&MDL_ticket::prev_in_lock>,I_P_List_null_counter,I_P_List_fast_push_back<MDL_ticket> >]"
"MDL_lock::Ticket_list::clear_bit_if_not_in_list(enum_mdl_type)" -> "MDL_ticket::get_type() const"
"L>::operator++(int) [with T = MDL_ticket,L = I_P_List<MDL_ticket,I_P_List_adapter<MDL_ticket,&MDL_ticket::next_in_lock,&MDL_ticket::prev_in_lock>,I_P_List_null_counter,I_P_List_fast_push_back<MDL_ticket> >]" -> "prev>::next_ptr(T*) [with T = MDL_ticket,T* T::* next = &MDL_ticket::next_in_lock,T** T::* prev = &MDL_ticket::prev_in_lock]"
"MDL_lock::Ticket_list::add_ticket(MDL_ticket*)" -> "MDL_ticket::get_type() const"
"MDL_lock::Ticket_list::add_ticket(MDL_ticket*)" -> "I>::push_back(T*) [with T = MDL_ticket,B = I_P_List_adapter<MDL_ticket,&MDL_ticket::next_in_lock,&MDL_ticket::prev_in_lock>,C = I_P_List_null_counter,I = I_P_List_fast_push_back<MDL_ticket>]"
"I>::push_back(T*) [with T = MDL_ticket,B = I_P_List_adapter<MDL_ticket,&MDL_ticket::next_in_lock,&MDL_ticket::prev_in_lock>,C = I_P_List_null_counter,I = I_P_List_fast_push_back<MDL_ticket>]" -> "prev>::next_ptr(T*) [with T = MDL_ticket,T* T::* next = &MDL_ticket::next_in_lock,T** T::* prev = &MDL_ticket::prev_in_lock]"
"I>::push_back(T*) [with T = MDL_ticket,B = I_P_List_adapter<MDL_ticket,&MDL_ticket::next_in_lock,&MDL_ticket::prev_in_lock>,C = I_P_List_null_counter,I = I_P_List_fast_push_back<MDL_ticket>]" -> "prev>::prev_ptr(T*) [with T = MDL_ticket,T* T::* next = &MDL_ticket::next_in_lock,T** T::* prev = &MDL_ticket::prev_in_lock]"
"I>::push_back(T*) [with T = MDL_ticket,B = I_P_List_adapter<MDL_ticket,&MDL_ticket::next_in_lock,&MDL_ticket::prev_in_lock>,C = I_P_List_null_counter,I = I_P_List_fast_push_back<MDL_ticket>]" -> "I_P_List_fast_push_back<T>::set_last(T**) [with T = MDL_ticket]"
"I>::push_back(T*) [with T = MDL_ticket,B = I_P_List_adapter<MDL_ticket,&MDL_ticket::next_in_lock,&MDL_ticket::prev_in_lock>,C = I_P_List_null_counter,I = I_P_List_fast_push_back<MDL_ticket>]" -> "I_P_List_fast_push_back<T>::get_last() const [with T = MDL_ticket]"
"I>::push_back(T*) [with T = MDL_ticket,B = I_P_List_adapter<MDL_ticket,&MDL_ticket::next_in_lock,&MDL_ticket::prev_in_lock>,C = I_P_List_null_counter,I = I_P_List_fast_push_back<MDL_ticket>]" -> "I_P_List_null_counter::inc()"
"MDL_lock::can_grant_lock(enum_mdl_type,MDL_context*,bool) const" -> "MDL_lock::Ticket_list::operator const List&() const"
"MDL_lock::can_grant_lock(enum_mdl_type,MDL_context*,bool) const" -> "MDL_lock::Ticket_list::bitmap() const"
"MDL_lock::can_grant_lock(enum_mdl_type,MDL_context*,bool) const" -> "L>::operator++(int) [with T = MDL_ticket,L = I_P_List<MDL_ticket,I_P_List_adapter<MDL_ticket,&MDL_ticket::next_in_lock,&MDL_ticket::prev_in_lock>,I_P_List_null_counter,I_P_List_fast_push_back<MDL_ticket> >]"
"MDL_lock::can_grant_lock(enum_mdl_type,MDL_context*,bool) const" -> "MDL_ticket::is_incompatible_when_granted(enum_mdl_type) const"
"MDL_lock::can_grant_lock(enum_mdl_type,MDL_context*,bool) const" -> "MDL_ticket::get_ctx() const"
"MDL_lock::can_grant_lock(enum_mdl_type,MDL_context*,bool) const" -> "L>::I_P_List_iterator(const L&) [with T = MDL_ticket,L = I_P_List<MDL_ticket,I_P_List_adapter<MDL_ticket,&MDL_ticket::next_in_lock,&MDL_ticket::prev_in_lock>,I_P_List_null_counter,I_P_List_fast_push_back<MDL_ticket> >]"
"MDL_wait::set_status(MDL_wait::enum_wait_status)" -> "inline_mysql_cond_signal(mysql_cond_t*)"
"MDL_wait::set_status(MDL_wait::enum_wait_status)" -> "inline_mysql_mutex_lock(mysql_mutex_t*)"
"MDL_wait::set_status(MDL_wait::enum_wait_status)" -> "inline_mysql_mutex_unlock(mysql_mutex_t*)"
"MDL_map::remove(MDL_lock*)" -> "inline_mysql_prlock_unlock(mysql_prlock_t*)"
"MDL_map::remove(MDL_lock*)" -> "MDL_key::mdl_namespace() const"
"MDL_map::remove(MDL_lock*)" -> "MDL_map_partition::remove(MDL_lock*)"
"inline_mysql_prlock_unlock(mysql_prlock_t*)" -> "rw_pr_unlock(rw_pr_lock_t*)"
"MDL_map_partition::remove(MDL_lock*)" -> "my_hash_delete(HASH*,uchar*)"
"MDL_map_partition::remove(MDL_lock*)" -> "MDL_lock::destroy(MDL_lock*)"
"MDL_map_partition::remove(MDL_lock*)" -> "inline_mysql_prlock_unlock(mysql_prlock_t*)"
"MDL_map_partition::remove(MDL_lock*)" -> "MDL_key::mdl_namespace() const"
"MDL_map_partition::remove(MDL_lock*)" -> "inline_mysql_mutex_lock(mysql_mutex_t*)"
"MDL_map_partition::remove(MDL_lock*)" -> "I>::push_front(T*) [with T = MDL_object_lock,B = MDL_object_lock_cache_adapter,C = I_P_List_counter,I = I_P_List_no_push_back<MDL_object_lock>]"
"MDL_map_partition::remove(MDL_lock*)" -> "I_P_List_counter::elements() const"
"MDL_map_partition::remove(MDL_lock*)" -> "inline_mysql_mutex_unlock(mysql_mutex_t*)"
"I>::push_front(T*) [with T = MDL_object_lock,B = MDL_object_lock_cache_adapter,C = I_P_List_counter,I = I_P_List_no_push_back<MDL_object_lock>]" -> "prev>::next_ptr(T*) [with T = MDL_object_lock,T* T::* next = &MDL_object_lock::next_in_cache,T** T::* prev = &MDL_object_lock::prev_in_cache]"
"I>::push_front(T*) [with T = MDL_object_lock,B = MDL_object_lock_cache_adapter,C = I_P_List_counter,I = I_P_List_no_push_back<MDL_object_lock>]" -> "I_P_List_counter::inc()"
"I>::push_front(T*) [with T = MDL_object_lock,B = MDL_object_lock_cache_adapter,C = I_P_List_counter,I = I_P_List_no_push_back<MDL_object_lock>]" -> "prev>::prev_ptr(T*) [with T = MDL_object_lock,T* T::* next = &MDL_object_lock::next_in_cache,T** T::* prev = &MDL_object_lock::prev_in_cache]"
"I>::push_front(T*) [with T = MDL_object_lock,B = MDL_object_lock_cache_adapter,C = I_P_List_counter,I = I_P_List_no_push_back<MDL_object_lock>]" -> "I_P_List_no_push_back<T>::set_last(T**) [with T = MDL_object_lock]"
"MDL_lock::is_empty() const" -> "MDL_lock::Ticket_list::is_empty() const"
"MDL_lock::Ticket_list::is_empty() const" -> "I>::is_empty() const [with T = MDL_ticket,B = I_P_List_adapter<MDL_ticket,&MDL_ticket::next_in_lock,&MDL_ticket::prev_in_lock>,C = I_P_List_null_counter,I = I_P_List_fast_push_back<MDL_ticket>]"
"trans_rollback(THD*)" -> "ha_rollback_trans(THD*,bool)"
"trans_rollback(THD*)" -> "THD_TRANS::reset_unsafe_rollback_flags()"
"trans_rollback(THD*)" -> "trans_check_state(THD*)"
"ha_rollback_trans(THD*,bool)" -> "THD::st_transactions::cleanup()"
"ha_rollback_trans(THD*,bool)" -> "my_error(int,myf,...)"
"ha_rollback_trans(THD*,bool)" -> "THD_TRANS::cannot_safely_rollback() const"
"ha_rollback_trans(THD*,bool)" -> "THD::st_transactions::push_unsafe_rollback_warnings(THD*)"
"ha_rollback_trans(THD*,bool)" -> "gtid_rollback(THD*)"
"THD::st_transactions::cleanup()" -> "xid_t::null()"
"THD::st_transactions::cleanup()" -> "free_root(MEM_ROOT*,myf)"
"THD::st_transactions::push_unsafe_rollback_warnings(THD*)" -> "THD_TRANS::has_modified_non_trans_table() const"
"THD::st_transactions::push_unsafe_rollback_warnings(THD*)" -> "THD_TRANS::has_created_temp_table() const"
"THD::st_transactions::push_unsafe_rollback_warnings(THD*)" -> "THD_TRANS::has_dropped_temp_table() const"
"THD::st_transactions::push_unsafe_rollback_warnings(THD*)" -> "push_warning(THD*,Sql_condition::enum_warning_level,uint,const char*)"
"THD::st_transactions::push_unsafe_rollback_warnings(THD*)" -> "_current_thd()"
"push_warning(THD*,Sql_condition::enum_warning_level,uint,const char*)" -> "THD::raise_condition(uint,const char*,Sql_condition::enum_warning_level,const char*)"
"THD::raise_condition(uint,const char*,Sql_condition::enum_warning_level,const char*)" -> "Query_cache::abort(Query_cache_tls*)"
"THD::raise_condition(uint,const char*,Sql_condition::enum_warning_level,const char*)" -> "THD::really_abort_on_warning()"
"THD::raise_condition(uint,const char*,Sql_condition::enum_warning_level,const char*)" -> "Diagnostics_area::is_error() const"
"THD::raise_condition(uint,const char*,Sql_condition::enum_warning_level,const char*)" -> "Diagnostics_area::push_warning(THD*,uint,const char*,Sql_condition::enum_warning_level,const char*)"
"THD::raise_condition(uint,const char*,Sql_condition::enum_warning_level,const char*)" -> "THD::handle_condition(uint,const char*,Sql_condition::enum_warning_level,const char*,Sql_condition**)"
"THD::raise_condition(uint,const char*,Sql_condition::enum_warning_level,const char*)" -> "mysql_errno_to_sqlstate(unsigned int)"
"THD::raise_condition(uint,const char*,Sql_condition::enum_warning_level,const char*)" -> "_current_thd()"
"THD::raise_condition(uint,const char*,Sql_condition::enum_warning_level,const char*)" -> "THD::get_stmt_da()"
"THD::raise_condition(uint,const char*,Sql_condition::enum_warning_level,const char*)" -> "THD::set_row_count_func(longlong)"
"THD::raise_condition(uint,const char*,Sql_condition::enum_warning_level,const char*)" -> "Diagnostics_area::set_error_status(uint,const char*,const char*,const Sql_condition*)"
"THD::raise_condition(uint,const char*,Sql_condition::enum_warning_level,const char*)" -> "Diagnostics_area::opt_clear_warning_info(ulonglong)"
"Query_cache::abort(Query_cache_tls*)" -> "Query_cache_block::query()"
"Query_cache::abort(Query_cache_tls*)" -> "Query_cache::is_disabled()"
"Query_cache::abort(Query_cache_tls*)" -> "THD::enter_stage(const PSI_stage_info*,PSI_stage_info*,const char*,const char*,unsigned int)"
"Query_cache::abort(Query_cache_tls*)" -> "Query_cache_query::lock_writing()"
"Query_cache::abort(Query_cache_tls*)" -> "_current_thd()"
"Query_cache::abort(Query_cache_tls*)" -> "Query_cache::try_lock(bool)"
"Query_cache::abort(Query_cache_tls*)" -> "Query_cache::free_query(Query_cache_block*)"
"Query_cache::abort(Query_cache_tls*)" -> "Query_cache::unlock()"
"Query_cache_block::query()" -> "Query_cache_block::data()"
"Query_cache_block::data()" -> "Query_cache_block::headers_len()"
"Query_cache_query::lock_writing()" -> "inline_mysql_rwlock_wrlock(mysql_rwlock_t*)"
"inline_mysql_rwlock_wrlock(mysql_rwlock_t*)" -> "pthread_rwlock_wrlock(pthread_rwlock_t*)"
"Query_cache::try_lock(bool)" -> "Query_cache_wait_state::Query_cache_wait_state(THD*,const char*,const char*,unsigned int)"
"Query_cache::try_lock(bool)" -> "my_getsystime()"
"Query_cache::try_lock(bool)" -> "inline_mysql_cond_timedwait(mysql_cond_t*,mysql_mutex_t*,const timespec*)"
"Query_cache::try_lock(bool)" -> "_current_thd()"
"Query_cache::try_lock(bool)" -> "inline_mysql_mutex_unlock(mysql_mutex_t*)"
"Query_cache::try_lock(bool)" -> "inline_mysql_cond_wait(mysql_cond_t*,mysql_mutex_t*)"
"Query_cache::try_lock(bool)" -> "inline_mysql_mutex_lock(mysql_mutex_t*)"
"Query_cache_wait_state::Query_cache_wait_state(THD*,const char*,const char*,unsigned int)" -> "set_thd_stage_info(void*,const PSI_stage_info*,PSI_stage_info*,const char*,const char*,unsigned int)"
"set_thd_stage_info(void*,const PSI_stage_info*,PSI_stage_info*,const char*,const char*,unsigned int)" -> "THD::enter_stage(const PSI_stage_info*,PSI_stage_info*,const char*,const char*,unsigned int)"
"set_thd_stage_info(void*,const PSI_stage_info*,PSI_stage_info*,const char*,const char*,unsigned int)" -> "_current_thd()"
"inline_mysql_cond_timedwait(mysql_cond_t*,mysql_mutex_t*,const timespec*)" -> "pthread_cond_timedwait(pthread_cond_t*,pthread_mutex_t*,const timespec*)"
"inline_mysql_cond_wait(mysql_cond_t*,mysql_mutex_t*)" -> "pthread_cond_wait(pthread_cond_t*,pthread_mutex_t*)"
"Query_cache::free_query(Query_cache_block*)" -> "Query_cache::free_query_internal(Query_cache_block*)"
"Query_cache::free_query(Query_cache_block*)" -> "my_hash_delete(HASH*,uchar*)"
"Query_cache::free_query_internal(Query_cache_block*)" -> "Query_cache_query::unlock_n_destroy()"
"Query_cache::free_query_internal(Query_cache_block*)" -> "Query_cache_block::table(uint)"
"Query_cache::free_query_internal(Query_cache_block*)" -> "Query_cache::unlink_table(Query_cache_block_table*)"
"Query_cache::free_query_internal(Query_cache_block*)" -> "Query_cache::double_linked_list_exclude(Query_cache_block*,Query_cache_block**)"
"Query_cache::free_query_internal(Query_cache_block*)" -> "Query_cache_query::writer(Query_cache_tls*)"
"Query_cache::free_query_internal(Query_cache_block*)" -> "Query_cache_query::result()"
"Query_cache::free_query_internal(Query_cache_block*)" -> "Query_cache::free_memory_block(Query_cache_block*)"
"Query_cache::free_query_internal(Query_cache_block*)" -> "Query_cache_query::writer()"
"Query_cache::free_query_internal(Query_cache_block*)" -> "Query_cache_block::query()"
"Query_cache_query::unlock_n_destroy()" -> "inline_mysql_rwlock_destroy(mysql_rwlock_t*)"
"Query_cache_query::unlock_n_destroy()" -> "Query_cache_query::unlock_writing()"
"inline_mysql_rwlock_destroy(mysql_rwlock_t*)" -> "pthread_rwlock_destroy(pthread_rwlock_t*)"
"Query_cache_query::unlock_writing()" -> "inline_mysql_rwlock_unlock(mysql_rwlock_t*)"
"Query_cache::unlink_table(Query_cache_block_table*)" -> "Query_cache::double_linked_list_exclude(Query_cache_block*,Query_cache_block**)"
"Query_cache::unlink_table(Query_cache_block_table*)" -> "my_hash_delete(HASH*,uchar*)"
"Query_cache::unlink_table(Query_cache_block_table*)" -> "Query_cache::free_memory_block(Query_cache_block*)"
"Query_cache::unlink_table(Query_cache_block_table*)" -> "Query_cache_block_table::block()"
"Query_cache::free_memory_block(Query_cache_block*)" -> "Query_cache::join_free_blocks(Query_cache_block*,Query_cache_block*)"
"Query_cache::free_memory_block(Query_cache_block*)" -> "Query_cache_block::is_free()"
"Query_cache::free_memory_block(Query_cache_block*)" -> "Query_cache::insert_into_free_memory_list(Query_cache_block*)"
"Query_cache::join_free_blocks(Query_cache_block*,Query_cache_block*)" -> "Query_cache_block::destroy()"
"Query_cache::join_free_blocks(Query_cache_block*,Query_cache_block*)" -> "Query_cache::exclude_from_free_memory_list(Query_cache_block*)"
"Query_cache::exclude_from_free_memory_list(Query_cache_block*)" -> "Query_cache_block::data()"
"Query_cache::exclude_from_free_memory_list(Query_cache_block*)" -> "Query_cache::double_linked_list_exclude(Query_cache_block*,Query_cache_block**)"
"Query_cache::insert_into_free_memory_list(Query_cache_block*)" -> "Query_cache_block::data()"
"Query_cache::insert_into_free_memory_list(Query_cache_block*)" -> "Query_cache::find_bin(ulong)"
"Query_cache::insert_into_free_memory_list(Query_cache_block*)" -> "Query_cache::insert_into_free_memory_sorted_list(Query_cache_block*,Query_cache_block**)"
"Query_cache::unlock()" -> "inline_mysql_mutex_lock(mysql_mutex_t*)"
"Query_cache::unlock()" -> "inline_mysql_cond_signal(mysql_cond_t*)"
"Query_cache::unlock()" -> "inline_mysql_mutex_unlock(mysql_mutex_t*)"
"THD::really_abort_on_warning()" -> "THD_TRANS::cannot_safely_rollback() const"
"Diagnostics_area::push_warning(THD*,uint,const char*,Sql_condition::enum_warning_level,const char*)" -> "Warning_info::push_warning(THD*,uint,const char*,Sql_condition::enum_warning_level,const char*)"
"Diagnostics_area::push_warning(THD*,uint,const char*,Sql_condition::enum_warning_level,const char*)" -> "Diagnostics_area::get_warning_info()"
"Warning_info::push_warning(THD*,uint,const char*,Sql_condition::enum_warning_level,const char*)" -> "Sql_condition::Sql_condition(MEM_ROOT*)"
"Warning_info::push_warning(THD*,uint,const char*,Sql_condition::enum_warning_level,const char*)" -> "I_P_List_counter::elements() const"
"Warning_info::push_warning(THD*,uint,const char*,Sql_condition::enum_warning_level,const char*)" -> "Sql_condition::set(uint,const char*,Sql_condition::enum_warning_level,const char*)"
"Warning_info::push_warning(THD*,uint,const char*,Sql_condition::enum_warning_level,const char*)" -> "I>::push_back(T*) [with T = Sql_condition,B = I_P_List_adapter<Sql_condition,&Sql_condition::next_in_wi,&Sql_condition::prev_in_wi>,C = I_P_List_counter,I = I_P_List_fast_push_back<Sql_condition>]"
"Sql_condition::Sql_condition(MEM_ROOT*)" -> "memset(void*,int,size_t)"
"Sql_condition::Sql_condition(MEM_ROOT*)" -> "Sql_alloc::Sql_alloc()"
"Sql_condition::Sql_condition(MEM_ROOT*)" -> "String::String()"
"Sql_condition::Sql_condition(MEM_ROOT*)" -> "String::String(const char*,uint32,const CHARSET_INFO*)"
"Sql_condition::set(uint,const char*,Sql_condition::enum_warning_level,const char*)" -> "Sql_condition::set_class_origins()"
"Sql_condition::set(uint,const char*,Sql_condition::enum_warning_level,const char*)" -> "memcpy(void*,const void*,size_t)"
"Sql_condition::set(uint,const char*,Sql_condition::enum_warning_level,const char*)" -> "Sql_condition::set_builtin_message_text(const char*)"
"Sql_condition::set_class_origins()" -> "String::set_ascii(const char*,uint32)"
"Sql_condition::set_class_origins()" -> "memcmp(const void*,const void*,size_t)"
"String::set_ascii(const char*,uint32)" -> "String::set(const char*,uint32,const CHARSET_INFO*)"
"String::set_ascii(const char*,uint32)" -> "String::copy(const char*,uint32,const CHARSET_INFO*,const CHARSET_INFO*,uint*)"
"String::set(const char*,uint32,const CHARSET_INFO*)" -> "String::free()"
"String::copy(const char*,uint32,const CHARSET_INFO*,const CHARSET_INFO*,uint*)" -> "String::copy(const char*,uint32,const CHARSET_INFO*)"
"String::copy(const char*,uint32,const CHARSET_INFO*,const CHARSET_INFO*,uint*)" -> "String::needs_conversion(uint32,const CHARSET_INFO*,const CHARSET_INFO*,uint32*)"
"String::copy(const char*,uint32,const CHARSET_INFO*,const CHARSET_INFO*,uint*)" -> "String::alloc(uint32)"
"String::copy(const char*,uint32,const CHARSET_INFO*,const CHARSET_INFO*,uint*)" -> "String::copy_aligned(const char*,uint32,uint32,const CHARSET_INFO*)"
"String::copy(const char*,uint32,const CHARSET_INFO*,const CHARSET_INFO*,uint*)" -> "copy_and_convert(char*,uint32,const CHARSET_INFO*,const char*,uint32,const CHARSET_INFO*,uint*)"
"String::copy(const char*,uint32,const CHARSET_INFO*)" -> "String::alloc(uint32)"
"String::copy(const char*,uint32,const CHARSET_INFO*)" -> "memcpy(void*,const void*,size_t)"
"String::alloc(uint32)" -> "String::real_alloc(uint32)"
"String::copy_aligned(const char*,uint32,uint32,const CHARSET_INFO*)" -> "memcpy(void*,const void*,size_t)"
"String::copy_aligned(const char*,uint32,uint32,const CHARSET_INFO*)" -> "memset(void*,int,size_t)"
"String::copy_aligned(const char*,uint32,uint32,const CHARSET_INFO*)" -> "String::alloc(uint32)"
"Sql_condition::set_builtin_message_text(const char*)" -> "String::set(const char*,uint32,const CHARSET_INFO*)"
"Sql_condition::set_builtin_message_text(const char*)" -> "strdup_root(MEM_ROOT*,const char*)"
"Sql_condition::set_builtin_message_text(const char*)" -> "strlen(const char*)"
"I>::push_back(T*) [with T = Sql_condition,B = I_P_List_adapter<Sql_condition,&Sql_condition::next_in_wi,&Sql_condition::prev_in_wi>,C = I_P_List_counter,I = I_P_List_fast_push_back<Sql_condition>]" -> "I_P_List_fast_push_back<T>::get_last() const [with T = Sql_condition]"
"I>::push_back(T*) [with T = Sql_condition,B = I_P_List_adapter<Sql_condition,&Sql_condition::next_in_wi,&Sql_condition::prev_in_wi>,C = I_P_List_counter,I = I_P_List_fast_push_back<Sql_condition>]" -> "prev>::next_ptr(T*) [with T = Sql_condition,T* T::* next = &Sql_condition::next_in_wi,T** T::* prev = &Sql_condition::prev_in_wi]"
"I>::push_back(T*) [with T = Sql_condition,B = I_P_List_adapter<Sql_condition,&Sql_condition::next_in_wi,&Sql_condition::prev_in_wi>,C = I_P_List_counter,I = I_P_List_fast_push_back<Sql_condition>]" -> "I_P_List_counter::inc()"
"I>::push_back(T*) [with T = Sql_condition,B = I_P_List_adapter<Sql_condition,&Sql_condition::next_in_wi,&Sql_condition::prev_in_wi>,C = I_P_List_counter,I = I_P_List_fast_push_back<Sql_condition>]" -> "I_P_List_fast_push_back<T>::set_last(T**) [with T = Sql_condition]"
"I>::push_back(T*) [with T = Sql_condition,B = I_P_List_adapter<Sql_condition,&Sql_condition::next_in_wi,&Sql_condition::prev_in_wi>,C = I_P_List_counter,I = I_P_List_fast_push_back<Sql_condition>]" -> "prev>::prev_ptr(T*) [with T = Sql_condition,T* T::* next = &Sql_condition::next_in_wi,T** T::* prev = &Sql_condition::prev_in_wi]"
"Diagnostics_area::set_error_status(uint,const char*,const char*,const Sql_condition*)" -> "Diagnostics_area::get_warning_info()"
"Diagnostics_area::set_error_status(uint,const char*,const char*,const Sql_condition*)" -> "memcpy(void*,const void*,size_t)"
"Diagnostics_area::set_error_status(uint,const char*,const char*,const Sql_condition*)" -> "Warning_info::set_error_condition(const Sql_condition*)"
"Diagnostics_area::set_error_status(uint,const char*,const char*,const Sql_condition*)" -> "strmake(char*,const char*,size_t)"
"Diagnostics_area::set_error_status(uint,const char*,const char*,const Sql_condition*)" -> "Diagnostics_area::is_disabled() const"
"Diagnostics_area::opt_clear_warning_info(ulonglong)" -> "Warning_info::opt_clear(ulonglong)"
"Diagnostics_area::opt_clear_warning_info(ulonglong)" -> "Diagnostics_area::get_warning_info()"
"Warning_info::opt_clear(ulonglong)" -> "Warning_info::clear(ulonglong)"
"Warning_info::clear(ulonglong)" -> "Warning_info::clear_error_condition()"
"Warning_info::clear(ulonglong)" -> "Warning_info::id(ulonglong)"
"Warning_info::clear(ulonglong)" -> "I>::empty() [with T = Sql_condition,B = I_P_List_adapter<Sql_condition,&Sql_condition::next_in_wi,&Sql_condition::prev_in_wi>,C = I_P_List_counter,I = I_P_List_fast_push_back<Sql_condition>]"
"Warning_info::clear(ulonglong)" -> "base_list::empty()"
"Warning_info::clear(ulonglong)" -> "memset(void*,int,size_t)"
"Warning_info::clear(ulonglong)" -> "free_root(MEM_ROOT*,myf)"
"gtid_rollback(THD*)" -> "Checkable_rwlock::unlock()"
"gtid_rollback(THD*)" -> "Checkable_rwlock::rdlock()"
"gtid_rollback(THD*)" -> "Gtid_state::update_on_rollback(THD*)"
"Checkable_rwlock::unlock()" -> "inline_mysql_rwlock_unlock(mysql_rwlock_t*)"
"Checkable_rwlock::unlock()" -> "Checkable_rwlock::assert_some_lock() const"
"Checkable_rwlock::rdlock()" -> "inline_mysql_rwlock_rdlock(mysql_rwlock_t*)"
"Checkable_rwlock::rdlock()" -> "inline_mysql_rwlock_rdlock(mysql_rwlock_t*,const char*,uint)"
"Checkable_rwlock::rdlock()" -> "Checkable_rwlock::assert_no_wrlock() const"
"inline_mysql_rwlock_rdlock(mysql_rwlock_t*,const char*,uint)" -> "pthread_rwlock_rdlock(pthread_rwlock_t*)"
"Gtid_state::update_on_rollback(THD*)" -> "Gtid_state::update_owned_gtids_impl(THD*,bool)"
"Gtid_state::update_owned_gtids_impl(THD*,bool)" -> "Checkable_rwlock::assert_some_lock() const"
"Gtid_state::update_owned_gtids_impl(THD*,bool)" -> "THD::clear_owned_gtids()"
"Gtid_state::update_owned_gtids_impl(THD*,bool)" -> "Gtid_state::lock_sidno(rpl_sidno)"
"Gtid_state::update_owned_gtids_impl(THD*,bool)" -> "Gtid_state::unlock_owned_sidnos(const THD*)"
"Gtid_state::update_owned_gtids_impl(THD*,bool)" -> "Owned_gtids::remove_gtid(const Gtid&)"
"Gtid_state::update_owned_gtids_impl(THD*,bool)" -> "Gtid_state::broadcast_owned_sidnos(const THD*)"
"Gtid_state::update_owned_gtids_impl(THD*,bool)" -> "Gtid_specification::set_undefined()"
"Gtid_state::lock_sidno(rpl_sidno)" -> "Mutex_cond_array::lock(int) const"
"Mutex_cond_array::lock(int) const" -> "inline_mysql_mutex_lock(mysql_mutex_t*)"
"Mutex_cond_array::lock(int) const" -> "Mutex_cond_array::assert_not_owner(int) const"
"Mutex_cond_array::lock(int) const" -> "Mutex_cond_array::get_mutex_cond(int) const"
"Mutex_cond_array::get_mutex_cond(int) const" -> "Checkable_rwlock::assert_some_lock() const"
"Gtid_state::unlock_owned_sidnos(const THD*)" -> "Gtid_state::unlock_sidno(rpl_sidno)"
"Gtid_state::unlock_sidno(rpl_sidno)" -> "Mutex_cond_array::unlock(int) const"
"Mutex_cond_array::unlock(int) const" -> "Mutex_cond_array::assert_owner(int) const"
"Mutex_cond_array::unlock(int) const" -> "inline_mysql_mutex_unlock(mysql_mutex_t*)"
"Mutex_cond_array::unlock(int) const" -> "Mutex_cond_array::get_mutex_cond(int) const"
"Owned_gtids::remove_gtid(const Gtid&)" -> "my_hash_delete(HASH*,uchar*)"
"Owned_gtids::remove_gtid(const Gtid&)" -> "Owned_gtids::get_hash(rpl_sidno) const"
"Owned_gtids::remove_gtid(const Gtid&)" -> "Owned_gtids::get_node(const HASH*,rpl_gno) const"
"Owned_gtids::get_hash(rpl_sidno) const" -> "Checkable_rwlock::assert_some_lock() const"
"Owned_gtids::get_node(const HASH*,rpl_gno) const" -> "my_hash_search(const HASH*,const uchar*,size_t)"
"Owned_gtids::get_node(const HASH*,rpl_gno) const" -> "Checkable_rwlock::assert_some_lock() const"
"Gtid_state::broadcast_owned_sidnos(const THD*)" -> "Gtid_state::broadcast_sidno(rpl_sidno)"
"Gtid_state::broadcast_sidno(rpl_sidno)" -> "Mutex_cond_array::broadcast(int) const"
"Mutex_cond_array::broadcast(int) const" -> "inline_mysql_cond_broadcast(mysql_cond_t*)"
"Mutex_cond_array::broadcast(int) const" -> "Mutex_cond_array::get_mutex_cond(int) const"
"inline_mysql_cond_broadcast(mysql_cond_t*)" -> "pthread_cond_broadcast(pthread_cond_t*)"
"trans_check_state(THD*)" -> "__builtin_expect(long int,long int)"
"trans_check_state(THD*)" -> "my_error(int,myf,...)"
"mysql_ha_cleanup(THD*)" -> "mysql_ha_close_table(THD*,TABLE_LIST*)"
"mysql_ha_cleanup(THD*)" -> "my_hash_element(HASH*,ulong)"
"mysql_ha_cleanup(THD*)" -> "my_hash_free(HASH*)"
"mysql_ha_close_table(THD*,TABLE_LIST*)" -> "handler::ha_index_or_rnd_end()"
"mysql_ha_close_table(THD*,TABLE_LIST*)" -> "mark_tmp_table_for_reuse(TABLE*)"
"mysql_ha_close_table(THD*,TABLE_LIST*)" -> "MDL_context::release_lock(MDL_ticket*)"
"mysql_ha_close_table(THD*,TABLE_LIST*)" -> "close_thread_table(THD*,TABLE**)"
"handler::ha_index_or_rnd_end()" -> "handler::ha_index_end()"
"handler::ha_index_or_rnd_end()" -> "handler::ha_rnd_end()"
"mark_tmp_table_for_reuse(TABLE*)" -> "handler::ha_reset()"
"handler::ha_reset()" -> "TABLE::default_column_bitmaps()"
"handler::ha_reset()" -> "free_io_cache(TABLE*)"
"free_io_cache(TABLE*)" -> "my_free(void*)"
"free_io_cache(TABLE*)" -> "close_cached_file(IO_CACHE*)"
"close_thread_table(THD*,TABLE**)" -> "TABLE::needs_reopen()"
"close_thread_table(THD*,TABLE**)" -> "Table_cache::remove_table(TABLE*)"
"close_thread_table(THD*,TABLE**)" -> "inline_mysql_mutex_lock(mysql_mutex_t*)"
"close_thread_table(THD*,TABLE**)" -> "Table_cache::unlock()"
"close_thread_table(THD*,TABLE**)" -> "intern_close_table(TABLE*)"
"close_thread_table(THD*,TABLE**)" -> "free_field_buffers_larger_than(TABLE*,uint32)"
"close_thread_table(THD*,TABLE**)" -> "inline_mysql_mutex_unlock(mysql_mutex_t*)"
"close_thread_table(THD*,TABLE**)" -> "Table_cache_manager::get_cache(THD*)"
"close_thread_table(THD*,TABLE**)" -> "handler::ha_reset()"
"close_thread_table(THD*,TABLE**)" -> "TABLE_SHARE::has_old_version() const"
"close_thread_table(THD*,TABLE**)" -> "Table_cache::release_table(THD*,TABLE*)"
"close_thread_table(THD*,TABLE**)" -> "Table_cache::lock()"
"Table_cache::remove_table(TABLE*)" -> "Table_cache::unlink_unused_table(TABLE*)"
"Table_cache::remove_table(TABLE*)" -> "I>::remove(T*) [with T = TABLE,B = I_P_List_adapter<TABLE,&TABLE::cache_next,&TABLE::cache_prev>,C = I_P_List_null_counter,I = I_P_List_no_push_back<TABLE>]"
"Table_cache::remove_table(TABLE*)" -> "my_hash_delete(HASH*,uchar*)"
"Table_cache::remove_table(TABLE*)" -> "I>::is_empty() const [with T = TABLE,B = I_P_List_adapter<TABLE,&TABLE::cache_next,&TABLE::cache_prev>,C = I_P_List_null_counter,I = I_P_List_no_push_back<TABLE>]"
"Table_cache::remove_table(TABLE*)" -> "Table_cache_manager::cache_index(Table_cache*) const"
"Table_cache::remove_table(TABLE*)" -> "Table_cache::assert_owner()"
"Table_cache::unlink_unused_table(TABLE*)" -> "Table_cache::check_unused()"
"I>::remove(T*) [with T = TABLE,B = I_P_List_adapter<TABLE,&TABLE::cache_next,&TABLE::cache_prev>,C = I_P_List_null_counter,I = I_P_List_no_push_back<TABLE>]" -> "I_P_List_no_push_back<T>::set_last(T**) [with T = TABLE]"
"I>::remove(T*) [with T = TABLE,B = I_P_List_adapter<TABLE,&TABLE::cache_next,&TABLE::cache_prev>,C = I_P_List_null_counter,I = I_P_List_no_push_back<TABLE>]" -> "I_P_List_null_counter::dec()"
"I>::remove(T*) [with T = TABLE,B = I_P_List_adapter<TABLE,&TABLE::cache_next,&TABLE::cache_prev>,C = I_P_List_null_counter,I = I_P_List_no_push_back<TABLE>]" -> "prev>::prev_ptr(T*) [with T = TABLE,T* T::* next = &TABLE::cache_next,T** T::* prev = &TABLE::cache_prev]"
"I>::remove(T*) [with T = TABLE,B = I_P_List_adapter<TABLE,&TABLE::cache_next,&TABLE::cache_prev>,C = I_P_List_null_counter,I = I_P_List_no_push_back<TABLE>]" -> "prev>::next_ptr(T*) [with T = TABLE,T* T::* next = &TABLE::cache_next,T** T::* prev = &TABLE::cache_prev]"
"Table_cache::unlock()" -> "inline_mysql_mutex_unlock(mysql_mutex_t*)"
"intern_close_table(TABLE*)" -> "free_io_cache(TABLE*)"
"intern_close_table(TABLE*)" -> "my_free(void*)"
"intern_close_table(TABLE*)" -> "closefrm(TABLE*,bool)"
"closefrm(TABLE*,bool)" -> "free_table_share(TABLE_SHARE*)"
"closefrm(TABLE*,bool)" -> "free_root(MEM_ROOT*,myf)"
"closefrm(TABLE*,bool)" -> "handler::ha_close()"
"closefrm(TABLE*,bool)" -> "release_table_share(TABLE_SHARE*)"
"closefrm(TABLE*,bool)" -> "free_items(Item*)"
"closefrm(TABLE*,bool)" -> "my_free(void*)"
"free_table_share(TABLE_SHARE*)" -> "L>::operator++(int) [with T = Wait_for_flush,L = I_P_List<Wait_for_flush,I_P_List_adapter<Wait_for_flush,&Wait_for_flush::next_in_share,&Wait_for_flush::prev_in_share> >]"
"free_table_share(TABLE_SHARE*)" -> "Wait_for_flush::get_ctx() const"
"free_table_share(TABLE_SHARE*)" -> "TABLE_SHARE::destroy()"
"free_table_share(TABLE_SHARE*)" -> "I>::is_empty() const [with T = Wait_for_flush,B = I_P_List_adapter<Wait_for_flush,&Wait_for_flush::next_in_share,&Wait_for_flush::prev_in_share>,C = I_P_List_null_counter,I = I_P_List_no_push_back<Wait_for_flush>]"
"free_table_share(TABLE_SHARE*)" -> "L>::I_P_List_iterator(const L&) [with T = Wait_for_flush,L = I_P_List<Wait_for_flush,I_P_List_adapter<Wait_for_flush,&Wait_for_flush::next_in_share,&Wait_for_flush::prev_in_share> >]"
"free_table_share(TABLE_SHARE*)" -> "MDL_wait::set_status(MDL_wait::enum_wait_status)"
"L>::operator++(int) [with T = Wait_for_flush,L = I_P_List<Wait_for_flush,I_P_List_adapter<Wait_for_flush,&Wait_for_flush::next_in_share,&Wait_for_flush::prev_in_share> >]" -> "prev>::next_ptr(T*) [with T = Wait_for_flush,T* T::* next = &Wait_for_flush::next_in_share,T** T::* prev = &Wait_for_flush::prev_in_share]"
"TABLE_SHARE::destroy()" -> "plugin_unlock(THD*,plugin_ref)"
"TABLE_SHARE::destroy()" -> "inline_mysql_mutex_destroy(mysql_mutex_t*)"
"TABLE_SHARE::destroy()" -> "my_hash_free(HASH*)"
"TABLE_SHARE::destroy()" -> "free_root(MEM_ROOT*,myf)"
"plugin_unlock(THD*,plugin_ref)" -> "reap_plugins()"
"plugin_unlock(THD*,plugin_ref)" -> "inline_mysql_mutex_lock(mysql_mutex_t*)"
"plugin_unlock(THD*,plugin_ref)" -> "inline_mysql_mutex_unlock(mysql_mutex_t*)"
"plugin_unlock(THD*,plugin_ref)" -> "intern_plugin_unlock(LEX*,plugin_ref)"
"reap_plugins()" -> "inline_mysql_mutex_lock(mysql_mutex_t*)"
"reap_plugins()" -> "plugin_del(st_plugin_int*)"
"reap_plugins()" -> "__builtin_alloca(long unsigned int)"
"reap_plugins()" -> "inline_mysql_mutex_unlock(mysql_mutex_t*)"
"reap_plugins()" -> "sql_print_information(const char*,...)"
"reap_plugins()" -> "plugin_deinitialize(st_plugin_int*,bool)"
"plugin_del(st_plugin_int*)" -> "free_root(MEM_ROOT*,myf)"
"plugin_del(st_plugin_int*)" -> "inline_mysql_rwlock_wrlock(mysql_rwlock_t*)"
"plugin_del(st_plugin_int*)" -> "mysql_del_sys_var_chain(sys_var*)"
"plugin_del(st_plugin_int*)" -> "restore_pluginvar_names(sys_var*)"
"plugin_del(st_plugin_int*)" -> "my_hash_delete(HASH*,uchar*)"
"plugin_del(st_plugin_int*)" -> "plugin_vars_free_values(sys_var*)"
"plugin_del(st_plugin_int*)" -> "inline_mysql_rwlock_unlock(mysql_rwlock_t*)"
"plugin_del(st_plugin_int*)" -> "plugin_dl_del(const LEX_STRING*)"
"mysql_del_sys_var_chain(sys_var*)" -> "my_hash_delete(HASH*,uchar*)"
"plugin_vars_free_values(sys_var*)" -> "sys_var_pluginvar::real_value_ptr(THD*,enum_var_type)"
"plugin_vars_free_values(sys_var*)" -> "my_free(void*)"
"sys_var_pluginvar::real_value_ptr(THD*,enum_var_type)" -> "intern_sys_var_ptr(THD*,int,bool)"
"intern_sys_var_ptr(THD*,int,bool)" -> "plugin_var_memalloc_session_update(THD*,st_mysql_sys_var*,char**,const char*)"
"intern_sys_var_ptr(THD*,int,bool)" -> "inline_mysql_rwlock_rdlock(mysql_rwlock_t*)"
"intern_sys_var_ptr(THD*,int,bool)" -> "inline_mysql_mutex_lock(mysql_mutex_t*)"
"intern_sys_var_ptr(THD*,int,bool)" -> "my_hash_element(HASH*,ulong)"
"intern_sys_var_ptr(THD*,int,bool)" -> "inline_mysql_mutex_unlock(mysql_mutex_t*)"
"intern_sys_var_ptr(THD*,int,bool)" -> "my_realloc(void*,size_t,myf)"
"intern_sys_var_ptr(THD*,int,bool)" -> "memcpy(void*,const void*,size_t)"
"intern_sys_var_ptr(THD*,int,bool)" -> "intern_find_sys_var(const char*,uint)"
"intern_sys_var_ptr(THD*,int,bool)" -> "inline_mysql_rwlock_unlock(mysql_rwlock_t*)"
"plugin_var_memalloc_session_update(THD*,st_mysql_sys_var*,char**,const char*)" -> "strlen(const char*)"
"plugin_var_memalloc_session_update(THD*,st_mysql_sys_var*,char**,const char*)" -> "my_free(void*)"
"plugin_var_memalloc_session_update(THD*,st_mysql_sys_var*,char**,const char*)" -> "list_add(LIST*,LIST*)"
"plugin_var_memalloc_session_update(THD*,st_mysql_sys_var*,char**,const char*)" -> "my_malloc(size_t,myf)"
"plugin_var_memalloc_session_update(THD*,st_mysql_sys_var*,char**,const char*)" -> "memcpy(void*,const void*,size_t)"
"plugin_var_memalloc_session_update(THD*,st_mysql_sys_var*,char**,const char*)" -> "list_delete(LIST*,LIST*)"
"intern_find_sys_var(const char*,uint)" -> "sys_var::not_visible() const"
"intern_find_sys_var(const char*,uint)" -> "my_hash_search(const HASH*,const uchar*,size_t)"
"intern_find_sys_var(const char*,uint)" -> "strlen(const char*)"
"plugin_dl_del(const LEX_STRING*)" -> "free_plugin_mem(st_plugin_dl*)"
"plugin_dl_del(const LEX_STRING*)" -> "memset(void*,int,size_t)"
"free_plugin_mem(st_plugin_dl*)" -> "dlclose(void*)"
"free_plugin_mem(st_plugin_dl*)" -> "my_free(void*)"
"sql_print_information(const char*,...)" -> "error_log_print(loglevel,const char*,__va_list_tag*)"
"sql_print_information(const char*,...)" -> "__builtin_va_end(__va_list_tag*)"
"sql_print_information(const char*,...)" -> "__builtin_va_start(__va_list_tag*,...)"
"error_log_print(loglevel,const char*,__va_list_tag*)" -> "LOGGER::error_log_print(loglevel,const char*,__va_list_tag*)"
"plugin_deinitialize(st_plugin_int*,bool)" -> "remove_status_vars(SHOW_VAR*)"
"plugin_deinitialize(st_plugin_int*,bool)" -> "sql_print_error(const char*,...)"
"remove_status_vars(SHOW_VAR*)" -> "show_var_cmp(const void*,const void*)"
"remove_status_vars(SHOW_VAR*)" -> "shrink_var_array(DYNAMIC_ARRAY*)"
"remove_status_vars(SHOW_VAR*)" -> "inline_mysql_mutex_lock(mysql_mutex_t*)"
"remove_status_vars(SHOW_VAR*)" -> "inline_mysql_mutex_unlock(mysql_mutex_t*)"
"show_var_cmp(const void*,const void*)" -> "strcmp(const char*,const char*)"
"shrink_var_array(DYNAMIC_ARRAY*)" -> "memset(void*,int,size_t)"
"shrink_var_array(DYNAMIC_ARRAY*)" -> "delete_dynamic(DYNAMIC_ARRAY*)"
"sql_print_error(const char*,...)" -> "error_log_print(loglevel,const char*,__va_list_tag*)"
"sql_print_error(const char*,...)" -> "__builtin_va_end(__va_list_tag*)"
"sql_print_error(const char*,...)" -> "__builtin_va_start(__va_list_tag*,...)"
"sql_print_error(const char*,...)" -> "error_or_warning(const char*,__va_list_tag*,const char*)"
"error_or_warning(const char*,__va_list_tag*,const char*)" -> "vfprintf(FILE*,const char*,__va_list_tag*)"
"error_or_warning(const char*,__va_list_tag*,const char*)" -> "fprintf(FILE*,const char*,...)"
"error_or_warning(const char*,__va_list_tag*,const char*)" -> "__builtin_fputc(int,FILE*)"
"inline_mysql_mutex_destroy(mysql_mutex_t*)" -> "pthread_mutex_destroy(pthread_mutex_t*)"
"release_table_share(TABLE_SHARE*)" -> "TABLE_SHARE::has_old_version() const"
"release_table_share(TABLE_SHARE*)" -> "my_hash_delete(HASH*,uchar*)"
"free_items(Item*)" -> "Item::delete_self()"
"free_field_buffers_larger_than(TABLE*,uint32)" -> "Field_blob::get_field_buffer_size()"
"Field_blob::get_field_buffer_size()" -> "String::alloced_length() const"
"Table_cache::release_table(THD*,TABLE*)" -> "Table_cache_manager::cache_index(Table_cache*) const"
"Table_cache::release_table(THD*,TABLE*)" -> "Table_cache::link_unused_table(TABLE*)"
"Table_cache::release_table(THD*,TABLE*)" -> "I>::push_front(T*) [with T = TABLE,B = I_P_List_adapter<TABLE,&TABLE::cache_next,&TABLE::cache_prev>,C = I_P_List_null_counter,I = I_P_List_no_push_back<TABLE>]"
"Table_cache::release_table(THD*,TABLE*)" -> "Table_cache::free_unused_tables_if_necessary(THD*)"
"Table_cache::release_table(THD*,TABLE*)" -> "Table_cache::assert_owner()"
"Table_cache::release_table(THD*,TABLE*)" -> "I>::remove(T*) [with T = TABLE,B = I_P_List_adapter<TABLE,&TABLE::cache_next,&TABLE::cache_prev>,C = I_P_List_null_counter,I = I_P_List_no_push_back<TABLE>]"
"Table_cache::link_unused_table(TABLE*)" -> "Table_cache::check_unused()"
"I>::push_front(T*) [with T = TABLE,B = I_P_List_adapter<TABLE,&TABLE::cache_next,&TABLE::cache_prev>,C = I_P_List_null_counter,I = I_P_List_no_push_back<TABLE>]" -> "I_P_List_null_counter::inc()"
"I>::push_front(T*) [with T = TABLE,B = I_P_List_adapter<TABLE,&TABLE::cache_next,&TABLE::cache_prev>,C = I_P_List_null_counter,I = I_P_List_no_push_back<TABLE>]" -> "prev>::prev_ptr(T*) [with T = TABLE,T* T::* next = &TABLE::cache_next,T** T::* prev = &TABLE::cache_prev]"
"I>::push_front(T*) [with T = TABLE,B = I_P_List_adapter<TABLE,&TABLE::cache_next,&TABLE::cache_prev>,C = I_P_List_null_counter,I = I_P_List_no_push_back<TABLE>]" -> "prev>::next_ptr(T*) [with T = TABLE,T* T::* next = &TABLE::cache_next,T** T::* prev = &TABLE::cache_prev]"
"I>::push_front(T*) [with T = TABLE,B = I_P_List_adapter<TABLE,&TABLE::cache_next,&TABLE::cache_prev>,C = I_P_List_null_counter,I = I_P_List_no_push_back<TABLE>]" -> "I_P_List_no_push_back<T>::set_last(T**) [with T = TABLE]"
"Table_cache::free_unused_tables_if_necessary(THD*)" -> "inline_mysql_mutex_unlock(mysql_mutex_t*)"
"Table_cache::free_unused_tables_if_necessary(THD*)" -> "intern_close_table(TABLE*)"
"Table_cache::free_unused_tables_if_necessary(THD*)" -> "Table_cache::remove_table(TABLE*)"
"Table_cache::free_unused_tables_if_necessary(THD*)" -> "inline_mysql_mutex_lock(mysql_mutex_t*)"
"Table_cache::lock()" -> "inline_mysql_mutex_lock(mysql_mutex_t*)"
"MDL_context::release_transactional_locks()" -> "MDL_context::release_locks_stored_before(enum_mdl_duration,MDL_ticket*)"
"MDL_context::release_locks_stored_before(enum_mdl_duration,MDL_ticket*)" -> "I>::is_empty() const [with T = MDL_ticket,B = I_P_List_adapter<MDL_ticket,&MDL_ticket::next_in_context,&MDL_ticket::prev_in_context>,C = I_P_List_null_counter,I = I_P_List_no_push_back<MDL_ticket>]"
"MDL_context::release_locks_stored_before(enum_mdl_duration,MDL_ticket*)" -> "L>::operator++(int) [with T = MDL_ticket,L = I_P_List<MDL_ticket,I_P_List_adapter<MDL_ticket,&MDL_ticket::next_in_context,&MDL_ticket::prev_in_context> >]"
"MDL_context::release_locks_stored_before(enum_mdl_duration,MDL_ticket*)" -> "L>::I_P_List_iterator(const L&) [with T = MDL_ticket,L = I_P_List<MDL_ticket,I_P_List_adapter<MDL_ticket,&MDL_ticket::next_in_context,&MDL_ticket::prev_in_context> >]"
"MDL_context::release_locks_stored_before(enum_mdl_duration,MDL_ticket*)" -> "MDL_context::release_lock(enum_mdl_duration,MDL_ticket*)"
"L>::operator++(int) [with T = MDL_ticket,L = I_P_List<MDL_ticket,I_P_List_adapter<MDL_ticket,&MDL_ticket::next_in_context,&MDL_ticket::prev_in_context> >]" -> "prev>::next_ptr(T*) [with T = MDL_ticket,T* T::* next = &MDL_ticket::next_in_context,T** T::* prev = &MDL_ticket::prev_in_context]"
"Locked_tables_list::unlock_locked_tables(THD*)" -> "close_thread_tables(THD*)"
"Locked_tables_list::unlock_locked_tables(THD*)" -> "THD::leave_locked_tables_mode()"
"Locked_tables_list::unlock_locked_tables(THD*)" -> "free_root(MEM_ROOT*,myf)"
"close_thread_tables(THD*)" -> "THD::binlog_flush_pending_rows_event(bool)"
"close_thread_tables(THD*)" -> "THD::leave_locked_tables_mode()"
"close_thread_tables(THD*)" -> "mark_used_tables_as_free_for_reuse(THD*,TABLE*)"
"close_thread_tables(THD*)" -> "free_tmp_table(THD*,TABLE*)"
"close_thread_tables(THD*)" -> "Query_tables_list::requires_prelocking()"
"close_thread_tables(THD*)" -> "mysql_unlock_tables(THD*,MYSQL_LOCK*)"
"close_thread_tables(THD*)" -> "close_open_tables(THD*)"
"close_thread_tables(THD*)" -> "mark_temp_tables_as_free_for_reuse(THD*)"
"THD::binlog_flush_pending_rows_event(bool)" -> "THD::binlog_flush_pending_rows_event(bool,bool)"
"THD::binlog_flush_pending_rows_event(bool,bool)" -> "MYSQL_LOG::is_open()"
"THD::binlog_flush_pending_rows_event(bool,bool)" -> "MYSQL_BIN_LOG::flush_and_set_pending_rows_event(THD*,Rows_log_event*,bool)"
"THD::binlog_flush_pending_rows_event(bool,bool)" -> "Rows_log_event::set_flags(Rows_log_event::flag_set)"
"THD::binlog_flush_pending_rows_event(bool,bool)" -> "THD::binlog_get_pending_rows_event(bool) const"
"MYSQL_BIN_LOG::flush_and_set_pending_rows_event(THD*,Rows_log_event*,bool)" -> "binlog_cache_data::write_event(THD*,Log_event*)"
"MYSQL_BIN_LOG::flush_and_set_pending_rows_event(THD*,Rows_log_event*,bool)" -> "binlog_cache_mngr::get_binlog_cache_data(bool)"
"MYSQL_BIN_LOG::flush_and_set_pending_rows_event(THD*,Rows_log_event*,bool)" -> "binlog_cache_data::set_pending(Rows_log_event*)"
"MYSQL_BIN_LOG::flush_and_set_pending_rows_event(THD*,Rows_log_event*,bool)" -> "binlog_cache_data::set_incident()"
"MYSQL_BIN_LOG::flush_and_set_pending_rows_event(THD*,Rows_log_event*,bool)" -> "thd_get_cache_mngr(const THD*)"
"MYSQL_BIN_LOG::flush_and_set_pending_rows_event(THD*,Rows_log_event*,bool)" -> "stmt_cannot_safely_rollback(const THD*)"
"MYSQL_BIN_LOG::flush_and_set_pending_rows_event(THD*,Rows_log_event*,bool)" -> "binlog_cache_data::pending() const"
"MYSQL_BIN_LOG::flush_and_set_pending_rows_event(THD*,Rows_log_event*,bool)" -> "MYSQL_BIN_LOG::check_write_error(THD*)"
"MYSQL_BIN_LOG::flush_and_set_pending_rows_event(THD*,Rows_log_event*,bool)" -> "MYSQL_BIN_LOG::set_write_error(THD*,bool)"
"binlog_cache_data::write_event(THD*,Log_event*)" -> "Group_cache::add_logged_group(const THD*,my_off_t)"
"binlog_cache_data::write_event(THD*,Log_event*)" -> "binlog_cache_data::is_trx_cache() const"
"binlog_cache_data::write_event(THD*,Log_event*)" -> "Log_event::write(IO_CACHE*)"
"binlog_cache_data::write_event(THD*,Log_event*)" -> "Log_event::is_using_immediate_logging() const"
"binlog_cache_data::write_event(THD*,Log_event*)" -> "Gtid_log_event::Gtid_log_event(THD*,bool,const Gtid_specification*)"
"binlog_cache_data::write_event(THD*,Log_event*)" -> "binlog_cache_data::get_byte_position() const"
"Group_cache::add_logged_group(const THD*,my_off_t)" -> "Gtid_specification::equals(const Gtid_specification&) const"
"Group_cache::add_logged_group(const THD*,my_off_t)" -> "Group_cache::get_last_group()"
"Group_cache::add_logged_group(const THD*,my_off_t)" -> "Group_cache::allocate_group()"
"Gtid_specification::equals(const Gtid_specification&) const" -> "Gtid::equals(const Gtid&) const"
"Group_cache::get_last_group()" -> "Group_cache::get_unsafe_pointer(int) const"
"Group_cache::get_last_group()" -> "Group_cache::get_n_groups() const"
"Group_cache::allocate_group()" -> "my_error(int,myf,...)"
"Group_cache::allocate_group()" -> "alloc_dynamic(DYNAMIC_ARRAY*)"
"Log_event::write(IO_CACHE*)" -> "Log_event::write_header(IO_CACHE*,ulong)"
"Log_event::write(IO_CACHE*)" -> "Log_event::write_footer(IO_CACHE*)"
"Log_event::write_header(IO_CACHE*,ulong)" -> "Log_event::need_checksum()"
"Log_event::write_header(IO_CACHE*,ulong)" -> "Log_event::get_time()"
"Log_event::write_header(IO_CACHE*,ulong)" -> "Log_event::wrapper_my_b_safe_write(IO_CACHE*,const uchar*,ulong)"
"Log_event::write_header(IO_CACHE*,ulong)" -> "my_checksum(ha_checksum,const uchar*,size_t)"
"Log_event::write_header(IO_CACHE*,ulong)" -> "Log_event::is_artificial_event() const"
"Log_event::write_header(IO_CACHE*,ulong)" -> "my_b_safe_tell(IO_CACHE*)"
"Log_event::write_header(IO_CACHE*,ulong)" -> "my_b_safe_write(IO_CACHE*,const uchar*,size_t)"
"Log_event::get_time()" -> "_current_thd()"
"Log_event::get_time()" -> "my_micro_time()"
"Log_event::get_time()" -> "my_micro_time_to_timeval(ulonglong,timeval*)"
"Log_event::wrapper_my_b_safe_write(IO_CACHE*,const uchar*,ulong)" -> "my_checksum(ha_checksum,const uchar*,size_t)"
"Log_event::wrapper_my_b_safe_write(IO_CACHE*,const uchar*,ulong)" -> "my_b_safe_write(IO_CACHE*,const uchar*,size_t)"
"Log_event::wrapper_my_b_safe_write(IO_CACHE*,const uchar*,ulong)" -> "Log_event::need_checksum()"
"Log_event::write_footer(IO_CACHE*)" -> "Log_event::need_checksum()"
"Log_event::write_footer(IO_CACHE*)" -> "my_b_safe_write(IO_CACHE*,const uchar*,size_t)"
"Gtid_log_event::Gtid_log_event(THD*,bool,const Gtid_specification*)" -> "Checkable_rwlock::unlock()"
"Gtid_log_event::Gtid_log_event(THD*,bool,const Gtid_specification*)" -> "Log_event::Log_event(THD*,uint16,Log_event::enum_event_cache_type,Log_event::enum_event_logging_type)"
"Gtid_log_event::Gtid_log_event(THD*,bool,const Gtid_specification*)" -> "Sid_map::sidno_to_sid(rpl_sidno) const"
"Gtid_log_event::Gtid_log_event(THD*,bool,const Gtid_specification*)" -> "Checkable_rwlock::rdlock()"
"Gtid_log_event::Gtid_log_event(THD*,bool,const Gtid_specification*)" -> "Uuid::clear()"
"Sid_map::sidno_to_sid(rpl_sidno) const" -> "Checkable_rwlock::assert_some_lock() const"
"Uuid::clear()" -> "memset(void*,int,size_t)"
"thd_get_cache_mngr(const THD*)" -> "thd_get_ha_data(const THD*,const handlerton*)"
"thd_get_ha_data(const THD*,const handlerton*)" -> "thd_ha_data(const THD*,const handlerton*)"
"stmt_cannot_safely_rollback(const THD*)" -> "THD_TRANS::cannot_safely_rollback() const"
"MYSQL_BIN_LOG::check_write_error(THD*)" -> "THD::get_stmt_da()"
"MYSQL_BIN_LOG::check_write_error(THD*)" -> "Diagnostics_area::sql_errno() const"
"MYSQL_BIN_LOG::check_write_error(THD*)" -> "THD::is_error() const"
"THD::is_error() const" -> "THD::get_stmt_da() const"
"THD::is_error() const" -> "Diagnostics_area::is_error() const"
"MYSQL_BIN_LOG::set_write_error(THD*,bool)" -> "_current_thd()"
"MYSQL_BIN_LOG::set_write_error(THD*,bool)" -> "__errno_location()"
"MYSQL_BIN_LOG::set_write_error(THD*,bool)" -> "MYSQL_BIN_LOG::check_write_error(THD*)"
"MYSQL_BIN_LOG::set_write_error(THD*,bool)" -> "_my_thread_var()"
"MYSQL_BIN_LOG::set_write_error(THD*,bool)" -> "my_error(int,myf,...)"
"MYSQL_BIN_LOG::set_write_error(THD*,bool)" -> "my_message(uint,const char*,myf)"
"MYSQL_BIN_LOG::set_write_error(THD*,bool)" -> "my_strerror(char*,size_t,int)"
"THD::binlog_get_pending_rows_event(bool) const" -> "thd_get_cache_mngr(const THD*)"
"THD::binlog_get_pending_rows_event(bool) const" -> "binlog_cache_mngr::get_binlog_cache_data(bool)"
"THD::binlog_get_pending_rows_event(bool) const" -> "binlog_cache_data::pending() const"
"THD::leave_locked_tables_mode()" -> "Global_read_lock::set_explicit_lock_duration(THD*)"
"THD::leave_locked_tables_mode()" -> "MDL_context::set_transaction_duration_for_all_locks()"
"THD::leave_locked_tables_mode()" -> "mysql_ha_set_explicit_lock_duration(THD*)"
"Global_read_lock::set_explicit_lock_duration(THD*)" -> "MDL_context::set_lock_duration(MDL_ticket*,enum_mdl_duration)"
"MDL_context::set_lock_duration(MDL_ticket*,enum_mdl_duration)" -> "I>::push_front(T*) [with T = MDL_ticket,B = I_P_List_adapter<MDL_ticket,&MDL_ticket::next_in_context,&MDL_ticket::prev_in_context>,C = I_P_List_null_counter,I = I_P_List_no_push_back<MDL_ticket>]"
"MDL_context::set_lock_duration(MDL_ticket*,enum_mdl_duration)" -> "I>::remove(T*) [with T = MDL_ticket,B = I_P_List_adapter<MDL_ticket,&MDL_ticket::next_in_context,&MDL_ticket::prev_in_context>,C = I_P_List_null_counter,I = I_P_List_no_push_back<MDL_ticket>]"
"I>::push_front(T*) [with T = MDL_ticket,B = I_P_List_adapter<MDL_ticket,&MDL_ticket::next_in_context,&MDL_ticket::prev_in_context>,C = I_P_List_null_counter,I = I_P_List_no_push_back<MDL_ticket>]" -> "I_P_List_no_push_back<T>::set_last(T**) [with T = MDL_ticket]"
"I>::push_front(T*) [with T = MDL_ticket,B = I_P_List_adapter<MDL_ticket,&MDL_ticket::next_in_context,&MDL_ticket::prev_in_context>,C = I_P_List_null_counter,I = I_P_List_no_push_back<MDL_ticket>]" -> "I_P_List_null_counter::inc()"
"I>::push_front(T*) [with T = MDL_ticket,B = I_P_List_adapter<MDL_ticket,&MDL_ticket::next_in_context,&MDL_ticket::prev_in_context>,C = I_P_List_null_counter,I = I_P_List_no_push_back<MDL_ticket>]" -> "prev>::prev_ptr(T*) [with T = MDL_ticket,T* T::* next = &MDL_ticket::next_in_context,T** T::* prev = &MDL_ticket::prev_in_context]"
"I>::push_front(T*) [with T = MDL_ticket,B = I_P_List_adapter<MDL_ticket,&MDL_ticket::next_in_context,&MDL_ticket::prev_in_context>,C = I_P_List_null_counter,I = I_P_List_no_push_back<MDL_ticket>]" -> "prev>::next_ptr(T*) [with T = MDL_ticket,T* T::* next = &MDL_ticket::next_in_context,T** T::* prev = &MDL_ticket::prev_in_context]"
"MDL_context::set_transaction_duration_for_all_locks()" -> "L>::operator++(int) [with T = MDL_ticket,L = I_P_List<MDL_ticket,I_P_List_adapter<MDL_ticket,&MDL_ticket::next_in_context,&MDL_ticket::prev_in_context> >]"
"MDL_context::set_transaction_duration_for_all_locks()" -> "I>::swap(I_P_List<T,B,C>&) [with T = MDL_ticket,B = I_P_List_adapter<MDL_ticket,&MDL_ticket::next_in_context,&MDL_ticket::prev_in_context>,C = I_P_List_null_counter,I = I_P_List_no_push_back<MDL_ticket>]"
"MDL_context::set_transaction_duration_for_all_locks()" -> "L>::I_P_List_iterator(const L&) [with T = MDL_ticket,L = I_P_List<MDL_ticket,I_P_List_adapter<MDL_ticket,&MDL_ticket::next_in_context,&MDL_ticket::prev_in_context> >]"
"MDL_context::set_transaction_duration_for_all_locks()" -> "I>::push_front(T*) [with T = MDL_ticket,B = I_P_List_adapter<MDL_ticket,&MDL_ticket::next_in_context,&MDL_ticket::prev_in_context>,C = I_P_List_null_counter,I = I_P_List_no_push_back<MDL_ticket>]"
"MDL_context::set_transaction_duration_for_all_locks()" -> "I>::remove(T*) [with T = MDL_ticket,B = I_P_List_adapter<MDL_ticket,&MDL_ticket::next_in_context,&MDL_ticket::prev_in_context>,C = I_P_List_null_counter,I = I_P_List_no_push_back<MDL_ticket>]"
"I>::swap(I_P_List<T,B,C>&) [with T = MDL_ticket,B = I_P_List_adapter<MDL_ticket,&MDL_ticket::next_in_context,&MDL_ticket::prev_in_context>,C = I_P_List_null_counter,I = I_P_List_no_push_back<MDL_ticket>]" -> "I_P_List_null_counter::swap(I_P_List_null_counter&)"
"I>::swap(I_P_List<T,B,C>&) [with T = MDL_ticket,B = I_P_List_adapter<MDL_ticket,&MDL_ticket::next_in_context,&MDL_ticket::prev_in_context>,C = I_P_List_null_counter,I = I_P_List_no_push_back<MDL_ticket>]" -> "prev>::prev_ptr(T*) [with T = MDL_ticket,T* T::* next = &MDL_ticket::next_in_context,T** T::* prev = &MDL_ticket::prev_in_context]"
"I>::swap(I_P_List<T,B,C>&) [with T = MDL_ticket,B = I_P_List_adapter<MDL_ticket,&MDL_ticket::next_in_context,&MDL_ticket::prev_in_context>,C = I_P_List_null_counter,I = I_P_List_no_push_back<MDL_ticket>]" -> "I_P_List_no_push_back<T>::swap(I_P_List_no_push_back<T>&) [with T = MDL_ticket]"
"I>::swap(I_P_List<T,B,C>&) [with T = MDL_ticket,B = I_P_List_adapter<MDL_ticket,&MDL_ticket::next_in_context,&MDL_ticket::prev_in_context>,C = I_P_List_null_counter,I = I_P_List_no_push_back<MDL_ticket>]" -> "I_P_List_no_push_back<T>::set_last(T**) [with T = MDL_ticket]"
"mysql_ha_set_explicit_lock_duration(THD*)" -> "my_hash_element(HASH*,ulong)"
"mysql_ha_set_explicit_lock_duration(THD*)" -> "MDL_context::set_lock_duration(MDL_ticket*,enum_mdl_duration)"
"mark_used_tables_as_free_for_reuse(THD*,TABLE*)" -> "handler::ha_reset()"
"free_tmp_table(THD*,TABLE*)" -> "plugin_unlock(THD*,plugin_ref)"
"free_tmp_table(THD*,TABLE*)" -> "TABLE::set_deleted()"
"free_tmp_table(THD*,TABLE*)" -> "ha_release_temporary_latches(THD*)"
"free_tmp_table(THD*,TABLE*)" -> "THD::enter_stage(const PSI_stage_info*,PSI_stage_info*,const char*,const char*,unsigned int)"
"free_tmp_table(THD*,TABLE*)" -> "free_io_cache(TABLE*)"
"free_tmp_table(THD*,TABLE*)" -> "set_thd_proc_info(void*,const char*,const char*,const char*,unsigned int)"
"free_tmp_table(THD*,TABLE*)" -> "TABLE::is_created() const"
"free_tmp_table(THD*,TABLE*)" -> "handler::ha_drop_table(const char*)"
"free_tmp_table(THD*,TABLE*)" -> "bitmap_lock_clear_bit(MY_BITMAP*,uint)"
"free_tmp_table(THD*,TABLE*)" -> "handler::ha_delete_table(const char*)"
"free_tmp_table(THD*,TABLE*)" -> "free_root(MEM_ROOT*,myf)"
"free_tmp_table(THD*,TABLE*)" -> "filesort_free_buffers(TABLE*,bool)"
"ha_release_temporary_latches(THD*)" -> "Ha_trx_info::ht() const"
"ha_release_temporary_latches(THD*)" -> "Ha_trx_info::next() const"
"set_thd_proc_info(void*,const char*,const char*,const char*,unsigned int)" -> "set_thd_stage_info(void*,const PSI_stage_info*,PSI_stage_info*,const char*,const char*,unsigned int)"
"handler::ha_drop_table(const char*)" -> "handler::mark_trx_read_write()"
"handler::mark_trx_read_write()" -> "Ha_trx_info::is_started() const"
"handler::mark_trx_read_write()" -> "Ha_trx_info::set_trx_read_write()"
"handler::mark_trx_read_write()" -> "handler::ha_thd() const"
"handler::ha_thd() const" -> "_current_thd()"
"handler::ha_delete_table(const char*)" -> "handler::mark_trx_read_write()"
"filesort_free_buffers(TABLE*,bool)" -> "Filesort_info::free_sort_buffer()"
"filesort_free_buffers(TABLE*,bool)" -> "my_free(void*)"
"Filesort_info::free_sort_buffer()" -> "Filesort_buffer::free_sort_buffer()"
"Filesort_buffer::free_sort_buffer()" -> "Bounds_checked_array<Element_type>::array() const [with Element_type = unsigned char*]"
"Filesort_buffer::free_sort_buffer()" -> "my_free(void*)"
"Filesort_buffer::free_sort_buffer()" -> "Bounds_checked_array<Element_type>::Bounds_checked_array() [with Element_type = unsigned char*]"
"mysql_unlock_tables(THD*,MYSQL_LOCK*)" -> "my_free(void*)"
"mysql_unlock_tables(THD*,MYSQL_LOCK*)" -> "thr_multi_unlock(THR_LOCK_DATA**,uint)"
"mysql_unlock_tables(THD*,MYSQL_LOCK*)" -> "unlock_external(THD*,TABLE**,uint)"
"unlock_external(THD*,TABLE**,uint)" -> "handler::ha_external_lock(THD*,int)"
"unlock_external(THD*,TABLE**,uint)" -> "print_lock_error(int,const char*)"
"handler::ha_external_lock(THD*,int)" -> "handler::ha_statistic_increment(ulonglong system_status_var::*) const"
"print_lock_error(int,const char*)" -> "my_error(int,myf,...)"
"print_lock_error(int,const char*)" -> "my_strerror(char*,size_t,int)"
"close_open_tables(THD*)" -> "close_thread_table(THD*,TABLE**)"
"mark_temp_tables_as_free_for_reuse(THD*)" -> "mark_tmp_table_for_reuse(TABLE*)"
"close_temporary_tables(THD*)" -> "strcmp(const char*,const char*)"
"close_temporary_tables(THD*)" -> "is_user_table(TABLE*)"
"close_temporary_tables(THD*)" -> "MYSQL_LOG::is_open()"
"close_temporary_tables(THD*)" -> "String::append(const char*)"
"close_temporary_tables(THD*)" -> "sql_print_error(const char*,...)"
"close_temporary_tables(THD*)" -> "THD::get_stmt_da()"
"close_temporary_tables(THD*)" -> "String::String()"
"close_temporary_tables(THD*)" -> "MYSQL_BIN_LOG::commit(THD*,bool)"
"close_temporary_tables(THD*)" -> "Gtid_specification::set_automatic()"
"close_temporary_tables(THD*)" -> "memcpy(void*,const void*,size_t)"
"close_temporary_tables(THD*)" -> "append_identifier(THD*,String*,const char*,uint)"
"close_temporary_tables(THD*)" -> "String::append(char)"
"close_temporary_tables(THD*)" -> "modify_slave_open_temp_tables(THD*,int)"
"close_temporary_tables(THD*)" -> "strlen(const char*)"
"close_temporary_tables(THD*)" -> "close_temporary(TABLE*,bool,bool)"
"close_temporary_tables(THD*)" -> "Query_log_event::Query_log_event(THD*,const char*,ulong,bool,bool,bool,int,bool)"
"close_temporary_tables(THD*)" -> "String::ptr() const"
"close_temporary_tables(THD*)" -> "tmpkeyval(THD*,TABLE*)"
"close_temporary_tables(THD*)" -> "THD::clear_error()"
"close_temporary_tables(THD*)" -> "String::String(char*,uint32,const CHARSET_INFO*)"
"close_temporary_tables(THD*)" -> "MYSQL_BIN_LOG::write_event(Log_event*)"
"close_temporary_tables(THD*)" -> "String::length() const"
"close_temporary_tables(THD*)" -> "String::length(uint32)"
"close_temporary_tables(THD*)" -> "Diagnostics_area::set_overwrite_status(bool)"
"is_user_table(TABLE*)" -> "strncmp(const char*,const char*,size_t)"
"String::append(const char*)" -> "String::append(const char*,uint32)"
"String::append(const char*)" -> "strlen(const char*)"
"String::append(const char*,uint32)" -> "copy_and_convert(char*,uint32,const CHARSET_INFO*,const char*,uint32,const CHARSET_INFO*,uint*)"
"String::append(const char*,uint32)" -> "memcpy(void*,const void*,size_t)"
"String::append(const char*,uint32)" -> "String::realloc(uint32)"
"MYSQL_BIN_LOG::commit(THD*,bool)" -> "ending_trans(THD*,bool)"
"MYSQL_BIN_LOG::commit(THD*,bool)" -> "MYSQL_BIN_LOG::ordered_commit(THD*,bool,bool)"
"MYSQL_BIN_LOG::commit(THD*,bool)" -> "binlog_trx_cache_data::set_prev_position(my_off_t)"
"MYSQL_BIN_LOG::commit(THD*,bool)" -> "binlog_cache_data::finalize(THD*,Log_event*)"
"MYSQL_BIN_LOG::commit(THD*,bool)" -> "write_empty_groups_to_cache(THD*,binlog_cache_data*)"
"MYSQL_BIN_LOG::commit(THD*,bool)" -> "binlog_cache_data::is_binlog_empty() const"
"MYSQL_BIN_LOG::commit(THD*,bool)" -> "binlog_stmt_cache_data::finalize(THD*)"
"MYSQL_BIN_LOG::commit(THD*,bool)" -> "thd_get_cache_mngr(const THD*)"
"MYSQL_BIN_LOG::commit(THD*,bool)" -> "Xid_log_event::Xid_log_event(THD*,my_xid)"
"MYSQL_BIN_LOG::commit(THD*,bool)" -> "Query_log_event::Query_log_event(THD*,const char*,ulong,bool,bool,bool,int,bool)"
"MYSQL_BIN_LOG::commit(THD*,bool)" -> "xid_t::get_my_xid()"
"MYSQL_BIN_LOG::commit(THD*,bool)" -> "ha_commit_low(THD*,bool,bool)"
"ending_trans(THD*,bool)" -> "ending_single_stmt_trans(THD*,bool)"
"ending_single_stmt_trans(THD*,bool)" -> "THD::in_multi_stmt_transaction_mode() const"
"MYSQL_BIN_LOG::ordered_commit(THD*,bool,bool)" -> "Stage_manager::signal_done(THD*)"
"MYSQL_BIN_LOG::ordered_commit(THD*,bool,bool)" -> "MYSQL_BIN_LOG::process_commit_stage_queue(THD*,THD*)"
"MYSQL_BIN_LOG::ordered_commit(THD*,bool,bool)" -> "MYSQL_BIN_LOG::flush_cache_to_file(my_off_t*)"
"MYSQL_BIN_LOG::ordered_commit(THD*,bool,bool)" -> "MYSQL_BIN_LOG::sync_binlog_file(bool)"
"MYSQL_BIN_LOG::ordered_commit(THD*,bool,bool)" -> "dirname_length(const char*)"
"MYSQL_BIN_LOG::ordered_commit(THD*,bool,bool)" -> "inline_mysql_mutex_lock(mysql_mutex_t*)"
"MYSQL_BIN_LOG::ordered_commit(THD*,bool,bool)" -> "Stage_manager::fetch_queue_for(Stage_manager::StageID)"
"MYSQL_BIN_LOG::ordered_commit(THD*,bool,bool)" -> "MYSQL_BIN_LOG::purge()"
"MYSQL_BIN_LOG::ordered_commit(THD*,bool,bool)" -> "inline_mysql_mutex_unlock(mysql_mutex_t*)"
"MYSQL_BIN_LOG::ordered_commit(THD*,bool,bool)" -> "MYSQL_BIN_LOG::process_after_commit_stage_queue(THD*,THD*)"
"MYSQL_BIN_LOG::ordered_commit(THD*,bool,bool)" -> "MYSQL_BIN_LOG::signal_update()"
"MYSQL_BIN_LOG::ordered_commit(THD*,bool,bool)" -> "MYSQL_BIN_LOG::finish_commit(THD*)"
"MYSQL_BIN_LOG::ordered_commit(THD*,bool,bool)" -> "sql_print_error(const char*,...)"
"MYSQL_BIN_LOG::ordered_commit(THD*,bool,bool)" -> "Delegate::is_empty()"
"MYSQL_BIN_LOG::ordered_commit(THD*,bool,bool)" -> "MYSQL_BIN_LOG::process_flush_stage_queue(my_off_t*,bool*,THD**)"
"MYSQL_BIN_LOG::ordered_commit(THD*,bool,bool)" -> "MYSQL_BIN_LOG::change_stage(THD*,Stage_manager::StageID,THD*,mysql_mutex_t*,mysql_mutex_t*)"
"MYSQL_BIN_LOG::ordered_commit(THD*,bool,bool)" -> "MYSQL_BIN_LOG::rotate(bool,bool*)"
"MYSQL_BIN_LOG::ordered_commit(THD*,bool,bool)" -> "Binlog_storage_delegate::after_flush(THD*,const char*,my_off_t)"
"MYSQL_BIN_LOG::ordered_commit(THD*,bool,bool)" -> "MYSQL_BIN_LOG::get_sync_period()"
"Stage_manager::signal_done(THD*)" -> "inline_mysql_mutex_lock(mysql_mutex_t*)"
"Stage_manager::signal_done(THD*)" -> "inline_mysql_cond_broadcast(mysql_cond_t*)"
"Stage_manager::signal_done(THD*)" -> "inline_mysql_mutex_unlock(mysql_mutex_t*)"
"MYSQL_BIN_LOG::process_commit_stage_queue(THD*,THD*)" -> "MYSQL_BIN_LOG::dec_prep_xids(THD*)"
"MYSQL_BIN_LOG::process_commit_stage_queue(THD*,THD*)" -> "Thread_excursion::try_to_attach_to(THD*)"
"MYSQL_BIN_LOG::process_commit_stage_queue(THD*,THD*)" -> "Thread_excursion::Thread_excursion(THD*)"
"MYSQL_BIN_LOG::process_commit_stage_queue(THD*,THD*)" -> "ha_commit_low(THD*,bool,bool)"
"MYSQL_BIN_LOG::dec_prep_xids(THD*)" -> "inline_mysql_cond_signal(mysql_cond_t*)"
"MYSQL_BIN_LOG::dec_prep_xids(THD*)" -> "inline_mysql_mutex_unlock(mysql_mutex_t*)"
"MYSQL_BIN_LOG::dec_prep_xids(THD*)" -> "inline_mysql_mutex_lock(mysql_mutex_t*)"
"MYSQL_BIN_LOG::dec_prep_xids(THD*)" -> "my_atomic_add32(volatile int32*,int32)"
"my_atomic_add32(volatile int32*,int32)" -> "__sync_fetch_and_add_4(volatile void*,unsigned int)"
"Thread_excursion::try_to_attach_to(THD*)" -> "Thread_excursion::attach_to(THD*)"
"Thread_excursion::try_to_attach_to(THD*)" -> "_exit(int)"
"Thread_excursion::try_to_attach_to(THD*)" -> "my_safe_printf_stderr(const char*,...)"
"Thread_excursion::try_to_attach_to(THD*)" -> "sql_print_warning(const char*,...)"
"Thread_excursion::try_to_attach_to(THD*)" -> "print_system_time()"
"Thread_excursion::attach_to(THD*)" -> "thd_get_psi(THD*)"
"sql_print_warning(const char*,...)" -> "__builtin_va_end(__va_list_tag*)"
"sql_print_warning(const char*,...)" -> "__builtin_va_start(__va_list_tag*,...)"
"sql_print_warning(const char*,...)" -> "error_log_print(loglevel,const char*,__va_list_tag*)"
"print_system_time()" -> "time(time_t*)"
"print_system_time()" -> "my_safe_itoa(int,longlong,char*)"
"print_system_time()" -> "my_safe_printf_stderr(const char*,...)"
"ha_commit_low(THD*,bool,bool)" -> "Query_cache::invalidate(CHANGED_TABLE_LIST*)"
"ha_commit_low(THD*,bool,bool)" -> "Delegate::is_empty()"
"ha_commit_low(THD*,bool,bool)" -> "my_error(int,myf,...)"
"ha_commit_low(THD*,bool,bool)" -> "Ha_trx_info::next() const"
"ha_commit_low(THD*,bool,bool)" -> "Ha_trx_info::reset()"
"ha_commit_low(THD*,bool,bool)" -> "Ha_trx_info::ht() const"
"ha_commit_low(THD*,bool,bool)" -> "Trans_delegate::after_commit(THD*,bool)"
"ha_commit_low(THD*,bool,bool)" -> "THD::st_transactions::cleanup()"
"Query_cache::invalidate(CHANGED_TABLE_LIST*)" -> "THD::enter_stage(const PSI_stage_info*,PSI_stage_info*,const char*,const char*,unsigned int)"
"Query_cache::invalidate(CHANGED_TABLE_LIST*)" -> "_current_thd()"
"Query_cache::invalidate(CHANGED_TABLE_LIST*)" -> "Query_cache::invalidate_table(THD*,uchar*,uint32)"
"Query_cache::invalidate(CHANGED_TABLE_LIST*)" -> "Query_cache::is_disabled()"
"Query_cache::invalidate_table(THD*,uchar*,uint32)" -> "Query_cache::unlock()"
"Query_cache::invalidate_table(THD*,uchar*,uint32)" -> "Query_cache::invalidate_table_internal(THD*,uchar*,uint32)"
"Query_cache::invalidate_table(THD*,uchar*,uint32)" -> "Query_cache::lock()"
"Query_cache::invalidate_table_internal(THD*,uchar*,uint32)" -> "Query_cache_block::table(uint)"
"Query_cache::invalidate_table_internal(THD*,uchar*,uint32)" -> "my_hash_search(const HASH*,const uchar*,size_t)"
"Query_cache::invalidate_table_internal(THD*,uchar*,uint32)" -> "Query_cache::invalidate_query_block_list(THD*,Query_cache_block_table*)"
"Query_cache::invalidate_query_block_list(THD*,Query_cache_block_table*)" -> "Query_cache_query::lock_writing()"
"Query_cache::invalidate_query_block_list(THD*,Query_cache_block_table*)" -> "Query_cache::free_query(Query_cache_block*)"
"Query_cache::invalidate_query_block_list(THD*,Query_cache_block_table*)" -> "Query_cache_block::query()"
"Query_cache::invalidate_query_block_list(THD*,Query_cache_block_table*)" -> "Query_cache_block_table::block()"
"Query_cache::lock()" -> "inline_mysql_mutex_unlock(mysql_mutex_t*)"
"Query_cache::lock()" -> "_current_thd()"
"Query_cache::lock()" -> "Query_cache_wait_state::Query_cache_wait_state(THD*,const char*,const char*,unsigned int)"
"Query_cache::lock()" -> "inline_mysql_cond_wait(mysql_cond_t*,mysql_mutex_t*)"
"Query_cache::lock()" -> "inline_mysql_mutex_lock(mysql_mutex_t*)"
"Delegate::is_empty()" -> "base_list::is_empty() const"
"Trans_delegate::after_commit(THD*,bool)" -> "plugin_lock(THD*,st_plugin_int**)"
"Trans_delegate::after_commit(THD*,bool)" -> "plugin_unlock_list(THD*,st_plugin_int**,uint)"
"Trans_delegate::after_commit(THD*,bool)" -> "insert_dynamic(DYNAMIC_ARRAY*,const void*)"
"Trans_delegate::after_commit(THD*,bool)" -> "delete_dynamic(DYNAMIC_ARRAY*)"
"Trans_delegate::after_commit(THD*,bool)" -> "Delegate::unlock()"
"Trans_delegate::after_commit(THD*,bool)" -> "List_iterator<T>::operator++(int) [with T = Observer_info]"
"Trans_delegate::after_commit(THD*,bool)" -> "Delegate::observer_info_iter()"
"Trans_delegate::after_commit(THD*,bool)" -> "init_dynamic_array2(DYNAMIC_ARRAY*,uint,void*,uint,uint)"
"Trans_delegate::after_commit(THD*,bool)" -> "THD::get_trans_fixed_pos(const char**,my_off_t*) const"
"Trans_delegate::after_commit(THD*,bool)" -> "Delegate::read_lock()"
"Trans_delegate::after_commit(THD*,bool)" -> "sql_print_error(const char*,...)"
"plugin_lock(THD*,st_plugin_int**)" -> "inline_mysql_mutex_lock(mysql_mutex_t*)"
"plugin_lock(THD*,st_plugin_int**)" -> "inline_mysql_mutex_unlock(mysql_mutex_t*)"
"plugin_lock(THD*,st_plugin_int**)" -> "intern_plugin_lock(LEX*,plugin_ref)"
"plugin_unlock_list(THD*,st_plugin_int**,uint)" -> "reap_plugins()"
"plugin_unlock_list(THD*,st_plugin_int**,uint)" -> "intern_plugin_unlock(LEX*,plugin_ref)"
"plugin_unlock_list(THD*,st_plugin_int**,uint)" -> "inline_mysql_mutex_unlock(mysql_mutex_t*)"
"plugin_unlock_list(THD*,st_plugin_int**,uint)" -> "inline_mysql_mutex_lock(mysql_mutex_t*)"
"Delegate::unlock()" -> "inline_mysql_rwlock_unlock(mysql_rwlock_t*)"
"List_iterator<T>::operator++(int) [with T = Observer_info]" -> "base_list_iterator::next()"
"Delegate::observer_info_iter()" -> "List_iterator<T>::List_iterator(List<T>&) [with T = Observer_info]"
"List_iterator<T>::List_iterator(List<T>&) [with T = Observer_info]" -> "base_list_iterator::base_list_iterator(base_list&)"
"base_list_iterator::base_list_iterator(base_list&)" -> "base_list_iterator::init(base_list&)"
"Delegate::read_lock()" -> "inline_mysql_rwlock_rdlock(mysql_rwlock_t*)"
"MYSQL_BIN_LOG::flush_cache_to_file(my_off_t*)" -> "my_b_flush_io_cache(IO_CACHE*,int)"
"MYSQL_BIN_LOG::sync_binlog_file(bool)" -> "inline_mysql_file_sync(File,myf)"
"MYSQL_BIN_LOG::sync_binlog_file(bool)" -> "MYSQL_BIN_LOG::get_sync_period()"
"MYSQL_BIN_LOG::sync_binlog_file(bool)" -> "std::make_pair(_T1,_T2) [with _T1 = bool,_T2 = bool]"
"inline_mysql_file_sync(File,myf)" -> "my_sync(File,myf)"
"std::make_pair(_T1,_T2) [with _T1 = bool,_T2 = bool]" -> "_T2>::pair(const _T1&,const _T2&) [with _T1 = bool,_T2 = bool]"
"Stage_manager::fetch_queue_for(Stage_manager::StageID)" -> "Stage_manager::Mutex_queue::fetch_and_empty()"
"Stage_manager::Mutex_queue::fetch_and_empty()" -> "Stage_manager::Mutex_queue::lock()"
"Stage_manager::Mutex_queue::fetch_and_empty()" -> "Stage_manager::Mutex_queue::unlock()"
"Stage_manager::Mutex_queue::lock()" -> "inline_mysql_mutex_lock(mysql_mutex_t*)"
"Stage_manager::Mutex_queue::unlock()" -> "inline_mysql_mutex_unlock(mysql_mutex_t*)"
"MYSQL_BIN_LOG::process_after_commit_stage_queue(THD*,THD*)" -> "Thread_excursion::try_to_attach_to(THD*)"
"MYSQL_BIN_LOG::process_after_commit_stage_queue(THD*,THD*)" -> "Thread_excursion::Thread_excursion(THD*)"
"MYSQL_BIN_LOG::process_after_commit_stage_queue(THD*,THD*)" -> "Trans_delegate::after_commit(THD*,bool)"
"MYSQL_BIN_LOG::process_after_commit_stage_queue(THD*,THD*)" -> "Delegate::is_empty()"
"MYSQL_BIN_LOG::signal_update()" -> "inline_mysql_cond_broadcast(mysql_cond_t*)"
"MYSQL_BIN_LOG::finish_commit(THD*)" -> "ha_commit_low(THD*,bool,bool)"
"MYSQL_BIN_LOG::finish_commit(THD*)" -> "Checkable_rwlock::unlock()"
"MYSQL_BIN_LOG::finish_commit(THD*)" -> "MYSQL_BIN_LOG::dec_prep_xids(THD*)"
"MYSQL_BIN_LOG::finish_commit(THD*)" -> "Delegate::is_empty()"
"MYSQL_BIN_LOG::finish_commit(THD*)" -> "Gtid_state::update_on_commit(THD*)"
"MYSQL_BIN_LOG::finish_commit(THD*)" -> "Checkable_rwlock::rdlock()"
"MYSQL_BIN_LOG::finish_commit(THD*)" -> "Trans_delegate::after_commit(THD*,bool)"
"Gtid_state::update_on_commit(THD*)" -> "Gtid_state::update_owned_gtids_impl(THD*,bool)"
"MYSQL_BIN_LOG::process_flush_stage_queue(my_off_t*,bool*,THD**)" -> "Stage_manager::pop_front(Stage_manager::StageID)"
"MYSQL_BIN_LOG::process_flush_stage_queue(my_off_t*,bool*,THD**)" -> "MYSQL_BIN_LOG::flush_thread_caches(THD*)"
"MYSQL_BIN_LOG::process_flush_stage_queue(my_off_t*,bool*,THD**)" -> "my_micro_time()"
"MYSQL_BIN_LOG::process_flush_stage_queue(my_off_t*,bool*,THD**)" -> "Stage_manager::fetch_queue_for(Stage_manager::StageID)"
"MYSQL_BIN_LOG::process_flush_stage_queue(my_off_t*,bool*,THD**)" -> "my_atomic_load32(volatile int32*)"
"Stage_manager::pop_front(Stage_manager::StageID)" -> "Stage_manager::Mutex_queue::pop_front()"
"Stage_manager::Mutex_queue::pop_front()" -> "std::make_pair(_T1,_T2) [with _T1 = bool,_T2 = THD*]"
"Stage_manager::Mutex_queue::pop_front()" -> "Stage_manager::Mutex_queue::lock()"
"Stage_manager::Mutex_queue::pop_front()" -> "Stage_manager::Mutex_queue::unlock()"
"std::make_pair(_T1,_T2) [with _T1 = bool,_T2 = THD*]" -> "_T2>::pair(const _T1&,const _T2&) [with _T1 = bool,_T2 = THD*]"
"MYSQL_BIN_LOG::flush_thread_caches(THD*)" -> "MYSQL_BIN_LOG::inc_prep_xids(THD*)"
"MYSQL_BIN_LOG::flush_thread_caches(THD*)" -> "std::make_pair(_T1,_T2) [with _T1 = int,_T2 = long long unsigned int]"
"MYSQL_BIN_LOG::flush_thread_caches(THD*)" -> "binlog_cache_mngr::flush(THD*,my_off_t*,bool*)"
"MYSQL_BIN_LOG::flush_thread_caches(THD*)" -> "THD::set_trans_pos(const char*,my_off_t)"
"MYSQL_BIN_LOG::flush_thread_caches(THD*)" -> "thd_get_cache_mngr(const THD*)"
"MYSQL_BIN_LOG::inc_prep_xids(THD*)" -> "my_atomic_add32(volatile int32*,int32)"
"std::make_pair(_T1,_T2) [with _T1 = int,_T2 = long long unsigned int]" -> "_T2>::pair(const _T1&,const _T2&) [with _T1 = int,_T2 = long long unsigned int]"
"binlog_cache_mngr::flush(THD*,my_off_t*,bool*)" -> "binlog_cache_data::flush(THD*,my_off_t*,bool*)"
"binlog_cache_data::flush(THD*,my_off_t*,bool*)" -> "gtid_before_write_cache(THD*,binlog_cache_data*)"
"binlog_cache_data::flush(THD*,my_off_t*,bool*)" -> "MYSQL_BIN_LOG::write_cache(THD*,binlog_cache_data*)"
"gtid_before_write_cache(THD*,binlog_cache_data*)" -> "Group_cache::generate_automatic_gno(THD*)"
"gtid_before_write_cache(THD*,binlog_cache_data*)" -> "Checkable_rwlock::unlock()"
"gtid_before_write_cache(THD*,binlog_cache_data*)" -> "Gtid_log_event::Gtid_log_event(THD*,bool,const Gtid_specification*)"
"gtid_before_write_cache(THD*,binlog_cache_data*)" -> "write_empty_groups_to_cache(THD*,binlog_cache_data*)"
"gtid_before_write_cache(THD*,binlog_cache_data*)" -> "Checkable_rwlock::rdlock()"
"gtid_before_write_cache(THD*,binlog_cache_data*)" -> "binlog_cache_data::is_trx_cache() const"
"gtid_before_write_cache(THD*,binlog_cache_data*)" -> "Group_cache::get_unsafe_pointer(int) const"
"gtid_before_write_cache(THD*,binlog_cache_data*)" -> "Log_event::write(IO_CACHE*)"
"gtid_before_write_cache(THD*,binlog_cache_data*)" -> "binlog_cache_data::reset_write_pos(my_off_t,bool)"
"Group_cache::generate_automatic_gno(THD*)" -> "Gtid_state::lock_sidno(rpl_sidno)"
"Group_cache::generate_automatic_gno(THD*)" -> "Group_cache::get_unsafe_pointer(int) const"
"Group_cache::generate_automatic_gno(THD*)" -> "Gtid_state::get_automatic_gno(rpl_sidno) const"
"Group_cache::generate_automatic_gno(THD*)" -> "Gtid_state::get_server_sidno() const"
"Group_cache::generate_automatic_gno(THD*)" -> "Gtid_state::unlock_sidno(rpl_sidno)"
"Group_cache::generate_automatic_gno(THD*)" -> "Group_cache::get_n_groups() const"
"Group_cache::generate_automatic_gno(THD*)" -> "Gtid_state::acquire_ownership(THD*,const Gtid&)"
"Gtid_state::get_automatic_gno(rpl_sidno) const" -> "Interval_p>::next() [with Gtid_set_p = const Gtid_set*,Interval_p = const Gtid_set::Interval*]"
"Gtid_state::get_automatic_gno(rpl_sidno) const" -> "my_error(int,myf,...)"
"Gtid_state::get_automatic_gno(rpl_sidno) const" -> "Owned_gtids::get_owner(const Gtid&) const"
"Gtid_state::get_automatic_gno(rpl_sidno) const" -> "Interval_p>::get() const [with Gtid_set_p = const Gtid_set*,Interval_p = const Gtid_set::Interval*]"
"Gtid_state::get_automatic_gno(rpl_sidno) const" -> "Gtid_set::Const_interval_iterator::Const_interval_iterator(const Gtid_set*,rpl_sidno)"
"Owned_gtids::get_owner(const Gtid&) const" -> "Owned_gtids::get_node(const Gtid&) const"
"Owned_gtids::get_node(const Gtid&) const" -> "Owned_gtids::get_node(const HASH*,rpl_gno) const"
"Owned_gtids::get_node(const Gtid&) const" -> "Owned_gtids::get_hash(rpl_sidno) const"
"Gtid_set::Const_interval_iterator::Const_interval_iterator(const Gtid_set*,rpl_sidno)" -> "Interval_p>::Interval_iterator_base(Gtid_set_p,rpl_sidno) [with Gtid_set_p = const Gtid_set*,Interval_p = const Gtid_set::Interval*,rpl_sidno = int]"
"Interval_p>::Interval_iterator_base(Gtid_set_p,rpl_sidno) [with Gtid_set_p = const Gtid_set*,Interval_p = const Gtid_set::Interval*,rpl_sidno = int]" -> "Interval_p>::init(Gtid_set_p,rpl_sidno) [with Gtid_set_p = const Gtid_set*,Interval_p = const Gtid_set::Interval*,rpl_sidno = int]"
"Gtid_state::acquire_ownership(THD*,const Gtid&)" -> "Checkable_rwlock::assert_some_lock() const"
"Gtid_state::acquire_ownership(THD*,const Gtid&)" -> "Gtid_state::assert_sidno_lock_owner(rpl_sidno)"
"Gtid_state::acquire_ownership(THD*,const Gtid&)" -> "THD::get_gtid_next_list()"
"Gtid_state::acquire_ownership(THD*,const Gtid&)" -> "Gtid_set::clear()"
"Gtid_state::acquire_ownership(THD*,const Gtid&)" -> "Owned_gtids::add_gtid_owner(const Gtid&,my_thread_id)"
"Gtid_state::assert_sidno_lock_owner(rpl_sidno)" -> "Mutex_cond_array::assert_owner(int) const"
"Gtid_set::clear()" -> "Interval_p>::next() [with Gtid_set_p = Gtid_set*,Interval_p = Gtid_set::Interval*]"
"Gtid_set::clear()" -> "Gtid_set::Interval_iterator::set(Gtid_set::Interval*)"
"Gtid_set::clear()" -> "Gtid_set::Interval_iterator::Interval_iterator(Gtid_set*)"
"Gtid_set::clear()" -> "Gtid_set::Interval_iterator::Interval_iterator(Gtid_set*,rpl_sidno)"
"Gtid_set::clear()" -> "Interval_p>::get() const [with Gtid_set_p = Gtid_set*,Interval_p = Gtid_set::Interval*]"
"Gtid_set::clear()" -> "Gtid_set::get_max_sidno() const"
"Gtid_set::Interval_iterator::Interval_iterator(Gtid_set*)" -> "Interval_p>::Interval_iterator_base(Gtid_set_p) [with Gtid_set_p = Gtid_set*,Interval_p = Gtid_set::Interval*]"
"Gtid_set::Interval_iterator::Interval_iterator(Gtid_set*,rpl_sidno)" -> "Interval_p>::Interval_iterator_base(Gtid_set_p,rpl_sidno) [with Gtid_set_p = Gtid_set*,Interval_p = Gtid_set::Interval*,rpl_sidno = int]"
"Interval_p>::Interval_iterator_base(Gtid_set_p,rpl_sidno) [with Gtid_set_p = Gtid_set*,Interval_p = Gtid_set::Interval*,rpl_sidno = int]" -> "Interval_p>::init(Gtid_set_p,rpl_sidno) [with Gtid_set_p = Gtid_set*,Interval_p = Gtid_set::Interval*,rpl_sidno = int]"
"Gtid_set::get_max_sidno() const" -> "Checkable_rwlock::assert_some_lock() const"
"Owned_gtids::add_gtid_owner(const Gtid&,my_thread_id)" -> "my_error(int,myf,...)"
"Owned_gtids::add_gtid_owner(const Gtid&,my_thread_id)" -> "my_malloc(size_t,myf)"
"Owned_gtids::add_gtid_owner(const Gtid&,my_thread_id)" -> "my_free(void*)"
"Owned_gtids::add_gtid_owner(const Gtid&,my_thread_id)" -> "my_hash_insert(HASH*,const uchar*)"
"Owned_gtids::add_gtid_owner(const Gtid&,my_thread_id)" -> "Owned_gtids::get_hash(rpl_sidno) const"
"write_empty_groups_to_cache(THD*,binlog_cache_data*)" -> "write_one_empty_group_to_cache(THD*,binlog_cache_data*,Gtid)"
"write_one_empty_group_to_cache(THD*,binlog_cache_data*,Gtid)" -> "Group_cache::contains_gtid(const Gtid&) const"
"Group_cache::contains_gtid(const Gtid&) const" -> "Gtid_specification::equals(const Gtid&) const"
"Group_cache::contains_gtid(const Gtid&) const" -> "Group_cache::get_n_groups() const"
"Group_cache::contains_gtid(const Gtid&) const" -> "Group_cache::get_unsafe_pointer(int) const"
"Gtid_specification::equals(const Gtid&) const" -> "Gtid::equals(const Gtid&) const"
"binlog_cache_data::reset_write_pos(my_off_t,bool)" -> "my_b_seek(IO_CACHE*,my_off_t)"
"binlog_cache_data::reset_write_pos(my_off_t,bool)" -> "binlog_cache_data::get_byte_position() const"
"binlog_cache_data::reset_write_pos(my_off_t,bool)" -> "reinit_io_cache(IO_CACHE*,cache_type,my_off_t,pbool,pbool)"
"MYSQL_BIN_LOG::write_cache(THD*,binlog_cache_data*)" -> "Checkable_rwlock::unlock()"
"MYSQL_BIN_LOG::write_cache(THD*,binlog_cache_data*)" -> "Gtid_state::update_on_flush(THD*)"
"MYSQL_BIN_LOG::write_cache(THD*,binlog_cache_data*)" -> "MYSQL_BIN_LOG::update_thd_next_event_pos(THD*)"
"MYSQL_BIN_LOG::write_cache(THD*,binlog_cache_data*)" -> "binlog_cache_data::has_incident() const"
"MYSQL_BIN_LOG::write_cache(THD*,binlog_cache_data*)" -> "__builtin_expect(long int,long int)"
"MYSQL_BIN_LOG::write_cache(THD*,binlog_cache_data*)" -> "MYSQL_BIN_LOG::do_write_cache(IO_CACHE*)"
"MYSQL_BIN_LOG::write_cache(THD*,binlog_cache_data*)" -> "my_strerror(char*,size_t,int)"
"MYSQL_BIN_LOG::write_cache(THD*,binlog_cache_data*)" -> "_current_thd()"
"MYSQL_BIN_LOG::write_cache(THD*,binlog_cache_data*)" -> "MYSQL_LOG::is_open()"
"MYSQL_BIN_LOG::write_cache(THD*,binlog_cache_data*)" -> "__errno_location()"
"MYSQL_BIN_LOG::write_cache(THD*,binlog_cache_data*)" -> "MYSQL_BIN_LOG::write_incident(THD*,bool,bool)"
"MYSQL_BIN_LOG::write_cache(THD*,binlog_cache_data*)" -> "Checkable_rwlock::rdlock()"
"MYSQL_BIN_LOG::write_cache(THD*,binlog_cache_data*)" -> "sql_print_error(const char*,...)"
"Gtid_state::update_on_flush(THD*)" -> "Gtid_state::unlock_owned_sidnos(const THD*)"
"Gtid_state::update_on_flush(THD*)" -> "Gtid_set::_add_gtid(const Gtid&)"
"Gtid_state::update_on_flush(THD*)" -> "Gtid_state::lock_sidno(rpl_sidno)"
"Gtid_state::update_on_flush(THD*)" -> "Gtid_state::broadcast_owned_sidnos(const THD*)"
"Gtid_state::update_on_flush(THD*)" -> "Gtid_specification::set_undefined()"
"Gtid_state::update_on_flush(THD*)" -> "Checkable_rwlock::assert_some_lock() const"
"Gtid_set::_add_gtid(const Gtid&)" -> "Gtid_set::_add_gtid(rpl_sidno,rpl_gno)"
"Gtid_set::_add_gtid(rpl_sidno,rpl_gno)" -> "Gtid_set::Interval_iterator::Interval_iterator(Gtid_set*,rpl_sidno)"
"Gtid_set::_add_gtid(rpl_sidno,rpl_gno)" -> "Gtid_set::Free_intervals_lock::Free_intervals_lock(Gtid_set*)"
"Gtid_set::_add_gtid(rpl_sidno,rpl_gno)" -> "Gtid_set::add_gno_interval(Gtid_set::Interval_iterator*,rpl_gno,rpl_gno,Gtid_set::Free_intervals_lock*)"
"Gtid_set::add_gno_interval(Gtid_set::Interval_iterator*,rpl_gno,rpl_gno,Gtid_set::Free_intervals_lock*)" -> "Gtid_set::Interval_iterator::insert(Gtid_set::Interval*)"
"Gtid_set::add_gno_interval(Gtid_set::Interval_iterator*,rpl_gno,rpl_gno,Gtid_set::Free_intervals_lock*)" -> "Interval_p>::next() [with Gtid_set_p = Gtid_set*,Interval_p = Gtid_set::Interval*]"
"Gtid_set::add_gno_interval(Gtid_set::Interval_iterator*,rpl_gno,rpl_gno,Gtid_set::Free_intervals_lock*)" -> "Gtid_set::Free_intervals_lock::lock_if_not_locked()"
"Gtid_set::add_gno_interval(Gtid_set::Interval_iterator*,rpl_gno,rpl_gno,Gtid_set::Free_intervals_lock*)" -> "Gtid_set::Interval_iterator::remove(Gtid_set*)"
"Gtid_set::add_gno_interval(Gtid_set::Interval_iterator*,rpl_gno,rpl_gno,Gtid_set::Free_intervals_lock*)" -> "Interval_p>::get() const [with Gtid_set_p = Gtid_set*,Interval_p = Gtid_set::Interval*]"
"Gtid_set::add_gno_interval(Gtid_set::Interval_iterator*,rpl_gno,rpl_gno,Gtid_set::Free_intervals_lock*)" -> "Gtid_set::get_free_interval(Gtid_set::Interval**)"
"Gtid_set::Interval_iterator::insert(Gtid_set::Interval*)" -> "Gtid_set::Interval_iterator::set(Gtid_set::Interval*)"
"Gtid_set::Free_intervals_lock::lock_if_not_locked()" -> "inline_mysql_mutex_lock(mysql_mutex_t*)"
"Gtid_set::Free_intervals_lock::lock_if_not_locked()" -> "inline_mysql_mutex_lock(mysql_mutex_t*,const char*,uint)"
"inline_mysql_mutex_lock(mysql_mutex_t*,const char*,uint)" -> "pthread_mutex_lock(pthread_mutex_t*)"
"Gtid_set::Interval_iterator::remove(Gtid_set*)" -> "Gtid_set::put_free_interval(Gtid_set::Interval*)"
"Gtid_set::Interval_iterator::remove(Gtid_set*)" -> "Gtid_set::Interval_iterator::set(Gtid_set::Interval*)"
"Gtid_set::put_free_interval(Gtid_set::Interval*)" -> "Gtid_set::Interval_iterator::Interval_iterator(Gtid_set*)"
"Gtid_set::put_free_interval(Gtid_set::Interval*)" -> "Gtid_set::Interval_iterator::set(Gtid_set::Interval*)"
"Gtid_set::put_free_interval(Gtid_set::Interval*)" -> "Gtid_set::assert_free_intervals_locked()"
"Gtid_set::put_free_interval(Gtid_set::Interval*)" -> "Interval_p>::get() const [with Gtid_set_p = Gtid_set*,Interval_p = Gtid_set::Interval*]"
"Gtid_set::get_free_interval(Gtid_set::Interval**)" -> "Gtid_set::Interval_iterator::set(Gtid_set::Interval*)"
"Gtid_set::get_free_interval(Gtid_set::Interval**)" -> "Gtid_set::Interval_iterator::Interval_iterator(Gtid_set*)"
"Gtid_set::get_free_interval(Gtid_set::Interval**)" -> "Gtid_set::create_new_chunk(int)"
"Gtid_set::get_free_interval(Gtid_set::Interval**)" -> "Interval_p>::get() const [with Gtid_set_p = Gtid_set*,Interval_p = Gtid_set::Interval*]"
"Gtid_set::get_free_interval(Gtid_set::Interval**)" -> "Gtid_set::assert_free_intervals_locked()"
"Gtid_set::create_new_chunk(int)" -> "Gtid_set::add_interval_memory_lock_taken(int,Gtid_set::Interval*)"
"Gtid_set::create_new_chunk(int)" -> "Gtid_set::assert_free_intervals_locked()"
"Gtid_set::create_new_chunk(int)" -> "my_malloc(size_t,myf)"
"Gtid_set::add_interval_memory_lock_taken(int,Gtid_set::Interval*)" -> "Gtid_set::assert_free_intervals_locked()"
"Gtid_set::add_interval_memory_lock_taken(int,Gtid_set::Interval*)" -> "Interval_p>::get() const [with Gtid_set_p = Gtid_set*,Interval_p = Gtid_set::Interval*]"
"Gtid_set::add_interval_memory_lock_taken(int,Gtid_set::Interval*)" -> "Gtid_set::Interval_iterator::Interval_iterator(Gtid_set*)"
"Gtid_set::add_interval_memory_lock_taken(int,Gtid_set::Interval*)" -> "Gtid_set::Interval_iterator::set(Gtid_set::Interval*)"
"MYSQL_BIN_LOG::update_thd_next_event_pos(THD*)" -> "THD::set_next_event_pos(const char*,ulonglong)"
"MYSQL_BIN_LOG::update_thd_next_event_pos(THD*)" -> "__builtin_expect(long int,long int)"
"THD::set_next_event_pos(const char*,ulonglong)" -> "my_malloc(size_t,myf)"
"THD::set_next_event_pos(const char*,ulonglong)" -> "strcpy(char*,const char*)"
"THD::set_next_event_pos(const char*,ulonglong)" -> "__assert_fail(const char*,const char*,unsigned int,const char*)"
"THD::set_next_event_pos(const char*,ulonglong)" -> "strlen(const char*)"
"MYSQL_BIN_LOG::do_write_cache(IO_CACHE*)" -> "my_checksum(ha_checksum,const uchar*,size_t)"
"MYSQL_BIN_LOG::do_write_cache(IO_CACHE*)" -> "reinit_io_cache(IO_CACHE*,cache_type,my_off_t,pbool,pbool)"
"MYSQL_BIN_LOG::do_write_cache(IO_CACHE*)" -> "memcpy(void*,const void*,size_t)"
"MYSQL_BIN_LOG::do_write_cache(IO_CACHE*)" -> "__builtin_expect(long int,long int)"
"MYSQL_BIN_LOG::do_write_cache(IO_CACHE*)" -> "my_b_fill(IO_CACHE*)"
"MYSQL_BIN_LOG::do_write_cache(IO_CACHE*)" -> "fix_log_event_crc(uchar*,uint,uint,uint,ha_checksum*)"
"fix_log_event_crc(uchar*,uint,uint,uint,ha_checksum*)" -> "my_checksum(ha_checksum,const uchar*,size_t)"
"MYSQL_BIN_LOG::write_incident(THD*,bool,bool)" -> "MYSQL_BIN_LOG::write_incident(Incident_log_event*,bool,bool)"
"MYSQL_BIN_LOG::write_incident(THD*,bool,bool)" -> "Incident_log_event::Incident_log_event(THD*,Incident,LEX_STRING)"
"MYSQL_BIN_LOG::write_incident(THD*,bool,bool)" -> "MYSQL_LOG::is_open()"
"MYSQL_BIN_LOG::write_incident(Incident_log_event*,bool,bool)" -> "MYSQL_LOG::is_open()"
"MYSQL_BIN_LOG::write_incident(Incident_log_event*,bool,bool)" -> "MYSQL_BIN_LOG::signal_update()"
"MYSQL_BIN_LOG::write_incident(Incident_log_event*,bool,bool)" -> "inline_mysql_mutex_lock(mysql_mutex_t*)"
"MYSQL_BIN_LOG::write_incident(Incident_log_event*,bool,bool)" -> "MYSQL_BIN_LOG::rotate(bool,bool*)"
"MYSQL_BIN_LOG::write_incident(Incident_log_event*,bool,bool)" -> "MYSQL_BIN_LOG::purge()"
"MYSQL_BIN_LOG::write_incident(Incident_log_event*,bool,bool)" -> "inline_mysql_mutex_unlock(mysql_mutex_t*)"
"MYSQL_BIN_LOG::write_incident(Incident_log_event*,bool,bool)" -> "MYSQL_BIN_LOG::flush_and_sync(bool)"
"MYSQL_BIN_LOG::rotate(bool,bool*)" -> "_current_thd()"
"MYSQL_BIN_LOG::rotate(bool,bool*)" -> "MYSQL_BIN_LOG::new_file_without_locking(Format_description_log_event*)"
"MYSQL_BIN_LOG::rotate(bool,bool*)" -> "MYSQL_BIN_LOG::flush_and_sync(bool)"
"MYSQL_BIN_LOG::rotate(bool,bool*)" -> "MYSQL_BIN_LOG::write_incident(THD*,bool,bool)"
"MYSQL_BIN_LOG::rotate(bool,bool*)" -> "sql_print_error(const char*,...)"
"MYSQL_BIN_LOG::new_file_without_locking(Format_description_log_event*)" -> "MYSQL_BIN_LOG::new_file_impl(bool,Format_description_log_event*)"
"MYSQL_BIN_LOG::new_file_impl(bool,Format_description_log_event*)" -> "MYSQL_BIN_LOG::close(uint)"
"MYSQL_BIN_LOG::new_file_impl(bool,Format_description_log_event*)" -> "sql_print_error(const char*,...)"
"MYSQL_BIN_LOG::new_file_impl(bool,Format_description_log_event*)" -> "my_printf_error(uint,const char*,myf,...)"
"MYSQL_BIN_LOG::new_file_impl(bool,Format_description_log_event*)" -> "__errno_location()"
"MYSQL_BIN_LOG::new_file_impl(bool,Format_description_log_event*)" -> "_current_thd()"
"MYSQL_BIN_LOG::new_file_impl(bool,Format_description_log_event*)" -> "my_error(int,myf,...)"
"MYSQL_BIN_LOG::new_file_impl(bool,Format_description_log_event*)" -> "my_free(void*)"
"MYSQL_BIN_LOG::new_file_impl(bool,Format_description_log_event*)" -> "MYSQL_LOG::generate_new_name(char*,const char*)"
"MYSQL_BIN_LOG::new_file_impl(bool,Format_description_log_event*)" -> "inline_mysql_mutex_lock(mysql_mutex_t*)"
"MYSQL_BIN_LOG::new_file_impl(bool,Format_description_log_event*)" -> "MYSQL_BIN_LOG::open_binlog(const char*,const char*,cache_type,ulong,bool,bool,bool,Format_description_log_event*)"
"MYSQL_BIN_LOG::new_file_impl(bool,Format_description_log_event*)" -> "dirname_length(const char*)"
"MYSQL_BIN_LOG::new_file_impl(bool,Format_description_log_event*)" -> "inline_mysql_cond_wait(mysql_cond_t*,mysql_mutex_t*)"
"MYSQL_BIN_LOG::new_file_impl(bool,Format_description_log_event*)" -> "Rotate_log_event::write(IO_CACHE*)"
"MYSQL_BIN_LOG::new_file_impl(bool,Format_description_log_event*)" -> "_exit(int)"
"MYSQL_BIN_LOG::new_file_impl(bool,Format_description_log_event*)" -> "ha_flush_logs(handlerton*)"
"MYSQL_BIN_LOG::new_file_impl(bool,Format_description_log_event*)" -> "THD::clear_error()"
"MYSQL_BIN_LOG::new_file_impl(bool,Format_description_log_event*)" -> "MYSQL_BIN_LOG::open_index_file(const char*,const char*,bool)"
"MYSQL_BIN_LOG::new_file_impl(bool,Format_description_log_event*)" -> "Protocol::end_statement()"
"MYSQL_BIN_LOG::new_file_impl(bool,Format_description_log_event*)" -> "Rotate_log_event::Rotate_log_event(const char*,uint,ulonglong,uint)"
"MYSQL_BIN_LOG::new_file_impl(bool,Format_description_log_event*)" -> "my_strerror(char*,size_t,int)"
"MYSQL_BIN_LOG::new_file_impl(bool,Format_description_log_event*)" -> "MYSQL_BIN_LOG::get_prep_xids()"
"MYSQL_BIN_LOG::new_file_impl(bool,Format_description_log_event*)" -> "MYSQL_BIN_LOG::signal_update()"
"MYSQL_BIN_LOG::new_file_impl(bool,Format_description_log_event*)" -> "MYSQL_LOG::is_open()"
"MYSQL_BIN_LOG::new_file_impl(bool,Format_description_log_event*)" -> "inline_mysql_mutex_unlock(mysql_mutex_t*)"
"MYSQL_BIN_LOG::close(uint)" -> "my_free(void*)"
"MYSQL_BIN_LOG::close(uint)" -> "my_strerror(char*,size_t,int)"
"MYSQL_BIN_LOG::close(uint)" -> "sql_print_error(const char*,...)"
"MYSQL_BIN_LOG::close(uint)" -> "MYSQL_LOG::close(uint)"
"MYSQL_BIN_LOG::close(uint)" -> "end_io_cache(IO_CACHE*)"
"MYSQL_BIN_LOG::close(uint)" -> "_current_thd()"
"MYSQL_BIN_LOG::close(uint)" -> "inline_mysql_file_pwrite(File,const uchar*,size_t,my_off_t,myf)"
"MYSQL_BIN_LOG::close(uint)" -> "inline_mysql_file_seek(File,my_off_t,int,myf)"
"MYSQL_BIN_LOG::close(uint)" -> "inline_mysql_file_close(File,myf)"
"MYSQL_BIN_LOG::close(uint)" -> "inline_mysql_file_tell(File,myf)"
"MYSQL_BIN_LOG::close(uint)" -> "__errno_location()"
"MYSQL_LOG::close(uint)" -> "my_strerror(char*,size_t,int)"
"MYSQL_LOG::close(uint)" -> "sql_print_error(const char*,...)"
"MYSQL_LOG::close(uint)" -> "end_io_cache(IO_CACHE*)"
"MYSQL_LOG::close(uint)" -> "inline_mysql_file_sync(File,myf)"
"MYSQL_LOG::close(uint)" -> "__errno_location()"
"MYSQL_LOG::close(uint)" -> "inline_mysql_file_close(File,myf)"
"MYSQL_LOG::close(uint)" -> "my_free(void*)"
"inline_mysql_file_close(File,myf)" -> "my_close(File,myf)"
"inline_mysql_file_pwrite(File,const uchar*,size_t,my_off_t,myf)" -> "my_pwrite(File,const uchar*,size_t,my_off_t,myf)"
"inline_mysql_file_seek(File,my_off_t,int,myf)" -> "my_seek(File,my_off_t,int,myf)"
"inline_mysql_file_tell(File,myf)" -> "my_tell(File,myf)"
"MYSQL_LOG::generate_new_name(char*,const char*)" -> "_current_thd()"
"MYSQL_LOG::generate_new_name(char*,const char*)" -> "find_uniq_filename(char*)"
"MYSQL_LOG::generate_new_name(char*,const char*)" -> "my_printf_error(uint,const char*,myf,...)"
"MYSQL_LOG::generate_new_name(char*,const char*)" -> "sql_print_error(const char*,...)"
"MYSQL_LOG::generate_new_name(char*,const char*)" -> "fn_ext(const char*)"
"MYSQL_LOG::generate_new_name(char*,const char*)" -> "fn_format(char*,const char*,const char*,const char*,uint)"
"find_uniq_filename(char*)" -> "strlen(const char*)"
"find_uniq_filename(char*)" -> "my_dir(const char*,myf)"
"find_uniq_filename(char*)" -> "memcmp(const void*,const void*,size_t)"
"find_uniq_filename(char*)" -> "dirname_part(char*,const char*,size_t*)"
"find_uniq_filename(char*)" -> "sql_print_warning(const char*,...)"
"find_uniq_filename(char*)" -> "sql_print_error(const char*,...)"
"find_uniq_filename(char*)" -> "strend(const char*)"
"find_uniq_filename(char*)" -> "test_if_number(const char*,ulong*,bool)"
"find_uniq_filename(char*)" -> "__builtin_memcpy(void*,const void*,long unsigned int)"
"find_uniq_filename(char*)" -> "my_dirend(MY_DIR*)"
"find_uniq_filename(char*)" -> "sprintf(char*,const char*,...)"
"test_if_number(const char*,ulong*,bool)" -> "atol(const char*)"
"atol(const char*)" -> "strtol(const char*,char**,int)"
"MYSQL_BIN_LOG::open_binlog(const char*,const char*,cache_type,ulong,bool,bool,bool,Format_description_log_event*)" -> "THD::clear_error()"
"MYSQL_BIN_LOG::open_binlog(const char*,const char*,cache_type,ulong,bool,bool,bool,Format_description_log_event*)" -> "Log_event::set_artificial_event()"
"MYSQL_BIN_LOG::open_binlog(const char*,const char*,cache_type,ulong,bool,bool,bool,Format_description_log_event*)" -> "my_free(void*)"
"MYSQL_BIN_LOG::open_binlog(const char*,const char*,cache_type,ulong,bool,bool,bool,Format_description_log_event*)" -> "Checkable_rwlock::assert_some_wrlock() const"
"MYSQL_BIN_LOG::open_binlog(const char*,const char*,cache_type,ulong,bool,bool,bool,Format_description_log_event*)" -> "Previous_gtids_log_event::Previous_gtids_log_event(const Gtid_set*)"
"MYSQL_BIN_LOG::open_binlog(const char*,const char*,cache_type,ulong,bool,bool,bool,Format_description_log_event*)" -> "MYSQL_BIN_LOG::add_log_to_index(uchar*,int,bool)"
"MYSQL_BIN_LOG::open_binlog(const char*,const char*,cache_type,ulong,bool,bool,bool,Format_description_log_event*)" -> "sql_print_error(const char*,...)"
"MYSQL_BIN_LOG::open_binlog(const char*,const char*,cache_type,ulong,bool,bool,bool,Format_description_log_event*)" -> "Format_description_log_event::is_valid() const"
"MYSQL_BIN_LOG::open_binlog(const char*,const char*,cache_type,ulong,bool,bool,bool,Format_description_log_event*)" -> "my_b_safe_write(IO_CACHE*,const uchar*,size_t)"
"MYSQL_BIN_LOG::open_binlog(const char*,const char*,cache_type,ulong,bool,bool,bool,Format_description_log_event*)" -> "__errno_location()"
"MYSQL_BIN_LOG::open_binlog(const char*,const char*,cache_type,ulong,bool,bool,bool,Format_description_log_event*)" -> "Format_description_log_event::Format_description_log_event(uint8,const char*)"
"MYSQL_BIN_LOG::open_binlog(const char*,const char*,cache_type,ulong,bool,bool,bool,Format_description_log_event*)" -> "MYSQL_LOG::open(PSI_file_key,const char*,enum_log_type,const char*,cache_type)"
"MYSQL_BIN_LOG::open_binlog(const char*,const char*,cache_type,ulong,bool,bool,bool,Format_description_log_event*)" -> "inline_mysql_file_close(File,myf)"
"MYSQL_BIN_LOG::open_binlog(const char*,const char*,cache_type,ulong,bool,bool,bool,Format_description_log_event*)" -> "_exit(int)"
"MYSQL_BIN_LOG::open_binlog(const char*,const char*,cache_type,ulong,bool,bool,bool,Format_description_log_event*)" -> "Checkable_rwlock::unlock()"
"MYSQL_BIN_LOG::open_binlog(const char*,const char*,cache_type,ulong,bool,bool,bool,Format_description_log_event*)" -> "inline_mysql_file_sync(File,myf)"
"MYSQL_BIN_LOG::open_binlog(const char*,const char*,cache_type,ulong,bool,bool,bool,Format_description_log_event*)" -> "Format_description_log_event::write(IO_CACHE*)"
"MYSQL_BIN_LOG::open_binlog(const char*,const char*,cache_type,ulong,bool,bool,bool,Format_description_log_event*)" -> "Log_event::set_relay_log_event()"
"MYSQL_BIN_LOG::open_binlog(const char*,const char*,cache_type,ulong,bool,bool,bool,Format_description_log_event*)" -> "Previous_gtids_log_event::write(IO_CACHE*)"
"MYSQL_BIN_LOG::open_binlog(const char*,const char*,cache_type,ulong,bool,bool,bool,Format_description_log_event*)" -> "Protocol::end_statement()"
"MYSQL_BIN_LOG::open_binlog(const char*,const char*,cache_type,ulong,bool,bool,bool,Format_description_log_event*)" -> "my_b_flush_io_cache(IO_CACHE*,int)"
"MYSQL_BIN_LOG::open_binlog(const char*,const char*,cache_type,ulong,bool,bool,bool,Format_description_log_event*)" -> "strlen(const char*)"
"MYSQL_BIN_LOG::open_binlog(const char*,const char*,cache_type,ulong,bool,bool,bool,Format_description_log_event*)" -> "Checkable_rwlock::wrlock()"
"MYSQL_BIN_LOG::open_binlog(const char*,const char*,cache_type,ulong,bool,bool,bool,Format_description_log_event*)" -> "end_io_cache(IO_CACHE*)"
"MYSQL_BIN_LOG::open_binlog(const char*,const char*,cache_type,ulong,bool,bool,bool,Format_description_log_event*)" -> "MYSQL_LOG::init_and_set_log_file_name(const char*,const char*,enum_log_type,cache_type)"
"MYSQL_BIN_LOG::open_binlog(const char*,const char*,cache_type,ulong,bool,bool,bool,Format_description_log_event*)" -> "_current_thd()"
"MYSQL_BIN_LOG::open_binlog(const char*,const char*,cache_type,ulong,bool,bool,bool,Format_description_log_event*)" -> "my_error(int,myf,...)"
"MYSQL_BIN_LOG::open_binlog(const char*,const char*,cache_type,ulong,bool,bool,bool,Format_description_log_event*)" -> "my_b_filelength(IO_CACHE*)"
"THD::clear_error()" -> "Diagnostics_area::reset_diagnostics_area()"
"THD::clear_error()" -> "Diagnostics_area::is_error() const"
"THD::clear_error()" -> "THD::get_stmt_da()"
"Previous_gtids_log_event::Previous_gtids_log_event(const Gtid_set*)" -> "Log_event::Log_event(Log_event::enum_event_cache_type,Log_event::enum_event_logging_type)"
"Previous_gtids_log_event::Previous_gtids_log_event(const Gtid_set*)" -> "Checkable_rwlock::assert_some_lock() const"
"Previous_gtids_log_event::Previous_gtids_log_event(const Gtid_set*)" -> "Gtid_set::get_encoded_length() const"
"Previous_gtids_log_event::Previous_gtids_log_event(const Gtid_set*)" -> "Gtid_set::encode(uchar*) const"
"Previous_gtids_log_event::Previous_gtids_log_event(const Gtid_set*)" -> "my_malloc(size_t,myf)"
"Previous_gtids_log_event::Previous_gtids_log_event(const Gtid_set*)" -> "Log_event::register_temp_buf(char*)"
"Gtid_set::get_encoded_length() const" -> "Checkable_rwlock::assert_some_wrlock() const"
"Gtid_set::get_encoded_length() const" -> "Gtid_set::get_max_sidno() const"
"Gtid_set::get_encoded_length() const" -> "Gtid_set::get_n_intervals(rpl_sidno) const"
"Gtid_set::get_encoded_length() const" -> "Gtid_set::contains_sidno(rpl_sidno) const"
"Gtid_set::get_n_intervals(rpl_sidno) const" -> "Gtid_set::Const_interval_iterator::Const_interval_iterator(const Gtid_set*,rpl_sidno)"
"Gtid_set::get_n_intervals(rpl_sidno) const" -> "Interval_p>::next() [with Gtid_set_p = const Gtid_set*,Interval_p = const Gtid_set::Interval*]"
"Gtid_set::get_n_intervals(rpl_sidno) const" -> "Interval_p>::get() const [with Gtid_set_p = const Gtid_set*,Interval_p = const Gtid_set::Interval*]"
"Gtid_set::contains_sidno(rpl_sidno) const" -> "Gtid_set::get_max_sidno() const"
"Gtid_set::contains_sidno(rpl_sidno) const" -> "Interval_p>::get() const [with Gtid_set_p = const Gtid_set*,Interval_p = const Gtid_set::Interval*]"
"Gtid_set::contains_sidno(rpl_sidno) const" -> "Gtid_set::Const_interval_iterator::Const_interval_iterator(const Gtid_set*,rpl_sidno)"
"Gtid_set::encode(uchar*) const" -> "Uuid::copy_to(uchar*) const"
"Gtid_set::encode(uchar*) const" -> "Interval_p>::get() const [with Gtid_set_p = const Gtid_set*,Interval_p = const Gtid_set::Interval*]"
"Gtid_set::encode(uchar*) const" -> "Checkable_rwlock::assert_some_wrlock() const"
"Gtid_set::encode(uchar*) const" -> "Interval_p>::next() [with Gtid_set_p = const Gtid_set*,Interval_p = const Gtid_set::Interval*]"
"Gtid_set::encode(uchar*) const" -> "Gtid_set::get_max_sidno() const"
"Gtid_set::encode(uchar*) const" -> "Sid_map::get_sorted_sidno(rpl_sidno) const"
"Gtid_set::encode(uchar*) const" -> "Gtid_set::Const_interval_iterator::Const_interval_iterator(const Gtid_set*,rpl_sidno)"
"Gtid_set::encode(uchar*) const" -> "Sid_map::get_max_sidno() const"
"Gtid_set::encode(uchar*) const" -> "Sid_map::sidno_to_sid(rpl_sidno) const"
"Uuid::copy_to(uchar*) const" -> "memcpy(void*,const void*,size_t)"
"Sid_map::get_sorted_sidno(rpl_sidno) const" -> "Checkable_rwlock::assert_some_lock() const"
"Sid_map::get_max_sidno() const" -> "Checkable_rwlock::assert_some_lock() const"
"MYSQL_BIN_LOG::add_log_to_index(uchar*,int,bool)" -> "MYSQL_BIN_LOG::open_crash_safe_index_file()"
"MYSQL_BIN_LOG::add_log_to_index(uchar*,int,bool)" -> "MYSQL_BIN_LOG::move_crash_safe_index_file_to_index_file(bool)"
"MYSQL_BIN_LOG::add_log_to_index(uchar*,int,bool)" -> "memcpy(void*,const void*,size_t)"
"MYSQL_BIN_LOG::add_log_to_index(uchar*,int,bool)" -> "copy_file(IO_CACHE*,IO_CACHE*,my_off_t)"
"MYSQL_BIN_LOG::add_log_to_index(uchar*,int,bool)" -> "MYSQL_BIN_LOG::close_crash_safe_index_file()"
"MYSQL_BIN_LOG::add_log_to_index(uchar*,int,bool)" -> "sql_print_error(const char*,...)"
"MYSQL_BIN_LOG::add_log_to_index(uchar*,int,bool)" -> "inline_mysql_file_sync(File,myf)"
"MYSQL_BIN_LOG::add_log_to_index(uchar*,int,bool)" -> "my_b_flush_io_cache(IO_CACHE*,int)"
"MYSQL_BIN_LOG::open_crash_safe_index_file()" -> "my_open(const char*,int,myf)"
"MYSQL_BIN_LOG::open_crash_safe_index_file()" -> "sql_print_error(const char*,...)"
"MYSQL_BIN_LOG::open_crash_safe_index_file()" -> "init_io_cache(IO_CACHE*,File,size_t,cache_type,my_off_t,pbool,myf)"
"MYSQL_BIN_LOG::move_crash_safe_index_file_to_index_file(bool)" -> "my_rename(const char*,const char*,myf)"
"MYSQL_BIN_LOG::move_crash_safe_index_file_to_index_file(bool)" -> "inline_mysql_file_open(const char*,int,myf)"
"MYSQL_BIN_LOG::move_crash_safe_index_file_to_index_file(bool)" -> "end_io_cache(IO_CACHE*)"
"MYSQL_BIN_LOG::move_crash_safe_index_file_to_index_file(bool)" -> "sql_print_error(const char*,...)"
"MYSQL_BIN_LOG::move_crash_safe_index_file_to_index_file(bool)" -> "inline_mysql_file_seek(File,my_off_t,int,myf)"
"MYSQL_BIN_LOG::move_crash_safe_index_file_to_index_file(bool)" -> "inline_mysql_file_delete(const char*,myf)"
"MYSQL_BIN_LOG::move_crash_safe_index_file_to_index_file(bool)" -> "inline_mysql_file_sync(File,myf)"
"MYSQL_BIN_LOG::move_crash_safe_index_file_to_index_file(bool)" -> "inline_mysql_mutex_lock(mysql_mutex_t*)"
"MYSQL_BIN_LOG::move_crash_safe_index_file_to_index_file(bool)" -> "inline_mysql_mutex_unlock(mysql_mutex_t*)"
"MYSQL_BIN_LOG::move_crash_safe_index_file_to_index_file(bool)" -> "init_io_cache(IO_CACHE*,File,size_t,cache_type,my_off_t,pbool,myf)"
"MYSQL_BIN_LOG::move_crash_safe_index_file_to_index_file(bool)" -> "inline_mysql_file_close(File,myf)"
"inline_mysql_file_open(const char*,int,myf)" -> "my_open(const char*,int,myf)"
"inline_mysql_file_delete(const char*,myf)" -> "my_delete(const char*,myf)"
"copy_file(IO_CACHE*,IO_CACHE*,my_off_t)" -> "inline_mysql_file_read(File,uchar*,size_t,myf)"
"copy_file(IO_CACHE*,IO_CACHE*,my_off_t)" -> "inline_mysql_file_write(File,const uchar*,size_t,myf)"
"copy_file(IO_CACHE*,IO_CACHE*,my_off_t)" -> "inline_mysql_file_seek(File,my_off_t,int,myf)"
"inline_mysql_file_read(File,uchar*,size_t,myf)" -> "my_read(File,uchar*,size_t,myf)"
"inline_mysql_file_write(File,const uchar*,size_t,myf)" -> "my_write(File,const uchar*,size_t,myf)"
"MYSQL_BIN_LOG::close_crash_safe_index_file()" -> "my_close(File,myf)"
"MYSQL_BIN_LOG::close_crash_safe_index_file()" -> "end_io_cache(IO_CACHE*)"
"MYSQL_BIN_LOG::close_crash_safe_index_file()" -> "memset(void*,int,size_t)"
"Format_description_log_event::is_valid() const" -> "Format_description_log_event::header_is_valid() const"
"Format_description_log_event::is_valid() const" -> "Format_description_log_event::version_is_valid() const"
"Format_description_log_event::Format_description_log_event(uint8,const char*)" -> "memcpy(void*,const void*,size_t)"
"Format_description_log_event::Format_description_log_event(uint8,const char*)" -> "Start_log_event_v3::Start_log_event_v3()"
"Format_description_log_event::Format_description_log_event(uint8,const char*)" -> "__builtin_strcpy(char*,const char*)"
"Format_description_log_event::Format_description_log_event(uint8,const char*)" -> "my_malloc(size_t,myf)"
"Format_description_log_event::Format_description_log_event(uint8,const char*)" -> "Format_description_log_event::calc_server_version_split()"
"Start_log_event_v3::Start_log_event_v3()" -> "Log_event::Log_event(Log_event::enum_event_cache_type,Log_event::enum_event_logging_type)"
"Start_log_event_v3::Start_log_event_v3()" -> "memcpy(void*,const void*,size_t)"
"Format_description_log_event::calc_server_version_split()" -> "do_server_version_split(char*,uchar*)"
"do_server_version_split(char*,uchar*)" -> "strtoul(const char*,char**,int)"
"MYSQL_LOG::open(PSI_file_key,const char*,enum_log_type,const char*,cache_type)" -> "sql_print_error(const char*,...)"
"MYSQL_LOG::open(PSI_file_key,const char*,enum_log_type,const char*,cache_type)" -> "my_error(int,myf,...)"
"MYSQL_LOG::open(PSI_file_key,const char*,enum_log_type,const char*,cache_type)" -> "my_b_flush_io_cache(IO_CACHE*,int)"
"MYSQL_LOG::open(PSI_file_key,const char*,enum_log_type,const char*,cache_type)" -> "inline_mysql_file_open(const char*,int,myf)"
"MYSQL_LOG::open(PSI_file_key,const char*,enum_log_type,const char*,cache_type)" -> "_current_thd()"
"MYSQL_LOG::open(PSI_file_key,const char*,enum_log_type,const char*,cache_type)" -> "end_io_cache(IO_CACHE*)"
"MYSQL_LOG::open(PSI_file_key,const char*,enum_log_type,const char*,cache_type)" -> "MYSQL_LOG::init_and_set_log_file_name(const char*,const char*,enum_log_type,cache_type)"
"MYSQL_LOG::open(PSI_file_key,const char*,enum_log_type,const char*,cache_type)" -> "my_stat(const char*,stat*,myf)"
"MYSQL_LOG::open(PSI_file_key,const char*,enum_log_type,const char*,cache_type)" -> "my_free(void*)"
"MYSQL_LOG::open(PSI_file_key,const char*,enum_log_type,const char*,cache_type)" -> "__errno_location()"
"MYSQL_LOG::open(PSI_file_key,const char*,enum_log_type,const char*,cache_type)" -> "strnmov(char*,const char*,size_t)"
"MYSQL_LOG::open(PSI_file_key,const char*,enum_log_type,const char*,cache_type)" -> "init_io_cache(IO_CACHE*,File,size_t,cache_type,my_off_t,pbool,myf)"
"MYSQL_LOG::open(PSI_file_key,const char*,enum_log_type,const char*,cache_type)" -> "memcpy(void*,const void*,size_t)"
"MYSQL_LOG::open(PSI_file_key,const char*,enum_log_type,const char*,cache_type)" -> "inline_mysql_file_tell(File,myf)"
"MYSQL_LOG::open(PSI_file_key,const char*,enum_log_type,const char*,cache_type)" -> "_my_thread_var()"
"MYSQL_LOG::open(PSI_file_key,const char*,enum_log_type,const char*,cache_type)" -> "my_snprintf(char*,size_t,const char*,...)"
"MYSQL_LOG::open(PSI_file_key,const char*,enum_log_type,const char*,cache_type)" -> "THD::clear_error()"
"MYSQL_LOG::open(PSI_file_key,const char*,enum_log_type,const char*,cache_type)" -> "my_strdup(const char*,myf)"
"MYSQL_LOG::open(PSI_file_key,const char*,enum_log_type,const char*,cache_type)" -> "Protocol::end_statement()"
"MYSQL_LOG::open(PSI_file_key,const char*,enum_log_type,const char*,cache_type)" -> "inline_mysql_file_close(File,myf)"
"MYSQL_LOG::open(PSI_file_key,const char*,enum_log_type,const char*,cache_type)" -> "_exit(int)"
"MYSQL_LOG::init_and_set_log_file_name(const char*,const char*,enum_log_type,cache_type)" -> "MYSQL_LOG::init(enum_log_type,cache_type)"
"MYSQL_LOG::init_and_set_log_file_name(const char*,const char*,enum_log_type,cache_type)" -> "MYSQL_LOG::generate_new_name(char*,const char*)"
"MYSQL_LOG::init_and_set_log_file_name(const char*,const char*,enum_log_type,cache_type)" -> "__builtin_stpcpy(char*,const char*)"
"Protocol::end_statement()" -> "Diagnostics_area::statement_warn_count() const"
"Protocol::end_statement()" -> "Diagnostics_area::last_insert_id() const"
"Protocol::end_statement()" -> "Diagnostics_area::sql_errno() const"
"Protocol::end_statement()" -> "Diagnostics_area::status() const"
"Protocol::end_statement()" -> "Diagnostics_area::affected_rows() const"
"Protocol::end_statement()" -> "Diagnostics_area::set_is_sent(bool)"
"Protocol::end_statement()" -> "Diagnostics_area::is_sent() const"
"Protocol::end_statement()" -> "THD::get_stmt_da()"
"Protocol::end_statement()" -> "Diagnostics_area::message() const"
"Protocol::end_statement()" -> "Diagnostics_area::get_sqlstate() const"
"Format_description_log_event::write(IO_CACHE*)" -> "memcpy(void*,const void*,size_t)"
"Format_description_log_event::write(IO_CACHE*)" -> "Log_event::write_header(IO_CACHE*,ulong)"
"Format_description_log_event::write(IO_CACHE*)" -> "Log_event::wrapper_my_b_safe_write(IO_CACHE*,const uchar*,ulong)"
"Format_description_log_event::write(IO_CACHE*)" -> "Log_event::need_checksum()"
"Format_description_log_event::write(IO_CACHE*)" -> "Log_event::write_footer(IO_CACHE*)"
"Format_description_log_event::write(IO_CACHE*)" -> "Log_event::get_time()"
"Previous_gtids_log_event::write(IO_CACHE*)" -> "Log_event::write_data_header(IO_CACHE*)"
"Previous_gtids_log_event::write(IO_CACHE*)" -> "Log_event::write_header(IO_CACHE*,ulong)"
"Previous_gtids_log_event::write(IO_CACHE*)" -> "Log_event::write_footer(IO_CACHE*)"
"Checkable_rwlock::wrlock()" -> "inline_mysql_rwlock_wrlock(mysql_rwlock_t*)"
"Checkable_rwlock::wrlock()" -> "Checkable_rwlock::assert_no_lock() const"
"Checkable_rwlock::wrlock()" -> "inline_mysql_rwlock_wrlock(mysql_rwlock_t*,const char*,uint)"
"inline_mysql_rwlock_wrlock(mysql_rwlock_t*,const char*,uint)" -> "pthread_rwlock_wrlock(pthread_rwlock_t*)"
"Rotate_log_event::write(IO_CACHE*)" -> "Log_event::write_footer(IO_CACHE*)"
"Rotate_log_event::write(IO_CACHE*)" -> "Log_event::wrapper_my_b_safe_write(IO_CACHE*,const uchar*,ulong)"
"Rotate_log_event::write(IO_CACHE*)" -> "Log_event::write_header(IO_CACHE*,ulong)"
"ha_flush_logs(handlerton*)" -> "plugin_foreach_with_mask(THD*,my_bool (*)(THD*,plugin_ref,void*),int,uint,void*)"
"plugin_foreach_with_mask(THD*,my_bool (*)(THD*,plugin_ref,void*),int,uint,void*)" -> "my_hash_element(HASH*,ulong)"
"plugin_foreach_with_mask(THD*,my_bool (*)(THD*,plugin_ref,void*),int,uint,void*)" -> "__builtin_alloca(long unsigned int)"
"plugin_foreach_with_mask(THD*,my_bool (*)(THD*,plugin_ref,void*),int,uint,void*)" -> "__builtin_expect(long int,long int)"
"plugin_foreach_with_mask(THD*,my_bool (*)(THD*,plugin_ref,void*),int,uint,void*)" -> "inline_mysql_mutex_lock(mysql_mutex_t*)"
"plugin_foreach_with_mask(THD*,my_bool (*)(THD*,plugin_ref,void*),int,uint,void*)" -> "inline_mysql_mutex_unlock(mysql_mutex_t*)"
"MYSQL_BIN_LOG::open_index_file(const char*,const char*,bool)" -> "MYSQL_BIN_LOG::set_crash_safe_index_file_name(const char*)"
"MYSQL_BIN_LOG::open_index_file(const char*,const char*,bool)" -> "access(const char*,int)"
"MYSQL_BIN_LOG::open_index_file(const char*,const char*,bool)" -> "my_rename(const char*,const char*,myf)"
"MYSQL_BIN_LOG::open_index_file(const char*,const char*,bool)" -> "inline_mysql_file_seek(File,my_off_t,int,myf)"
"MYSQL_BIN_LOG::open_index_file(const char*,const char*,bool)" -> "inline_mysql_file_open(const char*,int,myf)"
"MYSQL_BIN_LOG::open_index_file(const char*,const char*,bool)" -> "fn_format(char*,const char*,const char*,const char*,uint)"
"MYSQL_BIN_LOG::open_index_file(const char*,const char*,bool)" -> "inline_mysql_file_sync(File,myf)"
"MYSQL_BIN_LOG::open_index_file(const char*,const char*,bool)" -> "sql_print_error(const char*,...)"
"MYSQL_BIN_LOG::open_index_file(const char*,const char*,bool)" -> "init_io_cache(IO_CACHE*,File,size_t,cache_type,my_off_t,pbool,myf)"
"MYSQL_BIN_LOG::open_index_file(const char*,const char*,bool)" -> "inline_mysql_file_close(File,myf)"
"MYSQL_BIN_LOG::set_crash_safe_index_file_name(const char*)" -> "sql_print_error(const char*,...)"
"MYSQL_BIN_LOG::set_crash_safe_index_file_name(const char*)" -> "fn_format(char*,const char*,const char*,const char*,uint)"
"Rotate_log_event::Rotate_log_event(const char*,uint,ulonglong,uint)" -> "Log_event::Log_event(Log_event::enum_event_cache_type,Log_event::enum_event_logging_type)"
"Rotate_log_event::Rotate_log_event(const char*,uint,ulonglong,uint)" -> "strlen(const char*)"
"Rotate_log_event::Rotate_log_event(const char*,uint,ulonglong,uint)" -> "Log_event::set_relay_log_event()"
"Rotate_log_event::Rotate_log_event(const char*,uint,ulonglong,uint)" -> "my_strndup(const char*,size_t,myf)"
"MYSQL_BIN_LOG::get_prep_xids()" -> "my_atomic_load32(volatile int32*)"
"my_atomic_load32(volatile int32*)" -> "__sync_fetch_and_or_4(volatile void*,unsigned int)"
"MYSQL_BIN_LOG::flush_and_sync(bool)" -> "my_b_flush_io_cache(IO_CACHE*,int)"
"MYSQL_BIN_LOG::flush_and_sync(bool)" -> "MYSQL_BIN_LOG::sync_binlog_file(bool)"
"Incident_log_event::Incident_log_event(THD*,Incident,LEX_STRING)" -> "Log_event::Log_event(THD*,uint16,Log_event::enum_event_cache_type,Log_event::enum_event_logging_type)"
"Incident_log_event::Incident_log_event(THD*,Incident,LEX_STRING)" -> "strmake(char*,const char*,size_t)"
"Incident_log_event::Incident_log_event(THD*,Incident,LEX_STRING)" -> "my_malloc(size_t,myf)"
"THD::set_trans_pos(const char*,my_off_t)" -> "dirname_length(const char*)"
"THD::set_trans_pos(const char*,my_off_t)" -> "alloc_root(MEM_ROOT*,size_t)"
"THD::set_trans_pos(const char*,my_off_t)" -> "strcpy(char*,const char*)"
"MYSQL_BIN_LOG::change_stage(THD*,Stage_manager::StageID,THD*,mysql_mutex_t*,mysql_mutex_t*)" -> "Stage_manager::enroll_for(Stage_manager::StageID,THD*,mysql_mutex_t*)"
"MYSQL_BIN_LOG::change_stage(THD*,Stage_manager::StageID,THD*,mysql_mutex_t*,mysql_mutex_t*)" -> "inline_mysql_mutex_lock(mysql_mutex_t*)"
"Stage_manager::enroll_for(Stage_manager::StageID,THD*,mysql_mutex_t*)" -> "Stage_manager::Mutex_queue::append(THD*)"
"Stage_manager::enroll_for(Stage_manager::StageID,THD*,mysql_mutex_t*)" -> "inline_mysql_cond_wait(mysql_cond_t*,mysql_mutex_t*)"
"Stage_manager::enroll_for(Stage_manager::StageID,THD*,mysql_mutex_t*)" -> "inline_mysql_mutex_unlock(mysql_mutex_t*)"
"Stage_manager::enroll_for(Stage_manager::StageID,THD*,mysql_mutex_t*)" -> "inline_mysql_mutex_lock(mysql_mutex_t*)"
"Stage_manager::Mutex_queue::append(THD*)" -> "Stage_manager::Mutex_queue::lock()"
"Stage_manager::Mutex_queue::append(THD*)" -> "Stage_manager::Mutex_queue::unlock()"
"Binlog_storage_delegate::after_flush(THD*,const char*,my_off_t)" -> "Delegate::read_lock()"
"Binlog_storage_delegate::after_flush(THD*,const char*,my_off_t)" -> "init_dynamic_array2(DYNAMIC_ARRAY*,uint,void*,uint,uint)"
"Binlog_storage_delegate::after_flush(THD*,const char*,my_off_t)" -> "plugin_lock(THD*,st_plugin_int**)"
"Binlog_storage_delegate::after_flush(THD*,const char*,my_off_t)" -> "Delegate::unlock()"
"Binlog_storage_delegate::after_flush(THD*,const char*,my_off_t)" -> "List_iterator<T>::operator++(int) [with T = Observer_info]"
"Binlog_storage_delegate::after_flush(THD*,const char*,my_off_t)" -> "plugin_unlock_list(THD*,st_plugin_int**,uint)"
"Binlog_storage_delegate::after_flush(THD*,const char*,my_off_t)" -> "Delegate::observer_info_iter()"
"Binlog_storage_delegate::after_flush(THD*,const char*,my_off_t)" -> "insert_dynamic(DYNAMIC_ARRAY*,const void*)"
"Binlog_storage_delegate::after_flush(THD*,const char*,my_off_t)" -> "sql_print_error(const char*,...)"
"Binlog_storage_delegate::after_flush(THD*,const char*,my_off_t)" -> "delete_dynamic(DYNAMIC_ARRAY*)"
"binlog_cache_data::finalize(THD*,Log_event*)" -> "binlog_cache_data::flush_pending_event(THD*)"
"binlog_cache_data::finalize(THD*,Log_event*)" -> "binlog_cache_data::write_event(THD*,Log_event*)"
"binlog_cache_data::finalize(THD*,Log_event*)" -> "binlog_cache_data::is_binlog_empty() const"
"binlog_cache_data::flush_pending_event(THD*)" -> "Rows_log_event::set_flags(Rows_log_event::flag_set)"
"binlog_cache_data::flush_pending_event(THD*)" -> "binlog_cache_data::write_event(THD*,Log_event*)"
"binlog_cache_data::flush_pending_event(THD*)" -> "THD::clear_binlog_table_maps()"
"binlog_cache_data::is_binlog_empty() const" -> "binlog_cache_data::pending() const"
"binlog_stmt_cache_data::finalize(THD*)" -> "Query_log_event::Query_log_event(THD*,const char*,ulong,bool,bool,bool,int,bool)"
"binlog_stmt_cache_data::finalize(THD*)" -> "binlog_cache_data::finalize(THD*,Log_event*)"
"Query_log_event::Query_log_event(THD*,const char*,ulong,bool,bool,bool,int,bool)" -> "THD::in_multi_stmt_transaction_mode() const"
"Query_log_event::Query_log_event(THD*,const char*,ulong,bool,bool,bool,int,bool)" -> "my_micro_time()"
"Query_log_event::Query_log_event(THD*,const char*,ulong,bool,bool,bool,int,bool)" -> "stmt_has_updated_trans_table(const THD*)"
"Query_log_event::Query_log_event(THD*,const char*,ulong,bool,bool,bool,int,bool)" -> "my_micro_time_to_timeval(ulonglong,timeval*)"
"Query_log_event::Query_log_event(THD*,const char*,ulong,bool,bool,bool,int,bool)" -> "sqlcom_can_generate_row_events(const THD*)"
"Query_log_event::Query_log_event(THD*,const char*,ulong,bool,bool,bool,int,bool)" -> "strlen(const char*)"
"Query_log_event::Query_log_event(THD*,const char*,ulong,bool,bool,bool,int,bool)" -> "Query_tables_list::is_mixed_stmt_unsafe(bool,bool,bool,uint)"
"Query_log_event::Query_log_event(THD*,const char*,ulong,bool,bool,bool,int,bool)" -> "trans_has_updated_trans_table(const THD*)"
"Query_log_event::Query_log_event(THD*,const char*,ulong,bool,bool,bool,int,bool)" -> "memset(void*,int,size_t)"
"Query_log_event::Query_log_event(THD*,const char*,ulong,bool,bool,bool,int,bool)" -> "String::ptr() const"
"Query_log_event::Query_log_event(THD*,const char*,ulong,bool,bool,bool,int,bool)" -> "THD::is_current_stmt_binlog_format_row() const"
"Query_log_event::Query_log_event(THD*,const char*,ulong,bool,bool,bool,int,bool)" -> "String::length() const"
"Query_log_event::Query_log_event(THD*,const char*,ulong,bool,bool,bool,int,bool)" -> "Log_event::Log_event(THD*,uint16,Log_event::enum_event_cache_type,Log_event::enum_event_logging_type)"
"stmt_has_updated_trans_table(const THD*)" -> "Ha_trx_info::next() const"
"stmt_has_updated_trans_table(const THD*)" -> "Ha_trx_info::is_trx_read_write() const"
"stmt_has_updated_trans_table(const THD*)" -> "Ha_trx_info::ht() const"
"Query_tables_list::is_mixed_stmt_unsafe(bool,bool,bool,uint)" -> "Query_tables_list::stmt_accessed_table(Query_tables_list::enum_stmt_accessed_table)"
"trans_has_updated_trans_table(const THD*)" -> "thd_get_cache_mngr(const THD*)"
"trans_has_updated_trans_table(const THD*)" -> "binlog_cache_data::is_binlog_empty() const"
"Xid_log_event::Xid_log_event(THD*,my_xid)" -> "Log_event::Log_event(THD*,uint16,Log_event::enum_event_cache_type,Log_event::enum_event_logging_type)"
"xid_t::get_my_xid()" -> "xid_t::quick_get_my_xid()"
"xid_t::get_my_xid()" -> "memcmp(const void*,const void*,size_t)"
"append_identifier(THD*,String*,const char*,uint)" -> "get_quote_char_for_identifier(THD*,const char*,uint)"
"append_identifier(THD*,String*,const char*,uint)" -> "String::append(const char*,uint32,const CHARSET_INFO*)"
"append_identifier(THD*,String*,const char*,uint)" -> "String::charset() const"
"append_identifier(THD*,String*,const char*,uint)" -> "String::reserve(uint32)"
"get_quote_char_for_identifier(THD*,const char*,uint)" -> "is_keyword(const char*,uint)"
"get_quote_char_for_identifier(THD*,const char*,uint)" -> "require_quotes(const char*,uint)"
"is_keyword(const char*,uint)" -> "get_hash_symbol(const char*,unsigned int,bool)"
"get_hash_symbol(const char*,unsigned int,bool)" -> "lex_casecmp(const char*,const char*,uint)"
"String::reserve(uint32)" -> "String::realloc(uint32)"
"String::append(char)" -> "String::realloc(uint32)"
"modify_slave_open_temp_tables(THD*,int)" -> "my_atomic_add32(volatile int32*,int32)"
"close_temporary(TABLE*,bool,bool)" -> "TABLE_SHARE::db_type() const"
"close_temporary(TABLE*,bool,bool)" -> "rm_temporary_table(handlerton*,const char*)"
"close_temporary(TABLE*,bool,bool)" -> "closefrm(TABLE*,bool)"
"close_temporary(TABLE*,bool,bool)" -> "my_free(void*)"
"close_temporary(TABLE*,bool,bool)" -> "free_table_share(TABLE_SHARE*)"
"close_temporary(TABLE*,bool,bool)" -> "free_io_cache(TABLE*)"
"rm_temporary_table(handlerton*,const char*)" -> "strxnmov(char*,size_t,const char*,...)"
"rm_temporary_table(handlerton*,const char*)" -> "inline_mysql_file_delete(const char*,myf)"
"rm_temporary_table(handlerton*,const char*)" -> "sql_print_warning(const char*,...)"
"rm_temporary_table(handlerton*,const char*)" -> "_my_thread_var()"
"rm_temporary_table(handlerton*,const char*)" -> "get_new_handler(TABLE_SHARE*,MEM_ROOT*,handlerton*)"
"rm_temporary_table(handlerton*,const char*)" -> "handler::ha_delete_table(const char*)"
"rm_temporary_table(handlerton*,const char*)" -> "_current_thd()"
"get_new_handler(TABLE_SHARE*,MEM_ROOT*,handlerton*)" -> "get_new_handler(TABLE_SHARE*,MEM_ROOT*,handlerton*)"
"get_new_handler(TABLE_SHARE*,MEM_ROOT*,handlerton*)" -> "ha_default_handlerton(THD*)"
"get_new_handler(TABLE_SHARE*,MEM_ROOT*,handlerton*)" -> "handler::init()"
"get_new_handler(TABLE_SHARE*,MEM_ROOT*,handlerton*)" -> "_current_thd()"
"ha_default_handlerton(THD*)" -> "ha_default_plugin(THD*)"
"ha_default_plugin(THD*)" -> "plugin_lock(THD*,st_plugin_int**)"
"MYSQL_BIN_LOG::write_event(Log_event*)" -> "binlog_cache_mngr::get_binlog_cache_data(bool)"
"MYSQL_BIN_LOG::write_event(Log_event*)" -> "binlog_cache_data::write_event(THD*,Log_event*)"
"MYSQL_BIN_LOG::write_event(Log_event*)" -> "Simple_cstring::length() const"
"MYSQL_BIN_LOG::write_event(Log_event*)" -> "Query_tables_list::requires_prelocking()"
"MYSQL_BIN_LOG::write_event(Log_event*)" -> "THD::binlog_flush_pending_rows_event(bool,bool)"
"MYSQL_BIN_LOG::write_event(Log_event*)" -> "Simple_cstring::ptr() const"
"MYSQL_BIN_LOG::write_event(Log_event*)" -> "binlog_cache_data::set_incident()"
"MYSQL_BIN_LOG::write_event(Log_event*)" -> "binlog_trx_cache_data::set_cannot_rollback()"
"MYSQL_BIN_LOG::write_event(Log_event*)" -> "User_var_log_event::User_var_log_event(THD*,const char*,uint,char*,ulong,Item_result,uint,uchar,Log_event::enum_event_cache_type,Log_event::enum_event_logging_type)"
"MYSQL_BIN_LOG::write_event(Log_event*)" -> "thd_get_cache_mngr(const THD*)"
"MYSQL_BIN_LOG::write_event(Log_event*)" -> "Intvar_log_event::Intvar_log_event(THD*,uchar,ulonglong,Log_event::enum_event_cache_type,Log_event::enum_event_logging_type)"
"MYSQL_BIN_LOG::write_event(Log_event*)" -> "__builtin_expect(long int,long int)"
"MYSQL_BIN_LOG::write_event(Log_event*)" -> "THD::is_current_stmt_binlog_format_row() const"
"MYSQL_BIN_LOG::write_event(Log_event*)" -> "Log_event::is_using_trans_cache() const"
"MYSQL_BIN_LOG::write_event(Log_event*)" -> "binlog_start_trans_and_stmt(THD*,Log_event*)"
"MYSQL_BIN_LOG::write_event(Log_event*)" -> "get_dynamic(DYNAMIC_ARRAY*,void*,uint)"
"MYSQL_BIN_LOG::write_event(Log_event*)" -> "stmt_cannot_safely_rollback(const THD*)"
"MYSQL_BIN_LOG::write_event(Log_event*)" -> "MYSQL_BIN_LOG::set_write_error(THD*,bool)"
"MYSQL_BIN_LOG::write_event(Log_event*)" -> "Discrete_intervals_list::minimum() const"
"MYSQL_BIN_LOG::write_event(Log_event*)" -> "MYSQL_LOG::is_open()"
"MYSQL_BIN_LOG::write_event(Log_event*)" -> "MYSQL_BIN_LOG::check_write_error(THD*)"
"MYSQL_BIN_LOG::write_event(Log_event*)" -> "Discrete_intervals_list::nb_elements() const"
"MYSQL_BIN_LOG::write_event(Log_event*)" -> "Rand_log_event::Rand_log_event(THD*,ulonglong,ulonglong,Log_event::enum_event_cache_type,Log_event::enum_event_logging_type)"
"User_var_log_event::User_var_log_event(THD*,const char*,uint,char*,ulong,Item_result,uint,uchar,Log_event::enum_event_cache_type,Log_event::enum_event_logging_type)" -> "Log_event::Log_event(THD*,uint16,Log_event::enum_event_cache_type,Log_event::enum_event_logging_type)"
"Intvar_log_event::Intvar_log_event(THD*,uchar,ulonglong,Log_event::enum_event_cache_type,Log_event::enum_event_logging_type)" -> "Log_event::Log_event(THD*,uint16,Log_event::enum_event_cache_type,Log_event::enum_event_logging_type)"
"binlog_start_trans_and_stmt(THD*,Log_event*)" -> "thd_get_cache_mngr(const THD*)"
"binlog_start_trans_and_stmt(THD*,Log_event*)" -> "Log_event::is_using_trans_cache() const"
"binlog_start_trans_and_stmt(THD*,Log_event*)" -> "THD::binlog_setup_trx_data()"
"binlog_start_trans_and_stmt(THD*,Log_event*)" -> "THD::in_multi_stmt_transaction_mode() const"
"binlog_start_trans_and_stmt(THD*,Log_event*)" -> "Query_log_event::Query_log_event(THD*,const char*,ulong,bool,bool,bool,int,bool)"
"binlog_start_trans_and_stmt(THD*,Log_event*)" -> "register_binlog_handler(THD*,bool)"
"binlog_start_trans_and_stmt(THD*,Log_event*)" -> "Log_event::is_using_immediate_logging() const"
"binlog_start_trans_and_stmt(THD*,Log_event*)" -> "binlog_cache_data::write_event(THD*,Log_event*)"
"binlog_start_trans_and_stmt(THD*,Log_event*)" -> "binlog_cache_data::is_binlog_empty() const"
"binlog_start_trans_and_stmt(THD*,Log_event*)" -> "binlog_cache_mngr::get_binlog_cache_data(bool)"
"THD::binlog_setup_trx_data()" -> "thd_get_cache_mngr(const THD*)"
"THD::binlog_setup_trx_data()" -> "my_free(void*)"
"THD::binlog_setup_trx_data()" -> "open_cached_file(IO_CACHE*,const char*,const char*,size_t,myf)"
"THD::binlog_setup_trx_data()" -> "thd_set_ha_data(THD*,const handlerton*,const void*)"
"THD::binlog_setup_trx_data()" -> "binlog_cache_mngr::binlog_cache_mngr(my_off_t,ulong*,ulong*,my_off_t,ulong*,ulong*)"
"THD::binlog_setup_trx_data()" -> "my_malloc(size_t,myf)"
"THD::binlog_setup_trx_data()" -> "my_tmpdir(MY_TMPDIR*)"
"thd_set_ha_data(THD*,const handlerton*,const void*)" -> "thd_ha_data(const THD*,const handlerton*)"
"thd_set_ha_data(THD*,const handlerton*,const void*)" -> "ha_lock_engine(THD*,const handlerton*)"
"thd_set_ha_data(THD*,const handlerton*,const void*)" -> "plugin_unlock(THD*,plugin_ref)"
"ha_lock_engine(THD*,const handlerton*)" -> "plugin_lock(THD*,st_plugin_int**)"
"binlog_cache_mngr::binlog_cache_mngr(my_off_t,ulong*,ulong*,my_off_t,ulong*,ulong*)" -> "binlog_trx_cache_data::binlog_trx_cache_data(bool,my_off_t,ulong*,ulong*)"
"binlog_cache_mngr::binlog_cache_mngr(my_off_t,ulong*,ulong*,my_off_t,ulong*,ulong*)" -> "binlog_stmt_cache_data::binlog_stmt_cache_data(bool,my_off_t,ulong*,ulong*)"
"binlog_trx_cache_data::binlog_trx_cache_data(bool,my_off_t,ulong*,ulong*)" -> "binlog_cache_data::binlog_cache_data(bool,my_off_t,ulong*,ulong*)"
"binlog_cache_data::binlog_cache_data(bool,my_off_t,ulong*,ulong*)" -> "Group_cache::Group_cache()"
"binlog_cache_data::binlog_cache_data(bool,my_off_t,ulong*,ulong*)" -> "binlog_cache_data::reset()"
"Group_cache::Group_cache()" -> "init_dynamic_array2(DYNAMIC_ARRAY*,uint,void*,uint,uint)"
"binlog_cache_data::reset()" -> "sql_print_warning(const char*,...)"
"binlog_cache_data::reset()" -> "binlog_cache_data::truncate(my_off_t)"
"binlog_cache_data::reset()" -> "binlog_cache_data::compute_statistics()"
"binlog_cache_data::reset()" -> "Group_cache::clear()"
"binlog_cache_data::reset()" -> "my_chsize(File,my_off_t,int,myf)"
"binlog_cache_data::truncate(my_off_t)" -> "binlog_cache_data::remove_pending_event()"
"binlog_cache_data::truncate(my_off_t)" -> "reinit_io_cache(IO_CACHE*,cache_type,my_off_t,pbool,pbool)"
"binlog_cache_data::compute_statistics()" -> "binlog_cache_data::is_binlog_empty() const"
"binlog_stmt_cache_data::binlog_stmt_cache_data(bool,my_off_t,ulong*,ulong*)" -> "binlog_cache_data::binlog_cache_data(bool,my_off_t,ulong*,ulong*)"
"register_binlog_handler(THD*,bool)" -> "trans_register_ha(THD*,bool,handlerton*)"
"register_binlog_handler(THD*,bool)" -> "binlog_trans_log_savepos(THD*,my_off_t*)"
"register_binlog_handler(THD*,bool)" -> "binlog_trx_cache_data::get_prev_position() const"
"register_binlog_handler(THD*,bool)" -> "binlog_trx_cache_data::set_prev_position(my_off_t)"
"register_binlog_handler(THD*,bool)" -> "thd_get_cache_mngr(const THD*)"
"register_binlog_handler(THD*,bool)" -> "Ha_trx_info::set_trx_read_write()"
"trans_register_ha(THD*,bool,handlerton*)" -> "Ha_trx_info::register_ha(THD_TRANS*,handlerton*)"
"trans_register_ha(THD*,bool,handlerton*)" -> "Ha_trx_info::is_started() const"
"trans_register_ha(THD*,bool,handlerton*)" -> "xid_t::is_null()"
"trans_register_ha(THD*,bool,handlerton*)" -> "xid_t::set(ulonglong)"
"xid_t::set(ulonglong)" -> "xid_t::set(long int,long int,const char*)"
"xid_t::set(long int,long int,const char*)" -> "memcpy(void*,const void*,size_t)"
"binlog_trans_log_savepos(THD*,my_off_t*)" -> "thd_get_cache_mngr(const THD*)"
"binlog_trans_log_savepos(THD*,my_off_t*)" -> "binlog_cache_data::get_byte_position() const"
"Discrete_intervals_list::minimum() const" -> "Discrete_interval::minimum() const"
"Rand_log_event::Rand_log_event(THD*,ulonglong,ulonglong,Log_event::enum_event_cache_type,Log_event::enum_event_logging_type)" -> "Log_event::Log_event(THD*,uint16,Log_event::enum_event_cache_type,Log_event::enum_event_logging_type)"
"xid_cache_delete(XID_STATE*)" -> "inline_mysql_mutex_lock(mysql_mutex_t*)"
"xid_cache_delete(XID_STATE*)" -> "my_hash_delete(HASH*,uchar*)"
"xid_cache_delete(XID_STATE*)" -> "inline_mysql_mutex_unlock(mysql_mutex_t*)"
"Statement_map::reset()" -> "my_hash_reset(HASH*)"
"Statement_map::reset()" -> "inline_mysql_mutex_unlock(mysql_mutex_t*)"
"Statement_map::reset()" -> "inline_mysql_mutex_lock(mysql_mutex_t*)"
"mysqld_stmt_close(THD*,char*,uint)" -> "Prepared_statement::deallocate()"
"mysqld_stmt_close(THD*,char*,uint)" -> "general_log_print(THD*,enum_server_command,const char*,...)"
"mysqld_stmt_close(THD*,char*,uint)" -> "THD::get_command() const"
"mysqld_stmt_close(THD*,char*,uint)" -> "my_error(int,myf,...)"
"mysqld_stmt_close(THD*,char*,uint)" -> "Diagnostics_area::disable_status()"
"mysqld_stmt_close(THD*,char*,uint)" -> "find_prepared_statement(THD*,ulong)"
"mysqld_stmt_close(THD*,char*,uint)" -> "THD::get_stmt_da()"
"Prepared_statement::deallocate()" -> "Statement_map::erase(Statement*)"
"Statement_map::erase(Statement*)" -> "inline_mysql_mutex_unlock(mysql_mutex_t*)"
"Statement_map::erase(Statement*)" -> "inline_mysql_mutex_lock(mysql_mutex_t*)"
"Statement_map::erase(Statement*)" -> "my_hash_delete(HASH*,uchar*)"
"PROFILING::start_new_query(const char*)" -> "PROFILING::finish_current_query()"
"PROFILING::start_new_query(const char*)" -> "__builtin_expect(long int,long int)"
"PROFILING::start_new_query(const char*)" -> "QUERY_PROFILE::QUERY_PROFILE(PROFILING*,const char*)"
"PROFILING::finish_current_query()" -> "Queue<T>::pop() [with T = QUERY_PROFILE]"
"PROFILING::finish_current_query()" -> "Queue<T>::push_back(T*) [with T = QUERY_PROFILE]"
"PROFILING::finish_current_query()" -> "Queue<T>::is_empty() [with T = PROF_MEASUREMENT]"
"PROFILING::finish_current_query()" -> "PROFILING::next_profile_id()"
"PROFILING::finish_current_query()" -> "PROFILING::status_change(const char*,const char*,const char*,unsigned int)"
"Queue<T>::pop() [with T = QUERY_PROFILE]" -> "my_free(void*)"
"Queue<T>::push_back(T*) [with T = QUERY_PROFILE]" -> "my_malloc(size_t,myf)"
"QUERY_PROFILE::QUERY_PROFILE(PROFILING*,const char*)" -> "PROF_MEASUREMENT::PROF_MEASUREMENT(QUERY_PROFILE*,const char*)"
"QUERY_PROFILE::QUERY_PROFILE(PROFILING*,const char*)" -> "Queue<T>::Queue() [with T = PROF_MEASUREMENT]"
"QUERY_PROFILE::QUERY_PROFILE(PROFILING*,const char*)" -> "Queue<T>::push_back(T*) [with T = PROF_MEASUREMENT]"
"sql_kill(THD*,ulong,bool)" -> "kill_one_thread(THD*,ulong,bool)"
"sql_kill(THD*,ulong,bool)" -> "my_error(int,myf,...)"
"sql_kill(THD*,ulong,bool)" -> "my_ok(THD*,ulonglong,ulonglong,const char*)"
"kill_one_thread(THD*,ulong,bool)" -> "std::_Rb_tree_const_iterator<_Tp>::operator*() const [with _Tp = THD*,std::_Rb_tree_const_iterator<_Tp>::reference = THD* const&]"
"kill_one_thread(THD*,ulong,bool)" -> "std::_Rb_tree_const_iterator<_Tp>::operator++() [with _Tp = THD*,std::_Rb_tree_const_iterator<_Tp>::_Self = std::_Rb_tree_const_iterator<THD*>]"
"kill_one_thread(THD*,ulong,bool)" -> "THD::awake(THD::killed_state)"
"kill_one_thread(THD*,ulong,bool)" -> "inline_mysql_mutex_lock(mysql_mutex_t*)"
"kill_one_thread(THD*,ulong,bool)" -> "std::_Rb_tree_const_iterator<_Tp>::operator!=(const _Self&) const [with _Tp = THD*,std::_Rb_tree_const_iterator<_Tp>::_Self = std::_Rb_tree_const_iterator<THD*>]"
"kill_one_thread(THD*,ulong,bool)" -> "THD::get_command() const"
"kill_one_thread(THD*,ulong,bool)" -> "Security_context::user_matches(Security_context*)"
"kill_one_thread(THD*,ulong,bool)" -> "inline_mysql_mutex_unlock(mysql_mutex_t*)"
"kill_one_thread(THD*,ulong,bool)" -> "global_thread_list_end()"
"kill_one_thread(THD*,ulong,bool)" -> "global_thread_list_begin()"
"THD::awake(THD::killed_state)" -> "_current_thd()"
"THD::awake(THD::killed_state)" -> "thr_alarm_kill(my_thread_id)"
"THD::awake(THD::killed_state)" -> "inline_mysql_mutex_lock(mysql_mutex_t*)"
"THD::awake(THD::killed_state)" -> "inline_mysql_cond_broadcast(mysql_cond_t*)"
"THD::awake(THD::killed_state)" -> "inline_mysql_mutex_unlock(mysql_mutex_t*)"
"THD::awake(THD::killed_state)" -> "THD::shutdown_active_vio()"
"Security_context::user_matches(Security_context*)" -> "strcmp(const char*,const char*)"
"THD::set_query_id(query_id_t)" -> "inline_mysql_mutex_lock(mysql_mutex_t*)"
"THD::set_query_id(query_id_t)" -> "inline_mysql_mutex_unlock(mysql_mutex_t*)"
"TraceTool::get_instance()" -> "pthread_create(pthread_t*,const pthread_attr_t*,void* (*)(void*),void*)"
"TraceTool::get_instance()" -> "TraceTool::TraceTool()"
"TraceTool::TraceTool()" -> "_Traits>::basic_ofstream() [with _CharT = char,_Traits = std::char_traits<char>]"
"TraceTool::TraceTool()" -> "_Alloc>::push_back(const value_type&) [with _Tp = long int,_Alloc = std::allocator<long int>,std::vector<_Tp,_Alloc>::value_type = long int]"
"TraceTool::TraceTool()" -> "std::operator|(std::_Ios_Openmode,std::_Ios_Openmode)"
"TraceTool::TraceTool()" -> "_Traits>::open(const char*,std::ios_base::openmode) [with _CharT = char,_Traits = std::char_traits<char>,std::ios_base::openmode = std::_Ios_Openmode]"
"TraceTool::TraceTool()" -> "_Alloc>::vector() [with _Tp = std::vector<long int>,_Alloc = std::allocator<std::vector<long int> >]"
"TraceTool::TraceTool()" -> "_Alloc>::deque() [with _Tp = timespec,_Alloc = std::allocator<timespec>]"
"TraceTool::TraceTool()" -> "_Alloc>::push_back(const value_type&) [with _Tp = std::vector<long int>,_Alloc = std::allocator<std::vector<long int> >,std::vector<_Tp,_Alloc>::value_type = std::vector<long int>]"
"TraceTool::TraceTool()" -> "_Alloc>::deque() [with _Tp = const char*,_Alloc = std::allocator<const char*>]"
"TraceTool::TraceTool()" -> "_Alloc>::vector() [with _Tp = long int,_Alloc = std::allocator<long int>]"
"_Traits>::basic_ofstream() [with _CharT = char,_Traits = std::char_traits<char>]" -> "_Traits>::init(std::basic_streambuf<_CharT,_Traits>*) [with _CharT = char,_Traits = std::char_traits<char>]"
"_Traits>::basic_ofstream() [with _CharT = char,_Traits = std::char_traits<char>]" -> "_Traits>::basic_ios() [with _CharT = char,_Traits = std::char_traits<char>]"
"_Traits>::basic_ofstream() [with _CharT = char,_Traits = std::char_traits<char>]" -> "_Traits>::basic_filebuf() [with _CharT = char,_Traits = std::char_traits<char>]"
"_Traits>::basic_ofstream() [with _CharT = char,_Traits = std::char_traits<char>]" -> "_Traits>::basic_ostream() [with _CharT = char,_Traits = std::char_traits<char>]"
"_Traits>::basic_ios() [with _CharT = char,_Traits = std::char_traits<char>]" -> "std::ios_base::ios_base()"
"_Traits>::basic_ostream() [with _CharT = char,_Traits = std::char_traits<char>]" -> "_Traits>::init(std::basic_streambuf<_CharT,_Traits>*) [with _CharT = char,_Traits = std::char_traits<char>]"
"_Alloc>::push_back(const value_type&) [with _Tp = long int,_Alloc = std::allocator<long int>,std::vector<_Tp,_Alloc>::value_type = long int]" -> "_Alloc>::_M_insert_aux(std::vector<_Tp,_Alloc>::iterator,const _Tp&) [with _Tp = long int,_Alloc = std::allocator<long int>,std::vector<_Tp,_Alloc>::iterator = __gnu_cxx::__normal_iterator<long int*,std::vector<long int> >,typename std::_Vector_base<_Tp,_Alloc>::_Tp_alloc_type::pointer = long int*]"
"_Alloc>::push_back(const value_type&) [with _Tp = long int,_Alloc = std::allocator<long int>,std::vector<_Tp,_Alloc>::value_type = long int]" -> "_Alloc>::end() [with _Tp = long int,_Alloc = std::allocator<long int>,std::vector<_Tp,_Alloc>::iterator = __gnu_cxx::__normal_iterator<long int*,std::vector<long int> >,typename std::_Vector_base<_Tp,_Alloc>::_Tp_alloc_type::pointer = long int*]"
"_Alloc>::push_back(const value_type&) [with _Tp = long int,_Alloc = std::allocator<long int>,std::vector<_Tp,_Alloc>::value_type = long int]" -> "__gnu_cxx::new_allocator<_Tp>::construct(__gnu_cxx::new_allocator<_Tp>::pointer,const _Tp&) [with _Tp = long int,__gnu_cxx::new_allocator<_Tp>::pointer = long int*]"
"_Alloc>::_M_insert_aux(std::vector<_Tp,_Alloc>::iterator,const _Tp&) [with _Tp = long int,_Alloc = std::allocator<long int>,std::vector<_Tp,_Alloc>::iterator = __gnu_cxx::__normal_iterator<long int*,std::vector<long int> >,typename std::_Vector_base<_Tp,_Alloc>::_Tp_alloc_type::pointer = long int*]" -> "_Container>::operator*() const [with _Iterator = long int*,_Container = std::vector<long int>,__gnu_cxx::__normal_iterator<_Iterator,_Container>::reference = long int&]"
"_Alloc>::_M_insert_aux(std::vector<_Tp,_Alloc>::iterator,const _Tp&) [with _Tp = long int,_Alloc = std::allocator<long int>,std::vector<_Tp,_Alloc>::iterator = __gnu_cxx::__normal_iterator<long int*,std::vector<long int> >,typename std::_Vector_base<_Tp,_Alloc>::_Tp_alloc_type::pointer = long int*]" -> "_Alloc>::_M_allocate(std::size_t) [with _Tp = long int,_Alloc = std::allocator<long int>,typename _Alloc::rebind<_Tp>::other::pointer = long int*,std::size_t = long unsigned int]"
"_Alloc>::_M_insert_aux(std::vector<_Tp,_Alloc>::iterator,const _Tp&) [with _Tp = long int,_Alloc = std::allocator<long int>,std::vector<_Tp,_Alloc>::iterator = __gnu_cxx::__normal_iterator<long int*,std::vector<long int> >,typename std::_Vector_base<_Tp,_Alloc>::_Tp_alloc_type::pointer = long int*]" -> "_Alloc>::begin() [with _Tp = long int,_Alloc = std::allocator<long int>,std::vector<_Tp,_Alloc>::iterator = __gnu_cxx::__normal_iterator<long int*,std::vector<long int> >,typename std::_Vector_base<_Tp,_Alloc>::_Tp_alloc_type::pointer = long int*]"
"_Alloc>::_M_insert_aux(std::vector<_Tp,_Alloc>::iterator,const _Tp&) [with _Tp = long int,_Alloc = std::allocator<long int>,std::vector<_Tp,_Alloc>::iterator = __gnu_cxx::__normal_iterator<long int*,std::vector<long int> >,typename std::_Vector_base<_Tp,_Alloc>::_Tp_alloc_type::pointer = long int*]" -> "std::_Destroy(_ForwardIterator,_ForwardIterator,std::allocator<_T2>&) [with _ForwardIterator = long int*,_Tp = long int]"
"_Alloc>::_M_insert_aux(std::vector<_Tp,_Alloc>::iterator,const _Tp&) [with _Tp = long int,_Alloc = std::allocator<long int>,std::vector<_Tp,_Alloc>::iterator = __gnu_cxx::__normal_iterator<long int*,std::vector<long int> >,typename std::_Vector_base<_Tp,_Alloc>::_Tp_alloc_type::pointer = long int*]" -> "__cxa_rethrow()"
"_Alloc>::_M_insert_aux(std::vector<_Tp,_Alloc>::iterator,const _Tp&) [with _Tp = long int,_Alloc = std::allocator<long int>,std::vector<_Tp,_Alloc>::iterator = __gnu_cxx::__normal_iterator<long int*,std::vector<long int> >,typename std::_Vector_base<_Tp,_Alloc>::_Tp_alloc_type::pointer = long int*]" -> "_Alloc>::_M_get_Tp_allocator() [with _Tp = long int,_Alloc = std::allocator<long int>,std::_Vector_base<_Tp,_Alloc>::_Tp_alloc_type = std::allocator<long int>]"
"_Alloc>::_M_insert_aux(std::vector<_Tp,_Alloc>::iterator,const _Tp&) [with _Tp = long int,_Alloc = std::allocator<long int>,std::vector<_Tp,_Alloc>::iterator = __gnu_cxx::__normal_iterator<long int*,std::vector<long int> >,typename std::_Vector_base<_Tp,_Alloc>::_Tp_alloc_type::pointer = long int*]" -> "__gnu_cxx::new_allocator<_Tp>::construct(__gnu_cxx::new_allocator<_Tp>::pointer,const _Tp&) [with _Tp = long int,__gnu_cxx::new_allocator<_Tp>::pointer = long int*]"
"_Alloc>::_M_insert_aux(std::vector<_Tp,_Alloc>::iterator,const _Tp&) [with _Tp = long int,_Alloc = std::allocator<long int>,std::vector<_Tp,_Alloc>::iterator = __gnu_cxx::__normal_iterator<long int*,std::vector<long int> >,typename std::_Vector_base<_Tp,_Alloc>::_Tp_alloc_type::pointer = long int*]" -> "__builtin_eh_pointer(int)"
"_Alloc>::_M_insert_aux(std::vector<_Tp,_Alloc>::iterator,const _Tp&) [with _Tp = long int,_Alloc = std::allocator<long int>,std::vector<_Tp,_Alloc>::iterator = __gnu_cxx::__normal_iterator<long int*,std::vector<long int> >,typename std::_Vector_base<_Tp,_Alloc>::_Tp_alloc_type::pointer = long int*]" -> "std::__uninitialized_move_a(_InputIterator,_InputIterator,_ForwardIterator,_Allocator&) [with _InputIterator = long int*,_ForwardIterator = long int*,_Allocator = std::allocator<long int>]"
"_Alloc>::_M_insert_aux(std::vector<_Tp,_Alloc>::iterator,const _Tp&) [with _Tp = long int,_Alloc = std::allocator<long int>,std::vector<_Tp,_Alloc>::iterator = __gnu_cxx::__normal_iterator<long int*,std::vector<long int> >,typename std::_Vector_base<_Tp,_Alloc>::_Tp_alloc_type::pointer = long int*]" -> "_Alloc>::_M_check_len(std::vector<_Tp,_Alloc>::size_type,const char*) const [with _Tp = long int,_Alloc = std::allocator<long int>,std::vector<_Tp,_Alloc>::size_type = long unsigned int]"
"_Alloc>::_M_insert_aux(std::vector<_Tp,_Alloc>::iterator,const _Tp&) [with _Tp = long int,_Alloc = std::allocator<long int>,std::vector<_Tp,_Alloc>::iterator = __gnu_cxx::__normal_iterator<long int*,std::vector<long int> >,typename std::_Vector_base<_Tp,_Alloc>::_Tp_alloc_type::pointer = long int*]" -> "_Alloc>::_M_deallocate(typename _Alloc::rebind<_Tp>::other::pointer,std::size_t) [with _Tp = long int,_Alloc = std::allocator<long int>,typename _Alloc::rebind<_Tp>::other::pointer = long int*,std::size_t = long unsigned int]"
"_Alloc>::_M_insert_aux(std::vector<_Tp,_Alloc>::iterator,const _Tp&) [with _Tp = long int,_Alloc = std::allocator<long int>,std::vector<_Tp,_Alloc>::iterator = __gnu_cxx::__normal_iterator<long int*,std::vector<long int> >,typename std::_Vector_base<_Tp,_Alloc>::_Tp_alloc_type::pointer = long int*]" -> "__cxa_begin_catch(void*)"
"_Alloc>::_M_insert_aux(std::vector<_Tp,_Alloc>::iterator,const _Tp&) [with _Tp = long int,_Alloc = std::allocator<long int>,std::vector<_Tp,_Alloc>::iterator = __gnu_cxx::__normal_iterator<long int*,std::vector<long int> >,typename std::_Vector_base<_Tp,_Alloc>::_Tp_alloc_type::pointer = long int*]" -> "__cxa_end_catch()"
"_Alloc>::_M_insert_aux(std::vector<_Tp,_Alloc>::iterator,const _Tp&) [with _Tp = long int,_Alloc = std::allocator<long int>,std::vector<_Tp,_Alloc>::iterator = __gnu_cxx::__normal_iterator<long int*,std::vector<long int> >,typename std::_Vector_base<_Tp,_Alloc>::_Tp_alloc_type::pointer = long int*]" -> "__gnu_cxx::operator-(const __gnu_cxx::__normal_iterator<_Iterator,_Container>&,const __gnu_cxx::__normal_iterator<_Iterator,_Container>&) [with _Iterator = long int*,_Container = std::vector<long int>,typename __gnu_cxx::__normal_iterator<_Iterator,_Container>::difference_type = long int]"
"_Alloc>::_M_insert_aux(std::vector<_Tp,_Alloc>::iterator,const _Tp&) [with _Tp = long int,_Alloc = std::allocator<long int>,std::vector<_Tp,_Alloc>::iterator = __gnu_cxx::__normal_iterator<long int*,std::vector<long int> >,typename std::_Vector_base<_Tp,_Alloc>::_Tp_alloc_type::pointer = long int*]" -> "__gnu_cxx::new_allocator<_Tp>::destroy(__gnu_cxx::new_allocator<_Tp>::pointer) [with _Tp = long int,__gnu_cxx::new_allocator<_Tp>::pointer = long int*]"
"_Alloc>::_M_insert_aux(std::vector<_Tp,_Alloc>::iterator,const _Tp&) [with _Tp = long int,_Alloc = std::allocator<long int>,std::vector<_Tp,_Alloc>::iterator = __gnu_cxx::__normal_iterator<long int*,std::vector<long int> >,typename std::_Vector_base<_Tp,_Alloc>::_Tp_alloc_type::pointer = long int*]" -> "std::copy_backward(_BI1,_BI1,_BI2) [with _BI1 = long int*,_BI2 = long int*]"
"_Alloc>::_M_insert_aux(std::vector<_Tp,_Alloc>::iterator,const _Tp&) [with _Tp = long int,_Alloc = std::allocator<long int>,std::vector<_Tp,_Alloc>::iterator = __gnu_cxx::__normal_iterator<long int*,std::vector<long int> >,typename std::_Vector_base<_Tp,_Alloc>::_Tp_alloc_type::pointer = long int*]" -> "_Container>::base() const [with _Iterator = long int*,_Container = std::vector<long int>]"
"_Alloc>::_M_allocate(std::size_t) [with _Tp = long int,_Alloc = std::allocator<long int>,typename _Alloc::rebind<_Tp>::other::pointer = long int*,std::size_t = long unsigned int]" -> "__gnu_cxx::new_allocator<_Tp>::allocate(__gnu_cxx::new_allocator<_Tp>::size_type,const void*) [with _Tp = long int,__gnu_cxx::new_allocator<_Tp>::pointer = long int*,__gnu_cxx::new_allocator<_Tp>::size_type = long unsigned int]"
"__gnu_cxx::new_allocator<_Tp>::allocate(__gnu_cxx::new_allocator<_Tp>::size_type,const void*) [with _Tp = long int,__gnu_cxx::new_allocator<_Tp>::pointer = long int*,__gnu_cxx::new_allocator<_Tp>::size_type = long unsigned int]" -> "__gnu_cxx::new_allocator<_Tp>::max_size() const [with _Tp = long int,__gnu_cxx::new_allocator<_Tp>::size_type = long unsigned int]"
"__gnu_cxx::new_allocator<_Tp>::allocate(__gnu_cxx::new_allocator<_Tp>::size_type,const void*) [with _Tp = long int,__gnu_cxx::new_allocator<_Tp>::pointer = long int*,__gnu_cxx::new_allocator<_Tp>::size_type = long unsigned int]" -> "std::__throw_bad_alloc()"
"_Alloc>::begin() [with _Tp = long int,_Alloc = std::allocator<long int>,std::vector<_Tp,_Alloc>::iterator = __gnu_cxx::__normal_iterator<long int*,std::vector<long int> >,typename std::_Vector_base<_Tp,_Alloc>::_Tp_alloc_type::pointer = long int*]" -> "_Container>::__normal_iterator(const _Iterator&) [with _Iterator = long int*,_Container = std::vector<long int>]"
"std::_Destroy(_ForwardIterator,_ForwardIterator,std::allocator<_T2>&) [with _ForwardIterator = long int*,_Tp = long int]" -> "std::_Destroy(_ForwardIterator,_ForwardIterator) [with _ForwardIterator = long int*]"
"std::_Destroy(_ForwardIterator,_ForwardIterator) [with _ForwardIterator = long int*]" -> "std::_Destroy_aux<true>::__destroy(_ForwardIterator,_ForwardIterator) [with _ForwardIterator = long int*]"
"std::__uninitialized_move_a(_InputIterator,_InputIterator,_ForwardIterator,_Allocator&) [with _InputIterator = long int*,_ForwardIterator = long int*,_Allocator = std::allocator<long int>]" -> "std::__uninitialized_copy_a(_InputIterator,_InputIterator,_ForwardIterator,std::allocator<_Tp>&) [with _InputIterator = long int*,_ForwardIterator = long int*,_Tp = long int]"
"std::__uninitialized_copy_a(_InputIterator,_InputIterator,_ForwardIterator,std::allocator<_Tp>&) [with _InputIterator = long int*,_ForwardIterator = long int*,_Tp = long int]" -> "std::uninitialized_copy(_InputIterator,_InputIterator,_ForwardIterator) [with _InputIterator = long int*,_ForwardIterator = long int*]"
"std::uninitialized_copy(_InputIterator,_InputIterator,_ForwardIterator) [with _InputIterator = long int*,_ForwardIterator = long int*]" -> "std::__uninitialized_copy<true>::__uninit_copy(_InputIterator,_InputIterator,_ForwardIterator) [with _InputIterator = long int*,_ForwardIterator = long int*]"
"std::__uninitialized_copy<true>::__uninit_copy(_InputIterator,_InputIterator,_ForwardIterator) [with _InputIterator = long int*,_ForwardIterator = long int*]" -> "std::copy(_II,_II,_OI) [with _II = long int*,_OI = long int*]"
"std::copy(_II,_II,_OI) [with _II = long int*,_OI = long int*]" -> "std::__copy_move_a2(_II,_II,_OI) [with bool _IsMove = false,_II = long int*,_OI = long int*]"
"std::copy(_II,_II,_OI) [with _II = long int*,_OI = long int*]" -> "std::__miter_base(_Iterator) [with _Iterator = long int*,typename std::_Miter_base<_Iterator>::iterator_type = long int*]"
"std::__copy_move_a2(_II,_II,_OI) [with bool _IsMove = false,_II = long int*,_OI = long int*]" -> "std::__niter_base(_Iterator) [with _Iterator = long int*,typename std::_Niter_base<_Iterator>::iterator_type = long int*]"
"std::__copy_move_a2(_II,_II,_OI) [with bool _IsMove = false,_II = long int*,_OI = long int*]" -> "std::__copy_move_a(_II,_II,_OI) [with bool _IsMove = false,_II = long int*,_OI = long int*]"
"std::__niter_base(_Iterator) [with _Iterator = long int*,typename std::_Niter_base<_Iterator>::iterator_type = long int*]" -> "_HasBase>::_S_base(_Iterator) [with _Iterator = long int*,bool _HasBase = false,std::_Iter_base<_Iterator,_HasBase>::iterator_type = long int*]"
"std::__copy_move_a(_II,_II,_OI) [with bool _IsMove = false,_II = long int*,_OI = long int*]" -> "std::random_access_iterator_tag>::__copy_m(const _Tp*,const _Tp*,_Tp*) [with _Tp = long int,bool _IsMove = false]"
"std::random_access_iterator_tag>::__copy_m(const _Tp*,const _Tp*,_Tp*) [with _Tp = long int,bool _IsMove = false]" -> "__builtin_memmove(void*,const void*,long unsigned int)"
"std::__miter_base(_Iterator) [with _Iterator = long int*,typename std::_Miter_base<_Iterator>::iterator_type = long int*]" -> "_HasBase>::_S_base(_Iterator) [with _Iterator = long int*,bool _HasBase = false,std::_Iter_base<_Iterator,_HasBase>::iterator_type = long int*]"
"_Alloc>::_M_check_len(std::vector<_Tp,_Alloc>::size_type,const char*) const [with _Tp = long int,_Alloc = std::allocator<long int>,std::vector<_Tp,_Alloc>::size_type = long unsigned int]" -> "_Alloc>::max_size() const [with _Tp = long int,_Alloc = std::allocator<long int>,std::vector<_Tp,_Alloc>::size_type = long unsigned int]"
"_Alloc>::_M_check_len(std::vector<_Tp,_Alloc>::size_type,const char*) const [with _Tp = long int,_Alloc = std::allocator<long int>,std::vector<_Tp,_Alloc>::size_type = long unsigned int]" -> "_Alloc>::size() const [with _Tp = long int,_Alloc = std::allocator<long int>,std::vector<_Tp,_Alloc>::size_type = long unsigned int]"
"_Alloc>::_M_check_len(std::vector<_Tp,_Alloc>::size_type,const char*) const [with _Tp = long int,_Alloc = std::allocator<long int>,std::vector<_Tp,_Alloc>::size_type = long unsigned int]" -> "std::__throw_length_error(const char*)"
"_Alloc>::_M_check_len(std::vector<_Tp,_Alloc>::size_type,const char*) const [with _Tp = long int,_Alloc = std::allocator<long int>,std::vector<_Tp,_Alloc>::size_type = long unsigned int]" -> "std::max(const _Tp&,const _Tp&) [with _Tp = long unsigned int]"
"_Alloc>::max_size() const [with _Tp = long int,_Alloc = std::allocator<long int>,std::vector<_Tp,_Alloc>::size_type = long unsigned int]" -> "_Alloc>::_M_get_Tp_allocator() const [with _Tp = long int,_Alloc = std::allocator<long int>,std::_Vector_base<_Tp,_Alloc>::_Tp_alloc_type = std::allocator<long int>]"
"_Alloc>::max_size() const [with _Tp = long int,_Alloc = std::allocator<long int>,std::vector<_Tp,_Alloc>::size_type = long unsigned int]" -> "__gnu_cxx::new_allocator<_Tp>::max_size() const [with _Tp = long int,__gnu_cxx::new_allocator<_Tp>::size_type = long unsigned int]"
"_Alloc>::_M_deallocate(typename _Alloc::rebind<_Tp>::other::pointer,std::size_t) [with _Tp = long int,_Alloc = std::allocator<long int>,typename _Alloc::rebind<_Tp>::other::pointer = long int*,std::size_t = long unsigned int]" -> "__gnu_cxx::new_allocator<_Tp>::deallocate(__gnu_cxx::new_allocator<_Tp>::pointer,__gnu_cxx::new_allocator<_Tp>::size_type) [with _Tp = long int,__gnu_cxx::new_allocator<_Tp>::pointer = long int*,__gnu_cxx::new_allocator<_Tp>::size_type = long unsigned int]"
"__gnu_cxx::operator-(const __gnu_cxx::__normal_iterator<_Iterator,_Container>&,const __gnu_cxx::__normal_iterator<_Iterator,_Container>&) [with _Iterator = long int*,_Container = std::vector<long int>,typename __gnu_cxx::__normal_iterator<_Iterator,_Container>::difference_type = long int]" -> "_Container>::base() const [with _Iterator = long int*,_Container = std::vector<long int>]"
"std::copy_backward(_BI1,_BI1,_BI2) [with _BI1 = long int*,_BI2 = long int*]" -> "std::__copy_move_backward_a2(_BI1,_BI1,_BI2) [with bool _IsMove = false,_BI1 = long int*,_BI2 = long int*]"
"std::copy_backward(_BI1,_BI1,_BI2) [with _BI1 = long int*,_BI2 = long int*]" -> "std::__miter_base(_Iterator) [with _Iterator = long int*,typename std::_Miter_base<_Iterator>::iterator_type = long int*]"
"std::__copy_move_backward_a2(_BI1,_BI1,_BI2) [with bool _IsMove = false,_BI1 = long int*,_BI2 = long int*]" -> "std::__niter_base(_Iterator) [with _Iterator = long int*,typename std::_Niter_base<_Iterator>::iterator_type = long int*]"
"std::__copy_move_backward_a2(_BI1,_BI1,_BI2) [with bool _IsMove = false,_BI1 = long int*,_BI2 = long int*]" -> "std::__copy_move_backward_a(_BI1,_BI1,_BI2) [with bool _IsMove = false,_BI1 = long int*,_BI2 = long int*]"
"std::__copy_move_backward_a(_BI1,_BI1,_BI2) [with bool _IsMove = false,_BI1 = long int*,_BI2 = long int*]" -> "std::random_access_iterator_tag>::__copy_move_b(const _Tp*,const _Tp*,_Tp*) [with _Tp = long int,bool _IsMove = false]"
"std::random_access_iterator_tag>::__copy_move_b(const _Tp*,const _Tp*,_Tp*) [with _Tp = long int,bool _IsMove = false]" -> "__builtin_memmove(void*,const void*,long unsigned int)"
"_Alloc>::end() [with _Tp = long int,_Alloc = std::allocator<long int>,std::vector<_Tp,_Alloc>::iterator = __gnu_cxx::__normal_iterator<long int*,std::vector<long int> >,typename std::_Vector_base<_Tp,_Alloc>::_Tp_alloc_type::pointer = long int*]" -> "_Container>::__normal_iterator(const _Iterator&) [with _Iterator = long int*,_Container = std::vector<long int>]"
"_Traits>::open(const char*,std::ios_base::openmode) [with _CharT = char,_Traits = std::char_traits<char>,std::ios_base::openmode = std::_Ios_Openmode]" -> "_Traits>::open(const char*,std::ios_base::openmode) [with _CharT = char,_Traits = std::char_traits<char>,std::basic_filebuf<_CharT,_Traits>::__filebuf_type = std::basic_filebuf<char>,std::ios_base::openmode = std::_Ios_Openmode]"
"_Traits>::open(const char*,std::ios_base::openmode) [with _CharT = char,_Traits = std::char_traits<char>,std::ios_base::openmode = std::_Ios_Openmode]" -> "_Traits>::clear(std::ios_base::iostate) [with _CharT = char,_Traits = std::char_traits<char>,std::ios_base::iostate = std::_Ios_Iostate]"
"_Traits>::open(const char*,std::ios_base::openmode) [with _CharT = char,_Traits = std::char_traits<char>,std::ios_base::openmode = std::_Ios_Openmode]" -> "_Traits>::setstate(std::ios_base::iostate) [with _CharT = char,_Traits = std::char_traits<char>,std::ios_base::iostate = std::_Ios_Iostate]"
"_Traits>::open(const char*,std::ios_base::openmode) [with _CharT = char,_Traits = std::char_traits<char>,std::ios_base::openmode = std::_Ios_Openmode]" -> "std::operator|(std::_Ios_Openmode,std::_Ios_Openmode)"
"_Traits>::setstate(std::ios_base::iostate) [with _CharT = char,_Traits = std::char_traits<char>,std::ios_base::iostate = std::_Ios_Iostate]" -> "_Traits>::rdstate() const [with _CharT = char,_Traits = std::char_traits<char>,std::ios_base::iostate = std::_Ios_Iostate]"
"_Traits>::setstate(std::ios_base::iostate) [with _CharT = char,_Traits = std::char_traits<char>,std::ios_base::iostate = std::_Ios_Iostate]" -> "_Traits>::clear(std::ios_base::iostate) [with _CharT = char,_Traits = std::char_traits<char>,std::ios_base::iostate = std::_Ios_Iostate]"
"_Traits>::setstate(std::ios_base::iostate) [with _CharT = char,_Traits = std::char_traits<char>,std::ios_base::iostate = std::_Ios_Iostate]" -> "std::operator|(std::_Ios_Iostate,std::_Ios_Iostate)"
"_Alloc>::vector() [with _Tp = std::vector<long int>,_Alloc = std::allocator<std::vector<long int> >]" -> "_Alloc>::_Vector_base() [with _Tp = std::vector<long int>,_Alloc = std::allocator<std::vector<long int> >]"
"_Alloc>::_Vector_base() [with _Tp = std::vector<long int>,_Alloc = std::allocator<std::vector<long int> >]" -> "_Alloc>::_Vector_impl::_Vector_impl() [with _Tp = std::vector<long int>,_Alloc = std::allocator<std::vector<long int> >]"
"_Alloc>::_Vector_impl::_Vector_impl() [with _Tp = std::vector<long int>,_Alloc = std::allocator<std::vector<long int> >]" -> "std::allocator<_Alloc>::allocator() [with _Tp = std::vector<long int>]"
"std::allocator<_Alloc>::allocator() [with _Tp = std::vector<long int>]" -> "__gnu_cxx::new_allocator<_Tp>::new_allocator() [with _Tp = std::vector<long int>]"
"_Alloc>::deque() [with _Tp = timespec,_Alloc = std::allocator<timespec>]" -> "_Alloc>::_Deque_base() [with _Tp = timespec,_Alloc = std::allocator<timespec>]"
"_Alloc>::_Deque_base() [with _Tp = timespec,_Alloc = std::allocator<timespec>]" -> "_Alloc>::_M_initialize_map(std::size_t) [with _Tp = timespec,_Alloc = std::allocator<timespec>,std::size_t = long unsigned int]"
"_Alloc>::_Deque_base() [with _Tp = timespec,_Alloc = std::allocator<timespec>]" -> "_Alloc>::_Deque_impl::_Deque_impl() [with _Tp = timespec,_Alloc = std::allocator<timespec>]"
"_Alloc>::_M_initialize_map(std::size_t) [with _Tp = timespec,_Alloc = std::allocator<timespec>,std::size_t = long unsigned int]" -> "__cxa_rethrow()"
"_Alloc>::_M_initialize_map(std::size_t) [with _Tp = timespec,_Alloc = std::allocator<timespec>,std::size_t = long unsigned int]" -> "std::max(const _Tp&,const _Tp&) [with _Tp = long unsigned int]"
"_Alloc>::_M_initialize_map(std::size_t) [with _Tp = timespec,_Alloc = std::allocator<timespec>,std::size_t = long unsigned int]" -> "_Alloc>::_M_create_nodes(_Tp**,_Tp**) [with _Tp = timespec,_Alloc = std::allocator<timespec>]"
"_Alloc>::_M_initialize_map(std::size_t) [with _Tp = timespec,_Alloc = std::allocator<timespec>,std::size_t = long unsigned int]" -> "__cxa_begin_catch(void*)"
"_Alloc>::_M_initialize_map(std::size_t) [with _Tp = timespec,_Alloc = std::allocator<timespec>,std::size_t = long unsigned int]" -> "_Alloc>::_M_allocate_map(std::size_t) [with _Tp = timespec,_Alloc = std::allocator<timespec>,std::size_t = long unsigned int]"
"_Alloc>::_M_initialize_map(std::size_t) [with _Tp = timespec,_Alloc = std::allocator<timespec>,std::size_t = long unsigned int]" -> "_Alloc>::_M_deallocate_map(_Tp**,std::size_t) [with _Tp = timespec,_Alloc = std::allocator<timespec>,std::size_t = long unsigned int]"
"_Alloc>::_M_initialize_map(std::size_t) [with _Tp = timespec,_Alloc = std::allocator<timespec>,std::size_t = long unsigned int]" -> "std::__deque_buf_size(std::size_t)"
"_Alloc>::_M_initialize_map(std::size_t) [with _Tp = timespec,_Alloc = std::allocator<timespec>,std::size_t = long unsigned int]" -> "_Ptr>::_M_set_node(std::_Deque_iterator<_Tp,_Ref,_Ptr>::_Map_pointer) [with _Tp = timespec,_Ref = timespec&,_Ptr = timespec*,std::_Deque_iterator<_Tp,_Ref,_Ptr>::_Map_pointer = timespec**]"
"_Alloc>::_M_initialize_map(std::size_t) [with _Tp = timespec,_Alloc = std::allocator<timespec>,std::size_t = long unsigned int]" -> "__builtin_eh_pointer(int)"
"_Alloc>::_M_initialize_map(std::size_t) [with _Tp = timespec,_Alloc = std::allocator<timespec>,std::size_t = long unsigned int]" -> "__cxa_end_catch()"
"_Alloc>::_M_create_nodes(_Tp**,_Tp**) [with _Tp = timespec,_Alloc = std::allocator<timespec>]" -> "_Alloc>::_M_allocate_node() [with _Tp = timespec,_Alloc = std::allocator<timespec>]"
"_Alloc>::_M_create_nodes(_Tp**,_Tp**) [with _Tp = timespec,_Alloc = std::allocator<timespec>]" -> "_Alloc>::_M_destroy_nodes(_Tp**,_Tp**) [with _Tp = timespec,_Alloc = std::allocator<timespec>]"
"_Alloc>::_M_create_nodes(_Tp**,_Tp**) [with _Tp = timespec,_Alloc = std::allocator<timespec>]" -> "__cxa_rethrow()"
"_Alloc>::_M_create_nodes(_Tp**,_Tp**) [with _Tp = timespec,_Alloc = std::allocator<timespec>]" -> "__builtin_eh_pointer(int)"
"_Alloc>::_M_create_nodes(_Tp**,_Tp**) [with _Tp = timespec,_Alloc = std::allocator<timespec>]" -> "__cxa_end_catch()"
"_Alloc>::_M_create_nodes(_Tp**,_Tp**) [with _Tp = timespec,_Alloc = std::allocator<timespec>]" -> "__cxa_begin_catch(void*)"
"_Alloc>::_M_allocate_node() [with _Tp = timespec,_Alloc = std::allocator<timespec>]" -> "std::__deque_buf_size(std::size_t)"
"_Alloc>::_M_allocate_node() [with _Tp = timespec,_Alloc = std::allocator<timespec>]" -> "__gnu_cxx::new_allocator<_Tp>::allocate(__gnu_cxx::new_allocator<_Tp>::size_type,const void*) [with _Tp = timespec,__gnu_cxx::new_allocator<_Tp>::pointer = timespec*,__gnu_cxx::new_allocator<_Tp>::size_type = long unsigned int]"
"__gnu_cxx::new_allocator<_Tp>::allocate(__gnu_cxx::new_allocator<_Tp>::size_type,const void*) [with _Tp = timespec,__gnu_cxx::new_allocator<_Tp>::pointer = timespec*,__gnu_cxx::new_allocator<_Tp>::size_type = long unsigned int]" -> "__gnu_cxx::new_allocator<_Tp>::max_size() const [with _Tp = timespec,__gnu_cxx::new_allocator<_Tp>::size_type = long unsigned int]"
"__gnu_cxx::new_allocator<_Tp>::allocate(__gnu_cxx::new_allocator<_Tp>::size_type,const void*) [with _Tp = timespec,__gnu_cxx::new_allocator<_Tp>::pointer = timespec*,__gnu_cxx::new_allocator<_Tp>::size_type = long unsigned int]" -> "std::__throw_bad_alloc()"
"_Alloc>::_M_destroy_nodes(_Tp**,_Tp**) [with _Tp = timespec,_Alloc = std::allocator<timespec>]" -> "_Alloc>::_M_deallocate_node(_Tp*) [with _Tp = timespec,_Alloc = std::allocator<timespec>]"
"_Alloc>::_M_deallocate_node(_Tp*) [with _Tp = timespec,_Alloc = std::allocator<timespec>]" -> "std::__deque_buf_size(std::size_t)"
"_Alloc>::_M_deallocate_node(_Tp*) [with _Tp = timespec,_Alloc = std::allocator<timespec>]" -> "__gnu_cxx::new_allocator<_Tp>::deallocate(__gnu_cxx::new_allocator<_Tp>::pointer,__gnu_cxx::new_allocator<_Tp>::size_type) [with _Tp = timespec,__gnu_cxx::new_allocator<_Tp>::pointer = timespec*,__gnu_cxx::new_allocator<_Tp>::size_type = long unsigned int]"
"_Alloc>::_M_allocate_map(std::size_t) [with _Tp = timespec,_Alloc = std::allocator<timespec>,std::size_t = long unsigned int]" -> "_Alloc>::_M_get_map_allocator() const [with _Tp = timespec,_Alloc = std::allocator<timespec>,std::_Deque_base<_Tp,_Alloc>::_Map_alloc_type = std::allocator<timespec*>]"
"_Alloc>::_M_allocate_map(std::size_t) [with _Tp = timespec,_Alloc = std::allocator<timespec>,std::size_t = long unsigned int]" -> "__gnu_cxx::new_allocator<_Tp>::allocate(__gnu_cxx::new_allocator<_Tp>::size_type,const void*) [with _Tp = timespec*,__gnu_cxx::new_allocator<_Tp>::pointer = timespec**,__gnu_cxx::new_allocator<_Tp>::size_type = long unsigned int]"
"_Alloc>::_M_get_map_allocator() const [with _Tp = timespec,_Alloc = std::allocator<timespec>,std::_Deque_base<_Tp,_Alloc>::_Map_alloc_type = std::allocator<timespec*>]" -> "std::allocator<_Alloc>::allocator(const std::allocator<_Tp1>&) [with _Tp1 = timespec,_Tp = timespec*]"
"_Alloc>::_M_get_map_allocator() const [with _Tp = timespec,_Alloc = std::allocator<timespec>,std::_Deque_base<_Tp,_Alloc>::_Map_alloc_type = std::allocator<timespec*>]" -> "_Alloc>::_M_get_Tp_allocator() const [with _Tp = timespec,_Alloc = std::allocator<timespec>,std::_Deque_base<_Tp,_Alloc>::_Tp_alloc_type = std::allocator<timespec>]"
"std::allocator<_Alloc>::allocator(const std::allocator<_Tp1>&) [with _Tp1 = timespec,_Tp = timespec*]" -> "__gnu_cxx::new_allocator<_Tp>::new_allocator() [with _Tp = timespec*]"
"__gnu_cxx::new_allocator<_Tp>::allocate(__gnu_cxx::new_allocator<_Tp>::size_type,const void*) [with _Tp = timespec*,__gnu_cxx::new_allocator<_Tp>::pointer = timespec**,__gnu_cxx::new_allocator<_Tp>::size_type = long unsigned int]" -> "std::__throw_bad_alloc()"
"__gnu_cxx::new_allocator<_Tp>::allocate(__gnu_cxx::new_allocator<_Tp>::size_type,const void*) [with _Tp = timespec*,__gnu_cxx::new_allocator<_Tp>::pointer = timespec**,__gnu_cxx::new_allocator<_Tp>::size_type = long unsigned int]" -> "__gnu_cxx::new_allocator<_Tp>::max_size() const [with _Tp = timespec*,__gnu_cxx::new_allocator<_Tp>::size_type = long unsigned int]"
"_Alloc>::_M_deallocate_map(_Tp**,std::size_t) [with _Tp = timespec,_Alloc = std::allocator<timespec>,std::size_t = long unsigned int]" -> "_Alloc>::_M_get_map_allocator() const [with _Tp = timespec,_Alloc = std::allocator<timespec>,std::_Deque_base<_Tp,_Alloc>::_Map_alloc_type = std::allocator<timespec*>]"
"_Alloc>::_M_deallocate_map(_Tp**,std::size_t) [with _Tp = timespec,_Alloc = std::allocator<timespec>,std::size_t = long unsigned int]" -> "__gnu_cxx::new_allocator<_Tp>::deallocate(__gnu_cxx::new_allocator<_Tp>::pointer,__gnu_cxx::new_allocator<_Tp>::size_type) [with _Tp = timespec*,__gnu_cxx::new_allocator<_Tp>::pointer = timespec**,__gnu_cxx::new_allocator<_Tp>::size_type = long unsigned int]"
"_Ptr>::_M_set_node(std::_Deque_iterator<_Tp,_Ref,_Ptr>::_Map_pointer) [with _Tp = timespec,_Ref = timespec&,_Ptr = timespec*,std::_Deque_iterator<_Tp,_Ref,_Ptr>::_Map_pointer = timespec**]" -> "_Ptr>::_S_buffer_size() [with _Tp = timespec,_Ref = timespec&,_Ptr = timespec*,std::size_t = long unsigned int]"
"_Ptr>::_S_buffer_size() [with _Tp = timespec,_Ref = timespec&,_Ptr = timespec*,std::size_t = long unsigned int]" -> "std::__deque_buf_size(std::size_t)"
"_Alloc>::_Deque_impl::_Deque_impl() [with _Tp = timespec,_Alloc = std::allocator<timespec>]" -> "std::allocator<_Alloc>::allocator() [with _Tp = timespec]"
"_Alloc>::_Deque_impl::_Deque_impl() [with _Tp = timespec,_Alloc = std::allocator<timespec>]" -> "_Ptr>::_Deque_iterator() [with _Tp = timespec,_Ref = timespec&,_Ptr = timespec*]"
"std::allocator<_Alloc>::allocator() [with _Tp = timespec]" -> "__gnu_cxx::new_allocator<_Tp>::new_allocator() [with _Tp = timespec]"
"_Alloc>::push_back(const value_type&) [with _Tp = std::vector<long int>,_Alloc = std::allocator<std::vector<long int> >,std::vector<_Tp,_Alloc>::value_type = std::vector<long int>]" -> "__gnu_cxx::new_allocator<_Tp>::construct(__gnu_cxx::new_allocator<_Tp>::pointer,const _Tp&) [with _Tp = std::vector<long int>,__gnu_cxx::new_allocator<_Tp>::pointer = std::vector<long int>*]"
"_Alloc>::push_back(const value_type&) [with _Tp = std::vector<long int>,_Alloc = std::allocator<std::vector<long int> >,std::vector<_Tp,_Alloc>::value_type = std::vector<long int>]" -> "_Alloc>::end() [with _Tp = std::vector<long int>,_Alloc = std::allocator<std::vector<long int> >,std::vector<_Tp,_Alloc>::iterator = __gnu_cxx::__normal_iterator<std::vector<long int>*,std::vector<std::vector<long int> > >,typename std::_Vector_base<_Tp,_Alloc>::_Tp_alloc_type::pointer = std::vector<long int>*]"
"_Alloc>::push_back(const value_type&) [with _Tp = std::vector<long int>,_Alloc = std::allocator<std::vector<long int> >,std::vector<_Tp,_Alloc>::value_type = std::vector<long int>]" -> "_Alloc>::_M_insert_aux(std::vector<_Tp,_Alloc>::iterator,const _Tp&) [with _Tp = std::vector<long int>,_Alloc = std::allocator<std::vector<long int> >,std::vector<_Tp,_Alloc>::iterator = __gnu_cxx::__normal_iterator<std::vector<long int>*,std::vector<std::vector<long int> > >,typename std::_Vector_base<_Tp,_Alloc>::_Tp_alloc_type::pointer = std::vector<long int>*]"
"__gnu_cxx::new_allocator<_Tp>::construct(__gnu_cxx::new_allocator<_Tp>::pointer,const _Tp&) [with _Tp = std::vector<long int>,__gnu_cxx::new_allocator<_Tp>::pointer = std::vector<long int>*]" -> "_Alloc>::vector(const std::vector<_Tp,_Alloc>&) [with _Tp = long int,_Alloc = std::allocator<long int>,std::vector<_Tp,_Alloc> = std::vector<long int>]"
"_Alloc>::vector(const std::vector<_Tp,_Alloc>&) [with _Tp = long int,_Alloc = std::allocator<long int>,std::vector<_Tp,_Alloc> = std::vector<long int>]" -> "_Alloc>::begin() const [with _Tp = long int,_Alloc = std::allocator<long int>,std::vector<_Tp,_Alloc>::const_iterator = __gnu_cxx::__normal_iterator<const long int*,std::vector<long int> >,typename std::_Vector_base<_Tp,_Alloc>::_Tp_alloc_type::const_pointer = const long int*]"
"_Alloc>::vector(const std::vector<_Tp,_Alloc>&) [with _Tp = long int,_Alloc = std::allocator<long int>,std::vector<_Tp,_Alloc> = std::vector<long int>]" -> "_Alloc>::_M_get_Tp_allocator() const [with _Tp = long int,_Alloc = std::allocator<long int>,std::_Vector_base<_Tp,_Alloc>::_Tp_alloc_type = std::allocator<long int>]"
"_Alloc>::vector(const std::vector<_Tp,_Alloc>&) [with _Tp = long int,_Alloc = std::allocator<long int>,std::vector<_Tp,_Alloc> = std::vector<long int>]" -> "std::__uninitialized_copy_a(_InputIterator,_InputIterator,_ForwardIterator,std::allocator<_Tp>&) [with _InputIterator = __gnu_cxx::__normal_iterator<const long int*,std::vector<long int> >,_ForwardIterator = long int*,_Tp = long int]"
"_Alloc>::vector(const std::vector<_Tp,_Alloc>&) [with _Tp = long int,_Alloc = std::allocator<long int>,std::vector<_Tp,_Alloc> = std::vector<long int>]" -> "_Alloc>::size() const [with _Tp = long int,_Alloc = std::allocator<long int>,std::vector<_Tp,_Alloc>::size_type = long unsigned int]"
"_Alloc>::vector(const std::vector<_Tp,_Alloc>&) [with _Tp = long int,_Alloc = std::allocator<long int>,std::vector<_Tp,_Alloc> = std::vector<long int>]" -> "_Alloc>::end() const [with _Tp = long int,_Alloc = std::allocator<long int>,std::vector<_Tp,_Alloc>::const_iterator = __gnu_cxx::__normal_iterator<const long int*,std::vector<long int> >,typename std::_Vector_base<_Tp,_Alloc>::_Tp_alloc_type::const_pointer = const long int*]"
"_Alloc>::vector(const std::vector<_Tp,_Alloc>&) [with _Tp = long int,_Alloc = std::allocator<long int>,std::vector<_Tp,_Alloc> = std::vector<long int>]" -> "_Alloc>::_Vector_base(std::size_t,const allocator_type&) [with _Tp = long int,_Alloc = std::allocator<long int>,std::size_t = long unsigned int,std::_Vector_base<_Tp,_Alloc>::allocator_type = std::allocator<long int>]"
"_Alloc>::vector(const std::vector<_Tp,_Alloc>&) [with _Tp = long int,_Alloc = std::allocator<long int>,std::vector<_Tp,_Alloc> = std::vector<long int>]" -> "_Alloc>::_M_get_Tp_allocator() [with _Tp = long int,_Alloc = std::allocator<long int>,std::_Vector_base<_Tp,_Alloc>::_Tp_alloc_type = std::allocator<long int>]"
"_Alloc>::begin() const [with _Tp = long int,_Alloc = std::allocator<long int>,std::vector<_Tp,_Alloc>::const_iterator = __gnu_cxx::__normal_iterator<const long int*,std::vector<long int> >,typename std::_Vector_base<_Tp,_Alloc>::_Tp_alloc_type::const_pointer = const long int*]" -> "_Container>::__normal_iterator(const _Iterator&) [with _Iterator = const long int*,_Container = std::vector<long int>]"
"std::__uninitialized_copy_a(_InputIterator,_InputIterator,_ForwardIterator,std::allocator<_Tp>&) [with _InputIterator = __gnu_cxx::__normal_iterator<const long int*,std::vector<long int> >,_ForwardIterator = long int*,_Tp = long int]" -> "std::uninitialized_copy(_InputIterator,_InputIterator,_ForwardIterator) [with _InputIterator = __gnu_cxx::__normal_iterator<const long int*,std::vector<long int> >,_ForwardIterator = long int*]"
"std::uninitialized_copy(_InputIterator,_InputIterator,_ForwardIterator) [with _InputIterator = __gnu_cxx::__normal_iterator<const long int*,std::vector<long int> >,_ForwardIterator = long int*]" -> "std::__uninitialized_copy<true>::__uninit_copy(_InputIterator,_InputIterator,_ForwardIterator) [with _InputIterator = __gnu_cxx::__normal_iterator<const long int*,std::vector<long int> >,_ForwardIterator = long int*]"
"std::__uninitialized_copy<true>::__uninit_copy(_InputIterator,_InputIterator,_ForwardIterator) [with _InputIterator = __gnu_cxx::__normal_iterator<const long int*,std::vector<long int> >,_ForwardIterator = long int*]" -> "std::copy(_II,_II,_OI) [with _II = __gnu_cxx::__normal_iterator<const long int*,std::vector<long int> >,_OI = long int*]"
"std::copy(_II,_II,_OI) [with _II = __gnu_cxx::__normal_iterator<const long int*,std::vector<long int> >,_OI = long int*]" -> "std::__copy_move_a2(_II,_II,_OI) [with bool _IsMove = false,_II = __gnu_cxx::__normal_iterator<const long int*,std::vector<long int> >,_OI = long int*]"
"std::copy(_II,_II,_OI) [with _II = __gnu_cxx::__normal_iterator<const long int*,std::vector<long int> >,_OI = long int*]" -> "std::__miter_base(_Iterator) [with _Iterator = __gnu_cxx::__normal_iterator<const long int*,std::vector<long int> >,typename std::_Miter_base<_Iterator>::iterator_type = __gnu_cxx::__normal_iterator<const long int*,std::vector<long int> >]"
"std::__copy_move_a2(_II,_II,_OI) [with bool _IsMove = false,_II = __gnu_cxx::__normal_iterator<const long int*,std::vector<long int> >,_OI = long int*]" -> "std::__copy_move_a(_II,_II,_OI) [with bool _IsMove = false,_II = const long int*,_OI = long int*]"
"std::__copy_move_a2(_II,_II,_OI) [with bool _IsMove = false,_II = __gnu_cxx::__normal_iterator<const long int*,std::vector<long int> >,_OI = long int*]" -> "std::__niter_base(_Iterator) [with _Iterator = long int*,typename std::_Niter_base<_Iterator>::iterator_type = long int*]"
"std::__copy_move_a2(_II,_II,_OI) [with bool _IsMove = false,_II = __gnu_cxx::__normal_iterator<const long int*,std::vector<long int> >,_OI = long int*]" -> "std::__niter_base(_Iterator) [with _Iterator = __gnu_cxx::__normal_iterator<const long int*,std::vector<long int> >,typename std::_Niter_base<_Iterator>::iterator_type = const long int*]"
"std::__copy_move_a(_II,_II,_OI) [with bool _IsMove = false,_II = const long int*,_OI = long int*]" -> "std::random_access_iterator_tag>::__copy_m(const _Tp*,const _Tp*,_Tp*) [with _Tp = long int,bool _IsMove = false]"
"std::__niter_base(_Iterator) [with _Iterator = __gnu_cxx::__normal_iterator<const long int*,std::vector<long int> >,typename std::_Niter_base<_Iterator>::iterator_type = const long int*]" -> "true>::_S_base(_Iterator) [with _Iterator = __gnu_cxx::__normal_iterator<const long int*,std::vector<long int> >,std::_Iter_base<_Iterator,true>::iterator_type = const long int*]"
"true>::_S_base(_Iterator) [with _Iterator = __gnu_cxx::__normal_iterator<const long int*,std::vector<long int> >,std::_Iter_base<_Iterator,true>::iterator_type = const long int*]" -> "_Container>::base() const [with _Iterator = const long int*,_Container = std::vector<long int>]"
"std::__miter_base(_Iterator) [with _Iterator = __gnu_cxx::__normal_iterator<const long int*,std::vector<long int> >,typename std::_Miter_base<_Iterator>::iterator_type = __gnu_cxx::__normal_iterator<const long int*,std::vector<long int> >]" -> "_HasBase>::_S_base(_Iterator) [with _Iterator = __gnu_cxx::__normal_iterator<const long int*,std::vector<long int> >,bool _HasBase = false,std::_Iter_base<_Iterator,_HasBase>::iterator_type = __gnu_cxx::__normal_iterator<const long int*,std::vector<long int> >]"
"_Alloc>::end() const [with _Tp = long int,_Alloc = std::allocator<long int>,std::vector<_Tp,_Alloc>::const_iterator = __gnu_cxx::__normal_iterator<const long int*,std::vector<long int> >,typename std::_Vector_base<_Tp,_Alloc>::_Tp_alloc_type::const_pointer = const long int*]" -> "_Container>::__normal_iterator(const _Iterator&) [with _Iterator = const long int*,_Container = std::vector<long int>]"
"_Alloc>::_Vector_base(std::size_t,const allocator_type&) [with _Tp = long int,_Alloc = std::allocator<long int>,std::size_t = long unsigned int,std::_Vector_base<_Tp,_Alloc>::allocator_type = std::allocator<long int>]" -> "_Alloc>::_Vector_impl::_Vector_impl(const _Tp_alloc_type&) [with _Tp = long int,_Alloc = std::allocator<long int>,std::_Vector_base<_Tp,_Alloc>::_Tp_alloc_type = std::allocator<long int>]"
"_Alloc>::_Vector_base(std::size_t,const allocator_type&) [with _Tp = long int,_Alloc = std::allocator<long int>,std::size_t = long unsigned int,std::_Vector_base<_Tp,_Alloc>::allocator_type = std::allocator<long int>]" -> "_Alloc>::_M_allocate(std::size_t) [with _Tp = long int,_Alloc = std::allocator<long int>,typename _Alloc::rebind<_Tp>::other::pointer = long int*,std::size_t = long unsigned int]"
"_Alloc>::_Vector_impl::_Vector_impl(const _Tp_alloc_type&) [with _Tp = long int,_Alloc = std::allocator<long int>,std::_Vector_base<_Tp,_Alloc>::_Tp_alloc_type = std::allocator<long int>]" -> "std::allocator<_Alloc>::allocator(const std::allocator<_Alloc>&) [with _Tp = long int,std::allocator<_Alloc> = std::allocator<long int>]"
"std::allocator<_Alloc>::allocator(const std::allocator<_Alloc>&) [with _Tp = long int,std::allocator<_Alloc> = std::allocator<long int>]" -> "__gnu_cxx::new_allocator<_Tp>::new_allocator(const __gnu_cxx::new_allocator<_Tp>&) [with _Tp = long int,__gnu_cxx::new_allocator<_Tp> = __gnu_cxx::new_allocator<long int>]"
"_Alloc>::_M_insert_aux(std::vector<_Tp,_Alloc>::iterator,const _Tp&) [with _Tp = std::vector<long int>,_Alloc = std::allocator<std::vector<long int> >,std::vector<_Tp,_Alloc>::iterator = __gnu_cxx::__normal_iterator<std::vector<long int>*,std::vector<std::vector<long int> > >,typename std::_Vector_base<_Tp,_Alloc>::_Tp_alloc_type::pointer = std::vector<long int>*]" -> "_Alloc>::operator=(const std::vector<_Tp,_Alloc>&) [with _Tp = long int,_Alloc = std::allocator<long int>]"
"_Alloc>::_M_insert_aux(std::vector<_Tp,_Alloc>::iterator,const _Tp&) [with _Tp = std::vector<long int>,_Alloc = std::allocator<std::vector<long int> >,std::vector<_Tp,_Alloc>::iterator = __gnu_cxx::__normal_iterator<std::vector<long int>*,std::vector<std::vector<long int> > >,typename std::_Vector_base<_Tp,_Alloc>::_Tp_alloc_type::pointer = std::vector<long int>*]" -> "_Alloc>::_M_get_Tp_allocator() [with _Tp = std::vector<long int>,_Alloc = std::allocator<std::vector<long int> >,std::_Vector_base<_Tp,_Alloc>::_Tp_alloc_type = std::allocator<std::vector<long int> >]"
"_Alloc>::_M_insert_aux(std::vector<_Tp,_Alloc>::iterator,const _Tp&) [with _Tp = std::vector<long int>,_Alloc = std::allocator<std::vector<long int> >,std::vector<_Tp,_Alloc>::iterator = __gnu_cxx::__normal_iterator<std::vector<long int>*,std::vector<std::vector<long int> > >,typename std::_Vector_base<_Tp,_Alloc>::_Tp_alloc_type::pointer = std::vector<long int>*]" -> "std::_Destroy(_ForwardIterator,_ForwardIterator,std::allocator<_T2>&) [with _ForwardIterator = std::vector<long int>*,_Tp = std::vector<long int>]"
"_Alloc>::_M_insert_aux(std::vector<_Tp,_Alloc>::iterator,const _Tp&) [with _Tp = std::vector<long int>,_Alloc = std::allocator<std::vector<long int> >,std::vector<_Tp,_Alloc>::iterator = __gnu_cxx::__normal_iterator<std::vector<long int>*,std::vector<std::vector<long int> > >,typename std::_Vector_base<_Tp,_Alloc>::_Tp_alloc_type::pointer = std::vector<long int>*]" -> "_Alloc>::begin() [with _Tp = std::vector<long int>,_Alloc = std::allocator<std::vector<long int> >,std::vector<_Tp,_Alloc>::iterator = __gnu_cxx::__normal_iterator<std::vector<long int>*,std::vector<std::vector<long int> > >,typename std::_Vector_base<_Tp,_Alloc>::_Tp_alloc_type::pointer = std::vector<long int>*]"
"_Alloc>::_M_insert_aux(std::vector<_Tp,_Alloc>::iterator,const _Tp&) [with _Tp = std::vector<long int>,_Alloc = std::allocator<std::vector<long int> >,std::vector<_Tp,_Alloc>::iterator = __gnu_cxx::__normal_iterator<std::vector<long int>*,std::vector<std::vector<long int> > >,typename std::_Vector_base<_Tp,_Alloc>::_Tp_alloc_type::pointer = std::vector<long int>*]" -> "__gnu_cxx::new_allocator<_Tp>::construct(__gnu_cxx::new_allocator<_Tp>::pointer,const _Tp&) [with _Tp = std::vector<long int>,__gnu_cxx::new_allocator<_Tp>::pointer = std::vector<long int>*]"
"_Alloc>::_M_insert_aux(std::vector<_Tp,_Alloc>::iterator,const _Tp&) [with _Tp = std::vector<long int>,_Alloc = std::allocator<std::vector<long int> >,std::vector<_Tp,_Alloc>::iterator = __gnu_cxx::__normal_iterator<std::vector<long int>*,std::vector<std::vector<long int> > >,typename std::_Vector_base<_Tp,_Alloc>::_Tp_alloc_type::pointer = std::vector<long int>*]" -> "_Alloc>::_M_deallocate(typename _Alloc::rebind<_Tp>::other::pointer,std::size_t) [with _Tp = std::vector<long int>,_Alloc = std::allocator<std::vector<long int> >,typename _Alloc::rebind<_Tp>::other::pointer = std::vector<long int>*,std::size_t = long unsigned int]"
"_Alloc>::_M_insert_aux(std::vector<_Tp,_Alloc>::iterator,const _Tp&) [with _Tp = std::vector<long int>,_Alloc = std::allocator<std::vector<long int> >,std::vector<_Tp,_Alloc>::iterator = __gnu_cxx::__normal_iterator<std::vector<long int>*,std::vector<std::vector<long int> > >,typename std::_Vector_base<_Tp,_Alloc>::_Tp_alloc_type::pointer = std::vector<long int>*]" -> "__cxa_rethrow()"
"_Alloc>::_M_insert_aux(std::vector<_Tp,_Alloc>::iterator,const _Tp&) [with _Tp = std::vector<long int>,_Alloc = std::allocator<std::vector<long int> >,std::vector<_Tp,_Alloc>::iterator = __gnu_cxx::__normal_iterator<std::vector<long int>*,std::vector<std::vector<long int> > >,typename std::_Vector_base<_Tp,_Alloc>::_Tp_alloc_type::pointer = std::vector<long int>*]" -> "_Alloc>::_M_allocate(std::size_t) [with _Tp = std::vector<long int>,_Alloc = std::allocator<std::vector<long int> >,typename _Alloc::rebind<_Tp>::other::pointer = std::vector<long int>*,std::size_t = long unsigned int]"
"_Alloc>::_M_insert_aux(std::vector<_Tp,_Alloc>::iterator,const _Tp&) [with _Tp = std::vector<long int>,_Alloc = std::allocator<std::vector<long int> >,std::vector<_Tp,_Alloc>::iterator = __gnu_cxx::__normal_iterator<std::vector<long int>*,std::vector<std::vector<long int> > >,typename std::_Vector_base<_Tp,_Alloc>::_Tp_alloc_type::pointer = std::vector<long int>*]" -> "__builtin_eh_pointer(int)"
"_Alloc>::_M_insert_aux(std::vector<_Tp,_Alloc>::iterator,const _Tp&) [with _Tp = std::vector<long int>,_Alloc = std::allocator<std::vector<long int> >,std::vector<_Tp,_Alloc>::iterator = __gnu_cxx::__normal_iterator<std::vector<long int>*,std::vector<std::vector<long int> > >,typename std::_Vector_base<_Tp,_Alloc>::_Tp_alloc_type::pointer = std::vector<long int>*]" -> "_Container>::base() const [with _Iterator = std::vector<long int>*,_Container = std::vector<std::vector<long int> >]"
"_Alloc>::_M_insert_aux(std::vector<_Tp,_Alloc>::iterator,const _Tp&) [with _Tp = std::vector<long int>,_Alloc = std::allocator<std::vector<long int> >,std::vector<_Tp,_Alloc>::iterator = __gnu_cxx::__normal_iterator<std::vector<long int>*,std::vector<std::vector<long int> > >,typename std::_Vector_base<_Tp,_Alloc>::_Tp_alloc_type::pointer = std::vector<long int>*]" -> "_Alloc>::_M_check_len(std::vector<_Tp,_Alloc>::size_type,const char*) const [with _Tp = std::vector<long int>,_Alloc = std::allocator<std::vector<long int> >,std::vector<_Tp,_Alloc>::size_type = long unsigned int]"
"_Alloc>::_M_insert_aux(std::vector<_Tp,_Alloc>::iterator,const _Tp&) [with _Tp = std::vector<long int>,_Alloc = std::allocator<std::vector<long int> >,std::vector<_Tp,_Alloc>::iterator = __gnu_cxx::__normal_iterator<std::vector<long int>*,std::vector<std::vector<long int> > >,typename std::_Vector_base<_Tp,_Alloc>::_Tp_alloc_type::pointer = std::vector<long int>*]" -> "__gnu_cxx::operator-(const __gnu_cxx::__normal_iterator<_Iterator,_Container>&,const __gnu_cxx::__normal_iterator<_Iterator,_Container>&) [with _Iterator = std::vector<long int>*,_Container = std::vector<std::vector<long int> >,typename __gnu_cxx::__normal_iterator<_Iterator,_Container>::difference_type = long int]"
"_Alloc>::_M_insert_aux(std::vector<_Tp,_Alloc>::iterator,const _Tp&) [with _Tp = std::vector<long int>,_Alloc = std::allocator<std::vector<long int> >,std::vector<_Tp,_Alloc>::iterator = __gnu_cxx::__normal_iterator<std::vector<long int>*,std::vector<std::vector<long int> > >,typename std::_Vector_base<_Tp,_Alloc>::_Tp_alloc_type::pointer = std::vector<long int>*]" -> "__cxa_end_catch()"
"_Alloc>::_M_insert_aux(std::vector<_Tp,_Alloc>::iterator,const _Tp&) [with _Tp = std::vector<long int>,_Alloc = std::allocator<std::vector<long int> >,std::vector<_Tp,_Alloc>::iterator = __gnu_cxx::__normal_iterator<std::vector<long int>*,std::vector<std::vector<long int> > >,typename std::_Vector_base<_Tp,_Alloc>::_Tp_alloc_type::pointer = std::vector<long int>*]" -> "_Alloc>::vector(const std::vector<_Tp,_Alloc>&) [with _Tp = long int,_Alloc = std::allocator<long int>,std::vector<_Tp,_Alloc> = std::vector<long int>]"
"_Alloc>::_M_insert_aux(std::vector<_Tp,_Alloc>::iterator,const _Tp&) [with _Tp = std::vector<long int>,_Alloc = std::allocator<std::vector<long int> >,std::vector<_Tp,_Alloc>::iterator = __gnu_cxx::__normal_iterator<std::vector<long int>*,std::vector<std::vector<long int> > >,typename std::_Vector_base<_Tp,_Alloc>::_Tp_alloc_type::pointer = std::vector<long int>*]" -> "__cxa_begin_catch(void*)"
"_Alloc>::_M_insert_aux(std::vector<_Tp,_Alloc>::iterator,const _Tp&) [with _Tp = std::vector<long int>,_Alloc = std::allocator<std::vector<long int> >,std::vector<_Tp,_Alloc>::iterator = __gnu_cxx::__normal_iterator<std::vector<long int>*,std::vector<std::vector<long int> > >,typename std::_Vector_base<_Tp,_Alloc>::_Tp_alloc_type::pointer = std::vector<long int>*]" -> "__gnu_cxx::new_allocator<_Tp>::destroy(__gnu_cxx::new_allocator<_Tp>::pointer) [with _Tp = std::vector<long int>,__gnu_cxx::new_allocator<_Tp>::pointer = std::vector<long int>*]"
"_Alloc>::_M_insert_aux(std::vector<_Tp,_Alloc>::iterator,const _Tp&) [with _Tp = std::vector<long int>,_Alloc = std::allocator<std::vector<long int> >,std::vector<_Tp,_Alloc>::iterator = __gnu_cxx::__normal_iterator<std::vector<long int>*,std::vector<std::vector<long int> > >,typename std::_Vector_base<_Tp,_Alloc>::_Tp_alloc_type::pointer = std::vector<long int>*]" -> "std::__uninitialized_move_a(_InputIterator,_InputIterator,_ForwardIterator,_Allocator&) [with _InputIterator = std::vector<long int>*,_ForwardIterator = std::vector<long int>*,_Allocator = std::allocator<std::vector<long int> >]"
"_Alloc>::_M_insert_aux(std::vector<_Tp,_Alloc>::iterator,const _Tp&) [with _Tp = std::vector<long int>,_Alloc = std::allocator<std::vector<long int> >,std::vector<_Tp,_Alloc>::iterator = __gnu_cxx::__normal_iterator<std::vector<long int>*,std::vector<std::vector<long int> > >,typename std::_Vector_base<_Tp,_Alloc>::_Tp_alloc_type::pointer = std::vector<long int>*]" -> "_Container>::operator*() const [with _Iterator = std::vector<long int>*,_Container = std::vector<std::vector<long int> >,__gnu_cxx::__normal_iterator<_Iterator,_Container>::reference = std::vector<long int>&]"
"_Alloc>::_M_insert_aux(std::vector<_Tp,_Alloc>::iterator,const _Tp&) [with _Tp = std::vector<long int>,_Alloc = std::allocator<std::vector<long int> >,std::vector<_Tp,_Alloc>::iterator = __gnu_cxx::__normal_iterator<std::vector<long int>*,std::vector<std::vector<long int> > >,typename std::_Vector_base<_Tp,_Alloc>::_Tp_alloc_type::pointer = std::vector<long int>*]" -> "std::copy_backward(_BI1,_BI1,_BI2) [with _BI1 = std::vector<long int>*,_BI2 = std::vector<long int>*]"
"_Alloc>::operator=(const std::vector<_Tp,_Alloc>&) [with _Tp = long int,_Alloc = std::allocator<long int>]" -> "_Alloc>::_M_get_Tp_allocator() [with _Tp = long int,_Alloc = std::allocator<long int>,std::_Vector_base<_Tp,_Alloc>::_Tp_alloc_type = std::allocator<long int>]"
"_Alloc>::operator=(const std::vector<_Tp,_Alloc>&) [with _Tp = long int,_Alloc = std::allocator<long int>]" -> "std::_Destroy(_ForwardIterator,_ForwardIterator,std::allocator<_T2>&) [with _ForwardIterator = __gnu_cxx::__normal_iterator<long int*,std::vector<long int> >,_Tp = long int]"
"_Alloc>::operator=(const std::vector<_Tp,_Alloc>&) [with _Tp = long int,_Alloc = std::allocator<long int>]" -> "_Alloc>::size() const [with _Tp = long int,_Alloc = std::allocator<long int>,std::vector<_Tp,_Alloc>::size_type = long unsigned int]"
"_Alloc>::operator=(const std::vector<_Tp,_Alloc>&) [with _Tp = long int,_Alloc = std::allocator<long int>]" -> "std::copy(_II,_II,_OI) [with _II = long int*,_OI = long int*]"
"_Alloc>::operator=(const std::vector<_Tp,_Alloc>&) [with _Tp = long int,_Alloc = std::allocator<long int>]" -> "std::_Destroy(_ForwardIterator,_ForwardIterator,std::allocator<_T2>&) [with _ForwardIterator = long int*,_Tp = long int]"
"_Alloc>::operator=(const std::vector<_Tp,_Alloc>&) [with _Tp = long int,_Alloc = std::allocator<long int>]" -> "_Alloc>::begin() const [with _Tp = long int,_Alloc = std::allocator<long int>,std::vector<_Tp,_Alloc>::const_iterator = __gnu_cxx::__normal_iterator<const long int*,std::vector<long int> >,typename std::_Vector_base<_Tp,_Alloc>::_Tp_alloc_type::const_pointer = const long int*]"
"_Alloc>::operator=(const std::vector<_Tp,_Alloc>&) [with _Tp = long int,_Alloc = std::allocator<long int>]" -> "std::copy(_II,_II,_OI) [with _II = __gnu_cxx::__normal_iterator<const long int*,std::vector<long int> >,_OI = __gnu_cxx::__normal_iterator<long int*,std::vector<long int> >]"
"_Alloc>::operator=(const std::vector<_Tp,_Alloc>&) [with _Tp = long int,_Alloc = std::allocator<long int>]" -> "_Alloc>::end() [with _Tp = long int,_Alloc = std::allocator<long int>,std::vector<_Tp,_Alloc>::iterator = __gnu_cxx::__normal_iterator<long int*,std::vector<long int> >,typename std::_Vector_base<_Tp,_Alloc>::_Tp_alloc_type::pointer = long int*]"
"_Alloc>::operator=(const std::vector<_Tp,_Alloc>&) [with _Tp = long int,_Alloc = std::allocator<long int>]" -> "_Alloc>::begin() [with _Tp = long int,_Alloc = std::allocator<long int>,std::vector<_Tp,_Alloc>::iterator = __gnu_cxx::__normal_iterator<long int*,std::vector<long int> >,typename std::_Vector_base<_Tp,_Alloc>::_Tp_alloc_type::pointer = long int*]"
"_Alloc>::operator=(const std::vector<_Tp,_Alloc>&) [with _Tp = long int,_Alloc = std::allocator<long int>]" -> "_Alloc>::capacity() const [with _Tp = long int,_Alloc = std::allocator<long int>,std::vector<_Tp,_Alloc>::size_type = long unsigned int]"
"_Alloc>::operator=(const std::vector<_Tp,_Alloc>&) [with _Tp = long int,_Alloc = std::allocator<long int>]" -> "std::__uninitialized_copy_a(_InputIterator,_InputIterator,_ForwardIterator,std::allocator<_Tp>&) [with _InputIterator = long int*,_ForwardIterator = long int*,_Tp = long int]"
"_Alloc>::operator=(const std::vector<_Tp,_Alloc>&) [with _Tp = long int,_Alloc = std::allocator<long int>]" -> "_Alloc>::_M_deallocate(typename _Alloc::rebind<_Tp>::other::pointer,std::size_t) [with _Tp = long int,_Alloc = std::allocator<long int>,typename _Alloc::rebind<_Tp>::other::pointer = long int*,std::size_t = long unsigned int]"
"_Alloc>::operator=(const std::vector<_Tp,_Alloc>&) [with _Tp = long int,_Alloc = std::allocator<long int>]" -> "_Alloc>::end() const [with _Tp = long int,_Alloc = std::allocator<long int>,std::vector<_Tp,_Alloc>::const_iterator = __gnu_cxx::__normal_iterator<const long int*,std::vector<long int> >,typename std::_Vector_base<_Tp,_Alloc>::_Tp_alloc_type::const_pointer = const long int*]"
"_Alloc>::operator=(const std::vector<_Tp,_Alloc>&) [with _Tp = long int,_Alloc = std::allocator<long int>]" -> "_Alloc>::_M_allocate_and_copy(std::vector<_Tp,_Alloc>::size_type,_ForwardIterator,_ForwardIterator) [with _ForwardIterator = __gnu_cxx::__normal_iterator<const long int*,std::vector<long int> >,_Tp = long int,_Alloc = std::allocator<long int>,std::vector<_Tp,_Alloc>::pointer = long int*,std::vector<_Tp,_Alloc>::size_type = long unsigned int]"
"std::_Destroy(_ForwardIterator,_ForwardIterator,std::allocator<_T2>&) [with _ForwardIterator = __gnu_cxx::__normal_iterator<long int*,std::vector<long int> >,_Tp = long int]" -> "std::_Destroy(_ForwardIterator,_ForwardIterator) [with _ForwardIterator = __gnu_cxx::__normal_iterator<long int*,std::vector<long int> >]"
"std::_Destroy(_ForwardIterator,_ForwardIterator) [with _ForwardIterator = __gnu_cxx::__normal_iterator<long int*,std::vector<long int> >]" -> "std::_Destroy_aux<true>::__destroy(_ForwardIterator,_ForwardIterator) [with _ForwardIterator = __gnu_cxx::__normal_iterator<long int*,std::vector<long int> >]"
"std::copy(_II,_II,_OI) [with _II = __gnu_cxx::__normal_iterator<const long int*,std::vector<long int> >,_OI = __gnu_cxx::__normal_iterator<long int*,std::vector<long int> >]" -> "std::__copy_move_a2(_II,_II,_OI) [with bool _IsMove = false,_II = __gnu_cxx::__normal_iterator<const long int*,std::vector<long int> >,_OI = __gnu_cxx::__normal_iterator<long int*,std::vector<long int> >]"
"std::copy(_II,_II,_OI) [with _II = __gnu_cxx::__normal_iterator<const long int*,std::vector<long int> >,_OI = __gnu_cxx::__normal_iterator<long int*,std::vector<long int> >]" -> "std::__miter_base(_Iterator) [with _Iterator = __gnu_cxx::__normal_iterator<const long int*,std::vector<long int> >,typename std::_Miter_base<_Iterator>::iterator_type = __gnu_cxx::__normal_iterator<const long int*,std::vector<long int> >]"
"std::__copy_move_a2(_II,_II,_OI) [with bool _IsMove = false,_II = __gnu_cxx::__normal_iterator<const long int*,std::vector<long int> >,_OI = __gnu_cxx::__normal_iterator<long int*,std::vector<long int> >]" -> "std::__copy_move_a(_II,_II,_OI) [with bool _IsMove = false,_II = const long int*,_OI = long int*]"
"std::__copy_move_a2(_II,_II,_OI) [with bool _IsMove = false,_II = __gnu_cxx::__normal_iterator<const long int*,std::vector<long int> >,_OI = __gnu_cxx::__normal_iterator<long int*,std::vector<long int> >]" -> "_Container>::__normal_iterator(const _Iterator&) [with _Iterator = long int*,_Container = std::vector<long int>]"
"std::__copy_move_a2(_II,_II,_OI) [with bool _IsMove = false,_II = __gnu_cxx::__normal_iterator<const long int*,std::vector<long int> >,_OI = __gnu_cxx::__normal_iterator<long int*,std::vector<long int> >]" -> "std::__niter_base(_Iterator) [with _Iterator = __gnu_cxx::__normal_iterator<long int*,std::vector<long int> >,typename std::_Niter_base<_Iterator>::iterator_type = long int*]"
"std::__copy_move_a2(_II,_II,_OI) [with bool _IsMove = false,_II = __gnu_cxx::__normal_iterator<const long int*,std::vector<long int> >,_OI = __gnu_cxx::__normal_iterator<long int*,std::vector<long int> >]" -> "std::__niter_base(_Iterator) [with _Iterator = __gnu_cxx::__normal_iterator<const long int*,std::vector<long int> >,typename std::_Niter_base<_Iterator>::iterator_type = const long int*]"
"std::__niter_base(_Iterator) [with _Iterator = __gnu_cxx::__normal_iterator<long int*,std::vector<long int> >,typename std::_Niter_base<_Iterator>::iterator_type = long int*]" -> "true>::_S_base(_Iterator) [with _Iterator = __gnu_cxx::__normal_iterator<long int*,std::vector<long int> >,std::_Iter_base<_Iterator,true>::iterator_type = long int*]"
"true>::_S_base(_Iterator) [with _Iterator = __gnu_cxx::__normal_iterator<long int*,std::vector<long int> >,std::_Iter_base<_Iterator,true>::iterator_type = long int*]" -> "_Container>::base() const [with _Iterator = long int*,_Container = std::vector<long int>]"
"_Alloc>::_M_allocate_and_copy(std::vector<_Tp,_Alloc>::size_type,_ForwardIterator,_ForwardIterator) [with _ForwardIterator = __gnu_cxx::__normal_iterator<const long int*,std::vector<long int> >,_Tp = long int,_Alloc = std::allocator<long int>,std::vector<_Tp,_Alloc>::pointer = long int*,std::vector<_Tp,_Alloc>::size_type = long unsigned int]" -> "_Alloc>::_M_deallocate(typename _Alloc::rebind<_Tp>::other::pointer,std::size_t) [with _Tp = long int,_Alloc = std::allocator<long int>,typename _Alloc::rebind<_Tp>::other::pointer = long int*,std::size_t = long unsigned int]"
"_Alloc>::_M_allocate_and_copy(std::vector<_Tp,_Alloc>::size_type,_ForwardIterator,_ForwardIterator) [with _ForwardIterator = __gnu_cxx::__normal_iterator<const long int*,std::vector<long int> >,_Tp = long int,_Alloc = std::allocator<long int>,std::vector<_Tp,_Alloc>::pointer = long int*,std::vector<_Tp,_Alloc>::size_type = long unsigned int]" -> "std::__uninitialized_copy_a(_InputIterator,_InputIterator,_ForwardIterator,std::allocator<_Tp>&) [with _InputIterator = __gnu_cxx::__normal_iterator<const long int*,std::vector<long int> >,_ForwardIterator = long int*,_Tp = long int]"
"_Alloc>::_M_allocate_and_copy(std::vector<_Tp,_Alloc>::size_type,_ForwardIterator,_ForwardIterator) [with _ForwardIterator = __gnu_cxx::__normal_iterator<const long int*,std::vector<long int> >,_Tp = long int,_Alloc = std::allocator<long int>,std::vector<_Tp,_Alloc>::pointer = long int*,std::vector<_Tp,_Alloc>::size_type = long unsigned int]" -> "_Alloc>::_M_get_Tp_allocator() [with _Tp = long int,_Alloc = std::allocator<long int>,std::_Vector_base<_Tp,_Alloc>::_Tp_alloc_type = std::allocator<long int>]"
"_Alloc>::_M_allocate_and_copy(std::vector<_Tp,_Alloc>::size_type,_ForwardIterator,_ForwardIterator) [with _ForwardIterator = __gnu_cxx::__normal_iterator<const long int*,std::vector<long int> >,_Tp = long int,_Alloc = std::allocator<long int>,std::vector<_Tp,_Alloc>::pointer = long int*,std::vector<_Tp,_Alloc>::size_type = long unsigned int]" -> "__cxa_begin_catch(void*)"
"_Alloc>::_M_allocate_and_copy(std::vector<_Tp,_Alloc>::size_type,_ForwardIterator,_ForwardIterator) [with _ForwardIterator = __gnu_cxx::__normal_iterator<const long int*,std::vector<long int> >,_Tp = long int,_Alloc = std::allocator<long int>,std::vector<_Tp,_Alloc>::pointer = long int*,std::vector<_Tp,_Alloc>::size_type = long unsigned int]" -> "__cxa_rethrow()"
"_Alloc>::_M_allocate_and_copy(std::vector<_Tp,_Alloc>::size_type,_ForwardIterator,_ForwardIterator) [with _ForwardIterator = __gnu_cxx::__normal_iterator<const long int*,std::vector<long int> >,_Tp = long int,_Alloc = std::allocator<long int>,std::vector<_Tp,_Alloc>::pointer = long int*,std::vector<_Tp,_Alloc>::size_type = long unsigned int]" -> "_Alloc>::_M_allocate(std::size_t) [with _Tp = long int,_Alloc = std::allocator<long int>,typename _Alloc::rebind<_Tp>::other::pointer = long int*,std::size_t = long unsigned int]"
"_Alloc>::_M_allocate_and_copy(std::vector<_Tp,_Alloc>::size_type,_ForwardIterator,_ForwardIterator) [with _ForwardIterator = __gnu_cxx::__normal_iterator<const long int*,std::vector<long int> >,_Tp = long int,_Alloc = std::allocator<long int>,std::vector<_Tp,_Alloc>::pointer = long int*,std::vector<_Tp,_Alloc>::size_type = long unsigned int]" -> "__builtin_eh_pointer(int)"
"_Alloc>::_M_allocate_and_copy(std::vector<_Tp,_Alloc>::size_type,_ForwardIterator,_ForwardIterator) [with _ForwardIterator = __gnu_cxx::__normal_iterator<const long int*,std::vector<long int> >,_Tp = long int,_Alloc = std::allocator<long int>,std::vector<_Tp,_Alloc>::pointer = long int*,std::vector<_Tp,_Alloc>::size_type = long unsigned int]" -> "__cxa_end_catch()"
"std::_Destroy(_ForwardIterator,_ForwardIterator,std::allocator<_T2>&) [with _ForwardIterator = std::vector<long int>*,_Tp = std::vector<long int>]" -> "std::_Destroy(_ForwardIterator,_ForwardIterator) [with _ForwardIterator = std::vector<long int>*]"
"std::_Destroy(_ForwardIterator,_ForwardIterator) [with _ForwardIterator = std::vector<long int>*]" -> ">::__destroy(_ForwardIterator,_ForwardIterator) [with _ForwardIterator = std::vector<long int>*,bool <anonymous> = false]"
">::__destroy(_ForwardIterator,_ForwardIterator) [with _ForwardIterator = std::vector<long int>*,bool <anonymous> = false]" -> "std::__addressof(_Tp&) [with _Tp = std::vector<long int>]"
">::__destroy(_ForwardIterator,_ForwardIterator) [with _ForwardIterator = std::vector<long int>*,bool <anonymous> = false]" -> "std::_Destroy(_Tp*) [with _Tp = std::vector<long int>]"
"_Alloc>::begin() [with _Tp = std::vector<long int>,_Alloc = std::allocator<std::vector<long int> >,std::vector<_Tp,_Alloc>::iterator = __gnu_cxx::__normal_iterator<std::vector<long int>*,std::vector<std::vector<long int> > >,typename std::_Vector_base<_Tp,_Alloc>::_Tp_alloc_type::pointer = std::vector<long int>*]" -> "_Container>::__normal_iterator(const _Iterator&) [with _Iterator = std::vector<long int>*,_Container = std::vector<std::vector<long int> >]"
"_Alloc>::_M_deallocate(typename _Alloc::rebind<_Tp>::other::pointer,std::size_t) [with _Tp = std::vector<long int>,_Alloc = std::allocator<std::vector<long int> >,typename _Alloc::rebind<_Tp>::other::pointer = std::vector<long int>*,std::size_t = long unsigned int]" -> "__gnu_cxx::new_allocator<_Tp>::deallocate(__gnu_cxx::new_allocator<_Tp>::pointer,__gnu_cxx::new_allocator<_Tp>::size_type) [with _Tp = std::vector<long int>,__gnu_cxx::new_allocator<_Tp>::pointer = std::vector<long int>*,__gnu_cxx::new_allocator<_Tp>::size_type = long unsigned int]"
"_Alloc>::_M_allocate(std::size_t) [with _Tp = std::vector<long int>,_Alloc = std::allocator<std::vector<long int> >,typename _Alloc::rebind<_Tp>::other::pointer = std::vector<long int>*,std::size_t = long unsigned int]" -> "__gnu_cxx::new_allocator<_Tp>::allocate(__gnu_cxx::new_allocator<_Tp>::size_type,const void*) [with _Tp = std::vector<long int>,__gnu_cxx::new_allocator<_Tp>::pointer = std::vector<long int>*,__gnu_cxx::new_allocator<_Tp>::size_type = long unsigned int]"
"__gnu_cxx::new_allocator<_Tp>::allocate(__gnu_cxx::new_allocator<_Tp>::size_type,const void*) [with _Tp = std::vector<long int>,__gnu_cxx::new_allocator<_Tp>::pointer = std::vector<long int>*,__gnu_cxx::new_allocator<_Tp>::size_type = long unsigned int]" -> "__gnu_cxx::new_allocator<_Tp>::max_size() const [with _Tp = std::vector<long int>,__gnu_cxx::new_allocator<_Tp>::size_type = long unsigned int]"
"__gnu_cxx::new_allocator<_Tp>::allocate(__gnu_cxx::new_allocator<_Tp>::size_type,const void*) [with _Tp = std::vector<long int>,__gnu_cxx::new_allocator<_Tp>::pointer = std::vector<long int>*,__gnu_cxx::new_allocator<_Tp>::size_type = long unsigned int]" -> "std::__throw_bad_alloc()"
"_Alloc>::_M_check_len(std::vector<_Tp,_Alloc>::size_type,const char*) const [with _Tp = std::vector<long int>,_Alloc = std::allocator<std::vector<long int> >,std::vector<_Tp,_Alloc>::size_type = long unsigned int]" -> "std::__throw_length_error(const char*)"
"_Alloc>::_M_check_len(std::vector<_Tp,_Alloc>::size_type,const char*) const [with _Tp = std::vector<long int>,_Alloc = std::allocator<std::vector<long int> >,std::vector<_Tp,_Alloc>::size_type = long unsigned int]" -> "_Alloc>::max_size() const [with _Tp = std::vector<long int>,_Alloc = std::allocator<std::vector<long int> >,std::vector<_Tp,_Alloc>::size_type = long unsigned int]"
"_Alloc>::_M_check_len(std::vector<_Tp,_Alloc>::size_type,const char*) const [with _Tp = std::vector<long int>,_Alloc = std::allocator<std::vector<long int> >,std::vector<_Tp,_Alloc>::size_type = long unsigned int]" -> "_Alloc>::size() const [with _Tp = std::vector<long int>,_Alloc = std::allocator<std::vector<long int> >,std::vector<_Tp,_Alloc>::size_type = long unsigned int]"
"_Alloc>::_M_check_len(std::vector<_Tp,_Alloc>::size_type,const char*) const [with _Tp = std::vector<long int>,_Alloc = std::allocator<std::vector<long int> >,std::vector<_Tp,_Alloc>::size_type = long unsigned int]" -> "std::max(const _Tp&,const _Tp&) [with _Tp = long unsigned int]"
"_Alloc>::max_size() const [with _Tp = std::vector<long int>,_Alloc = std::allocator<std::vector<long int> >,std::vector<_Tp,_Alloc>::size_type = long unsigned int]" -> "__gnu_cxx::new_allocator<_Tp>::max_size() const [with _Tp = std::vector<long int>,__gnu_cxx::new_allocator<_Tp>::size_type = long unsigned int]"
"_Alloc>::max_size() const [with _Tp = std::vector<long int>,_Alloc = std::allocator<std::vector<long int> >,std::vector<_Tp,_Alloc>::size_type = long unsigned int]" -> "_Alloc>::_M_get_Tp_allocator() const [with _Tp = std::vector<long int>,_Alloc = std::allocator<std::vector<long int> >,std::_Vector_base<_Tp,_Alloc>::_Tp_alloc_type = std::allocator<std::vector<long int> >]"
"__gnu_cxx::operator-(const __gnu_cxx::__normal_iterator<_Iterator,_Container>&,const __gnu_cxx::__normal_iterator<_Iterator,_Container>&) [with _Iterator = std::vector<long int>*,_Container = std::vector<std::vector<long int> >,typename __gnu_cxx::__normal_iterator<_Iterator,_Container>::difference_type = long int]" -> "_Container>::base() const [with _Iterator = std::vector<long int>*,_Container = std::vector<std::vector<long int> >]"
"std::__uninitialized_move_a(_InputIterator,_InputIterator,_ForwardIterator,_Allocator&) [with _InputIterator = std::vector<long int>*,_ForwardIterator = std::vector<long int>*,_Allocator = std::allocator<std::vector<long int> >]" -> "std::__uninitialized_copy_a(_InputIterator,_InputIterator,_ForwardIterator,std::allocator<_Tp>&) [with _InputIterator = std::vector<long int>*,_ForwardIterator = std::vector<long int>*,_Tp = std::vector<long int>]"
"std::__uninitialized_copy_a(_InputIterator,_InputIterator,_ForwardIterator,std::allocator<_Tp>&) [with _InputIterator = std::vector<long int>*,_ForwardIterator = std::vector<long int>*,_Tp = std::vector<long int>]" -> "std::uninitialized_copy(_InputIterator,_InputIterator,_ForwardIterator) [with _InputIterator = std::vector<long int>*,_ForwardIterator = std::vector<long int>*]"
"std::uninitialized_copy(_InputIterator,_InputIterator,_ForwardIterator) [with _InputIterator = std::vector<long int>*,_ForwardIterator = std::vector<long int>*]" -> "std::__uninitialized_copy<_TrivialValueTypes>::__uninit_copy(_InputIterator,_InputIterator,_ForwardIterator) [with _InputIterator = std::vector<long int>*,_ForwardIterator = std::vector<long int>*,bool _TrivialValueTypes = false]"
"std::__uninitialized_copy<_TrivialValueTypes>::__uninit_copy(_InputIterator,_InputIterator,_ForwardIterator) [with _InputIterator = std::vector<long int>*,_ForwardIterator = std::vector<long int>*,bool _TrivialValueTypes = false]" -> "std::__addressof(_Tp&) [with _Tp = std::vector<long int>]"
"std::__uninitialized_copy<_TrivialValueTypes>::__uninit_copy(_InputIterator,_InputIterator,_ForwardIterator) [with _InputIterator = std::vector<long int>*,_ForwardIterator = std::vector<long int>*,bool _TrivialValueTypes = false]" -> "__cxa_begin_catch(void*)"
"std::__uninitialized_copy<_TrivialValueTypes>::__uninit_copy(_InputIterator,_InputIterator,_ForwardIterator) [with _InputIterator = std::vector<long int>*,_ForwardIterator = std::vector<long int>*,bool _TrivialValueTypes = false]" -> "__builtin_eh_pointer(int)"
"std::__uninitialized_copy<_TrivialValueTypes>::__uninit_copy(_InputIterator,_InputIterator,_ForwardIterator) [with _InputIterator = std::vector<long int>*,_ForwardIterator = std::vector<long int>*,bool _TrivialValueTypes = false]" -> "__cxa_rethrow()"
"std::__uninitialized_copy<_TrivialValueTypes>::__uninit_copy(_InputIterator,_InputIterator,_ForwardIterator) [with _InputIterator = std::vector<long int>*,_ForwardIterator = std::vector<long int>*,bool _TrivialValueTypes = false]" -> "std::_Destroy(_ForwardIterator,_ForwardIterator) [with _ForwardIterator = std::vector<long int>*]"
"std::__uninitialized_copy<_TrivialValueTypes>::__uninit_copy(_InputIterator,_InputIterator,_ForwardIterator) [with _InputIterator = std::vector<long int>*,_ForwardIterator = std::vector<long int>*,bool _TrivialValueTypes = false]" -> "std::_Construct(_T1*,const _T2&) [with _T1 = std::vector<long int>,_T2 = std::vector<long int>]"
"std::__uninitialized_copy<_TrivialValueTypes>::__uninit_copy(_InputIterator,_InputIterator,_ForwardIterator) [with _InputIterator = std::vector<long int>*,_ForwardIterator = std::vector<long int>*,bool _TrivialValueTypes = false]" -> "__cxa_end_catch()"
"std::_Construct(_T1*,const _T2&) [with _T1 = std::vector<long int>,_T2 = std::vector<long int>]" -> "_Alloc>::vector(const std::vector<_Tp,_Alloc>&) [with _Tp = long int,_Alloc = std::allocator<long int>,std::vector<_Tp,_Alloc> = std::vector<long int>]"
"std::copy_backward(_BI1,_BI1,_BI2) [with _BI1 = std::vector<long int>*,_BI2 = std::vector<long int>*]" -> "std::__copy_move_backward_a2(_BI1,_BI1,_BI2) [with bool _IsMove = false,_BI1 = std::vector<long int>*,_BI2 = std::vector<long int>*]"
"std::copy_backward(_BI1,_BI1,_BI2) [with _BI1 = std::vector<long int>*,_BI2 = std::vector<long int>*]" -> "std::__miter_base(_Iterator) [with _Iterator = std::vector<long int>*,typename std::_Miter_base<_Iterator>::iterator_type = std::vector<long int>*]"
"std::__copy_move_backward_a2(_BI1,_BI1,_BI2) [with bool _IsMove = false,_BI1 = std::vector<long int>*,_BI2 = std::vector<long int>*]" -> "std::__niter_base(_Iterator) [with _Iterator = std::vector<long int>*,typename std::_Niter_base<_Iterator>::iterator_type = std::vector<long int>*]"
"std::__copy_move_backward_a2(_BI1,_BI1,_BI2) [with bool _IsMove = false,_BI1 = std::vector<long int>*,_BI2 = std::vector<long int>*]" -> "std::__copy_move_backward_a(_BI1,_BI1,_BI2) [with bool _IsMove = false,_BI1 = std::vector<long int>*,_BI2 = std::vector<long int>*]"
"std::__niter_base(_Iterator) [with _Iterator = std::vector<long int>*,typename std::_Niter_base<_Iterator>::iterator_type = std::vector<long int>*]" -> "_HasBase>::_S_base(_Iterator) [with _Iterator = std::vector<long int>*,bool _HasBase = false,std::_Iter_base<_Iterator,_HasBase>::iterator_type = std::vector<long int>*]"
"std::__copy_move_backward_a(_BI1,_BI1,_BI2) [with bool _IsMove = false,_BI1 = std::vector<long int>*,_BI2 = std::vector<long int>*]" -> "std::random_access_iterator_tag>::__copy_move_b(_BI1,_BI1,_BI2) [with _BI1 = std::vector<long int>*,_BI2 = std::vector<long int>*]"
"std::random_access_iterator_tag>::__copy_move_b(_BI1,_BI1,_BI2) [with _BI1 = std::vector<long int>*,_BI2 = std::vector<long int>*]" -> "_Alloc>::operator=(const std::vector<_Tp,_Alloc>&) [with _Tp = long int,_Alloc = std::allocator<long int>]"
"std::__miter_base(_Iterator) [with _Iterator = std::vector<long int>*,typename std::_Miter_base<_Iterator>::iterator_type = std::vector<long int>*]" -> "_HasBase>::_S_base(_Iterator) [with _Iterator = std::vector<long int>*,bool _HasBase = false,std::_Iter_base<_Iterator,_HasBase>::iterator_type = std::vector<long int>*]"
"_Alloc>::deque() [with _Tp = const char*,_Alloc = std::allocator<const char*>]" -> "_Alloc>::_Deque_base() [with _Tp = const char*,_Alloc = std::allocator<const char*>]"
"_Alloc>::_Deque_base() [with _Tp = const char*,_Alloc = std::allocator<const char*>]" -> "_Alloc>::_M_initialize_map(std::size_t) [with _Tp = const char*,_Alloc = std::allocator<const char*>,std::size_t = long unsigned int]"
"_Alloc>::_Deque_base() [with _Tp = const char*,_Alloc = std::allocator<const char*>]" -> "_Alloc>::_Deque_impl::_Deque_impl() [with _Tp = const char*,_Alloc = std::allocator<const char*>]"
"_Alloc>::_M_initialize_map(std::size_t) [with _Tp = const char*,_Alloc = std::allocator<const char*>,std::size_t = long unsigned int]" -> "_Alloc>::_M_allocate_map(std::size_t) [with _Tp = const char*,_Alloc = std::allocator<const char*>,std::size_t = long unsigned int]"
"_Alloc>::_M_initialize_map(std::size_t) [with _Tp = const char*,_Alloc = std::allocator<const char*>,std::size_t = long unsigned int]" -> "_Ptr>::_M_set_node(std::_Deque_iterator<_Tp,_Ref,_Ptr>::_Map_pointer) [with _Tp = const char*,_Ref = const char*&,_Ptr = const char**,std::_Deque_iterator<_Tp,_Ref,_Ptr>::_Map_pointer = const char***]"
"_Alloc>::_M_initialize_map(std::size_t) [with _Tp = const char*,_Alloc = std::allocator<const char*>,std::size_t = long unsigned int]" -> "__builtin_eh_pointer(int)"
"_Alloc>::_M_initialize_map(std::size_t) [with _Tp = const char*,_Alloc = std::allocator<const char*>,std::size_t = long unsigned int]" -> "std::max(const _Tp&,const _Tp&) [with _Tp = long unsigned int]"
"_Alloc>::_M_initialize_map(std::size_t) [with _Tp = const char*,_Alloc = std::allocator<const char*>,std::size_t = long unsigned int]" -> "__cxa_end_catch()"
"_Alloc>::_M_initialize_map(std::size_t) [with _Tp = const char*,_Alloc = std::allocator<const char*>,std::size_t = long unsigned int]" -> "std::__deque_buf_size(std::size_t)"
"_Alloc>::_M_initialize_map(std::size_t) [with _Tp = const char*,_Alloc = std::allocator<const char*>,std::size_t = long unsigned int]" -> "_Alloc>::_M_deallocate_map(_Tp**,std::size_t) [with _Tp = const char*,_Alloc = std::allocator<const char*>,std::size_t = long unsigned int]"
"_Alloc>::_M_initialize_map(std::size_t) [with _Tp = const char*,_Alloc = std::allocator<const char*>,std::size_t = long unsigned int]" -> "__cxa_begin_catch(void*)"
"_Alloc>::_M_initialize_map(std::size_t) [with _Tp = const char*,_Alloc = std::allocator<const char*>,std::size_t = long unsigned int]" -> "_Alloc>::_M_create_nodes(_Tp**,_Tp**) [with _Tp = const char*,_Alloc = std::allocator<const char*>]"
"_Alloc>::_M_initialize_map(std::size_t) [with _Tp = const char*,_Alloc = std::allocator<const char*>,std::size_t = long unsigned int]" -> "__cxa_rethrow()"
"_Alloc>::_M_allocate_map(std::size_t) [with _Tp = const char*,_Alloc = std::allocator<const char*>,std::size_t = long unsigned int]" -> "_Alloc>::_M_get_map_allocator() const [with _Tp = const char*,_Alloc = std::allocator<const char*>,std::_Deque_base<_Tp,_Alloc>::_Map_alloc_type = std::allocator<const char**>]"
"_Alloc>::_M_allocate_map(std::size_t) [with _Tp = const char*,_Alloc = std::allocator<const char*>,std::size_t = long unsigned int]" -> "__gnu_cxx::new_allocator<_Tp>::allocate(__gnu_cxx::new_allocator<_Tp>::size_type,const void*) [with _Tp = const char**,__gnu_cxx::new_allocator<_Tp>::pointer = const char***,__gnu_cxx::new_allocator<_Tp>::size_type = long unsigned int]"
"_Alloc>::_M_get_map_allocator() const [with _Tp = const char*,_Alloc = std::allocator<const char*>,std::_Deque_base<_Tp,_Alloc>::_Map_alloc_type = std::allocator<const char**>]" -> "std::allocator<_Alloc>::allocator(const std::allocator<_Tp1>&) [with _Tp1 = const char*,_Tp = const char**]"
"_Alloc>::_M_get_map_allocator() const [with _Tp = const char*,_Alloc = std::allocator<const char*>,std::_Deque_base<_Tp,_Alloc>::_Map_alloc_type = std::allocator<const char**>]" -> "_Alloc>::_M_get_Tp_allocator() const [with _Tp = const char*,_Alloc = std::allocator<const char*>,std::_Deque_base<_Tp,_Alloc>::_Tp_alloc_type = std::allocator<const char*>]"
"std::allocator<_Alloc>::allocator(const std::allocator<_Tp1>&) [with _Tp1 = const char*,_Tp = const char**]" -> "__gnu_cxx::new_allocator<_Tp>::new_allocator() [with _Tp = const char**]"
"__gnu_cxx::new_allocator<_Tp>::allocate(__gnu_cxx::new_allocator<_Tp>::size_type,const void*) [with _Tp = const char**,__gnu_cxx::new_allocator<_Tp>::pointer = const char***,__gnu_cxx::new_allocator<_Tp>::size_type = long unsigned int]" -> "__gnu_cxx::new_allocator<_Tp>::max_size() const [with _Tp = const char**,__gnu_cxx::new_allocator<_Tp>::size_type = long unsigned int]"
"__gnu_cxx::new_allocator<_Tp>::allocate(__gnu_cxx::new_allocator<_Tp>::size_type,const void*) [with _Tp = const char**,__gnu_cxx::new_allocator<_Tp>::pointer = const char***,__gnu_cxx::new_allocator<_Tp>::size_type = long unsigned int]" -> "std::__throw_bad_alloc()"
"_Ptr>::_M_set_node(std::_Deque_iterator<_Tp,_Ref,_Ptr>::_Map_pointer) [with _Tp = const char*,_Ref = const char*&,_Ptr = const char**,std::_Deque_iterator<_Tp,_Ref,_Ptr>::_Map_pointer = const char***]" -> "_Ptr>::_S_buffer_size() [with _Tp = const char*,_Ref = const char*&,_Ptr = const char**,std::size_t = long unsigned int]"
"_Ptr>::_S_buffer_size() [with _Tp = const char*,_Ref = const char*&,_Ptr = const char**,std::size_t = long unsigned int]" -> "std::__deque_buf_size(std::size_t)"
"_Alloc>::_M_deallocate_map(_Tp**,std::size_t) [with _Tp = const char*,_Alloc = std::allocator<const char*>,std::size_t = long unsigned int]" -> "_Alloc>::_M_get_map_allocator() const [with _Tp = const char*,_Alloc = std::allocator<const char*>,std::_Deque_base<_Tp,_Alloc>::_Map_alloc_type = std::allocator<const char**>]"
"_Alloc>::_M_deallocate_map(_Tp**,std::size_t) [with _Tp = const char*,_Alloc = std::allocator<const char*>,std::size_t = long unsigned int]" -> "__gnu_cxx::new_allocator<_Tp>::deallocate(__gnu_cxx::new_allocator<_Tp>::pointer,__gnu_cxx::new_allocator<_Tp>::size_type) [with _Tp = const char**,__gnu_cxx::new_allocator<_Tp>::pointer = const char***,__gnu_cxx::new_allocator<_Tp>::size_type = long unsigned int]"
"_Alloc>::_M_create_nodes(_Tp**,_Tp**) [with _Tp = const char*,_Alloc = std::allocator<const char*>]" -> "__cxa_end_catch()"
"_Alloc>::_M_create_nodes(_Tp**,_Tp**) [with _Tp = const char*,_Alloc = std::allocator<const char*>]" -> "__cxa_rethrow()"
"_Alloc>::_M_create_nodes(_Tp**,_Tp**) [with _Tp = const char*,_Alloc = std::allocator<const char*>]" -> "_Alloc>::_M_destroy_nodes(_Tp**,_Tp**) [with _Tp = const char*,_Alloc = std::allocator<const char*>]"
"_Alloc>::_M_create_nodes(_Tp**,_Tp**) [with _Tp = const char*,_Alloc = std::allocator<const char*>]" -> "__builtin_eh_pointer(int)"
"_Alloc>::_M_create_nodes(_Tp**,_Tp**) [with _Tp = const char*,_Alloc = std::allocator<const char*>]" -> "_Alloc>::_M_allocate_node() [with _Tp = const char*,_Alloc = std::allocator<const char*>]"
"_Alloc>::_M_create_nodes(_Tp**,_Tp**) [with _Tp = const char*,_Alloc = std::allocator<const char*>]" -> "__cxa_begin_catch(void*)"
"_Alloc>::_M_destroy_nodes(_Tp**,_Tp**) [with _Tp = const char*,_Alloc = std::allocator<const char*>]" -> "_Alloc>::_M_deallocate_node(_Tp*) [with _Tp = const char*,_Alloc = std::allocator<const char*>]"
"_Alloc>::_M_deallocate_node(_Tp*) [with _Tp = const char*,_Alloc = std::allocator<const char*>]" -> "std::__deque_buf_size(std::size_t)"
"_Alloc>::_M_deallocate_node(_Tp*) [with _Tp = const char*,_Alloc = std::allocator<const char*>]" -> "__gnu_cxx::new_allocator<_Tp>::deallocate(__gnu_cxx::new_allocator<_Tp>::pointer,__gnu_cxx::new_allocator<_Tp>::size_type) [with _Tp = const char*,__gnu_cxx::new_allocator<_Tp>::pointer = const char**,__gnu_cxx::new_allocator<_Tp>::size_type = long unsigned int]"
"_Alloc>::_M_allocate_node() [with _Tp = const char*,_Alloc = std::allocator<const char*>]" -> "std::__deque_buf_size(std::size_t)"
"_Alloc>::_M_allocate_node() [with _Tp = const char*,_Alloc = std::allocator<const char*>]" -> "__gnu_cxx::new_allocator<_Tp>::allocate(__gnu_cxx::new_allocator<_Tp>::size_type,const void*) [with _Tp = const char*,__gnu_cxx::new_allocator<_Tp>::pointer = const char**,__gnu_cxx::new_allocator<_Tp>::size_type = long unsigned int]"
"__gnu_cxx::new_allocator<_Tp>::allocate(__gnu_cxx::new_allocator<_Tp>::size_type,const void*) [with _Tp = const char*,__gnu_cxx::new_allocator<_Tp>::pointer = const char**,__gnu_cxx::new_allocator<_Tp>::size_type = long unsigned int]" -> "std::__throw_bad_alloc()"
"__gnu_cxx::new_allocator<_Tp>::allocate(__gnu_cxx::new_allocator<_Tp>::size_type,const void*) [with _Tp = const char*,__gnu_cxx::new_allocator<_Tp>::pointer = const char**,__gnu_cxx::new_allocator<_Tp>::size_type = long unsigned int]" -> "__gnu_cxx::new_allocator<_Tp>::max_size() const [with _Tp = const char*,__gnu_cxx::new_allocator<_Tp>::size_type = long unsigned int]"
"_Alloc>::_Deque_impl::_Deque_impl() [with _Tp = const char*,_Alloc = std::allocator<const char*>]" -> "_Ptr>::_Deque_iterator() [with _Tp = const char*,_Ref = const char*&,_Ptr = const char**]"
"_Alloc>::_Deque_impl::_Deque_impl() [with _Tp = const char*,_Alloc = std::allocator<const char*>]" -> "std::allocator<_Alloc>::allocator() [with _Tp = const char*]"
"std::allocator<_Alloc>::allocator() [with _Tp = const char*]" -> "__gnu_cxx::new_allocator<_Tp>::new_allocator() [with _Tp = const char*]"
"_Alloc>::vector() [with _Tp = long int,_Alloc = std::allocator<long int>]" -> "_Alloc>::_Vector_base() [with _Tp = long int,_Alloc = std::allocator<long int>]"
"_Alloc>::_Vector_base() [with _Tp = long int,_Alloc = std::allocator<long int>]" -> "_Alloc>::_Vector_impl::_Vector_impl() [with _Tp = long int,_Alloc = std::allocator<long int>]"
"_Alloc>::_Vector_impl::_Vector_impl() [with _Tp = long int,_Alloc = std::allocator<long int>]" -> "std::allocator<_Alloc>::allocator() [with _Tp = long int]"
"std::allocator<_Alloc>::allocator() [with _Tp = long int]" -> "__gnu_cxx::new_allocator<_Tp>::new_allocator() [with _Tp = long int]"
"dec_thread_running()" -> "my_atomic_add32(volatile int32*,int32)"
"trans_rollback_implicit(THD*)" -> "THD_TRANS::reset_unsafe_rollback_flags()"
"trans_rollback_implicit(THD*)" -> "ha_rollback_trans(THD*,bool)"
"find_schema_table(THD*,const char*)" -> "plugin_foreach_with_mask(THD*,my_bool (*)(THD*,plugin_ref,void*),int,uint,void*)"
"THD::cleanup_after_query()" -> "Query_arena::free_items()"
"THD::cleanup_after_query()" -> "delete_dynamic(DYNAMIC_ARRAY*)"
"THD::cleanup_after_query()" -> "THD::reset_binlog_local_stmt_filter()"
"THD::cleanup_after_query()" -> "Discrete_intervals_list::empty()"
"THD::cleanup_after_query()" -> "gtid_post_statement_checks(THD*)"
"Query_arena::free_items()" -> "Item::delete_self()"
"gtid_post_statement_checks(THD*)" -> "stmt_causes_implicit_commit(const THD*,uint)"
"gtid_post_statement_checks(THD*)" -> "Gtid_specification::set_undefined()"
"gtid_post_statement_checks(THD*)" -> "THD::get_command() const"
"THD::update_server_status()" -> "THD::current_utime()"
"THD::current_utime()" -> "my_micro_time()"
"TraceTool::start_new_query()" -> "pthread_mutex_unlock(pthread_mutex_t*)"
"TraceTool::start_new_query()" -> "clock_gettime(clockid_t,timespec*)"
"TraceTool::start_new_query()" -> "pthread_mutex_lock(pthread_mutex_t*)"
"TABLE_LIST::TABLE_LIST()" -> "MDL_request::MDL_request()"
"TABLE_LIST::TABLE_LIST()" -> "List<T>::List() [with T = Derived_key]"
"TABLE_LIST::TABLE_LIST()" -> "Table_id::Table_id()"
"MDL_request::MDL_request()" -> "MDL_key::MDL_key()"
"List<T>::List() [with T = Derived_key]" -> "base_list::base_list()"
"mysql_print_status()" -> "Table_cache_manager::cached_tables()"
"mysql_print_status()" -> "get_thread_count()"
"mysql_print_status()" -> "calc_sum_of_all_status(STATUS_VAR*)"
"mysql_print_status()" -> "malloc_info(int,FILE*)"
"mysql_print_status()" -> "display_table_locks()"
"mysql_print_status()" -> "thr_print_locks()"
"mysql_print_status()" -> "__builtin_puts(const char*)"
"mysql_print_status()" -> "my_getwd(char*,size_t,myf)"
"mysql_print_status()" -> "puts(const char*)"
"mysql_print_status()" -> "process_key_caches(process_key_cache_t)"
"mysql_print_status()" -> "printf(const char*,...)"
"mysql_print_status()" -> "fflush(FILE*)"
"mysql_print_status()" -> "thr_alarm_info(ALARM_INFO*)"
"mysql_print_status()" -> "inline_mysql_mutex_lock(mysql_mutex_t*)"
"mysql_print_status()" -> "inline_mysql_mutex_unlock(mysql_mutex_t*)"
"Table_cache_manager::cached_tables()" -> "Table_cache::cached_tables() const"
"display_table_locks()" -> "freeze_size(DYNAMIC_ARRAY*)"
"display_table_locks()" -> "inline_mysql_mutex_lock(mysql_mutex_t*)"
"display_table_locks()" -> "printf(const char*,...)"
"display_table_locks()" -> "Table_cache_manager::cached_tables()"
"display_table_locks()" -> "inline_mysql_mutex_unlock(mysql_mutex_t*)"
"display_table_locks()" -> "push_locks_into_array(DYNAMIC_ARRAY*,THR_LOCK_DATA*,bool,const char*)"
"display_table_locks()" -> "delete_dynamic(DYNAMIC_ARRAY*)"
"display_table_locks()" -> "puts(const char*)"
"display_table_locks()" -> "init_dynamic_array2(DYNAMIC_ARRAY*,uint,void*,uint,uint)"
"display_table_locks()" -> "my_qsort(void*,size_t,size_t,qsort_cmp)"
"push_locks_into_array(DYNAMIC_ARRAY*,THR_LOCK_DATA*,bool,const char*)" -> "memcpy(void*,const void*,size_t)"
"push_locks_into_array(DYNAMIC_ARRAY*,THR_LOCK_DATA*,bool,const char*)" -> "insert_dynamic(DYNAMIC_ARRAY*,const void*)"
"push_locks_into_array(DYNAMIC_ARRAY*,THR_LOCK_DATA*,bool,const char*)" -> "strlen(const char*)"
"process_key_caches(process_key_cache_t)" -> "I_List_iterator<T>::I_List_iterator(I_List<T>&) [with T = NAMED_ILINK]"
"process_key_caches(process_key_cache_t)" -> "I_List_iterator<T>::operator++(int) [with T = NAMED_ILINK]"
"I_List_iterator<T>::I_List_iterator(I_List<T>&) [with T = NAMED_ILINK]" -> "base_ilist_iterator<T>::base_ilist_iterator(base_ilist<T>&) [with T = NAMED_ILINK]"
"I_List_iterator<T>::operator++(int) [with T = NAMED_ILINK]" -> "base_ilist_iterator<T>::next() [with T = NAMED_ILINK]"
"mysql_audit_general(THD*,uint,int,const char*)" -> "CSET_STRING::CSET_STRING(char*,size_t,const CHARSET_INFO*)"
"mysql_audit_general(THD*,uint,int,const char*)" -> "strlen(const char*)"
"mysql_audit_general(THD*,uint,int,const char*)" -> "CSET_STRING::length() const"
"mysql_audit_general(THD*,uint,int,const char*)" -> "String::charset() const"
"mysql_audit_general(THD*,uint,int,const char*)" -> "String::length() const"
"mysql_audit_general(THD*,uint,int,const char*)" -> "CSET_STRING::charset() const"
"mysql_audit_general(THD*,uint,int,const char*)" -> "Security_context::get_external_user()"
"mysql_audit_general(THD*,uint,int,const char*)" -> "mysql_audit_notify(THD*,uint,uint,...)"
"mysql_audit_general(THD*,uint,int,const char*)" -> "my_time(myf)"
"mysql_audit_general(THD*,uint,int,const char*)" -> "make_user_name(THD*,char*)"
"mysql_audit_general(THD*,uint,int,const char*)" -> "Security_context::get_ip()"
"mysql_audit_general(THD*,uint,int,const char*)" -> "mysql_rewrite_query(THD*)"
"mysql_audit_general(THD*,uint,int,const char*)" -> "CSET_STRING::CSET_STRING()"
"mysql_audit_general(THD*,uint,int,const char*)" -> "String::ptr() const"
"mysql_audit_general(THD*,uint,int,const char*)" -> "Security_context::get_host()"
"mysql_audit_general(THD*,uint,int,const char*)" -> "Diagnostics_area::current_row_for_warning() const"
"mysql_audit_general(THD*,uint,int,const char*)" -> "CSET_STRING::str() const"
"mysql_audit_general(THD*,uint,int,const char*)" -> "THD::get_stmt_da()"
"mysql_rewrite_query(THD*)" -> "mysql_rewrite_start_slave(THD*,String*)"
"mysql_rewrite_query(THD*)" -> "mysql_rewrite_set(THD*,String*)"
"mysql_rewrite_query(THD*)" -> "mysql_rewrite_change_master(THD*,String*)"
"mysql_rewrite_query(THD*)" -> "String::free()"
"mysql_rewrite_query(THD*)" -> "mysql_rewrite_prepare(THD*,String*)"
"mysql_rewrite_query(THD*)" -> "mysql_rewrite_create_server(THD*,String*)"
"mysql_rewrite_query(THD*)" -> "mysql_rewrite_create_user(THD*,String*)"
"mysql_rewrite_query(THD*)" -> "mysql_rewrite_alter_server(THD*,String*)"
"mysql_rewrite_query(THD*)" -> "mysql_rewrite_grant(THD*,String*)"
"mysql_rewrite_start_slave(THD*,String*)" -> "String::append_ulonglong(ulonglong)"
"mysql_rewrite_start_slave(THD*,String*)" -> "String::append(const char*,uint32)"
"mysql_rewrite_start_slave(THD*,String*)" -> "String::append(const char*)"
"String::append_ulonglong(ulonglong)" -> "int10_to_str(long int,char*,int)"
"String::append_ulonglong(ulonglong)" -> "String::realloc(uint32)"
"mysql_rewrite_set(THD*,String*)" -> "List_iterator_fast<T>::operator++(int) [with T = set_var_base]"
"mysql_rewrite_set(THD*,String*)" -> "String::append(const char*,uint32)"
"mysql_rewrite_set(THD*,String*)" -> "List_iterator_fast<T>::List_iterator_fast(List<T>&) [with T = set_var_base]"
"List_iterator_fast<T>::operator++(int) [with T = set_var_base]" -> "base_list_iterator::next_fast()"
"List_iterator_fast<T>::List_iterator_fast(List<T>&) [with T = set_var_base]" -> "base_list_iterator::base_list_iterator(base_list&)"
"mysql_rewrite_change_master(THD*,String*)" -> "String::append(const char*,uint32)"
"mysql_rewrite_change_master(THD*,String*)" -> "String::append(const char*)"
"mysql_rewrite_change_master(THD*,String*)" -> "String::append_ulonglong(ulonglong)"
"mysql_rewrite_change_master(THD*,String*)" -> "get_dynamic(DYNAMIC_ARRAY*,void*,uint)"
"mysql_rewrite_change_master(THD*,String*)" -> "snprintf(char*,size_t,const char*,...)"
"mysql_rewrite_prepare(THD*,String*)" -> "String::append(const char*,uint32)"
"mysql_rewrite_create_server(THD*,String*)" -> "String::append(const char*,uint32)"
"mysql_rewrite_create_server(THD*,String*)" -> "mysql_rewrite_server_options(THD*,String*)"
"mysql_rewrite_create_server(THD*,String*)" -> "String::append(const char*)"
"mysql_rewrite_server_options(THD*,String*)" -> "append_int(String*,bool,const char*,size_t,long int,int)"
"mysql_rewrite_server_options(THD*,String*)" -> "String::append(const char*,uint32)"
"mysql_rewrite_server_options(THD*,String*)" -> "append_str(String*,bool,const char*,char*)"
"append_int(String*,bool,const char*,size_t,long int,int)" -> "String::set(longlong,const CHARSET_INFO*)"
"append_int(String*,bool,const char*,size_t,long int,int)" -> "String::append(const String&)"
"append_int(String*,bool,const char*,size_t,long int,int)" -> "String::String(uint32)"
"append_int(String*,bool,const char*,size_t,long int,int)" -> "String::append(const char*,uint32)"
"String::set(longlong,const CHARSET_INFO*)" -> "String::alloc(uint32)"
"String::set(longlong,const CHARSET_INFO*)" -> "String::set_int(longlong,bool,const CHARSET_INFO*)"
"String::set_int(longlong,bool,const CHARSET_INFO*)" -> "String::alloc(uint32)"
"String::append(const String&)" -> "String::length() const"
"String::append(const String&)" -> "String::realloc(uint32)"
"String::append(const String&)" -> "memcpy(void*,const void*,size_t)"
"String::append(const String&)" -> "String::ptr() const"
"String::String(uint32)" -> "String::real_alloc(uint32)"
"append_str(String*,bool,const char*,char*)" -> "String::append(const char*)"
"append_str(String*,bool,const char*,char*)" -> "String::append(const char*,uint32)"
"mysql_rewrite_create_user(THD*,String*)" -> "append_user(THD*,String*,LEX_USER*,bool,bool)"
"mysql_rewrite_create_user(THD*,String*)" -> "List_iterator<T>::operator++(int) [with T = st_lex_user]"
"mysql_rewrite_create_user(THD*,String*)" -> "List_iterator<T>::List_iterator(List<T>&) [with T = st_lex_user]"
"mysql_rewrite_create_user(THD*,String*)" -> "String::append(const char*,uint32)"
"mysql_rewrite_create_user(THD*,String*)" -> "get_current_user(THD*,LEX_USER*)"
"append_user(THD*,String*,LEX_USER*,bool,bool)" -> "String::append(const char*,uint32)"
"append_user(THD*,String*,LEX_USER*,bool,bool)" -> "append_query_string(THD*,const CHARSET_INFO*,const String*,String*)"
"append_user(THD*,String*,LEX_USER*,bool,bool)" -> "String::append(char)"
"append_user(THD*,String*,LEX_USER*,bool,bool)" -> "String::String(char*,uint32,const CHARSET_INFO*)"
"append_user(THD*,String*,LEX_USER*,bool,bool)" -> "my_make_scrambled_password_sha1(char*,const char*,size_t)"
"append_user(THD*,String*,LEX_USER*,bool,bool)" -> "String::append(const char*)"
"append_user(THD*,String*,LEX_USER*,bool,bool)" -> "memcmp(const void*,const void*,size_t)"
"append_query_string(THD*,const CHARSET_INFO*,const String*,String*)" -> "String::length() const"
"append_query_string(THD*,const CHARSET_INFO*,const String*,String*)" -> "String::length(uint32)"
"append_query_string(THD*,const CHARSET_INFO*,const String*,String*)" -> "String::c_ptr_quick()"
"append_query_string(THD*,const CHARSET_INFO*,const String*,String*)" -> "String::reserve(uint32)"
"append_query_string(THD*,const CHARSET_INFO*,const String*,String*)" -> "str_to_hex(char*,const char*,uint)"
"append_query_string(THD*,const CHARSET_INFO*,const String*,String*)" -> "escape_string_for_mysql(const CHARSET_INFO*,char*,size_t,const char*,size_t)"
"append_query_string(THD*,const CHARSET_INFO*,const String*,String*)" -> "String::ptr() const"
"str_to_hex(char*,const char*,uint)" -> "__builtin_memcpy(void*,const void*,long unsigned int)"
"str_to_hex(char*,const char*,uint)" -> "octet2hex(char*,const char*,unsigned int)"
"List_iterator<T>::operator++(int) [with T = st_lex_user]" -> "base_list_iterator::next()"
"List_iterator<T>::List_iterator(List<T>&) [with T = st_lex_user]" -> "base_list_iterator::base_list_iterator(base_list&)"
"get_current_user(THD*,LEX_USER*)" -> "create_default_definer(THD*)"
"create_default_definer(THD*)" -> "THD::get_definer(LEX_USER*)"
"create_default_definer(THD*)" -> "Query_arena::alloc(size_t)"
"THD::get_definer(LEX_USER*)" -> "get_default_definer(THD*,LEX_USER*)"
"THD::get_definer(LEX_USER*)" -> "THD::binlog_invoker()"
"get_default_definer(THD*,LEX_USER*)" -> "strlen(const char*)"
"Query_arena::alloc(size_t)" -> "alloc_root(MEM_ROOT*,size_t)"
"mysql_rewrite_alter_server(THD*,String*)" -> "mysql_rewrite_server_options(THD*,String*)"
"mysql_rewrite_alter_server(THD*,String*)" -> "String::append(const char*,uint32)"
"mysql_rewrite_alter_server(THD*,String*)" -> "String::append(const char*)"
"mysql_rewrite_grant(THD*,String*)" -> "append_user(THD*,String*,LEX_USER*,bool,bool)"
"mysql_rewrite_grant(THD*,String*)" -> "strlen(const char*)"
"mysql_rewrite_grant(THD*,String*)" -> "String::String(uint32)"
"mysql_rewrite_grant(THD*,String*)" -> "List_iterator<T>::List_iterator(List<T>&) [with T = st_lex_user]"
"mysql_rewrite_grant(THD*,String*)" -> "String::ptr() const"
"mysql_rewrite_grant(THD*,String*)" -> "String::append(const char*,uint32)"
"mysql_rewrite_grant(THD*,String*)" -> "get_current_user(THD*,LEX_USER*)"
"mysql_rewrite_grant(THD*,String*)" -> "String::length(uint32)"
"mysql_rewrite_grant(THD*,String*)" -> "append_int(String*,bool,const char*,size_t,long int,int)"
"mysql_rewrite_grant(THD*,String*)" -> "append_identifier(THD*,String*,const char*,uint)"
"mysql_rewrite_grant(THD*,String*)" -> "String::append(const char*)"
"mysql_rewrite_grant(THD*,String*)" -> "List_iterator<T>::operator++(int) [with T = st_lex_user]"
"mysql_rewrite_grant(THD*,String*)" -> "String::append(const String&)"
"mysql_rewrite_grant(THD*,String*)" -> "List_iterator<T>::operator++(int) [with T = LEX_COLUMN]"
"mysql_rewrite_grant(THD*,String*)" -> "List_iterator<T>::List_iterator(List<T>&) [with T = LEX_COLUMN]"
"mysql_rewrite_grant(THD*,String*)" -> "String::length() const"
"List_iterator<T>::operator++(int) [with T = LEX_COLUMN]" -> "base_list_iterator::next()"
"List_iterator<T>::List_iterator(List<T>&) [with T = LEX_COLUMN]" -> "base_list_iterator::base_list_iterator(base_list&)"
"Diagnostics_area::current_row_for_warning() const" -> "Warning_info::current_row_for_warning() const"
"Diagnostics_area::current_row_for_warning() const" -> "Diagnostics_area::get_warning_info() const"
"mysqld_stmt_reset(THD*,char*,uint)" -> "llstr(longlong,char*)"
"mysqld_stmt_reset(THD*,char*,uint)" -> "my_ok(THD*,ulonglong,ulonglong,const char*)"
"mysqld_stmt_reset(THD*,char*,uint)" -> "mysql_reset_thd_for_next_command(THD*)"
"mysqld_stmt_reset(THD*,char*,uint)" -> "reset_stmt_params(Prepared_statement*)"
"mysqld_stmt_reset(THD*,char*,uint)" -> "my_error(int,myf,...)"
"mysqld_stmt_reset(THD*,char*,uint)" -> "THD::get_command() const"
"mysqld_stmt_reset(THD*,char*,uint)" -> "find_prepared_statement(THD*,ulong)"
"mysqld_stmt_reset(THD*,char*,uint)" -> "general_log_print(THD*,enum_server_command,const char*,...)"
"mysqld_stmt_reset(THD*,char*,uint)" -> "Prepared_statement::close_cursor()"
"mysql_reset_thd_for_next_command(THD*)" -> "THD::reset_for_next_command()"
"THD::reset_for_next_command()" -> "THD::get_stmt_da()"
"THD::reset_for_next_command()" -> "THD::clear_error()"
"THD::reset_for_next_command()" -> "THD::reset_current_stmt_binlog_format_row()"
"THD::reset_for_next_command()" -> "Discrete_intervals_list::empty()"
"THD::reset_for_next_command()" -> "Diagnostics_area::reset_for_next_command()"
"THD::reset_for_next_command()" -> "THD_TRANS::reset_unsafe_rollback_flags()"
"THD::reset_for_next_command()" -> "Diagnostics_area::reset_diagnostics_area()"
"THD::reset_for_next_command()" -> "THD::set_trans_pos(const char*,my_off_t)"
"THD::reset_for_next_command()" -> "THD::in_multi_stmt_transaction_mode() const"
"Diagnostics_area::reset_for_next_command()" -> "Diagnostics_area::get_warning_info()"
"Diagnostics_area::reset_for_next_command()" -> "Warning_info::reset_for_next_command()"
"reset_stmt_params(Prepared_statement*)" -> "Item_param::reset()"
"Item_param::reset()" -> "String::length(uint32)"
"Item_param::reset()" -> "String::free()"
"Item_param::reset()" -> "String::alloced_length() const"
"Item_param::reset()" -> "DTCollation::set(const CHARSET_INFO*,Derivation)"
"Item_param::reset()" -> "String::set_charset(const CHARSET_INFO*)"
"DTCollation::set(const CHARSET_INFO*,Derivation)" -> "DTCollation::set_repertoire_from_charset(const CHARSET_INFO*)"
"PROFILING::set_query_source(char*,uint)" -> "QUERY_PROFILE::set_query_source(char*,uint)"
"QUERY_PROFILE::set_query_source(char*,uint)" -> "std::min(const _Tp&,const _Tp&) [with _Tp = unsigned int]"
"QUERY_PROFILE::set_query_source(char*,uint)" -> "my_strndup(const char*,size_t,myf)"
"THD::reset_query()" -> "CSET_STRING::CSET_STRING()"
"THD::reset_query()" -> "THD::set_query(const CSET_STRING&)"
"MDL_context::mdl_savepoint()" -> "I>::front() [with T = MDL_ticket,B = I_P_List_adapter<MDL_ticket,&MDL_ticket::next_in_context,&MDL_ticket::prev_in_context>,C = I_P_List_null_counter,I = I_P_List_no_push_back<MDL_ticket>]"
"MDL_context::mdl_savepoint()" -> "MDL_savepoint::MDL_savepoint(MDL_ticket*,MDL_ticket*)"
"Parser_state::Parser_state()" -> "Yacc_state::Yacc_state()"
"Parser_state::Parser_state()" -> "Lex_input_stream::Lex_input_stream()"
"Yacc_state::Yacc_state()" -> "Set_signal_information::Set_signal_information()"
"Yacc_state::Yacc_state()" -> "Yacc_state::reset()"
"Yacc_state::reset()" -> "Set_signal_information::clear()"
"Set_signal_information::clear()" -> "memset(void*,int,size_t)"
"next_query_id()" -> "my_atomic_add64(volatile int64*,int64)"
"my_atomic_add64(volatile int64*,int64)" -> "__sync_fetch_and_add_8(volatile void*,long unsigned int)"
"reload_acl_and_cache(THD*,long unsigned int,TABLE_LIST*,int*)" -> "LOGGER::flush_slow_log()"
"reload_acl_and_cache(THD*,long unsigned int,TABLE_LIST*,int*)" -> "THD::THD(bool)"
"reload_acl_and_cache(THD*,long unsigned int,TABLE_LIST*,int*)" -> "MYSQL_LOG::is_open()"
"reload_acl_and_cache(THD*,long unsigned int,TABLE_LIST*,int*)" -> "MYSQL_BIN_LOG::rotate_and_purge(bool)"
"reload_acl_and_cache(THD*,long unsigned int,TABLE_LIST*,int*)" -> "MDL_context::is_lock_owner(MDL_key::enum_mdl_namespace,const char*,const char*,enum_mdl_type)"
"reload_acl_and_cache(THD*,long unsigned int,TABLE_LIST*,int*)" -> "LOGGER::flush_general_log()"
"reload_acl_and_cache(THD*,long unsigned int,TABLE_LIST*,int*)" -> "Global_read_lock::make_global_read_lock_block_commit(THD*)"
"reload_acl_and_cache(THD*,long unsigned int,TABLE_LIST*,int*)" -> "my_dbopt_cleanup()"
"reload_acl_and_cache(THD*,long unsigned int,TABLE_LIST*,int*)" -> "flush_error_log()"
"reload_acl_and_cache(THD*,long unsigned int,TABLE_LIST*,int*)" -> "Query_cache::pack(ulong,uint)"
"reload_acl_and_cache(THD*,long unsigned int,TABLE_LIST*,int*)" -> "ha_flush_logs(handlerton*)"
"reload_acl_and_cache(THD*,long unsigned int,TABLE_LIST*,int*)" -> "Query_cache::flush()"
"reload_acl_and_cache(THD*,long unsigned int,TABLE_LIST*,int*)" -> "hostname_cache_refresh()"
"reload_acl_and_cache(THD*,long unsigned int,TABLE_LIST*,int*)" -> "THD::store_globals()"
"reload_acl_and_cache(THD*,long unsigned int,TABLE_LIST*,int*)" -> "close_cached_tables(THD*,TABLE_LIST*,bool,ulong)"
"reload_acl_and_cache(THD*,long unsigned int,TABLE_LIST*,int*)" -> "find_table_for_mdl_upgrade(THD*,const char*,const char*,bool)"
"reload_acl_and_cache(THD*,long unsigned int,TABLE_LIST*,int*)" -> "MDL_ticket::is_upgradable_or_exclusive() const"
"reload_acl_and_cache(THD*,long unsigned int,TABLE_LIST*,int*)" -> "Global_read_lock::lock_global_read_lock(THD*)"
"reload_acl_and_cache(THD*,long unsigned int,TABLE_LIST*,int*)" -> "pthread_setspecific(pthread_key_t,const void*)"
"reload_acl_and_cache(THD*,long unsigned int,TABLE_LIST*,int*)" -> "refresh_status(THD*)"
"reload_acl_and_cache(THD*,long unsigned int,TABLE_LIST*,int*)" -> "reset_mqh(LEX_USER*,bool)"
"reload_acl_and_cache(THD*,long unsigned int,TABLE_LIST*,int*)" -> "my_error(int,myf,...)"
"reload_acl_and_cache(THD*,long unsigned int,TABLE_LIST*,int*)" -> "kill_blocked_pthreads()"
"reload_acl_and_cache(THD*,long unsigned int,TABLE_LIST*,int*)" -> "Global_read_lock::unlock_global_read_lock(THD*)"
"LOGGER::flush_slow_log()" -> "LOGGER::lock_exclusive()"
"LOGGER::flush_slow_log()" -> "MYSQL_QUERY_LOG::reopen_file()"
"LOGGER::flush_slow_log()" -> "Log_to_file_event_handler::get_mysql_slow_log()"
"LOGGER::flush_slow_log()" -> "LOGGER::unlock()"
"LOGGER::lock_exclusive()" -> "inline_mysql_rwlock_wrlock(mysql_rwlock_t*)"
"MYSQL_QUERY_LOG::reopen_file()" -> "my_free(void*)"
"MYSQL_QUERY_LOG::reopen_file()" -> "MYSQL_LOG::is_open()"
"MYSQL_QUERY_LOG::reopen_file()" -> "inline_mysql_mutex_lock(mysql_mutex_t*)"
"MYSQL_QUERY_LOG::reopen_file()" -> "MYSQL_LOG::close(uint)"
"MYSQL_QUERY_LOG::reopen_file()" -> "MYSQL_LOG::open(PSI_file_key,const char*,enum_log_type,const char*,cache_type)"
"MYSQL_QUERY_LOG::reopen_file()" -> "inline_mysql_mutex_unlock(mysql_mutex_t*)"
"THD::THD(bool)" -> "thd_scheduler::thd_scheduler()"
"THD::THD(bool)" -> "randominit(rand_struct*,long unsigned int,long unsigned int)"
"THD::THD(bool)" -> "_my_hash_init(HASH*,uint,CHARSET_INFO*,my_hash_function,ulong,size_t,size_t,my_hash_get_key,void (*)(void*),uint)"
"THD::THD(bool)" -> "Protocol_binary::Protocol_binary()"
"THD::THD(bool)" -> "init_sql_alloc(MEM_ROOT*,uint,uint)"
"THD::THD(bool)" -> "MDL_context::init(MDL_context_owner*)"
"THD::THD(bool)" -> "memset(void*,int,size_t)"
"THD::THD(bool)" -> "inline_mysql_mutex_init(mysql_mutex_t*,const pthread_mutexattr_t*)"
"THD::THD(bool)" -> "Open_tables_state::reset_open_tables_state()"
"THD::THD(bool)" -> "sql_rnd_with_mutex()"
"THD::THD(bool)" -> "I_List<Item_change_record>::I_List()"
"THD::THD(bool)" -> "Locked_tables_list::Locked_tables_list()"
"THD::THD(bool)" -> "Protocol::init(THD*)"
"THD::THD(bool)" -> "Opt_trace_context::Opt_trace_context()"
"THD::THD(bool)" -> "Open_tables_state::Open_tables_state()"
"THD::THD(bool)" -> "Security_context::init()"
"THD::THD(bool)" -> "LEX::LEX()"
"THD::THD(bool)" -> "PROFILING::PROFILING()"
"THD::THD(bool)" -> "String::String()"
"THD::THD(bool)" -> "thr_lock_info_init(THR_LOCK_INFO*)"
"THD::THD(bool)" -> "Statement::Statement(LEX*,MEM_ROOT*,Query_arena::enum_state,ulong)"
"THD::THD(bool)" -> "Ha_data::Ha_data()"
"THD::THD(bool)" -> "MDL_context_owner::MDL_context_owner()"
"THD::THD(bool)" -> "THD::set_command(enum_server_command)"
"THD::THD(bool)" -> "Protocol_text::Protocol_text()"
"THD::THD(bool)" -> "init_dynamic_array2(DYNAMIC_ARRAY*,uint,void*,uint,uint)"
"THD::THD(bool)" -> "Security_context::Security_context()"
"THD::THD(bool)" -> "Global_read_lock::Global_read_lock()"
"THD::THD(bool)" -> "THD::st_transactions::st_transactions()"
"THD::THD(bool)" -> "Diagnostics_area::Diagnostics_area(ulonglong,bool)"
"THD::THD(bool)" -> "MDL_context::MDL_context()"
"THD::THD(bool)" -> "Discrete_intervals_list::Discrete_intervals_list()"
"THD::THD(bool)" -> "Statement_map::Statement_map()"
"THD::THD(bool)" -> "Query_cache_tls::Query_cache_tls()"
"THD::THD(bool)" -> "PROFILING::set_thd(THD*)"
"THD::THD(bool)" -> "Gtid_set::Gtid_set(Sid_map*,Checkable_rwlock*)"
"THD::THD(bool)" -> "THD::init()"
"Protocol_binary::Protocol_binary()" -> "Protocol::Protocol()"
"inline_mysql_mutex_init(mysql_mutex_t*,const pthread_mutexattr_t*)" -> "pthread_mutex_init(pthread_mutex_t*,const pthread_mutexattr_t*)"
"Open_tables_state::reset_open_tables_state()" -> "Open_tables_state::reset_reprepare_observers()"
"Open_tables_state::reset_reprepare_observers()" -> "Dynamic_array<Elem>::clear() [with Elem = Reprepare_observer*]"
"Dynamic_array<Elem>::clear() [with Elem = Reprepare_observer*]" -> "Dynamic_array<Elem>::elements(uint) [with Elem = Reprepare_observer*,uint = unsigned int]"
"sql_rnd_with_mutex()" -> "inline_mysql_mutex_lock(mysql_mutex_t*)"
"sql_rnd_with_mutex()" -> "inline_mysql_mutex_unlock(mysql_mutex_t*)"
"sql_rnd_with_mutex()" -> "inline_mysql_mutex_lock(mysql_mutex_t*,const char*,uint)"
"sql_rnd_with_mutex()" -> "my_rnd(rand_struct*)"
"I_List<Item_change_record>::I_List()" -> "base_ilist<T>::base_ilist() [with T = Item_change_record]"
"base_ilist<T>::base_ilist() [with T = Item_change_record]" -> "base_ilist<T>::empty() [with T = Item_change_record]"
"base_ilist<T>::base_ilist() [with T = Item_change_record]" -> "ilink<T>::ilink() [with T = Item_change_record]"
"Locked_tables_list::Locked_tables_list()" -> "init_sql_alloc(MEM_ROOT*,uint,uint)"
"Open_tables_state::Open_tables_state()" -> "Dynamic_array<Elem>::Dynamic_array(uint,uint) [with Elem = Reprepare_observer*,uint = unsigned int]"
"Dynamic_array<Elem>::Dynamic_array(uint,uint) [with Elem = Reprepare_observer*,uint = unsigned int]" -> "Dynamic_array<Elem>::init(uint,uint) [with Elem = Reprepare_observer*,uint = unsigned int]"
"Dynamic_array<Elem>::init(uint,uint) [with Elem = Reprepare_observer*,uint = unsigned int]" -> "init_dynamic_array2(DYNAMIC_ARRAY*,uint,void*,uint,uint)"
"Security_context::init()" -> "String::set(const char*,uint32,const CHARSET_INFO*)"
"LEX::LEX()" -> "List<T>::List() [with T = set_var_base]"
"LEX::LEX()" -> "List<T>::List() [with T = String]"
"LEX::LEX()" -> "List<T>::List() [with T = LEX_COLUMN]"
"LEX::LEX()" -> "SQL_I_List<T>::SQL_I_List() [with T = TABLE_LIST]"
"LEX::LEX()" -> "st_select_lex_unit::st_select_lex_unit()"
"LEX::LEX()" -> "List<T>::List() [with T = st_mysql_lex_string]"
"LEX::LEX()" -> "Query_tables_list::Query_tables_list()"
"LEX::LEX()" -> "List<T>::List() [with T = Key_part_spec]"
"LEX::LEX()" -> "init_dynamic_array2(DYNAMIC_ARRAY*,uint,void*,uint,uint)"
"LEX::LEX()" -> "Query_tables_list::reset_query_tables_list(bool)"
"LEX::LEX()" -> "List<T>::List() [with T = Item]"
"LEX::LEX()" -> "st_ha_check_opt::st_ha_check_opt()"
"LEX::LEX()" -> "List<T>::List() [with T = List<Item>]"
"LEX::LEX()" -> "List<T>::List() [with T = st_lex_user]"
"LEX::LEX()" -> "List<T>::List() [with T = Item_param]"
"LEX::LEX()" -> "st_parsing_options::st_parsing_options()"
"LEX::LEX()" -> "Alter_info::Alter_info()"
"LEX::LEX()" -> "memset(void*,int,size_t)"
"LEX::LEX()" -> "List<T>::List() [with T = Name_resolution_context]"
"LEX::LEX()" -> "List<T>::List() [with T = Item_func_set_user_var]"
"LEX::LEX()" -> "st_ha_create_information::st_ha_create_information()"
"LEX::LEX()" -> "st_select_lex::st_select_lex()"
"List<T>::List() [with T = set_var_base]" -> "base_list::base_list()"
"List<T>::List() [with T = String]" -> "base_list::base_list()"
"List<T>::List() [with T = LEX_COLUMN]" -> "base_list::base_list()"
"SQL_I_List<T>::SQL_I_List() [with T = TABLE_LIST]" -> "Sql_alloc::Sql_alloc()"
"SQL_I_List<T>::SQL_I_List() [with T = TABLE_LIST]" -> "SQL_I_List<T>::empty() [with T = TABLE_LIST]"
"st_select_lex_unit::st_select_lex_unit()" -> "st_select_lex_node::st_select_lex_node()"
"st_select_lex_unit::st_select_lex_unit()" -> "List<T>::List() [with T = Item]"
"st_select_lex_unit::st_select_lex_unit()" -> "TABLE_LIST::TABLE_LIST()"
"List<T>::List() [with T = Item]" -> "base_list::base_list()"
"List<T>::List() [with T = st_mysql_lex_string]" -> "base_list::base_list()"
"Query_tables_list::Query_tables_list()" -> "SQL_I_List<T>::SQL_I_List() [with T = Sroutine_hash_entry]"
"SQL_I_List<T>::SQL_I_List() [with T = Sroutine_hash_entry]" -> "SQL_I_List<T>::empty() [with T = Sroutine_hash_entry]"
"SQL_I_List<T>::SQL_I_List() [with T = Sroutine_hash_entry]" -> "Sql_alloc::Sql_alloc()"
"List<T>::List() [with T = Key_part_spec]" -> "base_list::base_list()"
"List<T>::List() [with T = List<Item>]" -> "base_list::base_list()"
"List<T>::List() [with T = st_lex_user]" -> "base_list::base_list()"
"List<T>::List() [with T = Item_param]" -> "base_list::base_list()"
"st_parsing_options::st_parsing_options()" -> "st_parsing_options::reset()"
"Alter_info::Alter_info()" -> "List<T>::List() [with T = Key]"
"Alter_info::Alter_info()" -> "List<T>::List() [with T = Alter_column]"
"Alter_info::Alter_info()" -> "List<T>::List() [with T = Create_field]"
"Alter_info::Alter_info()" -> "List<T>::List() [with T = char]"
"Alter_info::Alter_info()" -> "List<T>::List() [with T = Alter_drop]"
"List<T>::List() [with T = Key]" -> "base_list::base_list()"
"List<T>::List() [with T = Alter_column]" -> "base_list::base_list()"
"List<T>::List() [with T = Create_field]" -> "base_list::base_list()"
"List<T>::List() [with T = char]" -> "base_list::base_list()"
"List<T>::List() [with T = Alter_drop]" -> "base_list::base_list()"
"List<T>::List() [with T = Name_resolution_context]" -> "base_list::base_list()"
"List<T>::List() [with T = Item_func_set_user_var]" -> "base_list::base_list()"
"st_ha_create_information::st_ha_create_information()" -> "SQL_I_List<T>::SQL_I_List() [with T = TABLE_LIST]"
"st_select_lex::st_select_lex()" -> "Bounds_checked_array<Element_type>::Bounds_checked_array() [with Element_type = Item*]"
"st_select_lex::st_select_lex()" -> "List<T>::List() [with T = TABLE_LIST]"
"st_select_lex::st_select_lex()" -> "SQL_I_List<T>::SQL_I_List() [with T = st_order]"
"st_select_lex::st_select_lex()" -> "List<T>::List() [with T = Item]"
"st_select_lex::st_select_lex()" -> "SQL_I_List<T>::SQL_I_List() [with T = TABLE_LIST]"
"st_select_lex::st_select_lex()" -> "Name_resolution_context::Name_resolution_context()"
"st_select_lex::st_select_lex()" -> "List<T>::List() [with T = String]"
"st_select_lex::st_select_lex()" -> "List<T>::List() [with T = st_udf_func]"
"st_select_lex::st_select_lex()" -> "List<T>::List() [with T = Item_func_match]"
"st_select_lex::st_select_lex()" -> "st_select_lex_node::st_select_lex_node()"
"st_select_lex::st_select_lex()" -> "List<T>::List() [with T = Item_field]"
"st_select_lex::st_select_lex()" -> "List<T>::List() [with T = Item_outer_ref]"
"List<T>::List() [with T = TABLE_LIST]" -> "base_list::base_list()"
"SQL_I_List<T>::SQL_I_List() [with T = st_order]" -> "SQL_I_List<T>::empty() [with T = st_order]"
"SQL_I_List<T>::SQL_I_List() [with T = st_order]" -> "Sql_alloc::Sql_alloc()"
"Name_resolution_context::Name_resolution_context()" -> "Sql_alloc::Sql_alloc()"
"List<T>::List() [with T = st_udf_func]" -> "base_list::base_list()"
"List<T>::List() [with T = Item_func_match]" -> "base_list::base_list()"
"List<T>::List() [with T = Item_field]" -> "base_list::base_list()"
"List<T>::List() [with T = Item_outer_ref]" -> "base_list::base_list()"
"PROFILING::PROFILING()" -> "Queue<T>::Queue() [with T = QUERY_PROFILE]"
"Statement::Statement(LEX*,MEM_ROOT*,Query_arena::enum_state,ulong)" -> "CSET_STRING::CSET_STRING()"
"Statement::Statement(LEX*,MEM_ROOT*,Query_arena::enum_state,ulong)" -> "String::String()"
"Statement::Statement(LEX*,MEM_ROOT*,Query_arena::enum_state,ulong)" -> "Query_arena::Query_arena(MEM_ROOT*,Query_arena::enum_state)"
"Ha_data::Ha_data()" -> "Ha_trx_info::Ha_trx_info()"
"Ha_trx_info::Ha_trx_info()" -> "Ha_trx_info::reset()"
"Protocol_text::Protocol_text()" -> "Protocol::Protocol()"
"Security_context::Security_context()" -> "String::String()"
"THD::st_transactions::st_transactions()" -> "xid_t::null()"
"THD::st_transactions::st_transactions()" -> "memset(void*,int,size_t)"
"THD::st_transactions::st_transactions()" -> "init_sql_alloc(MEM_ROOT*,uint,uint)"
"THD::st_transactions::st_transactions()" -> "st_xid_state::st_xid_state()"
"st_xid_state::st_xid_state()" -> "xid_t::xid_t()"
"MDL_context::MDL_context()" -> "inline_mysql_prlock_init(mysql_prlock_t*)"
"MDL_context::MDL_context()" -> "I>::I_P_List() [with T = MDL_ticket,B = I_P_List_adapter<MDL_ticket,&MDL_ticket::next_in_context,&MDL_ticket::prev_in_context>,C = I_P_List_null_counter,I = I_P_List_no_push_back<MDL_ticket>]"
"MDL_context::MDL_context()" -> "MDL_wait::MDL_wait()"
"inline_mysql_prlock_init(mysql_prlock_t*)" -> "rw_pr_init(rw_pr_lock_t*)"
"I>::I_P_List() [with T = MDL_ticket,B = I_P_List_adapter<MDL_ticket,&MDL_ticket::next_in_context,&MDL_ticket::prev_in_context>,C = I_P_List_null_counter,I = I_P_List_no_push_back<MDL_ticket>]" -> "I_P_List_null_counter::I_P_List_null_counter()"
"I>::I_P_List() [with T = MDL_ticket,B = I_P_List_adapter<MDL_ticket,&MDL_ticket::next_in_context,&MDL_ticket::prev_in_context>,C = I_P_List_null_counter,I = I_P_List_no_push_back<MDL_ticket>]" -> "I_P_List_no_push_back<T>::I_P_List_no_push_back(T**) [with T = MDL_ticket]"
"MDL_wait::MDL_wait()" -> "inline_mysql_cond_init(mysql_cond_t*,const pthread_condattr_t*)"
"MDL_wait::MDL_wait()" -> "inline_mysql_mutex_init(mysql_mutex_t*,const pthread_mutexattr_t*)"
"inline_mysql_cond_init(mysql_cond_t*,const pthread_condattr_t*)" -> "pthread_cond_init(pthread_cond_t*,const pthread_condattr_t*)"
"Discrete_intervals_list::Discrete_intervals_list()" -> "Discrete_interval::Discrete_interval()"
"Discrete_interval::Discrete_interval()" -> "Discrete_interval::replace(ulonglong,ulonglong,ulonglong)"
"Statement_map::Statement_map()" -> "_my_hash_init(HASH*,uint,CHARSET_INFO*,my_hash_function,ulong,size_t,size_t,my_hash_get_key,void (*)(void*),uint)"
"Gtid_set::Gtid_set(Sid_map*,Checkable_rwlock*)" -> "Gtid_set::init()"
"Gtid_set::init()" -> "inline_mysql_mutex_init(mysql_mutex_t*,const pthread_mutexattr_t*)"
"Gtid_set::init()" -> "init_dynamic_array2(DYNAMIC_ARRAY*,uint,void*,uint,uint)"
"Gtid_set::init()" -> "inline_mysql_mutex_init(PSI_mutex_key,mysql_mutex_t*,const pthread_mutexattr_t*)"
"inline_mysql_mutex_init(PSI_mutex_key,mysql_mutex_t*,const pthread_mutexattr_t*)" -> "pthread_mutex_init(pthread_mutex_t*,const pthread_mutexattr_t*)"
"MYSQL_BIN_LOG::rotate_and_purge(bool)" -> "inline_mysql_mutex_lock(mysql_mutex_t*)"
"MYSQL_BIN_LOG::rotate_and_purge(bool)" -> "MYSQL_BIN_LOG::purge()"
"MYSQL_BIN_LOG::rotate_and_purge(bool)" -> "MYSQL_BIN_LOG::rotate(bool,bool*)"
"MYSQL_BIN_LOG::rotate_and_purge(bool)" -> "inline_mysql_mutex_unlock(mysql_mutex_t*)"
"MDL_context::is_lock_owner(MDL_key::enum_mdl_namespace,const char*,const char*,enum_mdl_type)" -> "MDL_request::MDL_request()"
"MDL_context::is_lock_owner(MDL_key::enum_mdl_namespace,const char*,const char*,enum_mdl_type)" -> "MDL_request::init(MDL_key::enum_mdl_namespace,const char*,const char*,enum_mdl_type,enum_mdl_duration)"
"MDL_context::is_lock_owner(MDL_key::enum_mdl_namespace,const char*,const char*,enum_mdl_type)" -> "MDL_context::find_ticket(MDL_request*,enum_mdl_duration*)"
"MDL_context::find_ticket(MDL_request*,enum_mdl_duration*)" -> "L>::operator++(int) [with T = MDL_ticket,L = I_P_List<MDL_ticket,I_P_List_adapter<MDL_ticket,&MDL_ticket::next_in_context,&MDL_ticket::prev_in_context> >]"
"MDL_context::find_ticket(MDL_request*,enum_mdl_duration*)" -> "L>::I_P_List_iterator(const L&) [with T = MDL_ticket,L = I_P_List<MDL_ticket,I_P_List_adapter<MDL_ticket,&MDL_ticket::next_in_context,&MDL_ticket::prev_in_context> >]"
"MDL_context::find_ticket(MDL_request*,enum_mdl_duration*)" -> "MDL_key::is_equal(const MDL_key*) const"
"MDL_context::find_ticket(MDL_request*,enum_mdl_duration*)" -> "MDL_ticket::has_stronger_or_equal_type(enum_mdl_type) const"
"MDL_key::is_equal(const MDL_key*) const" -> "memcmp(const void*,const void*,size_t)"
"LOGGER::flush_general_log()" -> "LOGGER::lock_exclusive()"
"LOGGER::flush_general_log()" -> "LOGGER::unlock()"
"LOGGER::flush_general_log()" -> "Log_to_file_event_handler::get_mysql_log()"
"LOGGER::flush_general_log()" -> "MYSQL_QUERY_LOG::reopen_file()"
"Global_read_lock::make_global_read_lock_block_commit(THD*)" -> "MDL_request::MDL_request()"
"Global_read_lock::make_global_read_lock_block_commit(THD*)" -> "MDL_context::acquire_lock(MDL_request*,ulong)"
"Global_read_lock::make_global_read_lock_block_commit(THD*)" -> "MDL_request::init(MDL_key::enum_mdl_namespace,const char*,const char*,enum_mdl_type,enum_mdl_duration)"
"MDL_context::acquire_lock(MDL_request*,ulong)" -> "MDL_wait::timed_wait(MDL_context_owner*,timespec*,bool,const PSI_stage_info*)"
"MDL_context::acquire_lock(MDL_request*,ulong)" -> "MDL_context::find_deadlock()"
"MDL_context::acquire_lock(MDL_request*,ulong)" -> "I>::push_front(T*) [with T = MDL_ticket,B = I_P_List_adapter<MDL_ticket,&MDL_ticket::next_in_context,&MDL_ticket::prev_in_context>,C = I_P_List_null_counter,I = I_P_List_no_push_back<MDL_ticket>]"
"MDL_context::acquire_lock(MDL_request*,ulong)" -> "MDL_lock::Ticket_list::add_ticket(MDL_ticket*)"
"MDL_context::acquire_lock(MDL_request*,ulong)" -> "my_getsystime()"
"MDL_context::acquire_lock(MDL_request*,ulong)" -> "MDL_key::get_wait_state_name() const"
"MDL_context::acquire_lock(MDL_request*,ulong)" -> "inline_mysql_prlock_wrlock(mysql_prlock_t*)"
"MDL_context::acquire_lock(MDL_request*,ulong)" -> "MDL_context::done_waiting_for()"
"MDL_context::acquire_lock(MDL_request*,ulong)" -> "MDL_wait::reset_status()"
"MDL_context::acquire_lock(MDL_request*,ulong)" -> "MDL_lock::remove_ticket(MDL_lock::Ticket_list MDL_lock::*,MDL_ticket*)"
"MDL_context::acquire_lock(MDL_request*,ulong)" -> "my_error(int,myf,...)"
"MDL_context::acquire_lock(MDL_request*,ulong)" -> "MDL_context::try_acquire_lock_impl(MDL_request*,MDL_ticket**)"
"MDL_context::acquire_lock(MDL_request*,ulong)" -> "MDL_ticket::destroy(MDL_ticket*)"
"MDL_context::acquire_lock(MDL_request*,ulong)" -> "MDL_context::will_wait_for(MDL_wait_for_subgraph*)"
"MDL_context::acquire_lock(MDL_request*,ulong)" -> "inline_mysql_prlock_unlock(mysql_prlock_t*)"
"MDL_wait::timed_wait(MDL_context_owner*,timespec*,bool,const PSI_stage_info*)" -> "inline_mysql_mutex_lock(mysql_mutex_t*)"
"MDL_wait::timed_wait(MDL_context_owner*,timespec*,bool,const PSI_stage_info*)" -> "thd_wait_end(THD*)"
"MDL_wait::timed_wait(MDL_context_owner*,timespec*,bool,const PSI_stage_info*)" -> "inline_mysql_cond_timedwait(mysql_cond_t*,mysql_mutex_t*,const timespec*)"
"MDL_wait::timed_wait(MDL_context_owner*,timespec*,bool,const PSI_stage_info*)" -> "thd_wait_begin(THD*,int)"
"MDL_context::find_deadlock()" -> "MDL_wait::set_status(MDL_wait::enum_wait_status)"
"MDL_context::find_deadlock()" -> "MDL_context::visit_subgraph(MDL_wait_for_graph_visitor*)"
"MDL_context::find_deadlock()" -> "Deadlock_detection_visitor::get_victim() const"
"MDL_context::find_deadlock()" -> "MDL_context::unlock_deadlock_victim()"
"MDL_context::find_deadlock()" -> "Deadlock_detection_visitor::Deadlock_detection_visitor(MDL_context*)"
"MDL_context::visit_subgraph(MDL_wait_for_graph_visitor*)" -> "inline_mysql_prlock_rdlock(mysql_prlock_t*)"
"MDL_context::visit_subgraph(MDL_wait_for_graph_visitor*)" -> "inline_mysql_prlock_unlock(mysql_prlock_t*)"
"inline_mysql_prlock_rdlock(mysql_prlock_t*)" -> "rw_pr_rdlock(rw_pr_lock_t*)"
"MDL_context::unlock_deadlock_victim()" -> "inline_mysql_prlock_unlock(mysql_prlock_t*)"
"Deadlock_detection_visitor::Deadlock_detection_visitor(MDL_context*)" -> "MDL_wait_for_graph_visitor::MDL_wait_for_graph_visitor()"
"MDL_key::get_wait_state_name() const" -> "MDL_key::mdl_namespace() const"
"MDL_context::done_waiting_for()" -> "inline_mysql_prlock_wrlock(mysql_prlock_t*)"
"MDL_context::done_waiting_for()" -> "inline_mysql_prlock_unlock(mysql_prlock_t*)"
"MDL_wait::reset_status()" -> "inline_mysql_mutex_unlock(mysql_mutex_t*)"
"MDL_wait::reset_status()" -> "inline_mysql_mutex_lock(mysql_mutex_t*)"
"MDL_context::try_acquire_lock_impl(MDL_request*,MDL_ticket**)" -> "MDL_context::clone_ticket(MDL_request*)"
"MDL_context::try_acquire_lock_impl(MDL_request*,MDL_ticket**)" -> "inline_mysql_prlock_unlock(mysql_prlock_t*)"
"MDL_context::try_acquire_lock_impl(MDL_request*,MDL_ticket**)" -> "MDL_lock::can_grant_lock(enum_mdl_type,MDL_context*,bool) const"
"MDL_context::try_acquire_lock_impl(MDL_request*,MDL_ticket**)" -> "MDL_lock::Ticket_list::add_ticket(MDL_ticket*)"
"MDL_context::try_acquire_lock_impl(MDL_request*,MDL_ticket**)" -> "MDL_ticket::create(MDL_context*,enum_mdl_type)"
"MDL_context::try_acquire_lock_impl(MDL_request*,MDL_ticket**)" -> "MDL_context::find_ticket(MDL_request*,enum_mdl_duration*)"
"MDL_context::try_acquire_lock_impl(MDL_request*,MDL_ticket**)" -> "MDL_map::find_or_insert(const MDL_key*)"
"MDL_context::try_acquire_lock_impl(MDL_request*,MDL_ticket**)" -> "MDL_ticket::destroy(MDL_ticket*)"
"MDL_context::try_acquire_lock_impl(MDL_request*,MDL_ticket**)" -> "I>::push_front(T*) [with T = MDL_ticket,B = I_P_List_adapter<MDL_ticket,&MDL_ticket::next_in_context,&MDL_ticket::prev_in_context>,C = I_P_List_null_counter,I = I_P_List_no_push_back<MDL_ticket>]"
"MDL_context::clone_ticket(MDL_request*)" -> "MDL_ticket::create(MDL_context*,enum_mdl_type)"
"MDL_context::clone_ticket(MDL_request*)" -> "I>::push_front(T*) [with T = MDL_ticket,B = I_P_List_adapter<MDL_ticket,&MDL_ticket::next_in_context,&MDL_ticket::prev_in_context>,C = I_P_List_null_counter,I = I_P_List_no_push_back<MDL_ticket>]"
"MDL_context::clone_ticket(MDL_request*)" -> "inline_mysql_prlock_unlock(mysql_prlock_t*)"
"MDL_context::clone_ticket(MDL_request*)" -> "MDL_lock::Ticket_list::add_ticket(MDL_ticket*)"
"MDL_context::clone_ticket(MDL_request*)" -> "inline_mysql_prlock_wrlock(mysql_prlock_t*)"
"MDL_ticket::create(MDL_context*,enum_mdl_type)" -> "MDL_ticket::MDL_ticket(MDL_context*,enum_mdl_type)"
"MDL_ticket::MDL_ticket(MDL_context*,enum_mdl_type)" -> "MDL_wait_for_subgraph::MDL_wait_for_subgraph()"
"MDL_map::find_or_insert(const MDL_key*)" -> "MDL_key::mdl_namespace() const"
"MDL_map::find_or_insert(const MDL_key*)" -> "inline_mysql_prlock_wrlock(mysql_prlock_t*)"
"MDL_map::find_or_insert(const MDL_key*)" -> "MDL_map_partition::find_or_insert(const MDL_key*,my_hash_value_type)"
"MDL_map::find_or_insert(const MDL_key*)" -> "Dynamic_array<Elem>::at(int) [with Elem = MDL_map_partition*]"
"MDL_map::find_or_insert(const MDL_key*)" -> "MDL_map_partition::get_key_hash(const MDL_key*) const"
"MDL_map_partition::find_or_insert(const MDL_key*,my_hash_value_type)" -> "MDL_object_lock::reset(const MDL_key*)"
"MDL_map_partition::find_or_insert(const MDL_key*,my_hash_value_type)" -> "my_hash_search_using_hash_value(const HASH*,my_hash_value_type,const uchar*,size_t)"
"MDL_map_partition::find_or_insert(const MDL_key*,my_hash_value_type)" -> "I>::push_front(T*) [with T = MDL_object_lock,B = MDL_object_lock_cache_adapter,C = I_P_List_counter,I = I_P_List_no_push_back<MDL_object_lock>]"
"MDL_map_partition::find_or_insert(const MDL_key*,my_hash_value_type)" -> "MDL_key::length() const"
"MDL_map_partition::find_or_insert(const MDL_key*,my_hash_value_type)" -> "I>::pop_front() [with T = MDL_object_lock,B = MDL_object_lock_cache_adapter,C = I_P_List_counter,I = I_P_List_no_push_back<MDL_object_lock>]"
"MDL_map_partition::find_or_insert(const MDL_key*,my_hash_value_type)" -> "my_hash_insert(HASH*,const uchar*)"
"MDL_map_partition::find_or_insert(const MDL_key*,my_hash_value_type)" -> "inline_mysql_mutex_unlock(mysql_mutex_t*)"
"MDL_map_partition::find_or_insert(const MDL_key*,my_hash_value_type)" -> "inline_mysql_mutex_lock(mysql_mutex_t*)"
"MDL_map_partition::find_or_insert(const MDL_key*,my_hash_value_type)" -> "MDL_key::ptr() const"
"MDL_map_partition::find_or_insert(const MDL_key*,my_hash_value_type)" -> "MDL_map_partition::move_from_hash_to_lock_mutex(MDL_lock*)"
"MDL_map_partition::find_or_insert(const MDL_key*,my_hash_value_type)" -> "MDL_key::mdl_namespace() const"
"MDL_map_partition::find_or_insert(const MDL_key*,my_hash_value_type)" -> "MDL_lock::destroy(MDL_lock*)"
"MDL_map_partition::find_or_insert(const MDL_key*,my_hash_value_type)" -> "MDL_lock::create(const MDL_key*,MDL_map_partition*)"
"MDL_map_partition::find_or_insert(const MDL_key*,my_hash_value_type)" -> "I_P_List_counter::elements() const"
"MDL_object_lock::reset(const MDL_key*)" -> "MDL_key::mdl_key_init(const MDL_key*)"
"MDL_key::mdl_key_init(const MDL_key*)" -> "memcpy(void*,const void*,size_t)"
"I>::pop_front() [with T = MDL_object_lock,B = MDL_object_lock_cache_adapter,C = I_P_List_counter,I = I_P_List_no_push_back<MDL_object_lock>]" -> "I>::remove(T*) [with T = MDL_object_lock,B = MDL_object_lock_cache_adapter,C = I_P_List_counter,I = I_P_List_no_push_back<MDL_object_lock>]"
"I>::pop_front() [with T = MDL_object_lock,B = MDL_object_lock_cache_adapter,C = I_P_List_counter,I = I_P_List_no_push_back<MDL_object_lock>]" -> "I>::front() [with T = MDL_object_lock,B = MDL_object_lock_cache_adapter,C = I_P_List_counter,I = I_P_List_no_push_back<MDL_object_lock>]"
"I>::remove(T*) [with T = MDL_object_lock,B = MDL_object_lock_cache_adapter,C = I_P_List_counter,I = I_P_List_no_push_back<MDL_object_lock>]" -> "I_P_List_counter::dec()"
"I>::remove(T*) [with T = MDL_object_lock,B = MDL_object_lock_cache_adapter,C = I_P_List_counter,I = I_P_List_no_push_back<MDL_object_lock>]" -> "prev>::next_ptr(T*) [with T = MDL_object_lock,T* T::* next = &MDL_object_lock::next_in_cache,T** T::* prev = &MDL_object_lock::prev_in_cache]"
"I>::remove(T*) [with T = MDL_object_lock,B = MDL_object_lock_cache_adapter,C = I_P_List_counter,I = I_P_List_no_push_back<MDL_object_lock>]" -> "prev>::prev_ptr(T*) [with T = MDL_object_lock,T* T::* next = &MDL_object_lock::next_in_cache,T** T::* prev = &MDL_object_lock::prev_in_cache]"
"I>::remove(T*) [with T = MDL_object_lock,B = MDL_object_lock_cache_adapter,C = I_P_List_counter,I = I_P_List_no_push_back<MDL_object_lock>]" -> "I_P_List_no_push_back<T>::set_last(T**) [with T = MDL_object_lock]"
"MDL_map_partition::move_from_hash_to_lock_mutex(MDL_lock*)" -> "inline_mysql_mutex_unlock(mysql_mutex_t*)"
"MDL_map_partition::move_from_hash_to_lock_mutex(MDL_lock*)" -> "inline_mysql_prlock_unlock(mysql_prlock_t*)"
"MDL_map_partition::move_from_hash_to_lock_mutex(MDL_lock*)" -> "MDL_lock::destroy(MDL_lock*)"
"MDL_map_partition::move_from_hash_to_lock_mutex(MDL_lock*)" -> "__builtin_expect(long int,long int)"
"MDL_map_partition::move_from_hash_to_lock_mutex(MDL_lock*)" -> "inline_mysql_prlock_wrlock(mysql_prlock_t*)"
"MDL_lock::create(const MDL_key*,MDL_map_partition*)" -> "MDL_scoped_lock::MDL_scoped_lock(const MDL_key*,MDL_map_partition*)"
"MDL_lock::create(const MDL_key*,MDL_map_partition*)" -> "MDL_key::mdl_namespace() const"
"MDL_lock::create(const MDL_key*,MDL_map_partition*)" -> "MDL_object_lock::MDL_object_lock(const MDL_key*,MDL_map_partition*)"
"MDL_scoped_lock::MDL_scoped_lock(const MDL_key*,MDL_map_partition*)" -> "MDL_lock::MDL_lock(const MDL_key*,MDL_map_partition*)"
"MDL_lock::MDL_lock(const MDL_key*,MDL_map_partition*)" -> "MDL_key::MDL_key(const MDL_key*)"
"MDL_lock::MDL_lock(const MDL_key*,MDL_map_partition*)" -> "inline_mysql_prlock_init(mysql_prlock_t*)"
"MDL_lock::MDL_lock(const MDL_key*,MDL_map_partition*)" -> "MDL_lock::Ticket_list::Ticket_list()"
"MDL_key::MDL_key(const MDL_key*)" -> "MDL_key::mdl_key_init(const MDL_key*)"
"MDL_lock::Ticket_list::Ticket_list()" -> "I>::I_P_List() [with T = MDL_ticket,B = I_P_List_adapter<MDL_ticket,&MDL_ticket::next_in_lock,&MDL_ticket::prev_in_lock>,C = I_P_List_null_counter,I = I_P_List_fast_push_back<MDL_ticket>]"
"I>::I_P_List() [with T = MDL_ticket,B = I_P_List_adapter<MDL_ticket,&MDL_ticket::next_in_lock,&MDL_ticket::prev_in_lock>,C = I_P_List_null_counter,I = I_P_List_fast_push_back<MDL_ticket>]" -> "I_P_List_fast_push_back<T>::I_P_List_fast_push_back(T**) [with T = MDL_ticket]"
"I>::I_P_List() [with T = MDL_ticket,B = I_P_List_adapter<MDL_ticket,&MDL_ticket::next_in_lock,&MDL_ticket::prev_in_lock>,C = I_P_List_null_counter,I = I_P_List_fast_push_back<MDL_ticket>]" -> "I_P_List_null_counter::I_P_List_null_counter()"
"MDL_object_lock::MDL_object_lock(const MDL_key*,MDL_map_partition*)" -> "MDL_lock::MDL_lock(const MDL_key*,MDL_map_partition*)"
"MDL_map_partition::get_key_hash(const MDL_key*) const" -> "MDL_key::length() const"
"MDL_map_partition::get_key_hash(const MDL_key*) const" -> "MDL_key::ptr() const"
"MDL_map_partition::get_key_hash(const MDL_key*) const" -> "my_calc_hash(const HASH*,const uchar*,size_t)"
"MDL_context::will_wait_for(MDL_wait_for_subgraph*)" -> "inline_mysql_prlock_wrlock(mysql_prlock_t*)"
"MDL_context::will_wait_for(MDL_wait_for_subgraph*)" -> "inline_mysql_prlock_unlock(mysql_prlock_t*)"
"my_dbopt_cleanup()" -> "inline_mysql_rwlock_unlock(mysql_rwlock_t*)"
"my_dbopt_cleanup()" -> "_my_hash_init(HASH*,uint,CHARSET_INFO*,my_hash_function,ulong,size_t,size_t,my_hash_get_key,void (*)(void*),uint)"
"my_dbopt_cleanup()" -> "inline_mysql_rwlock_wrlock(mysql_rwlock_t*)"
"my_dbopt_cleanup()" -> "my_hash_free(HASH*)"
"flush_error_log()" -> "inline_mysql_mutex_lock(mysql_mutex_t*)"
"flush_error_log()" -> "redirect_std_streams(const char*)"
"flush_error_log()" -> "inline_mysql_mutex_unlock(mysql_mutex_t*)"
"redirect_std_streams(const char*)" -> "reopen_fstreams(const char*,FILE*,FILE*)"
"redirect_std_streams(const char*)" -> "setbuf(FILE*,char*)"
"reopen_fstreams(const char*,FILE*,FILE*)" -> "setbuf(FILE*,char*)"
"reopen_fstreams(const char*,FILE*,FILE*)" -> "my_freopen(const char*,const char*,FILE*)"
"Query_cache::pack(ulong,uint)" -> "Query_cache::try_lock(bool)"
"Query_cache::pack(ulong,uint)" -> "Query_cache::pack_cache()"
"Query_cache::pack(ulong,uint)" -> "Query_cache::unlock()"
"Query_cache::pack(ulong,uint)" -> "Query_cache::join_results(ulong)"
"Query_cache::pack(ulong,uint)" -> "Query_cache::is_disabled()"
"Query_cache::pack_cache()" -> "Query_cache::insert_into_free_memory_list(Query_cache_block*)"
"Query_cache::pack_cache()" -> "Query_cache_block::init(ulong)"
"Query_cache::pack_cache()" -> "Query_cache::move_by_type(uchar**,Query_cache_block**,ulong*,Query_cache_block*)"
"Query_cache::move_by_type(uchar**,Query_cache_block**,ulong*,Query_cache_block*)" -> "query_cache_table_get_key(const uchar*,size_t*,my_bool)"
"Query_cache::move_by_type(uchar**,Query_cache_block**,ulong*,Query_cache_block*)" -> "Query_cache_table::table(char*)"
"Query_cache::move_by_type(uchar**,Query_cache_block**,ulong*,Query_cache_block*)" -> "my_hash_replace(HASH*,HASH_SEARCH_STATE*,uchar*)"
"Query_cache::move_by_type(uchar**,Query_cache_block**,ulong*,Query_cache_block*)" -> "Query_cache_table::db()"
"Query_cache::move_by_type(uchar**,Query_cache_block**,ulong*,Query_cache_block*)" -> "Query_cache_query::unlock_n_destroy()"
"Query_cache::move_by_type(uchar**,Query_cache_block**,ulong*,Query_cache_block*)" -> "Query_cache_block::table(uint)"
"Query_cache::move_by_type(uchar**,Query_cache_block**,ulong*,Query_cache_block*)" -> "Query_cache_block::data()"
"Query_cache::move_by_type(uchar**,Query_cache_block**,ulong*,Query_cache_block*)" -> "Query_cache_block::result()"
"Query_cache::move_by_type(uchar**,Query_cache_block**,ulong*,Query_cache_block*)" -> "Query_cache_query::writer()"
"Query_cache::move_by_type(uchar**,Query_cache_block**,ulong*,Query_cache_block*)" -> "my_hash_first(const HASH*,const uchar*,size_t,HASH_SEARCH_STATE*)"
"Query_cache::move_by_type(uchar**,Query_cache_block**,ulong*,Query_cache_block*)" -> "Query_cache_block::destroy()"
"Query_cache::move_by_type(uchar**,Query_cache_block**,ulong*,Query_cache_block*)" -> "Query_cache_block::headers_len()"
"Query_cache::move_by_type(uchar**,Query_cache_block**,ulong*,Query_cache_block*)" -> "inline_mysql_rwlock_init(mysql_rwlock_t*)"
"Query_cache::move_by_type(uchar**,Query_cache_block**,ulong*,Query_cache_block*)" -> "Query_cache_block::table()"
"Query_cache::move_by_type(uchar**,Query_cache_block**,ulong*,Query_cache_block*)" -> "Query_cache_query::result(Query_cache_block*)"
"Query_cache::move_by_type(uchar**,Query_cache_block**,ulong*,Query_cache_block*)" -> "query_cache_query_get_key(const uchar*,size_t*,my_bool)"
"Query_cache::move_by_type(uchar**,Query_cache_block**,ulong*,Query_cache_block*)" -> "Query_cache_block::init(ulong)"
"Query_cache::move_by_type(uchar**,Query_cache_block**,ulong*,Query_cache_block*)" -> "Query_cache_query::lock_writing()"
"Query_cache::move_by_type(uchar**,Query_cache_block**,ulong*,Query_cache_block*)" -> "Query_cache_query::result()"
"Query_cache::move_by_type(uchar**,Query_cache_block**,ulong*,Query_cache_block*)" -> "Query_cache_query::unlock_writing()"
"Query_cache::move_by_type(uchar**,Query_cache_block**,ulong*,Query_cache_block*)" -> "Query_cache::exclude_from_free_memory_list(Query_cache_block*)"
"Query_cache::move_by_type(uchar**,Query_cache_block**,ulong*,Query_cache_block*)" -> "Query_cache::relink(Query_cache_block*,Query_cache_block*,Query_cache_block*,Query_cache_block*,Query_cache_block*,Query_cache_block*)"
"Query_cache::move_by_type(uchar**,Query_cache_block**,ulong*,Query_cache_block*)" -> "Query_cache_block::query()"
"Query_cache::move_by_type(uchar**,Query_cache_block**,ulong*,Query_cache_block*)" -> "Query_cache_table::table()"
"Query_cache::move_by_type(uchar**,Query_cache_block**,ulong*,Query_cache_block*)" -> "Query_cache_result::parent(Query_cache_block*)"
"Query_cache::move_by_type(uchar**,Query_cache_block**,ulong*,Query_cache_block*)" -> "Query_cache_result::parent()"
"Query_cache::move_by_type(uchar**,Query_cache_block**,ulong*,Query_cache_block*)" -> "memmove(void*,const void*,size_t)"
"query_cache_table_get_key(const uchar*,size_t*,my_bool)" -> "Query_cache_block::data()"
"query_cache_table_get_key(const uchar*,size_t*,my_bool)" -> "Query_cache_block::headers_len()"
"Query_cache_table::db()" -> "Query_cache_table::data()"
"Query_cache_block::result()" -> "Query_cache_block::data()"
"inline_mysql_rwlock_init(mysql_rwlock_t*)" -> "pthread_rwlock_init(pthread_rwlock_t*,const pthread_rwlockattr_t*)"
"Query_cache_block::table()" -> "Query_cache_block::data()"
"query_cache_query_get_key(const uchar*,size_t*,my_bool)" -> "Query_cache_block::headers_len()"
"query_cache_query_get_key(const uchar*,size_t*,my_bool)" -> "Query_cache_block::data()"
"Query_cache::join_results(ulong)" -> "Query_cache::split_block(Query_cache_block*,ulong)"
"Query_cache::join_results(ulong)" -> "Query_cache_result::parent(Query_cache_block*)"
"Query_cache::join_results(ulong)" -> "memcpy(void*,const void*,size_t)"
"Query_cache::join_results(ulong)" -> "Query_cache_query::result()"
"Query_cache::join_results(ulong)" -> "Query_cache_block::result()"
"Query_cache::join_results(ulong)" -> "Query_cache_query::lock_writing()"
"Query_cache::join_results(ulong)" -> "Query_cache_block::headers_len()"
"Query_cache::join_results(ulong)" -> "Query_cache_result::data()"
"Query_cache::join_results(ulong)" -> "Query_cache::free_memory_block(Query_cache_block*)"
"Query_cache::join_results(ulong)" -> "Query_cache_block::query()"
"Query_cache::join_results(ulong)" -> "Query_cache_query::unlock_writing()"
"Query_cache::join_results(ulong)" -> "Query_cache_query::result(Query_cache_block*)"
"Query_cache::join_results(ulong)" -> "Query_cache::get_free_block(ulong,my_bool,ulong)"
"Query_cache::join_results(ulong)" -> "Query_cache_query::length()"
"Query_cache::split_block(Query_cache_block*,ulong)" -> "Query_cache::free_memory_block(Query_cache_block*)"
"Query_cache::split_block(Query_cache_block*,ulong)" -> "Query_cache::insert_into_free_memory_list(Query_cache_block*)"
"Query_cache::split_block(Query_cache_block*,ulong)" -> "Query_cache_block::init(ulong)"
"Query_cache::get_free_block(ulong,my_bool,ulong)" -> "Query_cache::exclude_from_free_memory_list(Query_cache_block*)"
"Query_cache::get_free_block(ulong,my_bool,ulong)" -> "Query_cache::find_bin(ulong)"
"Query_cache::flush()" -> "Query_cache::lock_and_suspend()"
"Query_cache::flush()" -> "Query_cache::flush_cache()"
"Query_cache::flush()" -> "Query_cache::is_disabled()"
"Query_cache::flush()" -> "Query_cache::unlock()"
"Query_cache::lock_and_suspend()" -> "Query_cache_wait_state::Query_cache_wait_state(THD*,const char*,const char*,unsigned int)"
"Query_cache::lock_and_suspend()" -> "inline_mysql_cond_broadcast(mysql_cond_t*)"
"Query_cache::lock_and_suspend()" -> "inline_mysql_mutex_lock(mysql_mutex_t*)"
"Query_cache::lock_and_suspend()" -> "inline_mysql_mutex_unlock(mysql_mutex_t*)"
"Query_cache::lock_and_suspend()" -> "inline_mysql_cond_wait(mysql_cond_t*,mysql_mutex_t*)"
"Query_cache::lock_and_suspend()" -> "_current_thd()"
"Query_cache::flush_cache()" -> "Query_cache_block::query()"
"Query_cache::flush_cache()" -> "Query_cache::free_query_internal(Query_cache_block*)"
"Query_cache::flush_cache()" -> "Query_cache_query::lock_writing()"
"Query_cache::flush_cache()" -> "my_hash_reset(HASH*)"
"hostname_cache_refresh()" -> "hash_filo::clear(bool)"
"hash_filo::clear(bool)" -> "_my_hash_init(HASH*,uint,CHARSET_INFO*,my_hash_function,ulong,size_t,size_t,my_hash_get_key,void (*)(void*),uint)"
"hash_filo::clear(bool)" -> "inline_mysql_mutex_lock(mysql_mutex_t*)"
"hash_filo::clear(bool)" -> "inline_mysql_mutex_init(mysql_mutex_t*,const pthread_mutexattr_t*)"
"hash_filo::clear(bool)" -> "inline_mysql_mutex_unlock(mysql_mutex_t*)"
"hash_filo::clear(bool)" -> "my_hash_free(HASH*)"
"THD::store_globals()" -> "pthread_setspecific(pthread_key_t,const void*)"
"THD::store_globals()" -> "_my_thread_var()"
"THD::store_globals()" -> "thr_lock_info_init(THR_LOCK_INFO*)"
"THD::store_globals()" -> "pthread_self()"
"close_cached_tables(THD*,TABLE_LIST*,bool,ulong)" -> "get_cached_table_share(const char*,const char*)"
"close_cached_tables(THD*,TABLE_LIST*,bool,ulong)" -> "tdc_remove_table(THD*,enum_tdc_remove_table_type,const char*,const char*,bool)"
"close_cached_tables(THD*,TABLE_LIST*,bool,ulong)" -> "mysql_ha_flush_tables(THD*,TABLE_LIST*)"
"close_cached_tables(THD*,TABLE_LIST*,bool,ulong)" -> "TABLE_SHARE::has_old_version() const"
"close_cached_tables(THD*,TABLE_LIST*,bool,ulong)" -> "inline_mysql_mutex_unlock(mysql_mutex_t*)"
"close_cached_tables(THD*,TABLE_LIST*,bool,ulong)" -> "Table_cache_manager::free_all_unused_tables()"
"close_cached_tables(THD*,TABLE_LIST*,bool,ulong)" -> "my_hash_delete(HASH*,uchar*)"
"close_cached_tables(THD*,TABLE_LIST*,bool,ulong)" -> "Locked_tables_list::locked_tables()"
"close_cached_tables(THD*,TABLE_LIST*,bool,ulong)" -> "find_table_for_mdl_upgrade(THD*,const char*,const char*,bool)"
"close_cached_tables(THD*,TABLE_LIST*,bool,ulong)" -> "close_all_tables_for_name(THD*,TABLE_SHARE*,bool,TABLE*)"
"close_cached_tables(THD*,TABLE_LIST*,bool,ulong)" -> "inline_mysql_mutex_lock(mysql_mutex_t*)"
"close_cached_tables(THD*,TABLE_LIST*,bool,ulong)" -> "my_hash_element(HASH*,ulong)"
"close_cached_tables(THD*,TABLE_LIST*,bool,ulong)" -> "Table_cache_manager::lock_all_and_tdc()"
"close_cached_tables(THD*,TABLE_LIST*,bool,ulong)" -> "wait_while_table_is_used(THD*,TABLE*,ha_extra_function)"
"close_cached_tables(THD*,TABLE_LIST*,bool,ulong)" -> "TABLE_SHARE::wait_for_old_version(THD*,timespec*,uint)"
"close_cached_tables(THD*,TABLE_LIST*,bool,ulong)" -> "my_getsystime()"
"close_cached_tables(THD*,TABLE_LIST*,bool,ulong)" -> "kill_delayed_threads_for_table(TABLE_SHARE*)"
"close_cached_tables(THD*,TABLE_LIST*,bool,ulong)" -> "kill_delayed_threads()"
"close_cached_tables(THD*,TABLE_LIST*,bool,ulong)" -> "Locked_tables_list::reopen_tables(THD*)"
"close_cached_tables(THD*,TABLE_LIST*,bool,ulong)" -> "Table_cache_manager::unlock_all_and_tdc()"
"close_cached_tables(THD*,TABLE_LIST*,bool,ulong)" -> "mysql_ha_flush(THD*)"
"close_cached_tables(THD*,TABLE_LIST*,bool,ulong)" -> "MDL_ticket::downgrade_lock(enum_mdl_type)"
"get_cached_table_share(const char*,const char*)" -> "create_table_def_key(THD*,char*,const char*,const char*,bool)"
"get_cached_table_share(const char*,const char*)" -> "my_hash_search(const HASH*,const uchar*,size_t)"
"create_table_def_key(THD*,char*,const char*,const char*,bool)" -> "strmake(char*,const char*,size_t)"
"tdc_remove_table(THD*,enum_tdc_remove_table_type,const char*,const char*,bool)" -> "my_hash_search(const HASH*,const uchar*,size_t)"
"tdc_remove_table(THD*,enum_tdc_remove_table_type,const char*,const char*,bool)" -> "Table_cache_manager::unlock_all_and_tdc()"
"tdc_remove_table(THD*,enum_tdc_remove_table_type,const char*,const char*,bool)" -> "Table_cache_manager::free_table(THD*,enum_tdc_remove_table_type,TABLE_SHARE*)"
"tdc_remove_table(THD*,enum_tdc_remove_table_type,const char*,const char*,bool)" -> "my_hash_delete(HASH*,uchar*)"
"tdc_remove_table(THD*,enum_tdc_remove_table_type,const char*,const char*,bool)" -> "Table_cache_manager::lock_all_and_tdc()"
"tdc_remove_table(THD*,enum_tdc_remove_table_type,const char*,const char*,bool)" -> "create_table_def_key(THD*,char*,const char*,const char*,bool)"
"tdc_remove_table(THD*,enum_tdc_remove_table_type,const char*,const char*,bool)" -> "Table_cache_manager::assert_owner_all_and_tdc()"
"Table_cache_manager::unlock_all_and_tdc()" -> "Table_cache::unlock()"
"Table_cache_manager::unlock_all_and_tdc()" -> "inline_mysql_mutex_unlock(mysql_mutex_t*)"
"Table_cache_manager::free_table(THD*,enum_tdc_remove_table_type,TABLE_SHARE*)" -> "Table_cache::remove_table(TABLE*)"
"Table_cache_manager::free_table(THD*,enum_tdc_remove_table_type,TABLE_SHARE*)" -> "intern_close_table(TABLE*)"
"Table_cache_manager::free_table(THD*,enum_tdc_remove_table_type,TABLE_SHARE*)" -> "L>::operator++(int) [with T = TABLE,L = I_P_List<TABLE,I_P_List_adapter<TABLE,&TABLE::cache_next,&TABLE::cache_prev> >]"
"Table_cache_manager::free_table(THD*,enum_tdc_remove_table_type,TABLE_SHARE*)" -> "memcpy(void*,const void*,size_t)"
"Table_cache_manager::free_table(THD*,enum_tdc_remove_table_type,TABLE_SHARE*)" -> "L>::I_P_List_iterator(const L&) [with T = TABLE,L = I_P_List<TABLE,I_P_List_adapter<TABLE,&TABLE::cache_next,&TABLE::cache_prev> >]"
"Table_cache_manager::free_table(THD*,enum_tdc_remove_table_type,TABLE_SHARE*)" -> "Table_cache_manager::assert_owner_all_and_tdc()"
"L>::operator++(int) [with T = TABLE,L = I_P_List<TABLE,I_P_List_adapter<TABLE,&TABLE::cache_next,&TABLE::cache_prev> >]" -> "prev>::next_ptr(T*) [with T = TABLE,T* T::* next = &TABLE::cache_next,T** T::* prev = &TABLE::cache_prev]"
"Table_cache_manager::assert_owner_all_and_tdc()" -> "Table_cache_manager::assert_owner_all()"
"Table_cache_manager::assert_owner_all()" -> "Table_cache::assert_owner()"
"Table_cache_manager::lock_all_and_tdc()" -> "inline_mysql_mutex_lock(mysql_mutex_t*)"
"Table_cache_manager::lock_all_and_tdc()" -> "Table_cache::lock()"
"mysql_ha_flush_tables(THD*,TABLE_LIST*)" -> "mysql_ha_find(THD*,TABLE_LIST*)"
"mysql_ha_flush_tables(THD*,TABLE_LIST*)" -> "mysql_ha_close_table(THD*,TABLE_LIST*)"
"mysql_ha_find(THD*,TABLE_LIST*)" -> "TABLE_LIST::get_table_name() const"
"mysql_ha_find(THD*,TABLE_LIST*)" -> "TABLE_LIST::get_db_name() const"
"mysql_ha_find(THD*,TABLE_LIST*)" -> "my_hash_element(HASH*,ulong)"
"mysql_ha_find(THD*,TABLE_LIST*)" -> "TABLE_LIST::is_anonymous_derived_table() const"
"Table_cache_manager::free_all_unused_tables()" -> "Table_cache_manager::assert_owner_all_and_tdc()"
"Table_cache_manager::free_all_unused_tables()" -> "Table_cache::free_all_unused_tables()"
"Table_cache::free_all_unused_tables()" -> "intern_close_table(TABLE*)"
"Table_cache::free_all_unused_tables()" -> "Table_cache::assert_owner()"
"Table_cache::free_all_unused_tables()" -> "Table_cache::remove_table(TABLE*)"
"find_table_for_mdl_upgrade(THD*,const char*,const char*,bool)" -> "MDL_context::is_lock_owner(MDL_key::enum_mdl_namespace,const char*,const char*,enum_mdl_type)"
"find_table_for_mdl_upgrade(THD*,const char*,const char*,bool)" -> "find_locked_table(TABLE*,const char*,const char*)"
"find_table_for_mdl_upgrade(THD*,const char*,const char*,bool)" -> "my_error(int,myf,...)"
"find_table_for_mdl_upgrade(THD*,const char*,const char*,bool)" -> "MDL_ticket::is_upgradable_or_exclusive() const"
"find_locked_table(TABLE*,const char*,const char*)" -> "memcmp(const void*,const void*,size_t)"
"find_locked_table(TABLE*,const char*,const char*)" -> "create_table_def_key(THD*,char*,const char*,const char*,bool)"
"close_all_tables_for_name(THD*,TABLE_SHARE*,bool,TABLE*)" -> "Locked_tables_list::unlink_from_list(THD*,TABLE_LIST*,bool)"
"close_all_tables_for_name(THD*,TABLE_SHARE*,bool,TABLE*)" -> "mysql_lock_remove(THD*,MYSQL_LOCK*,TABLE*)"
"close_all_tables_for_name(THD*,TABLE_SHARE*,bool,TABLE*)" -> "tdc_remove_table(THD*,enum_tdc_remove_table_type,const char*,const char*,bool)"
"close_all_tables_for_name(THD*,TABLE_SHARE*,bool,TABLE*)" -> "memcpy(void*,const void*,size_t)"
"close_all_tables_for_name(THD*,TABLE_SHARE*,bool,TABLE*)" -> "close_thread_table(THD*,TABLE**)"
"close_all_tables_for_name(THD*,TABLE_SHARE*,bool,TABLE*)" -> "memcmp(const void*,const void*,size_t)"
"mysql_lock_remove(THD*,MYSQL_LOCK*,TABLE*)" -> "memmove(void*,const void*,size_t)"
"mysql_lock_remove(THD*,MYSQL_LOCK*,TABLE*)" -> "mysql_unlock_some_tables(THD*,TABLE**,uint)"
"mysql_unlock_some_tables(THD*,TABLE**,uint)" -> "mysql_unlock_tables(THD*,MYSQL_LOCK*)"
"mysql_unlock_some_tables(THD*,TABLE**,uint)" -> "get_lock_data(THD*,TABLE**,uint,uint)"
"get_lock_data(THD*,TABLE**,uint,uint)" -> "my_malloc(size_t,myf)"
"wait_while_table_is_used(THD*,TABLE*,ha_extra_function)" -> "MDL_context::upgrade_shared_lock(MDL_ticket*,enum_mdl_type,ulong)"
"wait_while_table_is_used(THD*,TABLE*,ha_extra_function)" -> "tdc_remove_table(THD*,enum_tdc_remove_table_type,const char*,const char*,bool)"
"MDL_context::upgrade_shared_lock(MDL_ticket*,enum_mdl_type,ulong)" -> "MDL_request::MDL_request()"
"MDL_context::upgrade_shared_lock(MDL_ticket*,enum_mdl_type,ulong)" -> "MDL_ticket::destroy(MDL_ticket*)"
"MDL_context::upgrade_shared_lock(MDL_ticket*,enum_mdl_type,ulong)" -> "MDL_context::mdl_savepoint()"
"MDL_context::upgrade_shared_lock(MDL_ticket*,enum_mdl_type,ulong)" -> "inline_mysql_prlock_wrlock(mysql_prlock_t*)"
"MDL_context::upgrade_shared_lock(MDL_ticket*,enum_mdl_type,ulong)" -> "MDL_context::acquire_lock(MDL_request*,ulong)"
"MDL_context::upgrade_shared_lock(MDL_ticket*,enum_mdl_type,ulong)" -> "MDL_context::has_lock(const MDL_savepoint&,MDL_ticket*)"
"MDL_context::upgrade_shared_lock(MDL_ticket*,enum_mdl_type,ulong)" -> "I>::remove(T*) [with T = MDL_ticket,B = I_P_List_adapter<MDL_ticket,&MDL_ticket::next_in_context,&MDL_ticket::prev_in_context>,C = I_P_List_null_counter,I = I_P_List_no_push_back<MDL_ticket>]"
"MDL_context::upgrade_shared_lock(MDL_ticket*,enum_mdl_type,ulong)" -> "inline_mysql_prlock_unlock(mysql_prlock_t*)"
"MDL_context::upgrade_shared_lock(MDL_ticket*,enum_mdl_type,ulong)" -> "MDL_lock::Ticket_list::add_ticket(MDL_ticket*)"
"MDL_context::upgrade_shared_lock(MDL_ticket*,enum_mdl_type,ulong)" -> "MDL_ticket::has_stronger_or_equal_type(enum_mdl_type) const"
"MDL_context::upgrade_shared_lock(MDL_ticket*,enum_mdl_type,ulong)" -> "MDL_lock::Ticket_list::remove_ticket(MDL_ticket*)"
"MDL_context::upgrade_shared_lock(MDL_ticket*,enum_mdl_type,ulong)" -> "MDL_request::init(const MDL_key*,enum_mdl_type,enum_mdl_duration)"
"MDL_context::has_lock(const MDL_savepoint&,MDL_ticket*)" -> "L>::operator++(int) [with T = MDL_ticket,L = I_P_List<MDL_ticket,I_P_List_adapter<MDL_ticket,&MDL_ticket::next_in_context,&MDL_ticket::prev_in_context> >]"
"MDL_context::has_lock(const MDL_savepoint&,MDL_ticket*)" -> "L>::I_P_List_iterator(const L&) [with T = MDL_ticket,L = I_P_List<MDL_ticket,I_P_List_adapter<MDL_ticket,&MDL_ticket::next_in_context,&MDL_ticket::prev_in_context> >]"
"MDL_request::init(const MDL_key*,enum_mdl_type,enum_mdl_duration)" -> "MDL_key::mdl_key_init(const MDL_key*)"
"TABLE_SHARE::wait_for_old_version(THD*,timespec*,uint)" -> "I>::push_front(T*) [with T = Wait_for_flush,B = I_P_List_adapter<Wait_for_flush,&Wait_for_flush::next_in_share,&Wait_for_flush::prev_in_share>,C = I_P_List_null_counter,I = I_P_List_no_push_back<Wait_for_flush>]"
"TABLE_SHARE::wait_for_old_version(THD*,timespec*,uint)" -> "MDL_context::find_deadlock()"
"TABLE_SHARE::wait_for_old_version(THD*,timespec*,uint)" -> "MDL_wait::reset_status()"
"TABLE_SHARE::wait_for_old_version(THD*,timespec*,uint)" -> "my_error(int,myf,...)"
"TABLE_SHARE::wait_for_old_version(THD*,timespec*,uint)" -> "MDL_context::done_waiting_for()"
"TABLE_SHARE::wait_for_old_version(THD*,timespec*,uint)" -> "inline_mysql_mutex_lock(mysql_mutex_t*)"
"TABLE_SHARE::wait_for_old_version(THD*,timespec*,uint)" -> "I>::remove(T*) [with T = Wait_for_flush,B = I_P_List_adapter<Wait_for_flush,&Wait_for_flush::next_in_share,&Wait_for_flush::prev_in_share>,C = I_P_List_null_counter,I = I_P_List_no_push_back<Wait_for_flush>]"
"TABLE_SHARE::wait_for_old_version(THD*,timespec*,uint)" -> "MDL_context::will_wait_for(MDL_wait_for_subgraph*)"
"TABLE_SHARE::wait_for_old_version(THD*,timespec*,uint)" -> "Wait_for_flush::Wait_for_flush(MDL_context*,TABLE_SHARE*,uint)"
"TABLE_SHARE::wait_for_old_version(THD*,timespec*,uint)" -> "I>::is_empty() const [with T = Wait_for_flush,B = I_P_List_adapter<Wait_for_flush,&Wait_for_flush::next_in_share,&Wait_for_flush::prev_in_share>,C = I_P_List_null_counter,I = I_P_List_no_push_back<Wait_for_flush>]"
"TABLE_SHARE::wait_for_old_version(THD*,timespec*,uint)" -> "MDL_wait::timed_wait(MDL_context_owner*,timespec*,bool,const PSI_stage_info*)"
"TABLE_SHARE::wait_for_old_version(THD*,timespec*,uint)" -> "inline_mysql_mutex_unlock(mysql_mutex_t*)"
"TABLE_SHARE::wait_for_old_version(THD*,timespec*,uint)" -> "TABLE_SHARE::destroy()"
"I>::push_front(T*) [with T = Wait_for_flush,B = I_P_List_adapter<Wait_for_flush,&Wait_for_flush::next_in_share,&Wait_for_flush::prev_in_share>,C = I_P_List_null_counter,I = I_P_List_no_push_back<Wait_for_flush>]" -> "prev>::prev_ptr(T*) [with T = Wait_for_flush,T* T::* next = &Wait_for_flush::next_in_share,T** T::* prev = &Wait_for_flush::prev_in_share]"
"I>::push_front(T*) [with T = Wait_for_flush,B = I_P_List_adapter<Wait_for_flush,&Wait_for_flush::next_in_share,&Wait_for_flush::prev_in_share>,C = I_P_List_null_counter,I = I_P_List_no_push_back<Wait_for_flush>]" -> "I_P_List_null_counter::inc()"
"I>::push_front(T*) [with T = Wait_for_flush,B = I_P_List_adapter<Wait_for_flush,&Wait_for_flush::next_in_share,&Wait_for_flush::prev_in_share>,C = I_P_List_null_counter,I = I_P_List_no_push_back<Wait_for_flush>]" -> "prev>::next_ptr(T*) [with T = Wait_for_flush,T* T::* next = &Wait_for_flush::next_in_share,T** T::* prev = &Wait_for_flush::prev_in_share]"
"I>::push_front(T*) [with T = Wait_for_flush,B = I_P_List_adapter<Wait_for_flush,&Wait_for_flush::next_in_share,&Wait_for_flush::prev_in_share>,C = I_P_List_null_counter,I = I_P_List_no_push_back<Wait_for_flush>]" -> "I_P_List_no_push_back<T>::set_last(T**) [with T = Wait_for_flush]"
"I>::remove(T*) [with T = Wait_for_flush,B = I_P_List_adapter<Wait_for_flush,&Wait_for_flush::next_in_share,&Wait_for_flush::prev_in_share>,C = I_P_List_null_counter,I = I_P_List_no_push_back<Wait_for_flush>]" -> "prev>::next_ptr(T*) [with T = Wait_for_flush,T* T::* next = &Wait_for_flush::next_in_share,T** T::* prev = &Wait_for_flush::prev_in_share]"
"I>::remove(T*) [with T = Wait_for_flush,B = I_P_List_adapter<Wait_for_flush,&Wait_for_flush::next_in_share,&Wait_for_flush::prev_in_share>,C = I_P_List_null_counter,I = I_P_List_no_push_back<Wait_for_flush>]" -> "I_P_List_null_counter::dec()"
"I>::remove(T*) [with T = Wait_for_flush,B = I_P_List_adapter<Wait_for_flush,&Wait_for_flush::next_in_share,&Wait_for_flush::prev_in_share>,C = I_P_List_null_counter,I = I_P_List_no_push_back<Wait_for_flush>]" -> "prev>::prev_ptr(T*) [with T = Wait_for_flush,T* T::* next = &Wait_for_flush::next_in_share,T** T::* prev = &Wait_for_flush::prev_in_share]"
"I>::remove(T*) [with T = Wait_for_flush,B = I_P_List_adapter<Wait_for_flush,&Wait_for_flush::next_in_share,&Wait_for_flush::prev_in_share>,C = I_P_List_null_counter,I = I_P_List_no_push_back<Wait_for_flush>]" -> "I_P_List_no_push_back<T>::set_last(T**) [with T = Wait_for_flush]"
"Wait_for_flush::Wait_for_flush(MDL_context*,TABLE_SHARE*,uint)" -> "MDL_wait_for_subgraph::MDL_wait_for_subgraph()"
"kill_delayed_threads_for_table(TABLE_SHARE*)" -> "inline_mysql_mutex_unlock(mysql_mutex_t*)"
"kill_delayed_threads_for_table(TABLE_SHARE*)" -> "Table_cache_iterator::Table_cache_iterator(const TABLE_SHARE*)"
"kill_delayed_threads_for_table(TABLE_SHARE*)" -> "inline_mysql_cond_broadcast(mysql_cond_t*)"
"kill_delayed_threads_for_table(TABLE_SHARE*)" -> "Table_cache_manager::assert_owner_all()"
"kill_delayed_threads_for_table(TABLE_SHARE*)" -> "Table_cache_iterator::operator++(int)"
"kill_delayed_threads_for_table(TABLE_SHARE*)" -> "inline_mysql_mutex_lock(mysql_mutex_t*)"
"Table_cache_iterator::Table_cache_iterator(const TABLE_SHARE*)" -> "Table_cache_manager::assert_owner_all()"
"Table_cache_iterator::Table_cache_iterator(const TABLE_SHARE*)" -> "Table_cache_iterator::move_to_next_table()"
"Table_cache_iterator::move_to_next_table()" -> "I>::front() [with T = TABLE,B = I_P_List_adapter<TABLE,&TABLE::cache_next,&TABLE::cache_prev>,C = I_P_List_null_counter,I = I_P_List_no_push_back<TABLE>]"
"Table_cache_iterator::operator++(int)" -> "Table_cache_manager::assert_owner_all()"
"Table_cache_iterator::operator++(int)" -> "L>::I_P_List_iterator(const L&,T*) [with T = TABLE,L = I_P_List<TABLE,I_P_List_adapter<TABLE,&TABLE::cache_next,&TABLE::cache_prev> >]"
"Table_cache_iterator::operator++(int)" -> "Table_cache_iterator::move_to_next_table()"
"Table_cache_iterator::operator++(int)" -> "L>::operator++() [with T = TABLE,L = I_P_List<TABLE,I_P_List_adapter<TABLE,&TABLE::cache_next,&TABLE::cache_prev> >]"
"L>::operator++() [with T = TABLE,L = I_P_List<TABLE,I_P_List_adapter<TABLE,&TABLE::cache_next,&TABLE::cache_prev> >]" -> "prev>::next_ptr(T*) [with T = TABLE,T* T::* next = &TABLE::cache_next,T** T::* prev = &TABLE::cache_prev]"
"Locked_tables_list::reopen_tables(THD*)" -> "Open_table_context::Open_table_context(THD*,uint)"
"Locked_tables_list::reopen_tables(THD*)" -> "mysql_lock_merge(MYSQL_LOCK*,MYSQL_LOCK*)"
"Locked_tables_list::reopen_tables(THD*)" -> "mysql_lock_tables(THD*,TABLE**,uint,uint)"
"Locked_tables_list::reopen_tables(THD*)" -> "Locked_tables_list::unlink_all_closed_tables(THD*,MYSQL_LOCK*,size_t)"
"Locked_tables_list::reopen_tables(THD*)" -> "open_table(THD*,TABLE_LIST*,Open_table_context*)"
"Locked_tables_list::reopen_tables(THD*)" -> "my_error(int,myf,...)"
"Open_table_context::Open_table_context(THD*,uint)" -> "MDL_context::has_locks() const"
"Open_table_context::Open_table_context(THD*,uint)" -> "MDL_context::mdl_savepoint()"
"MDL_context::has_locks() const" -> "I>::is_empty() const [with T = MDL_ticket,B = I_P_List_adapter<MDL_ticket,&MDL_ticket::next_in_context,&MDL_ticket::prev_in_context>,C = I_P_List_null_counter,I = I_P_List_no_push_back<MDL_ticket>]"
"mysql_lock_merge(MYSQL_LOCK*,MYSQL_LOCK*)" -> "my_free(void*)"
"mysql_lock_merge(MYSQL_LOCK*,MYSQL_LOCK*)" -> "memcpy(void*,const void*,size_t)"
"mysql_lock_merge(MYSQL_LOCK*,MYSQL_LOCK*)" -> "my_malloc(size_t,myf)"
"mysql_lock_merge(MYSQL_LOCK*,MYSQL_LOCK*)" -> "thr_lock_merge_status(THR_LOCK_DATA**,uint)"
"mysql_lock_tables(THD*,TABLE**,uint,uint)" -> "lock_external(THD*,TABLE**,uint)"
"mysql_lock_tables(THD*,TABLE**,uint,uint)" -> "reset_lock_data_and_free(MYSQL_LOCK**)"
"mysql_lock_tables(THD*,TABLE**,uint,uint)" -> "THD::enter_stage(const PSI_stage_info*,PSI_stage_info*,const char*,const char*,unsigned int)"
"mysql_lock_tables(THD*,TABLE**,uint,uint)" -> "my_error(int,myf,...)"
"mysql_lock_tables(THD*,TABLE**,uint,uint)" -> "get_lock_data(THD*,TABLE**,uint,uint)"
"mysql_lock_tables(THD*,TABLE**,uint,uint)" -> "memcpy(void*,const void*,size_t)"
"mysql_lock_tables(THD*,TABLE**,uint,uint)" -> "mysql_unlock_tables(THD*,MYSQL_LOCK*)"
"mysql_lock_tables(THD*,TABLE**,uint,uint)" -> "THD::send_kill_message() const"
"mysql_lock_tables(THD*,TABLE**,uint,uint)" -> "THD::set_time_after_lock()"
"mysql_lock_tables(THD*,TABLE**,uint,uint)" -> "unlock_external(THD*,TABLE**,uint)"
"mysql_lock_tables(THD*,TABLE**,uint,uint)" -> "thr_multi_lock(THR_LOCK_DATA**,uint,THR_LOCK_INFO*,ulong)"
"mysql_lock_tables(THD*,TABLE**,uint,uint)" -> "lock_tables_check(THD*,TABLE**,uint,uint)"
"lock_external(THD*,TABLE**,uint)" -> "print_lock_error(int,const char*)"
"lock_external(THD*,TABLE**,uint)" -> "handler::ha_external_lock(THD*,int)"
"reset_lock_data_and_free(MYSQL_LOCK**)" -> "my_free(void*)"
"reset_lock_data_and_free(MYSQL_LOCK**)" -> "reset_lock_data(MYSQL_LOCK*)"
"THD::send_kill_message() const" -> "Diagnostics_area::is_set() const"
"THD::send_kill_message() const" -> "my_message(uint,const char*,myf)"
"THD::send_kill_message() const" -> "_current_thd()"
"THD::send_kill_message() const" -> "THD::get_stmt_da() const"
"THD::send_kill_message() const" -> "THD::killed_errno() const"
"THD::set_time_after_lock()" -> "my_micro_time()"
"lock_tables_check(THD*,TABLE**,uint,uint)" -> "my_error(int,myf,...)"
"lock_tables_check(THD*,TABLE**,uint,uint)" -> "is_log_table_write_query(enum_sql_command)"
"Locked_tables_list::unlink_all_closed_tables(THD*,MYSQL_LOCK*,size_t)" -> "mysql_unlock_tables(THD*,MYSQL_LOCK*)"
"Locked_tables_list::unlink_all_closed_tables(THD*,MYSQL_LOCK*,size_t)" -> "close_thread_table(THD*,TABLE**)"
"open_table(THD*,TABLE_LIST*,Open_table_context*)" -> "get_table_def_key(const TABLE_LIST*,const char**)"
"open_table(THD*,TABLE_LIST*,Open_table_context*)" -> "MDL_context::upgrade_shared_lock(MDL_ticket*,enum_mdl_type,ulong)"
"open_table(THD*,TABLE_LIST*,Open_table_context*)" -> "MDL_deadlock_handler::MDL_deadlock_handler(Open_table_context*)"
"open_table(THD*,TABLE_LIST*,Open_table_context*)" -> "MDL_request::MDL_request()"
"open_table(THD*,TABLE_LIST*,Open_table_context*)" -> "TABLE::init(THD*,TABLE_LIST*)"
"open_table(THD*,TABLE_LIST*,Open_table_context*)" -> "check_and_update_table_version(THD*,TABLE_LIST*,TABLE_SHARE*)"
"open_table(THD*,TABLE_LIST*,Open_table_context*)" -> "my_free(void*)"
"open_table(THD*,TABLE_LIST*,Open_table_context*)" -> "dd_frm_type(THD*,char*,legacy_db_type*)"
"open_table(THD*,TABLE_LIST*,Open_table_context*)" -> "Table_cache::lock()"
"open_table(THD*,TABLE_LIST*,Open_table_context*)" -> "Table_cache::add_used_table(THD*,TABLE*)"
"open_table(THD*,TABLE_LIST*,Open_table_context*)" -> "TABLE_SHARE::has_old_version() const"
"open_table(THD*,TABLE_LIST*,Open_table_context*)" -> "THD::set_open_tables(TABLE*)"
"open_table(THD*,TABLE_LIST*,Open_table_context*)" -> "Open_table_context::set_has_protection_against_grl()"
"open_table(THD*,TABLE_LIST*,Open_table_context*)" -> "TABLE::set_created()"
"open_table(THD*,TABLE_LIST*,Open_table_context*)" -> "my_error(int,myf,...)"
"open_table(THD*,TABLE_LIST*,Open_table_context*)" -> "THD::push_internal_handler(Internal_error_handler*)"
"open_table(THD*,TABLE_LIST*,Open_table_context*)" -> "Open_table_context::get_flags() const"
"open_table(THD*,TABLE_LIST*,Open_table_context*)" -> "THD::is_error() const"
"open_table(THD*,TABLE_LIST*,Open_table_context*)" -> "open_table_get_mdl_lock(THD*,Open_table_context*,MDL_request*,uint,MDL_ticket**)"
"open_table(THD*,TABLE_LIST*,Open_table_context*)" -> "tdc_open_view(THD*,TABLE_LIST*,const char*,const char*,uint,uint)"
"open_table(THD*,TABLE_LIST*,Open_table_context*)" -> "MDL_request::init(MDL_key::enum_mdl_namespace,const char*,const char*,enum_mdl_type,enum_mdl_duration)"
"open_table(THD*,TABLE_LIST*,Open_table_context*)" -> "partition_info::set_partition_bitmaps(TABLE_LIST*)"
"open_table(THD*,TABLE_LIST*,Open_table_context*)" -> "Table_cache_manager::get_cache(THD*)"
"open_table(THD*,TABLE_LIST*,Open_table_context*)" -> "build_table_filename(char*,size_t,const char*,const char*,const char*,uint)"
"open_table(THD*,TABLE_LIST*,Open_table_context*)" -> "check_stack_overrun(THD*,long int,uchar*)"
"open_table(THD*,TABLE_LIST*,Open_table_context*)" -> "mysql_make_view(THD*,TABLE_SHARE*,TABLE_LIST*,bool)"
"open_table(THD*,TABLE_LIST*,Open_table_context*)" -> "inline_mysql_mutex_unlock(mysql_mutex_t*)"
"open_table(THD*,TABLE_LIST*,Open_table_context*)" -> "open_table_entry_fini(THD*,TABLE_SHARE*,TABLE*)"
"open_table(THD*,TABLE_LIST*,Open_table_context*)" -> "my_malloc(size_t,myf)"
"open_table(THD*,TABLE_LIST*,Open_table_context*)" -> "release_table_share(TABLE_SHARE*)"
"open_table(THD*,TABLE_LIST*,Open_table_context*)" -> "Global_read_lock::can_acquire_protection() const"
"open_table(THD*,TABLE_LIST*,Open_table_context*)" -> "memcmp(const void*,const void*,size_t)"
"open_table(THD*,TABLE_LIST*,Open_table_context*)" -> "open_table_from_share(THD*,TABLE_SHARE*,const char*,uint,uint,uint,TABLE*,bool)"
"open_table(THD*,TABLE_LIST*,Open_table_context*)" -> "Open_table_context::has_protection_against_grl() const"
"open_table(THD*,TABLE_LIST*,Open_table_context*)" -> "Open_table_context::get_timeout() const"
"open_table(THD*,TABLE_LIST*,Open_table_context*)" -> "closefrm(TABLE*,bool)"
"open_table(THD*,TABLE_LIST*,Open_table_context*)" -> "MDL_context::acquire_lock(MDL_request*,ulong)"
"open_table(THD*,TABLE_LIST*,Open_table_context*)" -> "Table_cache::release_table(THD*,TABLE*)"
"open_table(THD*,TABLE_LIST*,Open_table_context*)" -> "inline_mysql_mutex_lock(mysql_mutex_t*)"
"open_table(THD*,TABLE_LIST*,Open_table_context*)" -> "check_if_table_exists(THD*,TABLE_LIST*,bool*)"
"open_table(THD*,TABLE_LIST*,Open_table_context*)" -> "Table_cache::unlock()"
"open_table(THD*,TABLE_LIST*,Open_table_context*)" -> "Open_table_context::request_backoff_action(Open_table_context::enum_open_table_action,TABLE_LIST*)"
"open_table(THD*,TABLE_LIST*,Open_table_context*)" -> "MDL_context::is_lock_owner(MDL_key::enum_mdl_namespace,const char*,const char*,enum_mdl_type)"
"open_table(THD*,TABLE_LIST*,Open_table_context*)" -> "my_calc_hash(const HASH*,const uchar*,size_t)"
"open_table(THD*,TABLE_LIST*,Open_table_context*)" -> "THD::pop_internal_handler()"
"open_table(THD*,TABLE_LIST*,Open_table_context*)" -> "get_table_share_with_discover(THD*,TABLE_LIST*,const char*,uint,uint,int*,my_hash_value_type)"
"open_table(THD*,TABLE_LIST*,Open_table_context*)" -> "Table_cache::get_table(THD*,my_hash_value_type,const char*,uint,TABLE_SHARE**)"
"open_table(THD*,TABLE_LIST*,Open_table_context*)" -> "tdc_wait_for_old_version(THD*,const char*,const char*,ulong,uint)"
"get_table_def_key(const TABLE_LIST*,const char**)" -> "MDL_key::ptr() const"
"get_table_def_key(const TABLE_LIST*,const char**)" -> "MDL_key::length() const"
"MDL_deadlock_handler::MDL_deadlock_handler(Open_table_context*)" -> "Internal_error_handler::Internal_error_handler()"
"TABLE::init(THD*,TABLE_LIST*)" -> "TABLE::clear_column_bitmaps()"
"TABLE::init(THD*,TABLE_LIST*)" -> "memcpy(void*,const void*,size_t)"
"TABLE::init(THD*,TABLE_LIST*)" -> "my_realloc(void*,size_t,myf)"
"TABLE::init(THD*,TABLE_LIST*)" -> "strcmp(const char*,const char*)"
"TABLE::init(THD*,TABLE_LIST*)" -> "strlen(const char*)"
"TABLE::init(THD*,TABLE_LIST*)" -> "LEX::need_correct_ident()"
"TABLE::clear_column_bitmaps()" -> "memset(void*,int,size_t)"
"TABLE::clear_column_bitmaps()" -> "TABLE::column_bitmaps_set(MY_BITMAP*,MY_BITMAP*)"
"check_and_update_table_version(THD*,TABLE_LIST*,TABLE_SHARE*)" -> "Open_tables_state::get_reprepare_observer() const"
"check_and_update_table_version(THD*,TABLE_LIST*,TABLE_SHARE*)" -> "TABLE_LIST::is_table_ref_id_equal(TABLE_SHARE*) const"
"check_and_update_table_version(THD*,TABLE_LIST*,TABLE_SHARE*)" -> "TABLE_LIST::set_table_ref_id(TABLE_SHARE*)"
"check_and_update_table_version(THD*,TABLE_LIST*,TABLE_SHARE*)" -> "Reprepare_observer::report_error(THD*)"
"Open_tables_state::get_reprepare_observer() const" -> "Dynamic_array<Elem>::back() const [with Elem = Reprepare_observer*]"
"Open_tables_state::get_reprepare_observer() const" -> "Dynamic_array<Elem>::elements() const [with Elem = Reprepare_observer*]"
"TABLE_LIST::is_table_ref_id_equal(TABLE_SHARE*) const" -> "TABLE_SHARE::get_table_ref_version() const"
"TABLE_LIST::is_table_ref_id_equal(TABLE_SHARE*) const" -> "TABLE_SHARE::get_table_ref_type() const"
"TABLE_SHARE::get_table_ref_version() const" -> "Table_id::id() const"
"TABLE_LIST::set_table_ref_id(TABLE_SHARE*)" -> "TABLE_SHARE::get_table_ref_version() const"
"TABLE_LIST::set_table_ref_id(TABLE_SHARE*)" -> "TABLE_SHARE::get_table_ref_type() const"
"TABLE_LIST::set_table_ref_id(TABLE_SHARE*)" -> "TABLE_LIST::set_table_ref_id(enum_table_ref_type,ulonglong)"
"Reprepare_observer::report_error(THD*)" -> "THD::get_stmt_da()"
"Reprepare_observer::report_error(THD*)" -> "Diagnostics_area::set_error_status(uint)"
"Diagnostics_area::set_error_status(uint)" -> "_current_thd()"
"Diagnostics_area::set_error_status(uint)" -> "Diagnostics_area::set_error_status(uint,const char*,const char*,const Sql_condition*)"
"Diagnostics_area::set_error_status(uint)" -> "mysql_errno_to_sqlstate(unsigned int)"
"dd_frm_type(THD*,char*,legacy_db_type*)" -> "inline_mysql_file_open(const char*,int,myf)"
"dd_frm_type(THD*,char*,legacy_db_type*)" -> "inline_mysql_file_read(File,uchar*,size_t,myf)"
"dd_frm_type(THD*,char*,legacy_db_type*)" -> "inline_mysql_file_close(File,myf)"
"dd_frm_type(THD*,char*,legacy_db_type*)" -> "strncmp(const char*,const char*,size_t)"
"Table_cache::add_used_table(THD*,TABLE*)" -> "Table_cache::assert_owner()"
"Table_cache::add_used_table(THD*,TABLE*)" -> "Table_cache_element::Table_cache_element(TABLE_SHARE*)"
"Table_cache::add_used_table(THD*,TABLE*)" -> "Table_cache::free_unused_tables_if_necessary(THD*)"
"Table_cache::add_used_table(THD*,TABLE*)" -> "my_hash_insert(HASH*,const uchar*)"
"Table_cache::add_used_table(THD*,TABLE*)" -> "Table_cache_manager::cache_index(Table_cache*) const"
"Table_cache::add_used_table(THD*,TABLE*)" -> "I>::push_front(T*) [with T = TABLE,B = I_P_List_adapter<TABLE,&TABLE::cache_next,&TABLE::cache_prev>,C = I_P_List_null_counter,I = I_P_List_no_push_back<TABLE>]"
"Table_cache_element::Table_cache_element(TABLE_SHARE*)" -> "I>::I_P_List() [with T = TABLE,B = I_P_List_adapter<TABLE,&TABLE::cache_next,&TABLE::cache_prev>,C = I_P_List_null_counter,I = I_P_List_no_push_back<TABLE>]"
"I>::I_P_List() [with T = TABLE,B = I_P_List_adapter<TABLE,&TABLE::cache_next,&TABLE::cache_prev>,C = I_P_List_null_counter,I = I_P_List_no_push_back<TABLE>]" -> "I_P_List_no_push_back<T>::I_P_List_no_push_back(T**) [with T = TABLE]"
"I>::I_P_List() [with T = TABLE,B = I_P_List_adapter<TABLE,&TABLE::cache_next,&TABLE::cache_prev>,C = I_P_List_null_counter,I = I_P_List_no_push_back<TABLE>]" -> "I_P_List_null_counter::I_P_List_null_counter()"
"THD::set_open_tables(TABLE*)" -> "inline_mysql_mutex_unlock(mysql_mutex_t*)"
"THD::set_open_tables(TABLE*)" -> "inline_mysql_mutex_lock(mysql_mutex_t*)"
"open_table_get_mdl_lock(THD*,Open_table_context*,MDL_request*,uint,MDL_ticket**)" -> "THD::push_internal_handler(Internal_error_handler*)"
"open_table_get_mdl_lock(THD*,Open_table_context*,MDL_request*,uint,MDL_ticket**)" -> "MDL_deadlock_handler::MDL_deadlock_handler(Open_table_context*)"
"open_table_get_mdl_lock(THD*,Open_table_context*,MDL_request*,uint,MDL_ticket**)" -> "MDL_key::name() const"
"open_table_get_mdl_lock(THD*,Open_table_context*,MDL_request*,uint,MDL_ticket**)" -> "Open_table_context::can_recover_from_failed_open() const"
"open_table_get_mdl_lock(THD*,Open_table_context*,MDL_request*,uint,MDL_ticket**)" -> "MDL_request::init(const MDL_key*,enum_mdl_type,enum_mdl_duration)"
"open_table_get_mdl_lock(THD*,Open_table_context*,MDL_request*,uint,MDL_ticket**)" -> "my_error(int,myf,...)"
"open_table_get_mdl_lock(THD*,Open_table_context*,MDL_request*,uint,MDL_ticket**)" -> "MDL_request::MDL_request()"
"open_table_get_mdl_lock(THD*,Open_table_context*,MDL_request*,uint,MDL_ticket**)" -> "MDL_context::try_acquire_lock(MDL_request*)"
"open_table_get_mdl_lock(THD*,Open_table_context*,MDL_request*,uint,MDL_ticket**)" -> "Open_table_context::get_timeout() const"
"open_table_get_mdl_lock(THD*,Open_table_context*,MDL_request*,uint,MDL_ticket**)" -> "MDL_key::db_name() const"
"open_table_get_mdl_lock(THD*,Open_table_context*,MDL_request*,uint,MDL_ticket**)" -> "THD::pop_internal_handler()"
"open_table_get_mdl_lock(THD*,Open_table_context*,MDL_request*,uint,MDL_ticket**)" -> "MDL_context::acquire_lock(MDL_request*,ulong)"
"MDL_context::try_acquire_lock(MDL_request*)" -> "MDL_ticket::destroy(MDL_ticket*)"
"MDL_context::try_acquire_lock(MDL_request*)" -> "MDL_context::try_acquire_lock_impl(MDL_request*,MDL_ticket**)"
"MDL_context::try_acquire_lock(MDL_request*)" -> "inline_mysql_prlock_unlock(mysql_prlock_t*)"
"tdc_open_view(THD*,TABLE_LIST*,const char*,const char*,uint,uint)" -> "get_table_share(THD*,TABLE_LIST*,const char*,uint,uint,int*,my_hash_value_type)"
"tdc_open_view(THD*,TABLE_LIST*,const char*,const char*,uint,uint)" -> "my_error(int,myf,...)"
"tdc_open_view(THD*,TABLE_LIST*,const char*,const char*,uint,uint)" -> "inline_mysql_mutex_unlock(mysql_mutex_t*)"
"tdc_open_view(THD*,TABLE_LIST*,const char*,const char*,uint,uint)" -> "check_and_update_table_version(THD*,TABLE_LIST*,TABLE_SHARE*)"
"tdc_open_view(THD*,TABLE_LIST*,const char*,const char*,uint,uint)" -> "mysql_make_view(THD*,TABLE_SHARE*,TABLE_LIST*,bool)"
"tdc_open_view(THD*,TABLE_LIST*,const char*,const char*,uint,uint)" -> "my_calc_hash(const HASH*,const uchar*,size_t)"
"tdc_open_view(THD*,TABLE_LIST*,const char*,const char*,uint,uint)" -> "release_table_share(TABLE_SHARE*)"
"tdc_open_view(THD*,TABLE_LIST*,const char*,const char*,uint,uint)" -> "inline_mysql_mutex_lock(mysql_mutex_t*)"
"get_table_share(THD*,TABLE_LIST*,const char*,uint,uint,int*,my_hash_value_type)" -> "my_hash_delete(HASH*,uchar*)"
"get_table_share(THD*,TABLE_LIST*,const char*,uint,uint,int*,my_hash_value_type)" -> "open_table_error(TABLE_SHARE*,int,int,int)"
"get_table_share(THD*,TABLE_LIST*,const char*,uint,uint,int*,my_hash_value_type)" -> "my_hash_insert(HASH*,const uchar*)"
"get_table_share(THD*,TABLE_LIST*,const char*,uint,uint,int*,my_hash_value_type)" -> "free_table_share(TABLE_SHARE*)"
"get_table_share(THD*,TABLE_LIST*,const char*,uint,uint,int*,my_hash_value_type)" -> "alloc_table_share(TABLE_LIST*,const char*,uint)"
"get_table_share(THD*,TABLE_LIST*,const char*,uint,uint,int*,my_hash_value_type)" -> "assign_new_table_id(TABLE_SHARE*)"
"get_table_share(THD*,TABLE_LIST*,const char*,uint,uint,int*,my_hash_value_type)" -> "my_hash_search_using_hash_value(const HASH*,my_hash_value_type,const uchar*,size_t)"
"get_table_share(THD*,TABLE_LIST*,const char*,uint,uint,int*,my_hash_value_type)" -> "open_table_def(THD*,TABLE_SHARE*,uint)"
"open_table_error(TABLE_SHARE*,int,int,int)" -> "get_charset_name(uint)"
"open_table_error(TABLE_SHARE*,int,int,int)" -> "my_strerror(char*,size_t,int)"
"open_table_error(TABLE_SHARE*,int,int,int)" -> "my_error(int,myf,...)"
"open_table_error(TABLE_SHARE*,int,int,int)" -> "_current_thd()"
"open_table_error(TABLE_SHARE*,int,int,int)" -> "TABLE_SHARE::db_type() const"
"open_table_error(TABLE_SHARE*,int,int,int)" -> "File_parser::type() const"
"open_table_error(TABLE_SHARE*,int,int,int)" -> "get_new_handler(TABLE_SHARE*,MEM_ROOT*,handlerton*)"
"open_table_error(TABLE_SHARE*,int,int,int)" -> "my_snprintf(char*,size_t,const char*,...)"
"open_table_error(TABLE_SHARE*,int,int,int)" -> "my_printf_error(uint,const char*,myf,...)"
"open_table_error(TABLE_SHARE*,int,int,int)" -> "strxmov(char*,const char*,...)"
"alloc_table_share(TABLE_LIST*,const char*,uint)" -> "multi_alloc_root(MEM_ROOT*,...)"
"alloc_table_share(TABLE_LIST*,const char*,uint)" -> "TABLE_SHARE::set_table_cache_key(char*,const char*,uint)"
"alloc_table_share(TABLE_LIST*,const char*,uint)" -> "__builtin_strcpy(char*,const char*)"
"alloc_table_share(TABLE_LIST*,const char*,uint)" -> "I>::empty() [with T = Wait_for_flush,B = I_P_List_adapter<Wait_for_flush,&Wait_for_flush::next_in_share,&Wait_for_flush::prev_in_share>,C = I_P_List_null_counter,I = I_P_List_no_push_back<Wait_for_flush>]"
"alloc_table_share(TABLE_LIST*,const char*,uint)" -> "init_sql_alloc(MEM_ROOT*,uint,uint)"
"alloc_table_share(TABLE_LIST*,const char*,uint)" -> "build_table_filename(char*,size_t,const char*,const char*,const char*,uint)"
"alloc_table_share(TABLE_LIST*,const char*,uint)" -> "inline_mysql_mutex_init(mysql_mutex_t*,const pthread_mutexattr_t*)"
"alloc_table_share(TABLE_LIST*,const char*,uint)" -> "memset(void*,int,size_t)"
"alloc_table_share(TABLE_LIST*,const char*,uint)" -> "Table_id::operator=(ulonglong)"
"TABLE_SHARE::set_table_cache_key(char*,const char*,uint)" -> "TABLE_SHARE::set_table_cache_key(char*,uint)"
"TABLE_SHARE::set_table_cache_key(char*,const char*,uint)" -> "memcpy(void*,const void*,size_t)"
"TABLE_SHARE::set_table_cache_key(char*,uint)" -> "strlen(const char*)"
"I>::empty() [with T = Wait_for_flush,B = I_P_List_adapter<Wait_for_flush,&Wait_for_flush::next_in_share,&Wait_for_flush::prev_in_share>,C = I_P_List_null_counter,I = I_P_List_no_push_back<Wait_for_flush>]" -> "I_P_List_null_counter::reset()"
"I>::empty() [with T = Wait_for_flush,B = I_P_List_adapter<Wait_for_flush,&Wait_for_flush::next_in_share,&Wait_for_flush::prev_in_share>,C = I_P_List_null_counter,I = I_P_List_no_push_back<Wait_for_flush>]" -> "I_P_List_no_push_back<T>::set_last(T**) [with T = Wait_for_flush]"
"build_table_filename(char*,size_t,const char*,const char*,const char*,uint)" -> "build_table_filename(char*,size_t,const char*,const char*,const char*,uint,bool*)"
"build_table_filename(char*,size_t,const char*,const char*,const char*,uint,bool*)" -> "tablename_to_filename(const char*,char*,uint)"
"build_table_filename(char*,size_t,const char*,const char*,const char*,uint,bool*)" -> "memcmp(const void*,const void*,size_t)"
"build_table_filename(char*,size_t,const char*,const char*,const char*,uint,bool*)" -> "strnmov(char*,const char*,size_t)"
"build_table_filename(char*,size_t,const char*,const char*,const char*,uint,bool*)" -> "strlen(const char*)"
"build_table_filename(char*,size_t,const char*,const char*,const char*,uint,bool*)" -> "strxnmov(char*,size_t,const char*,...)"
"tablename_to_filename(const char*,char*,uint)" -> "memcpy(void*,const void*,size_t)"
"tablename_to_filename(const char*,char*,uint)" -> "check_if_legal_tablename(const char*)"
"tablename_to_filename(const char*,char*,uint)" -> "strconvert(CHARSET_INFO*,const char*,CHARSET_INFO*,char*,uint,uint*)"
"tablename_to_filename(const char*,char*,uint)" -> "check_table_name(const char*,size_t,bool)"
"tablename_to_filename(const char*,char*,uint)" -> "check_n_cut_mysql50_prefix(const char*,char*,uint)"
"check_n_cut_mysql50_prefix(const char*,char*,uint)" -> "strmake(char*,const char*,size_t)"
"check_n_cut_mysql50_prefix(const char*,char*,uint)" -> "check_mysql50_prefix(const char*)"
"check_mysql50_prefix(const char*)" -> "strncmp(const char*,const char*,size_t)"
"assign_new_table_id(TABLE_SHARE*)" -> "Table_id::operator++(int)"
"assign_new_table_id(TABLE_SHARE*)" -> "Table_id::operator=(const Table_id&)"
"Table_id::operator++(int)" -> "Table_id::Table_id(ulonglong)"
"open_table_def(THD*,TABLE_SHARE*,uint)" -> "pthread_getspecific(pthread_key_t)"
"open_table_def(THD*,TABLE_SHARE*,uint)" -> "inline_mysql_file_close(File,myf)"
"open_table_def(THD*,TABLE_SHARE*,uint)" -> "_my_thread_var()"
"open_table_def(THD*,TABLE_SHARE*,uint)" -> "sql_parse_prepare(const LEX_STRING*,MEM_ROOT*,bool)"
"open_table_def(THD*,TABLE_SHARE*,uint)" -> "has_disabled_path_chars(const char*)"
"open_table_def(THD*,TABLE_SHARE*,uint)" -> "inline_mysql_file_read(File,uchar*,size_t,myf)"
"open_table_def(THD*,TABLE_SHARE*,uint)" -> "inline_mysql_file_open(const char*,int,myf)"
"open_table_def(THD*,TABLE_SHARE*,uint)" -> "File_parser::type() const"
"open_table_def(THD*,TABLE_SHARE*,uint)" -> "strxmov(char*,const char*,...)"
"open_table_def(THD*,TABLE_SHARE*,uint)" -> "memcmp(const void*,const void*,size_t)"
"open_table_def(THD*,TABLE_SHARE*,uint)" -> "strlen(const char*)"
"open_table_def(THD*,TABLE_SHARE*,uint)" -> "open_table_error(TABLE_SHARE*,int,int,int)"
"open_table_def(THD*,TABLE_SHARE*,uint)" -> "is_equal(const LEX_STRING*,const LEX_STRING*)"
"open_table_def(THD*,TABLE_SHARE*,uint)" -> "get_table_category(const LEX_STRING*,const LEX_STRING*)"
"open_table_def(THD*,TABLE_SHARE*,uint)" -> "__builtin_strcpy(char*,const char*)"
"open_table_def(THD*,TABLE_SHARE*,uint)" -> "strncmp(const char*,const char*,size_t)"
"open_table_def(THD*,TABLE_SHARE*,uint)" -> "open_binary_frm(THD*,TABLE_SHARE*,uchar*,File)"
"open_table_def(THD*,TABLE_SHARE*,uint)" -> "strxnmov(char*,size_t,const char*,...)"
"open_table_def(THD*,TABLE_SHARE*,uint)" -> "unpack_filename(char*,const char*)"
"sql_parse_prepare(const LEX_STRING*,MEM_ROOT*,bool)" -> "inline_mysql_file_read(File,uchar*,size_t,myf)"
"sql_parse_prepare(const LEX_STRING*,MEM_ROOT*,bool)" -> "inline_mysql_file_stat(const char*,stat*,myf)"
"sql_parse_prepare(const LEX_STRING*,MEM_ROOT*,bool)" -> "File_parser::File_parser()"
"sql_parse_prepare(const LEX_STRING*,MEM_ROOT*,bool)" -> "my_error(int,myf,...)"
"sql_parse_prepare(const LEX_STRING*,MEM_ROOT*,bool)" -> "inline_mysql_file_open(const char*,int,myf)"
"sql_parse_prepare(const LEX_STRING*,MEM_ROOT*,bool)" -> "inline_mysql_file_close(File,myf)"
"sql_parse_prepare(const LEX_STRING*,MEM_ROOT*,bool)" -> "alloc_root(MEM_ROOT*,size_t)"
"inline_mysql_file_stat(const char*,stat*,myf)" -> "my_stat(const char*,stat*,myf)"
"File_parser::File_parser()" -> "Sql_alloc::Sql_alloc()"
"is_equal(const LEX_STRING*,const LEX_STRING*)" -> "strncmp(const char*,const char*,size_t)"
"get_table_category(const LEX_STRING*,const LEX_STRING*)" -> "is_system_table_name(const char*,uint)"
"get_table_category(const LEX_STRING*,const LEX_STRING*)" -> "is_infoschema_db(const char*,size_t)"
"open_binary_frm(THD*,TABLE_SHARE*,uchar*,File)" -> "plugin_unlock(THD*,plugin_ref)"
"open_binary_frm(THD*,TABLE_SHARE*,uchar*,File)" -> "handler::ha_table_flags() const"
"open_binary_frm(THD*,TABLE_SHARE*,uchar*,File)" -> "ha_checktype(THD*,legacy_db_type,bool,bool)"
"open_binary_frm(THD*,TABLE_SHARE*,uchar*,File)" -> "fix_type_pointers(const char***,TYPELIB*,uint,char**)"
"open_binary_frm(THD*,TABLE_SHARE*,uchar*,File)" -> "ha_legacy_type(const handlerton*)"
"open_binary_frm(THD*,TABLE_SHARE*,uchar*,File)" -> "unhex_type2(TYPELIB*)"
"open_binary_frm(THD*,TABLE_SHARE*,uchar*,File)" -> "TABLE_SHARE::db_type() const"
"open_binary_frm(THD*,TABLE_SHARE*,uchar*,File)" -> "my_decimal_precision_to_length(uint,uint8,bool)"
"open_binary_frm(THD*,TABLE_SHARE*,uchar*,File)" -> "inline_mysql_file_pread(File,uchar*,size_t,my_off_t,myf)"
"open_binary_frm(THD*,TABLE_SHARE*,uchar*,File)" -> "Field::null_offset(const uchar*) const"
"open_binary_frm(THD*,TABLE_SHARE*,uchar*,File)" -> "Bitmap<64u>::is_set(uint) const"
"open_binary_frm(THD*,TABLE_SHARE*,uchar*,File)" -> "push_warning_printf(THD*,Sql_condition::enum_warning_level,uint,const char*,...)"
"open_binary_frm(THD*,TABLE_SHARE*,uchar*,File)" -> "KEY_PART_INFO::init_flags()"
"open_binary_frm(THD*,TABLE_SHARE*,uchar*,File)" -> "ha_resolve_by_name(THD*,const LEX_STRING*,bool)"
"open_binary_frm(THD*,TABLE_SHARE*,uchar*,File)" -> "get_charset_by_csname(const char*,uint,myf)"
"open_binary_frm(THD*,TABLE_SHARE*,uchar*,File)" -> "my_hash_free(HASH*)"
"open_binary_frm(THD*,TABLE_SHARE*,uchar*,File)" -> "plugin_lock_by_name(THD*,const LEX_STRING*,int)"
"open_binary_frm(THD*,TABLE_SHARE*,uchar*,File)" -> "find_field(Field**,uchar*,uint,uint)"
"open_binary_frm(THD*,TABLE_SHARE*,uchar*,File)" -> "plugin_is_ready(const LEX_STRING*,int)"
"open_binary_frm(THD*,TABLE_SHARE*,uchar*,File)" -> "strmake_root(MEM_ROOT*,const char*,size_t)"
"open_binary_frm(THD*,TABLE_SHARE*,uchar*,File)" -> "bitmap_init(MY_BITMAP*,my_bitmap_map*,uint,my_bool)"
"open_binary_frm(THD*,TABLE_SHARE*,uchar*,File)" -> "ha_lock_engine(THD*,const handlerton*)"
"open_binary_frm(THD*,TABLE_SHARE*,uchar*,File)" -> "open_table_error(TABLE_SHARE*,int,int,int)"
"open_binary_frm(THD*,TABLE_SHARE*,uchar*,File)" -> "strncmp(const char*,const char*,size_t)"
"open_binary_frm(THD*,TABLE_SHARE*,uchar*,File)" -> "_my_hash_init(HASH*,uint,CHARSET_INFO*,my_hash_function,ulong,size_t,size_t,my_hash_get_key,void (*)(void*),uint)"
"open_binary_frm(THD*,TABLE_SHARE*,uchar*,File)" -> "Field::real_maybe_null() const"
"open_binary_frm(THD*,TABLE_SHARE*,uchar*,File)" -> "Field::set_column_format(column_format_type)"
"open_binary_frm(THD*,TABLE_SHARE*,uchar*,File)" -> "alloc_root(MEM_ROOT*,size_t)"
"open_binary_frm(THD*,TABLE_SHARE*,uchar*,File)" -> "my_hash_insert(HASH*,const uchar*)"
"open_binary_frm(THD*,TABLE_SHARE*,uchar*,File)" -> "find_type(const char*,const TYPELIB*,unsigned int)"
"open_binary_frm(THD*,TABLE_SHARE*,uchar*,File)" -> "inline_mysql_file_seek(File,my_off_t,int,myf)"
"open_binary_frm(THD*,TABLE_SHARE*,uchar*,File)" -> "strlen(const char*)"
"open_binary_frm(THD*,TABLE_SHARE*,uchar*,File)" -> "my_malloc(size_t,myf)"
"open_binary_frm(THD*,TABLE_SHARE*,uchar*,File)" -> "Bitmap<64u>::init(uint)"
"open_binary_frm(THD*,TABLE_SHARE*,uchar*,File)" -> "my_error(int,myf,...)"
"open_binary_frm(THD*,TABLE_SHARE*,uchar*,File)" -> "_my_thread_var()"
"open_binary_frm(THD*,TABLE_SHARE*,uchar*,File)" -> "make_field(TABLE_SHARE*,uchar*,uint32,uchar*,uchar,uint,enum_field_types,const CHARSET_INFO*,Field::geometry_type,Field::utype,TYPELIB*,const char*,MEM_ROOT*)"
"open_binary_frm(THD*,TABLE_SHARE*,uchar*,File)" -> "plugin_lock(THD*,st_plugin_int**)"
"open_binary_frm(THD*,TABLE_SHARE*,uchar*,File)" -> "read_string(File,uchar**,size_t)"
"open_binary_frm(THD*,TABLE_SHARE*,uchar*,File)" -> "my_free(void*)"
"open_binary_frm(THD*,TABLE_SHARE*,uchar*,File)" -> "get_new_handler(TABLE_SHARE*,MEM_ROOT*,handlerton*)"
"open_binary_frm(THD*,TABLE_SHARE*,uchar*,File)" -> "get_charset(uint,myf)"
"open_binary_frm(THD*,TABLE_SHARE*,uchar*,File)" -> "memdup_root(MEM_ROOT*,const void*,size_t)"
"open_binary_frm(THD*,TABLE_SHARE*,uchar*,File)" -> "__builtin_stpcpy(char*,const char*)"
"open_binary_frm(THD*,TABLE_SHARE*,uchar*,File)" -> "sql_print_error(const char*,...)"
"open_binary_frm(THD*,TABLE_SHARE*,uchar*,File)" -> "ha_check_storage_engine_flag(const handlerton*,uint32)"
"open_binary_frm(THD*,TABLE_SHARE*,uchar*,File)" -> "get_form_pos(File,uchar*)"
"open_binary_frm(THD*,TABLE_SHARE*,uchar*,File)" -> "sql_print_warning(const char*,...)"
"open_binary_frm(THD*,TABLE_SHARE*,uchar*,File)" -> "setup_key_part_field(TABLE_SHARE*,handler*,uint,KEY*,uint,uint,uint*)"
"open_binary_frm(THD*,TABLE_SHARE*,uchar*,File)" -> "find_ref_key(KEY*,uint,uchar*,Field*,uint*,uint*)"
"open_binary_frm(THD*,TABLE_SHARE*,uchar*,File)" -> "inline_mysql_file_read(File,uchar*,size_t,myf)"
"open_binary_frm(THD*,TABLE_SHARE*,uchar*,File)" -> "memcpy(void*,const void*,size_t)"
"open_binary_frm(THD*,TABLE_SHARE*,uchar*,File)" -> "add_pk_parts_to_sk(KEY*,uint,KEY*,uint,TABLE_SHARE*,handler*,uint*)"
"open_binary_frm(THD*,TABLE_SHARE*,uchar*,File)" -> "memset(void*,int,size_t)"
"open_binary_frm(THD*,TABLE_SHARE*,uchar*,File)" -> "Field::set_storage_type(ha_storage_media)"
"ha_checktype(THD*,legacy_db_type,bool,bool)" -> "ha_resolve_storage_engine_name(const handlerton*)"
"ha_checktype(THD*,legacy_db_type,bool,bool)" -> "ha_storage_engine_is_enabled(const handlerton*)"
"ha_checktype(THD*,legacy_db_type,bool,bool)" -> "Delegate::is_empty()"
"ha_checktype(THD*,legacy_db_type,bool,bool)" -> "ha_resolve_by_legacy_type(THD*,legacy_db_type)"
"ha_checktype(THD*,legacy_db_type,bool,bool)" -> "Trans_delegate::after_rollback(THD*,bool)"
"ha_checktype(THD*,legacy_db_type,bool,bool)" -> "ha_default_handlerton(THD*)"
"ha_checktype(THD*,legacy_db_type,bool,bool)" -> "my_error(int,myf,...)"
"ha_resolve_by_legacy_type(THD*,legacy_db_type)" -> "ha_default_handlerton(THD*)"
"ha_resolve_by_legacy_type(THD*,legacy_db_type)" -> "ha_lock_engine(THD*,const handlerton*)"
"Trans_delegate::after_rollback(THD*,bool)" -> "delete_dynamic(DYNAMIC_ARRAY*)"
"Trans_delegate::after_rollback(THD*,bool)" -> "init_dynamic_array2(DYNAMIC_ARRAY*,uint,void*,uint,uint)"
"Trans_delegate::after_rollback(THD*,bool)" -> "insert_dynamic(DYNAMIC_ARRAY*,const void*)"
"Trans_delegate::after_rollback(THD*,bool)" -> "Delegate::observer_info_iter()"
"Trans_delegate::after_rollback(THD*,bool)" -> "THD::get_trans_fixed_pos(const char**,my_off_t*) const"
"Trans_delegate::after_rollback(THD*,bool)" -> "Delegate::read_lock()"
"Trans_delegate::after_rollback(THD*,bool)" -> "Delegate::unlock()"
"Trans_delegate::after_rollback(THD*,bool)" -> "sql_print_error(const char*,...)"
"Trans_delegate::after_rollback(THD*,bool)" -> "plugin_lock(THD*,st_plugin_int**)"
"Trans_delegate::after_rollback(THD*,bool)" -> "List_iterator<T>::operator++(int) [with T = Observer_info]"
"Trans_delegate::after_rollback(THD*,bool)" -> "plugin_unlock_list(THD*,st_plugin_int**,uint)"
"fix_type_pointers(const char***,TYPELIB*,uint,char**)" -> "strchr(char*,int)"
"strchr(char*,int)" -> "__builtin_strchr(const char*,int)"
"unhex_type2(TYPELIB*)" -> "hexchar_to_int(char)"
"my_decimal_precision_to_length(uint,uint8,bool)" -> "my_decimal_precision_to_length_no_truncation(uint,uint8,bool)"
"inline_mysql_file_pread(File,uchar*,size_t,my_off_t,myf)" -> "my_pread(File,uchar*,size_t,my_off_t,myf)"
"push_warning_printf(THD*,Sql_condition::enum_warning_level,uint,const char*,...)" -> "push_warning(THD*,Sql_condition::enum_warning_level,uint,const char*)"
"push_warning_printf(THD*,Sql_condition::enum_warning_level,uint,const char*,...)" -> "__builtin_va_end(__va_list_tag*)"
"push_warning_printf(THD*,Sql_condition::enum_warning_level,uint,const char*,...)" -> "__builtin_va_start(__va_list_tag*,...)"
"push_warning_printf(THD*,Sql_condition::enum_warning_level,uint,const char*,...)" -> "my_vsnprintf_ex(const CHARSET_INFO*,char*,size_t,const char*,__va_list_tag*)"
"ha_resolve_by_name(THD*,const LEX_STRING*,bool)" -> "ha_default_plugin(THD*)"
"ha_resolve_by_name(THD*,const LEX_STRING*,bool)" -> "ha_default_temp_plugin(THD*)"
"ha_resolve_by_name(THD*,const LEX_STRING*,bool)" -> "plugin_unlock(THD*,plugin_ref)"
"ha_resolve_by_name(THD*,const LEX_STRING*,bool)" -> "plugin_lock_by_name(THD*,const LEX_STRING*,int)"
"ha_default_temp_plugin(THD*)" -> "plugin_lock(THD*,st_plugin_int**)"
"plugin_lock_by_name(THD*,const LEX_STRING*,int)" -> "plugin_find_internal(const LEX_STRING*,int)"
"plugin_lock_by_name(THD*,const LEX_STRING*,int)" -> "inline_mysql_mutex_lock(mysql_mutex_t*)"
"plugin_lock_by_name(THD*,const LEX_STRING*,int)" -> "intern_plugin_lock(LEX*,plugin_ref)"
"plugin_lock_by_name(THD*,const LEX_STRING*,int)" -> "inline_mysql_mutex_unlock(mysql_mutex_t*)"
"plugin_find_internal(const LEX_STRING*,int)" -> "my_hash_search(const HASH*,const uchar*,size_t)"
"find_field(Field**,uchar*,uint,uint)" -> "Field::offset(uchar*)"
"plugin_is_ready(const LEX_STRING*,int)" -> "plugin_status(const LEX_STRING*,int)"
"plugin_status(const LEX_STRING*,int)" -> "inline_mysql_mutex_lock(mysql_mutex_t*)"
"plugin_status(const LEX_STRING*,int)" -> "plugin_find_internal(const LEX_STRING*,int)"
"plugin_status(const LEX_STRING*,int)" -> "inline_mysql_mutex_unlock(mysql_mutex_t*)"
"Bitmap<64u>::init(uint)" -> "Bitmap<64u>::set_prefix(uint)"
"Bitmap<64u>::set_prefix(uint)" -> "Bitmap<64u>::length() const"
"Bitmap<64u>::set_prefix(uint)" -> "Bitmap<64u>::set_all()"
"make_field(TABLE_SHARE*,uchar*,uint32,uchar*,uchar,uint,enum_field_types,const CHARSET_INFO*,Field::geometry_type,Field::utype,TYPELIB*,const char*,MEM_ROOT*)" -> "Field_timestamp::Field_timestamp(uchar*,uint32,uchar*,uchar,Field::utype,const char*)"
"make_field(TABLE_SHARE*,uchar*,uint32,uchar*,uchar,uint,enum_field_types,const CHARSET_INFO*,Field::geometry_type,Field::utype,TYPELIB*,const char*,MEM_ROOT*)" -> "Field_geom::Field_geom(uchar*,uchar*,uint,Field::utype,const char*,TABLE_SHARE*,uint,Field::geometry_type)"
"make_field(TABLE_SHARE*,uchar*,uint32,uchar*,uchar,uint,enum_field_types,const CHARSET_INFO*,Field::geometry_type,Field::utype,TYPELIB*,const char*,MEM_ROOT*)" -> "is_temporal_real_type(enum_field_types)"
"make_field(TABLE_SHARE*,uchar*,uint32,uchar*,uchar,uint,enum_field_types,const CHARSET_INFO*,Field::geometry_type,Field::utype,TYPELIB*,const char*,MEM_ROOT*)" -> "Field_set::Field_set(uchar*,uint32,uchar*,uchar,Field::utype,const char*,uint32,TYPELIB*,const CHARSET_INFO*)"
"make_field(TABLE_SHARE*,uchar*,uint32,uchar*,uchar,uint,enum_field_types,const CHARSET_INFO*,Field::geometry_type,Field::utype,TYPELIB*,const char*,MEM_ROOT*)" -> "Field_new_decimal::Field_new_decimal(uchar*,uint32,uchar*,uchar,Field::utype,const char*,uint8,bool,bool)"
"make_field(TABLE_SHARE*,uchar*,uint32,uchar*,uchar,uint,enum_field_types,const CHARSET_INFO*,Field::geometry_type,Field::utype,TYPELIB*,const char*,MEM_ROOT*)" -> "Field_enum::Field_enum(uchar*,uint32,uchar*,uchar,Field::utype,const char*,uint,TYPELIB*,const CHARSET_INFO*)"
"make_field(TABLE_SHARE*,uchar*,uint32,uchar*,uchar,uint,enum_field_types,const CHARSET_INFO*,Field::geometry_type,Field::utype,TYPELIB*,const char*,MEM_ROOT*)" -> "Field_long::Field_long(uchar*,uint32,uchar*,uchar,Field::utype,const char*,bool,bool)"
"make_field(TABLE_SHARE*,uchar*,uint32,uchar*,uchar,uint,enum_field_types,const CHARSET_INFO*,Field::geometry_type,Field::utype,TYPELIB*,const char*,MEM_ROOT*)" -> "Field_float::Field_float(uchar*,uint32,uchar*,uchar,Field::utype,const char*,uint8,bool,bool)"
"make_field(TABLE_SHARE*,uchar*,uint32,uchar*,uchar,uint,enum_field_types,const CHARSET_INFO*,Field::geometry_type,Field::utype,TYPELIB*,const char*,MEM_ROOT*)" -> "Field_newdate::Field_newdate(uchar*,uchar*,uchar,Field::utype,const char*)"
"make_field(TABLE_SHARE*,uchar*,uint32,uchar*,uchar,uint,enum_field_types,const CHARSET_INFO*,Field::geometry_type,Field::utype,TYPELIB*,const char*,MEM_ROOT*)" -> "calc_pack_length(enum_field_types,uint32)"
"make_field(TABLE_SHARE*,uchar*,uint32,uchar*,uchar,uint,enum_field_types,const CHARSET_INFO*,Field::geometry_type,Field::utype,TYPELIB*,const char*,MEM_ROOT*)" -> "Field_string::Field_string(uchar*,uint32,uchar*,uchar,Field::utype,const char*,const CHARSET_INFO*)"
"make_field(TABLE_SHARE*,uchar*,uint32,uchar*,uchar,uint,enum_field_types,const CHARSET_INFO*,Field::geometry_type,Field::utype,TYPELIB*,const char*,MEM_ROOT*)" -> "Field_blob::Field_blob(uchar*,uchar*,uchar,Field::utype,const char*,TABLE_SHARE*,uint,const CHARSET_INFO*)"
"make_field(TABLE_SHARE*,uchar*,uint32,uchar*,uchar,uint,enum_field_types,const CHARSET_INFO*,Field::geometry_type,Field::utype,TYPELIB*,const char*,MEM_ROOT*)" -> "Field_double::Field_double(uchar*,uint32,uchar*,uchar,Field::utype,const char*,uint8,bool,bool)"
"make_field(TABLE_SHARE*,uchar*,uint32,uchar*,uchar,uint,enum_field_types,const CHARSET_INFO*,Field::geometry_type,Field::utype,TYPELIB*,const char*,MEM_ROOT*)" -> "_current_thd()"
"make_field(TABLE_SHARE*,uchar*,uint32,uchar*,uchar,uint,enum_field_types,const CHARSET_INFO*,Field::geometry_type,Field::utype,TYPELIB*,const char*,MEM_ROOT*)" -> "Field_short::Field_short(uchar*,uint32,uchar*,uchar,Field::utype,const char*,bool,bool)"
"make_field(TABLE_SHARE*,uchar*,uint32,uchar*,uchar,uint,enum_field_types,const CHARSET_INFO*,Field::geometry_type,Field::utype,TYPELIB*,const char*,MEM_ROOT*)" -> "Field_varstring::Field_varstring(uchar*,uint32,uint,uchar*,uchar,Field::utype,const char*,TABLE_SHARE*,const CHARSET_INFO*)"
"make_field(TABLE_SHARE*,uchar*,uint32,uchar*,uchar,uint,enum_field_types,const CHARSET_INFO*,Field::geometry_type,Field::utype,TYPELIB*,const char*,MEM_ROOT*)" -> "Field_bit::Field_bit(uchar*,uint32,uchar*,uchar,uchar*,uchar,Field::utype,const char*)"
"make_field(TABLE_SHARE*,uchar*,uint32,uchar*,uchar,uint,enum_field_types,const CHARSET_INFO*,Field::geometry_type,Field::utype,TYPELIB*,const char*,MEM_ROOT*)" -> "Field_longlong::Field_longlong(uchar*,uint32,uchar*,uchar,Field::utype,const char*,bool,bool)"
"make_field(TABLE_SHARE*,uchar*,uint32,uchar*,uchar,uint,enum_field_types,const CHARSET_INFO*,Field::geometry_type,Field::utype,TYPELIB*,const char*,MEM_ROOT*)" -> "Field_bit_as_char::Field_bit_as_char(uchar*,uint32,uchar*,uchar,Field::utype,const char*)"
"make_field(TABLE_SHARE*,uchar*,uint32,uchar*,uchar,uint,enum_field_types,const CHARSET_INFO*,Field::geometry_type,Field::utype,TYPELIB*,const char*,MEM_ROOT*)" -> "Field_timestampf::Field_timestampf(uchar*,uchar*,uchar,Field::utype,const char*,uint8)"
"make_field(TABLE_SHARE*,uchar*,uint32,uchar*,uchar,uint,enum_field_types,const CHARSET_INFO*,Field::geometry_type,Field::utype,TYPELIB*,const char*,MEM_ROOT*)" -> "Field_tiny::Field_tiny(uchar*,uint32,uchar*,uchar,Field::utype,const char*,bool,bool)"
"make_field(TABLE_SHARE*,uchar*,uint32,uchar*,uchar,uint,enum_field_types,const CHARSET_INFO*,Field::geometry_type,Field::utype,TYPELIB*,const char*,MEM_ROOT*)" -> "Field_timef::Field_timef(uchar*,uchar*,uchar,Field::utype,const char*,uint8)"
"make_field(TABLE_SHARE*,uchar*,uint32,uchar*,uchar,uint,enum_field_types,const CHARSET_INFO*,Field::geometry_type,Field::utype,TYPELIB*,const char*,MEM_ROOT*)" -> "Field_time::Field_time(uchar*,uchar*,uchar,Field::utype,const char*)"
"make_field(TABLE_SHARE*,uchar*,uint32,uchar*,uchar,uint,enum_field_types,const CHARSET_INFO*,Field::geometry_type,Field::utype,TYPELIB*,const char*,MEM_ROOT*)" -> "Field_null::Field_null(uchar*,uint32,Field::utype,const char*,const CHARSET_INFO*)"
"make_field(TABLE_SHARE*,uchar*,uint32,uchar*,uchar,uint,enum_field_types,const CHARSET_INFO*,Field::geometry_type,Field::utype,TYPELIB*,const char*,MEM_ROOT*)" -> "Field_datetime::Field_datetime(uchar*,uchar*,uchar,Field::utype,const char*)"
"make_field(TABLE_SHARE*,uchar*,uint32,uchar*,uchar,uint,enum_field_types,const CHARSET_INFO*,Field::geometry_type,Field::utype,TYPELIB*,const char*,MEM_ROOT*)" -> "Field_medium::Field_medium(uchar*,uint32,uchar*,uchar,Field::utype,const char*,bool,bool)"
"make_field(TABLE_SHARE*,uchar*,uint32,uchar*,uchar,uint,enum_field_types,const CHARSET_INFO*,Field::geometry_type,Field::utype,TYPELIB*,const char*,MEM_ROOT*)" -> "Field_year::Field_year(uchar*,uint32,uchar*,uchar,Field::utype,const char*)"
"make_field(TABLE_SHARE*,uchar*,uint32,uchar*,uchar,uint,enum_field_types,const CHARSET_INFO*,Field::geometry_type,Field::utype,TYPELIB*,const char*,MEM_ROOT*)" -> "Field_datetimef::Field_datetimef(uchar*,uchar*,uchar,Field::utype,const char*,uint8)"
"make_field(TABLE_SHARE*,uchar*,uint32,uchar*,uchar,uint,enum_field_types,const CHARSET_INFO*,Field::geometry_type,Field::utype,TYPELIB*,const char*,MEM_ROOT*)" -> "Field_decimal::Field_decimal(uchar*,uint32,uchar*,uchar,Field::utype,const char*,uint8,bool,bool)"
"Field_timestamp::Field_timestamp(uchar*,uint32,uchar*,uchar,Field::utype,const char*)" -> "Field_temporal_with_date_and_time::Field_temporal_with_date_and_time(uchar*,uchar*,uchar,Field::utype,const char*,uint8)"
"Field_timestamp::Field_timestamp(uchar*,uint32,uchar*,uchar,Field::utype,const char*)" -> "Field_temporal_with_date_and_time::init_timestamp_flags()"
"Field_temporal_with_date_and_time::Field_temporal_with_date_and_time(uchar*,uchar*,uchar,Field::utype,const char*,uint8)" -> "Field_temporal_with_date::Field_temporal_with_date(uchar*,uchar*,uchar,Field::utype,const char*,uint8,uint8)"
"Field_temporal_with_date::Field_temporal_with_date(uchar*,uchar*,uchar,Field::utype,const char*,uint8,uint8)" -> "Field_temporal::Field_temporal(uchar*,uchar*,uchar,Field::utype,const char*,uint32,uint8)"
"Field_temporal::Field_temporal(uchar*,uchar*,uchar,Field::utype,const char*,uint32,uint8)" -> "Field::Field(uchar*,uint32,uchar*,uchar,Field::utype,const char*)"
"Field_temporal::Field_temporal(uchar*,uchar*,uchar,Field::utype,const char*,uint32,uint8)" -> "Field_temporal::normalize_dec(uint8)"
"Field::Field(uchar*,uint32,uchar*,uchar,Field::utype,const char*)" -> "Bitmap<64u>::Bitmap()"
"Bitmap<64u>::Bitmap()" -> "Bitmap<64u>::init()"
"Bitmap<64u>::init()" -> "Bitmap<64u>::clear_all()"
"Field_geom::Field_geom(uchar*,uchar*,uint,Field::utype,const char*,TABLE_SHARE*,uint,Field::geometry_type)" -> "Field_blob::Field_blob(uchar*,uchar*,uchar,Field::utype,const char*,TABLE_SHARE*,uint,const CHARSET_INFO*)"
"Field_blob::Field_blob(uchar*,uchar*,uchar,Field::utype,const char*,TABLE_SHARE*,uint,const CHARSET_INFO*)" -> "Field_longstr::Field_longstr(uchar*,uint32,uchar*,uchar,Field::utype,const char*,const CHARSET_INFO*)"
"Field_blob::Field_blob(uchar*,uchar*,uchar,Field::utype,const char*,TABLE_SHARE*,uint,const CHARSET_INFO*)" -> "String::String()"
"Field_longstr::Field_longstr(uchar*,uint32,uchar*,uchar,Field::utype,const char*,const CHARSET_INFO*)" -> "Field_str::Field_str(uchar*,uint32,uchar*,uchar,Field::utype,const char*,const CHARSET_INFO*)"
"Field_str::Field_str(uchar*,uint32,uchar*,uchar,Field::utype,const char*,const CHARSET_INFO*)" -> "Field::Field(uchar*,uint32,uchar*,uchar,Field::utype,const char*)"
"is_temporal_real_type(enum_field_types)" -> "is_temporal_type(enum_field_types)"
"Field_set::Field_set(uchar*,uint32,uchar*,uchar,Field::utype,const char*,uint32,TYPELIB*,const CHARSET_INFO*)" -> "String::String(const char*,uint32,const CHARSET_INFO*)"
"Field_set::Field_set(uchar*,uint32,uchar*,uchar,Field::utype,const char*,uint32,TYPELIB*,const CHARSET_INFO*)" -> "Field_enum::Field_enum(uchar*,uint32,uchar*,uchar,Field::utype,const char*,uint,TYPELIB*,const CHARSET_INFO*)"
"Field_enum::Field_enum(uchar*,uint32,uchar*,uchar,Field::utype,const char*,uint,TYPELIB*,const CHARSET_INFO*)" -> "Field_str::Field_str(uchar*,uint32,uchar*,uchar,Field::utype,const char*,const CHARSET_INFO*)"
"Field_new_decimal::Field_new_decimal(uchar*,uint32,uchar*,uchar,Field::utype,const char*,uint8,bool,bool)" -> "Field_num::Field_num(uchar*,uint32,uchar*,uchar,Field::utype,const char*,uint8,bool,bool)"
"Field_new_decimal::Field_new_decimal(uchar*,uint32,uchar*,uchar,Field::utype,const char*,uint8,bool,bool)" -> "my_decimal_get_binary_size(uint,uint)"
"Field_new_decimal::Field_new_decimal(uchar*,uint32,uchar*,uchar,Field::utype,const char*,uint8,bool,bool)" -> "my_decimal_length_to_precision(uint,uint,bool)"
"Field_num::Field_num(uchar*,uint32,uchar*,uchar,Field::utype,const char*,uint8,bool,bool)" -> "Field::Field(uchar*,uint32,uchar*,uchar,Field::utype,const char*)"
"my_decimal_get_binary_size(uint,uint)" -> "decimal_bin_size(int,int)"
"Field_long::Field_long(uchar*,uint32,uchar*,uchar,Field::utype,const char*,bool,bool)" -> "Field_num::Field_num(uchar*,uint32,uchar*,uchar,Field::utype,const char*,uint8,bool,bool)"
"Field_float::Field_float(uchar*,uint32,uchar*,uchar,Field::utype,const char*,uint8,bool,bool)" -> "Field_real::Field_real(uchar*,uint32,uchar*,uchar,Field::utype,const char*,uint8,bool,bool)"
"Field_real::Field_real(uchar*,uint32,uchar*,uchar,Field::utype,const char*,uint8,bool,bool)" -> "Field_num::Field_num(uchar*,uint32,uchar*,uchar,Field::utype,const char*,uint8,bool,bool)"
"Field_newdate::Field_newdate(uchar*,uchar*,uchar,Field::utype,const char*)" -> "Field_temporal_with_date::Field_temporal_with_date(uchar*,uchar*,uchar,Field::utype,const char*,uint8,uint8)"
"calc_pack_length(enum_field_types,uint32)" -> "my_time_binary_length(uint)"
"calc_pack_length(enum_field_types,uint32)" -> "abort()"
"calc_pack_length(enum_field_types,uint32)" -> "my_datetime_binary_length(uint)"
"calc_pack_length(enum_field_types,uint32)" -> "my_timestamp_binary_length(uint)"
"Field_string::Field_string(uchar*,uint32,uchar*,uchar,Field::utype,const char*,const CHARSET_INFO*)" -> "Field_longstr::Field_longstr(uchar*,uint32,uchar*,uchar,Field::utype,const char*,const CHARSET_INFO*)"
"Field_double::Field_double(uchar*,uint32,uchar*,uchar,Field::utype,const char*,uint8,bool,bool)" -> "Field_real::Field_real(uchar*,uint32,uchar*,uchar,Field::utype,const char*,uint8,bool,bool)"
"Field_short::Field_short(uchar*,uint32,uchar*,uchar,Field::utype,const char*,bool,bool)" -> "Field_num::Field_num(uchar*,uint32,uchar*,uchar,Field::utype,const char*,uint8,bool,bool)"
"Field_varstring::Field_varstring(uchar*,uint32,uint,uchar*,uchar,Field::utype,const char*,TABLE_SHARE*,const CHARSET_INFO*)" -> "Field_longstr::Field_longstr(uchar*,uint32,uchar*,uchar,Field::utype,const char*,const CHARSET_INFO*)"
"Field_bit::Field_bit(uchar*,uint32,uchar*,uchar,uchar*,uchar,Field::utype,const char*)" -> "Field::Field(uchar*,uint32,uchar*,uchar,Field::utype,const char*)"
"Field_longlong::Field_longlong(uchar*,uint32,uchar*,uchar,Field::utype,const char*,bool,bool)" -> "Field_num::Field_num(uchar*,uint32,uchar*,uchar,Field::utype,const char*,uint8,bool,bool)"
"Field_bit_as_char::Field_bit_as_char(uchar*,uint32,uchar*,uchar,Field::utype,const char*)" -> "Field_bit::Field_bit(uchar*,uint32,uchar*,uchar,uchar*,uchar,Field::utype,const char*)"
"Field_timestampf::Field_timestampf(uchar*,uchar*,uchar,Field::utype,const char*,uint8)" -> "Field_temporal_with_date_and_timef::Field_temporal_with_date_and_timef(uchar*,uchar*,uchar,Field::utype,const char*,uint8)"
"Field_timestampf::Field_timestampf(uchar*,uchar*,uchar,Field::utype,const char*,uint8)" -> "Field_temporal_with_date_and_time::init_timestamp_flags()"
"Field_temporal_with_date_and_timef::Field_temporal_with_date_and_timef(uchar*,uchar*,uchar,Field::utype,const char*,uint8)" -> "Field_temporal_with_date_and_time::Field_temporal_with_date_and_time(uchar*,uchar*,uchar,Field::utype,const char*,uint8)"
"Field_tiny::Field_tiny(uchar*,uint32,uchar*,uchar,Field::utype,const char*,bool,bool)" -> "Field_num::Field_num(uchar*,uint32,uchar*,uchar,Field::utype,const char*,uint8,bool,bool)"
"Field_timef::Field_timef(uchar*,uchar*,uchar,Field::utype,const char*,uint8)" -> "Field_time_common::Field_time_common(uchar*,uchar*,uchar,Field::utype,const char*,uint8)"
"Field_time_common::Field_time_common(uchar*,uchar*,uchar,Field::utype,const char*,uint8)" -> "Field_temporal::Field_temporal(uchar*,uchar*,uchar,Field::utype,const char*,uint32,uint8)"
"Field_time::Field_time(uchar*,uchar*,uchar,Field::utype,const char*)" -> "Field_time_common::Field_time_common(uchar*,uchar*,uchar,Field::utype,const char*,uint8)"
"Field_null::Field_null(uchar*,uint32,Field::utype,const char*,const CHARSET_INFO*)" -> "Field_str::Field_str(uchar*,uint32,uchar*,uchar,Field::utype,const char*,const CHARSET_INFO*)"
"Field_datetime::Field_datetime(uchar*,uchar*,uchar,Field::utype,const char*)" -> "Field_temporal_with_date_and_time::Field_temporal_with_date_and_time(uchar*,uchar*,uchar,Field::utype,const char*,uint8)"
"Field_medium::Field_medium(uchar*,uint32,uchar*,uchar,Field::utype,const char*,bool,bool)" -> "Field_num::Field_num(uchar*,uint32,uchar*,uchar,Field::utype,const char*,uint8,bool,bool)"
"Field_year::Field_year(uchar*,uint32,uchar*,uchar,Field::utype,const char*)" -> "Field_tiny::Field_tiny(uchar*,uint32,uchar*,uchar,Field::utype,const char*,bool,bool)"
"Field_datetimef::Field_datetimef(uchar*,uchar*,uchar,Field::utype,const char*,uint8)" -> "Field_temporal_with_date_and_timef::Field_temporal_with_date_and_timef(uchar*,uchar*,uchar,Field::utype,const char*,uint8)"
"Field_decimal::Field_decimal(uchar*,uint32,uchar*,uchar,Field::utype,const char*,uint8,bool,bool)" -> "Field_real::Field_real(uchar*,uint32,uchar*,uchar,Field::utype,const char*,uint8,bool,bool)"
"read_string(File,uchar**,size_t)" -> "inline_mysql_file_read(File,uchar*,size_t,myf)"
"read_string(File,uchar**,size_t)" -> "my_free(void*)"
"read_string(File,uchar**,size_t)" -> "my_malloc(size_t,myf)"
"get_form_pos(File,uchar*)" -> "inline_mysql_file_seek(File,my_off_t,int,myf)"
"get_form_pos(File,uchar*)" -> "my_malloc(size_t,myf)"
"get_form_pos(File,uchar*)" -> "my_free(void*)"
"get_form_pos(File,uchar*)" -> "inline_mysql_file_read(File,uchar*,size_t,myf)"
"setup_key_part_field(TABLE_SHARE*,handler*,uint,KEY*,uint,uint,uint*)" -> "Bitmap<64u>::set_bit(uint)"
"find_ref_key(KEY*,uint,uchar*,Field*,uint*,uint*)" -> "Field::offset(uchar*)"
"add_pk_parts_to_sk(KEY*,uint,KEY*,uint,TABLE_SHARE*,handler*,uint*)" -> "setup_key_part_field(TABLE_SHARE*,handler*,uint,KEY*,uint,uint,uint*)"
"mysql_make_view(THD*,TABLE_SHARE*,TABLE_LIST*,bool)" -> "TABLE_LIST::prepare_security(THD*)"
"mysql_make_view(THD*,TABLE_SHARE*,TABLE_LIST*,bool)" -> "st_select_lex_node::include_down(st_select_lex_node*)"
"mysql_make_view(THD*,TABLE_SHARE*,TABLE_LIST*,bool)" -> "List<T>::List() [with T = TABLE_LIST]"
"mysql_make_view(THD*,TABLE_SHARE*,TABLE_LIST*,bool)" -> "Query_tables_list::get_stmt_unsafe_flags() const"
"mysql_make_view(THD*,TABLE_SHARE*,TABLE_LIST*,bool)" -> "memset(void*,int,size_t)"
"mysql_make_view(THD*,TABLE_SHARE*,TABLE_LIST*,bool)" -> "LEX::can_be_merged()"
"mysql_make_view(THD*,TABLE_SHARE*,TABLE_LIST*,bool)" -> "Name_resolution_context::resolve_in_table_list_only(TABLE_LIST*)"
"mysql_make_view(THD*,TABLE_SHARE*,TABLE_LIST*,bool)" -> "mysql_opt_change_db(THD*,const LEX_STRING*,LEX_STRING*,bool,bool*)"
"mysql_make_view(THD*,TABLE_SHARE*,TABLE_LIST*,bool)" -> "__builtin_memcpy(void*,const void*,long unsigned int)"
"mysql_make_view(THD*,TABLE_SHARE*,TABLE_LIST*,bool)" -> "THD::restore_active_arena(Query_arena*,Query_arena*)"
"mysql_make_view(THD*,TABLE_SHARE*,TABLE_LIST*,bool)" -> "LEX::set_trg_event_type_for_tables()"
"mysql_make_view(THD*,TABLE_SHARE*,TABLE_LIST*,bool)" -> "List<T>::head() [with T = Index_hint]"
"mysql_make_view(THD*,TABLE_SHARE*,TABLE_LIST*,bool)" -> "is_explainable_query(enum_sql_command)"
"mysql_make_view(THD*,TABLE_SHARE*,TABLE_LIST*,bool)" -> "check_table_access(THD*,ulong,TABLE_LIST*,bool,uint,bool)"
"mysql_make_view(THD*,TABLE_SHARE*,TABLE_LIST*,bool)" -> "Opt_trace_struct::add_utf8(const char*,const char*)"
"mysql_make_view(THD*,TABLE_SHARE*,TABLE_LIST*,bool)" -> "Opt_trace_struct::add(const char*,bool)"
"mysql_make_view(THD*,TABLE_SHARE*,TABLE_LIST*,bool)" -> "Query_tables_list::set_stmt_unsafe_flags(uint32)"
"mysql_make_view(THD*,TABLE_SHARE*,TABLE_LIST*,bool)" -> "Opt_trace_object::Opt_trace_object(Opt_trace_context*,const char*,Opt_trace_context::feature_value)"
"mysql_make_view(THD*,TABLE_SHARE*,TABLE_LIST*,bool)" -> "base_list::empty()"
"mysql_make_view(THD*,TABLE_SHARE*,TABLE_LIST*,bool)" -> "LEX::get_effective_with_check(TABLE_LIST*)"
"mysql_make_view(THD*,TABLE_SHARE*,TABLE_LIST*,bool)" -> "parse_sql(THD*,Parser_state*,Object_creation_ctx*)"
"mysql_make_view(THD*,TABLE_SHARE*,TABLE_LIST*,bool)" -> "st_select_lex_unit::next_unit()"
"mysql_make_view(THD*,TABLE_SHARE*,TABLE_LIST*,bool)" -> "List_iterator_fast<T>::operator++(int) [with T = TABLE_LIST]"
"mysql_make_view(THD*,TABLE_SHARE*,TABLE_LIST*,bool)" -> "st_select_lex_unit::is_union()"
"mysql_make_view(THD*,TABLE_SHARE*,TABLE_LIST*,bool)" -> "st_select_lex::first_inner_unit()"
"mysql_make_view(THD*,TABLE_SHARE*,TABLE_LIST*,bool)" -> "Query_arena::calloc(size_t)"
"mysql_make_view(THD*,TABLE_SHARE*,TABLE_LIST*,bool)" -> "Parser_state::Parser_state()"
"mysql_make_view(THD*,TABLE_SHARE*,TABLE_LIST*,bool)" -> "lex_end(LEX*)"
"mysql_make_view(THD*,TABLE_SHARE*,TABLE_LIST*,bool)" -> "push_warning_printf(THD*,Sql_condition::enum_warning_level,uint,const char*,...)"
"mysql_make_view(THD*,TABLE_SHARE*,TABLE_LIST*,bool)" -> "my_message(uint,const char*,myf)"
"mysql_make_view(THD*,TABLE_SHARE*,TABLE_LIST*,bool)" -> "lex_start(THD*)"
"mysql_make_view(THD*,TABLE_SHARE*,TABLE_LIST*,bool)" -> "View_creation_ctx::create(THD*,TABLE_LIST*)"
"mysql_make_view(THD*,TABLE_SHARE*,TABLE_LIST*,bool)" -> "TABLE_LIST::top_table()"
"mysql_make_view(THD*,TABLE_SHARE*,TABLE_LIST*,bool)" -> "TABLE_LIST::TABLE_LIST()"
"mysql_make_view(THD*,TABLE_SHARE*,TABLE_LIST*,bool)" -> "List_iterator_fast<T>::rewind() [with T = TABLE_LIST]"
"mysql_make_view(THD*,TABLE_SHARE*,TABLE_LIST*,bool)" -> "Query_arena::Query_arena()"
"mysql_make_view(THD*,TABLE_SHARE*,TABLE_LIST*,bool)" -> "repoint_contexts_of_join_nests(List<TABLE_LIST>,SELECT_LEX*,SELECT_LEX*)"
"mysql_make_view(THD*,TABLE_SHARE*,TABLE_LIST*,bool)" -> "opt_trace_disable_if_no_view_access(THD*,TABLE_LIST*,TABLE_LIST*)"
"mysql_make_view(THD*,TABLE_SHARE*,TABLE_LIST*,bool)" -> "LEX::can_not_use_merged()"
"mysql_make_view(THD*,TABLE_SHARE*,TABLE_LIST*,bool)" -> "File_parser::parse(uchar*,MEM_ROOT*,File_option*,uint,Unknown_key_hook*) const"
"mysql_make_view(THD*,TABLE_SHARE*,TABLE_LIST*,bool)" -> "_current_thd()"
"mysql_make_view(THD*,TABLE_SHARE*,TABLE_LIST*,bool)" -> "st_lex_local::st_lex_local()"
"mysql_make_view(THD*,TABLE_SHARE*,TABLE_LIST*,bool)" -> "Parser_state::init(THD*,char*,unsigned int)"
"mysql_make_view(THD*,TABLE_SHARE*,TABLE_LIST*,bool)" -> "List<T>::push_back(T*) [with T = TABLE_LIST]"
"mysql_make_view(THD*,TABLE_SHARE*,TABLE_LIST*,bool)" -> "Opt_trace_struct::add_utf8(const char*,const char*,size_t)"
"mysql_make_view(THD*,TABLE_SHARE*,TABLE_LIST*,bool)" -> "mysql_change_db(THD*,const LEX_STRING*,bool)"
"mysql_make_view(THD*,TABLE_SHARE*,TABLE_LIST*,bool)" -> "Opt_trace_struct::add(const char*,uint)"
"mysql_make_view(THD*,TABLE_SHARE*,TABLE_LIST*,bool)" -> "List_iterator_fast<T>::List_iterator_fast(List<T>&) [with T = TABLE_LIST]"
"mysql_make_view(THD*,TABLE_SHARE*,TABLE_LIST*,bool)" -> "MDL_request::set_type(enum_mdl_type)"
"mysql_make_view(THD*,TABLE_SHARE*,TABLE_LIST*,bool)" -> "List<T>::List(const List<T>&) [with T = TABLE_LIST]"
"mysql_make_view(THD*,TABLE_SHARE*,TABLE_LIST*,bool)" -> "get_default_definer(THD*,LEX_USER*)"
"mysql_make_view(THD*,TABLE_SHARE*,TABLE_LIST*,bool)" -> "LEX::can_use_merged()"
"mysql_make_view(THD*,TABLE_SHARE*,TABLE_LIST*,bool)" -> "THD::set_n_backup_active_arena(Query_arena*,Query_arena*)"
"mysql_make_view(THD*,TABLE_SHARE*,TABLE_LIST*,bool)" -> "SQL_I_List<T>::push_back(SQL_I_List<T>*) [with T = st_order]"
"mysql_make_view(THD*,TABLE_SHARE*,TABLE_LIST*,bool)" -> "my_error(int,myf,...)"
"mysql_make_view(THD*,TABLE_SHARE*,TABLE_LIST*,bool)" -> "Query_arena::is_conventional() const"
"mysql_make_view(THD*,TABLE_SHARE*,TABLE_LIST*,bool)" -> "st_select_lex::get_table_list()"
"mysql_make_view(THD*,TABLE_SHARE*,TABLE_LIST*,bool)" -> "Opt_trace_object::Opt_trace_object(Opt_trace_context*,Opt_trace_context::feature_value)"
"mysql_make_view(THD*,TABLE_SHARE*,TABLE_LIST*,bool)" -> "st_select_lex::next_select_in_list()"
"TABLE_LIST::prepare_security(THD*)" -> "List_iterator_fast<T>::List_iterator_fast(List<T>&) [with T = TABLE_LIST]"
"TABLE_LIST::prepare_security(THD*)" -> "List_iterator_fast<T>::operator++(int) [with T = TABLE_LIST]"
"List_iterator_fast<T>::List_iterator_fast(List<T>&) [with T = TABLE_LIST]" -> "base_list_iterator::base_list_iterator(base_list&)"
"List_iterator_fast<T>::operator++(int) [with T = TABLE_LIST]" -> "base_list_iterator::next_fast()"
"LEX::can_be_merged()" -> "st_select_lex::next_select()"
"LEX::can_be_merged()" -> "Item_subselect::place()"
"LEX::can_be_merged()" -> "st_select_lex_unit::first_select()"
"LEX::can_be_merged()" -> "st_select_lex::first_inner_unit()"
"LEX::can_be_merged()" -> "st_select_lex_unit::next_unit()"
"mysql_opt_change_db(THD*,const LEX_STRING*,LEX_STRING*,bool,bool*)" -> "cmp_db_names(const char*,const char*)"
"mysql_opt_change_db(THD*,const LEX_STRING*,LEX_STRING*,bool,bool*)" -> "backup_current_db_name(THD*,LEX_STRING*)"
"mysql_opt_change_db(THD*,const LEX_STRING*,LEX_STRING*,bool,bool*)" -> "mysql_change_db(THD*,const LEX_STRING*,bool)"
"backup_current_db_name(THD*,LEX_STRING*)" -> "strmake(char*,const char*,size_t)"
"mysql_change_db(THD*,const LEX_STRING*,bool)" -> "my_message(uint,const char*,myf)"
"mysql_change_db(THD*,const LEX_STRING*,bool)" -> "_current_thd()"
"mysql_change_db(THD*,const LEX_STRING*,bool)" -> "get_default_db_collation(THD*,const char*)"
"mysql_change_db(THD*,const LEX_STRING*,bool)" -> "push_warning_printf(THD*,Sql_condition::enum_warning_level,uint,const char*,...)"
"mysql_change_db(THD*,const LEX_STRING*,bool)" -> "my_free(void*)"
"mysql_change_db(THD*,const LEX_STRING*,bool)" -> "mysql_change_db_impl(THD*,LEX_STRING*,ulong,const CHARSET_INFO*)"
"mysql_change_db(THD*,const LEX_STRING*,bool)" -> "my_error(int,myf,...)"
"mysql_change_db(THD*,const LEX_STRING*,bool)" -> "my_strndup(const char*,size_t,myf)"
"mysql_change_db(THD*,const LEX_STRING*,bool)" -> "check_and_convert_db_name(LEX_STRING*,bool)"
"mysql_change_db(THD*,const LEX_STRING*,bool)" -> "is_infoschema_db(const char*,size_t)"
"mysql_change_db(THD*,const LEX_STRING*,bool)" -> "check_db_dir_existence(const char*)"
"get_default_db_collation(THD*,const char*)" -> "st_ha_create_information::st_ha_create_information()"
"get_default_db_collation(THD*,const char*)" -> "load_db_opt_by_name(THD*,const char*,HA_CREATE_INFO*)"
"get_default_db_collation(THD*,const char*)" -> "strcmp(const char*,const char*)"
"load_db_opt_by_name(THD*,const char*,HA_CREATE_INFO*)" -> "load_db_opt(THD*,const char*,HA_CREATE_INFO*)"
"load_db_opt_by_name(THD*,const char*,HA_CREATE_INFO*)" -> "build_table_filename(char*,size_t,const char*,const char*,const char*,uint)"
"load_db_opt(THD*,const char*,HA_CREATE_INFO*)" -> "init_io_cache(IO_CACHE*,File,size_t,cache_type,my_off_t,pbool,myf)"
"load_db_opt(THD*,const char*,HA_CREATE_INFO*)" -> "memset(void*,int,size_t)"
"load_db_opt(THD*,const char*,HA_CREATE_INFO*)" -> "_current_thd()"
"load_db_opt(THD*,const char*,HA_CREATE_INFO*)" -> "put_dbopt(const char*,HA_CREATE_INFO*)"
"load_db_opt(THD*,const char*,HA_CREATE_INFO*)" -> "inline_mysql_file_open(const char*,int,myf)"
"load_db_opt(THD*,const char*,HA_CREATE_INFO*)" -> "get_charset_by_csname(const char*,uint,myf)"
"load_db_opt(THD*,const char*,HA_CREATE_INFO*)" -> "my_b_gets(IO_CACHE*,char*,size_t)"
"load_db_opt(THD*,const char*,HA_CREATE_INFO*)" -> "inline_mysql_file_close(File,myf)"
"load_db_opt(THD*,const char*,HA_CREATE_INFO*)" -> "end_io_cache(IO_CACHE*)"
"load_db_opt(THD*,const char*,HA_CREATE_INFO*)" -> "strchr(char*,int)"
"load_db_opt(THD*,const char*,HA_CREATE_INFO*)" -> "get_dbopt(const char*,HA_CREATE_INFO*)"
"load_db_opt(THD*,const char*,HA_CREATE_INFO*)" -> "strncmp(const char*,const char*,size_t)"
"load_db_opt(THD*,const char*,HA_CREATE_INFO*)" -> "sql_print_error(const char*,...)"
"load_db_opt(THD*,const char*,HA_CREATE_INFO*)" -> "get_charset_by_name(const char*,myf)"
"put_dbopt(const char*,HA_CREATE_INFO*)" -> "my_hash_insert(HASH*,const uchar*)"
"put_dbopt(const char*,HA_CREATE_INFO*)" -> "__builtin_strcpy(char*,const char*)"
"put_dbopt(const char*,HA_CREATE_INFO*)" -> "my_multi_malloc(myf,...)"
"put_dbopt(const char*,HA_CREATE_INFO*)" -> "inline_mysql_rwlock_unlock(mysql_rwlock_t*)"
"put_dbopt(const char*,HA_CREATE_INFO*)" -> "strlen(const char*)"
"put_dbopt(const char*,HA_CREATE_INFO*)" -> "my_free(void*)"
"put_dbopt(const char*,HA_CREATE_INFO*)" -> "inline_mysql_rwlock_wrlock(mysql_rwlock_t*)"
"put_dbopt(const char*,HA_CREATE_INFO*)" -> "my_hash_search(const HASH*,const uchar*,size_t)"
"get_dbopt(const char*,HA_CREATE_INFO*)" -> "inline_mysql_rwlock_unlock(mysql_rwlock_t*)"
"get_dbopt(const char*,HA_CREATE_INFO*)" -> "my_hash_search(const HASH*,const uchar*,size_t)"
"get_dbopt(const char*,HA_CREATE_INFO*)" -> "inline_mysql_rwlock_rdlock(mysql_rwlock_t*)"
"get_dbopt(const char*,HA_CREATE_INFO*)" -> "strlen(const char*)"
"mysql_change_db_impl(THD*,LEX_STRING*,ulong,const CHARSET_INFO*)" -> "THD::set_db(const char*,size_t)"
"mysql_change_db_impl(THD*,LEX_STRING*,ulong,const CHARSET_INFO*)" -> "inline_mysql_mutex_lock(mysql_mutex_t*)"
"mysql_change_db_impl(THD*,LEX_STRING*,ulong,const CHARSET_INFO*)" -> "my_free(void*)"
"mysql_change_db_impl(THD*,LEX_STRING*,ulong,const CHARSET_INFO*)" -> "THD::reset_db(char*,size_t)"
"mysql_change_db_impl(THD*,LEX_STRING*,ulong,const CHARSET_INFO*)" -> "inline_mysql_mutex_unlock(mysql_mutex_t*)"
"THD::set_db(const char*,size_t)" -> "inline_mysql_mutex_lock(mysql_mutex_t*,const char*,uint)"
"THD::set_db(const char*,size_t)" -> "my_strndup(const char*,size_t,myf)"
"THD::set_db(const char*,size_t)" -> "memcpy(void*,const void*,size_t)"
"THD::set_db(const char*,size_t)" -> "my_free(void*)"
"THD::set_db(const char*,size_t)" -> "inline_mysql_mutex_unlock(mysql_mutex_t*)"
"THD::set_db(const char*,size_t)" -> "inline_mysql_mutex_lock(mysql_mutex_t*)"
"check_and_convert_db_name(LEX_STRING*,bool)" -> "check_mysql50_prefix(const char*)"
"check_and_convert_db_name(LEX_STRING*,bool)" -> "my_error(int,myf,...)"
"check_and_convert_db_name(LEX_STRING*,bool)" -> "check_table_name(const char*,size_t,bool)"
"check_db_dir_existence(const char*)" -> "access(const char*,int)"
"check_db_dir_existence(const char*)" -> "build_table_filename(char*,size_t,const char*,const char*,const char*,uint)"
"THD::restore_active_arena(Query_arena*,Query_arena*)" -> "Query_arena::set_query_arena(Query_arena*)"
"LEX::set_trg_event_type_for_tables()" -> "st_select_lex::get_table_list()"
"List<T>::head() [with T = Index_hint]" -> "base_list::head()"
"Opt_trace_struct::add_utf8(const char*,const char*)" -> "Opt_trace_struct::do_add(const char*,const char*,size_t,bool)"
"Opt_trace_struct::add_utf8(const char*,const char*)" -> "strlen(const char*)"
"Opt_trace_struct::add_utf8(const char*,const char*)" -> "__builtin_expect(long int,long int)"
"Opt_trace_struct::do_add(const char*,const char*,size_t,bool)" -> "Opt_trace_stmt::add(const char*,const char*,size_t,bool,bool)"
"Opt_trace_stmt::add(const char*,const char*,size_t,bool,bool)" -> "Opt_trace_stmt::support_I_S() const"
"Opt_trace_stmt::add(const char*,const char*,size_t,bool,bool)" -> "Opt_trace_stmt::separator()"
"Opt_trace_stmt::add(const char*,const char*,size_t,bool,bool)" -> "random_name_to_avoid_gcc_bug_29365::Buffer::append(char)"
"Opt_trace_stmt::add(const char*,const char*,size_t,bool,bool)" -> "random_name_to_avoid_gcc_bug_29365::Buffer::append(const char*,size_t)"
"Opt_trace_stmt::add(const char*,const char*,size_t,bool,bool)" -> "random_name_to_avoid_gcc_bug_29365::Buffer::append(const char*)"
"Opt_trace_stmt::add(const char*,const char*,size_t,bool,bool)" -> "random_name_to_avoid_gcc_bug_29365::Buffer::append_escaped(const char*,size_t)"
"Opt_trace_stmt::add(const char*,const char*,size_t,bool,bool)" -> "Opt_trace_struct::check_key(const char*)"
"Opt_trace_stmt::separator()" -> "Opt_trace_struct::set_not_empty()"
"Opt_trace_stmt::separator()" -> "Opt_trace_stmt::next_line()"
"Opt_trace_stmt::separator()" -> "random_name_to_avoid_gcc_bug_29365::Buffer::append(char)"
"Opt_trace_stmt::next_line()" -> "Opt_trace_context::get_one_line() const"
"Opt_trace_stmt::next_line()" -> "random_name_to_avoid_gcc_bug_29365::Buffer::append(char)"
"Opt_trace_stmt::next_line()" -> "random_name_to_avoid_gcc_bug_29365::Buffer::append(const char*,size_t)"
"Opt_trace_stmt::next_line()" -> "Dynamic_array<Elem>::elements() const [with Elem = Opt_trace_struct*]"
"random_name_to_avoid_gcc_bug_29365::Buffer::append(char)" -> "random_name_to_avoid_gcc_bug_29365::Buffer::alloced_length() const"
"random_name_to_avoid_gcc_bug_29365::Buffer::append(char)" -> "String::append(char)"
"random_name_to_avoid_gcc_bug_29365::Buffer::alloced_length() const" -> "String::alloced_length() const"
"random_name_to_avoid_gcc_bug_29365::Buffer::append(const char*,size_t)" -> "String::append(const char*,uint32)"
"random_name_to_avoid_gcc_bug_29365::Buffer::append(const char*,size_t)" -> "random_name_to_avoid_gcc_bug_29365::Buffer::alloced_length() const"
"random_name_to_avoid_gcc_bug_29365::Buffer::append(const char*)" -> "strlen(const char*)"
"random_name_to_avoid_gcc_bug_29365::Buffer::append(const char*)" -> "random_name_to_avoid_gcc_bug_29365::Buffer::append(const char*,size_t)"
"random_name_to_avoid_gcc_bug_29365::Buffer::append_escaped(const char*,size_t)" -> "String::append(const char*,uint32)"
"random_name_to_avoid_gcc_bug_29365::Buffer::append_escaped(const char*,size_t)" -> "random_name_to_avoid_gcc_bug_29365::Buffer::alloced_length() const"
"Opt_trace_struct::check_key(const char*)" -> "__builtin_expect(long int,long int)"
"Opt_trace_struct::check_key(const char*)" -> "Opt_trace_stmt::assert_current_struct(const Opt_trace_struct*) const"
"Opt_trace_struct::check_key(const char*)" -> "Opt_trace_stmt::make_unknown_key()"
"Opt_trace_stmt::make_unknown_key()" -> "my_snprintf(char*,size_t,const char*,...)"
"Opt_trace_struct::add(const char*,bool)" -> "__builtin_expect(long int,long int)"
"Opt_trace_struct::add(const char*,bool)" -> "Opt_trace_struct::do_add(const char*,bool)"
"Opt_trace_struct::do_add(const char*,bool)" -> "Opt_trace_stmt::add(const char*,const char*,size_t,bool,bool)"
"Opt_trace_object::Opt_trace_object(Opt_trace_context*,const char*,Opt_trace_context::feature_value)" -> "Opt_trace_struct::Opt_trace_struct(Opt_trace_context*,bool,const char*,Opt_trace_context::feature_value)"
"Opt_trace_struct::Opt_trace_struct(Opt_trace_context*,bool,const char*,Opt_trace_context::feature_value)" -> "__builtin_expect(long int,long int)"
"Opt_trace_struct::Opt_trace_struct(Opt_trace_context*,bool,const char*,Opt_trace_context::feature_value)" -> "Opt_trace_struct::do_construct(Opt_trace_context*,bool,const char*,Opt_trace_context::feature_value)"
"Opt_trace_struct::Opt_trace_struct(Opt_trace_context*,bool,const char*,Opt_trace_context::feature_value)" -> "Opt_trace_context::is_started() const"
"Opt_trace_struct::do_construct(Opt_trace_context*,bool,const char*,Opt_trace_context::feature_value)" -> "Opt_trace_context::feature_enabled(Opt_trace_context::feature_value) const"
"Opt_trace_struct::do_construct(Opt_trace_context*,bool,const char*,Opt_trace_context::feature_value)" -> "__builtin_expect(long int,long int)"
"Opt_trace_struct::do_construct(Opt_trace_context*,bool,const char*,Opt_trace_context::feature_value)" -> "Opt_trace_context::get_current_stmt_in_gen()"
"Opt_trace_struct::do_construct(Opt_trace_context*,bool,const char*,Opt_trace_context::feature_value)" -> "anonymous}::opening_bracket(bool)"
"Opt_trace_struct::do_construct(Opt_trace_context*,bool,const char*,Opt_trace_context::feature_value)" -> "Opt_trace_stmt::open_struct(const char*,Opt_trace_struct*,bool,char)"
"Opt_trace_context::feature_enabled(Opt_trace_context::feature_value) const" -> "__builtin_expect(long int,long int)"
"Opt_trace_stmt::open_struct(const char*,Opt_trace_struct*,bool,char)" -> "Opt_trace_struct::add_alnum(const char*)"
"Opt_trace_stmt::open_struct(const char*,Opt_trace_struct*,bool,char)" -> "__builtin_expect(long int,long int)"
"Opt_trace_stmt::open_struct(const char*,Opt_trace_struct*,bool,char)" -> "Opt_trace_struct::add_alnum(const char*,const char*)"
"Opt_trace_stmt::open_struct(const char*,Opt_trace_struct*,bool,char)" -> "Opt_trace_stmt::support_I_S() const"
"Opt_trace_stmt::open_struct(const char*,Opt_trace_struct*,bool,char)" -> "Opt_trace_stmt::add(const char*,const char*,size_t,bool,bool)"
"Opt_trace_stmt::open_struct(const char*,Opt_trace_struct*,bool,char)" -> "random_name_to_avoid_gcc_bug_29365::Buffer::prealloc()"
"Opt_trace_stmt::open_struct(const char*,Opt_trace_struct*,bool,char)" -> "Dynamic_array<Elem>::append(const Elem&) [with Elem = Opt_trace_struct*]"
"Opt_trace_stmt::open_struct(const char*,Opt_trace_struct*,bool,char)" -> "Opt_trace_context::disable_I_S_for_this_and_children()"
"Opt_trace_struct::add_alnum(const char*)" -> "Opt_trace_struct::do_add(const char*,const char*,size_t,bool)"
"Opt_trace_struct::add_alnum(const char*)" -> "strlen(const char*)"
"Opt_trace_struct::add_alnum(const char*)" -> "__builtin_expect(long int,long int)"
"Opt_trace_struct::add_alnum(const char*,const char*)" -> "strlen(const char*)"
"Opt_trace_struct::add_alnum(const char*,const char*)" -> "Opt_trace_struct::do_add(const char*,const char*,size_t,bool)"
"Opt_trace_struct::add_alnum(const char*,const char*)" -> "__builtin_expect(long int,long int)"
"random_name_to_avoid_gcc_bug_29365::Buffer::prealloc()" -> "String::realloc(uint32)"
"random_name_to_avoid_gcc_bug_29365::Buffer::prealloc()" -> "random_name_to_avoid_gcc_bug_29365::Buffer::alloced_length() const"
"random_name_to_avoid_gcc_bug_29365::Buffer::prealloc()" -> "random_name_to_avoid_gcc_bug_29365::Buffer::length() const"
"random_name_to_avoid_gcc_bug_29365::Buffer::length() const" -> "String::length() const"
"Dynamic_array<Elem>::append(const Elem&) [with Elem = Opt_trace_struct*]" -> "insert_dynamic(DYNAMIC_ARRAY*,const void*)"
"Opt_trace_context::disable_I_S_for_this_and_children()" -> "__builtin_expect(long int,long int)"
"Opt_trace_context::disable_I_S_for_this_and_children()" -> "Opt_trace_context::Opt_trace_context_impl::disable_I_S_for_this_and_children()"
"Opt_trace_context::Opt_trace_context_impl::disable_I_S_for_this_and_children()" -> "Opt_trace_stmt::disable_I_S()"
"Opt_trace_context::is_started() const" -> "__builtin_expect(long int,long int)"
"LEX::get_effective_with_check(TABLE_LIST*)" -> "LEX::which_check_option_applicable()"
"parse_sql(THD*,Parser_state*,Object_creation_ctx*)" -> "Object_creation_ctx::restore_env(THD*,Object_creation_ctx*)"
"parse_sql(THD*,Parser_state*,Object_creation_ctx*)" -> "Object_creation_ctx::set_n_backup(THD*)"
"parse_sql(THD*,Parser_state*,Object_creation_ctx*)" -> "MYSQLparse(THD*)"
"MYSQLparse(THD*)" -> "Item_cond::add_at_head(Item*)"
"MYSQLparse(THD*)" -> "sp_instr_jump::sp_instr_jump(uint,sp_pcontext*,uint)"
"MYSQLparse(THD*)" -> "Item_func_old_password::alloc(THD*,const char*,size_t)"
"MYSQLparse(THD*)" -> "sp_pcontext::add_variable(THD*,LEX_STRING,enum_field_types,sp_variable::enum_mode)"
"MYSQLparse(THD*)" -> "sp_instr_hpush_jump::sp_instr_hpush_jump(uint,sp_pcontext*,sp_handler*)"
"MYSQLparse(THD*)" -> "st_select_lex::alloc_index_hints(THD*)"
"MYSQLparse(THD*)" -> "Item_func_weight_string::Item_func_weight_string(Item*,uint,uint,uint)"
"MYSQLparse(THD*)" -> "ErrConvString::length() const"
"MYSQLparse(THD*)" -> "Table_ident::Table_ident(SELECT_LEX_UNIT*)"
"MYSQLparse(THD*)" -> "st_select_lex::add_ftfunc_to_list(Item_func_match*)"
"MYSQLparse(THD*)" -> "Item_func_quarter::Item_func_quarter(Item*)"
"MYSQLparse(THD*)" -> "push_new_name_resolution_context(THD*,TABLE_LIST*,TABLE_LIST*)"
"MYSQLparse(THD*)" -> "Item_func_rtrim::Item_func_rtrim(Item*,Item*)"
"MYSQLparse(THD*)" -> "List<T>::push_back(T*) [with T = LEX_COLUMN]"
"MYSQLparse(THD*)" -> "is_cond_and(Item*)"
"MYSQLparse(THD*)" -> "st_select_lex_unit::is_union()"
"MYSQLparse(THD*)" -> "my_string_repertoire(const CHARSET_INFO*,const char*,ulong)"
"MYSQLparse(THD*)" -> "LEX::get_sp_current_parsing_ctx()"
"MYSQLparse(THD*)" -> "check_and_convert_db_name(LEX_STRING*,bool)"
"MYSQLparse(THD*)" -> "Item_func_old_password::Item_func_old_password(Item*)"
"MYSQLparse(THD*)" -> "Item_cond::argument_list()"
"MYSQLparse(THD*)" -> "Item_func_isfalse::Item_func_isfalse(Item*)"
"MYSQLparse(THD*)" -> "handle_sql2003_note184_exception(THD*,Item*,bool,Item*)"
"MYSQLparse(THD*)" -> "st_alter_tablespace::st_alter_tablespace()"
"MYSQLparse(THD*)" -> "Diagnostics_information::set_which_da(Diagnostics_information::Which_area)"
"MYSQLparse(THD*)" -> "Item_char_typecast::Item_char_typecast(Item*,int,const CHARSET_INFO*)"
"MYSQLparse(THD*)" -> "Sql_cmd_alter_table_analyze_partition::Sql_cmd_alter_table_analyze_partition()"
"MYSQLparse(THD*)" -> "sp_instr_stmt::sp_instr_stmt(uint,LEX*,LEX_STRING)"
"MYSQLparse(THD*)" -> "case_stmt_action_case(THD*)"
"MYSQLparse(THD*)" -> "sp_pcontext::push_context(THD*,sp_pcontext::enum_scope)"
"MYSQLparse(THD*)" -> "Sql_cmd_optimize_table::Sql_cmd_optimize_table()"
"MYSQLparse(THD*)" -> "sql_print_warning(const char*,...)"
"MYSQLparse(THD*)" -> "Item_func_second::Item_func_second(Item*)"
"MYSQLparse(THD*)" -> "sp_instr_cfetch::add_to_varlist(sp_variable*)"
"MYSQLparse(THD*)" -> "case_stmt_action_then(THD*,LEX*)"
"MYSQLparse(THD*)" -> "Table_ident::Table_ident(LEX_STRING)"
"MYSQLparse(THD*)" -> "atol(const char*)"
"MYSQLparse(THD*)" -> "sp_pcontext::find_variable(LEX_STRING,bool) const"
"MYSQLparse(THD*)" -> "ha_default_temp_handlerton(THD*)"
"MYSQLparse(THD*)" -> "Proc_analyse_params::Proc_analyse_params()"
"MYSQLparse(THD*)" -> "Item_func_plus::Item_func_plus(Item*,Item*)"
"MYSQLparse(THD*)" -> "strtoul(const char*,char**,int)"
"MYSQLparse(THD*)" -> "std::max(const _Tp&,const _Tp&) [with _Tp = long long unsigned int]"
"MYSQLparse(THD*)" -> "Item_func_reverse::Item_func_reverse(Item*)"
"MYSQLparse(THD*)" -> "sp_instr_jump_if_not::sp_instr_jump_if_not(uint,LEX*,Item*,LEX_STRING)"
"MYSQLparse(THD*)" -> "prepare_schema_table(THD*,LEX*,Table_ident*,enum_schema_tables)"
"MYSQLparse(THD*)" -> "my_parse_error(const char*)"
"MYSQLparse(THD*)" -> "get_old_charset_by_name(const char*)"
"MYSQLparse(THD*)" -> "match_authorized_user(Security_context*,LEX_USER*)"
"MYSQLparse(THD*)" -> "Item_func_div::Item_func_div(Item*,Item*)"
"MYSQLparse(THD*)" -> "partition_info::partition_info()"
"MYSQLparse(THD*)" -> "Item_trigger_field::Item_trigger_field(Name_resolution_context*,Item_trigger_field::row_version_type,const char*,ulong,bool)"
"MYSQLparse(THD*)" -> "Item_func_mod::Item_func_mod(Item*,Item*)"
"MYSQLparse(THD*)" -> "Lex_input_stream::eof()"
"MYSQLparse(THD*)" -> "Item_func_bit_and::Item_func_bit_and(Item*,Item*)"
"MYSQLparse(THD*)" -> "sql_exchange::sql_exchange(char*,bool,enum_filetype)"
"MYSQLparse(THD*)" -> "ErrConvString::ErrConvString(String*)"
"MYSQLparse(THD*)" -> "st_lex_master_info::set_unspecified()"
"MYSQLparse(THD*)" -> "base_list::empty()"
"MYSQLparse(THD*)" -> "strcont(const char*,const char*)"
"MYSQLparse(THD*)" -> "sp_instr_hpush_jump::add_condition(sp_condition_value*)"
"MYSQLparse(THD*)" -> "Item_func_eq::Item_func_eq(Item*,Item*)"
"MYSQLparse(THD*)" -> "sp_pcontext::diff_handlers(const sp_pcontext*,bool) const"
"MYSQLparse(THD*)" -> "sp_add_used_routine(Query_tables_list*,Query_arena*,sp_name*,enum_sp_type)"
"MYSQLparse(THD*)" -> "my_strtoll10(const char*,char**,int*)"
"MYSQLparse(THD*)" -> "mysql_init_select(LEX*)"
"MYSQLparse(THD*)" -> "List<T>::push_back(T*) [with T = Key]"
"MYSQLparse(THD*)" -> "sp_head::instructions()"
"MYSQLparse(THD*)" -> "Item_func_hour::Item_func_hour(Item*)"
"MYSQLparse(THD*)" -> "get_current_user(THD*,LEX_USER*)"
"MYSQLparse(THD*)" -> "sp_head::last_instruction()"
"MYSQLparse(THD*)" -> "sp_pcontext::push_label(THD*,LEX_STRING,uint)"
"MYSQLparse(THD*)" -> "Item_func_group_concat::Item_func_group_concat(Name_resolution_context*,bool,List<Item>*,const SQL_I_List<st_order>&,String*)"
"MYSQLparse(THD*)" -> "Item_func_password::create_password_hash_buffer(THD*,const char*,size_t)"
"MYSQLparse(THD*)" -> "Item_func_add_time::Item_func_add_time(Item*,Item*,bool,bool)"
"MYSQLparse(THD*)" -> "Item_func_spatial_mbr_rel::Item_func_spatial_mbr_rel(Item*,Item*,Item_func::Functype)"
"MYSQLparse(THD*)" -> "is_native_function(THD*,const LEX_STRING*)"
"MYSQLparse(THD*)" -> "set_var_password::set_var_password(LEX_USER*,char*)"
"MYSQLparse(THD*)" -> "Sql_cmd_resignal::Sql_cmd_resignal(const sp_condition_value*,const Set_signal_information&)"
"MYSQLparse(THD*)" -> "List<T>::push_back(T*) [with T = Item_func_set_user_var]"
"MYSQLparse(THD*)" -> "sp_create_assignment_lex(THD*,const char*)"
"MYSQLparse(THD*)" -> "Item_sum_std::Item_sum_std(Item*,uint)"
"MYSQLparse(THD*)" -> "partition_info::add_max_value()"
"MYSQLparse(THD*)" -> "Item_func_ascii::Item_func_ascii(Item*)"
"MYSQLparse(THD*)" -> "sp_instr_cclose::sp_instr_cclose(uint,sp_pcontext*,int)"
"MYSQLparse(THD*)" -> "List<T>::push_back(T*) [with T = my_var]"
"MYSQLparse(THD*)" -> "check_table_name(const char*,size_t,bool)"
"MYSQLparse(THD*)" -> "Item_func_trim::Item_func_trim(Item*)"
"MYSQLparse(THD*)" -> "Lex_input_stream::get_cpp_tok_end()"
"MYSQLparse(THD*)" -> "Item_func_year::Item_func_year(Item*)"
"MYSQLparse(THD*)" -> "Item_func_timestamp_diff::Item_func_timestamp_diff(Item*,Item*,interval_type)"
"MYSQLparse(THD*)" -> "List<T>::push_back(T*) [with T = st_mysql_lex_string]"
"MYSQLparse(THD*)" -> "sp_parser_data::add_cont_backpatch_entry(sp_lex_branch_instr*)"
"MYSQLparse(THD*)" -> "Item_string::set_cs_specified(bool)"
"MYSQLparse(THD*)" -> "Table_ident::Table_ident(THD*,LEX_STRING,LEX_STRING,bool)"
"MYSQLparse(THD*)" -> "Item_func_between::Item_func_between(Item*,Item*,Item*)"
"MYSQLparse(THD*)" -> "sp_pcontext::add_cursor(LEX_STRING)"
"MYSQLparse(THD*)" -> "ha_resolve_by_name(THD*,const LEX_STRING*,bool)"
"MYSQLparse(THD*)" -> "Item_func_bit_neg::Item_func_bit_neg(Item*)"
"MYSQLparse(THD*)" -> "sp_pcontext::find_cursor(LEX_STRING,uint*,bool) const"
"MYSQLparse(THD*)" -> "Item_func_concat::Item_func_concat(Item*,Item*)"
"MYSQLparse(THD*)" -> "MDL_request::set_type(enum_mdl_type)"
"MYSQLparse(THD*)" -> "Lex_input_stream::yyLength()"
"MYSQLparse(THD*)" -> "create_func_cast(THD*,Item*,Cast_target,const char*,const char*,const CHARSET_INFO*)"
"MYSQLparse(THD*)" -> "Alter_info::set_requested_algorithm(const LEX_STRING*)"
"MYSQLparse(THD*)" -> "Sql_cmd_check_table::Sql_cmd_check_table()"
"MYSQLparse(THD*)" -> "String::String(char*,uint32,const CHARSET_INFO*)"
"MYSQLparse(THD*)" -> "my_var::my_var(LEX_STRING&,bool,uint,enum_field_types)"
"MYSQLparse(THD*)" -> "Item_func_coalesce::Item_func_coalesce(List<Item>&)"
"MYSQLparse(THD*)" -> "Item_bin_string::Item_bin_string(const char*,uint)"
"MYSQLparse(THD*)" -> "sp_pcontext::var_context2runtime(uint) const"
"MYSQLparse(THD*)" -> "LEX::is_partition_management() const"
"MYSQLparse(THD*)" -> "find_sys_var(THD*,const char*,uint)"
"MYSQLparse(THD*)" -> "Query_arena::memdup(const void*,size_t)"
"MYSQLparse(THD*)" -> "Item_int::Item_int(int32,uint)"
"MYSQLparse(THD*)" -> "sp_head::add_instr(THD*,sp_instr*)"
"MYSQLparse(THD*)" -> "Sql_cmd_alter_table_truncate_partition::Sql_cmd_alter_table_truncate_partition()"
"MYSQLparse(THD*)" -> "is_cond_or(Item*)"
"MYSQLparse(THD*)" -> "sp_pcontext::parent_context() const"
"MYSQLparse(THD*)" -> "sp_head::reset_lex(THD*)"
"MYSQLparse(THD*)" -> "Item_func_collation::Item_func_collation(Item*)"
"MYSQLparse(THD*)" -> "strlen(const char*)"
"MYSQLparse(THD*)" -> "mysql_init_multi_delete(LEX*)"
"MYSQLparse(THD*)" -> "st_select_lex::add_table_to_list(THD*,Table_ident*,LEX_STRING*,ulong,thr_lock_type,enum_mdl_type,List<Index_hint>*,List<String>*,LEX_STRING*)"
"MYSQLparse(THD*)" -> "st_select_lex_unit::add_fake_select_lex(THD*)"
"MYSQLparse(THD*)" -> "sp_parser_data::get_current_stmt_start_ptr() const"
"MYSQLparse(THD*)" -> "set_system_variable(THD*,sys_var_with_base*,enum_var_type,Item*)"
"MYSQLparse(THD*)" -> "Table_ident::change_db(char*)"
"MYSQLparse(THD*)" -> "get_system_var(THD*,enum_var_type,LEX_STRING,LEX_STRING)"
"MYSQLparse(THD*)" -> "Item_func_user::Item_func_user()"
"MYSQLparse(THD*)" -> "select_export::select_export(sql_exchange*)"
"MYSQLparse(THD*)" -> "Item_sum_xor::Item_sum_xor(Item*)"
"MYSQLparse(THD*)" -> "partition_info::set_part_expr(char*,Item*,char*,bool)"
"MYSQLparse(THD*)" -> "Item_func_shift_right::Item_func_shift_right(Item*,Item*)"
"MYSQLparse(THD*)" -> "mysql_new_select(LEX*,bool)"
"MYSQLparse(THD*)" -> "sp_pcontext::find_variable(uint) const"
"MYSQLparse(THD*)" -> "String::String(const char*,uint32,const CHARSET_INFO*)"
"MYSQLparse(THD*)" -> "sp_parser_data::new_cont_backpatch()"
"MYSQLparse(THD*)" -> "partition_info::print_debug(const char*,uint*)"
"MYSQLparse(THD*)" -> "Sql_cmd_analyze_table::Sql_cmd_analyze_table()"
"MYSQLparse(THD*)" -> "is_sqlstate_valid(const LEX_STRING*)"
"MYSQLparse(THD*)" -> "add_order_to_list(THD*,Item*,bool)"
"MYSQLparse(THD*)" -> "LEX::current_context()"
"MYSQLparse(THD*)" -> "sql_memdup(const void*,size_t)"
"MYSQLparse(THD*)" -> "Key_part_spec::Key_part_spec(const LEX_STRING&,uint)"
"MYSQLparse(THD*)" -> "LEX::set_sp_current_parsing_ctx(sp_pcontext*)"
"MYSQLparse(THD*)" -> "st_ha_check_opt::init()"
"MYSQLparse(THD*)" -> "sp_pcontext::find_condition(LEX_STRING,bool) const"
"MYSQLparse(THD*)" -> "Item_func_dayofmonth::Item_func_dayofmonth(Item*)"
"MYSQLparse(THD*)" -> "sp_pcontext::last_label()"
"MYSQLparse(THD*)" -> "String::ptr() const"
"MYSQLparse(THD*)" -> "List<T>::push_back(T*) [with T = Item_param]"
"MYSQLparse(THD*)" -> "add_gorder_to_list(THD*,Item*,bool)"
"MYSQLparse(THD*)" -> "sp_instr_jump_if_not::sp_instr_jump_if_not(uint,LEX*,Item*,LEX_STRING,uint)"
"MYSQLparse(THD*)" -> "set_var::set_var(enum_var_type,sys_var*,const LEX_STRING*,Item*)"
"MYSQLparse(THD*)" -> "Item_user_var_as_out_param::Item_user_var_as_out_param(Name_string)"
"MYSQLparse(THD*)" -> "std::max(const _Tp&,const _Tp&) [with _Tp = long unsigned int]"
"MYSQLparse(THD*)" -> "Item_func_equal::Item_func_equal(Item*,Item*)"
"MYSQLparse(THD*)" -> "sp_name::sp_name(LEX_STRING,LEX_STRING,bool)"
"MYSQLparse(THD*)" -> "Sql_cmd_get_diagnostics::Sql_cmd_get_diagnostics(Diagnostics_information*)"
"MYSQLparse(THD*)" -> "Item_func_point::Item_func_point(Item*,Item*)"
"MYSQLparse(THD*)" -> "ha_resolve_storage_engine_name(const handlerton*)"
"MYSQLparse(THD*)" -> "Alter_info::set_requested_lock(const LEX_STRING*)"
"MYSQLparse(THD*)" -> "sp_pcontext::find_label(LEX_STRING)"
"MYSQLparse(THD*)" -> "check_string_char_length(LEX_STRING*,const char*,uint,const CHARSET_INFO*,bool)"
"MYSQLparse(THD*)" -> "set_var_collation_client::set_var_collation_client(int,const CHARSET_INFO*,const CHARSET_INFO*,const CHARSET_INFO*)"
"MYSQLparse(THD*)" -> "Sql_cmd_alter_table_check_partition::Sql_cmd_alter_table_check_partition()"
"MYSQLparse(THD*)" -> "struct_slave_connection::reset()"
"MYSQLparse(THD*)" -> "List<T>::List() [with T = Condition_information_item]"
"MYSQLparse(THD*)" -> "yydestruct(const char*,int,YYSTYPE*,THD*)"
"MYSQLparse(THD*)" -> "sp_pcontext::push_case_expr_id()"
"MYSQLparse(THD*)" -> "st_select_lex::set_index_hint_type(index_hint_type,index_clause_map)"
"MYSQLparse(THD*)" -> "st_select_lex::nest_last_join(THD*)"
"MYSQLparse(THD*)" -> "check_simple_select()"
"MYSQLparse(THD*)" -> "Item_cond_or::Item_cond_or(Item*,Item*)"
"MYSQLparse(THD*)" -> "st_select_lex::get_table_list()"
"MYSQLparse(THD*)" -> "get_charset_by_csname(const char*,uint,myf)"
"MYSQLparse(THD*)" -> "trim_whitespace(const CHARSET_INFO*,LEX_STRING*)"
"MYSQLparse(THD*)" -> "Item_func_like::Item_func_like(Item*,Item*,Item*,bool)"
"MYSQLparse(THD*)" -> "Item_func_trim::Item_func_trim(Item*,Item*)"
"MYSQLparse(THD*)" -> "Item_func_format::Item_func_format(Item*,Item*,Item*)"
"MYSQLparse(THD*)" -> "MYSQLerror(THD*,const char*)"
"MYSQLparse(THD*)" -> "Item_func_minute::Item_func_minute(Item*)"
"MYSQLparse(THD*)" -> "List<T>::push_back(T*) [with T = char]"
"MYSQLparse(THD*)" -> "negate_expression(THD*,Item*)"
"MYSQLparse(THD*)" -> "find_sys_var_null_base(THD*,sys_var_with_base*)"
"MYSQLparse(THD*)" -> "sp_check_name(LEX_STRING*)"
"MYSQLparse(THD*)" -> "Item_func_interval::Item_func_interval(Item_row*)"
"MYSQLparse(THD*)" -> "Item_func_int_div::Item_func_int_div(Item*,Item*)"
"MYSQLparse(THD*)" -> "xid_t::set(long int,const char*,long int,const char*,long int)"
"MYSQLparse(THD*)" -> "Statement::query() const"
"MYSQLparse(THD*)" -> "List<T>::push_back(T*) [with T = Alter_column]"
"MYSQLparse(THD*)" -> "Create_udf_func::create(THD*,udf_func*,List<Item>*)"
"MYSQLparse(THD*)" -> "Simple_cstring::is_set() const"
"MYSQLparse(THD*)" -> "add_field_to_list(THD*,LEX_STRING*,enum_field_types,char*,char*,uint,Item*,Item*,LEX_STRING*,char*,List<String>*,const CHARSET_INFO*,uint)"
"MYSQLparse(THD*)" -> "sp_pcontext::get_current_case_expr_id() const"
"MYSQLparse(THD*)" -> "Item_func_case::Item_func_case(List<Item>&,Item*,Item*)"
"MYSQLparse(THD*)" -> "Item_func_set_user_var::Item_func_set_user_var(Name_string,Item*,bool)"
"MYSQLparse(THD*)" -> "sp_lex_branch_instr::set_cont_dest(uint)"
"MYSQLparse(THD*)" -> "sp_parser_data::pop_expr_start_ptr()"
"MYSQLparse(THD*)" -> "sp_name::init_qname(THD*)"
"MYSQLparse(THD*)" -> "Item_func_now_utc::Item_func_now_utc(uint8)"
"MYSQLparse(THD*)" -> "sp_pcontext::pop_label()"
"MYSQLparse(THD*)" -> "Alter_info::reset()"
"MYSQLparse(THD*)" -> "List<T>::push_front(T*) [with T = Item]"
"MYSQLparse(THD*)" -> "Item_func_curdate_local::Item_func_curdate_local()"
"MYSQLparse(THD*)" -> "Item_func_round::Item_func_round(Item*,Item*,bool)"
"MYSQLparse(THD*)" -> "sp_pcontext::add_condition(THD*,LEX_STRING,sp_condition_value*)"
"MYSQLparse(THD*)" -> "check_host_name(LEX_STRING*)"
"MYSQLparse(THD*)" -> "List_iterator<T>::operator++(int) [with T = LEX_COLUMN]"
"MYSQLparse(THD*)" -> "Item_func_match::Item_func_match(List<Item>&,uint)"
"MYSQLparse(THD*)" -> "Item_func_current_user::Item_func_current_user(Name_resolution_context*)"
"MYSQLparse(THD*)" -> "sp_instr_error::sp_instr_error(uint,sp_pcontext*,int)"
"MYSQLparse(THD*)" -> "List<T>::push_back(T*) [with T = set_var_base]"
"MYSQLparse(THD*)" -> "Item_func_char::Item_func_char(List<Item>&)"
"MYSQLparse(THD*)" -> "sp_create_assignment_instr(THD*,const char*)"
"MYSQLparse(THD*)" -> "Item_func_soundex::Item_func_soundex(Item*)"
"MYSQLparse(THD*)" -> "Item_string::append(char*,uint)"
"MYSQLparse(THD*)" -> "st_select_lex::end_nested_join(THD*)"
"MYSQLparse(THD*)" -> "Item_cond::add(Item*)"
"MYSQLparse(THD*)" -> "partition_info::init_column_part()"
"MYSQLparse(THD*)" -> "sp_parser_data::set_parameter_end_ptr(const char*)"
"MYSQLparse(THD*)" -> "Sql_cmd_truncate_table::Sql_cmd_truncate_table()"
"MYSQLparse(THD*)" -> "Item::quick_fix_field()"
"MYSQLparse(THD*)" -> "__errno_location()"
"MYSQLparse(THD*)" -> "sp_pcontext::current_cursor_count() const"
"MYSQLparse(THD*)" -> "Name_string::copy(const char*,size_t,const CHARSET_INFO*)"
"MYSQLparse(THD*)" -> "Item_sum_count::Item_sum_count(Item*)"
"MYSQLparse(THD*)" -> "st_select_lex::add_index_hint(THD*,char*,uint)"
"MYSQLparse(THD*)" -> "Item_default_value::Item_default_value(Name_resolution_context*,Item*)"
"MYSQLparse(THD*)" -> "Item_sum_max::Item_sum_max(Item*)"
"MYSQLparse(THD*)" -> "Item_ref::Item_ref(Name_resolution_context*,const char*,const char*,const char*)"
"MYSQLparse(THD*)" -> "Lex_input_stream::get_cpp_ptr()"
"MYSQLparse(THD*)" -> "List_iterator<T>::List_iterator(List<T>&) [with T = LEX_COLUMN]"
"MYSQLparse(THD*)" -> "List<T>::List() [with T = Item]"
"MYSQLparse(THD*)" -> "find_qualified_function_builder(THD*)"
"MYSQLparse(THD*)" -> "sp_pcontext::add_handler(THD*,sp_handler::enum_type)"
"MYSQLparse(THD*)" -> "Item_extract::Item_extract(interval_type,Item*)"
"MYSQLparse(THD*)" -> "Item_func_microsecond::Item_func_microsecond(Item*)"
"MYSQLparse(THD*)" -> "create_item_for_sp_var(THD*,LEX_STRING,sp_variable*,const char*,const char*,const char*)"
"MYSQLparse(THD*)" -> "Item_func_repeat::Item_func_repeat(Item*,Item*)"
"MYSQLparse(THD*)" -> "Item_cond::add_at_head(List<Item>*)"
"MYSQLparse(THD*)" -> "select_dump::select_dump(sql_exchange*)"
"MYSQLparse(THD*)" -> "Lex_input_stream::get_tok_start_prev()"
"MYSQLparse(THD*)" -> "MYSQLlex(YYSTYPE*,THD*)"
"MYSQLparse(THD*)" -> "is_sqlstate_completion(const char*)"
"MYSQLparse(THD*)" -> "Statement_information::Statement_information(List<Statement_information_item>*)"
"MYSQLparse(THD*)" -> "sp_head::restore_lex(THD*)"
"MYSQLparse(THD*)" -> "check_password_policy(String*)"
"MYSQLparse(THD*)" -> "Item_sum_variance::Item_sum_variance(Item*,uint)"
"MYSQLparse(THD*)" -> "Lex_input_stream::get_cpp_tok_start()"
"MYSQLparse(THD*)" -> "Item_func_curtime_local::Item_func_curtime_local(uint8)"
"MYSQLparse(THD*)" -> "Item_row::Item_row(List<Item>&)"
"MYSQLparse(THD*)" -> "Item_datetime_typecast::Item_datetime_typecast(Item*)"
"MYSQLparse(THD*)" -> "List<T>::push_back(T*) [with T = st_lex_user]"
"MYSQLparse(THD*)" -> "sp_parser_data::set_parameter_start_ptr(const char*)"
"MYSQLparse(THD*)" -> "Item_sum_or::Item_sum_or(Item*)"
"MYSQLparse(THD*)" -> "Item_sum_avg::Item_sum_avg(Item*,bool)"
"MYSQLparse(THD*)" -> "fill_field_definition(THD*,sp_head*,enum_field_types,Create_field*)"
"MYSQLparse(THD*)" -> "sp_parser_data::do_backpatch(sp_label*,uint)"
"MYSQLparse(THD*)" -> "st_select_lex_unit::first_select()"
"MYSQLparse(THD*)" -> "add_join_natural(TABLE_LIST*,TABLE_LIST*,List<String>*,SELECT_LEX*)"
"MYSQLparse(THD*)" -> "Alter_column::Alter_column(const char*,Item*)"
"MYSQLparse(THD*)" -> "Item_func_sysdate_local::Item_func_sysdate_local(uint8)"
"MYSQLparse(THD*)" -> "List<T>::push_back(T*) [with T = partition_element]"
"MYSQLparse(THD*)" -> "Name_string::Name_string(const char*,size_t)"
"MYSQLparse(THD*)" -> "Item_field::Item_field(Name_resolution_context*,const char*,const char*,const char*)"
"MYSQLparse(THD*)" -> "String::length() const"
"MYSQLparse(THD*)" -> "LEX::copy_db_to(char**,size_t*) const"
"MYSQLparse(THD*)" -> "ErrConvString::ErrConvString(const char*,uint,const CHARSET_INFO*)"
"MYSQLparse(THD*)" -> "List<T>::push_back(T*) [with T = Key_part_spec]"
"MYSQLparse(THD*)" -> "Item_func_curdate_utc::Item_func_curdate_utc()"
"MYSQLparse(THD*)" -> "Item_func_conv_charset::Item_func_conv_charset(Item*,const CHARSET_INFO*)"
"MYSQLparse(THD*)" -> "create_select_for_variable(const char*)"
"MYSQLparse(THD*)" -> "LEX::pop_context()"
"MYSQLparse(THD*)" -> "THD::convert_string(LEX_STRING*,const CHARSET_INFO*,const char*,uint,const CHARSET_INFO*)"
"MYSQLparse(THD*)" -> "sp_parser_data::push_expr_start_ptr(const char*)"
"MYSQLparse(THD*)" -> "sp_condition_value::sp_condition_value(const char*)"
"MYSQLparse(THD*)" -> "Sql_cmd_handler_open::Sql_cmd_handler_open()"
"MYSQLparse(THD*)" -> "Item_func_charset::Item_func_charset(Item*)"
"MYSQLparse(THD*)" -> "create_temporal_literal(THD*,const char*,uint,const CHARSET_INFO*,enum_field_types,bool)"
"MYSQLparse(THD*)" -> "case_stmt_action_end_case(LEX*,bool)"
"MYSQLparse(THD*)" -> "add_group_to_list(THD*,Item*,bool)"
"MYSQLparse(THD*)" -> "sp_pcontext::declare_var_boundary(uint)"
"MYSQLparse(THD*)" -> "List<T>::push_back(T*) [with T = String]"
"MYSQLparse(THD*)" -> "Set_signal_information::clear()"
"MYSQLparse(THD*)" -> "sp_instr_set::sp_instr_set(uint,LEX*,uint,Item*,LEX_STRING,bool)"
"MYSQLparse(THD*)" -> "Item_func_in::Item_func_in(List<Item>&)"
"MYSQLparse(THD*)" -> "Item_func_ltrim::Item_func_ltrim(Item*)"
"MYSQLparse(THD*)" -> "sp_pcontext::diff_cursors(const sp_pcontext*,bool) const"
"MYSQLparse(THD*)" -> "Item_func_get_user_var::Item_func_get_user_var(Name_string)"
"MYSQLparse(THD*)" -> "Name_string::Name_string(LEX_STRING)"
"MYSQLparse(THD*)" -> "my_yyoverflow(short int**,YYSTYPE**,ulong*)"
"MYSQLparse(THD*)" -> "SQL_I_List<T>::empty() [with T = st_order]"
"MYSQLparse(THD*)" -> "Item_func_istrue::Item_func_istrue(Item*)"
"MYSQLparse(THD*)" -> "sys_var::is_struct()"
"MYSQLparse(THD*)" -> "my_charset_same(const CHARSET_INFO*,const CHARSET_INFO*)"
"MYSQLparse(THD*)" -> "partition_element::partition_element()"
"MYSQLparse(THD*)" -> "Item_func_isnull::Item_func_isnull(Item*)"
"MYSQLparse(THD*)" -> "Lex_input_stream::get_ptr()"
"MYSQLparse(THD*)" -> "sp_instr_jump::sp_instr_jump(uint,sp_pcontext*)"
"MYSQLparse(THD*)" -> "Item_func_spatial_collection::Item_func_spatial_collection(List<Item>&,Geometry::wkbType,Geometry::wkbType)"
"MYSQLparse(THD*)" -> "sp_pcontext::context_var_count() const"
"MYSQLparse(THD*)" -> "sp_finish_parsing(THD*)"
"MYSQLparse(THD*)" -> "Sql_cmd_discard_import_tablespace::Sql_cmd_discard_import_tablespace(Sql_cmd_discard_import_tablespace::enum_tablespace_op_type)"
"MYSQLparse(THD*)" -> "sprintf(char*,const char*,...)"
"MYSQLparse(THD*)" -> "create_table_set_open_action_and_adjust_tables(LEX*)"
"MYSQLparse(THD*)" -> "find_udf(const char*,uint,bool)"
"MYSQLparse(THD*)" -> "LEX_COLUMN::LEX_COLUMN(const String&,const uint&)"
"MYSQLparse(THD*)" -> "SQL_I_List<T>::link_in_list(T*,T**) [with T = Item_trigger_field]"
"MYSQLparse(THD*)" -> "sp_parser_data::set_current_stmt_start_ptr(const char*)"
"MYSQLparse(THD*)" -> "List<T>::push_back(T*) [with T = Condition_information_item]"
"MYSQLparse(THD*)" -> "st_select_lex::clear_index_hints()"
"MYSQLparse(THD*)" -> "LEX::is_metadata_used() const"
"MYSQLparse(THD*)" -> "Item_func_insert::Item_func_insert(Item*,Item*,Item*,Item*)"
"MYSQLparse(THD*)" -> "ErrConvString::ptr()"
"MYSQLparse(THD*)" -> "Item_func_shift_left::Item_func_shift_left(Item*,Item*)"
"MYSQLparse(THD*)" -> "add_create_index_prepare(LEX*,Table_ident*)"
"MYSQLparse(THD*)" -> "Item_func_rtrim::Item_func_rtrim(Item*)"
"MYSQLparse(THD*)" -> "select_dumpvar::select_dumpvar()"
"MYSQLparse(THD*)" -> "init_dynamic_array2(DYNAMIC_ARRAY*,uint,void*,uint,uint)"
"MYSQLparse(THD*)" -> "SQL_I_List<T>::push_front(SQL_I_List<T>*) [with T = TABLE_LIST]"
"MYSQLparse(THD*)" -> "Item_func_get_format::Item_func_get_format(timestamp_type,Item*)"
"MYSQLparse(THD*)" -> "List<T>::push_back(T*) [with T = Statement_information_item]"
"MYSQLparse(THD*)" -> "add_value_to_list(THD*,Item*)"
"MYSQLparse(THD*)" -> "Query_arena::strmake(const char*,size_t)"
"MYSQLparse(THD*)" -> "Item_string::Item_string(Name_string,const char*,uint,const CHARSET_INFO*,Derivation,uint)"
"MYSQLparse(THD*)" -> "Item_decimal::Item_decimal(const char*,uint,const CHARSET_INFO*)"
"MYSQLparse(THD*)" -> "Item_date_typecast::Item_date_typecast(Item*)"
"MYSQLparse(THD*)" -> "sp_parser_data::add_backpatch_entry(sp_branch_instr*,sp_label*)"
"MYSQLparse(THD*)" -> "sp_instr_hpop::sp_instr_hpop(uint,sp_pcontext*)"
"MYSQLparse(THD*)" -> "Alter_drop::Alter_drop(Alter_drop::drop_type,const char*)"
"MYSQLparse(THD*)" -> "Item_func_left::Item_func_left(Item*,Item*)"
"MYSQLparse(THD*)" -> "Item_func_database::Item_func_database()"
"MYSQLparse(THD*)" -> "sp_instr_hreturn::sp_instr_hreturn(uint,sp_pcontext*)"
"MYSQLparse(THD*)" -> "Sql_cmd_alter_table_repair_partition::Sql_cmd_alter_table_repair_partition()"
"MYSQLparse(THD*)" -> "Item_sum_min::Item_sum_min(Item*)"
"MYSQLparse(THD*)" -> "sp_parser_data::do_cont_backpatch(uint)"
"MYSQLparse(THD*)" -> "Sql_cmd_alter_table::Sql_cmd_alter_table()"
"MYSQLparse(THD*)" -> "List<T>::List() [with T = String]"
"MYSQLparse(THD*)" -> "Item_int::Item_int(const Name_string&,longlong,uint)"
"MYSQLparse(THD*)" -> "Item_time_typecast::Item_time_typecast(Item*)"
"MYSQLparse(THD*)" -> "multi_delete_set_locks_and_link_aux_tables(LEX*)"
"MYSQLparse(THD*)" -> "Item_default_value::Item_default_value(Name_resolution_context*)"
"MYSQLparse(THD*)" -> "List<T>::push_back(T*) [with T = Alter_drop]"
"MYSQLparse(THD*)" -> "Item_func_mul::Item_func_mul(Item*,Item*)"
"MYSQLparse(THD*)" -> "Sql_cmd_repair_table::Sql_cmd_repair_table()"
"MYSQLparse(THD*)" -> "sp_instr_set_case_expr::sp_instr_set_case_expr(uint,LEX*,uint,Item*,LEX_STRING)"
"MYSQLparse(THD*)" -> "st_select_lex::convert_right_join()"
"MYSQLparse(THD*)" -> "Lex_input_stream::get_tok_start()"
"MYSQLparse(THD*)" -> "Item_func_char::Item_func_char(List<Item>&,const CHARSET_INFO*)"
"MYSQLparse(THD*)" -> "Item_func_opt_neg::negate()"
"MYSQLparse(THD*)" -> "Item_func_password::Item_func_password(Item*)"
"MYSQLparse(THD*)" -> "check_reserved_words(LEX_STRING*)"
"MYSQLparse(THD*)" -> "Item_date_add_interval::Item_date_add_interval(Item*,Item*,interval_type,bool)"
"MYSQLparse(THD*)" -> "Condition_information_item::Condition_information_item(Condition_information_item::Name,Item*)"
"MYSQLparse(THD*)" -> "Sql_cmd_handler_close::Sql_cmd_handler_close()"
"MYSQLparse(THD*)" -> "all_any_subquery_creator(Item*,chooser_compare_func_creator,bool,SELECT_LEX*)"
"MYSQLparse(THD*)" -> "Item_param::Item_param(uint)"
"MYSQLparse(THD*)" -> "Condition_information::Condition_information(Item*,List<Condition_information_item>*)"
"MYSQLparse(THD*)" -> "push_warning_printf(THD*,Sql_condition::enum_warning_level,uint,const char*,...)"
"MYSQLparse(THD*)" -> "mem_alloc_error(size_t)"
"MYSQLparse(THD*)" -> "st_select_lex::pop_index_hints()"
"MYSQLparse(THD*)" -> "st_select_lex::init_order()"
"MYSQLparse(THD*)" -> "sp_condition_value::sp_condition_value(sp_condition_value::enum_type)"
"MYSQLparse(THD*)" -> "Item_func_minus::Item_func_minus(Item*,Item*)"
"MYSQLparse(THD*)" -> "Item_null::Item_null()"
"MYSQLparse(THD*)" -> "THD::is_error() const"
"MYSQLparse(THD*)" -> "Item_func_locate::Item_func_locate(Item*,Item*)"
"MYSQLparse(THD*)" -> "make_string(THD*,const char*,const char*)"
"MYSQLparse(THD*)" -> "List<T>::push_front(T*) [with T = st_lex_user]"
"MYSQLparse(THD*)" -> "LEX::uncacheable(uint8)"
"MYSQLparse(THD*)" -> "Item_sum_and::Item_sum_and(Item*)"
"MYSQLparse(THD*)" -> "Item_string::set_repertoire_from_value()"
"MYSQLparse(THD*)" -> "check_column_name(const char*)"
"MYSQLparse(THD*)" -> "Item_string::Item_string(const char*,uint,const CHARSET_INFO*,Derivation,uint)"
"MYSQLparse(THD*)" -> "LEX::cleanup_lex_after_parse_error(THD*)"
"MYSQLparse(THD*)" -> "atoi(const char*)"
"MYSQLparse(THD*)" -> "partition_info::reorganize_into_single_field_col_val()"
"MYSQLparse(THD*)" -> "Item_func_substr::Item_func_substr(Item*,Item*)"
"MYSQLparse(THD*)" -> "my_message(uint,const char*,myf)"
"MYSQLparse(THD*)" -> "add_select_to_union_list(LEX*,bool,bool)"
"MYSQLparse(THD*)" -> "Item_func_get_system_var::is_written_to_binlog()"
"MYSQLparse(THD*)" -> "SQL_I_List<T>::save_and_clear(SQL_I_List<T>*) [with T = TABLE_LIST]"
"MYSQLparse(THD*)" -> "strtol(const char*,char**,int)"
"MYSQLparse(THD*)" -> "Item::check_well_formed_result(String*,bool)"
"MYSQLparse(THD*)" -> "Item_func_bit_or::Item_func_bit_or(Item*,Item*)"
"MYSQLparse(THD*)" -> "my_charset_is_ascii_based(const CHARSET_INFO*)"
"MYSQLparse(THD*)" -> "Item_uint::Item_uint(const char*,uint)"
"MYSQLparse(THD*)" -> "sp_instr_cpush::sp_instr_cpush(uint,sp_pcontext*,LEX*,LEX_STRING,int)"
"MYSQLparse(THD*)" -> "set_var_user::set_var_user(Item_func_set_user_var*)"
"MYSQLparse(THD*)" -> "THD::charset()"
"MYSQLparse(THD*)" -> "Item_func_isnotfalse::Item_func_isnotfalse(Item*)"
"MYSQLparse(THD*)" -> "sp_head::is_not_allowed_in_function(const char*)"
"MYSQLparse(THD*)" -> "ha_default_handlerton(THD*)"
"MYSQLparse(THD*)" -> "Item_insert_value::Item_insert_value(Name_resolution_context*,Item*)"
"MYSQLparse(THD*)" -> "sp_instr_jump_case_when::sp_instr_jump_case_when(uint,LEX*,int,Item*,LEX_STRING)"
"MYSQLparse(THD*)" -> "Item_sum_count::Item_sum_count(List<Item>&)"
"MYSQLparse(THD*)" -> "Item_float::Item_float(const char*,uint)"
"MYSQLparse(THD*)" -> "store_position_for_column(const char*)"
"MYSQLparse(THD*)" -> "sp_instr_cpop::sp_instr_cpop(uint,sp_pcontext*,uint)"
"MYSQLparse(THD*)" -> "sp_pcontext::pop_context()"
"MYSQLparse(THD*)" -> "Lex_input_stream::get_tok_end()"
"MYSQLparse(THD*)" -> "sp_instr_copen::sp_instr_copen(uint,sp_pcontext*,int)"
"MYSQLparse(THD*)" -> "Item_func_regex::Item_func_regex(Item*,Item*)"
"MYSQLparse(THD*)" -> "List<T>::push_back(T*) [with T = List<Item>]"
"MYSQLparse(THD*)" -> "sp_head::set_body_start(THD*,const char*)"
"MYSQLparse(THD*)" -> "Item_func_substr::Item_func_substr(Item*,Item*,Item*)"
"MYSQLparse(THD*)" -> "Query_tables_list::last_table()"
"MYSQLparse(THD*)" -> "plugin_is_ready(const LEX_STRING*,int)"
"MYSQLparse(THD*)" -> "Sql_cmd_handler_read::Sql_cmd_handler_read(enum_ha_read_modes,const char*,List<Item>*,ha_rkey_function)"
"MYSQLparse(THD*)" -> "Item_func_right::Item_func_right(Item*,Item*)"
"MYSQLparse(THD*)" -> "Statement_information_item::Statement_information_item(Statement_information_item::Name,Item*)"
"MYSQLparse(THD*)" -> "_current_thd()"
"MYSQLparse(THD*)" -> "memset(void*,int,size_t)"
"MYSQLparse(THD*)" -> "sp_instr_cfetch::sp_instr_cfetch(uint,sp_pcontext*,int)"
"MYSQLparse(THD*)" -> "Item_exists_subselect::Item_exists_subselect(st_select_lex*)"
"MYSQLparse(THD*)" -> "Item_name_string::copy(const char*,size_t,const CHARSET_INFO*,bool)"
"MYSQLparse(THD*)" -> "Item_func_curtime_utc::Item_func_curtime_utc(uint8)"
"MYSQLparse(THD*)" -> "add_join_on(TABLE_LIST*,Item*)"
"MYSQLparse(THD*)" -> "Event_parse_data::new_instance(THD*)"
"MYSQLparse(THD*)" -> "sp_condition_value::sp_condition_value(uint)"
"MYSQLparse(THD*)" -> "Item_func_set_collation::Item_func_set_collation(Item*,Item*)"
"MYSQLparse(THD*)" -> "Item_func_xor::Item_func_xor(Item*,Item*)"
"MYSQLparse(THD*)" -> "Query_tables_list::uses_stored_routines() const"
"MYSQLparse(THD*)" -> "find_native_function_builder(THD*,LEX_STRING)"
"MYSQLparse(THD*)" -> "merge_charset_and_collation(const CHARSET_INFO*,const CHARSET_INFO*)"
"MYSQLparse(THD*)" -> "Query_arena::alloc(size_t)"
"MYSQLparse(THD*)" -> "sp_start_parsing(THD*,enum_sp_type,sp_name*)"
"MYSQLparse(THD*)" -> "Item_cond_and::Item_cond_and(Item*,Item*)"
"MYSQLparse(THD*)" -> "Explain_format_traditional::Explain_format_traditional()"
"MYSQLparse(THD*)" -> "Explain_format_JSON::Explain_format_JSON()"
"MYSQLparse(THD*)" -> "partition_info::add_column_list_value(THD*,Item*)"
"MYSQLparse(THD*)" -> "Item_in_subselect::Item_in_subselect(Item*,st_select_lex*)"
"MYSQLparse(THD*)" -> "Simple_cstring::ptr() const"
"MYSQLparse(THD*)" -> "Item_singlerow_subselect::Item_singlerow_subselect(st_select_lex*)"
"MYSQLparse(THD*)" -> "Item_func_neg::Item_func_neg(Item*)"
"MYSQLparse(THD*)" -> "sp_pcontext::check_duplicate_handler(const sp_condition_value*) const"
"MYSQLparse(THD*)" -> "partition_element::partition_element(partition_element*)"
"MYSQLparse(THD*)" -> "sp_instr_freturn::sp_instr_freturn(uint,LEX*,Item*,LEX_STRING,enum_field_types)"
"MYSQLparse(THD*)" -> "Query_tables_list::set_stmt_unsafe(Query_tables_list::enum_binlog_stmt_unsafe)"
"MYSQLparse(THD*)" -> "Item_func_bit_xor::Item_func_bit_xor(Item*,Item*)"
"MYSQLparse(THD*)" -> "Item_func_replace::Item_func_replace(Item*,Item*,Item*)"
"MYSQLparse(THD*)" -> "Item_func_format::Item_func_format(Item*,Item*)"
"MYSQLparse(THD*)" -> "Sql_cmd_alter_table_exchange_partition::Sql_cmd_alter_table_exchange_partition()"
"MYSQLparse(THD*)" -> "Item_hex_string::Item_hex_string(const char*,uint)"
"MYSQLparse(THD*)" -> "Item_func_week::Item_func_week(Item*,Item*)"
"MYSQLparse(THD*)" -> "Item_func_ltrim::Item_func_ltrim(Item*,Item*)"
"MYSQLparse(THD*)" -> "Item_func_not::Item_func_not(Item*)"
"MYSQLparse(THD*)" -> "add_item_to_list(THD*,Item*)"
"MYSQLparse(THD*)" -> "Item_func_row_count::Item_func_row_count()"
"MYSQLparse(THD*)" -> "sp_get_flags_for_command(LEX*)"
"MYSQLparse(THD*)" -> "set_trigger_new_row(THD*,LEX_STRING,Item*,LEX_STRING)"
"MYSQLparse(THD*)" -> "insert_dynamic(DYNAMIC_ARRAY*,const void*)"
"MYSQLparse(THD*)" -> "List<T>::List() [with T = Statement_information_item]"
"MYSQLparse(THD*)" -> "Item_func_month::Item_func_month(Item*)"
"MYSQLparse(THD*)" -> "String::String(const char*,const CHARSET_INFO*)"
"MYSQLparse(THD*)" -> "Item_func_isnotnull::Item_func_isnotnull(Item*)"
"MYSQLparse(THD*)" -> "Sql_cmd_signal::Sql_cmd_signal(const sp_condition_value*,const Set_signal_information&)"
"MYSQLparse(THD*)" -> "Foreign_key::Foreign_key(const LEX_STRING&,List<Key_part_spec>&,const LEX_STRING&,const LEX_STRING&,List<Key_part_spec>&,uint,uint,uint)"
"MYSQLparse(THD*)" -> "Item_func_isnottrue::Item_func_isnottrue(Item*)"
"MYSQLparse(THD*)" -> "st_select_lex::add_joined_table(TABLE_LIST*)"
"MYSQLparse(THD*)" -> "Item_sum_sum::Item_sum_sum(Item*,bool)"
"MYSQLparse(THD*)" -> "Sql_cmd_alter_table_optimize_partition::Sql_cmd_alter_table_optimize_partition()"
"MYSQLparse(THD*)" -> "Item_func_now_local::Item_func_now_local(uint8)"
"MYSQLparse(THD*)" -> "Item_func_if::Item_func_if(Item*,Item*,Item*)"
"MYSQLparse(THD*)" -> "List<T>::push_back(T*) [with T = Item]"
"MYSQLparse(THD*)" -> "mysqld_collation_get_by_name(const char*,CHARSET_INFO*)"
"MYSQLparse(THD*)" -> "my_error(int,myf,...)"
"MYSQLparse(THD*)" -> "st_select_lex::init_nested_join(THD*)"
"MYSQLparse(THD*)" -> "add_create_index(LEX*,Key::Keytype,const LEX_STRING&,KEY_CREATE_INFO*,bool)"
"MYSQLparse(THD*)" -> "setup_select_in_parentheses(LEX*)"
"Item_cond::add_at_head(Item*)" -> "List<T>::push_front(T*) [with T = Item]"
"List<T>::push_front(T*) [with T = Item]" -> "base_list::push_front(void*)"
"sp_instr_jump::sp_instr_jump(uint,sp_pcontext*,uint)" -> "sp_branch_instr::sp_branch_instr()"
"sp_instr_jump::sp_instr_jump(uint,sp_pcontext*,uint)" -> "sp_instr::sp_instr(uint,sp_pcontext*)"
"sp_instr::sp_instr(uint,sp_pcontext*)" -> "Sql_alloc::Sql_alloc()"
"sp_instr::sp_instr(uint,sp_pcontext*)" -> "sp_printable::sp_printable()"
"sp_instr::sp_instr(uint,sp_pcontext*)" -> "Query_arena::Query_arena(MEM_ROOT*,Query_arena::enum_state)"
"Item_func_old_password::alloc(THD*,const char*,size_t)" -> "check_password_policy(String*)"
"Item_func_old_password::alloc(THD*,const char*,size_t)" -> "String::String(const char*,const CHARSET_INFO*)"
"Item_func_old_password::alloc(THD*,const char*,size_t)" -> "Query_arena::alloc(size_t)"
"Item_func_old_password::alloc(THD*,const char*,size_t)" -> "my_make_scrambled_password_323(char*,const char*,size_t)"
"check_password_policy(String*)" -> "String::String()"
"check_password_policy(String*)" -> "plugin_unlock(THD*,plugin_ref)"
"check_password_policy(String*)" -> "my_error(int,myf,...)"
"check_password_policy(String*)" -> "plugin_lock_by_name(THD*,const LEX_STRING*,int)"
"String::String(const char*,const CHARSET_INFO*)" -> "strlen(const char*)"
"sp_pcontext::add_variable(THD*,LEX_STRING,enum_field_types,sp_variable::enum_mode)" -> "Dynamic_array<Elem>::append(const Elem&) [with Elem = sp_variable*]"
"sp_pcontext::add_variable(THD*,LEX_STRING,enum_field_types,sp_variable::enum_mode)" -> "sp_variable::sp_variable(LEX_STRING,enum_field_types,sp_variable::enum_mode,uint)"
"sp_pcontext::add_variable(THD*,LEX_STRING,enum_field_types,sp_variable::enum_mode)" -> "sp_pcontext::current_var_count() const"
"Dynamic_array<Elem>::append(const Elem&) [with Elem = sp_variable*]" -> "insert_dynamic(DYNAMIC_ARRAY*,const void*)"
"sp_variable::sp_variable(LEX_STRING,enum_field_types,sp_variable::enum_mode,uint)" -> "Create_field::Create_field()"
"sp_variable::sp_variable(LEX_STRING,enum_field_types,sp_variable::enum_mode,uint)" -> "Sql_alloc::Sql_alloc()"
"Create_field::Create_field()" -> "List<T>::List() [with T = String]"
"Create_field::Create_field()" -> "Sql_alloc::Sql_alloc()"
"sp_pcontext::current_var_count() const" -> "Dynamic_array<Elem>::elements() const [with Elem = sp_variable*]"
"sp_instr_hpush_jump::sp_instr_hpush_jump(uint,sp_pcontext*,sp_handler*)" -> "sp_instr_jump::sp_instr_jump(uint,sp_pcontext*)"
"sp_instr_hpush_jump::sp_instr_hpush_jump(uint,sp_pcontext*,sp_handler*)" -> "sp_pcontext::current_var_count() const"
"sp_instr_jump::sp_instr_jump(uint,sp_pcontext*)" -> "sp_branch_instr::sp_branch_instr()"
"sp_instr_jump::sp_instr_jump(uint,sp_pcontext*)" -> "sp_instr::sp_instr(uint,sp_pcontext*)"
"st_select_lex::alloc_index_hints(THD*)" -> "List<T>::List() [with T = Index_hint]"
"List<T>::List() [with T = Index_hint]" -> "base_list::base_list()"
"Item_func_weight_string::Item_func_weight_string(Item*,uint,uint,uint)" -> "String::String()"
"Item_func_weight_string::Item_func_weight_string(Item*,uint,uint,uint)" -> "Item_str_func::Item_str_func(Item*)"
"Item_str_func::Item_str_func(Item*)" -> "Item_func::Item_func(Item*)"
"Item_func::Item_func(Item*)" -> "Item_result_field::Item_result_field()"
"Item_result_field::Item_result_field()" -> "Item::Item()"
"Item::Item()" -> "Item_name_string::Item_name_string()"
"Item::Item()" -> "String::String()"
"Item::Item()" -> "_current_thd()"
"Item::Item()" -> "DTCollation::DTCollation(const CHARSET_INFO*,Derivation)"
"Item_name_string::Item_name_string()" -> "Name_string::Name_string()"
"Name_string::Name_string()" -> "Simple_cstring::Simple_cstring()"
"Simple_cstring::Simple_cstring()" -> "Simple_cstring::set(const char*,size_t)"
"DTCollation::DTCollation(const CHARSET_INFO*,Derivation)" -> "DTCollation::set_repertoire_from_charset(const CHARSET_INFO*)"
"Table_ident::Table_ident(SELECT_LEX_UNIT*)" -> "Sql_alloc::Sql_alloc()"
"st_select_lex::add_ftfunc_to_list(Item_func_match*)" -> "List<T>::push_back(T*) [with T = Item_func_match]"
"List<T>::push_back(T*) [with T = Item_func_match]" -> "base_list::push_back(void*)"
"base_list::push_back(void*)" -> "list_node::list_node(void*,list_node*)"
"Item_func_quarter::Item_func_quarter(Item*)" -> "Item_int_func::Item_int_func(Item*)"
"Item_int_func::Item_int_func(Item*)" -> "Item_func::Item_func(Item*)"
"Item_int_func::Item_int_func(Item*)" -> "Item::fix_char_length(uint32)"
"Item_int_func::Item_int_func(Item*)" -> "DTCollation::set_numeric()"
"Item::fix_char_length(uint32)" -> "char_to_byte_length_safe(uint32,uint32)"
"push_new_name_resolution_context(THD*,TABLE_LIST*,TABLE_LIST*)" -> "Name_resolution_context::Name_resolution_context()"
"push_new_name_resolution_context(THD*,TABLE_LIST*,TABLE_LIST*)" -> "Name_resolution_context::init()"
"push_new_name_resolution_context(THD*,TABLE_LIST*,TABLE_LIST*)" -> "TABLE_LIST::last_leaf_for_name_resolution()"
"push_new_name_resolution_context(THD*,TABLE_LIST*,TABLE_LIST*)" -> "LEX::push_context(Name_resolution_context*)"
"push_new_name_resolution_context(THD*,TABLE_LIST*,TABLE_LIST*)" -> "TABLE_LIST::first_leaf_for_name_resolution()"
"TABLE_LIST::last_leaf_for_name_resolution()" -> "List_iterator_fast<T>::operator++(int) [with T = TABLE_LIST]"
"TABLE_LIST::last_leaf_for_name_resolution()" -> "TABLE_LIST::is_leaf_for_name_resolution()"
"TABLE_LIST::last_leaf_for_name_resolution()" -> "List<T>::head() [with T = TABLE_LIST]"
"TABLE_LIST::last_leaf_for_name_resolution()" -> "List_iterator_fast<T>::List_iterator_fast(List<T>&) [with T = TABLE_LIST]"
"List<T>::head() [with T = TABLE_LIST]" -> "base_list::head()"
"TABLE_LIST::first_leaf_for_name_resolution()" -> "List_iterator_fast<T>::operator++(int) [with T = TABLE_LIST]"
"TABLE_LIST::first_leaf_for_name_resolution()" -> "TABLE_LIST::is_leaf_for_name_resolution()"
"TABLE_LIST::first_leaf_for_name_resolution()" -> "List_iterator_fast<T>::List_iterator_fast(List<T>&) [with T = TABLE_LIST]"
"Item_func_rtrim::Item_func_rtrim(Item*,Item*)" -> "Item_func_trim::Item_func_trim(Item*,Item*)"
"Item_func_trim::Item_func_trim(Item*,Item*)" -> "Item_str_func::Item_str_func(Item*,Item*)"
"Item_func_trim::Item_func_trim(Item*,Item*)" -> "String::String()"
"Item_str_func::Item_str_func(Item*,Item*)" -> "Item_func::Item_func(Item*,Item*)"
"Item_func::Item_func(Item*,Item*)" -> "Item_result_field::Item_result_field()"
"List<T>::push_back(T*) [with T = LEX_COLUMN]" -> "base_list::push_back(void*)"
"st_select_lex_unit::is_union()" -> "st_select_lex_unit::first_select()"
"st_select_lex_unit::is_union()" -> "st_select_lex::next_select()"
"Item_func_old_password::Item_func_old_password(Item*)" -> "Item_str_ascii_func::Item_str_ascii_func(Item*)"
"Item_str_ascii_func::Item_str_ascii_func(Item*)" -> "String::String()"
"Item_str_ascii_func::Item_str_ascii_func(Item*)" -> "DTCollation::set_repertoire(uint)"
"Item_str_ascii_func::Item_str_ascii_func(Item*)" -> "Item_str_func::Item_str_func(Item*)"
"Item_func_isfalse::Item_func_isfalse(Item*)" -> "Item_func_truth::Item_func_truth(Item*,bool,bool)"
"Item_func_truth::Item_func_truth(Item*,bool,bool)" -> "Item_bool_func::Item_bool_func(Item*)"
"Item_bool_func::Item_bool_func(Item*)" -> "Item_int_func::Item_int_func(Item*)"
"handle_sql2003_note184_exception(THD*,Item*,bool,Item*)" -> "Item_func_eq::Item_func_eq(Item*,Item*)"
"handle_sql2003_note184_exception(THD*,Item*,bool,Item*)" -> "negate_expression(THD*,Item*)"
"handle_sql2003_note184_exception(THD*,Item*,bool,Item*)" -> "Item_func_ne::Item_func_ne(Item*,Item*)"
"handle_sql2003_note184_exception(THD*,Item*,bool,Item*)" -> "Item_in_subselect::Item_in_subselect(Item*,st_select_lex*)"
"handle_sql2003_note184_exception(THD*,Item*,bool,Item*)" -> "Item_singlerow_subselect::invalidate_and_restore_select_lex()"
"Item_func_eq::Item_func_eq(Item*,Item*)" -> "Item_bool_rowready_func2::Item_bool_rowready_func2(Item*,Item*)"
"Item_bool_rowready_func2::Item_bool_rowready_func2(Item*,Item*)" -> "Item_bool_func2::Item_bool_func2(Item*,Item*)"
"Item_bool_func2::Item_bool_func2(Item*,Item*)" -> "Arg_comparator::Arg_comparator(Item**,Item**)"
"Item_bool_func2::Item_bool_func2(Item*,Item*)" -> "Item_bool_func::Item_bool_func(Item*,Item*)"
"Arg_comparator::Arg_comparator(Item**,Item**)" -> "String::String()"
"Arg_comparator::Arg_comparator(Item**,Item**)" -> "DTCollation::DTCollation()"
"Arg_comparator::Arg_comparator(Item**,Item**)" -> "Sql_alloc::Sql_alloc()"
"Item_bool_func::Item_bool_func(Item*,Item*)" -> "Item_int_func::Item_int_func(Item*,Item*)"
"Item_int_func::Item_int_func(Item*,Item*)" -> "DTCollation::set_numeric()"
"Item_int_func::Item_int_func(Item*,Item*)" -> "Item::fix_char_length(uint32)"
"Item_int_func::Item_int_func(Item*,Item*)" -> "Item_func::Item_func(Item*,Item*)"
"negate_expression(THD*,Item*)" -> "Item_int_0::Item_int_0()"
"negate_expression(THD*,Item*)" -> "Item_func_ne::Item_func_ne(Item*,Item*)"
"negate_expression(THD*,Item*)" -> "Item_func_not::Item_func_not(Item*)"
"negate_expression(THD*,Item*)" -> "Item_func::arguments() const"
"Item_int_0::Item_int_0()" -> "Item_int::Item_int(const Name_string&,longlong,uint)"
"Item_int_0::Item_int_0()" -> "Name_string::Name_string(const char*,size_t)"
"Item_int::Item_int(const Name_string&,longlong,uint)" -> "__builtin_memcpy(void*,const void*,long unsigned int)"
"Item_int::Item_int(const Name_string&,longlong,uint)" -> "Item_name_string::Item_name_string(Name_string)"
"Item_int::Item_int(const Name_string&,longlong,uint)" -> "Item_num::Item_num()"
"Item_num::Item_num()" -> "Item_basic_constant::Item_basic_constant()"
"Item_num::Item_num()" -> "DTCollation::set_numeric()"
"Item_basic_constant::Item_basic_constant()" -> "Item::Item()"
"Name_string::Name_string(const char*,size_t)" -> "Simple_cstring::Simple_cstring(const char*,size_t)"
"Simple_cstring::Simple_cstring(const char*,size_t)" -> "Simple_cstring::set(const char*,size_t)"
"Item_func_ne::Item_func_ne(Item*,Item*)" -> "Item_bool_rowready_func2::Item_bool_rowready_func2(Item*,Item*)"
"Item_func_not::Item_func_not(Item*)" -> "Item_bool_func::Item_bool_func(Item*)"
"Item_in_subselect::Item_in_subselect(Item*,st_select_lex*)" -> "select_exists_subselect::select_exists_subselect(Item_subselect*)"
"Item_in_subselect::Item_in_subselect(Item*,st_select_lex*)" -> "Item_subselect::init(st_select_lex*,select_result_interceptor*)"
"Item_in_subselect::Item_in_subselect(Item*,st_select_lex*)" -> "Item_in_subselect::test_limit(st_select_lex_unit*)"
"Item_in_subselect::Item_in_subselect(Item*,st_select_lex*)" -> "Item_in_subselect::reset()"
"Item_in_subselect::Item_in_subselect(Item*,st_select_lex*)" -> "Item_exists_subselect::Item_exists_subselect()"
"select_exists_subselect::select_exists_subselect(Item_subselect*)" -> "select_subselect::select_subselect(Item_subselect*)"
"select_subselect::select_subselect(Item_subselect*)" -> "select_result_interceptor::select_result_interceptor()"
"select_result_interceptor::select_result_interceptor()" -> "select_result::select_result()"
"select_result::select_result()" -> "_current_thd()"
"select_result::select_result()" -> "Sql_alloc::Sql_alloc()"
"Item_subselect::init(st_select_lex*,select_result_interceptor*)" -> "subselect_single_select_engine::subselect_single_select_engine(st_select_lex*,select_result_interceptor*,Item_subselect*)"
"Item_subselect::init(st_select_lex*,select_result_interceptor*)" -> "subselect_union_engine::subselect_union_engine(st_select_lex_unit*,select_result_interceptor*,Item_subselect*)"
"Item_subselect::init(st_select_lex*,select_result_interceptor*)" -> "st_select_lex_unit::is_union()"
"subselect_single_select_engine::subselect_single_select_engine(st_select_lex*,select_result_interceptor*,Item_subselect*)" -> "subselect_engine::subselect_engine(Item_subselect*,select_result_interceptor*)"
"subselect_engine::subselect_engine(Item_subselect*,select_result_interceptor*)" -> "Sql_alloc::Sql_alloc()"
"subselect_union_engine::subselect_union_engine(st_select_lex_unit*,select_result_interceptor*,Item_subselect*)" -> "subselect_engine::subselect_engine(Item_subselect*,select_result_interceptor*)"
"Item_in_subselect::test_limit(st_select_lex_unit*)" -> "st_select_lex::test_limit()"
"Item_in_subselect::test_limit(st_select_lex_unit*)" -> "st_select_lex::next_select()"
"Item_in_subselect::test_limit(st_select_lex_unit*)" -> "st_select_lex_unit::first_select()"
"st_select_lex::test_limit()" -> "my_error(int,myf,...)"
"Item_exists_subselect::Item_exists_subselect()" -> "Item_subselect::Item_subselect()"
"Item_subselect::Item_subselect()" -> "Item_subselect::reset()"
"Item_subselect::Item_subselect()" -> "Item_result_field::Item_result_field()"
"Item_singlerow_subselect::invalidate_and_restore_select_lex()" -> "st_select_lex_unit::first_select()"
"st_alter_tablespace::st_alter_tablespace()" -> "Sql_alloc::Sql_alloc()"
"Item_char_typecast::Item_char_typecast(Item*,int,const CHARSET_INFO*)" -> "String::String()"
"Item_char_typecast::Item_char_typecast(Item*,int,const CHARSET_INFO*)" -> "Item_str_func::Item_str_func(Item*)"
"Sql_cmd_alter_table_analyze_partition::Sql_cmd_alter_table_analyze_partition()" -> "Sql_cmd_analyze_table::Sql_cmd_analyze_table()"
"Sql_cmd_analyze_table::Sql_cmd_analyze_table()" -> "Sql_cmd::Sql_cmd()"
"Sql_cmd::Sql_cmd()" -> "Sql_alloc::Sql_alloc()"
"sp_instr_stmt::sp_instr_stmt(uint,LEX*,LEX_STRING)" -> "LEX::get_sp_current_parsing_ctx()"
"sp_instr_stmt::sp_instr_stmt(uint,LEX*,LEX_STRING)" -> "sp_lex_instr::sp_lex_instr(uint,sp_pcontext*,LEX*,bool)"
"sp_lex_instr::sp_lex_instr(uint,sp_pcontext*,LEX*,bool)" -> "memset(void*,int,size_t)"
"sp_lex_instr::sp_lex_instr(uint,sp_pcontext*,LEX*,bool)" -> "sp_lex_instr::set_lex(LEX*,bool)"
"sp_lex_instr::sp_lex_instr(uint,sp_pcontext*,LEX*,bool)" -> "sp_instr::sp_instr(uint,sp_pcontext*)"
"sp_lex_instr::sp_lex_instr(uint,sp_pcontext*,LEX*,bool)" -> "SQL_I_List<T>::SQL_I_List() [with T = Item_trigger_field]"
"sp_lex_instr::set_lex(LEX*,bool)" -> "sp_lex_instr::free_lex()"
"sp_lex_instr::free_lex()" -> "lex_end(LEX*)"
"lex_end(LEX*)" -> "plugin_unlock_list(THD*,st_plugin_int**,uint)"
"SQL_I_List<T>::SQL_I_List() [with T = Item_trigger_field]" -> "Sql_alloc::Sql_alloc()"
"SQL_I_List<T>::SQL_I_List() [with T = Item_trigger_field]" -> "SQL_I_List<T>::empty() [with T = Item_trigger_field]"
"case_stmt_action_case(THD*)" -> "sp_head::instructions()"
"case_stmt_action_case(THD*)" -> "sp_pcontext::push_label(THD*,LEX_STRING,uint)"
"case_stmt_action_case(THD*)" -> "LEX::get_sp_current_parsing_ctx()"
"case_stmt_action_case(THD*)" -> "sp_parser_data::new_cont_backpatch()"
"sp_head::instructions()" -> "Dynamic_array<Elem>::elements() const [with Elem = sp_instr*]"
"sp_pcontext::push_label(THD*,LEX_STRING,uint)" -> "List<T>::push_front(T*) [with T = sp_label]"
"sp_pcontext::push_label(THD*,LEX_STRING,uint)" -> "sp_label::sp_label(LEX_STRING,uint,sp_label::enum_type,sp_pcontext*)"
"List<T>::push_front(T*) [with T = sp_label]" -> "base_list::push_front(void*)"
"sp_label::sp_label(LEX_STRING,uint,sp_label::enum_type,sp_pcontext*)" -> "Sql_alloc::Sql_alloc()"
"sp_pcontext::push_context(THD*,sp_pcontext::enum_scope)" -> "Dynamic_array<Elem>::append(const Elem&) [with Elem = sp_pcontext*]"
"sp_pcontext::push_context(THD*,sp_pcontext::enum_scope)" -> "sp_pcontext::sp_pcontext(sp_pcontext*,sp_pcontext::enum_scope)"
"Dynamic_array<Elem>::append(const Elem&) [with Elem = sp_pcontext*]" -> "insert_dynamic(DYNAMIC_ARRAY*,const void*)"
"sp_pcontext::sp_pcontext(sp_pcontext*,sp_pcontext::enum_scope)" -> "Sql_alloc::Sql_alloc()"
"sp_pcontext::sp_pcontext(sp_pcontext*,sp_pcontext::enum_scope)" -> "Dynamic_array<Elem>::Dynamic_array(uint,uint) [with Elem = st_mysql_lex_string,uint = unsigned int]"
"sp_pcontext::sp_pcontext(sp_pcontext*,sp_pcontext::enum_scope)" -> "Dynamic_array<Elem>::Dynamic_array(uint,uint) [with Elem = sp_variable*,uint = unsigned int]"
"sp_pcontext::sp_pcontext(sp_pcontext*,sp_pcontext::enum_scope)" -> "List<T>::List() [with T = sp_label]"
"sp_pcontext::sp_pcontext(sp_pcontext*,sp_pcontext::enum_scope)" -> "Dynamic_array<Elem>::Dynamic_array(uint,uint) [with Elem = sp_handler*,uint = unsigned int]"
"sp_pcontext::sp_pcontext(sp_pcontext*,sp_pcontext::enum_scope)" -> "Dynamic_array<Elem>::Dynamic_array(uint,uint) [with Elem = int,uint = unsigned int]"
"sp_pcontext::sp_pcontext(sp_pcontext*,sp_pcontext::enum_scope)" -> "Dynamic_array<Elem>::Dynamic_array(uint,uint) [with Elem = sp_pcontext*,uint = unsigned int]"
"sp_pcontext::sp_pcontext(sp_pcontext*,sp_pcontext::enum_scope)" -> "sp_pcontext::get_num_case_exprs() const"
"sp_pcontext::sp_pcontext(sp_pcontext*,sp_pcontext::enum_scope)" -> "sp_pcontext::init(uint,uint,int)"
"sp_pcontext::sp_pcontext(sp_pcontext*,sp_pcontext::enum_scope)" -> "sp_pcontext::current_cursor_count() const"
"sp_pcontext::sp_pcontext(sp_pcontext*,sp_pcontext::enum_scope)" -> "Dynamic_array<Elem>::Dynamic_array(uint,uint) [with Elem = sp_condition*,uint = unsigned int]"
"Dynamic_array<Elem>::Dynamic_array(uint,uint) [with Elem = st_mysql_lex_string,uint = unsigned int]" -> "Dynamic_array<Elem>::init(uint,uint) [with Elem = st_mysql_lex_string,uint = unsigned int]"
"Dynamic_array<Elem>::init(uint,uint) [with Elem = st_mysql_lex_string,uint = unsigned int]" -> "init_dynamic_array2(DYNAMIC_ARRAY*,uint,void*,uint,uint)"
"Dynamic_array<Elem>::Dynamic_array(uint,uint) [with Elem = sp_variable*,uint = unsigned int]" -> "Dynamic_array<Elem>::init(uint,uint) [with Elem = sp_variable*,uint = unsigned int]"
"Dynamic_array<Elem>::init(uint,uint) [with Elem = sp_variable*,uint = unsigned int]" -> "init_dynamic_array2(DYNAMIC_ARRAY*,uint,void*,uint,uint)"
"List<T>::List() [with T = sp_label]" -> "base_list::base_list()"
"Dynamic_array<Elem>::Dynamic_array(uint,uint) [with Elem = sp_handler*,uint = unsigned int]" -> "Dynamic_array<Elem>::init(uint,uint) [with Elem = sp_handler*,uint = unsigned int]"
"Dynamic_array<Elem>::init(uint,uint) [with Elem = sp_handler*,uint = unsigned int]" -> "init_dynamic_array2(DYNAMIC_ARRAY*,uint,void*,uint,uint)"
"Dynamic_array<Elem>::Dynamic_array(uint,uint) [with Elem = int,uint = unsigned int]" -> "Dynamic_array<Elem>::init(uint,uint) [with Elem = int,uint = unsigned int]"
"Dynamic_array<Elem>::init(uint,uint) [with Elem = int,uint = unsigned int]" -> "init_dynamic_array2(DYNAMIC_ARRAY*,uint,void*,uint,uint)"
"Dynamic_array<Elem>::Dynamic_array(uint,uint) [with Elem = sp_pcontext*,uint = unsigned int]" -> "Dynamic_array<Elem>::init(uint,uint) [with Elem = sp_pcontext*,uint = unsigned int]"
"Dynamic_array<Elem>::init(uint,uint) [with Elem = sp_pcontext*,uint = unsigned int]" -> "init_dynamic_array2(DYNAMIC_ARRAY*,uint,void*,uint,uint)"
"sp_pcontext::init(uint,uint,int)" -> "base_list::empty()"
"sp_pcontext::current_cursor_count() const" -> "Dynamic_array<Elem>::elements() const [with Elem = st_mysql_lex_string]"
"Dynamic_array<Elem>::Dynamic_array(uint,uint) [with Elem = sp_condition*,uint = unsigned int]" -> "Dynamic_array<Elem>::init(uint,uint) [with Elem = sp_condition*,uint = unsigned int]"
"Dynamic_array<Elem>::init(uint,uint) [with Elem = sp_condition*,uint = unsigned int]" -> "init_dynamic_array2(DYNAMIC_ARRAY*,uint,void*,uint,uint)"
"Sql_cmd_optimize_table::Sql_cmd_optimize_table()" -> "Sql_cmd::Sql_cmd()"
"Item_func_second::Item_func_second(Item*)" -> "Item_int_func::Item_int_func(Item*)"
"sp_instr_cfetch::add_to_varlist(sp_variable*)" -> "List<T>::push_back(T*) [with T = sp_variable]"
"List<T>::push_back(T*) [with T = sp_variable]" -> "base_list::push_back(void*)"
"case_stmt_action_then(THD*,LEX*)" -> "sp_pcontext::last_label()"
"case_stmt_action_then(THD*,LEX*)" -> "sp_head::instructions()"
"case_stmt_action_then(THD*,LEX*)" -> "sp_instr_jump::sp_instr_jump(uint,sp_pcontext*)"
"case_stmt_action_then(THD*,LEX*)" -> "sp_pcontext::pop_label()"
"case_stmt_action_then(THD*,LEX*)" -> "LEX::get_sp_current_parsing_ctx()"
"case_stmt_action_then(THD*,LEX*)" -> "sp_parser_data::add_backpatch_entry(sp_branch_instr*,sp_label*)"
"case_stmt_action_then(THD*,LEX*)" -> "sp_parser_data::do_backpatch(sp_label*,uint)"
"case_stmt_action_then(THD*,LEX*)" -> "sp_head::add_instr(THD*,sp_instr*)"
"sp_pcontext::last_label()" -> "sp_pcontext::last_label()"
"sp_pcontext::last_label()" -> "List<T>::head() [with T = sp_label]"
"List<T>::head() [with T = sp_label]" -> "base_list::head()"
"sp_pcontext::pop_label()" -> "List<T>::pop() [with T = sp_label]"
"List<T>::pop() [with T = sp_label]" -> "base_list::pop()"
"sp_parser_data::add_backpatch_entry(sp_branch_instr*,sp_label*)" -> "List<T>::push_front(T*) [with T = sp_parser_data::Backpatch_info]"
"sp_parser_data::add_backpatch_entry(sp_branch_instr*,sp_label*)" -> "sql_alloc(size_t)"
"List<T>::push_front(T*) [with T = sp_parser_data::Backpatch_info]" -> "base_list::push_front(void*)"
"sql_alloc(size_t)" -> "alloc_root(MEM_ROOT*,size_t)"
"sql_alloc(size_t)" -> "pthread_getspecific(pthread_key_t)"
"sp_parser_data::do_backpatch(sp_label*,uint)" -> "List_iterator_fast<T>::List_iterator_fast(List<T>&) [with T = sp_parser_data::Backpatch_info]"
"sp_parser_data::do_backpatch(sp_label*,uint)" -> "List_iterator_fast<T>::operator++(int) [with T = sp_parser_data::Backpatch_info]"
"List_iterator_fast<T>::List_iterator_fast(List<T>&) [with T = sp_parser_data::Backpatch_info]" -> "base_list_iterator::base_list_iterator(base_list&)"
"List_iterator_fast<T>::operator++(int) [with T = sp_parser_data::Backpatch_info]" -> "base_list_iterator::next_fast()"
"sp_head::add_instr(THD*,sp_instr*)" -> "SQL_I_List<T>::link_in_list(T*,T**) [with T = SQL_I_List<Item_trigger_field>]"
"sp_head::add_instr(THD*,sp_instr*)" -> "Dynamic_array<Elem>::append(const Elem&) [with Elem = sp_instr*]"
"sp_head::add_instr(THD*,sp_instr*)" -> "SQL_I_List<T>::save_and_clear(SQL_I_List<T>*) [with T = Item_trigger_field]"
"sp_head::add_instr(THD*,sp_instr*)" -> "sp_parser_data::process_new_sp_instr(THD*,sp_instr*)"
"sp_head::add_instr(THD*,sp_instr*)" -> "sp_head::get_persistent_mem_root() const"
"Dynamic_array<Elem>::append(const Elem&) [with Elem = sp_instr*]" -> "insert_dynamic(DYNAMIC_ARRAY*,const void*)"
"SQL_I_List<T>::save_and_clear(SQL_I_List<T>*) [with T = Item_trigger_field]" -> "SQL_I_List<T>::empty() [with T = Item_trigger_field]"
"Table_ident::Table_ident(LEX_STRING)" -> "Sql_alloc::Sql_alloc()"
"sp_pcontext::find_variable(LEX_STRING,bool) const" -> "Dynamic_array<Elem>::at(int) const [with Elem = sp_variable*]"
"sp_pcontext::find_variable(LEX_STRING,bool) const" -> "Dynamic_array<Elem>::elements() const [with Elem = sp_variable*]"
"sp_pcontext::find_variable(LEX_STRING,bool) const" -> "sp_pcontext::find_variable(LEX_STRING,bool) const"
"ha_default_temp_handlerton(THD*)" -> "ha_default_temp_plugin(THD*)"
"Proc_analyse_params::Proc_analyse_params()" -> "Sql_alloc::Sql_alloc()"
"Item_func_plus::Item_func_plus(Item*,Item*)" -> "Item_func_additive_op::Item_func_additive_op(Item*,Item*)"
"Item_func_additive_op::Item_func_additive_op(Item*,Item*)" -> "Item_num_op::Item_num_op(Item*,Item*)"
"Item_num_op::Item_num_op(Item*,Item*)" -> "Item_func_numhybrid::Item_func_numhybrid(Item*,Item*)"
"Item_func_numhybrid::Item_func_numhybrid(Item*,Item*)" -> "Item_func::Item_func(Item*,Item*)"
"Item_func_numhybrid::Item_func_numhybrid(Item*,Item*)" -> "DTCollation::set_numeric()"
"Item_func_reverse::Item_func_reverse(Item*)" -> "Item_str_func::Item_str_func(Item*)"
"Item_func_reverse::Item_func_reverse(Item*)" -> "String::String()"
"sp_instr_jump_if_not::sp_instr_jump_if_not(uint,LEX*,Item*,LEX_STRING)" -> "sp_lex_branch_instr::sp_lex_branch_instr(uint,sp_pcontext*,LEX*,Item*,LEX_STRING)"
"sp_instr_jump_if_not::sp_instr_jump_if_not(uint,LEX*,Item*,LEX_STRING)" -> "LEX::get_sp_current_parsing_ctx()"
"sp_lex_branch_instr::sp_lex_branch_instr(uint,sp_pcontext*,LEX*,Item*,LEX_STRING)" -> "sp_lex_instr::sp_lex_instr(uint,sp_pcontext*,LEX*,bool)"
"sp_lex_branch_instr::sp_lex_branch_instr(uint,sp_pcontext*,LEX*,Item*,LEX_STRING)" -> "sp_branch_instr::sp_branch_instr()"
"prepare_schema_table(THD*,LEX*,Table_ident*,enum_schema_tables)" -> "strlen(const char*)"
"prepare_schema_table(THD*,LEX*,Table_ident*,enum_schema_tables)" -> "PROFILING::discard_current_query()"
"prepare_schema_table(THD*,LEX*,Table_ident*,enum_schema_tables)" -> "make_schema_select(THD*,SELECT_LEX*,enum_schema_tables)"
"prepare_schema_table(THD*,LEX*,Table_ident*,enum_schema_tables)" -> "st_select_lex::st_select_lex()"
"prepare_schema_table(THD*,LEX*,Table_ident*,enum_schema_tables)" -> "check_and_convert_db_name(LEX_STRING*,bool)"
"prepare_schema_table(THD*,LEX*,Table_ident*,enum_schema_tables)" -> "LEX::copy_db_to(char**,size_t*) const"
"make_schema_select(THD*,SELECT_LEX*,enum_schema_tables)" -> "Table_ident::Table_ident(THD*,LEX_STRING,LEX_STRING,bool)"
"make_schema_select(THD*,SELECT_LEX*,enum_schema_tables)" -> "get_schema_table(enum_schema_tables)"
"make_schema_select(THD*,SELECT_LEX*,enum_schema_tables)" -> "THD::make_lex_string(LEX_STRING*,const char*,uint,bool)"
"make_schema_select(THD*,SELECT_LEX*,enum_schema_tables)" -> "strlen(const char*)"
"Table_ident::Table_ident(THD*,LEX_STRING,LEX_STRING,bool)" -> "Sql_alloc::Sql_alloc()"
"THD::make_lex_string(LEX_STRING*,const char*,uint,bool)" -> "make_lex_string_root(MEM_ROOT*,LEX_STRING*,const char*,uint,bool)"
"make_lex_string_root(MEM_ROOT*,LEX_STRING*,const char*,uint,bool)" -> "strmake_root(MEM_ROOT*,const char*,size_t)"
"make_lex_string_root(MEM_ROOT*,LEX_STRING*,const char*,uint,bool)" -> "alloc_root(MEM_ROOT*,size_t)"
"LEX::copy_db_to(char**,size_t*) const" -> "THD::copy_db_to(char**,size_t*)"
"THD::copy_db_to(char**,size_t*)" -> "_current_thd()"
"THD::copy_db_to(char**,size_t*)" -> "Query_arena::strmake(const char*,size_t)"
"THD::copy_db_to(char**,size_t*)" -> "my_message(uint,const char*,myf)"
"Query_arena::strmake(const char*,size_t)" -> "strmake_root(MEM_ROOT*,const char*,size_t)"
"my_parse_error(const char*)" -> "Lex_input_stream::get_tok_start()"
"my_parse_error(const char*)" -> "_current_thd()"
"my_parse_error(const char*)" -> "my_printf_error(uint,const char*,myf,...)"
"my_parse_error(const char*)" -> "ErrConvString::ptr()"
"my_parse_error(const char*)" -> "ErrConvString::ErrConvString(const char*,const CHARSET_INFO*)"
"ErrConvString::ErrConvString(const char*,const CHARSET_INFO*)" -> "strlen(const char*)"
"ErrConvString::ErrConvString(const char*,const CHARSET_INFO*)" -> "err_conv(char*,size_t,const char*,size_t,const CHARSET_INFO*)"
"err_conv(char*,size_t,const char*,size_t,const CHARSET_INFO*)" -> "copy_and_convert(char*,uint32,const CHARSET_INFO*,const char*,uint32,const CHARSET_INFO*,uint*)"
"err_conv(char*,size_t,const char*,size_t,const CHARSET_INFO*)" -> "my_snprintf(char*,size_t,const char*,...)"
"get_old_charset_by_name(const char*)" -> "get_charset_by_csname(const char*,uint,myf)"
"Item_func_div::Item_func_div(Item*,Item*)" -> "Item_num_op::Item_num_op(Item*,Item*)"
"partition_info::partition_info()" -> "List<T>::List() [with T = partition_element]"
"partition_info::partition_info()" -> "Bitmap<64u>::Bitmap()"
"partition_info::partition_info()" -> "List<T>::List() [with T = char]"
"partition_info::partition_info()" -> "base_list::empty()"
"partition_info::partition_info()" -> "Sql_alloc::Sql_alloc()"
"List<T>::List() [with T = partition_element]" -> "base_list::base_list()"
"Item_trigger_field::Item_trigger_field(Name_resolution_context*,Item_trigger_field::row_version_type,const char*,ulong,bool)" -> "Settable_routine_parameter::Settable_routine_parameter()"
"Item_trigger_field::Item_trigger_field(Name_resolution_context*,Item_trigger_field::row_version_type,const char*,ulong,bool)" -> "Item_field::Item_field(Name_resolution_context*,const char*,const char*,const char*)"
"Item_field::Item_field(Name_resolution_context*,const char*,const char*,const char*)" -> "_current_thd()"
"Item_field::Item_field(Name_resolution_context*,const char*,const char*,const char*)" -> "DTCollation::set(Derivation)"
"Item_field::Item_field(Name_resolution_context*,const char*,const char*,const char*)" -> "Item_ident::Item_ident(Name_resolution_context*,const char*,const char*,const char*)"
"Item_ident::Item_ident(Name_resolution_context*,const char*,const char*,const char*)" -> "Simple_cstring::set(const char*)"
"Item_ident::Item_ident(Name_resolution_context*,const char*,const char*,const char*)" -> "Item::Item()"
"Simple_cstring::set(const char*)" -> "strlen(const char*)"
"Simple_cstring::set(const char*)" -> "Simple_cstring::set(const char*,size_t)"
"Item_func_mod::Item_func_mod(Item*,Item*)" -> "Item_num_op::Item_num_op(Item*,Item*)"
"Item_func_bit_and::Item_func_bit_and(Item*,Item*)" -> "Item_func_bit::Item_func_bit(Item*,Item*)"
"Item_func_bit::Item_func_bit(Item*,Item*)" -> "Item_int_func::Item_int_func(Item*,Item*)"
"sql_exchange::sql_exchange(char*,bool,enum_filetype)" -> "Sql_alloc::Sql_alloc()"
"ErrConvString::ErrConvString(String*)" -> "err_conv(char*,size_t,const char*,size_t,const CHARSET_INFO*)"
"ErrConvString::ErrConvString(String*)" -> "String::ptr() const"
"ErrConvString::ErrConvString(String*)" -> "String::charset() const"
"ErrConvString::ErrConvString(String*)" -> "String::length() const"
"st_lex_master_info::set_unspecified()" -> "memset(void*,int,size_t)"
"sp_instr_hpush_jump::add_condition(sp_condition_value*)" -> "List<T>::push_back(T*) [with T = sp_condition_value]"
"List<T>::push_back(T*) [with T = sp_condition_value]" -> "base_list::push_back(void*)"
"sp_pcontext::diff_handlers(const sp_pcontext*,bool) const" -> "Dynamic_array<Elem>::elements() const [with Elem = sp_handler*]"
"sp_pcontext::diff_handlers(const sp_pcontext*,bool) const" -> "sp_pcontext::parent_context() const"
"sp_add_used_routine(Query_tables_list*,Query_arena*,sp_name*,enum_sp_type)" -> "MDL_key::MDL_key(MDL_key::enum_mdl_namespace,const char*,const char*)"
"sp_add_used_routine(Query_tables_list*,Query_arena*,sp_name*,enum_sp_type)" -> "sp_add_used_routine(Query_tables_list*,Query_arena*,const MDL_key*,TABLE_LIST*)"
"MDL_key::MDL_key(MDL_key::enum_mdl_namespace,const char*,const char*)" -> "MDL_key::mdl_key_init(MDL_key::enum_mdl_namespace,const char*,const char*)"
"sp_add_used_routine(Query_tables_list*,Query_arena*,const MDL_key*,TABLE_LIST*)" -> "Query_arena::alloc(size_t)"
"sp_add_used_routine(Query_tables_list*,Query_arena*,const MDL_key*,TABLE_LIST*)" -> "my_hash_search(const HASH*,const uchar*,size_t)"
"sp_add_used_routine(Query_tables_list*,Query_arena*,const MDL_key*,TABLE_LIST*)" -> "SQL_I_List<T>::link_in_list(T*,T**) [with T = Sroutine_hash_entry]"
"sp_add_used_routine(Query_tables_list*,Query_arena*,const MDL_key*,TABLE_LIST*)" -> "my_hash_insert(HASH*,const uchar*)"
"sp_add_used_routine(Query_tables_list*,Query_arena*,const MDL_key*,TABLE_LIST*)" -> "MDL_request::init(const MDL_key*,enum_mdl_type,enum_mdl_duration)"
"sp_add_used_routine(Query_tables_list*,Query_arena*,const MDL_key*,TABLE_LIST*)" -> "_my_hash_init(HASH*,uint,CHARSET_INFO*,my_hash_function,ulong,size_t,size_t,my_hash_get_key,void (*)(void*),uint)"
"sp_add_used_routine(Query_tables_list*,Query_arena*,const MDL_key*,TABLE_LIST*)" -> "MDL_key::ptr() const"
"sp_add_used_routine(Query_tables_list*,Query_arena*,const MDL_key*,TABLE_LIST*)" -> "MDL_key::length() const"
"List<T>::push_back(T*) [with T = Key]" -> "base_list::push_back(void*)"
"Item_func_hour::Item_func_hour(Item*)" -> "Item_int_func::Item_int_func(Item*)"
"sp_head::last_instruction()" -> "Dynamic_array<Elem>::back() [with Elem = sp_instr*]"
"Item_func_group_concat::Item_func_group_concat(Name_resolution_context*,bool,List<Item>*,const SQL_I_List<st_order>&,String*)" -> "sql_alloc(size_t)"
"Item_func_group_concat::Item_func_group_concat(Name_resolution_context*,bool,List<Item>*,const SQL_I_List<st_order>&,String*)" -> "Item_sum::Item_sum()"
"Item_func_group_concat::Item_func_group_concat(Name_resolution_context*,bool,List<Item>*,const SQL_I_List<st_order>&,String*)" -> "List_iterator_fast<T>::operator++(int) [with T = Item]"
"Item_func_group_concat::Item_func_group_concat(Name_resolution_context*,bool,List<Item>*,const SQL_I_List<st_order>&,String*)" -> "String::String()"
"Item_func_group_concat::Item_func_group_concat(Name_resolution_context*,bool,List<Item>*,const SQL_I_List<st_order>&,String*)" -> "memcpy(void*,const void*,size_t)"
"Item_func_group_concat::Item_func_group_concat(Name_resolution_context*,bool,List<Item>*,const SQL_I_List<st_order>&,String*)" -> "List_iterator_fast<T>::List_iterator_fast(List<T>&) [with T = Item]"
"Item_sum::Item_sum()" -> "Item_sum::init_aggregator()"
"Item_sum::Item_sum()" -> "List<T>::List() [with T = Item_field]"
"Item_sum::Item_sum()" -> "Item_result_field::Item_result_field()"
"Item_sum::Item_sum()" -> "Item_sum::mark_as_sum_func()"
"Item_sum::mark_as_sum_func()" -> "_current_thd()"
"List_iterator_fast<T>::operator++(int) [with T = Item]" -> "base_list_iterator::next_fast()"
"List_iterator_fast<T>::List_iterator_fast(List<T>&) [with T = Item]" -> "base_list_iterator::base_list_iterator(base_list&)"
"Item_func_password::create_password_hash_buffer(THD*,const char*,size_t)" -> "Query_arena::alloc(size_t)"
"Item_func_password::create_password_hash_buffer(THD*,const char*,size_t)" -> "check_password_policy(String*)"
"Item_func_password::create_password_hash_buffer(THD*,const char*,size_t)" -> "my_make_scrambled_password_sha1(char*,const char*,size_t)"
"Item_func_password::create_password_hash_buffer(THD*,const char*,size_t)" -> "String::String(const char*,const CHARSET_INFO*)"
"Item_func_add_time::Item_func_add_time(Item*,Item*,bool,bool)" -> "Item_temporal_hybrid_func::Item_temporal_hybrid_func(Item*,Item*)"
"Item_temporal_hybrid_func::Item_temporal_hybrid_func(Item*,Item*)" -> "String::String()"
"Item_temporal_hybrid_func::Item_temporal_hybrid_func(Item*,Item*)" -> "Item_str_func::Item_str_func(Item*,Item*)"
"Item_func_spatial_mbr_rel::Item_func_spatial_mbr_rel(Item*,Item*,Item_func::Functype)" -> "Item_bool_func2::Item_bool_func2(Item*,Item*)"
"is_native_function(THD*,const LEX_STRING*)" -> "is_lex_native_function(const LEX_STRING*)"
"is_native_function(THD*,const LEX_STRING*)" -> "find_native_function_builder(THD*,LEX_STRING)"
"is_lex_native_function(const LEX_STRING*)" -> "get_hash_symbol(const char*,unsigned int,bool)"
"find_native_function_builder(THD*,LEX_STRING)" -> "my_hash_search(const HASH*,const uchar*,size_t)"
"set_var_password::set_var_password(LEX_USER*,char*)" -> "set_var_base::set_var_base()"
"set_var_base::set_var_base()" -> "Sql_alloc::Sql_alloc()"
"Sql_cmd_resignal::Sql_cmd_resignal(const sp_condition_value*,const Set_signal_information&)" -> "Sql_cmd_common_signal::Sql_cmd_common_signal(const sp_condition_value*,const Set_signal_information&)"
"Sql_cmd_common_signal::Sql_cmd_common_signal(const sp_condition_value*,const Set_signal_information&)" -> "Sql_cmd::Sql_cmd()"
"Sql_cmd_common_signal::Sql_cmd_common_signal(const sp_condition_value*,const Set_signal_information&)" -> "Set_signal_information::Set_signal_information(const Set_signal_information&)"
"Set_signal_information::Set_signal_information(const Set_signal_information&)" -> "memcpy(void*,const void*,size_t)"
"List<T>::push_back(T*) [with T = Item_func_set_user_var]" -> "base_list::push_back(void*)"
"sp_create_assignment_lex(THD*,const char*)" -> "base_list::empty()"
"sp_create_assignment_lex(THD*,const char*)" -> "sp_parser_data::set_current_stmt_start_ptr(const char*)"
"sp_create_assignment_lex(THD*,const char*)" -> "sp_head::is_invoked() const"
"sp_create_assignment_lex(THD*,const char*)" -> "sp_head::reset_lex(THD*)"
"sp_create_assignment_lex(THD*,const char*)" -> "mysql_init_select(LEX*)"
"sp_create_assignment_lex(THD*,const char*)" -> "sp_parser_data::set_option_start_ptr(const char*)"
"sp_head::reset_lex(THD*)" -> "base_list::empty()"
"sp_head::reset_lex(THD*)" -> "st_lex_local::st_lex_local()"
"sp_head::reset_lex(THD*)" -> "LEX::get_sp_current_parsing_ctx()"
"sp_head::reset_lex(THD*)" -> "LEX::set_sp_current_parsing_ctx(sp_pcontext*)"
"sp_head::reset_lex(THD*)" -> "Yacc_state::reset_before_substatement()"
"sp_head::reset_lex(THD*)" -> "sp_parser_data::push_lex(LEX*)"
"sp_head::reset_lex(THD*)" -> "lex_start(THD*)"
"st_lex_local::st_lex_local()" -> "LEX::LEX()"
"sp_parser_data::push_lex(LEX*)" -> "List<T>::push_front(T*) [with T = LEX]"
"List<T>::push_front(T*) [with T = LEX]" -> "base_list::push_front(void*)"
"Item_sum_std::Item_sum_std(Item*,uint)" -> "Item_sum_variance::Item_sum_variance(Item*,uint)"
"Item_sum_variance::Item_sum_variance(Item*,uint)" -> "Item_sum_num::Item_sum_num(Item*)"
"Item_sum_num::Item_sum_num(Item*)" -> "Item_sum::Item_sum(Item*)"
"Item_sum::Item_sum(Item*)" -> "Item_sum::mark_as_sum_func()"
"Item_sum::Item_sum(Item*)" -> "Item_result_field::Item_result_field()"
"Item_sum::Item_sum(Item*)" -> "Item_sum::init_aggregator()"
"Item_sum::Item_sum(Item*)" -> "List<T>::List() [with T = Item_field]"
"partition_info::add_max_value()" -> "partition_info::add_column_value()"
"partition_info::add_column_value()" -> "partition_info::add_column_value()"
"partition_info::add_column_value()" -> "partition_info::reorganize_into_single_field_col_val()"
"partition_info::add_column_value()" -> "partition_info::init_column_part()"
"partition_info::add_column_value()" -> "my_error(int,myf,...)"
"partition_info::reorganize_into_single_field_col_val()" -> "partition_info::init_col_val(part_column_list_val*,Item*)"
"partition_info::reorganize_into_single_field_col_val()" -> "memcpy(void*,const void*,size_t)"
"partition_info::reorganize_into_single_field_col_val()" -> "partition_info::add_column_value()"
"partition_info::reorganize_into_single_field_col_val()" -> "partition_info::init_column_part()"
"partition_info::init_column_part()" -> "List<T>::push_back(T*) [with T = p_elem_val]"
"partition_info::init_column_part()" -> "mem_alloc_error(size_t)"
"partition_info::init_column_part()" -> "sql_calloc(size_t)"
"List<T>::push_back(T*) [with T = p_elem_val]" -> "base_list::push_back(void*)"
"mem_alloc_error(size_t)" -> "my_error(int,myf,...)"
"sql_calloc(size_t)" -> "memset(void*,int,size_t)"
"sql_calloc(size_t)" -> "sql_alloc(size_t)"
"Item_func_ascii::Item_func_ascii(Item*)" -> "String::String()"
"Item_func_ascii::Item_func_ascii(Item*)" -> "Item_int_func::Item_int_func(Item*)"
"sp_instr_cclose::sp_instr_cclose(uint,sp_pcontext*,int)" -> "sp_instr::sp_instr(uint,sp_pcontext*)"
"List<T>::push_back(T*) [with T = my_var]" -> "base_list::push_back(void*)"
"Item_func_trim::Item_func_trim(Item*)" -> "Item_str_func::Item_str_func(Item*)"
"Item_func_trim::Item_func_trim(Item*)" -> "String::String()"
"Item_func_year::Item_func_year(Item*)" -> "Item_int_func::Item_int_func(Item*)"
"Item_func_timestamp_diff::Item_func_timestamp_diff(Item*,Item*,interval_type)" -> "Item_int_func::Item_int_func(Item*,Item*)"
"List<T>::push_back(T*) [with T = st_mysql_lex_string]" -> "base_list::push_back(void*)"
"sp_parser_data::add_cont_backpatch_entry(sp_lex_branch_instr*)" -> "sp_lex_branch_instr::set_cont_dest(uint)"
"sp_parser_data::add_cont_backpatch_entry(sp_lex_branch_instr*)" -> "List<T>::push_front(T*) [with T = sp_lex_branch_instr]"
"List<T>::push_front(T*) [with T = sp_lex_branch_instr]" -> "base_list::push_front(void*)"
"Item_func_between::Item_func_between(Item*,Item*,Item*)" -> "Arg_comparator::Arg_comparator()"
"Item_func_between::Item_func_between(Item*,Item*,Item*)" -> "DTCollation::DTCollation()"
"Item_func_between::Item_func_between(Item*,Item*,Item*)" -> "Item_func_opt_neg::Item_func_opt_neg(Item*,Item*,Item*)"
"Item_func_between::Item_func_between(Item*,Item*,Item*)" -> "String::String()"
"Arg_comparator::Arg_comparator()" -> "String::String()"
"Arg_comparator::Arg_comparator()" -> "Sql_alloc::Sql_alloc()"
"Arg_comparator::Arg_comparator()" -> "DTCollation::DTCollation()"
"Item_func_opt_neg::Item_func_opt_neg(Item*,Item*,Item*)" -> "Item_int_func::Item_int_func(Item*,Item*,Item*)"
"Item_int_func::Item_int_func(Item*,Item*,Item*)" -> "DTCollation::set_numeric()"
"Item_int_func::Item_int_func(Item*,Item*,Item*)" -> "Item_func::Item_func(Item*,Item*,Item*)"
"Item_int_func::Item_int_func(Item*,Item*,Item*)" -> "Item::fix_char_length(uint32)"
"Item_func::Item_func(Item*,Item*,Item*)" -> "sql_alloc(size_t)"
"Item_func::Item_func(Item*,Item*,Item*)" -> "Item_result_field::Item_result_field()"
"sp_pcontext::add_cursor(LEX_STRING)" -> "Dynamic_array<Elem>::elements() const [with Elem = st_mysql_lex_string]"
"sp_pcontext::add_cursor(LEX_STRING)" -> "Dynamic_array<Elem>::append(const Elem&) [with Elem = st_mysql_lex_string]"
"Dynamic_array<Elem>::append(const Elem&) [with Elem = st_mysql_lex_string]" -> "insert_dynamic(DYNAMIC_ARRAY*,const void*)"
"Item_func_bit_neg::Item_func_bit_neg(Item*)" -> "Item_func_bit::Item_func_bit(Item*)"
"Item_func_bit::Item_func_bit(Item*)" -> "Item_int_func::Item_int_func(Item*)"
"sp_pcontext::find_cursor(LEX_STRING,uint*,bool) const" -> "sp_pcontext::find_cursor(LEX_STRING,uint*,bool) const"
"sp_pcontext::find_cursor(LEX_STRING,uint*,bool) const" -> "Dynamic_array<Elem>::elements() const [with Elem = st_mysql_lex_string]"
"sp_pcontext::find_cursor(LEX_STRING,uint*,bool) const" -> "Dynamic_array<Elem>::at(int) const [with Elem = st_mysql_lex_string]"
"Item_func_concat::Item_func_concat(Item*,Item*)" -> "String::String()"
"Item_func_concat::Item_func_concat(Item*,Item*)" -> "Item_str_func::Item_str_func(Item*,Item*)"
"create_func_cast(THD*,Item*,Cast_target,const char*,const char*,const CHARSET_INFO*)" -> "Item_datetime_typecast::Item_datetime_typecast(Item*,uint8)"
"create_func_cast(THD*,Item*,Cast_target,const char*,const char*,const CHARSET_INFO*)" -> "Item_date_typecast::Item_date_typecast(Item*)"
"create_func_cast(THD*,Item*,Cast_target,const char*,const char*,const CHARSET_INFO*)" -> "Simple_cstring::ptr() const"
"create_func_cast(THD*,Item*,Cast_target,const char*,const char*,const CHARSET_INFO*)" -> "Item_char_typecast::Item_char_typecast(Item*,int,const CHARSET_INFO*)"
"create_func_cast(THD*,Item*,Cast_target,const char*,const char*,const CHARSET_INFO*)" -> "my_decimal_trim(ulong*,uint*)"
"create_func_cast(THD*,Item*,Cast_target,const char*,const char*,const CHARSET_INFO*)" -> "my_error(int,myf,...)"
"create_func_cast(THD*,Item*,Cast_target,const char*,const char*,const CHARSET_INFO*)" -> "Item_func_unsigned::Item_func_unsigned(Item*)"
"create_func_cast(THD*,Item*,Cast_target,const char*,const char*,const CHARSET_INFO*)" -> "Item_func_signed::Item_func_signed(Item*)"
"create_func_cast(THD*,Item*,Cast_target,const char*,const char*,const CHARSET_INFO*)" -> "__errno_location()"
"create_func_cast(THD*,Item*,Cast_target,const char*,const char*,const CHARSET_INFO*)" -> "Item_func_binary::Item_func_binary(Item*)"
"create_func_cast(THD*,Item*,Cast_target,const char*,const char*,const CHARSET_INFO*)" -> "Item_decimal_typecast::Item_decimal_typecast(Item*,int,int)"
"create_func_cast(THD*,Item*,Cast_target,const char*,const char*,const CHARSET_INFO*)" -> "strtoul(const char*,char**,int)"
"create_func_cast(THD*,Item*,Cast_target,const char*,const char*,const CHARSET_INFO*)" -> "Item_time_typecast::Item_time_typecast(Item*,uint8)"
"Item_datetime_typecast::Item_datetime_typecast(Item*,uint8)" -> "Item_datetime_func::Item_datetime_func(Item*)"
"Item_datetime_func::Item_datetime_func(Item*)" -> "Item_temporal_func::Item_temporal_func(Item*)"
"Item_temporal_func::Item_temporal_func(Item*)" -> "Item_func::Item_func(Item*)"
"Item_date_typecast::Item_date_typecast(Item*)" -> "Item_date_func::Item_date_func(Item*)"
"Item_date_func::Item_date_func(Item*)" -> "Item_temporal_func::Item_temporal_func(Item*)"
"Item_func_unsigned::Item_func_unsigned(Item*)" -> "Item_func_signed::Item_func_signed(Item*)"
"Item_func_signed::Item_func_signed(Item*)" -> "Item_int_func::Item_int_func(Item*)"
"Item_func_binary::Item_func_binary(Item*)" -> "Item_str_func::Item_str_func(Item*)"
"Item_decimal_typecast::Item_decimal_typecast(Item*,int,int)" -> "my_decimal_precision_to_length_no_truncation(uint,uint8,bool)"
"Item_decimal_typecast::Item_decimal_typecast(Item*,int,int)" -> "Item_func::Item_func(Item*)"
"Item_decimal_typecast::Item_decimal_typecast(Item*,int,int)" -> "my_decimal::my_decimal()"
"Item_decimal_typecast::Item_decimal_typecast(Item*,int,int)" -> "Item::fix_char_length(uint32)"
"Item_decimal_typecast::Item_decimal_typecast(Item*,int,int)" -> "DTCollation::set_numeric()"
"my_decimal::my_decimal()" -> "st_decimal_t::st_decimal_t()"
"my_decimal::my_decimal()" -> "my_decimal::init()"
"Item_time_typecast::Item_time_typecast(Item*,uint8)" -> "Item_time_func::Item_time_func(Item*)"
"Item_time_func::Item_time_func(Item*)" -> "Item_temporal_func::Item_temporal_func(Item*)"
"Sql_cmd_check_table::Sql_cmd_check_table()" -> "Sql_cmd::Sql_cmd()"
"my_var::my_var(LEX_STRING&,bool,uint,enum_field_types)" -> "Sql_alloc::Sql_alloc()"
"Item_func_coalesce::Item_func_coalesce(List<Item>&)" -> "Item_func_numhybrid::Item_func_numhybrid(List<Item>&)"
"Item_func_numhybrid::Item_func_numhybrid(List<Item>&)" -> "Item_func::Item_func(List<Item>&)"
"Item_func_numhybrid::Item_func_numhybrid(List<Item>&)" -> "DTCollation::set_numeric()"
"Item_func::Item_func(List<Item>&)" -> "Item_func::set_arguments(List<Item>&)"
"Item_func::Item_func(List<Item>&)" -> "Item_result_field::Item_result_field()"
"Item_func::set_arguments(List<Item>&)" -> "sql_alloc(size_t)"
"Item_func::set_arguments(List<Item>&)" -> "List_iterator_fast<T>::List_iterator_fast(List<T>&) [with T = Item]"
"Item_func::set_arguments(List<Item>&)" -> "List_iterator_fast<T>::operator++(int) [with T = Item]"
"Item_func::set_arguments(List<Item>&)" -> "base_list::empty()"
"Item_bin_string::Item_bin_string(const char*,uint)" -> "Item_hex_string::Item_hex_string()"
"Item_bin_string::Item_bin_string(const char*,uint)" -> "DTCollation::set(const CHARSET_INFO*,Derivation)"
"Item_bin_string::Item_bin_string(const char*,uint)" -> "sql_alloc(size_t)"
"Item_bin_string::Item_bin_string(const char*,uint)" -> "String::set(char*,uint32,const CHARSET_INFO*)"
"Item_hex_string::Item_hex_string()" -> "Item_hex_string::hex_string_init(const char*,uint)"
"Item_hex_string::Item_hex_string()" -> "Item_basic_constant::Item_basic_constant()"
"Item_hex_string::hex_string_init(const char*,uint)" -> "String::set(char*,uint32,const CHARSET_INFO*)"
"Item_hex_string::hex_string_init(const char*,uint)" -> "char_val(char)"
"Item_hex_string::hex_string_init(const char*,uint)" -> "String::set(const char*,uint32,const CHARSET_INFO*)"
"Item_hex_string::hex_string_init(const char*,uint)" -> "DTCollation::set(const CHARSET_INFO*,Derivation)"
"Item_hex_string::hex_string_init(const char*,uint)" -> "sql_alloc(size_t)"
"String::set(char*,uint32,const CHARSET_INFO*)" -> "String::free()"
"find_sys_var(THD*,const char*,uint)" -> "intern_plugin_unlock(LEX*,plugin_ref)"
"find_sys_var(THD*,const char*,uint)" -> "inline_mysql_rwlock_rdlock(mysql_rwlock_t*)"
"find_sys_var(THD*,const char*,uint)" -> "inline_mysql_mutex_unlock(mysql_mutex_t*)"
"find_sys_var(THD*,const char*,uint)" -> "intern_find_sys_var(const char*,uint)"
"find_sys_var(THD*,const char*,uint)" -> "my_error(int,myf,...)"
"find_sys_var(THD*,const char*,uint)" -> "intern_plugin_lock(LEX*,plugin_ref)"
"find_sys_var(THD*,const char*,uint)" -> "inline_mysql_rwlock_unlock(mysql_rwlock_t*)"
"find_sys_var(THD*,const char*,uint)" -> "inline_mysql_mutex_lock(mysql_mutex_t*)"
"Query_arena::memdup(const void*,size_t)" -> "memdup_root(MEM_ROOT*,const void*,size_t)"
"Item_int::Item_int(int32,uint)" -> "Item_num::Item_num()"
"Sql_cmd_alter_table_truncate_partition::Sql_cmd_alter_table_truncate_partition()" -> "Sql_cmd_truncate_table::Sql_cmd_truncate_table()"
"Sql_cmd_truncate_table::Sql_cmd_truncate_table()" -> "Sql_cmd::Sql_cmd()"
"Item_func_collation::Item_func_collation(Item*)" -> "Item_str_func::Item_str_func(Item*)"
"mysql_init_multi_delete(LEX*)" -> "SQL_I_List<T>::save_and_clear(SQL_I_List<T>*) [with T = TABLE_LIST]"
"mysql_init_multi_delete(LEX*)" -> "mysql_init_select(LEX*)"
"SQL_I_List<T>::save_and_clear(SQL_I_List<T>*) [with T = TABLE_LIST]" -> "SQL_I_List<T>::empty() [with T = TABLE_LIST]"
"st_select_lex::add_table_to_list(THD*,Table_ident*,LEX_STRING*,ulong,thr_lock_type,enum_mdl_type,List<Index_hint>*,List<String>*,LEX_STRING*)" -> "base_list::empty()"
"st_select_lex::add_table_to_list(THD*,Table_ident*,LEX_STRING*,ulong,thr_lock_type,enum_mdl_type,List<Index_hint>*,List<String>*,LEX_STRING*)" -> "check_and_convert_db_name(LEX_STRING*,bool)"
"st_select_lex::add_table_to_list(THD*,Table_ident*,LEX_STRING*,ulong,thr_lock_type,enum_mdl_type,List<Index_hint>*,List<String>*,LEX_STRING*)" -> "MDL_request::init(MDL_key::enum_mdl_namespace,const char*,const char*,enum_mdl_type,enum_mdl_duration)"
"st_select_lex::add_table_to_list(THD*,Table_ident*,LEX_STRING*,ulong,thr_lock_type,enum_mdl_type,List<Index_hint>*,List<String>*,LEX_STRING*)" -> "SQL_I_List<T>::link_in_list(T*,T**) [with T = TABLE_LIST]"
"st_select_lex::add_table_to_list(THD*,Table_ident*,LEX_STRING*,ulong,thr_lock_type,enum_mdl_type,List<Index_hint>*,List<String>*,LEX_STRING*)" -> "is_infoschema_db(const char*,size_t)"
"st_select_lex::add_table_to_list(THD*,Table_ident*,LEX_STRING*,ulong,thr_lock_type,enum_mdl_type,List<Index_hint>*,List<String>*,LEX_STRING*)" -> "strcmp(const char*,const char*)"
"st_select_lex::add_table_to_list(THD*,Table_ident*,LEX_STRING*,ulong,thr_lock_type,enum_mdl_type,List<Index_hint>*,List<String>*,LEX_STRING*)" -> "Query_tables_list::add_to_query_tables(TABLE_LIST*)"
"st_select_lex::add_table_to_list(THD*,Table_ident*,LEX_STRING*,ulong,thr_lock_type,enum_mdl_type,List<Index_hint>*,List<String>*,LEX_STRING*)" -> "_current_thd()"
"st_select_lex::add_table_to_list(THD*,Table_ident*,LEX_STRING*,ulong,thr_lock_type,enum_mdl_type,List<Index_hint>*,List<String>*,LEX_STRING*)" -> "my_error(int,myf,...)"
"st_select_lex::add_table_to_list(THD*,Table_ident*,LEX_STRING*,ulong,thr_lock_type,enum_mdl_type,List<Index_hint>*,List<String>*,LEX_STRING*)" -> "Query_arena::calloc(size_t)"
"st_select_lex::add_table_to_list(THD*,Table_ident*,LEX_STRING*,ulong,thr_lock_type,enum_mdl_type,List<Index_hint>*,List<String>*,LEX_STRING*)" -> "LEX::copy_db_to(char**,size_t*) const"
"st_select_lex::add_table_to_list(THD*,Table_ident*,LEX_STRING*,ulong,thr_lock_type,enum_mdl_type,List<Index_hint>*,List<String>*,LEX_STRING*)" -> "find_schema_table(THD*,const char*)"
"st_select_lex::add_table_to_list(THD*,Table_ident*,LEX_STRING*,ulong,thr_lock_type,enum_mdl_type,List<Index_hint>*,List<String>*,LEX_STRING*)" -> "Table_ident::is_derived_table() const"
"st_select_lex::add_table_to_list(THD*,Table_ident*,LEX_STRING*,ulong,thr_lock_type,enum_mdl_type,List<Index_hint>*,List<String>*,LEX_STRING*)" -> "my_message(uint,const char*,myf)"
"st_select_lex::add_table_to_list(THD*,Table_ident*,LEX_STRING*,ulong,thr_lock_type,enum_mdl_type,List<Index_hint>*,List<String>*,LEX_STRING*)" -> "check_table_name(const char*,size_t,bool)"
"st_select_lex::add_table_to_list(THD*,Table_ident*,LEX_STRING*,ulong,thr_lock_type,enum_mdl_type,List<Index_hint>*,List<String>*,LEX_STRING*)" -> "Query_arena::memdup(const void*,size_t)"
"Query_arena::calloc(size_t)" -> "memset(void*,int,size_t)"
"Query_arena::calloc(size_t)" -> "alloc_root(MEM_ROOT*,size_t)"
"st_select_lex_unit::add_fake_select_lex(THD*)" -> "st_select_lex::st_select_lex()"
"st_select_lex_unit::add_fake_select_lex(THD*)" -> "LEX::pop_context()"
"st_select_lex_unit::add_fake_select_lex(THD*)" -> "st_select_lex_node::include_standalone(st_select_lex_node*,st_select_lex_node**)"
"st_select_lex_unit::add_fake_select_lex(THD*)" -> "st_select_lex::make_empty_select()"
"st_select_lex_unit::add_fake_select_lex(THD*)" -> "st_select_lex_unit::first_select()"
"st_select_lex_unit::add_fake_select_lex(THD*)" -> "st_select_lex_unit::is_union()"
"LEX::pop_context()" -> "List<T>::pop() [with T = Name_resolution_context]"
"List<T>::pop() [with T = Name_resolution_context]" -> "base_list::pop()"
"set_system_variable(THD*,sys_var_with_base*,enum_var_type,Item*)" -> "set_var::set_var(enum_var_type,sys_var*,const LEX_STRING*,Item*)"
"set_system_variable(THD*,sys_var_with_base*,enum_var_type,Item*)" -> "my_error(int,myf,...)"
"set_system_variable(THD*,sys_var_with_base*,enum_var_type,Item*)" -> "List<T>::push_back(T*) [with T = set_var_base]"
"set_system_variable(THD*,sys_var_with_base*,enum_var_type,Item*)" -> "LEX::get_sp_current_parsing_ctx()"
"set_var::set_var(enum_var_type,sys_var*,const LEX_STRING*,Item*)" -> "set_var_base::set_var_base()"
"set_var::set_var(enum_var_type,sys_var*,const LEX_STRING*,Item*)" -> "strlen(const char*)"
"set_var::set_var(enum_var_type,sys_var*,const LEX_STRING*,Item*)" -> "Item_string::Item_string(const char*,uint,const CHARSET_INFO*,Derivation,uint)"
"Item_string::Item_string(const char*,uint,const CHARSET_INFO*,Derivation,uint)" -> "DTCollation::set(const CHARSET_INFO*,Derivation,uint)"
"Item_string::Item_string(const char*,uint,const CHARSET_INFO*,Derivation,uint)" -> "String::numchars() const"
"Item_string::Item_string(const char*,uint,const CHARSET_INFO*,Derivation,uint)" -> "Name_string::copy(const char*,size_t,const CHARSET_INFO*)"
"Item_string::Item_string(const char*,uint,const CHARSET_INFO*,Derivation,uint)" -> "String::set_or_copy_aligned(const char*,uint32,const CHARSET_INFO*)"
"Item_string::Item_string(const char*,uint,const CHARSET_INFO*,Derivation,uint)" -> "Item_basic_constant::Item_basic_constant()"
"Name_string::copy(const char*,size_t,const CHARSET_INFO*)" -> "my_charset_same(const CHARSET_INFO*,const CHARSET_INFO*)"
"Name_string::copy(const char*,size_t,const CHARSET_INFO*)" -> "Simple_cstring::set(const char*,size_t)"
"Name_string::copy(const char*,size_t,const CHARSET_INFO*)" -> "std::min(const _Tp&,const _Tp&) [with _Tp = long unsigned int]"
"Name_string::copy(const char*,size_t,const CHARSET_INFO*)" -> "sql_strmake_with_convert(const char*,size_t,const CHARSET_INFO*,size_t,const CHARSET_INFO*,size_t*)"
"Name_string::copy(const char*,size_t,const CHARSET_INFO*)" -> "sql_strmake(const char*,size_t)"
"sql_strmake_with_convert(const char*,size_t,const CHARSET_INFO*,size_t,const CHARSET_INFO*,size_t*)" -> "memcpy(void*,const void*,size_t)"
"sql_strmake_with_convert(const char*,size_t,const CHARSET_INFO*,size_t,const CHARSET_INFO*,size_t*)" -> "copy_and_convert(char*,uint32,const CHARSET_INFO*,const char*,uint32,const CHARSET_INFO*,uint*)"
"sql_strmake_with_convert(const char*,size_t,const CHARSET_INFO*,size_t,const CHARSET_INFO*,size_t*)" -> "sql_alloc(size_t)"
"sql_strmake_with_convert(const char*,size_t,const CHARSET_INFO*,size_t,const CHARSET_INFO*,size_t*)" -> "std::min(const _Tp&,const _Tp&) [with _Tp = long unsigned int]"
"sql_strmake(const char*,size_t)" -> "sql_alloc(size_t)"
"sql_strmake(const char*,size_t)" -> "memcpy(void*,const void*,size_t)"
"String::set_or_copy_aligned(const char*,uint32,const CHARSET_INFO*)" -> "String::copy_aligned(const char*,uint32,uint32,const CHARSET_INFO*)"
"String::set_or_copy_aligned(const char*,uint32,const CHARSET_INFO*)" -> "String::set(const char*,uint32,const CHARSET_INFO*)"
"List<T>::push_back(T*) [with T = set_var_base]" -> "base_list::push_back(void*)"
"Table_ident::change_db(char*)" -> "strlen(const char*)"
"get_system_var(THD*,enum_var_type,LEX_STRING,LEX_STRING)" -> "sys_var::do_deprecated_warning(THD*)"
"get_system_var(THD*,enum_var_type,LEX_STRING,LEX_STRING)" -> "my_error(int,myf,...)"
"get_system_var(THD*,enum_var_type,LEX_STRING,LEX_STRING)" -> "sys_var::is_struct()"
"get_system_var(THD*,enum_var_type,LEX_STRING,LEX_STRING)" -> "Item_func_get_system_var::Item_func_get_system_var(sys_var*,enum_var_type,LEX_STRING*,const char*,size_t)"
"get_system_var(THD*,enum_var_type,LEX_STRING,LEX_STRING)" -> "LEX::uncacheable(uint8)"
"get_system_var(THD*,enum_var_type,LEX_STRING,LEX_STRING)" -> "find_sys_var(THD*,const char*,uint)"
"sys_var::do_deprecated_warning(THD*)" -> "sql_print_warning(const char*,...)"
"sys_var::do_deprecated_warning(THD*)" -> "strxnmov(char*,size_t,const char*,...)"
"sys_var::do_deprecated_warning(THD*)" -> "_current_thd()"
"sys_var::do_deprecated_warning(THD*)" -> "push_warning_printf(THD*,Sql_condition::enum_warning_level,uint,const char*,...)"
"Item_func_get_system_var::Item_func_get_system_var(sys_var*,enum_var_type,LEX_STRING*,const char*,size_t)" -> "String::String()"
"Item_func_get_system_var::Item_func_get_system_var(sys_var*,enum_var_type,LEX_STRING*,const char*,size_t)" -> "Item_var_func::Item_var_func()"
"Item_func_get_system_var::Item_func_get_system_var(sys_var*,enum_var_type,LEX_STRING*,const char*,size_t)" -> "Name_string::copy(const char*,size_t)"
"Item_var_func::Item_var_func()" -> "Item_func::Item_func()"
"Item_func::Item_func()" -> "Item_result_field::Item_result_field()"
"Name_string::copy(const char*,size_t)" -> "Name_string::copy(const char*,size_t,const CHARSET_INFO*)"
"Item_func_user::Item_func_user()" -> "String::set(const char*,uint32,const CHARSET_INFO*)"
"Item_func_user::Item_func_user()" -> "Item_func_sysconst::Item_func_sysconst()"
"Item_func_sysconst::Item_func_sysconst()" -> "Item_str_func::Item_str_func()"
"Item_func_sysconst::Item_func_sysconst()" -> "DTCollation::set(const CHARSET_INFO*,Derivation)"
"Item_str_func::Item_str_func()" -> "Item_func::Item_func()"
"select_export::select_export(sql_exchange*)" -> "select_to_file::select_to_file(sql_exchange*)"
"select_to_file::select_to_file(sql_exchange*)" -> "select_result_interceptor::select_result_interceptor()"
"Item_sum_xor::Item_sum_xor(Item*)" -> "Item_sum_bit::Item_sum_bit(Item*,ulonglong)"
"Item_sum_bit::Item_sum_bit(Item*,ulonglong)" -> "Item_sum_int::Item_sum_int(Item*)"
"Item_sum_int::Item_sum_int(Item*)" -> "Item_sum_num::Item_sum_num(Item*)"
"partition_info::set_part_expr(char*,Item*,char*,bool)" -> "mem_alloc_error(size_t)"
"partition_info::set_part_expr(char*,Item*,char*,bool)" -> "sql_memdup(const void*,size_t)"
"sql_memdup(const void*,size_t)" -> "sql_alloc(size_t)"
"sql_memdup(const void*,size_t)" -> "memcpy(void*,const void*,size_t)"
"Item_func_shift_right::Item_func_shift_right(Item*,Item*)" -> "Item_func_bit::Item_func_bit(Item*,Item*)"
"mysql_new_select(LEX*,bool)" -> "st_select_lex_unit::st_select_lex_unit()"
"mysql_new_select(LEX*,bool)" -> "st_select_lex_unit::add_fake_select_lex(THD*)"
"mysql_new_select(LEX*,bool)" -> "st_select_lex_node::include_global(st_select_lex_node**)"
"mysql_new_select(LEX*,bool)" -> "st_select_lex_node::include_neighbour(st_select_lex_node*)"
"mysql_new_select(LEX*,bool)" -> "LEX::current_context()"
"mysql_new_select(LEX*,bool)" -> "st_select_lex::st_select_lex()"
"mysql_new_select(LEX*,bool)" -> "st_select_lex_node::include_down(st_select_lex_node*)"
"mysql_new_select(LEX*,bool)" -> "my_error(int,myf,...)"
"mysql_new_select(LEX*,bool)" -> "st_select_lex_unit::first_select()"
"LEX::current_context()" -> "List<T>::head() [with T = Name_resolution_context]"
"List<T>::head() [with T = Name_resolution_context]" -> "base_list::head()"
"sp_pcontext::find_variable(uint) const" -> "sp_pcontext::find_variable(uint) const"
"sp_pcontext::find_variable(uint) const" -> "Dynamic_array<Elem>::elements() const [with Elem = sp_variable*]"
"sp_pcontext::find_variable(uint) const" -> "Dynamic_array<Elem>::at(int) const [with Elem = sp_variable*]"
"add_order_to_list(THD*,Item*,bool)" -> "st_select_lex::add_order_to_list(THD*,Item*,bool)"
"st_select_lex::add_order_to_list(THD*,Item*,bool)" -> "add_to_list(THD*,SQL_I_List<st_order>&,Item*,bool)"
"add_to_list(THD*,SQL_I_List<st_order>&,Item*,bool)" -> "Query_arena::alloc(size_t)"
"add_to_list(THD*,SQL_I_List<st_order>&,Item*,bool)" -> "SQL_I_List<T>::link_in_list(T*,T**) [with T = st_order]"
"Key_part_spec::Key_part_spec(const LEX_STRING&,uint)" -> "Sql_alloc::Sql_alloc()"
"sp_pcontext::find_condition(LEX_STRING,bool) const" -> "Dynamic_array<Elem>::elements() const [with Elem = sp_condition*]"
"sp_pcontext::find_condition(LEX_STRING,bool) const" -> "Dynamic_array<Elem>::at(int) const [with Elem = sp_condition*]"
"sp_pcontext::find_condition(LEX_STRING,bool) const" -> "sp_pcontext::find_condition(LEX_STRING,bool) const"
"Item_func_dayofmonth::Item_func_dayofmonth(Item*)" -> "Item_int_func::Item_int_func(Item*)"
"List<T>::push_back(T*) [with T = Item_param]" -> "base_list::push_back(void*)"
"add_gorder_to_list(THD*,Item*,bool)" -> "st_select_lex::add_gorder_to_list(THD*,Item*,bool)"
"st_select_lex::add_gorder_to_list(THD*,Item*,bool)" -> "add_to_list(THD*,SQL_I_List<st_order>&,Item*,bool)"
"sp_instr_jump_if_not::sp_instr_jump_if_not(uint,LEX*,Item*,LEX_STRING,uint)" -> "sp_lex_branch_instr::sp_lex_branch_instr(uint,sp_pcontext*,LEX*,Item*,LEX_STRING,uint)"
"sp_instr_jump_if_not::sp_instr_jump_if_not(uint,LEX*,Item*,LEX_STRING,uint)" -> "LEX::get_sp_current_parsing_ctx()"
"sp_lex_branch_instr::sp_lex_branch_instr(uint,sp_pcontext*,LEX*,Item*,LEX_STRING,uint)" -> "sp_lex_instr::sp_lex_instr(uint,sp_pcontext*,LEX*,bool)"
"sp_lex_branch_instr::sp_lex_branch_instr(uint,sp_pcontext*,LEX*,Item*,LEX_STRING,uint)" -> "sp_branch_instr::sp_branch_instr()"
"Item_user_var_as_out_param::Item_user_var_as_out_param(Name_string)" -> "Name_string::copy(Name_string)"
"Item_user_var_as_out_param::Item_user_var_as_out_param(Name_string)" -> "Item::Item()"
"Name_string::copy(Name_string)" -> "Simple_cstring::ptr() const"
"Name_string::copy(Name_string)" -> "Simple_cstring::length() const"
"Name_string::copy(Name_string)" -> "Name_string::copy(const char*,size_t)"
"Item_func_equal::Item_func_equal(Item*,Item*)" -> "Item_bool_rowready_func2::Item_bool_rowready_func2(Item*,Item*)"
"sp_name::sp_name(LEX_STRING,LEX_STRING,bool)" -> "Sql_alloc::Sql_alloc()"
"Sql_cmd_get_diagnostics::Sql_cmd_get_diagnostics(Diagnostics_information*)" -> "Sql_cmd::Sql_cmd()"
"Item_func_point::Item_func_point(Item*,Item*)" -> "Item_geometry_func::Item_geometry_func(Item*,Item*)"
"Item_geometry_func::Item_geometry_func(Item*,Item*)" -> "Item_str_func::Item_str_func(Item*,Item*)"
"sp_pcontext::find_label(LEX_STRING)" -> "List_iterator_fast<T>::operator++(int) [with T = sp_label]"
"sp_pcontext::find_label(LEX_STRING)" -> "List_iterator_fast<T>::List_iterator_fast(List<T>&) [with T = sp_label]"
"sp_pcontext::find_label(LEX_STRING)" -> "sp_pcontext::find_label(LEX_STRING)"
"List_iterator_fast<T>::operator++(int) [with T = sp_label]" -> "base_list_iterator::next_fast()"
"List_iterator_fast<T>::List_iterator_fast(List<T>&) [with T = sp_label]" -> "base_list_iterator::base_list_iterator(base_list&)"
"check_string_char_length(LEX_STRING*,const char*,uint,const CHARSET_INFO*,bool)" -> "ErrConvString::ErrConvString(const char*,uint,const CHARSET_INFO*)"
"check_string_char_length(LEX_STRING*,const char*,uint,const CHARSET_INFO*,bool)" -> "my_error(int,myf,...)"
"check_string_char_length(LEX_STRING*,const char*,uint,const CHARSET_INFO*,bool)" -> "ErrConvString::ptr()"
"ErrConvString::ErrConvString(const char*,uint,const CHARSET_INFO*)" -> "err_conv(char*,size_t,const char*,size_t,const CHARSET_INFO*)"
"set_var_collation_client::set_var_collation_client(int,const CHARSET_INFO*,const CHARSET_INFO*,const CHARSET_INFO*)" -> "set_var_base::set_var_base()"
"Sql_cmd_alter_table_check_partition::Sql_cmd_alter_table_check_partition()" -> "Sql_cmd_check_table::Sql_cmd_check_table()"
"List<T>::List() [with T = Condition_information_item]" -> "base_list::base_list()"
"sp_pcontext::push_case_expr_id()" -> "Dynamic_array<Elem>::append(const Elem&) [with Elem = int]"
"Dynamic_array<Elem>::append(const Elem&) [with Elem = int]" -> "insert_dynamic(DYNAMIC_ARRAY*,const void*)"
"st_select_lex::nest_last_join(THD*)" -> "List<T>::pop() [with T = TABLE_LIST]"
"st_select_lex::nest_last_join(THD*)" -> "List<T>::push_back(T*) [with T = TABLE_LIST]"
"st_select_lex::nest_last_join(THD*)" -> "List<T>::push_front(T*) [with T = TABLE_LIST]"
"st_select_lex::nest_last_join(THD*)" -> "TABLE_LIST::new_nested_join(MEM_ROOT*,const char*,TABLE_LIST*,List<TABLE_LIST>*,st_select_lex*)"
"List<T>::pop() [with T = TABLE_LIST]" -> "base_list::pop()"
"List<T>::push_back(T*) [with T = TABLE_LIST]" -> "base_list::push_back(void*)"
"List<T>::push_front(T*) [with T = TABLE_LIST]" -> "base_list::push_front(void*)"
"TABLE_LIST::new_nested_join(MEM_ROOT*,const char*,TABLE_LIST*,List<TABLE_LIST>*,st_select_lex*)" -> "memset(void*,int,size_t)"
"TABLE_LIST::new_nested_join(MEM_ROOT*,const char*,TABLE_LIST*,List<TABLE_LIST>*,st_select_lex*)" -> "alloc_root(MEM_ROOT*,size_t)"
"TABLE_LIST::new_nested_join(MEM_ROOT*,const char*,TABLE_LIST*,List<TABLE_LIST>*,st_select_lex*)" -> "base_list::empty()"
"check_simple_select()" -> "strmake(char*,const char*,size_t)"
"check_simple_select()" -> "my_error(int,myf,...)"
"check_simple_select()" -> "std::min(const _Tp&,const _Tp&) [with _Tp = long unsigned int]"
"check_simple_select()" -> "_current_thd()"
"Item_cond_or::Item_cond_or(Item*,Item*)" -> "Item_cond::Item_cond(Item*,Item*)"
"Item_cond::Item_cond(Item*,Item*)" -> "List<T>::List() [with T = Item]"
"Item_cond::Item_cond(Item*,Item*)" -> "List<T>::push_back(T*) [with T = Item]"
"Item_cond::Item_cond(Item*,Item*)" -> "Item_bool_func::Item_bool_func()"
"List<T>::push_back(T*) [with T = Item]" -> "base_list::push_back(void*)"
"Item_bool_func::Item_bool_func()" -> "Item_int_func::Item_int_func()"
"Item_int_func::Item_int_func()" -> "DTCollation::set_numeric()"
"Item_int_func::Item_int_func()" -> "Item_func::Item_func()"
"Item_int_func::Item_int_func()" -> "Item::fix_char_length(uint32)"
"Item_func_like::Item_func_like(Item*,Item*,Item*,bool)" -> "Item_bool_func2::Item_bool_func2(Item*,Item*)"
"Item_func_format::Item_func_format(Item*,Item*,Item*)" -> "Item_str_ascii_func::Item_str_ascii_func(Item*,Item*,Item*)"
"Item_func_format::Item_func_format(Item*,Item*,Item*)" -> "String::String()"
"Item_str_ascii_func::Item_str_ascii_func(Item*,Item*,Item*)" -> "Item_str_func::Item_str_func(Item*,Item*,Item*)"
"Item_str_ascii_func::Item_str_ascii_func(Item*,Item*,Item*)" -> "DTCollation::set_repertoire(uint)"
"Item_str_ascii_func::Item_str_ascii_func(Item*,Item*,Item*)" -> "String::String()"
"Item_str_func::Item_str_func(Item*,Item*,Item*)" -> "Item_func::Item_func(Item*,Item*,Item*)"
"MYSQLerror(THD*,const char*)" -> "LEX::cleanup_lex_after_parse_error(THD*)"
"MYSQLerror(THD*,const char*)" -> "_current_thd()"
"MYSQLerror(THD*,const char*)" -> "my_parse_error(const char*)"
"MYSQLerror(THD*,const char*)" -> "strcmp(const char*,const char*)"
"LEX::cleanup_lex_after_parse_error(THD*)" -> "sp_parser_data::finish_parsing_sp_body(THD*)"
"sp_parser_data::finish_parsing_sp_body(THD*)" -> "Query_arena::free_items()"
"sp_parser_data::finish_parsing_sp_body(THD*)" -> "sp_parser_data::is_parsing_sp_body() const"
"Item_func_minute::Item_func_minute(Item*)" -> "Item_int_func::Item_int_func(Item*)"
"List<T>::push_back(T*) [with T = char]" -> "base_list::push_back(void*)"
"find_sys_var_null_base(THD*,sys_var_with_base*)" -> "THD::is_error() const"
"find_sys_var_null_base(THD*,sys_var_with_base*)" -> "my_error(int,myf,...)"
"find_sys_var_null_base(THD*,sys_var_with_base*)" -> "find_sys_var(THD*,const char*,uint)"
"sp_check_name(LEX_STRING*)" -> "my_error(int,myf,...)"
"sp_check_name(LEX_STRING*)" -> "check_string_char_length(LEX_STRING*,const char*,uint,const CHARSET_INFO*,bool)"
"Item_func_interval::Item_func_interval(Item_row*)" -> "Item_int_func::Item_int_func(Item*)"
"Item_func_int_div::Item_func_int_div(Item*,Item*)" -> "Item_int_func::Item_int_func(Item*,Item*)"
"xid_t::set(long int,const char*,long int,const char*,long int)" -> "memcpy(void*,const void*,size_t)"
"List<T>::push_back(T*) [with T = Alter_column]" -> "base_list::push_back(void*)"
"Create_udf_func::create(THD*,udf_func*,List<Item>*)" -> "Item_func_udf_str::Item_func_udf_str(udf_func*,List<Item>&)"
"Create_udf_func::create(THD*,udf_func*,List<Item>*)" -> "Item_sum_udf_int::Item_sum_udf_int(udf_func*,List<Item>&)"
"Create_udf_func::create(THD*,udf_func*,List<Item>*)" -> "my_error(int,myf,...)"
"Create_udf_func::create(THD*,udf_func*,List<Item>*)" -> "Item_func_udf_int::Item_func_udf_int(udf_func*)"
"Create_udf_func::create(THD*,udf_func*,List<Item>*)" -> "Item_func_udf_decimal::Item_func_udf_decimal(udf_func*,List<Item>&)"
"Create_udf_func::create(THD*,udf_func*,List<Item>*)" -> "Item_sum_udf_str::Item_sum_udf_str(udf_func*)"
"Create_udf_func::create(THD*,udf_func*,List<Item>*)" -> "Item_func_udf_decimal::Item_func_udf_decimal(udf_func*)"
"Create_udf_func::create(THD*,udf_func*,List<Item>*)" -> "Query_tables_list::set_stmt_unsafe(Query_tables_list::enum_binlog_stmt_unsafe)"
"Create_udf_func::create(THD*,udf_func*,List<Item>*)" -> "Item_func_udf_int::Item_func_udf_int(udf_func*,List<Item>&)"
"Create_udf_func::create(THD*,udf_func*,List<Item>*)" -> "Item_sum_udf_float::Item_sum_udf_float(udf_func*)"
"Create_udf_func::create(THD*,udf_func*,List<Item>*)" -> "Item_func_udf_float::Item_func_udf_float(udf_func*,List<Item>&)"
"Create_udf_func::create(THD*,udf_func*,List<Item>*)" -> "Item_sum_udf_decimal::Item_sum_udf_decimal(udf_func*,List<Item>&)"
"Create_udf_func::create(THD*,udf_func*,List<Item>*)" -> "Item_sum_udf_decimal::Item_sum_udf_decimal(udf_func*)"
"Create_udf_func::create(THD*,udf_func*,List<Item>*)" -> "Item_func_udf_str::Item_func_udf_str(udf_func*)"
"Create_udf_func::create(THD*,udf_func*,List<Item>*)" -> "Item_sum_udf_float::Item_sum_udf_float(udf_func*,List<Item>&)"
"Create_udf_func::create(THD*,udf_func*,List<Item>*)" -> "Item_sum_udf_str::Item_sum_udf_str(udf_func*,List<Item>&)"
"Create_udf_func::create(THD*,udf_func*,List<Item>*)" -> "Item_sum_udf_int::Item_sum_udf_int(udf_func*)"
"Create_udf_func::create(THD*,udf_func*,List<Item>*)" -> "Item_func_udf_float::Item_func_udf_float(udf_func*)"
"Item_func_udf_str::Item_func_udf_str(udf_func*,List<Item>&)" -> "Item_udf_func::Item_udf_func(udf_func*,List<Item>&)"
"Item_udf_func::Item_udf_func(udf_func*,List<Item>&)" -> "udf_handler::udf_handler(udf_func*)"
"Item_udf_func::Item_udf_func(udf_func*,List<Item>&)" -> "Item_func::Item_func(List<Item>&)"
"udf_handler::udf_handler(udf_func*)" -> "Sql_alloc::Sql_alloc()"
"Item_sum_udf_int::Item_sum_udf_int(udf_func*,List<Item>&)" -> "Item_udf_sum::Item_udf_sum(udf_func*,List<Item>&)"
"Item_udf_sum::Item_udf_sum(udf_func*,List<Item>&)" -> "udf_handler::udf_handler(udf_func*)"
"Item_udf_sum::Item_udf_sum(udf_func*,List<Item>&)" -> "Item_sum::Item_sum(List<Item>&)"
"Item_sum::Item_sum(List<Item>&)" -> "List<T>::List() [with T = Item_field]"
"Item_sum::Item_sum(List<Item>&)" -> "sql_alloc(size_t)"
"Item_sum::Item_sum(List<Item>&)" -> "base_list::empty()"
"Item_sum::Item_sum(List<Item>&)" -> "Item_sum::init_aggregator()"
"Item_sum::Item_sum(List<Item>&)" -> "Item_result_field::Item_result_field()"
"Item_sum::Item_sum(List<Item>&)" -> "List_iterator_fast<T>::operator++(int) [with T = Item]"
"Item_sum::Item_sum(List<Item>&)" -> "Item_sum::mark_as_sum_func()"
"Item_sum::Item_sum(List<Item>&)" -> "List_iterator_fast<T>::List_iterator_fast(List<T>&) [with T = Item]"
"Item_func_udf_int::Item_func_udf_int(udf_func*)" -> "Item_udf_func::Item_udf_func(udf_func*)"
"Item_udf_func::Item_udf_func(udf_func*)" -> "Item_func::Item_func()"
"Item_udf_func::Item_udf_func(udf_func*)" -> "udf_handler::udf_handler(udf_func*)"
"Item_func_udf_decimal::Item_func_udf_decimal(udf_func*,List<Item>&)" -> "Item_udf_func::Item_udf_func(udf_func*,List<Item>&)"
"Item_sum_udf_str::Item_sum_udf_str(udf_func*)" -> "Item_udf_sum::Item_udf_sum(udf_func*)"
"Item_udf_sum::Item_udf_sum(udf_func*)" -> "Item_sum::Item_sum()"
"Item_udf_sum::Item_udf_sum(udf_func*)" -> "udf_handler::udf_handler(udf_func*)"
"Item_func_udf_decimal::Item_func_udf_decimal(udf_func*)" -> "Item_udf_func::Item_udf_func(udf_func*)"
"Item_func_udf_int::Item_func_udf_int(udf_func*,List<Item>&)" -> "Item_udf_func::Item_udf_func(udf_func*,List<Item>&)"
"Item_sum_udf_float::Item_sum_udf_float(udf_func*)" -> "Item_udf_sum::Item_udf_sum(udf_func*)"
"Item_func_udf_float::Item_func_udf_float(udf_func*,List<Item>&)" -> "Item_udf_func::Item_udf_func(udf_func*,List<Item>&)"
"Item_sum_udf_decimal::Item_sum_udf_decimal(udf_func*,List<Item>&)" -> "Item_udf_sum::Item_udf_sum(udf_func*,List<Item>&)"
"Item_sum_udf_decimal::Item_sum_udf_decimal(udf_func*)" -> "Item_udf_sum::Item_udf_sum(udf_func*)"
"Item_func_udf_str::Item_func_udf_str(udf_func*)" -> "Item_udf_func::Item_udf_func(udf_func*)"
"Item_sum_udf_float::Item_sum_udf_float(udf_func*,List<Item>&)" -> "Item_udf_sum::Item_udf_sum(udf_func*,List<Item>&)"
"Item_sum_udf_str::Item_sum_udf_str(udf_func*,List<Item>&)" -> "Item_udf_sum::Item_udf_sum(udf_func*,List<Item>&)"
"Item_sum_udf_int::Item_sum_udf_int(udf_func*)" -> "Item_udf_sum::Item_udf_sum(udf_func*)"
"Item_func_udf_float::Item_func_udf_float(udf_func*)" -> "Item_udf_func::Item_udf_func(udf_func*)"
"add_field_to_list(THD*,LEX_STRING*,enum_field_types,char*,char*,uint,Item*,Item*,LEX_STRING*,char*,List<String>*,const CHARSET_INFO*,uint)" -> "real_type_with_now_on_update(enum_field_types)"
"add_field_to_list(THD*,LEX_STRING*,enum_field_types,char*,char*,uint,Item*,Item*,LEX_STRING*,char*,List<String>*,const CHARSET_INFO*,uint)" -> "Key::Key(Key::Keytype,const LEX_STRING&,KEY_CREATE_INFO*,bool,List<Key_part_spec>&)"
"add_field_to_list(THD*,LEX_STRING*,enum_field_types,char*,char*,uint,Item*,Item*,LEX_STRING*,char*,List<String>*,const CHARSET_INFO*,uint)" -> "base_list::empty()"
"add_field_to_list(THD*,LEX_STRING*,enum_field_types,char*,char*,uint,Item*,Item*,LEX_STRING*,char*,List<String>*,const CHARSET_INFO*,uint)" -> "check_string_char_length(LEX_STRING*,const char*,uint,const CHARSET_INFO*,bool)"
"add_field_to_list(THD*,LEX_STRING*,enum_field_types,char*,char*,uint,Item*,Item*,LEX_STRING*,char*,List<String>*,const CHARSET_INFO*,uint)" -> "List<T>::push_back(T*) [with T = Key]"
"add_field_to_list(THD*,LEX_STRING*,enum_field_types,char*,char*,uint,Item*,Item*,LEX_STRING*,char*,List<String>*,const CHARSET_INFO*,uint)" -> "atoi(const char*)"
"add_field_to_list(THD*,LEX_STRING*,enum_field_types,char*,char*,uint,Item*,Item*,LEX_STRING*,char*,List<String>*,const CHARSET_INFO*,uint)" -> "Create_field::init(THD*,const char*,enum_field_types,const char*,const char*,uint,Item*,Item*,LEX_STRING*,const char*,List<String>*,const CHARSET_INFO*,uint)"
"add_field_to_list(THD*,LEX_STRING*,enum_field_types,char*,char*,uint,Item*,Item*,LEX_STRING*,char*,List<String>*,const CHARSET_INFO*,uint)" -> "Create_field::Create_field()"
"add_field_to_list(THD*,LEX_STRING*,enum_field_types,char*,char*,uint,Item*,Item*,LEX_STRING*,char*,List<String>*,const CHARSET_INFO*,uint)" -> "List<T>::push_back(T*) [with T = Key_part_spec]"
"add_field_to_list(THD*,LEX_STRING*,enum_field_types,char*,char*,uint,Item*,Item*,LEX_STRING*,char*,List<String>*,const CHARSET_INFO*,uint)" -> "real_type_with_now_as_default(enum_field_types)"
"add_field_to_list(THD*,LEX_STRING*,enum_field_types,char*,char*,uint,Item*,Item*,LEX_STRING*,char*,List<String>*,const CHARSET_INFO*,uint)" -> "my_error(int,myf,...)"
"add_field_to_list(THD*,LEX_STRING*,enum_field_types,char*,char*,uint,Item*,Item*,LEX_STRING*,char*,List<String>*,const CHARSET_INFO*,uint)" -> "List<T>::push_back(T*) [with T = Create_field]"
"add_field_to_list(THD*,LEX_STRING*,enum_field_types,char*,char*,uint,Item*,Item*,LEX_STRING*,char*,List<String>*,const CHARSET_INFO*,uint)" -> "Key_part_spec::Key_part_spec(const LEX_STRING&,uint)"
"Key::Key(Key::Keytype,const LEX_STRING&,KEY_CREATE_INFO*,bool,List<Key_part_spec>&)" -> "Sql_alloc::Sql_alloc()"
"Key::Key(Key::Keytype,const LEX_STRING&,KEY_CREATE_INFO*,bool,List<Key_part_spec>&)" -> "List<T>::List(const List<T>&) [with T = Key_part_spec]"
"List<T>::List(const List<T>&) [with T = Key_part_spec]" -> "base_list::base_list(const base_list&)"
"base_list::base_list(const base_list&)" -> "Sql_alloc::Sql_alloc()"
"atoi(const char*)" -> "strtol(const char*,char**,int)"
"Create_field::init(THD*,const char*,enum_field_types,const char*,const char*,uint,Item*,Item*,LEX_STRING*,const char*,List<String>*,const CHARSET_INFO*,uint)" -> "strtoul(const char*,char**,int)"
"Create_field::init(THD*,const char*,enum_field_types,const char*,const char*,uint,Item*,Item*,LEX_STRING*,const char*,List<String>*,const CHARSET_INFO*,uint)" -> "std::min(const _Tp&,const _Tp&) [with _Tp = long unsigned int]"
"Create_field::init(THD*,const char*,enum_field_types,const char*,const char*,uint,Item*,Item*,LEX_STRING*,const char*,List<String>*,const CHARSET_INFO*,uint)" -> "String::length() const"
"Create_field::init(THD*,const char*,enum_field_types,const char*,const char*,uint,Item*,Item*,LEX_STRING*,const char*,List<String>*,const CHARSET_INFO*,uint)" -> "my_decimal_trim(ulong*,uint*)"
"Create_field::init(THD*,const char*,enum_field_types,const char*,const char*,uint,Item*,Item*,LEX_STRING*,const char*,List<String>*,const CHARSET_INFO*,uint)" -> "is_temporal_real_type(enum_field_types)"
"Create_field::init(THD*,const char*,enum_field_types,const char*,const char*,uint,Item*,Item*,LEX_STRING*,const char*,List<String>*,const CHARSET_INFO*,uint)" -> "THD::is_strict_mode() const"
"Create_field::init(THD*,const char*,enum_field_types,const char*,const char*,uint,Item*,Item*,LEX_STRING*,const char*,List<String>*,const CHARSET_INFO*,uint)" -> "List_iterator<T>::operator++(int) [with T = String]"
"Create_field::init(THD*,const char*,enum_field_types,const char*,const char*,uint,Item*,Item*,LEX_STRING*,const char*,List<String>*,const CHARSET_INFO*,uint)" -> "List_iterator<T>::List_iterator(List<T>&) [with T = String]"
"Create_field::init(THD*,const char*,enum_field_types,const char*,const char*,uint,Item*,Item*,LEX_STRING*,const char*,List<String>*,const CHARSET_INFO*,uint)" -> "get_set_pack_length(int)"
"Create_field::init(THD*,const char*,enum_field_types,const char*,const char*,uint,Item*,Item*,LEX_STRING*,const char*,List<String>*,const CHARSET_INFO*,uint)" -> "base_list::empty()"
"Create_field::init(THD*,const char*,enum_field_types,const char*,const char*,uint,Item*,Item*,LEX_STRING*,const char*,List<String>*,const CHARSET_INFO*,uint)" -> "__errno_location()"
"Create_field::init(THD*,const char*,enum_field_types,const char*,const char*,uint,Item*,Item*,LEX_STRING*,const char*,List<String>*,const CHARSET_INFO*,uint)" -> "atoi(const char*)"
"Create_field::init(THD*,const char*,enum_field_types,const char*,const char*,uint,Item*,Item*,LEX_STRING*,const char*,List<String>*,const CHARSET_INFO*,uint)" -> "my_decimal_precision_to_length(uint,uint8,bool)"
"Create_field::init(THD*,const char*,enum_field_types,const char*,const char*,uint,Item*,Item*,LEX_STRING*,const char*,List<String>*,const CHARSET_INFO*,uint)" -> "String::String()"
"Create_field::init(THD*,const char*,enum_field_types,const char*,const char*,uint,Item*,Item*,LEX_STRING*,const char*,List<String>*,const CHARSET_INFO*,uint)" -> "_current_thd()"
"Create_field::init(THD*,const char*,enum_field_types,const char*,const char*,uint,Item*,Item*,LEX_STRING*,const char*,List<String>*,const CHARSET_INFO*,uint)" -> "is_timestamp_type(enum_field_types)"
"Create_field::init(THD*,const char*,enum_field_types,const char*,const char*,uint,Item*,Item*,LEX_STRING*,const char*,List<String>*,const CHARSET_INFO*,uint)" -> "my_error(int,myf,...)"
"Create_field::init(THD*,const char*,enum_field_types,const char*,const char*,uint,Item*,Item*,LEX_STRING*,const char*,List<String>*,const CHARSET_INFO*,uint)" -> "push_warning_printf(THD*,Sql_condition::enum_warning_level,uint,const char*,...)"
"Create_field::init(THD*,const char*,enum_field_types,const char*,const char*,uint,Item*,Item*,LEX_STRING*,const char*,List<String>*,const CHARSET_INFO*,uint)" -> "List<T>::push_back(T*) [with T = String]"
"Create_field::init(THD*,const char*,enum_field_types,const char*,const char*,uint,Item*,Item*,LEX_STRING*,const char*,List<String>*,const CHARSET_INFO*,uint)" -> "my_decimal_get_binary_size(uint,uint)"
"Create_field::init(THD*,const char*,enum_field_types,const char*,const char*,uint,Item*,Item*,LEX_STRING*,const char*,List<String>*,const CHARSET_INFO*,uint)" -> "get_enum_pack_length(int)"
"List_iterator<T>::operator++(int) [with T = String]" -> "base_list_iterator::next()"
"List_iterator<T>::List_iterator(List<T>&) [with T = String]" -> "base_list_iterator::base_list_iterator(base_list&)"
"List<T>::push_back(T*) [with T = String]" -> "base_list::push_back(void*)"
"List<T>::push_back(T*) [with T = Key_part_spec]" -> "base_list::push_back(void*)"
"List<T>::push_back(T*) [with T = Create_field]" -> "base_list::push_back(void*)"
"sp_pcontext::get_current_case_expr_id() const" -> "Dynamic_array<Elem>::back() const [with Elem = int]"
"Item_func_case::Item_func_case(List<Item>&,Item*,Item*)" -> "Item_func::set_arguments(List<Item>&)"
"Item_func_case::Item_func_case(List<Item>&,Item*,Item*)" -> "List<T>::push_back(T*) [with T = Item]"
"Item_func_case::Item_func_case(List<Item>&,Item*,Item*)" -> "String::String()"
"Item_func_case::Item_func_case(List<Item>&,Item*,Item*)" -> "memset(void*,int,size_t)"
"Item_func_case::Item_func_case(List<Item>&,Item*,Item*)" -> "DTCollation::DTCollation()"
"Item_func_case::Item_func_case(List<Item>&,Item*,Item*)" -> "Item_func::Item_func()"
"Item_func_set_user_var::Item_func_set_user_var(Name_string,Item*,bool)" -> "my_decimal::my_decimal()"
"Item_func_set_user_var::Item_func_set_user_var(Name_string,Item*,bool)" -> "String::String()"
"Item_func_set_user_var::Item_func_set_user_var(Name_string,Item*,bool)" -> "Item_var_func::Item_var_func(Item*)"
"Item_var_func::Item_var_func(Item*)" -> "Item_func::Item_func(Item*)"
"sp_name::init_qname(THD*)" -> "sprintf(char*,const char*,...)"
"sp_name::init_qname(THD*)" -> "Query_arena::alloc(size_t)"
"Item_func_now_utc::Item_func_now_utc(uint8)" -> "Item_func_now::Item_func_now(uint8)"
"Item_func_now::Item_func_now(uint8)" -> "Item_datetime_func::Item_datetime_func()"
"Item_func_now::Item_func_now(uint8)" -> "MYSQL_TIME_cache::MYSQL_TIME_cache()"
"Item_datetime_func::Item_datetime_func()" -> "Item_temporal_func::Item_temporal_func()"
"Item_temporal_func::Item_temporal_func()" -> "Item_func::Item_func()"
"MYSQL_TIME_cache::MYSQL_TIME_cache()" -> "MYSQL_TIME_cache::reset()"
"MYSQL_TIME_cache::reset()" -> "MYSQL_TIME_cache::reset_string()"
"Alter_info::reset()" -> "base_list::empty()"
"Item_func_curdate_local::Item_func_curdate_local()" -> "Item_func_curdate::Item_func_curdate()"
"Item_func_curdate::Item_func_curdate()" -> "Item_date_func::Item_date_func()"
"Item_func_curdate::Item_func_curdate()" -> "MYSQL_TIME_cache::MYSQL_TIME_cache()"
"Item_date_func::Item_date_func()" -> "Item_temporal_func::Item_temporal_func()"
"Item_func_round::Item_func_round(Item*,Item*,bool)" -> "Item_func_num1::Item_func_num1(Item*,Item*)"
"Item_func_num1::Item_func_num1(Item*,Item*)" -> "Item_func_numhybrid::Item_func_numhybrid(Item*,Item*)"
"sp_pcontext::add_condition(THD*,LEX_STRING,sp_condition_value*)" -> "sp_condition::sp_condition(LEX_STRING,sp_condition_value*)"
"sp_pcontext::add_condition(THD*,LEX_STRING,sp_condition_value*)" -> "Dynamic_array<Elem>::append(const Elem&) [with Elem = sp_condition*]"
"sp_condition::sp_condition(LEX_STRING,sp_condition_value*)" -> "Sql_alloc::Sql_alloc()"
"Dynamic_array<Elem>::append(const Elem&) [with Elem = sp_condition*]" -> "insert_dynamic(DYNAMIC_ARRAY*,const void*)"
"check_host_name(LEX_STRING*)" -> "my_printf_error(uint,const char*,myf,...)"
"check_host_name(LEX_STRING*)" -> "check_string_byte_length(LEX_STRING*,const char*,uint)"
"check_host_name(LEX_STRING*)" -> "_current_thd()"
"check_string_byte_length(LEX_STRING*,const char*,uint)" -> "my_error(int,myf,...)"
"Item_func_match::Item_func_match(List<Item>&,uint)" -> "String::String()"
"Item_func_match::Item_func_match(List<Item>&,uint)" -> "DTCollation::DTCollation()"
"Item_func_match::Item_func_match(List<Item>&,uint)" -> "Item_real_func::Item_real_func(List<Item>&)"
"Item_real_func::Item_real_func(List<Item>&)" -> "Item_func::Item_func(List<Item>&)"
"Item_real_func::Item_real_func(List<Item>&)" -> "DTCollation::set_numeric()"
"Item_func_current_user::Item_func_current_user(Name_resolution_context*)" -> "Item_func_user::Item_func_user()"
"sp_instr_error::sp_instr_error(uint,sp_pcontext*,int)" -> "sp_instr::sp_instr(uint,sp_pcontext*)"
"Item_func_char::Item_func_char(List<Item>&)" -> "DTCollation::set(const CHARSET_INFO*)"
"Item_func_char::Item_func_char(List<Item>&)" -> "Item_str_func::Item_str_func(List<Item>&)"
"DTCollation::set(const CHARSET_INFO*)" -> "DTCollation::set_repertoire_from_charset(const CHARSET_INFO*)"
"Item_str_func::Item_str_func(List<Item>&)" -> "Item_func::Item_func(List<Item>&)"
"sp_create_assignment_instr(THD*,const char*)" -> "sp_head::is_invoked() const"
"sp_create_assignment_instr(THD*,const char*)" -> "sp_head::add_instr(THD*,sp_instr*)"
"sp_create_assignment_instr(THD*,const char*)" -> "base_list::is_empty() const"
"sp_create_assignment_instr(THD*,const char*)" -> "sp_head::restore_lex(THD*)"
"sp_create_assignment_instr(THD*,const char*)" -> "sp_head::instructions()"
"sp_create_assignment_instr(THD*,const char*)" -> "sp_instr_stmt::sp_instr_stmt(uint,LEX*,LEX_STRING)"
"sp_create_assignment_instr(THD*,const char*)" -> "Query_arena::alloc(size_t)"
"sp_create_assignment_instr(THD*,const char*)" -> "sp_parser_data::get_option_start_ptr() const"
"sp_create_assignment_instr(THD*,const char*)" -> "strmake(char*,const char*,size_t)"
"sp_head::restore_lex(THD*)" -> "LEX::set_trg_event_type_for_tables()"
"sp_head::restore_lex(THD*)" -> "is_update_query(enum_sql_command)"
"sp_head::restore_lex(THD*)" -> "sp_parser_data::pop_lex()"
"sp_head::restore_lex(THD*)" -> "lex_end(LEX*)"
"sp_head::restore_lex(THD*)" -> "sp_head::merge_table_list(THD*,TABLE_LIST*,LEX*)"
"sp_head::restore_lex(THD*)" -> "sp_update_sp_used_routines(HASH*,HASH*)"
"sp_head::restore_lex(THD*)" -> "Query_tables_list::get_stmt_unsafe_flags() const"
"sp_parser_data::pop_lex()" -> "List<T>::pop() [with T = LEX]"
"List<T>::pop() [with T = LEX]" -> "base_list::pop()"
"sp_head::merge_table_list(THD*,TABLE_LIST*,LEX*)" -> "my_hash_element(HASH*,ulong)"
"sp_head::merge_table_list(THD*,TABLE_LIST*,LEX*)" -> "String::String(char*,uint32,const CHARSET_INFO*)"
"sp_head::merge_table_list(THD*,TABLE_LIST*,LEX*)" -> "String::length(uint32)"
"sp_head::merge_table_list(THD*,TABLE_LIST*,LEX*)" -> "String::append(const char*,uint32)"
"sp_head::merge_table_list(THD*,TABLE_LIST*,LEX*)" -> "String::append(const char*)"
"sp_head::merge_table_list(THD*,TABLE_LIST*,LEX*)" -> "my_hash_insert(HASH*,const uchar*)"
"sp_head::merge_table_list(THD*,TABLE_LIST*,LEX*)" -> "my_hash_search(const HASH*,const uchar*,size_t)"
"sp_head::merge_table_list(THD*,TABLE_LIST*,LEX*)" -> "Query_arena::calloc(size_t)"
"sp_head::merge_table_list(THD*,TABLE_LIST*,LEX*)" -> "String::ptr() const"
"sp_head::merge_table_list(THD*,TABLE_LIST*,LEX*)" -> "String::append(char)"
"sp_head::merge_table_list(THD*,TABLE_LIST*,LEX*)" -> "Query_arena::memdup(const void*,size_t)"
"sp_head::merge_table_list(THD*,TABLE_LIST*,LEX*)" -> "String::length() const"
"sp_update_sp_used_routines(HASH*,HASH*)" -> "my_hash_search(const HASH*,const uchar*,size_t)"
"sp_update_sp_used_routines(HASH*,HASH*)" -> "my_hash_insert(HASH*,const uchar*)"
"sp_update_sp_used_routines(HASH*,HASH*)" -> "my_hash_element(HASH*,ulong)"
"sp_update_sp_used_routines(HASH*,HASH*)" -> "MDL_key::ptr() const"
"sp_update_sp_used_routines(HASH*,HASH*)" -> "MDL_key::length() const"
"Item_func_soundex::Item_func_soundex(Item*)" -> "String::String()"
"Item_func_soundex::Item_func_soundex(Item*)" -> "Item_str_func::Item_str_func(Item*)"
"Item_string::append(char*,uint)" -> "String::append(const char*,uint32)"
"Item_string::append(char*,uint)" -> "String::numchars() const"
"st_select_lex::end_nested_join(THD*)" -> "List<T>::push_front(T*) [with T = TABLE_LIST]"
"st_select_lex::end_nested_join(THD*)" -> "List<T>::pop() [with T = TABLE_LIST]"
"st_select_lex::end_nested_join(THD*)" -> "List<T>::head() [with T = TABLE_LIST]"
"Item_cond::add(Item*)" -> "List<T>::push_back(T*) [with T = Item]"
"Item_sum_count::Item_sum_count(Item*)" -> "Item_sum_int::Item_sum_int(Item*)"
"st_select_lex::add_index_hint(THD*,char*,uint)" -> "List<T>::push_front(T*) [with T = Index_hint]"
"st_select_lex::add_index_hint(THD*,char*,uint)" -> "Index_hint::Index_hint(index_hint_type,index_clause_map,char*,uint)"
"List<T>::push_front(T*) [with T = Index_hint]" -> "base_list::push_front(void*)"
"Index_hint::Index_hint(index_hint_type,index_clause_map,char*,uint)" -> "Sql_alloc::Sql_alloc()"
"Item_default_value::Item_default_value(Name_resolution_context*,Item*)" -> "Item_field::Item_field(Name_resolution_context*,const char*,const char*,const char*)"
"Item_sum_max::Item_sum_max(Item*)" -> "Item_sum_hybrid::Item_sum_hybrid(Item*,int)"
"Item_sum_hybrid::Item_sum_hybrid(Item*,int)" -> "DTCollation::set(const CHARSET_INFO*)"
"Item_sum_hybrid::Item_sum_hybrid(Item*,int)" -> "Item_sum::Item_sum(Item*)"
"Item_ref::Item_ref(Name_resolution_context*,const char*,const char*,const char*)" -> "Item_ident::Item_ident(Name_resolution_context*,const char*,const char*,const char*)"
"sp_pcontext::add_handler(THD*,sp_handler::enum_type)" -> "Dynamic_array<Elem>::append(const Elem&) [with Elem = sp_handler*]"
"sp_pcontext::add_handler(THD*,sp_handler::enum_type)" -> "sp_handler::sp_handler(sp_handler::enum_type,sp_pcontext*)"
"Dynamic_array<Elem>::append(const Elem&) [with Elem = sp_handler*]" -> "insert_dynamic(DYNAMIC_ARRAY*,const void*)"
"sp_handler::sp_handler(sp_handler::enum_type,sp_pcontext*)" -> "Sql_alloc::Sql_alloc()"
"sp_handler::sp_handler(sp_handler::enum_type,sp_pcontext*)" -> "List<T>::List() [with T = sp_condition_value]"
"List<T>::List() [with T = sp_condition_value]" -> "base_list::base_list()"
"Item_extract::Item_extract(interval_type,Item*)" -> "Item_int_func::Item_int_func(Item*)"
"Item_func_microsecond::Item_func_microsecond(Item*)" -> "Item_int_func::Item_int_func(Item*)"
"create_item_for_sp_var(THD*,LEX_STRING,sp_variable*,const char*,const char*,const char*)" -> "my_error(int,myf,...)"
"create_item_for_sp_var(THD*,LEX_STRING,sp_variable*,const char*,const char*,const char*)" -> "sp_pcontext::find_variable(LEX_STRING,bool) const"
"create_item_for_sp_var(THD*,LEX_STRING,sp_variable*,const char*,const char*,const char*)" -> "Item_splocal::Item_splocal(Name_string,uint,enum_field_types,uint,uint)"
"create_item_for_sp_var(THD*,LEX_STRING,sp_variable*,const char*,const char*,const char*)" -> "LEX::get_sp_current_parsing_ctx()"
"create_item_for_sp_var(THD*,LEX_STRING,sp_variable*,const char*,const char*,const char*)" -> "Name_string::Name_string(LEX_STRING)"
"Item_splocal::Item_splocal(Name_string,uint,enum_field_types,uint,uint)" -> "real_type_to_type(enum_field_types)"
"Item_splocal::Item_splocal(Name_string,uint,enum_field_types,uint,uint)" -> "sp_map_item_type(enum_field_types)"
"Item_splocal::Item_splocal(Name_string,uint,enum_field_types,uint,uint)" -> "Settable_routine_parameter::Settable_routine_parameter()"
"Item_splocal::Item_splocal(Name_string,uint,enum_field_types,uint,uint)" -> "sp_map_result_type(enum_field_types)"
"Item_splocal::Item_splocal(Name_string,uint,enum_field_types,uint,uint)" -> "Item_sp_variable::Item_sp_variable(Name_string)"
"Item_sp_variable::Item_sp_variable(Name_string)" -> "Item::Item()"
"Name_string::Name_string(LEX_STRING)" -> "Simple_cstring::Simple_cstring(LEX_STRING)"
"Simple_cstring::Simple_cstring(LEX_STRING)" -> "Simple_cstring::set(const char*,size_t)"
"Item_func_repeat::Item_func_repeat(Item*,Item*)" -> "Item_str_func::Item_str_func(Item*,Item*)"
"Item_func_repeat::Item_func_repeat(Item*,Item*)" -> "String::String()"
"Item_cond::add_at_head(List<Item>*)" -> "List<T>::prepand(List<T>*) [with T = Item]"
"List<T>::prepand(List<T>*) [with T = Item]" -> "base_list::prepand(base_list*)"
"base_list::prepand(base_list*)" -> "base_list::is_empty() const"
"select_dump::select_dump(sql_exchange*)" -> "select_to_file::select_to_file(sql_exchange*)"
"MYSQLlex(YYSTYPE*,THD*)" -> "lex_one_token(YYSTYPE*,THD*)"
"lex_one_token(YYSTYPE*,THD*)" -> "Lex_input_stream::cpp_inject(char)"
"lex_one_token(YYSTYPE*,THD*)" -> "Lex_input_stream::restore_in_comment_state()"
"lex_one_token(YYSTYPE*,THD*)" -> "Lex_input_stream::body_utf8_append_literal(THD*,const LEX_STRING*,const CHARSET_INFO*,const char*)"
"lex_one_token(YYSTYPE*,THD*)" -> "Lex_input_stream::yyPeekn(int)"
"lex_one_token(YYSTYPE*,THD*)" -> "consume_comment(Lex_input_stream*,int)"
"lex_one_token(YYSTYPE*,THD*)" -> "get_quoted_token(Lex_input_stream*,uint,uint,char)"
"lex_one_token(YYSTYPE*,THD*)" -> "find_keyword(Lex_input_stream*,uint,bool)"
"lex_one_token(YYSTYPE*,THD*)" -> "Lex_input_stream::yyPeek()"
"lex_one_token(YYSTYPE*,THD*)" -> "THD::charset()"
"lex_one_token(YYSTYPE*,THD*)" -> "int_token(const char*,uint)"
"lex_one_token(YYSTYPE*,THD*)" -> "get_charset_by_csname(const char*,uint,myf)"
"lex_one_token(YYSTYPE*,THD*)" -> "get_token(Lex_input_stream*,uint,uint)"
"lex_one_token(YYSTYPE*,THD*)" -> "Lex_input_stream::eof()"
"lex_one_token(YYSTYPE*,THD*)" -> "Lex_input_stream::restart_token()"
"lex_one_token(YYSTYPE*,THD*)" -> "Lex_input_stream::yyGet()"
"lex_one_token(YYSTYPE*,THD*)" -> "get_text(Lex_input_stream*,int,int)"
"lex_one_token(YYSTYPE*,THD*)" -> "Lex_input_stream::yySkip()"
"lex_one_token(YYSTYPE*,THD*)" -> "strtol(const char*,char**,int)"
"lex_one_token(YYSTYPE*,THD*)" -> "Lex_input_stream::yyUnput(char)"
"lex_one_token(YYSTYPE*,THD*)" -> "Lex_input_stream::get_cpp_ptr()"
"lex_one_token(YYSTYPE*,THD*)" -> "Lex_input_stream::yyGetLast()"
"lex_one_token(YYSTYPE*,THD*)" -> "Lex_input_stream::get_end_of_query()"
"lex_one_token(YYSTYPE*,THD*)" -> "Lex_input_stream::yyUnget()"
"lex_one_token(YYSTYPE*,THD*)" -> "Lex_input_stream::body_utf8_append(const char*,const char*)"
"lex_one_token(YYSTYPE*,THD*)" -> "Lex_input_stream::skip_binary(int)"
"lex_one_token(YYSTYPE*,THD*)" -> "Lex_input_stream::set_echo(bool)"
"lex_one_token(YYSTYPE*,THD*)" -> "Lex_input_stream::yySkipn(int)"
"lex_one_token(YYSTYPE*,THD*)" -> "Lex_input_stream::get_cpp_tok_start()"
"lex_one_token(YYSTYPE*,THD*)" -> "Lex_input_stream::save_in_comment_state()"
"lex_one_token(YYSTYPE*,THD*)" -> "Lex_input_stream::start_token()"
"lex_one_token(YYSTYPE*,THD*)" -> "Lex_input_stream::yyLength()"
"lex_one_token(YYSTYPE*,THD*)" -> "Lex_input_stream::body_utf8_append(const char*)"
"lex_one_token(YYSTYPE*,THD*)" -> "Lex_input_stream::get_cpp_buf()"
"lex_one_token(YYSTYPE*,THD*)" -> "Lex_input_stream::get_ptr()"
"Lex_input_stream::body_utf8_append_literal(THD*,const LEX_STRING*,const CHARSET_INFO*,const char*)" -> "my_charset_same(const CHARSET_INFO*,const CHARSET_INFO*)"
"Lex_input_stream::body_utf8_append_literal(THD*,const LEX_STRING*,const CHARSET_INFO*,const char*)" -> "memcpy(void*,const void*,size_t)"
"Lex_input_stream::body_utf8_append_literal(THD*,const LEX_STRING*,const CHARSET_INFO*,const char*)" -> "THD::convert_string(LEX_STRING*,const CHARSET_INFO*,const char*,uint,const CHARSET_INFO*)"
"THD::convert_string(LEX_STRING*,const CHARSET_INFO*,const char*,uint,const CHARSET_INFO*)" -> "copy_and_convert(char*,uint32,const CHARSET_INFO*,const char*,uint32,const CHARSET_INFO*,uint*)"
"THD::convert_string(LEX_STRING*,const CHARSET_INFO*,const char*,uint,const CHARSET_INFO*)" -> "Query_arena::alloc(size_t)"
"consume_comment(Lex_input_stream*,int)" -> "consume_comment(Lex_input_stream*,int)"
"consume_comment(Lex_input_stream*,int)" -> "Lex_input_stream::eof()"
"consume_comment(Lex_input_stream*,int)" -> "Lex_input_stream::yyGet()"
"consume_comment(Lex_input_stream*,int)" -> "Lex_input_stream::yySkip()"
"consume_comment(Lex_input_stream*,int)" -> "Lex_input_stream::yyPeek()"
"get_quoted_token(Lex_input_stream*,uint,uint,char)" -> "Lex_input_stream::get_tok_start()"
"get_quoted_token(Lex_input_stream*,uint,uint,char)" -> "Query_arena::alloc(size_t)"
"get_quoted_token(Lex_input_stream*,uint,uint,char)" -> "Lex_input_stream::yyUnget()"
"get_quoted_token(Lex_input_stream*,uint,uint,char)" -> "Lex_input_stream::get_cpp_tok_start()"
"find_keyword(Lex_input_stream*,uint,bool)" -> "Lex_input_stream::get_tok_start()"
"find_keyword(Lex_input_stream*,uint,bool)" -> "get_hash_symbol(const char*,unsigned int,bool)"
"get_token(Lex_input_stream*,uint,uint)" -> "Lex_input_stream::yyUnget()"
"get_token(Lex_input_stream*,uint,uint)" -> "Lex_input_stream::get_tok_start()"
"get_token(Lex_input_stream*,uint,uint)" -> "Query_arena::strmake(const char*,size_t)"
"get_token(Lex_input_stream*,uint,uint)" -> "Lex_input_stream::get_cpp_tok_start()"
"get_text(Lex_input_stream*,int,int)" -> "Lex_input_stream::yyUnget()"
"get_text(Lex_input_stream*,int,int)" -> "Query_arena::alloc(size_t)"
"get_text(Lex_input_stream*,int,int)" -> "Lex_input_stream::eof()"
"get_text(Lex_input_stream*,int,int)" -> "Lex_input_stream::get_end_of_query()"
"get_text(Lex_input_stream*,int,int)" -> "Lex_input_stream::get_cpp_tok_start()"
"get_text(Lex_input_stream*,int,int)" -> "Lex_input_stream::yyGet()"
"get_text(Lex_input_stream*,int,int)" -> "Lex_input_stream::get_tok_start()"
"get_text(Lex_input_stream*,int,int)" -> "THD::charset()"
"get_text(Lex_input_stream*,int,int)" -> "Lex_input_stream::skip_binary(int)"
"get_text(Lex_input_stream*,int,int)" -> "Lex_input_stream::yySkip()"
"get_text(Lex_input_stream*,int,int)" -> "Lex_input_stream::get_cpp_ptr()"
"get_text(Lex_input_stream*,int,int)" -> "Lex_input_stream::get_ptr()"
"get_text(Lex_input_stream*,int,int)" -> "Lex_input_stream::yyGetLast()"
"get_text(Lex_input_stream*,int,int)" -> "memcpy(void*,const void*,size_t)"
"Lex_input_stream::skip_binary(int)" -> "memcpy(void*,const void*,size_t)"
"Lex_input_stream::body_utf8_append(const char*,const char*)" -> "memcpy(void*,const void*,size_t)"
"Lex_input_stream::yySkipn(int)" -> "memcpy(void*,const void*,size_t)"
"Lex_input_stream::body_utf8_append(const char*)" -> "Lex_input_stream::body_utf8_append(const char*,const char*)"
"Statement_information::Statement_information(List<Statement_information_item>*)" -> "Diagnostics_information::Diagnostics_information()"
"Diagnostics_information::Diagnostics_information()" -> "Sql_alloc::Sql_alloc()"
"Item_func_curtime_local::Item_func_curtime_local(uint8)" -> "Item_func_curtime::Item_func_curtime(uint8)"
"Item_func_curtime::Item_func_curtime(uint8)" -> "MYSQL_TIME_cache::MYSQL_TIME_cache()"
"Item_func_curtime::Item_func_curtime(uint8)" -> "Item_time_func::Item_time_func()"
"Item_time_func::Item_time_func()" -> "Item_temporal_func::Item_temporal_func()"
"Item_row::Item_row(List<Item>&)" -> "Item::Item()"
"Item_row::Item_row(List<Item>&)" -> "sql_alloc(size_t)"
"Item_row::Item_row(List<Item>&)" -> "List_iterator<T>::List_iterator(List<T>&) [with T = Item]"
"Item_row::Item_row(List<Item>&)" -> "List_iterator<T>::operator++(int) [with T = Item]"
"List_iterator<T>::List_iterator(List<T>&) [with T = Item]" -> "base_list_iterator::base_list_iterator(base_list&)"
"List_iterator<T>::operator++(int) [with T = Item]" -> "base_list_iterator::next()"
"Item_datetime_typecast::Item_datetime_typecast(Item*)" -> "Item_datetime_func::Item_datetime_func(Item*)"
"List<T>::push_back(T*) [with T = st_lex_user]" -> "base_list::push_back(void*)"
"Item_sum_or::Item_sum_or(Item*)" -> "Item_sum_bit::Item_sum_bit(Item*,ulonglong)"
"Item_sum_avg::Item_sum_avg(Item*,bool)" -> "Item_sum_sum::Item_sum_sum(Item*,bool)"
"Item_sum_sum::Item_sum_sum(Item*,bool)" -> "Item_sum::set_distinct(bool)"
"Item_sum_sum::Item_sum_sum(Item*,bool)" -> "my_decimal::my_decimal()"
"Item_sum_sum::Item_sum_sum(Item*,bool)" -> "Item_sum_num::Item_sum_num(Item*)"
"fill_field_definition(THD*,sp_head*,enum_field_types,Create_field*)" -> "create_typelib(MEM_ROOT*,Create_field*,List<String>*)"
"fill_field_definition(THD*,sp_head*,enum_field_types,Create_field*)" -> "sp_head::get_current_mem_root() const"
"fill_field_definition(THD*,sp_head*,enum_field_types,Create_field*)" -> "prepare_create_field(Create_field*,uint*,longlong)"
"fill_field_definition(THD*,sp_head*,enum_field_types,Create_field*)" -> "sp_prepare_create_field(THD*,Create_field*)"
"fill_field_definition(THD*,sp_head*,enum_field_types,Create_field*)" -> "Create_field::init(THD*,const char*,enum_field_types,const char*,const char*,uint,Item*,Item*,LEX_STRING*,const char*,List<String>*,const CHARSET_INFO*,uint)"
"create_typelib(MEM_ROOT*,Create_field*,List<String>*)" -> "String::length() const"
"create_typelib(MEM_ROOT*,Create_field*,List<String>*)" -> "String::String()"
"create_typelib(MEM_ROOT*,Create_field*,List<String>*)" -> "String::ptr() const"
"create_typelib(MEM_ROOT*,Create_field*,List<String>*)" -> "String::needs_conversion(uint32,const CHARSET_INFO*,const CHARSET_INFO*,uint32*)"
"create_typelib(MEM_ROOT*,Create_field*,List<String>*)" -> "alloc_root(MEM_ROOT*,size_t)"
"create_typelib(MEM_ROOT*,Create_field*,List<String>*)" -> "strmake_root(MEM_ROOT*,const char*,size_t)"
"create_typelib(MEM_ROOT*,Create_field*,List<String>*)" -> "List_iterator<T>::List_iterator(List<T>&) [with T = String]"
"create_typelib(MEM_ROOT*,Create_field*,List<String>*)" -> "String::charset() const"
"create_typelib(MEM_ROOT*,Create_field*,List<String>*)" -> "String::copy(const char*,uint32,const CHARSET_INFO*,const CHARSET_INFO*,uint*)"
"create_typelib(MEM_ROOT*,Create_field*,List<String>*)" -> "List_iterator<T>::operator++(int) [with T = String]"
"prepare_create_field(Create_field*,uint*,longlong)" -> "my_error(int,myf,...)"
"prepare_create_field(Create_field*,uint*,longlong)" -> "pack_length_to_packflag(uint)"
"prepare_create_field(Create_field*,uint*,longlong)" -> "my_printf_error(uint,const char*,myf,...)"
"prepare_create_field(Create_field*,uint*,longlong)" -> "_current_thd()"
"prepare_create_field(Create_field*,uint*,longlong)" -> "calc_pack_length(enum_field_types,uint32)"
"prepare_create_field(Create_field*,uint*,longlong)" -> "check_duplicates_in_interval(const char*,const char*,TYPELIB*,const CHARSET_INFO*,uint*)"
"check_duplicates_in_interval(const char*,const char*,TYPELIB*,const CHARSET_INFO*,uint*)" -> "find_type2(const TYPELIB*,const char*,uint,const CHARSET_INFO*)"
"check_duplicates_in_interval(const char*,const char*,TYPELIB*,const CHARSET_INFO*,uint*)" -> "push_warning_printf(THD*,Sql_condition::enum_warning_level,uint,const char*,...)"
"check_duplicates_in_interval(const char*,const char*,TYPELIB*,const CHARSET_INFO*,uint*)" -> "THD::is_strict_mode() const"
"check_duplicates_in_interval(const char*,const char*,TYPELIB*,const CHARSET_INFO*,uint*)" -> "my_error(int,myf,...)"
"check_duplicates_in_interval(const char*,const char*,TYPELIB*,const CHARSET_INFO*,uint*)" -> "ErrConvString::ErrConvString(const char*,uint,const CHARSET_INFO*)"
"check_duplicates_in_interval(const char*,const char*,TYPELIB*,const CHARSET_INFO*,uint*)" -> "_current_thd()"
"check_duplicates_in_interval(const char*,const char*,TYPELIB*,const CHARSET_INFO*,uint*)" -> "ErrConvString::ptr()"
"sp_prepare_create_field(THD*,Create_field*)" -> "Create_field::create_length_to_internal_length()"
"sp_prepare_create_field(THD*,Create_field*)" -> "calculate_interval_lengths(const CHARSET_INFO*,TYPELIB*,uint32*,uint32*)"
"sp_prepare_create_field(THD*,Create_field*)" -> "prepare_blob_field(THD*,Create_field*)"
"Create_field::create_length_to_internal_length()" -> "calc_pack_length(enum_field_types,uint32)"
"Create_field::create_length_to_internal_length()" -> "my_decimal_length_to_precision(uint,uint,bool)"
"Create_field::create_length_to_internal_length()" -> "my_decimal_get_binary_size(uint,uint)"
"prepare_blob_field(THD*,Create_field*)" -> "push_warning(THD*,Sql_condition::enum_warning_level,uint,const char*)"
"prepare_blob_field(THD*,Create_field*)" -> "my_error(int,myf,...)"
"prepare_blob_field(THD*,Create_field*)" -> "_current_thd()"
"prepare_blob_field(THD*,Create_field*)" -> "get_blob_type_from_length(ulong)"
"prepare_blob_field(THD*,Create_field*)" -> "THD::is_strict_mode() const"
"prepare_blob_field(THD*,Create_field*)" -> "calc_pack_length(enum_field_types,uint32)"
"prepare_blob_field(THD*,Create_field*)" -> "my_snprintf(char*,size_t,const char*,...)"
"Alter_column::Alter_column(const char*,Item*)" -> "Sql_alloc::Sql_alloc()"
"Item_func_sysdate_local::Item_func_sysdate_local(uint8)" -> "Item_datetime_func::Item_datetime_func()"
"List<T>::push_back(T*) [with T = partition_element]" -> "base_list::push_back(void*)"
"Item_func_curdate_utc::Item_func_curdate_utc()" -> "Item_func_curdate::Item_func_curdate()"
"Item_func_conv_charset::Item_func_conv_charset(Item*,const CHARSET_INFO*)" -> "String::String()"
"Item_func_conv_charset::Item_func_conv_charset(Item*,const CHARSET_INFO*)" -> "Item_str_func::Item_str_func(Item*)"
"create_select_for_variable(const char*)" -> "_current_thd()"
"create_select_for_variable(const char*)" -> "Name_string::copy(const char*,size_t)"
"create_select_for_variable(const char*)" -> "add_item_to_list(THD*,Item*)"
"create_select_for_variable(const char*)" -> "strxmov(char*,const char*,...)"
"create_select_for_variable(const char*)" -> "strlen(const char*)"
"create_select_for_variable(const char*)" -> "mysql_init_select(LEX*)"
"create_select_for_variable(const char*)" -> "memset(void*,int,size_t)"
"create_select_for_variable(const char*)" -> "get_system_var(THD*,enum_var_type,LEX_STRING,LEX_STRING)"
"add_item_to_list(THD*,Item*)" -> "st_select_lex::add_item_to_list(THD*,Item*)"
"st_select_lex::add_item_to_list(THD*,Item*)" -> "List<T>::push_back(T*) [with T = Item]"
"sp_condition_value::sp_condition_value(const char*)" -> "memcpy(void*,const void*,size_t)"
"sp_condition_value::sp_condition_value(const char*)" -> "Sql_alloc::Sql_alloc()"
"Sql_cmd_handler_open::Sql_cmd_handler_open()" -> "Sql_cmd::Sql_cmd()"
"Item_func_charset::Item_func_charset(Item*)" -> "Item_str_func::Item_str_func(Item*)"
"create_temporal_literal(THD*,const char*,uint,const CHARSET_INFO*,enum_field_types,bool)" -> "Item_date_literal::Item_date_literal(MYSQL_TIME*)"
"create_temporal_literal(THD*,const char*,uint,const CHARSET_INFO*,enum_field_types,bool)" -> "Item_time_literal::Item_time_literal(MYSQL_TIME*,uint)"
"create_temporal_literal(THD*,const char*,uint,const CHARSET_INFO*,enum_field_types,bool)" -> "Item_datetime_literal::Item_datetime_literal(MYSQL_TIME*,uint)"
"create_temporal_literal(THD*,const char*,uint,const CHARSET_INFO*,enum_field_types,bool)" -> "ErrConvString::ptr()"
"create_temporal_literal(THD*,const char*,uint,const CHARSET_INFO*,enum_field_types,bool)" -> "my_error(int,myf,...)"
"create_temporal_literal(THD*,const char*,uint,const CHARSET_INFO*,enum_field_types,bool)" -> "THD::datetime_flags() const"
"create_temporal_literal(THD*,const char*,uint,const CHARSET_INFO*,enum_field_types,bool)" -> "str_to_datetime(const CHARSET_INFO*,const char*,uint,MYSQL_TIME*,uint,MYSQL_TIME_STATUS*)"
"create_temporal_literal(THD*,const char*,uint,const CHARSET_INFO*,enum_field_types,bool)" -> "str_to_time(const CHARSET_INFO*,const char*,uint,MYSQL_TIME*,uint,MYSQL_TIME_STATUS*)"
"create_temporal_literal(THD*,const char*,uint,const CHARSET_INFO*,enum_field_types,bool)" -> "ErrConvString::ErrConvString(const char*,uint,const CHARSET_INFO*)"
"Item_date_literal::Item_date_literal(MYSQL_TIME*)" -> "MYSQL_TIME_cache::set_date(MYSQL_TIME*)"
"Item_date_literal::Item_date_literal(MYSQL_TIME*)" -> "MYSQL_TIME_cache::MYSQL_TIME_cache()"
"Item_date_literal::Item_date_literal(MYSQL_TIME*)" -> "Item_date_func::Item_date_func()"
"Item_date_literal::Item_date_literal(MYSQL_TIME*)" -> "Item_date_literal::fix_length_and_dec()"
"MYSQL_TIME_cache::set_date(MYSQL_TIME*)" -> "MYSQL_TIME_cache::reset_string()"
"MYSQL_TIME_cache::set_date(MYSQL_TIME*)" -> "TIME_to_longlong_date_packed(const MYSQL_TIME*)"
"Item_date_literal::fix_length_and_dec()" -> "Item::fix_length_and_dec_and_charset_datetime(uint32,uint8)"
"Item::fix_length_and_dec_and_charset_datetime(uint32,uint8)" -> "Item::fix_length_and_charset_datetime(uint32)"
"Item::fix_length_and_charset_datetime(uint32)" -> "Item::fix_char_length(uint32)"
"Item::fix_length_and_charset_datetime(uint32)" -> "DTCollation::set(const CHARSET_INFO*,Derivation,uint)"
"Item_time_literal::Item_time_literal(MYSQL_TIME*,uint)" -> "MYSQL_TIME_cache::MYSQL_TIME_cache()"
"Item_time_literal::Item_time_literal(MYSQL_TIME*,uint)" -> "MYSQL_TIME_cache::set_time(MYSQL_TIME*,uint8)"
"Item_time_literal::Item_time_literal(MYSQL_TIME*,uint)" -> "Item_time_func::Item_time_func()"
"Item_time_literal::Item_time_literal(MYSQL_TIME*,uint)" -> "Item_time_literal::fix_length_and_dec()"
"MYSQL_TIME_cache::set_time(MYSQL_TIME*,uint8)" -> "MYSQL_TIME_cache::reset_string()"
"MYSQL_TIME_cache::set_time(MYSQL_TIME*,uint8)" -> "TIME_to_longlong_time_packed(const MYSQL_TIME*)"
"Item_time_literal::fix_length_and_dec()" -> "Item::fix_length_and_dec_and_charset_datetime(uint32,uint8)"
"Item_datetime_literal::Item_datetime_literal(MYSQL_TIME*,uint)" -> "Item_datetime_literal::fix_length_and_dec()"
"Item_datetime_literal::Item_datetime_literal(MYSQL_TIME*,uint)" -> "MYSQL_TIME_cache::MYSQL_TIME_cache()"
"Item_datetime_literal::Item_datetime_literal(MYSQL_TIME*,uint)" -> "Item_datetime_func::Item_datetime_func()"
"Item_datetime_literal::Item_datetime_literal(MYSQL_TIME*,uint)" -> "MYSQL_TIME_cache::set_datetime(MYSQL_TIME*,uint8)"
"Item_datetime_literal::fix_length_and_dec()" -> "Item::fix_length_and_dec_and_charset_datetime(uint32,uint8)"
"MYSQL_TIME_cache::set_datetime(MYSQL_TIME*,uint8)" -> "MYSQL_TIME_cache::reset_string()"
"MYSQL_TIME_cache::set_datetime(MYSQL_TIME*,uint8)" -> "TIME_to_longlong_datetime_packed(const MYSQL_TIME*)"
"str_to_datetime(const CHARSET_INFO*,const char*,uint,MYSQL_TIME*,uint,MYSQL_TIME_STATUS*)" -> "to_ascii(const CHARSET_INFO*,const char*,uint,char*,uint)"
"str_to_datetime(const CHARSET_INFO*,const char*,uint,MYSQL_TIME*,uint,MYSQL_TIME_STATUS*)" -> "datetime_add_nanoseconds_with_round(MYSQL_TIME*,uint,int*)"
"str_to_datetime(const CHARSET_INFO*,const char*,uint,MYSQL_TIME*,uint,MYSQL_TIME_STATUS*)" -> "str_to_datetime(const char*,uint,MYSQL_TIME*,ulonglong,MYSQL_TIME_STATUS*)"
"datetime_add_nanoseconds_with_round(MYSQL_TIME*,uint,int*)" -> "date_add_interval(MYSQL_TIME*,interval_type,INTERVAL)"
"datetime_add_nanoseconds_with_round(MYSQL_TIME*,uint,int*)" -> "non_zero_date(const MYSQL_TIME*)"
"datetime_add_nanoseconds_with_round(MYSQL_TIME*,uint,int*)" -> "memset(void*,int,size_t)"
"datetime_add_nanoseconds_with_round(MYSQL_TIME*,uint,int*)" -> "check_date(const MYSQL_TIME*,my_bool,ulonglong,int*)"
"date_add_interval(MYSQL_TIME*,interval_type,INTERVAL)" -> "calc_daynr(uint,uint,uint)"
"date_add_interval(MYSQL_TIME*,interval_type,INTERVAL)" -> "push_warning_printf(THD*,Sql_condition::enum_warning_level,uint,const char*,...)"
"date_add_interval(MYSQL_TIME*,interval_type,INTERVAL)" -> "calc_days_in_year(uint)"
"date_add_interval(MYSQL_TIME*,interval_type,INTERVAL)" -> "_current_thd()"
"date_add_interval(MYSQL_TIME*,interval_type,INTERVAL)" -> "get_date_from_daynr(long int,uint*,uint*,uint*)"
"get_date_from_daynr(long int,uint*,uint*,uint*)" -> "calc_days_in_year(uint)"
"str_to_time(const CHARSET_INFO*,const char*,uint,MYSQL_TIME*,uint,MYSQL_TIME_STATUS*)" -> "str_to_time(const char*,uint,MYSQL_TIME*,MYSQL_TIME_STATUS*)"
"str_to_time(const CHARSET_INFO*,const char*,uint,MYSQL_TIME*,uint,MYSQL_TIME_STATUS*)" -> "time_add_nanoseconds_with_round(MYSQL_TIME*,uint,int*)"
"str_to_time(const CHARSET_INFO*,const char*,uint,MYSQL_TIME*,uint,MYSQL_TIME_STATUS*)" -> "to_ascii(const CHARSET_INFO*,const char*,uint,char*,uint)"
"time_add_nanoseconds_with_round(MYSQL_TIME*,uint,int*)" -> "adjust_time_range(st_mysql_time*,int*)"
"case_stmt_action_end_case(LEX*,bool)" -> "sp_pcontext::pop_case_expr_id()"
"case_stmt_action_end_case(LEX*,bool)" -> "sp_parser_data::do_backpatch(sp_label*,uint)"
"case_stmt_action_end_case(LEX*,bool)" -> "sp_pcontext::pop_label()"
"case_stmt_action_end_case(LEX*,bool)" -> "sp_parser_data::do_cont_backpatch(uint)"
"case_stmt_action_end_case(LEX*,bool)" -> "sp_head::instructions()"
"case_stmt_action_end_case(LEX*,bool)" -> "LEX::get_sp_current_parsing_ctx()"
"sp_pcontext::pop_case_expr_id()" -> "Dynamic_array<Elem>::pop() [with Elem = int]"
"Dynamic_array<Elem>::pop() [with Elem = int]" -> "pop_dynamic(DYNAMIC_ARRAY*)"
"sp_parser_data::do_cont_backpatch(uint)" -> "sp_lex_branch_instr::set_cont_dest(uint)"
"sp_parser_data::do_cont_backpatch(uint)" -> "List<T>::pop() [with T = sp_lex_branch_instr]"
"sp_parser_data::do_cont_backpatch(uint)" -> "List<T>::head() [with T = sp_lex_branch_instr]"
"List<T>::pop() [with T = sp_lex_branch_instr]" -> "base_list::pop()"
"List<T>::head() [with T = sp_lex_branch_instr]" -> "base_list::head()"
"add_group_to_list(THD*,Item*,bool)" -> "st_select_lex::add_group_to_list(THD*,Item*,bool)"
"st_select_lex::add_group_to_list(THD*,Item*,bool)" -> "add_to_list(THD*,SQL_I_List<st_order>&,Item*,bool)"
"sp_instr_set::sp_instr_set(uint,LEX*,uint,Item*,LEX_STRING,bool)" -> "LEX::get_sp_current_parsing_ctx()"
"sp_instr_set::sp_instr_set(uint,LEX*,uint,Item*,LEX_STRING,bool)" -> "sp_lex_instr::sp_lex_instr(uint,sp_pcontext*,LEX*,bool)"
"Item_func_in::Item_func_in(List<Item>&)" -> "memset(void*,int,size_t)"
"Item_func_in::Item_func_in(List<Item>&)" -> "DTCollation::DTCollation()"
"Item_func_in::Item_func_in(List<Item>&)" -> "Item_func_opt_neg::Item_func_opt_neg(List<Item>&)"
"Item_func_opt_neg::Item_func_opt_neg(List<Item>&)" -> "Item_int_func::Item_int_func(List<Item>&)"
"Item_int_func::Item_int_func(List<Item>&)" -> "DTCollation::set_numeric()"
"Item_int_func::Item_int_func(List<Item>&)" -> "Item::fix_char_length(uint32)"
"Item_int_func::Item_int_func(List<Item>&)" -> "Item_func::Item_func(List<Item>&)"
"Item_func_ltrim::Item_func_ltrim(Item*)" -> "Item_func_trim::Item_func_trim(Item*)"
"sp_pcontext::diff_cursors(const sp_pcontext*,bool) const" -> "Dynamic_array<Elem>::elements() const [with Elem = st_mysql_lex_string]"
"sp_pcontext::diff_cursors(const sp_pcontext*,bool) const" -> "sp_pcontext::parent_context() const"
"Item_func_get_user_var::Item_func_get_user_var(Name_string)" -> "Item_var_func::Item_var_func()"
"Item_func_get_user_var::Item_func_get_user_var(Name_string)" -> "Settable_routine_parameter::Settable_routine_parameter()"
"my_yyoverflow(short int**,YYSTYPE**,ulong*)" -> "memcpy(void*,const void*,size_t)"
"my_yyoverflow(short int**,YYSTYPE**,ulong*)" -> "_current_thd()"
"my_yyoverflow(short int**,YYSTYPE**,ulong*)" -> "set_zone(int,int,int)"
"my_yyoverflow(short int**,YYSTYPE**,ulong*)" -> "my_realloc(void*,size_t,myf)"
"Item_func_istrue::Item_func_istrue(Item*)" -> "Item_func_truth::Item_func_truth(Item*,bool,bool)"
"partition_element::partition_element()" -> "List<T>::List() [with T = partition_element]"
"partition_element::partition_element()" -> "List<T>::List() [with T = p_elem_val]"
"partition_element::partition_element()" -> "Sql_alloc::Sql_alloc()"
"List<T>::List() [with T = p_elem_val]" -> "base_list::base_list()"
"Item_func_isnull::Item_func_isnull(Item*)" -> "Item_bool_func::Item_bool_func(Item*)"
"Item_func_spatial_collection::Item_func_spatial_collection(List<Item>&,Geometry::wkbType,Geometry::wkbType)" -> "Item_geometry_func::Item_geometry_func(List<Item>&)"
"Item_func_spatial_collection::Item_func_spatial_collection(List<Item>&,Geometry::wkbType,Geometry::wkbType)" -> "String::String()"
"Item_geometry_func::Item_geometry_func(List<Item>&)" -> "Item_str_func::Item_str_func(List<Item>&)"
"sp_pcontext::context_var_count() const" -> "Dynamic_array<Elem>::elements() const [with Elem = sp_variable*]"
"sp_finish_parsing(THD*)" -> "sp_parser_data::finish_parsing_sp_body(THD*)"
"sp_finish_parsing(THD*)" -> "sp_head::set_body_end(THD*)"
"sp_head::set_body_end(THD*)" -> "THD::charset()"
"sp_head::set_body_end(THD*)" -> "Lex_input_stream::get_cpp_ptr()"
"sp_head::set_body_end(THD*)" -> "Lex_input_stream::get_body_utf8_length()"
"sp_head::set_body_end(THD*)" -> "sp_parser_data::get_parameter_start_ptr() const"
"sp_head::set_body_end(THD*)" -> "trim_whitespace(const CHARSET_INFO*,LEX_STRING*)"
"sp_head::set_body_end(THD*)" -> "sp_parser_data::get_body_start_ptr() const"
"sp_head::set_body_end(THD*)" -> "sp_parser_data::get_parameter_end_ptr() const"
"sp_head::set_body_end(THD*)" -> "Lex_input_stream::get_cpp_buf()"
"sp_head::set_body_end(THD*)" -> "Lex_input_stream::body_utf8_append(const char*)"
"sp_head::set_body_end(THD*)" -> "Query_arena::strmake(const char*,size_t)"
"sp_head::set_body_end(THD*)" -> "Lex_input_stream::get_body_utf8_str()"
"Sql_cmd_discard_import_tablespace::Sql_cmd_discard_import_tablespace(Sql_cmd_discard_import_tablespace::enum_tablespace_op_type)" -> "Sql_cmd_common_alter_table::Sql_cmd_common_alter_table()"
"Sql_cmd_common_alter_table::Sql_cmd_common_alter_table()" -> "Sql_cmd::Sql_cmd()"
"find_udf(const char*,uint,bool)" -> "strlen(const char*)"
"find_udf(const char*,uint,bool)" -> "inline_mysql_rwlock_rdlock(mysql_rwlock_t*)"
"find_udf(const char*,uint,bool)" -> "inline_mysql_rwlock_wrlock(mysql_rwlock_t*)"
"find_udf(const char*,uint,bool)" -> "inline_mysql_rwlock_unlock(mysql_rwlock_t*)"
"find_udf(const char*,uint,bool)" -> "my_hash_search(const HASH*,const uchar*,size_t)"
"LEX_COLUMN::LEX_COLUMN(const String&,const uint&)" -> "String::String(const String&)"
"LEX_COLUMN::LEX_COLUMN(const String&,const uint&)" -> "Sql_alloc::Sql_alloc()"
"List<T>::push_back(T*) [with T = Condition_information_item]" -> "base_list::push_back(void*)"
"Item_func_insert::Item_func_insert(Item*,Item*,Item*,Item*)" -> "String::String()"
"Item_func_insert::Item_func_insert(Item*,Item*,Item*,Item*)" -> "Item_str_func::Item_str_func(Item*,Item*,Item*,Item*)"
"Item_str_func::Item_str_func(Item*,Item*,Item*,Item*)" -> "Item_func::Item_func(Item*,Item*,Item*,Item*)"
"Item_func::Item_func(Item*,Item*,Item*,Item*)" -> "Item_result_field::Item_result_field()"
"Item_func::Item_func(Item*,Item*,Item*,Item*)" -> "sql_alloc(size_t)"
"Item_func_shift_left::Item_func_shift_left(Item*,Item*)" -> "Item_func_bit::Item_func_bit(Item*,Item*)"
"add_create_index_prepare(LEX*,Table_ident*)" -> "base_list::empty()"
"add_create_index_prepare(LEX*,Table_ident*)" -> "Alter_info::reset()"
"Item_func_rtrim::Item_func_rtrim(Item*)" -> "Item_func_trim::Item_func_trim(Item*)"
"select_dumpvar::select_dumpvar()" -> "base_list::empty()"
"select_dumpvar::select_dumpvar()" -> "List<T>::List() [with T = my_var]"
"select_dumpvar::select_dumpvar()" -> "select_result_interceptor::select_result_interceptor()"
"List<T>::List() [with T = my_var]" -> "base_list::base_list()"
"Item_func_get_format::Item_func_get_format(timestamp_type,Item*)" -> "Item_str_ascii_func::Item_str_ascii_func(Item*)"
"List<T>::push_back(T*) [with T = Statement_information_item]" -> "base_list::push_back(void*)"
"add_value_to_list(THD*,Item*)" -> "List<T>::push_back(T*) [with T = Item]"
"Item_string::Item_string(Name_string,const char*,uint,const CHARSET_INFO*,Derivation,uint)" -> "Item_name_string::Item_name_string(Name_string)"
"Item_string::Item_string(Name_string,const char*,uint,const CHARSET_INFO*,Derivation,uint)" -> "String::set_or_copy_aligned(const char*,uint32,const CHARSET_INFO*)"
"Item_string::Item_string(Name_string,const char*,uint,const CHARSET_INFO*,Derivation,uint)" -> "__builtin_memcpy(void*,const void*,long unsigned int)"
"Item_string::Item_string(Name_string,const char*,uint,const CHARSET_INFO*,Derivation,uint)" -> "String::numchars() const"
"Item_string::Item_string(Name_string,const char*,uint,const CHARSET_INFO*,Derivation,uint)" -> "Item_basic_constant::Item_basic_constant()"
"Item_string::Item_string(Name_string,const char*,uint,const CHARSET_INFO*,Derivation,uint)" -> "DTCollation::set(const CHARSET_INFO*,Derivation,uint)"
"Item_decimal::Item_decimal(const char*,uint,const CHARSET_INFO*)" -> "str2my_decimal(uint,const char*,uint,const CHARSET_INFO*,my_decimal*)"
"Item_decimal::Item_decimal(const char*,uint,const CHARSET_INFO*)" -> "my_decimal::my_decimal()"
"Item_decimal::Item_decimal(const char*,uint,const CHARSET_INFO*)" -> "Item_num::Item_num()"
"Item_decimal::Item_decimal(const char*,uint,const CHARSET_INFO*)" -> "Simple_cstring::set(const char*)"
"Item_decimal::Item_decimal(const char*,uint,const CHARSET_INFO*)" -> "my_decimal_precision_to_length_no_truncation(uint,uint8,bool)"
"str2my_decimal(uint,const char*,uint,const CHARSET_INFO*,my_decimal*)" -> "check_result_and_overflow(uint,int,my_decimal*)"
"str2my_decimal(uint,const char*,uint,const CHARSET_INFO*,my_decimal*)" -> "internal_str2dec(const char*,decimal_t*,char**,my_bool)"
"str2my_decimal(uint,const char*,uint,const CHARSET_INFO*,my_decimal*)" -> "String::length() const"
"str2my_decimal(uint,const char*,uint,const CHARSET_INFO*,my_decimal*)" -> "String::ptr() const"
"str2my_decimal(uint,const char*,uint,const CHARSET_INFO*,my_decimal*)" -> "String::String(char*,uint32,const CHARSET_INFO*)"
"str2my_decimal(uint,const char*,uint,const CHARSET_INFO*,my_decimal*)" -> "String::copy(const char*,uint32,const CHARSET_INFO*,const CHARSET_INFO*,uint*)"
"check_result_and_overflow(uint,int,my_decimal*)" -> "check_result(uint,int)"
"check_result_and_overflow(uint,int,my_decimal*)" -> "my_decimal::sign() const"
"check_result_and_overflow(uint,int,my_decimal*)" -> "my_decimal::fix_buffer_pointer()"
"check_result_and_overflow(uint,int,my_decimal*)" -> "max_internal_decimal(my_decimal*)"
"check_result_and_overflow(uint,int,my_decimal*)" -> "my_decimal::sign(bool)"
"check_result(uint,int)" -> "decimal_operation_results(int)"
"decimal_operation_results(int)" -> "my_error(int,myf,...)"
"decimal_operation_results(int)" -> "push_warning_printf(THD*,Sql_condition::enum_warning_level,uint,const char*,...)"
"decimal_operation_results(int)" -> "_current_thd()"
"max_internal_decimal(my_decimal*)" -> "max_my_decimal(my_decimal*,int,int)"
"max_my_decimal(my_decimal*,int,int)" -> "max_decimal(int,int,decimal_t*)"
"internal_str2dec(const char*,decimal_t*,char**,my_bool)" -> "decimal_shift(decimal_t*,int)"
"internal_str2dec(const char*,decimal_t*,char**,my_bool)" -> "my_strtoll10(const char*,char**,int*)"
"internal_str2dec(const char*,decimal_t*,char**,my_bool)" -> "__builtin_expect(long int,long int)"
"decimal_shift(decimal_t*,int)" -> "do_mini_right_shift(decimal_t*,int,int,int)"
"decimal_shift(decimal_t*,int)" -> "decimal_round(const decimal_t*,decimal_t*,int,decimal_round_mode)"
"decimal_shift(decimal_t*,int)" -> "digits_bounds(decimal_t*,int*,int*)"
"decimal_shift(decimal_t*,int)" -> "do_mini_left_shift(decimal_t*,int,int,int)"
"decimal_round(const decimal_t*,decimal_t*,int,decimal_round_mode)" -> "__builtin_expect(long int,long int)"
"sp_instr_hpop::sp_instr_hpop(uint,sp_pcontext*)" -> "sp_instr::sp_instr(uint,sp_pcontext*)"
"Alter_drop::Alter_drop(Alter_drop::drop_type,const char*)" -> "Sql_alloc::Sql_alloc()"
"Item_func_left::Item_func_left(Item*,Item*)" -> "Item_str_func::Item_str_func(Item*,Item*)"
"Item_func_left::Item_func_left(Item*,Item*)" -> "String::String()"
"Item_func_database::Item_func_database()" -> "Item_func_sysconst::Item_func_sysconst()"
"sp_instr_hreturn::sp_instr_hreturn(uint,sp_pcontext*)" -> "sp_pcontext::current_var_count() const"
"sp_instr_hreturn::sp_instr_hreturn(uint,sp_pcontext*)" -> "sp_instr_jump::sp_instr_jump(uint,sp_pcontext*)"
"Sql_cmd_alter_table_repair_partition::Sql_cmd_alter_table_repair_partition()" -> "Sql_cmd_repair_table::Sql_cmd_repair_table()"
"Sql_cmd_repair_table::Sql_cmd_repair_table()" -> "Sql_cmd::Sql_cmd()"
"Item_sum_min::Item_sum_min(Item*)" -> "Item_sum_hybrid::Item_sum_hybrid(Item*,int)"
"Sql_cmd_alter_table::Sql_cmd_alter_table()" -> "Sql_cmd_common_alter_table::Sql_cmd_common_alter_table()"
"Item_time_typecast::Item_time_typecast(Item*)" -> "Item_time_func::Item_time_func(Item*)"
"multi_delete_set_locks_and_link_aux_tables(LEX*)" -> "MDL_request::set_type(enum_mdl_type)"
"multi_delete_set_locks_and_link_aux_tables(LEX*)" -> "multi_delete_table_match(LEX*,TABLE_LIST*,TABLE_LIST*)"
"multi_delete_table_match(LEX*,TABLE_LIST*,TABLE_LIST*)" -> "strcmp(const char*,const char*)"
"multi_delete_table_match(LEX*,TABLE_LIST*,TABLE_LIST*)" -> "my_error(int,myf,...)"
"Item_default_value::Item_default_value(Name_resolution_context*)" -> "Item_field::Item_field(Name_resolution_context*,const char*,const char*,const char*)"
"List<T>::push_back(T*) [with T = Alter_drop]" -> "base_list::push_back(void*)"
"Item_func_mul::Item_func_mul(Item*,Item*)" -> "Item_num_op::Item_num_op(Item*,Item*)"
"sp_instr_set_case_expr::sp_instr_set_case_expr(uint,LEX*,uint,Item*,LEX_STRING)" -> "LEX::get_sp_current_parsing_ctx()"
"sp_instr_set_case_expr::sp_instr_set_case_expr(uint,LEX*,uint,Item*,LEX_STRING)" -> "sp_lex_branch_instr::sp_lex_branch_instr(uint,sp_pcontext*,LEX*,Item*,LEX_STRING)"
"st_select_lex::convert_right_join()" -> "List<T>::push_front(T*) [with T = TABLE_LIST]"
"st_select_lex::convert_right_join()" -> "List<T>::pop() [with T = TABLE_LIST]"
"Item_func_char::Item_func_char(List<Item>&,const CHARSET_INFO*)" -> "Item_str_func::Item_str_func(List<Item>&)"
"Item_func_char::Item_func_char(List<Item>&,const CHARSET_INFO*)" -> "DTCollation::set(const CHARSET_INFO*)"
"Item_func_password::Item_func_password(Item*)" -> "Item_str_ascii_func::Item_str_ascii_func(Item*)"
"Item_date_add_interval::Item_date_add_interval(Item*,Item*,interval_type,bool)" -> "String::String()"
"Item_date_add_interval::Item_date_add_interval(Item*,Item*,interval_type,bool)" -> "Item_temporal_hybrid_func::Item_temporal_hybrid_func(Item*,Item*)"
"Condition_information_item::Condition_information_item(Condition_information_item::Name,Item*)" -> "Diagnostics_information_item::Diagnostics_information_item(Item*)"
"Diagnostics_information_item::Diagnostics_information_item(Item*)" -> "Sql_alloc::Sql_alloc()"
"Sql_cmd_handler_close::Sql_cmd_handler_close()" -> "Sql_cmd::Sql_cmd()"
"all_any_subquery_creator(Item*,chooser_compare_func_creator,bool,SELECT_LEX*)" -> "Item_in_subselect::Item_in_subselect(Item*,st_select_lex*)"
"all_any_subquery_creator(Item*,chooser_compare_func_creator,bool,SELECT_LEX*)" -> "Item_func_not_all::Item_func_not_all(Item*)"
"all_any_subquery_creator(Item*,chooser_compare_func_creator,bool,SELECT_LEX*)" -> "Item_func_nop_all::Item_func_nop_all(Item*)"
"all_any_subquery_creator(Item*,chooser_compare_func_creator,bool,SELECT_LEX*)" -> "Item_allany_subselect::Item_allany_subselect(Item*,chooser_compare_func_creator,st_select_lex*,bool)"
"all_any_subquery_creator(Item*,chooser_compare_func_creator,bool,SELECT_LEX*)" -> "Item_func_not::Item_func_not(Item*)"
"Item_func_not_all::Item_func_not_all(Item*)" -> "Item_func_not::Item_func_not(Item*)"
"Item_func_nop_all::Item_func_nop_all(Item*)" -> "Item_func_not_all::Item_func_not_all(Item*)"
"Item_allany_subselect::Item_allany_subselect(Item*,chooser_compare_func_creator,st_select_lex*,bool)" -> "select_exists_subselect::select_exists_subselect(Item_subselect*)"
"Item_allany_subselect::Item_allany_subselect(Item*,chooser_compare_func_creator,st_select_lex*,bool)" -> "Item_subselect::init(st_select_lex*,select_result_interceptor*)"
"Item_allany_subselect::Item_allany_subselect(Item*,chooser_compare_func_creator,st_select_lex*,bool)" -> "Item_in_subselect::Item_in_subselect()"
"Item_allany_subselect::Item_allany_subselect(Item*,chooser_compare_func_creator,st_select_lex*,bool)" -> "Item_in_subselect::test_limit(st_select_lex_unit*)"
"Item_allany_subselect::Item_allany_subselect(Item*,chooser_compare_func_creator,st_select_lex*,bool)" -> "Item_in_subselect::reset()"
"Item_in_subselect::Item_in_subselect()" -> "Item_exists_subselect::Item_exists_subselect()"
"Item_param::Item_param(uint)" -> "Item_string::Item_string(const char*,uint,const CHARSET_INFO*,Derivation,uint)"
"Item_param::Item_param(uint)" -> "my_decimal::my_decimal()"
"Item_param::Item_param(uint)" -> "String::String()"
"Item_param::Item_param(uint)" -> "Item::Item()"
"Item_param::Item_param(uint)" -> "Simple_cstring::set(const char*)"
"Item_param::Item_param(uint)" -> "Settable_routine_parameter::Settable_routine_parameter()"
"Item_param::Item_param(uint)" -> "String::set(char*,uint32,const CHARSET_INFO*)"
"Condition_information::Condition_information(Item*,List<Condition_information_item>*)" -> "Diagnostics_information::Diagnostics_information()"
"sp_condition_value::sp_condition_value(sp_condition_value::enum_type)" -> "Sql_alloc::Sql_alloc()"
"Item_func_minus::Item_func_minus(Item*,Item*)" -> "Item_func_additive_op::Item_func_additive_op(Item*,Item*)"
"Item_null::Item_null()" -> "Item_name_string::Item_name_string(Name_string)"
"Item_null::Item_null()" -> "Item_basic_constant::Item_basic_constant()"
"Item_null::Item_null()" -> "__builtin_memcpy(void*,const void*,long unsigned int)"
"Item_null::Item_null()" -> "Name_string::Name_string(const char*,size_t)"
"Item_null::Item_null()" -> "Item_null::init()"
"Item_null::init()" -> "DTCollation::set(const CHARSET_INFO*,Derivation)"
"Item_func_locate::Item_func_locate(Item*,Item*)" -> "Item_int_func::Item_int_func(Item*,Item*)"
"Item_func_locate::Item_func_locate(Item*,Item*)" -> "String::String()"
"Item_func_locate::Item_func_locate(Item*,Item*)" -> "DTCollation::DTCollation()"
"make_string(THD*,const char*,const char*)" -> "strmake(char*,const char*,size_t)"
"make_string(THD*,const char*,const char*)" -> "Query_arena::alloc(size_t)"
"List<T>::push_front(T*) [with T = st_lex_user]" -> "base_list::push_front(void*)"
"Item_sum_and::Item_sum_and(Item*)" -> "Item_sum_bit::Item_sum_bit(Item*,ulonglong)"
"Item_string::set_repertoire_from_value()" -> "String::charset() const"
"Item_string::set_repertoire_from_value()" -> "String::length() const"
"Item_string::set_repertoire_from_value()" -> "my_string_repertoire(const CHARSET_INFO*,const char*,ulong)"
"Item_string::set_repertoire_from_value()" -> "String::ptr() const"
"Item_func_substr::Item_func_substr(Item*,Item*)" -> "Item_str_func::Item_str_func(Item*,Item*)"
"Item_func_substr::Item_func_substr(Item*,Item*)" -> "String::String()"
"add_select_to_union_list(LEX*,bool,bool)" -> "_current_thd()"
"add_select_to_union_list(LEX*,bool,bool)" -> "mysql_init_select(LEX*)"
"add_select_to_union_list(LEX*,bool,bool)" -> "my_parse_error(const char*)"
"add_select_to_union_list(LEX*,bool,bool)" -> "mysql_new_select(LEX*,bool)"
"add_select_to_union_list(LEX*,bool,bool)" -> "my_error(int,myf,...)"
"Item_func_get_system_var::is_written_to_binlog()" -> "sys_var::is_written_to_binlog(enum_var_type)"
"Item::check_well_formed_result(String*,bool)" -> "String::charset() const"
"Item::check_well_formed_result(String*,bool)" -> "String::length(uint32)"
"Item::check_well_formed_result(String*,bool)" -> "THD::is_strict_mode() const"
"Item::check_well_formed_result(String*,bool)" -> "String::length() const"
"Item::check_well_formed_result(String*,bool)" -> "push_warning_printf(THD*,Sql_condition::enum_warning_level,uint,const char*,...)"
"Item::check_well_formed_result(String*,bool)" -> "octet2hex(char*,const char*,unsigned int)"
"Item::check_well_formed_result(String*,bool)" -> "my_error(int,myf,...)"
"Item::check_well_formed_result(String*,bool)" -> "_current_thd()"
"Item::check_well_formed_result(String*,bool)" -> "String::ptr() const"
"Item_func_bit_or::Item_func_bit_or(Item*,Item*)" -> "Item_func_bit::Item_func_bit(Item*,Item*)"
"Item_uint::Item_uint(const char*,uint)" -> "Item_int::Item_int(const char*,uint)"
"Item_int::Item_int(const char*,uint)" -> "Name_string::copy(const char*,size_t)"
"Item_int::Item_int(const char*,uint)" -> "Item_num::Item_num()"
"Item_int::Item_int(const char*,uint)" -> "my_strtoll10(const char*,char**,int*)"
"sp_instr_cpush::sp_instr_cpush(uint,sp_pcontext*,LEX*,LEX_STRING,int)" -> "sp_lex_instr::sp_lex_instr(uint,sp_pcontext*,LEX*,bool)"
"set_var_user::set_var_user(Item_func_set_user_var*)" -> "set_var_base::set_var_base()"
"Item_func_isnotfalse::Item_func_isnotfalse(Item*)" -> "Item_func_truth::Item_func_truth(Item*,bool,bool)"
"sp_head::is_not_allowed_in_function(const char*)" -> "my_error(int,myf,...)"
"Item_insert_value::Item_insert_value(Name_resolution_context*,Item*)" -> "Item_field::Item_field(Name_resolution_context*,const char*,const char*,const char*)"
"sp_instr_jump_case_when::sp_instr_jump_case_when(uint,LEX*,int,Item*,LEX_STRING)" -> "LEX::get_sp_current_parsing_ctx()"
"sp_instr_jump_case_when::sp_instr_jump_case_when(uint,LEX*,int,Item*,LEX_STRING)" -> "sp_lex_branch_instr::sp_lex_branch_instr(uint,sp_pcontext*,LEX*,Item*,LEX_STRING)"
"Item_sum_count::Item_sum_count(List<Item>&)" -> "Item_sum_int::Item_sum_int(List<Item>&)"
"Item_sum_count::Item_sum_count(List<Item>&)" -> "Item_sum::set_distinct(bool)"
"Item_sum_int::Item_sum_int(List<Item>&)" -> "Item_sum_num::Item_sum_num(List<Item>&)"
"Item_sum_num::Item_sum_num(List<Item>&)" -> "Item_sum::Item_sum(List<Item>&)"
"Item_float::Item_float(const char*,uint)" -> "my_snprintf(char*,size_t,const char*,...)"
"Item_float::Item_float(const char*,uint)" -> "my_error(int,myf,...)"
"Item_float::Item_float(const char*,uint)" -> "nr_of_decimals(const char*,const char*)"
"Item_float::Item_float(const char*,uint)" -> "Name_string::Name_string()"
"Item_float::Item_float(const char*,uint)" -> "Item_num::Item_num()"
"Item_float::Item_float(const char*,uint)" -> "Name_string::copy(const char*,size_t)"
"store_position_for_column(const char*)" -> "_current_thd()"
"sp_instr_cpop::sp_instr_cpop(uint,sp_pcontext*,uint)" -> "sp_instr::sp_instr(uint,sp_pcontext*)"
"sp_pcontext::pop_context()" -> "sp_pcontext::max_cursor_index() const"
"sp_pcontext::max_cursor_index() const" -> "Dynamic_array<Elem>::elements() const [with Elem = st_mysql_lex_string]"
"sp_instr_copen::sp_instr_copen(uint,sp_pcontext*,int)" -> "sp_instr::sp_instr(uint,sp_pcontext*)"
"Item_func_regex::Item_func_regex(Item*,Item*)" -> "DTCollation::DTCollation()"
"Item_func_regex::Item_func_regex(Item*,Item*)" -> "String::String()"
"Item_func_regex::Item_func_regex(Item*,Item*)" -> "Item_bool_func::Item_bool_func(Item*,Item*)"
"List<T>::push_back(T*) [with T = List<Item>]" -> "base_list::push_back(void*)"
"sp_head::set_body_start(THD*,const char*)" -> "Lex_input_stream::body_utf8_start(THD*,const char*)"
"sp_head::set_body_start(THD*,const char*)" -> "sp_parser_data::set_body_start_ptr(const char*)"
"Lex_input_stream::body_utf8_start(THD*,const char*)" -> "Query_arena::alloc(size_t)"
"Item_func_substr::Item_func_substr(Item*,Item*,Item*)" -> "Item_str_func::Item_str_func(Item*,Item*,Item*)"
"Item_func_substr::Item_func_substr(Item*,Item*,Item*)" -> "String::String()"
"Sql_cmd_handler_read::Sql_cmd_handler_read(enum_ha_read_modes,const char*,List<Item>*,ha_rkey_function)" -> "Sql_cmd::Sql_cmd()"
"Item_func_right::Item_func_right(Item*,Item*)" -> "String::String()"
"Item_func_right::Item_func_right(Item*,Item*)" -> "Item_str_func::Item_str_func(Item*,Item*)"
"Statement_information_item::Statement_information_item(Statement_information_item::Name,Item*)" -> "Diagnostics_information_item::Diagnostics_information_item(Item*)"
"sp_instr_cfetch::sp_instr_cfetch(uint,sp_pcontext*,int)" -> "List<T>::List() [with T = sp_variable]"
"sp_instr_cfetch::sp_instr_cfetch(uint,sp_pcontext*,int)" -> "sp_instr::sp_instr(uint,sp_pcontext*)"
"List<T>::List() [with T = sp_variable]" -> "base_list::base_list()"
"Item_exists_subselect::Item_exists_subselect(st_select_lex*)" -> "select_exists_subselect::select_exists_subselect(Item_subselect*)"
"Item_exists_subselect::Item_exists_subselect(st_select_lex*)" -> "Item_subselect::Item_subselect()"
"Item_exists_subselect::Item_exists_subselect(st_select_lex*)" -> "Item_subselect::init(st_select_lex*,select_result_interceptor*)"
"Item_name_string::copy(const char*,size_t,const CHARSET_INFO*,bool)" -> "push_warning_printf(THD*,Sql_condition::enum_warning_level,uint,const char*,...)"
"Item_name_string::copy(const char*,size_t,const CHARSET_INFO*,bool)" -> "Name_string::copy(const char*,size_t,const CHARSET_INFO*)"
"Item_name_string::copy(const char*,size_t,const CHARSET_INFO*,bool)" -> "_current_thd()"
"Item_name_string::copy(const char*,size_t,const CHARSET_INFO*,bool)" -> "ErrConvString::ErrConvString(const char*,uint,const CHARSET_INFO*)"
"Item_name_string::copy(const char*,size_t,const CHARSET_INFO*,bool)" -> "Simple_cstring::length() const"
"Item_name_string::copy(const char*,size_t,const CHARSET_INFO*,bool)" -> "Item_name_string::is_autogenerated() const"
"Item_name_string::copy(const char*,size_t,const CHARSET_INFO*,bool)" -> "ErrConvString::ptr()"
"Item_func_curtime_utc::Item_func_curtime_utc(uint8)" -> "Item_func_curtime::Item_func_curtime(uint8)"
"add_join_on(TABLE_LIST*,Item*)" -> "TABLE_LIST::set_join_cond(Item*)"
"add_join_on(TABLE_LIST*,Item*)" -> "Item_cond_and::Item_cond_and(Item*,Item*)"
"add_join_on(TABLE_LIST*,Item*)" -> "TABLE_LIST::join_cond() const"
"Item_cond_and::Item_cond_and(Item*,Item*)" -> "COND_EQUAL::COND_EQUAL()"
"Item_cond_and::Item_cond_and(Item*,Item*)" -> "Item_cond::Item_cond(Item*,Item*)"
"COND_EQUAL::COND_EQUAL()" -> "List<T>::List() [with T = Item_equal]"
"COND_EQUAL::COND_EQUAL()" -> "Sql_alloc::Sql_alloc()"
"List<T>::List() [with T = Item_equal]" -> "base_list::base_list()"
"Event_parse_data::new_instance(THD*)" -> "Event_parse_data::Event_parse_data()"
"Event_parse_data::Event_parse_data()" -> "Sql_alloc::Sql_alloc()"
"sp_condition_value::sp_condition_value(uint)" -> "Sql_alloc::Sql_alloc()"
"Item_func_set_collation::Item_func_set_collation(Item*,Item*)" -> "Item_str_func::Item_str_func(Item*,Item*)"
"Item_func_xor::Item_func_xor(Item*,Item*)" -> "Item_bool_func2::Item_bool_func2(Item*,Item*)"
"merge_charset_and_collation(const CHARSET_INFO*,const CHARSET_INFO*)" -> "my_error(int,myf,...)"
"merge_charset_and_collation(const CHARSET_INFO*,const CHARSET_INFO*)" -> "my_charset_same(const CHARSET_INFO*,const CHARSET_INFO*)"
"sp_start_parsing(THD*,enum_sp_type,sp_name*)" -> "sp_head::sp_head(enum_sp_type)"
"sp_start_parsing(THD*,enum_sp_type,sp_name*)" -> "LEX::set_sp_current_parsing_ctx(sp_pcontext*)"
"sp_start_parsing(THD*,enum_sp_type,sp_name*)" -> "sp_parser_data::start_parsing_sp_body(THD*,sp_head*)"
"sp_start_parsing(THD*,enum_sp_type,sp_name*)" -> "sp_head::init_sp_name(THD*,sp_name*)"
"sp_start_parsing(THD*,enum_sp_type,sp_name*)" -> "sp_pcontext::sp_pcontext()"
"sp_head::sp_head(enum_sp_type)" -> "Dynamic_array<Elem>::Dynamic_array(uint,uint) [with Elem = sp_instr*,uint = unsigned int]"
"sp_head::sp_head(enum_sp_type)" -> "_my_hash_init(HASH*,uint,CHARSET_INFO*,my_hash_function,ulong,size_t,size_t,my_hash_get_key,void (*)(void*),uint)"
"sp_head::sp_head(enum_sp_type)" -> "Create_field::Create_field()"
"sp_head::sp_head(enum_sp_type)" -> "Security_context::Security_context()"
"sp_head::sp_head(enum_sp_type)" -> "SQL_I_List<T>::SQL_I_List() [with T = Item_trigger_field]"
"sp_head::sp_head(enum_sp_type)" -> "SQL_I_List<T>::SQL_I_List() [with T = SQL_I_List<Item_trigger_field>]"
"sp_head::sp_head(enum_sp_type)" -> "sp_parser_data::sp_parser_data()"
"sp_head::sp_head(enum_sp_type)" -> "Query_arena::Query_arena(MEM_ROOT*,Query_arena::enum_state)"
"Dynamic_array<Elem>::Dynamic_array(uint,uint) [with Elem = sp_instr*,uint = unsigned int]" -> "Dynamic_array<Elem>::init(uint,uint) [with Elem = sp_instr*,uint = unsigned int]"
"Dynamic_array<Elem>::init(uint,uint) [with Elem = sp_instr*,uint = unsigned int]" -> "init_dynamic_array2(DYNAMIC_ARRAY*,uint,void*,uint,uint)"
"SQL_I_List<T>::SQL_I_List() [with T = SQL_I_List<Item_trigger_field>]" -> "Sql_alloc::Sql_alloc()"
"SQL_I_List<T>::SQL_I_List() [with T = SQL_I_List<Item_trigger_field>]" -> "SQL_I_List<T>::empty() [with T = SQL_I_List<Item_trigger_field>]"
"sp_parser_data::sp_parser_data()" -> "List<T>::List() [with T = LEX]"
"sp_parser_data::sp_parser_data()" -> "List<T>::List() [with T = sp_parser_data::Backpatch_info]"
"sp_parser_data::sp_parser_data()" -> "List<T>::List() [with T = sp_lex_branch_instr]"
"List<T>::List() [with T = LEX]" -> "base_list::base_list()"
"List<T>::List() [with T = sp_parser_data::Backpatch_info]" -> "base_list::base_list()"
"List<T>::List() [with T = sp_lex_branch_instr]" -> "base_list::base_list()"
"sp_parser_data::start_parsing_sp_body(THD*,sp_head*)" -> "sp_head::get_persistent_mem_root() const"
"sp_head::init_sp_name(THD*,sp_name*)" -> "memdup_root(MEM_ROOT*,const void*,size_t)"
"sp_head::init_sp_name(THD*,sp_name*)" -> "strmake_root(MEM_ROOT*,const char*,size_t)"
"sp_head::init_sp_name(THD*,sp_name*)" -> "sp_name::init_qname(THD*)"
"sp_pcontext::sp_pcontext()" -> "List<T>::List() [with T = sp_label]"
"sp_pcontext::sp_pcontext()" -> "Dynamic_array<Elem>::Dynamic_array(uint,uint) [with Elem = sp_pcontext*,uint = unsigned int]"
"sp_pcontext::sp_pcontext()" -> "Dynamic_array<Elem>::Dynamic_array(uint,uint) [with Elem = int,uint = unsigned int]"
"sp_pcontext::sp_pcontext()" -> "Dynamic_array<Elem>::Dynamic_array(uint,uint) [with Elem = sp_handler*,uint = unsigned int]"
"sp_pcontext::sp_pcontext()" -> "Dynamic_array<Elem>::Dynamic_array(uint,uint) [with Elem = st_mysql_lex_string,uint = unsigned int]"
"sp_pcontext::sp_pcontext()" -> "Dynamic_array<Elem>::Dynamic_array(uint,uint) [with Elem = sp_condition*,uint = unsigned int]"
"sp_pcontext::sp_pcontext()" -> "Dynamic_array<Elem>::Dynamic_array(uint,uint) [with Elem = sp_variable*,uint = unsigned int]"
"sp_pcontext::sp_pcontext()" -> "sp_pcontext::init(uint,uint,int)"
"sp_pcontext::sp_pcontext()" -> "Sql_alloc::Sql_alloc()"
"Explain_format_traditional::Explain_format_traditional()" -> "qep_row::qep_row()"
"Explain_format_traditional::Explain_format_traditional()" -> "Explain_format::Explain_format()"
"qep_row::qep_row()" -> "qep_row::mem_root_str::mem_root_str()"
"qep_row::qep_row()" -> "Sql_alloc::Sql_alloc()"
"qep_row::qep_row()" -> "List<T>::List() [with T = opt_explain_json_namespace::context]"
"qep_row::qep_row()" -> "qep_row::column<T>::column() [with T = unsigned int]"
"qep_row::qep_row()" -> "List<T>::List() [with T = qep_row::extra]"
"qep_row::qep_row()" -> "qep_row::column<T>::column() [with T = long long int]"
"qep_row::qep_row()" -> "qep_row::column<T>::column() [with T = st_select_lex::type_enum]"
"qep_row::qep_row()" -> "List<T>::List() [with T = const char]"
"qep_row::qep_row()" -> "qep_row::column<T>::column() [with T = float]"
"qep_row::mem_root_str::mem_root_str()" -> "qep_row::mem_root_str::cleanup()"
"List<T>::List() [with T = opt_explain_json_namespace::context]" -> "base_list::base_list()"
"qep_row::column<T>::column() [with T = unsigned int]" -> "qep_row::column<T>::cleanup() [with T = unsigned int]"
"List<T>::List() [with T = qep_row::extra]" -> "base_list::base_list()"
"qep_row::column<T>::column() [with T = long long int]" -> "qep_row::column<T>::cleanup() [with T = long long int]"
"qep_row::column<T>::column() [with T = st_select_lex::type_enum]" -> "qep_row::column<T>::cleanup() [with T = st_select_lex::type_enum]"
"List<T>::List() [with T = const char]" -> "base_list::base_list()"
"qep_row::column<T>::column() [with T = float]" -> "qep_row::column<T>::cleanup() [with T = float]"
"Explain_format::Explain_format()" -> "Sql_alloc::Sql_alloc()"
"Explain_format_JSON::Explain_format_JSON()" -> "Explain_format::Explain_format()"
"partition_info::add_column_list_value(THD*,Item*)" -> "partition_info::init_column_part()"
"partition_info::add_column_list_value(THD*,Item*)" -> "my_error(int,myf,...)"
"partition_info::add_column_list_value(THD*,Item*)" -> "partition_info::add_column_value()"
"partition_info::add_column_list_value(THD*,Item*)" -> "partition_info::init_col_val(part_column_list_val*,Item*)"
"Item_singlerow_subselect::Item_singlerow_subselect(st_select_lex*)" -> "select_singlerow_subselect::select_singlerow_subselect(Item_subselect*)"
"Item_singlerow_subselect::Item_singlerow_subselect(st_select_lex*)" -> "Item_subselect::Item_subselect()"
"Item_singlerow_subselect::Item_singlerow_subselect(st_select_lex*)" -> "Item_subselect::init(st_select_lex*,select_result_interceptor*)"
"select_singlerow_subselect::select_singlerow_subselect(Item_subselect*)" -> "select_subselect::select_subselect(Item_subselect*)"
"Item_func_neg::Item_func_neg(Item*)" -> "Item_func_num1::Item_func_num1(Item*)"
"Item_func_num1::Item_func_num1(Item*)" -> "Item_func_numhybrid::Item_func_numhybrid(Item*)"
"Item_func_numhybrid::Item_func_numhybrid(Item*)" -> "Item_func::Item_func(Item*)"
"Item_func_numhybrid::Item_func_numhybrid(Item*)" -> "DTCollation::set_numeric()"
"sp_pcontext::check_duplicate_handler(const sp_condition_value*) const" -> "List_iterator_fast<T>::List_iterator_fast(List<T>&) [with T = sp_condition_value]"
"sp_pcontext::check_duplicate_handler(const sp_condition_value*) const" -> "sp_condition_value::equals(const sp_condition_value*) const"
"sp_pcontext::check_duplicate_handler(const sp_condition_value*) const" -> "Dynamic_array<Elem>::elements() const [with Elem = sp_handler*]"
"sp_pcontext::check_duplicate_handler(const sp_condition_value*) const" -> "Dynamic_array<Elem>::at(int) const [with Elem = sp_handler*]"
"sp_pcontext::check_duplicate_handler(const sp_condition_value*) const" -> "List_iterator_fast<T>::operator++(int) [with T = sp_condition_value]"
"List_iterator_fast<T>::List_iterator_fast(List<T>&) [with T = sp_condition_value]" -> "base_list_iterator::base_list_iterator(base_list&)"
"sp_condition_value::equals(const sp_condition_value*) const" -> "strcmp(const char*,const char*)"
"List_iterator_fast<T>::operator++(int) [with T = sp_condition_value]" -> "base_list_iterator::next_fast()"
"partition_element::partition_element(partition_element*)" -> "Sql_alloc::Sql_alloc()"
"partition_element::partition_element(partition_element*)" -> "List<T>::List() [with T = p_elem_val]"
"partition_element::partition_element(partition_element*)" -> "List<T>::List() [with T = partition_element]"
"sp_instr_freturn::sp_instr_freturn(uint,LEX*,Item*,LEX_STRING,enum_field_types)" -> "LEX::get_sp_current_parsing_ctx()"
"sp_instr_freturn::sp_instr_freturn(uint,LEX*,Item*,LEX_STRING,enum_field_types)" -> "sp_lex_instr::sp_lex_instr(uint,sp_pcontext*,LEX*,bool)"
"Item_func_bit_xor::Item_func_bit_xor(Item*,Item*)" -> "Item_func_bit::Item_func_bit(Item*,Item*)"
"Item_func_replace::Item_func_replace(Item*,Item*,Item*)" -> "Item_str_func::Item_str_func(Item*,Item*,Item*)"
"Item_func_replace::Item_func_replace(Item*,Item*,Item*)" -> "String::String()"
"Item_func_format::Item_func_format(Item*,Item*)" -> "Item_str_ascii_func::Item_str_ascii_func(Item*,Item*)"
"Item_func_format::Item_func_format(Item*,Item*)" -> "String::String()"
"Item_str_ascii_func::Item_str_ascii_func(Item*,Item*)" -> "Item_str_func::Item_str_func(Item*,Item*)"
"Item_str_ascii_func::Item_str_ascii_func(Item*,Item*)" -> "String::String()"
"Item_str_ascii_func::Item_str_ascii_func(Item*,Item*)" -> "DTCollation::set_repertoire(uint)"
"Sql_cmd_alter_table_exchange_partition::Sql_cmd_alter_table_exchange_partition()" -> "Sql_cmd_common_alter_table::Sql_cmd_common_alter_table()"
"Item_hex_string::Item_hex_string(const char*,uint)" -> "Item_hex_string::hex_string_init(const char*,uint)"
"Item_hex_string::Item_hex_string(const char*,uint)" -> "Item_basic_constant::Item_basic_constant()"
"Item_func_week::Item_func_week(Item*,Item*)" -> "Item_int_func::Item_int_func(Item*,Item*)"
"Item_func_ltrim::Item_func_ltrim(Item*,Item*)" -> "Item_func_trim::Item_func_trim(Item*,Item*)"
"Item_func_row_count::Item_func_row_count()" -> "Item_int_func::Item_int_func()"
"set_trigger_new_row(THD*,LEX_STRING,Item*,LEX_STRING)" -> "SQL_I_List<T>::link_in_list(T*,T**) [with T = Item_trigger_field]"
"set_trigger_new_row(THD*,LEX_STRING,Item*,LEX_STRING)" -> "Item_trigger_field::Item_trigger_field(Name_resolution_context*,Item_trigger_field::row_version_type,const char*,ulong,bool)"
"set_trigger_new_row(THD*,LEX_STRING,Item*,LEX_STRING)" -> "LEX::current_context()"
"set_trigger_new_row(THD*,LEX_STRING,Item*,LEX_STRING)" -> "sp_head::add_instr(THD*,sp_instr*)"
"set_trigger_new_row(THD*,LEX_STRING,Item*,LEX_STRING)" -> "sp_head::instructions()"
"set_trigger_new_row(THD*,LEX_STRING,Item*,LEX_STRING)" -> "sp_instr_set_trigger_field::sp_instr_set_trigger_field(uint,LEX*,LEX_STRING,Item_trigger_field*,Item*,LEX_STRING)"
"sp_instr_set_trigger_field::sp_instr_set_trigger_field(uint,LEX*,LEX_STRING,Item_trigger_field*,Item*,LEX_STRING)" -> "sp_lex_instr::sp_lex_instr(uint,sp_pcontext*,LEX*,bool)"
"sp_instr_set_trigger_field::sp_instr_set_trigger_field(uint,LEX*,LEX_STRING,Item_trigger_field*,Item*,LEX_STRING)" -> "LEX::get_sp_current_parsing_ctx()"
"List<T>::List() [with T = Statement_information_item]" -> "base_list::base_list()"
"Item_func_month::Item_func_month(Item*)" -> "Item_func::Item_func(Item*)"
"Item_func_month::Item_func_month(Item*)" -> "DTCollation::set_numeric()"
"Item_func_isnotnull::Item_func_isnotnull(Item*)" -> "Item_bool_func::Item_bool_func(Item*)"
"Sql_cmd_signal::Sql_cmd_signal(const sp_condition_value*,const Set_signal_information&)" -> "Sql_cmd_common_signal::Sql_cmd_common_signal(const sp_condition_value*,const Set_signal_information&)"
"Foreign_key::Foreign_key(const LEX_STRING&,List<Key_part_spec>&,const LEX_STRING&,const LEX_STRING&,List<Key_part_spec>&,uint,uint,uint)" -> "List<T>::List(const List<T>&) [with T = Key_part_spec]"
"Foreign_key::Foreign_key(const LEX_STRING&,List<Key_part_spec>&,const LEX_STRING&,const LEX_STRING&,List<Key_part_spec>&,uint,uint,uint)" -> "Key::Key(Key::Keytype,const LEX_STRING&,KEY_CREATE_INFO*,bool,List<Key_part_spec>&)"
"Item_func_isnottrue::Item_func_isnottrue(Item*)" -> "Item_func_truth::Item_func_truth(Item*,bool,bool)"
"st_select_lex::add_joined_table(TABLE_LIST*)" -> "List<T>::push_front(T*) [with T = TABLE_LIST]"
"Sql_cmd_alter_table_optimize_partition::Sql_cmd_alter_table_optimize_partition()" -> "Sql_cmd_optimize_table::Sql_cmd_optimize_table()"
"Item_func_now_local::Item_func_now_local(uint8)" -> "Item_func_now::Item_func_now(uint8)"
"Item_func_if::Item_func_if(Item*,Item*,Item*)" -> "Item_func::Item_func(Item*,Item*,Item*)"
"mysqld_collation_get_by_name(const char*,CHARSET_INFO*)" -> "ErrConvString::ErrConvString(const char*,const CHARSET_INFO*)"
"mysqld_collation_get_by_name(const char*,CHARSET_INFO*)" -> "push_warning_printf(THD*,Sql_condition::enum_warning_level,uint,const char*,...)"
"mysqld_collation_get_by_name(const char*,CHARSET_INFO*)" -> "my_error(int,myf,...)"
"mysqld_collation_get_by_name(const char*,CHARSET_INFO*)" -> "my_collation_get_by_name(MY_CHARSET_LOADER*,const char*,myf)"
"mysqld_collation_get_by_name(const char*,CHARSET_INFO*)" -> "my_charset_loader_init_mysys(MY_CHARSET_LOADER*)"
"mysqld_collation_get_by_name(const char*,CHARSET_INFO*)" -> "_current_thd()"
"mysqld_collation_get_by_name(const char*,CHARSET_INFO*)" -> "ErrConvString::ptr()"
"st_select_lex::init_nested_join(THD*)" -> "TABLE_LIST::new_nested_join(MEM_ROOT*,const char*,TABLE_LIST*,List<TABLE_LIST>*,st_select_lex*)"
"st_select_lex::init_nested_join(THD*)" -> "List<T>::push_front(T*) [with T = TABLE_LIST]"
"add_create_index(LEX*,Key::Keytype,const LEX_STRING&,KEY_CREATE_INFO*,bool)" -> "Key::Key(Key::Keytype,const LEX_STRING&,KEY_CREATE_INFO*,bool,List<Key_part_spec>&)"
"add_create_index(LEX*,Key::Keytype,const LEX_STRING&,KEY_CREATE_INFO*,bool)" -> "List<T>::push_back(T*) [with T = Key]"
"add_create_index(LEX*,Key::Keytype,const LEX_STRING&,KEY_CREATE_INFO*,bool)" -> "base_list::empty()"
"setup_select_in_parentheses(LEX*)" -> "_current_thd()"
"setup_select_in_parentheses(LEX*)" -> "my_parse_error(const char*)"
"setup_select_in_parentheses(LEX*)" -> "st_select_lex_unit::first_select()"
"setup_select_in_parentheses(LEX*)" -> "my_error(int,myf,...)"
"View_creation_ctx::create(THD*,TABLE_LIST*)" -> "_current_thd()"
"View_creation_ctx::create(THD*,TABLE_LIST*)" -> "resolve_collation(const char*,const CHARSET_INFO*,const CHARSET_INFO**)"
"View_creation_ctx::create(THD*,TABLE_LIST*)" -> "sql_print_warning(const char*,...)"
"View_creation_ctx::create(THD*,TABLE_LIST*)" -> "resolve_charset(const char*,const CHARSET_INFO*,const CHARSET_INFO**)"
"View_creation_ctx::create(THD*,TABLE_LIST*)" -> "View_creation_ctx::View_creation_ctx(THD*)"
"View_creation_ctx::create(THD*,TABLE_LIST*)" -> "push_warning_printf(THD*,Sql_condition::enum_warning_level,uint,const char*,...)"
"View_creation_ctx::View_creation_ctx(THD*)" -> "Sql_alloc::Sql_alloc()"
"View_creation_ctx::View_creation_ctx(THD*)" -> "Default_object_creation_ctx::Default_object_creation_ctx(THD*)"
"Default_object_creation_ctx::Default_object_creation_ctx(THD*)" -> "Object_creation_ctx::Object_creation_ctx()"
"TABLE_LIST::top_table()" -> "TABLE_LIST::top_table() const"
"List_iterator_fast<T>::rewind() [with T = TABLE_LIST]" -> "base_list_iterator::rewind()"
"repoint_contexts_of_join_nests(List<TABLE_LIST>,SELECT_LEX*,SELECT_LEX*)" -> "repoint_contexts_of_join_nests(List<TABLE_LIST>,SELECT_LEX*,SELECT_LEX*)"
"repoint_contexts_of_join_nests(List<TABLE_LIST>,SELECT_LEX*,SELECT_LEX*)" -> "List_iterator_fast<T>::List_iterator_fast(List<T>&) [with T = TABLE_LIST]"
"repoint_contexts_of_join_nests(List<TABLE_LIST>,SELECT_LEX*,SELECT_LEX*)" -> "List_iterator_fast<T>::operator++(int) [with T = TABLE_LIST]"
"repoint_contexts_of_join_nests(List<TABLE_LIST>,SELECT_LEX*,SELECT_LEX*)" -> "List<T>::List(const List<T>&) [with T = TABLE_LIST]"
"List<T>::List(const List<T>&) [with T = TABLE_LIST]" -> "base_list::base_list(const base_list&)"
"File_parser::parse(uchar*,MEM_ROOT*,File_option*,uint,Unknown_key_hook*) const" -> "strchr(const char*,int)"
"File_parser::parse(uchar*,MEM_ROOT*,File_option*,uint,Unknown_key_hook*) const" -> "parse_quoted_escaped_string(const char*,const char*,MEM_ROOT*,LEX_STRING*)"
"File_parser::parse(uchar*,MEM_ROOT*,File_option*,uint,Unknown_key_hook*) const" -> "parse_escaped_string(const char*,const char*,MEM_ROOT*,LEX_STRING*)"
"File_parser::parse(uchar*,MEM_ROOT*,File_option*,uint,Unknown_key_hook*) const" -> "memcpy(void*,const void*,size_t)"
"File_parser::parse(uchar*,MEM_ROOT*,File_option*,uint,Unknown_key_hook*) const" -> "my_error(int,myf,...)"
"File_parser::parse(uchar*,MEM_ROOT*,File_option*,uint,Unknown_key_hook*) const" -> "parse_string(const char*,const char*,MEM_ROOT*,LEX_STRING*)"
"File_parser::parse(uchar*,MEM_ROOT*,File_option*,uint,Unknown_key_hook*) const" -> "List<T>::push_back(T*,MEM_ROOT*) [with T = st_mysql_lex_string,MEM_ROOT = st_mem_root]"
"File_parser::parse(uchar*,MEM_ROOT*,File_option*,uint,Unknown_key_hook*) const" -> "get_file_options_ulllist(const char*&,const char*,const char*,uchar*,File_option*,MEM_ROOT*)"
"File_parser::parse(uchar*,MEM_ROOT*,File_option*,uint,Unknown_key_hook*) const" -> "base_list::empty()"
"File_parser::parse(uchar*,MEM_ROOT*,File_option*,uint,Unknown_key_hook*) const" -> "my_strtoll10(const char*,char**,int*)"
"File_parser::parse(uchar*,MEM_ROOT*,File_option*,uint,Unknown_key_hook*) const" -> "memcmp(const void*,const void*,size_t)"
"File_parser::parse(uchar*,MEM_ROOT*,File_option*,uint,Unknown_key_hook*) const" -> "alloc_root(MEM_ROOT*,size_t)"
"strchr(const char*,int)" -> "__builtin_strchr(const char*,int)"
"parse_quoted_escaped_string(const char*,const char*,MEM_ROOT*,LEX_STRING*)" -> "alloc_root(MEM_ROOT*,size_t)"
"parse_quoted_escaped_string(const char*,const char*,MEM_ROOT*,LEX_STRING*)" -> "read_escaped_string(const char*,const char*,LEX_STRING*)"
"parse_escaped_string(const char*,const char*,MEM_ROOT*,LEX_STRING*)" -> "read_escaped_string(const char*,const char*,LEX_STRING*)"
"parse_escaped_string(const char*,const char*,MEM_ROOT*,LEX_STRING*)" -> "strchr(const char*,int)"
"parse_escaped_string(const char*,const char*,MEM_ROOT*,LEX_STRING*)" -> "alloc_root(MEM_ROOT*,size_t)"
"parse_string(const char*,const char*,MEM_ROOT*,LEX_STRING*)" -> "strchr(const char*,int)"
"parse_string(const char*,const char*,MEM_ROOT*,LEX_STRING*)" -> "strmake_root(MEM_ROOT*,const char*,size_t)"
"List<T>::push_back(T*,MEM_ROOT*) [with T = st_mysql_lex_string,MEM_ROOT = st_mem_root]" -> "base_list::push_back(void*,MEM_ROOT*)"
"base_list::push_back(void*,MEM_ROOT*)" -> "list_node::list_node(void*,list_node*)"
"get_file_options_ulllist(const char*&,const char*,const char*,uchar*,File_option*,MEM_ROOT*)" -> "base_list::empty()"
"get_file_options_ulllist(const char*&,const char*,const char*,uchar*,File_option*,MEM_ROOT*)" -> "List<T>::push_back(T*,MEM_ROOT*) [with T = long long unsigned int,MEM_ROOT = st_mem_root]"
"get_file_options_ulllist(const char*&,const char*,const char*,uchar*,File_option*,MEM_ROOT*)" -> "alloc_root(MEM_ROOT*,size_t)"
"get_file_options_ulllist(const char*&,const char*,const char*,uchar*,File_option*,MEM_ROOT*)" -> "my_error(int,myf,...)"
"get_file_options_ulllist(const char*&,const char*,const char*,uchar*,File_option*,MEM_ROOT*)" -> "my_strtoll10(const char*,char**,int*)"
"List<T>::push_back(T*,MEM_ROOT*) [with T = long long unsigned int,MEM_ROOT = st_mem_root]" -> "base_list::push_back(void*,MEM_ROOT*)"
"Parser_state::init(THD*,char*,unsigned int)" -> "Lex_input_stream::init(THD*,char*,unsigned int)"
"Lex_input_stream::init(THD*,char*,unsigned int)" -> "Lex_input_stream::reset(char*,unsigned int)"
"Lex_input_stream::init(THD*,char*,unsigned int)" -> "Query_arena::alloc(size_t)"
"Opt_trace_struct::add_utf8(const char*,const char*,size_t)" -> "Opt_trace_struct::do_add(const char*,const char*,size_t,bool)"
"Opt_trace_struct::add_utf8(const char*,const char*,size_t)" -> "__builtin_expect(long int,long int)"
"Opt_trace_struct::add(const char*,uint)" -> "Opt_trace_struct::do_add(const char*,ulonglong)"
"Opt_trace_struct::add(const char*,uint)" -> "__builtin_expect(long int,long int)"
"Opt_trace_struct::do_add(const char*,ulonglong)" -> "strlen(const char*)"
"Opt_trace_struct::do_add(const char*,ulonglong)" -> "Opt_trace_stmt::add(const char*,const char*,size_t,bool,bool)"
"Opt_trace_struct::do_add(const char*,ulonglong)" -> "ullstr(longlong,char*)"
"THD::set_n_backup_active_arena(Query_arena*,Query_arena*)" -> "Query_arena::set_query_arena(Query_arena*)"
"Opt_trace_object::Opt_trace_object(Opt_trace_context*,Opt_trace_context::feature_value)" -> "Opt_trace_struct::Opt_trace_struct(Opt_trace_context*,bool,const char*,Opt_trace_context::feature_value)"
"partition_info::set_partition_bitmaps(TABLE_LIST*)" -> "bitmap_copy(MY_BITMAP*,const MY_BITMAP*)"
"partition_info::set_partition_bitmaps(TABLE_LIST*)" -> "partition_info::prune_partition_bitmaps(TABLE_LIST*)"
"partition_info::set_partition_bitmaps(TABLE_LIST*)" -> "memset(void*,int,size_t)"
"partition_info::set_partition_bitmaps(TABLE_LIST*)" -> "TABLE_SHARE::db_type() const"
"partition_info::set_partition_bitmaps(TABLE_LIST*)" -> "my_error(int,myf,...)"
"partition_info::prune_partition_bitmaps(TABLE_LIST*)" -> "List_iterator<T>::operator++(int) [with T = String]"
"partition_info::prune_partition_bitmaps(TABLE_LIST*)" -> "List_iterator<T>::List_iterator(List<T>&) [with T = String]"
"partition_info::prune_partition_bitmaps(TABLE_LIST*)" -> "memset(void*,int,size_t)"
"partition_info::prune_partition_bitmaps(TABLE_LIST*)" -> "partition_info::add_named_partition(const char*,uint)"
"partition_info::prune_partition_bitmaps(TABLE_LIST*)" -> "String::length() const"
"partition_info::prune_partition_bitmaps(TABLE_LIST*)" -> "String::c_ptr()"
"partition_info::add_named_partition(const char*,uint)" -> "my_error(int,myf,...)"
"partition_info::add_named_partition(const char*,uint)" -> "bitmap_set_bit(MY_BITMAP*,uint)"
"partition_info::add_named_partition(const char*,uint)" -> "partition_info::is_sub_partitioned()"
"partition_info::add_named_partition(const char*,uint)" -> "my_hash_search(const HASH*,const uchar*,size_t)"
"String::c_ptr()" -> "String::realloc(uint32)"
"check_stack_overrun(THD*,long int,uchar*)" -> "_current_thd()"
"check_stack_overrun(THD*,long int,uchar*)" -> "my_snprintf(char*,size_t,const char*,...)"
"check_stack_overrun(THD*,long int,uchar*)" -> "my_message(uint,const char*,myf)"
"open_table_entry_fini(THD*,TABLE_SHARE*,TABLE*)" -> "THD::binlog_query(THD::enum_binlog_query_type,const char*,ulong,bool,bool,bool,int)"
"open_table_entry_fini(THD*,TABLE_SHARE*,TABLE*)" -> "MYSQL_LOG::is_open()"
"open_table_entry_fini(THD*,TABLE_SHARE*,TABLE*)" -> "append_identifier(THD*,String*,const char*,uint)"
"open_table_entry_fini(THD*,TABLE_SHARE*,TABLE*)" -> "Table_triggers_list::check_n_load(THD*,const char*,const char*,TABLE*,bool)"
"open_table_entry_fini(THD*,TABLE_SHARE*,TABLE*)" -> "query_error_code(THD*,bool)"
"open_table_entry_fini(THD*,TABLE_SHARE*,TABLE*)" -> "sql_print_error(const char*,...)"
"open_table_entry_fini(THD*,TABLE_SHARE*,TABLE*)" -> "String::c_ptr_safe()"
"open_table_entry_fini(THD*,TABLE_SHARE*,TABLE*)" -> "String::length() const"
"open_table_entry_fini(THD*,TABLE_SHARE*,TABLE*)" -> "String::String()"
"open_table_entry_fini(THD*,TABLE_SHARE*,TABLE*)" -> "String::append(const char*)"
"open_table_entry_fini(THD*,TABLE_SHARE*,TABLE*)" -> "__builtin_expect(long int,long int)"
"open_table_entry_fini(THD*,TABLE_SHARE*,TABLE*)" -> "strlen(const char*)"
"THD::binlog_query(THD::enum_binlog_query_type,const char*,ulong,bool,bool,bool,int)" -> "THD::binlog_flush_pending_rows_event(bool,bool)"
"THD::binlog_query(THD::enum_binlog_query_type,const char*,ulong,bool,bool,bool,int)" -> "THD::get_binlog_local_stmt_filter()"
"THD::binlog_query(THD::enum_binlog_query_type,const char*,ulong,bool,bool,bool,int)" -> "THD::is_current_stmt_binlog_format_row() const"
"THD::binlog_query(THD::enum_binlog_query_type,const char*,ulong,bool,bool,bool,int)" -> "Query_log_event::Query_log_event(THD*,const char*,ulong,bool,bool,bool,int,bool)"
"THD::binlog_query(THD::enum_binlog_query_type,const char*,ulong,bool,bool,bool,int)" -> "MYSQL_BIN_LOG::write_event(Log_event*)"
"THD::binlog_query(THD::enum_binlog_query_type,const char*,ulong,bool,bool,bool,int)" -> "THD::issue_unsafe_warnings()"
"THD::issue_unsafe_warnings()" -> "_current_thd()"
"THD::issue_unsafe_warnings()" -> "do_unsafe_limit_checkout(char*,int,char*)"
"THD::issue_unsafe_warnings()" -> "print_unsafe_warning_to_log(int,char*,char*)"
"THD::issue_unsafe_warnings()" -> "push_warning_printf(THD*,Sql_condition::enum_warning_level,uint,const char*,...)"
"THD::issue_unsafe_warnings()" -> "Statement::query() const"
"do_unsafe_limit_checkout(char*,int,char*)" -> "sql_print_information(const char*,...)"
"do_unsafe_limit_checkout(char*,int,char*)" -> "print_unsafe_warning_to_log(int,char*,char*)"
"do_unsafe_limit_checkout(char*,int,char*)" -> "my_getsystime()"
"do_unsafe_limit_checkout(char*,int,char*)" -> "reset_binlog_unsafe_suppression()"
"print_unsafe_warning_to_log(int,char*,char*)" -> "sprintf(char*,const char*,...)"
"print_unsafe_warning_to_log(int,char*,char*)" -> "sql_print_warning(const char*,...)"
"print_unsafe_warning_to_log(int,char*,char*)" -> "_current_thd()"
"reset_binlog_unsafe_suppression()" -> "my_getsystime()"
"Table_triggers_list::check_n_load(THD*,const char*,const char*,TABLE*,bool)" -> "strmake_root(MEM_ROOT*,const char*,size_t)"
"Table_triggers_list::check_n_load(THD*,const char*,const char*,TABLE*,bool)" -> "LEX::LEX()"
"Table_triggers_list::check_n_load(THD*,const char*,const char*,TABLE*,bool)" -> "THD::pop_internal_handler()"
"Table_triggers_list::check_n_load(THD*,const char*,const char*,TABLE*,bool)" -> "Table_triggers_list::prepare_record1_accessors()"
"Table_triggers_list::check_n_load(THD*,const char*,const char*,TABLE*,bool)" -> "List<T>::push_back(T*,MEM_ROOT*) [with T = st_mysql_lex_string,MEM_ROOT = st_mem_root]"
"Table_triggers_list::check_n_load(THD*,const char*,const char*,TABLE*,bool)" -> "List<T>::push_back(T*,MEM_ROOT*) [with T = long long unsigned int,MEM_ROOT = st_mem_root]"
"Table_triggers_list::check_n_load(THD*,const char*,const char*,TABLE*,bool)" -> "List_iterator_fast<T>::rewind() [with T = st_mysql_lex_string]"
"Table_triggers_list::check_n_load(THD*,const char*,const char*,TABLE*,bool)" -> "push_warning_printf(THD*,Sql_condition::enum_warning_level,uint,const char*,...)"
"Table_triggers_list::check_n_load(THD*,const char*,const char*,TABLE*,bool)" -> "List_iterator_fast<T>::List_iterator_fast(List<T>&) [with T = long long unsigned int]"
"Table_triggers_list::check_n_load(THD*,const char*,const char*,TABLE*,bool)" -> "parse_sql(THD*,Parser_state*,Object_creation_ctx*)"
"Table_triggers_list::check_n_load(THD*,const char*,const char*,TABLE*,bool)" -> "build_table_filename(char*,size_t,const char*,const char*,const char*,uint)"
"Table_triggers_list::check_n_load(THD*,const char*,const char*,TABLE*,bool)" -> "List_iterator_fast<T>::operator++(int) [with T = st_mysql_lex_string]"
"Table_triggers_list::check_n_load(THD*,const char*,const char*,TABLE*,bool)" -> "is_equal(const LEX_STRING*,const LEX_STRING*)"
"Table_triggers_list::check_n_load(THD*,const char*,const char*,TABLE*,bool)" -> "base_list::empty()"
"Table_triggers_list::check_n_load(THD*,const char*,const char*,TABLE*,bool)" -> "List_iterator_fast<T>::List_iterator_fast(List<T>&) [with T = st_mysql_lex_string]"
"Table_triggers_list::check_n_load(THD*,const char*,const char*,TABLE*,bool)" -> "my_error(int,myf,...)"
"Table_triggers_list::check_n_load(THD*,const char*,const char*,TABLE*,bool)" -> "File_parser::type() const"
"Table_triggers_list::check_n_load(THD*,const char*,const char*,TABLE*,bool)" -> "Item_trigger_field::setup_field(THD*,TABLE*,GRANT_INFO*)"
"Table_triggers_list::check_n_load(THD*,const char*,const char*,TABLE*,bool)" -> "lex_start(THD*)"
"Table_triggers_list::check_n_load(THD*,const char*,const char*,TABLE*,bool)" -> "alloc_lex_string(MEM_ROOT*)"
"Table_triggers_list::check_n_load(THD*,const char*,const char*,TABLE*,bool)" -> "Parser_state::init(THD*,char*,unsigned int)"
"Table_triggers_list::check_n_load(THD*,const char*,const char*,TABLE*,bool)" -> "File_parser::parse(uchar*,MEM_ROOT*,File_option*,uint,Unknown_key_hook*) const"
"Table_triggers_list::check_n_load(THD*,const char*,const char*,TABLE*,bool)" -> "access(const char*,int)"
"Table_triggers_list::check_n_load(THD*,const char*,const char*,TABLE*,bool)" -> "Deprecated_trigger_syntax_handler::get_error_message()"
"Table_triggers_list::check_n_load(THD*,const char*,const char*,TABLE*,bool)" -> "sp_head::set_creation_ctx(Stored_program_creation_ctx*)"
"Table_triggers_list::check_n_load(THD*,const char*,const char*,TABLE*,bool)" -> "lex_string_set(LEX_STRING*,const char*)"
"Table_triggers_list::check_n_load(THD*,const char*,const char*,TABLE*,bool)" -> "THD::push_internal_handler(Internal_error_handler*)"
"Table_triggers_list::check_n_load(THD*,const char*,const char*,TABLE*,bool)" -> "sp_head::set_info(longlong,longlong,st_sp_chistics*,sql_mode_t)"
"Table_triggers_list::check_n_load(THD*,const char*,const char*,TABLE*,bool)" -> "Table_triggers_list::set_parse_error_message(char*)"
"Table_triggers_list::check_n_load(THD*,const char*,const char*,TABLE*,bool)" -> "Trigger_creation_ctx::create(THD*,const char*,const char*,const LEX_STRING*,const LEX_STRING*,const LEX_STRING*)"
"Table_triggers_list::check_n_load(THD*,const char*,const char*,TABLE*,bool)" -> "alloc_type(MEM_ROOT*) [with T = long long unsigned int,MEM_ROOT = st_mem_root]"
"Table_triggers_list::check_n_load(THD*,const char*,const char*,TABLE*,bool)" -> "Table_triggers_list::Table_triggers_list(TABLE*)"
"Table_triggers_list::check_n_load(THD*,const char*,const char*,TABLE*,bool)" -> "Deprecated_trigger_syntax_handler::Deprecated_trigger_syntax_handler()"
"Table_triggers_list::check_n_load(THD*,const char*,const char*,TABLE*,bool)" -> "Deprecated_trigger_syntax_handler::get_trigger_name()"
"Table_triggers_list::check_n_load(THD*,const char*,const char*,TABLE*,bool)" -> "Parser_state::Parser_state()"
"Table_triggers_list::check_n_load(THD*,const char*,const char*,TABLE*,bool)" -> "strlen(const char*)"
"Table_triggers_list::check_n_load(THD*,const char*,const char*,TABLE*,bool)" -> "List_iterator_fast<T>::operator++(int) [with T = long long unsigned int]"
"Table_triggers_list::check_n_load(THD*,const char*,const char*,TABLE*,bool)" -> "LEX::set_trg_event_type_for_tables()"
"Table_triggers_list::check_n_load(THD*,const char*,const char*,TABLE*,bool)" -> "base_list::is_empty() const"
"Table_triggers_list::check_n_load(THD*,const char*,const char*,TABLE*,bool)" -> "THD::reset_db(char*,size_t)"
"Table_triggers_list::check_n_load(THD*,const char*,const char*,TABLE*,bool)" -> "sp_head::set_definer(const char*,uint)"
"Table_triggers_list::check_n_load(THD*,const char*,const char*,TABLE*,bool)" -> "_current_thd()"
"Table_triggers_list::check_n_load(THD*,const char*,const char*,TABLE*,bool)" -> "sql_parse_prepare(const LEX_STRING*,MEM_ROOT*,bool)"
"Table_triggers_list::check_n_load(THD*,const char*,const char*,TABLE*,bool)" -> "lex_end(LEX*)"
"Table_triggers_list::check_n_load(THD*,const char*,const char*,TABLE*,bool)" -> "Handle_old_incorrect_sql_modes_hook::Handle_old_incorrect_sql_modes_hook(char*)"
"Table_triggers_list::prepare_record1_accessors()" -> "alloc_root(MEM_ROOT*,size_t)"
"List_iterator_fast<T>::rewind() [with T = st_mysql_lex_string]" -> "base_list_iterator::rewind()"
"List_iterator_fast<T>::List_iterator_fast(List<T>&) [with T = long long unsigned int]" -> "base_list_iterator::base_list_iterator(base_list&)"
"List_iterator_fast<T>::operator++(int) [with T = st_mysql_lex_string]" -> "base_list_iterator::next_fast()"
"List_iterator_fast<T>::List_iterator_fast(List<T>&) [with T = st_mysql_lex_string]" -> "base_list_iterator::base_list_iterator(base_list&)"
"Item_trigger_field::setup_field(THD*,TABLE*,GRANT_INFO*)" -> "find_field_in_table(THD*,TABLE*,const char*,uint,bool,uint*)"
"Item_trigger_field::setup_field(THD*,TABLE*,GRANT_INFO*)" -> "strlen(const char*)"
"find_field_in_table(THD*,TABLE*,const char*,uint,bool,uint*)" -> "my_hash_search(const HASH*,const uchar*,size_t)"
"find_field_in_table(THD*,TABLE*,const char*,uint,bool,uint*)" -> "update_field_dependencies(THD*,Field*,TABLE*)"
"update_field_dependencies(THD*,Field*,TABLE*)" -> "bitmap_fast_test_and_set(MY_BITMAP*,uint)"
"update_field_dependencies(THD*,Field*,TABLE*)" -> "Bitmap<64u>::merge(const Bitmap<64u>&)"
"update_field_dependencies(THD*,Field*,TABLE*)" -> "Bitmap<64u>::intersect(const Bitmap<64u>&)"
"alloc_lex_string(MEM_ROOT*)" -> "alloc_type(MEM_ROOT*) [with T = st_mysql_lex_string,MEM_ROOT = st_mem_root]"
"alloc_type(MEM_ROOT*) [with T = st_mysql_lex_string,MEM_ROOT = st_mem_root]" -> "alloc_root(MEM_ROOT*,size_t)"
"lex_string_set(LEX_STRING*,const char*)" -> "strlen(const char*)"
"sp_head::set_info(longlong,longlong,st_sp_chistics*,sql_mode_t)" -> "strmake_root(MEM_ROOT*,const char*,size_t)"
"sp_head::set_info(longlong,longlong,st_sp_chistics*,sql_mode_t)" -> "memdup_root(MEM_ROOT*,const void*,size_t)"
"Table_triggers_list::set_parse_error_message(char*)" -> "strncpy(char*,const char*,size_t)"
"Trigger_creation_ctx::create(THD*,const char*,const char*,const LEX_STRING*,const LEX_STRING*,const LEX_STRING*)" -> "sql_print_warning(const char*,...)"
"Trigger_creation_ctx::create(THD*,const char*,const char*,const LEX_STRING*,const LEX_STRING*,const LEX_STRING*)" -> "get_default_db_collation(THD*,const char*)"
"Trigger_creation_ctx::create(THD*,const char*,const char*,const LEX_STRING*,const LEX_STRING*,const LEX_STRING*)" -> "Trigger_creation_ctx::Trigger_creation_ctx(const CHARSET_INFO*,const CHARSET_INFO*,const CHARSET_INFO*)"
"Trigger_creation_ctx::create(THD*,const char*,const char*,const LEX_STRING*,const LEX_STRING*,const LEX_STRING*)" -> "resolve_charset(const char*,const CHARSET_INFO*,const CHARSET_INFO**)"
"Trigger_creation_ctx::create(THD*,const char*,const char*,const LEX_STRING*,const LEX_STRING*,const LEX_STRING*)" -> "_current_thd()"
"Trigger_creation_ctx::create(THD*,const char*,const char*,const LEX_STRING*,const LEX_STRING*,const LEX_STRING*)" -> "resolve_collation(const char*,const CHARSET_INFO*,const CHARSET_INFO**)"
"Trigger_creation_ctx::create(THD*,const char*,const char*,const LEX_STRING*,const LEX_STRING*,const LEX_STRING*)" -> "push_warning_printf(THD*,Sql_condition::enum_warning_level,uint,const char*,...)"
"Trigger_creation_ctx::Trigger_creation_ctx(const CHARSET_INFO*,const CHARSET_INFO*,const CHARSET_INFO*)" -> "Stored_program_creation_ctx::Stored_program_creation_ctx(const CHARSET_INFO*,const CHARSET_INFO*,const CHARSET_INFO*)"
"Trigger_creation_ctx::Trigger_creation_ctx(const CHARSET_INFO*,const CHARSET_INFO*,const CHARSET_INFO*)" -> "Sql_alloc::Sql_alloc()"
"Stored_program_creation_ctx::Stored_program_creation_ctx(const CHARSET_INFO*,const CHARSET_INFO*,const CHARSET_INFO*)" -> "Default_object_creation_ctx::Default_object_creation_ctx(const CHARSET_INFO*,const CHARSET_INFO*)"
"Default_object_creation_ctx::Default_object_creation_ctx(const CHARSET_INFO*,const CHARSET_INFO*)" -> "Object_creation_ctx::Object_creation_ctx()"
"alloc_type(MEM_ROOT*) [with T = long long unsigned int,MEM_ROOT = st_mem_root]" -> "alloc_root(MEM_ROOT*,size_t)"
"Table_triggers_list::Table_triggers_list(TABLE*)" -> "List<T>::List() [with T = long long unsigned int]"
"Table_triggers_list::Table_triggers_list(TABLE*)" -> "Sql_alloc::Sql_alloc()"
"Table_triggers_list::Table_triggers_list(TABLE*)" -> "memset(void*,int,size_t)"
"Table_triggers_list::Table_triggers_list(TABLE*)" -> "List<T>::List() [with T = st_mysql_lex_string]"
"List<T>::List() [with T = long long unsigned int]" -> "base_list::base_list()"
"Deprecated_trigger_syntax_handler::Deprecated_trigger_syntax_handler()" -> "Internal_error_handler::Internal_error_handler()"
"List_iterator_fast<T>::operator++(int) [with T = long long unsigned int]" -> "base_list_iterator::next_fast()"
"sp_head::set_definer(const char*,uint)" -> "parse_user(const char*,size_t,char*,size_t*,char*,size_t*)"
"sp_head::set_definer(const char*,uint)" -> "sp_head::set_definer(const LEX_STRING*,const LEX_STRING*)"
"sp_head::set_definer(const LEX_STRING*,const LEX_STRING*)" -> "strmake_root(MEM_ROOT*,const char*,size_t)"
"Handle_old_incorrect_sql_modes_hook::Handle_old_incorrect_sql_modes_hook(char*)" -> "Unknown_key_hook::Unknown_key_hook()"
"query_error_code(THD*,bool)" -> "THD::killed_errno() const"
"query_error_code(THD*,bool)" -> "Diagnostics_area::sql_errno() const"
"query_error_code(THD*,bool)" -> "THD::is_error() const"
"query_error_code(THD*,bool)" -> "THD::get_stmt_da()"
"String::c_ptr_safe()" -> "String::realloc(uint32)"
"Global_read_lock::can_acquire_protection() const" -> "my_error(int,myf,...)"
"open_table_from_share(THD*,TABLE_SHARE*,const char*,uint,uint,uint,TABLE*,bool)" -> "memcpy(void*,const void*,size_t)"
"open_table_from_share(THD*,TABLE_SHARE*,const char*,uint,uint,uint,TABLE*,bool)" -> "THD::set_n_backup_active_arena(Query_arena*,Query_arena*)"
"open_table_from_share(THD*,TABLE_SHARE*,const char*,uint,uint,uint,TABLE*,bool)" -> "_my_thread_var()"
"open_table_from_share(THD*,TABLE_SHARE*,const char*,uint,uint,uint,TABLE*,bool)" -> "mysql_unpack_partition(THD*,char*,uint,TABLE*,bool,handlerton*,bool*)"
"open_table_from_share(THD*,TABLE_SHARE*,const char*,uint,uint,uint,TABLE*,bool)" -> "Query_arena::Query_arena()"
"open_table_from_share(THD*,TABLE_SHARE*,const char*,uint,uint,uint,TABLE*,bool)" -> "alloc_root(MEM_ROOT*,size_t)"
"open_table_from_share(THD*,TABLE_SHARE*,const char*,uint,uint,uint,TABLE*,bool)" -> "fix_partition_func(THD*,TABLE*,bool)"
"open_table_from_share(THD*,TABLE_SHARE*,const char*,uint,uint,uint,TABLE*,bool)" -> "handler::ha_open(TABLE*,const char*,int,int)"
"open_table_from_share(THD*,TABLE_SHARE*,const char*,uint,uint,uint,TABLE*,bool)" -> "Query_arena::Query_arena(MEM_ROOT*,Query_arena::enum_state)"
"open_table_from_share(THD*,TABLE_SHARE*,const char*,uint,uint,uint,TABLE*,bool)" -> "get_new_handler(TABLE_SHARE*,MEM_ROOT*,handlerton*)"
"open_table_from_share(THD*,TABLE_SHARE*,const char*,uint,uint,uint,TABLE*,bool)" -> "open_table_error(TABLE_SHARE*,int,int,int)"
"open_table_from_share(THD*,TABLE_SHARE*,const char*,uint,uint,uint,TABLE*,bool)" -> "TABLE::default_column_bitmaps()"
"open_table_from_share(THD*,TABLE_SHARE*,const char*,uint,uint,uint,TABLE*,bool)" -> "bitmap_init(MY_BITMAP*,my_bitmap_map*,uint,my_bool)"
"open_table_from_share(THD*,TABLE_SHARE*,const char*,uint,uint,uint,TABLE*,bool)" -> "handler::ha_table_flags() const"
"open_table_from_share(THD*,TABLE_SHARE*,const char*,uint,uint,uint,TABLE*,bool)" -> "my_free(void*)"
"open_table_from_share(THD*,TABLE_SHARE*,const char*,uint,uint,uint,TABLE*,bool)" -> "Field::init(TABLE*)"
"open_table_from_share(THD*,TABLE_SHARE*,const char*,uint,uint,uint,TABLE*,bool)" -> "free_items(Item*)"
"open_table_from_share(THD*,TABLE_SHARE*,const char*,uint,uint,uint,TABLE*,bool)" -> "init_sql_alloc(MEM_ROOT*,uint,uint)"
"open_table_from_share(THD*,TABLE_SHARE*,const char*,uint,uint,uint,TABLE*,bool)" -> "memset(void*,int,size_t)"
"open_table_from_share(THD*,TABLE_SHARE*,const char*,uint,uint,uint,TABLE*,bool)" -> "free_root(MEM_ROOT*,myf)"
"open_table_from_share(THD*,TABLE_SHARE*,const char*,uint,uint,uint,TABLE*,bool)" -> "my_strdup(const char*,myf)"
"open_table_from_share(THD*,TABLE_SHARE*,const char*,uint,uint,uint,TABLE*,bool)" -> "TABLE_SHARE::db_type() const"
"open_table_from_share(THD*,TABLE_SHARE*,const char*,uint,uint,uint,TABLE*,bool)" -> "Bitmap<64u>::init()"
"open_table_from_share(THD*,TABLE_SHARE*,const char*,uint,uint,uint,TABLE*,bool)" -> "THD::restore_active_arena(Query_arena*,Query_arena*)"
"mysql_unpack_partition(THD*,char*,uint,TABLE*,bool,handlerton*,bool*)" -> "partition_info::fix_parser_data(THD*)"
"mysql_unpack_partition(THD*,char*,uint,TABLE*,bool,handlerton*,bool*)" -> "Parser_state::init(THD*,char*,unsigned int)"
"mysql_unpack_partition(THD*,char*,uint,TABLE*,bool,handlerton*,bool*)" -> "LEX::LEX()"
"mysql_unpack_partition(THD*,char*,uint,TABLE*,bool,handlerton*,bool*)" -> "Parser_state::Parser_state()"
"mysql_unpack_partition(THD*,char*,uint,TABLE*,bool,handlerton*,bool*)" -> "partition_info::partition_info()"
"mysql_unpack_partition(THD*,char*,uint,TABLE*,bool,handlerton*,bool*)" -> "memcpy(void*,const void*,size_t)"
"mysql_unpack_partition(THD*,char*,uint,TABLE*,bool,handlerton*,bool*)" -> "Query_arena::free_items()"
"mysql_unpack_partition(THD*,char*,uint,TABLE*,bool,handlerton*,bool*)" -> "init_lex_with_single_table(THD*,TABLE*,LEX*)"
"mysql_unpack_partition(THD*,char*,uint,TABLE*,bool,handlerton*,bool*)" -> "mem_alloc_error(size_t)"
"mysql_unpack_partition(THD*,char*,uint,TABLE*,bool,handlerton*,bool*)" -> "Query_arena::alloc(size_t)"
"mysql_unpack_partition(THD*,char*,uint,TABLE*,bool,handlerton*,bool*)" -> "parse_sql(THD*,Parser_state*,Object_creation_ctx*)"
"mysql_unpack_partition(THD*,char*,uint,TABLE*,bool,handlerton*,bool*)" -> "end_lex_with_single_table(THD*,TABLE*,LEX*)"
"partition_info::fix_parser_data(THD*)" -> "List_iterator<T>::List_iterator(List<T>&) [with T = p_elem_val]"
"partition_info::fix_parser_data(THD*)" -> "List_iterator<T>::List_iterator(List<T>&) [with T = partition_element]"
"partition_info::fix_parser_data(THD*)" -> "List_iterator<T>::remove() [with T = p_elem_val]"
"partition_info::fix_parser_data(THD*)" -> "partition_info::fix_partition_values(THD*,part_elem_value*,partition_element*,uint)"
"partition_info::fix_parser_data(THD*)" -> "my_error(int,myf,...)"
"partition_info::fix_parser_data(THD*)" -> "thd_sql_command(const THD*)"
"partition_info::fix_parser_data(THD*)" -> "partition_info::is_sub_partitioned()"
"partition_info::fix_parser_data(THD*)" -> "List_iterator<T>::operator++(int) [with T = p_elem_val]"
"partition_info::fix_parser_data(THD*)" -> "List_iterator<T>::operator++(int) [with T = partition_element]"
"List_iterator<T>::List_iterator(List<T>&) [with T = p_elem_val]" -> "base_list_iterator::base_list_iterator(base_list&)"
"List_iterator<T>::List_iterator(List<T>&) [with T = partition_element]" -> "base_list_iterator::base_list_iterator(base_list&)"
"List_iterator<T>::remove() [with T = p_elem_val]" -> "base_list_iterator::remove()"
"base_list_iterator::remove()" -> "base_list::remove(list_node**)"
"partition_info::fix_partition_values(THD*,part_elem_value*,partition_element*,uint)" -> "my_error(int,myf,...)"
"List_iterator<T>::operator++(int) [with T = p_elem_val]" -> "base_list_iterator::next()"
"List_iterator<T>::operator++(int) [with T = partition_element]" -> "base_list_iterator::next()"
"init_lex_with_single_table(THD*,TABLE*,LEX*)" -> "Name_resolution_context::init()"
"init_lex_with_single_table(THD*,TABLE*,LEX*)" -> "Table_ident::Table_ident(THD*,LEX_STRING,LEX_STRING,bool)"
"init_lex_with_single_table(THD*,TABLE*,LEX*)" -> "lex_start(THD*)"
"init_lex_with_single_table(THD*,TABLE*,LEX*)" -> "Name_resolution_context::resolve_in_table_list_only(TABLE_LIST*)"
"end_lex_with_single_table(THD*,TABLE*,LEX*)" -> "lex_end(LEX*)"
"fix_partition_func(THD*,TABLE*,bool)" -> "partition_info::report_part_expr_error(bool)"
"fix_partition_func(THD*,TABLE*,bool)" -> "check_part_func_fields(Field**,bool)"
"fix_partition_func(THD*,TABLE*,bool)" -> "my_error(int,myf,...)"
"fix_partition_func(THD*,TABLE*,bool)" -> "partition_info::set_up_charset_field_preps()"
"fix_partition_func(THD*,TABLE*,bool)" -> "create_full_part_field_array(THD*,TABLE*,partition_info*)"
"fix_partition_func(THD*,TABLE*,bool)" -> "check_range_capable_PF(TABLE*)"
"fix_partition_func(THD*,TABLE*,bool)" -> "handle_list_of_fields(List_iterator<char>,TABLE*,partition_info*,bool)"
"fix_partition_func(THD*,TABLE*,bool)" -> "check_primary_key(TABLE*)"
"fix_partition_func(THD*,TABLE*,bool)" -> "set_up_range_analysis_info(partition_info*)"
"fix_partition_func(THD*,TABLE*,bool)" -> "partition_default_handling(TABLE*,partition_info*,bool,const char*)"
"fix_partition_func(THD*,TABLE*,bool)" -> "partition_info::check_partition_field_length()"
"fix_partition_func(THD*,TABLE*,bool)" -> "set_up_partition_key_maps(TABLE*,partition_info*)"
"fix_partition_func(THD*,TABLE*,bool)" -> "List_iterator<T>::List_iterator(List<T>&) [with T = char]"
"fix_partition_func(THD*,TABLE*,bool)" -> "check_unique_keys(TABLE*)"
"fix_partition_func(THD*,TABLE*,bool)" -> "partition_info::is_sub_partitioned()"
"fix_partition_func(THD*,TABLE*,bool)" -> "set_up_partition_func_pointers(partition_info*)"
"fix_partition_func(THD*,TABLE*,bool)" -> "set_up_partition_bitmaps(THD*,partition_info*)"
"fix_partition_func(THD*,TABLE*,bool)" -> "partition_info::check_list_constants(THD*)"
"fix_partition_func(THD*,TABLE*,bool)" -> "__builtin_expect(long int,long int)"
"fix_partition_func(THD*,TABLE*,bool)" -> "fix_fields_part_func(THD*,Item*,TABLE*,bool,bool)"
"fix_partition_func(THD*,TABLE*,bool)" -> "TABLE_SHARE::db_type() const"
"fix_partition_func(THD*,TABLE*,bool)" -> "partition_info::check_range_constants(THD*)"
"fix_partition_func(THD*,TABLE*,bool)" -> "set_linear_hash_mask(partition_info*,uint)"
"partition_info::report_part_expr_error(bool)" -> "my_error(int,myf,...)"
"partition_info::report_part_expr_error(bool)" -> "Simple_cstring::ptr() const"
"check_part_func_fields(Field**,bool)" -> "field_is_partition_charset(Field*)"
"partition_info::set_up_charset_field_preps()" -> "partition_info::is_sub_partitioned()"
"partition_info::set_up_charset_field_preps()" -> "mem_alloc_error(size_t)"
"partition_info::set_up_charset_field_preps()" -> "sql_alloc(size_t)"
"partition_info::set_up_charset_field_preps()" -> "field_is_partition_charset(Field*)"
"partition_info::set_up_charset_field_preps()" -> "check_part_func_fields(Field**,bool)"
"partition_info::set_up_charset_field_preps()" -> "sql_calloc(size_t)"
"create_full_part_field_array(THD*,TABLE*,partition_info*)" -> "mem_alloc_error(size_t)"
"create_full_part_field_array(THD*,TABLE*,partition_info*)" -> "__builtin_expect(long int,long int)"
"create_full_part_field_array(THD*,TABLE*,partition_info*)" -> "Query_arena::alloc(size_t)"
"create_full_part_field_array(THD*,TABLE*,partition_info*)" -> "bitmap_set_bit(MY_BITMAP*,uint)"
"create_full_part_field_array(THD*,TABLE*,partition_info*)" -> "bitmap_init(MY_BITMAP*,my_bitmap_map*,uint,my_bool)"
"create_full_part_field_array(THD*,TABLE*,partition_info*)" -> "sql_calloc(size_t)"
"create_full_part_field_array(THD*,TABLE*,partition_info*)" -> "partition_info::is_sub_partitioned()"
"handle_list_of_fields(List_iterator<char>,TABLE*,partition_info*,bool)" -> "TABLE_SHARE::db_type() const"
"handle_list_of_fields(List_iterator<char>,TABLE*,partition_info*,bool)" -> "clear_field_flag(TABLE*)"
"handle_list_of_fields(List_iterator<char>,TABLE*,partition_info*,bool)" -> "my_error(int,myf,...)"
"handle_list_of_fields(List_iterator<char>,TABLE*,partition_info*,bool)" -> "set_up_field_array(TABLE*,bool)"
"handle_list_of_fields(List_iterator<char>,TABLE*,partition_info*,bool)" -> "find_field_in_table_sef(TABLE*,const char*)"
"handle_list_of_fields(List_iterator<char>,TABLE*,partition_info*,bool)" -> "List_iterator<T>::operator++(int) [with T = char]"
"handle_list_of_fields(List_iterator<char>,TABLE*,partition_info*,bool)" -> "__builtin_expect(long int,long int)"
"set_up_field_array(TABLE*,bool)" -> "mem_alloc_error(size_t)"
"set_up_field_array(TABLE*,bool)" -> "my_error(int,myf,...)"
"set_up_field_array(TABLE*,bool)" -> "List_iterator<T>::operator++(int) [with T = char]"
"set_up_field_array(TABLE*,bool)" -> "sql_calloc(size_t)"
"set_up_field_array(TABLE*,bool)" -> "__builtin_expect(long int,long int)"
"set_up_field_array(TABLE*,bool)" -> "List_iterator<T>::List_iterator(List<T>&) [with T = char]"
"List_iterator<T>::operator++(int) [with T = char]" -> "base_list_iterator::next()"
"List_iterator<T>::List_iterator(List<T>&) [with T = char]" -> "base_list_iterator::base_list_iterator(base_list&)"
"find_field_in_table_sef(TABLE*,const char*)" -> "my_hash_search(const HASH*,const uchar*,size_t)"
"find_field_in_table_sef(TABLE*,const char*)" -> "strlen(const char*)"
"check_primary_key(TABLE*)" -> "__builtin_expect(long int,long int)"
"check_primary_key(TABLE*)" -> "check_fields_in_PF(Field**,bool*,bool*)"
"check_primary_key(TABLE*)" -> "my_error(int,myf,...)"
"check_primary_key(TABLE*)" -> "set_indicator_in_key_fields(KEY*)"
"check_primary_key(TABLE*)" -> "clear_indicator_in_key_fields(KEY*)"
"partition_default_handling(TABLE*,partition_info*,bool,const char*)" -> "partition_info::set_up_defaults_for_partitioning(handler*,HA_CREATE_INFO*,uint)"
"partition_default_handling(TABLE*,partition_info*,bool,const char*)" -> "partition_info::is_sub_partitioned()"
"partition_info::set_up_defaults_for_partitioning(handler*,HA_CREATE_INFO*,uint)" -> "partition_info::set_up_default_subpartitions(handler*,HA_CREATE_INFO*)"
"partition_info::set_up_defaults_for_partitioning(handler*,HA_CREATE_INFO*,uint)" -> "partition_info::is_sub_partitioned()"
"partition_info::set_up_defaults_for_partitioning(handler*,HA_CREATE_INFO*,uint)" -> "partition_info::set_up_default_partitions(handler*,HA_CREATE_INFO*,uint)"
"partition_info::set_up_default_subpartitions(handler*,HA_CREATE_INFO*)" -> "my_error(int,myf,...)"
"partition_info::set_up_default_subpartitions(handler*,HA_CREATE_INFO*)" -> "List<T>::push_back(T*) [with T = partition_element]"
"partition_info::set_up_default_subpartitions(handler*,HA_CREATE_INFO*)" -> "List_iterator<T>::List_iterator(List<T>&) [with T = partition_element]"
"partition_info::set_up_default_subpartitions(handler*,HA_CREATE_INFO*)" -> "partition_info::create_default_subpartition_name(uint,const char*)"
"partition_info::set_up_default_subpartitions(handler*,HA_CREATE_INFO*)" -> "List_iterator<T>::operator++(int) [with T = partition_element]"
"partition_info::set_up_default_subpartitions(handler*,HA_CREATE_INFO*)" -> "mem_alloc_error(size_t)"
"partition_info::set_up_default_subpartitions(handler*,HA_CREATE_INFO*)" -> "__builtin_expect(long int,long int)"
"partition_info::set_up_default_subpartitions(handler*,HA_CREATE_INFO*)" -> "partition_element::partition_element(partition_element*)"
"partition_info::create_default_subpartition_name(uint,const char*)" -> "strlen(const char*)"
"partition_info::create_default_subpartition_name(uint,const char*)" -> "my_snprintf(char*,size_t,const char*,...)"
"partition_info::create_default_subpartition_name(uint,const char*)" -> "__builtin_expect(long int,long int)"
"partition_info::create_default_subpartition_name(uint,const char*)" -> "sql_calloc(size_t)"
"partition_info::create_default_subpartition_name(uint,const char*)" -> "mem_alloc_error(size_t)"
"partition_info::set_up_default_partitions(handler*,HA_CREATE_INFO*,uint)" -> "partition_element::partition_element()"
"partition_info::set_up_default_partitions(handler*,HA_CREATE_INFO*,uint)" -> "List<T>::push_back(T*) [with T = partition_element]"
"partition_info::set_up_default_partitions(handler*,HA_CREATE_INFO*,uint)" -> "partition_info::create_default_partition_names(uint,uint,uint)"
"partition_info::set_up_default_partitions(handler*,HA_CREATE_INFO*,uint)" -> "my_error(int,myf,...)"
"partition_info::set_up_default_partitions(handler*,HA_CREATE_INFO*,uint)" -> "mem_alloc_error(size_t)"
"partition_info::set_up_default_partitions(handler*,HA_CREATE_INFO*,uint)" -> "__builtin_expect(long int,long int)"
"partition_info::create_default_partition_names(uint,uint,uint)" -> "mem_alloc_error(size_t)"
"partition_info::create_default_partition_names(uint,uint,uint)" -> "sprintf(char*,const char*,...)"
"partition_info::create_default_partition_names(uint,uint,uint)" -> "__builtin_expect(long int,long int)"
"partition_info::create_default_partition_names(uint,uint,uint)" -> "sql_calloc(size_t)"
"partition_info::check_partition_field_length()" -> "get_partition_field_store_length(Field*)"
"get_partition_field_store_length(Field*)" -> "Field::real_maybe_null() const"
"set_up_partition_key_maps(TABLE*,partition_info*)" -> "set_indicator_in_key_fields(KEY*)"
"set_up_partition_key_maps(TABLE*,partition_info*)" -> "check_fields_in_PF(Field**,bool*,bool*)"
"set_up_partition_key_maps(TABLE*,partition_info*)" -> "partition_info::is_sub_partitioned()"
"set_up_partition_key_maps(TABLE*,partition_info*)" -> "clear_indicator_in_key_fields(KEY*)"
"set_up_partition_key_maps(TABLE*,partition_info*)" -> "Bitmap<64u>::clear_all()"
"set_up_partition_key_maps(TABLE*,partition_info*)" -> "Bitmap<64u>::set_bit(uint)"
"check_unique_keys(TABLE*)" -> "clear_indicator_in_key_fields(KEY*)"
"check_unique_keys(TABLE*)" -> "__builtin_expect(long int,long int)"
"check_unique_keys(TABLE*)" -> "set_indicator_in_key_fields(KEY*)"
"check_unique_keys(TABLE*)" -> "check_fields_in_PF(Field**,bool*,bool*)"
"check_unique_keys(TABLE*)" -> "my_error(int,myf,...)"
"set_up_partition_func_pointers(partition_info*)" -> "partition_info::is_sub_partitioned()"
"set_up_partition_bitmaps(THD*,partition_info*)" -> "mem_alloc_error(size_t)"
"set_up_partition_bitmaps(THD*,partition_info*)" -> "bitmap_init(MY_BITMAP*,my_bitmap_map*,uint,my_bool)"
"set_up_partition_bitmaps(THD*,partition_info*)" -> "alloc_root(MEM_ROOT*,size_t)"
"set_up_partition_bitmaps(THD*,partition_info*)" -> "partition_info::set_partition_bitmaps(TABLE_LIST*)"
"partition_info::check_list_constants(THD*)" -> "sql_calloc(size_t)"
"partition_info::check_list_constants(THD*)" -> "List_iterator<T>::operator++(int) [with T = p_elem_val]"
"partition_info::check_list_constants(THD*)" -> "mem_alloc_error(size_t)"
"partition_info::check_list_constants(THD*)" -> "my_error(int,myf,...)"
"partition_info::check_list_constants(THD*)" -> "List_iterator<T>::operator++(int) [with T = partition_element]"
"partition_info::check_list_constants(THD*)" -> "List_iterator<T>::List_iterator(List<T>&) [with T = p_elem_val]"
"partition_info::check_list_constants(THD*)" -> "List_iterator<T>::rewind() [with T = partition_element]"
"partition_info::check_list_constants(THD*)" -> "__builtin_expect(long int,long int)"
"partition_info::check_list_constants(THD*)" -> "List_iterator<T>::List_iterator(List<T>&) [with T = partition_element]"
"partition_info::check_list_constants(THD*)" -> "my_qsort(void*,size_t,size_t,qsort_cmp)"
"partition_info::check_list_constants(THD*)" -> "memcpy(void*,const void*,size_t)"
"partition_info::check_list_constants(THD*)" -> "partition_info::fix_column_value_functions(THD*,part_elem_value*,uint)"
"List_iterator<T>::rewind() [with T = partition_element]" -> "base_list_iterator::rewind()"
"partition_info::fix_column_value_functions(THD*,part_elem_value*,uint)" -> "partition_info::get_column_item(Item*,Field*)"
"partition_info::fix_column_value_functions(THD*,part_elem_value*,uint)" -> "my_error(int,myf,...)"
"partition_info::fix_column_value_functions(THD*,part_elem_value*,uint)" -> "sql_calloc(size_t)"
"partition_info::fix_column_value_functions(THD*,part_elem_value*,uint)" -> "memcpy(void*,const void*,size_t)"
"partition_info::fix_column_value_functions(THD*,part_elem_value*,uint)" -> "mem_alloc_error(size_t)"
"partition_info::get_column_item(Item*,Field*)" -> "convert_charset_partition_constant(Item*,const CHARSET_INFO*)"
"partition_info::get_column_item(Item*,Field*)" -> "my_error(int,myf,...)"
"convert_charset_partition_constant(Item*,const CHARSET_INFO*)" -> "_current_thd()"
"fix_fields_part_func(THD*,Item*,TABLE*,bool,bool)" -> "LEX::LEX()"
"fix_fields_part_func(THD*,Item*,TABLE*,bool,bool)" -> "st_select_lex::set_non_agg_field_used(bool)"
"fix_fields_part_func(THD*,Item*,TABLE*,bool,bool)" -> "my_error(int,myf,...)"
"fix_fields_part_func(THD*,Item*,TABLE*,bool,bool)" -> "push_warning(THD*,Sql_condition::enum_warning_level,uint,const char*)"
"fix_fields_part_func(THD*,Item*,TABLE*,bool,bool)" -> "st_select_lex::non_agg_field_used() const"
"fix_fields_part_func(THD*,Item*,TABLE*,bool,bool)" -> "__builtin_expect(long int,long int)"
"fix_fields_part_func(THD*,Item*,TABLE*,bool,bool)" -> "clear_field_flag(TABLE*)"
"fix_fields_part_func(THD*,Item*,TABLE*,bool,bool)" -> "check_signed_flag(partition_info*)"
"fix_fields_part_func(THD*,Item*,TABLE*,bool,bool)" -> "set_up_field_array(TABLE*,bool)"
"fix_fields_part_func(THD*,Item*,TABLE*,bool,bool)" -> "end_lex_with_single_table(THD*,TABLE*,LEX*)"
"fix_fields_part_func(THD*,Item*,TABLE*,bool,bool)" -> "st_select_lex::set_agg_func_used(bool)"
"fix_fields_part_func(THD*,Item*,TABLE*,bool,bool)" -> "_current_thd()"
"fix_fields_part_func(THD*,Item*,TABLE*,bool,bool)" -> "st_select_lex::agg_func_used() const"
"fix_fields_part_func(THD*,Item*,TABLE*,bool,bool)" -> "init_lex_with_single_table(THD*,TABLE*,LEX*)"
"check_signed_flag(partition_info*)" -> "my_error(int,myf,...)"
"check_signed_flag(partition_info*)" -> "List_iterator<T>::List_iterator(List<T>&) [with T = partition_element]"
"check_signed_flag(partition_info*)" -> "List_iterator<T>::operator++(int) [with T = partition_element]"
"partition_info::check_range_constants(THD*)" -> "List_iterator<T>::List_iterator(List<T>&) [with T = p_elem_val]"
"partition_info::check_range_constants(THD*)" -> "List_iterator<T>::operator++(int) [with T = partition_element]"
"partition_info::check_range_constants(THD*)" -> "List_iterator<T>::operator++(int) [with T = p_elem_val]"
"partition_info::check_range_constants(THD*)" -> "partition_info::fix_column_value_functions(THD*,part_elem_value*,uint)"
"partition_info::check_range_constants(THD*)" -> "partition_info::compare_column_values(const void*,const void*)"
"partition_info::check_range_constants(THD*)" -> "mem_alloc_error(size_t)"
"partition_info::check_range_constants(THD*)" -> "__builtin_expect(long int,long int)"
"partition_info::check_range_constants(THD*)" -> "List_iterator<T>::List_iterator(List<T>&) [with T = partition_element]"
"partition_info::check_range_constants(THD*)" -> "sql_alloc(size_t)"
"partition_info::check_range_constants(THD*)" -> "sql_calloc(size_t)"
"partition_info::check_range_constants(THD*)" -> "my_error(int,myf,...)"
"partition_info::check_range_constants(THD*)" -> "memcpy(void*,const void*,size_t)"
"partition_info::compare_column_values(const void*,const void*)" -> "partition_info_compare_column_values(const void*,const void*)"
"handler::ha_open(TABLE*,const char*,int,int)" -> "alloc_root(MEM_ROOT*,size_t)"
"handler::ha_open(TABLE*,const char*,int,int)" -> "handler::ha_close()"
"handler::ha_open(TABLE*,const char*,int,int)" -> "_my_thread_var()"
"check_if_table_exists(THD*,TABLE_LIST*,bool*)" -> "my_printf_error(uint,const char*,myf,...)"
"check_if_table_exists(THD*,TABLE_LIST*,bool*)" -> "inline_mysql_mutex_unlock(mysql_mutex_t*)"
"check_if_table_exists(THD*,TABLE_LIST*,bool*)" -> "ha_check_if_table_exists(THD*,const char*,const char*,bool*)"
"check_if_table_exists(THD*,TABLE_LIST*,bool*)" -> "access(const char*,int)"
"check_if_table_exists(THD*,TABLE_LIST*,bool*)" -> "inline_mysql_mutex_lock(mysql_mutex_t*)"
"check_if_table_exists(THD*,TABLE_LIST*,bool*)" -> "build_table_filename(char*,size_t,const char*,const char*,const char*,uint)"
"check_if_table_exists(THD*,TABLE_LIST*,bool*)" -> "get_cached_table_share(const char*,const char*)"
"ha_check_if_table_exists(THD*,const char*,const char*,bool*)" -> "my_free(void*)"
"ha_check_if_table_exists(THD*,const char*,const char*,bool*)" -> "ha_discover(THD*,const char*,const char*,uchar**,size_t*)"
"ha_discover(THD*,const char*,const char*,uchar**,size_t*)" -> "is_prefix(const char*,const char*)"
"ha_discover(THD*,const char*,const char*,uchar**,size_t*)" -> "plugin_foreach_with_mask(THD*,my_bool (*)(THD*,plugin_ref,void*),int,uint,void*)"
"Open_table_context::request_backoff_action(Open_table_context::enum_open_table_action,TABLE_LIST*)" -> "mark_transaction_to_rollback(THD*,bool)"
"Open_table_context::request_backoff_action(Open_table_context::enum_open_table_action,TABLE_LIST*)" -> "MDL_request::set_type(enum_mdl_type)"
"Open_table_context::request_backoff_action(Open_table_context::enum_open_table_action,TABLE_LIST*)" -> "Query_arena::alloc(size_t)"
"Open_table_context::request_backoff_action(Open_table_context::enum_open_table_action,TABLE_LIST*)" -> "my_error(int,myf,...)"
"Open_table_context::request_backoff_action(Open_table_context::enum_open_table_action,TABLE_LIST*)" -> "TABLE_LIST::init_one_table(const char*,size_t,const char*,size_t,const char*,thr_lock_type)"
"get_table_share_with_discover(THD*,TABLE_LIST*,const char*,uint,uint,int*,my_hash_value_type)" -> "my_error(int,myf,...)"
"get_table_share_with_discover(THD*,TABLE_LIST*,const char*,uint,uint,int*,my_hash_value_type)" -> "ha_check_if_table_exists(THD*,const char*,const char*,bool*)"
"get_table_share_with_discover(THD*,TABLE_LIST*,const char*,uint,uint,int*,my_hash_value_type)" -> "get_table_share(THD*,TABLE_LIST*,const char*,uint,uint,int*,my_hash_value_type)"
"get_table_share_with_discover(THD*,TABLE_LIST*,const char*,uint,uint,int*,my_hash_value_type)" -> "THD::is_error() const"
"get_table_share_with_discover(THD*,TABLE_LIST*,const char*,uint,uint,int*,my_hash_value_type)" -> "Diagnostics_area::sql_errno() const"
"get_table_share_with_discover(THD*,TABLE_LIST*,const char*,uint,uint,int*,my_hash_value_type)" -> "THD::clear_error()"
"get_table_share_with_discover(THD*,TABLE_LIST*,const char*,uint,uint,int*,my_hash_value_type)" -> "THD::get_stmt_da()"
"Table_cache::get_table(THD*,my_hash_value_type,const char*,uint,TABLE_SHARE**)" -> "I>::remove(T*) [with T = TABLE,B = I_P_List_adapter<TABLE,&TABLE::cache_next,&TABLE::cache_prev>,C = I_P_List_null_counter,I = I_P_List_no_push_back<TABLE>]"
"Table_cache::get_table(THD*,my_hash_value_type,const char*,uint,TABLE_SHARE**)" -> "my_hash_search_using_hash_value(const HASH*,my_hash_value_type,const uchar*,size_t)"
"Table_cache::get_table(THD*,my_hash_value_type,const char*,uint,TABLE_SHARE**)" -> "Table_cache::unlink_unused_table(TABLE*)"
"Table_cache::get_table(THD*,my_hash_value_type,const char*,uint,TABLE_SHARE**)" -> "I>::front() [with T = TABLE,B = I_P_List_adapter<TABLE,&TABLE::cache_next,&TABLE::cache_prev>,C = I_P_List_null_counter,I = I_P_List_no_push_back<TABLE>]"
"Table_cache::get_table(THD*,my_hash_value_type,const char*,uint,TABLE_SHARE**)" -> "Table_cache::assert_owner()"
"Table_cache::get_table(THD*,my_hash_value_type,const char*,uint,TABLE_SHARE**)" -> "I>::push_front(T*) [with T = TABLE,B = I_P_List_adapter<TABLE,&TABLE::cache_next,&TABLE::cache_prev>,C = I_P_List_null_counter,I = I_P_List_no_push_back<TABLE>]"
"tdc_wait_for_old_version(THD*,const char*,const char*,ulong,uint)" -> "TABLE_SHARE::wait_for_old_version(THD*,timespec*,uint)"
"tdc_wait_for_old_version(THD*,const char*,const char*,ulong,uint)" -> "inline_mysql_mutex_unlock(mysql_mutex_t*)"
"tdc_wait_for_old_version(THD*,const char*,const char*,ulong,uint)" -> "inline_mysql_mutex_lock(mysql_mutex_t*)"
"tdc_wait_for_old_version(THD*,const char*,const char*,ulong,uint)" -> "TABLE_SHARE::has_old_version() const"
"tdc_wait_for_old_version(THD*,const char*,const char*,ulong,uint)" -> "get_cached_table_share(const char*,const char*)"
"tdc_wait_for_old_version(THD*,const char*,const char*,ulong,uint)" -> "my_getsystime()"
"mysql_ha_flush(THD*)" -> "TABLE_SHARE::has_old_version() const"
"mysql_ha_flush(THD*)" -> "MDL_ticket::has_pending_conflicting_lock() const"
"mysql_ha_flush(THD*)" -> "mysql_ha_close_table(THD*,TABLE_LIST*)"
"mysql_ha_flush(THD*)" -> "my_hash_element(HASH*,ulong)"
"MDL_ticket::has_pending_conflicting_lock() const" -> "MDL_lock::has_pending_conflicting_lock(enum_mdl_type)"
"MDL_lock::has_pending_conflicting_lock(enum_mdl_type)" -> "inline_mysql_prlock_unlock(mysql_prlock_t*)"
"MDL_lock::has_pending_conflicting_lock(enum_mdl_type)" -> "MDL_lock::Ticket_list::bitmap() const"
"MDL_lock::has_pending_conflicting_lock(enum_mdl_type)" -> "inline_mysql_prlock_rdlock(mysql_prlock_t*)"
"MDL_ticket::downgrade_lock(enum_mdl_type)" -> "inline_mysql_prlock_wrlock(mysql_prlock_t*)"
"MDL_ticket::downgrade_lock(enum_mdl_type)" -> "MDL_ticket::has_stronger_or_equal_type(enum_mdl_type) const"
"MDL_ticket::downgrade_lock(enum_mdl_type)" -> "MDL_lock::Ticket_list::remove_ticket(MDL_ticket*)"
"MDL_ticket::downgrade_lock(enum_mdl_type)" -> "MDL_lock::reschedule_waiters()"
"MDL_ticket::downgrade_lock(enum_mdl_type)" -> "inline_mysql_prlock_unlock(mysql_prlock_t*)"
"MDL_ticket::downgrade_lock(enum_mdl_type)" -> "MDL_lock::Ticket_list::add_ticket(MDL_ticket*)"
"Global_read_lock::lock_global_read_lock(THD*)" -> "MDL_request::MDL_request()"
"Global_read_lock::lock_global_read_lock(THD*)" -> "MDL_request::init(MDL_key::enum_mdl_namespace,const char*,const char*,enum_mdl_type,enum_mdl_duration)"
"Global_read_lock::lock_global_read_lock(THD*)" -> "MDL_context::acquire_lock(MDL_request*,ulong)"
"refresh_status(THD*)" -> "inline_mysql_mutex_lock(mysql_mutex_t*)"
"refresh_status(THD*)" -> "time(time_t*)"
"refresh_status(THD*)" -> "memset(void*,int,size_t)"
"refresh_status(THD*)" -> "get_thread_count()"
"refresh_status(THD*)" -> "reset_status_vars()"
"refresh_status(THD*)" -> "inline_mysql_mutex_lock(mysql_mutex_t*,const char*,uint)"
"refresh_status(THD*)" -> "inline_mysql_mutex_unlock(mysql_mutex_t*)"
"refresh_status(THD*)" -> "add_to_status(STATUS_VAR*,STATUS_VAR*)"
"refresh_status(THD*)" -> "process_key_caches(process_key_cache_t)"
"kill_blocked_pthreads()" -> "inline_mysql_cond_wait(mysql_cond_t*,mysql_mutex_t*)"
"kill_blocked_pthreads()" -> "inline_mysql_mutex_lock(mysql_mutex_t*)"
"kill_blocked_pthreads()" -> "inline_mysql_cond_wait(mysql_cond_t*,mysql_mutex_t*,const char*,uint)"
"kill_blocked_pthreads()" -> "inline_mysql_cond_broadcast(mysql_cond_t*)"
"kill_blocked_pthreads()" -> "inline_mysql_mutex_lock(mysql_mutex_t*,const char*,uint)"
"kill_blocked_pthreads()" -> "inline_mysql_mutex_unlock(mysql_mutex_t*)"
"inline_mysql_cond_wait(mysql_cond_t*,mysql_mutex_t*,const char*,uint)" -> "pthread_cond_wait(pthread_cond_t*,pthread_mutex_t*)"
"mysqld_stmt_prepare(THD*,const char*,uint)" -> "mysql_reset_thd_for_next_command(THD*)"
"mysqld_stmt_prepare(THD*,const char*,uint)" -> "Prepared_statement::prepare(const char*,uint)"
"mysqld_stmt_prepare(THD*,const char*,uint)" -> "sp_cache_enforce_limit(sp_cache*,ulong)"
"mysqld_stmt_prepare(THD*,const char*,uint)" -> "Statement_map::insert(THD*,Statement*)"
"mysqld_stmt_prepare(THD*,const char*,uint)" -> "Prepared_statement::Prepared_statement(THD*)"
"mysqld_stmt_prepare(THD*,const char*,uint)" -> "Statement_map::erase(Statement*)"
"Prepared_statement::prepare(const char*,uint)" -> "THD::restore_active_arena(Query_arena*,Query_arena*)"
"Prepared_statement::prepare(const char*,uint)" -> "trans_rollback_implicit(THD*)"
"Prepared_statement::prepare(const char*,uint)" -> "String::c_ptr_safe()"
"Prepared_statement::prepare(const char*,uint)" -> "Parser_state::init(THD*,char*,unsigned int)"
"Prepared_statement::prepare(const char*,uint)" -> "rewrite_query_if_needed(THD*)"
"Prepared_statement::prepare(const char*,uint)" -> "Statement::restore_backup_statement(Statement*,Statement*)"
"Prepared_statement::prepare(const char*,uint)" -> "init_param_array(Prepared_statement*)"
"Prepared_statement::prepare(const char*,uint)" -> "Statement::set_n_backup_statement(Statement*,Statement*)"
"Prepared_statement::prepare(const char*,uint)" -> "Statement::query() const"
"Prepared_statement::prepare(const char*,uint)" -> "lex_start(THD*)"
"Prepared_statement::prepare(const char*,uint)" -> "THD::is_error() const"
"Prepared_statement::prepare(const char*,uint)" -> "LEX::set_trg_event_type_for_tables()"
"Prepared_statement::prepare(const char*,uint)" -> "Parser_state::Parser_state()"
"Prepared_statement::prepare(const char*,uint)" -> "st_lex_local::st_lex_local()"
"Prepared_statement::prepare(const char*,uint)" -> "lex_end(LEX*)"
"Prepared_statement::prepare(const char*,uint)" -> "Prepared_statement::setup_set_params()"
"Prepared_statement::prepare(const char*,uint)" -> "close_thread_tables(THD*)"
"Prepared_statement::prepare(const char*,uint)" -> "MDL_context::release_transactional_locks()"
"Prepared_statement::prepare(const char*,uint)" -> "THD::set_n_backup_active_arena(Query_arena*,Query_arena*)"
"Prepared_statement::prepare(const char*,uint)" -> "MDL_context::rollback_to_savepoint(const MDL_savepoint&)"
"Prepared_statement::prepare(const char*,uint)" -> "alloc_query(THD*,const char*,uint)"
"Prepared_statement::prepare(const char*,uint)" -> "String::length() const"
"Prepared_statement::prepare(const char*,uint)" -> "Prepared_statement::set_db(const char*,uint)"
"Prepared_statement::prepare(const char*,uint)" -> "st_select_lex_unit::cleanup()"
"Prepared_statement::prepare(const char*,uint)" -> "LOGGER::general_log_write(THD*,enum_server_command,const char*,uint)"
"Prepared_statement::prepare(const char*,uint)" -> "MDL_context::mdl_savepoint()"
"Prepared_statement::prepare(const char*,uint)" -> "check_prepared_statement(Prepared_statement*)"
"Prepared_statement::prepare(const char*,uint)" -> "Statement::Statement()"
"Prepared_statement::prepare(const char*,uint)" -> "parse_sql(THD*,Parser_state*,Object_creation_ctx*)"
"Prepared_statement::prepare(const char*,uint)" -> "Statement::query_length() const"
"rewrite_query_if_needed(THD*)" -> "mysql_rewrite_query(THD*)"
"init_param_array(Prepared_statement*)" -> "List_iterator<T>::List_iterator(List<T>&) [with T = Item_param]"
"init_param_array(Prepared_statement*)" -> "List_iterator<T>::operator++(int) [with T = Item_param]"
"init_param_array(Prepared_statement*)" -> "my_message(uint,const char*,myf)"
"init_param_array(Prepared_statement*)" -> "_current_thd()"
"init_param_array(Prepared_statement*)" -> "alloc_root(MEM_ROOT*,size_t)"
"List_iterator<T>::List_iterator(List<T>&) [with T = Item_param]" -> "base_list_iterator::base_list_iterator(base_list&)"
"List_iterator<T>::operator++(int) [with T = Item_param]" -> "base_list_iterator::next()"
"Prepared_statement::setup_set_params()" -> "MYSQL_LOG::is_open()"
"Prepared_statement::setup_set_params()" -> "is_update_query(enum_sql_command)"
"MDL_context::rollback_to_savepoint(const MDL_savepoint&)" -> "MDL_context::release_locks_stored_before(enum_mdl_duration,MDL_ticket*)"
"Prepared_statement::set_db(const char*,uint)" -> "Query_arena::strmake(const char*,size_t)"
"st_select_lex_unit::cleanup()" -> "st_select_lex_unit::cleanup_level()"
"st_select_lex_unit::cleanup()" -> "st_select_lex::next_select()"
"st_select_lex_unit::cleanup()" -> "st_select_lex::cleanup()"
"st_select_lex_unit::cleanup()" -> "st_select_lex_unit::first_select()"
"st_select_lex_unit::cleanup_level()" -> "st_select_lex::cleanup()"
"st_select_lex_unit::cleanup_level()" -> "free_tmp_table(THD*,TABLE*)"
"st_select_lex::cleanup()" -> "st_select_lex::cleanup_level()"
"st_select_lex::cleanup()" -> "st_select_lex_unit::next_unit()"
"st_select_lex::cleanup()" -> "st_select_lex::first_inner_unit()"
"st_select_lex::cleanup()" -> "st_select_lex_unit::cleanup()"
"st_select_lex::cleanup_level()" -> "JOIN::destroy()"
"st_select_lex::cleanup_level()" -> "base_list::empty()"
"JOIN::destroy()" -> "JOIN::cleanup_item_list(List<Item>&) const"
"JOIN::destroy()" -> "has_trivial_destructor>::clear() [with Element_type = Key_use,bool has_trivial_destructor = true]"
"JOIN::destroy()" -> "JOIN::cleanup(bool)"
"JOIN::destroy()" -> "free_tmp_table(THD*,TABLE*)"
"JOIN::destroy()" -> "List_iterator<T>::List_iterator(List<T>&) [with T = Semijoin_mat_exec]"
"JOIN::destroy()" -> "List_iterator<T>::operator++(int) [with T = Semijoin_mat_exec]"
"JOIN::destroy()" -> "destroy_sj_tmp_tables(JOIN*)"
"JOIN::destroy()" -> "base_list::empty()"
"JOIN::cleanup_item_list(List<Item>&) const" -> "List_iterator_fast<T>::List_iterator_fast(List<T>&) [with T = Item]"
"JOIN::cleanup_item_list(List<Item>&) const" -> "List_iterator_fast<T>::operator++(int) [with T = Item]"
"JOIN::cleanup_item_list(List<Item>&) const" -> "base_list::is_empty() const"
"has_trivial_destructor>::clear() [with Element_type = Key_use,bool has_trivial_destructor = true]" -> "has_trivial_destructor>::empty() const [with Element_type = Key_use,bool has_trivial_destructor = true]"
"has_trivial_destructor>::clear() [with Element_type = Key_use,bool has_trivial_destructor = true]" -> "has_trivial_destructor>::chop(size_t) [with Element_type = Key_use,bool has_trivial_destructor = true,size_t = long unsigned int]"
"has_trivial_destructor>::empty() const [with Element_type = Key_use,bool has_trivial_destructor = true]" -> "has_trivial_destructor>::size() const [with Element_type = Key_use,bool has_trivial_destructor = true,size_t = long unsigned int]"
"JOIN::cleanup(bool)" -> "free_io_cache(TABLE*)"
"JOIN::cleanup(bool)" -> "Bounds_checked_array<Element_type>::operator!=(const Bounds_checked_array<Element_type>&) const [with Element_type = Item*]"
"JOIN::cleanup(bool)" -> "handler::ha_index_or_rnd_end()"
"JOIN::cleanup(bool)" -> "base_list::empty()"
"JOIN::cleanup(bool)" -> "JOIN::set_items_ref_array(Ref_ptr_array)"
"JOIN::cleanup(bool)" -> "filesort_free_buffers(TABLE*,bool)"
"JOIN::cleanup(bool)" -> "st_join_table::cleanup()"
"JOIN::cleanup(bool)" -> "TMP_TABLE_PARAM::cleanup()"
"JOIN::cleanup(bool)" -> "List<T>::delete_elements() [with T = Cached_item]"
"JOIN::cleanup(bool)" -> "TABLE::is_created() const"
"JOIN::set_items_ref_array(Ref_ptr_array)" -> "JOIN::copy_ref_ptr_array(Ref_ptr_array,Ref_ptr_array)"
"JOIN::copy_ref_ptr_array(Ref_ptr_array,Ref_ptr_array)" -> "Bounds_checked_array<Element_type>::array() const [with Element_type = Item*]"
"JOIN::copy_ref_ptr_array(Ref_ptr_array,Ref_ptr_array)" -> "Bounds_checked_array<Element_type>::size() const [with Element_type = Item*,size_t = long unsigned int]"
"JOIN::copy_ref_ptr_array(Ref_ptr_array,Ref_ptr_array)" -> "Bounds_checked_array<Element_type>::element_size() const [with Element_type = Item*,size_t = long unsigned int]"
"JOIN::copy_ref_ptr_array(Ref_ptr_array,Ref_ptr_array)" -> "memcpy(void*,const void*,size_t)"
"st_join_table::cleanup()" -> "TABLE::set_keyread(bool)"
"st_join_table::cleanup()" -> "free_io_cache(TABLE*)"
"st_join_table::cleanup()" -> "filesort_free_buffers(TABLE*,bool)"
"st_join_table::cleanup()" -> "end_read_record(READ_RECORD*)"
"st_join_table::cleanup()" -> "base_list::empty()"
"st_join_table::cleanup()" -> "TABLE::is_created() const"
"st_join_table::cleanup()" -> "handler::ha_index_or_rnd_end()"
"TABLE::set_keyread(bool)" -> "TABLE::is_created() const"
"end_read_record(READ_RECORD*)" -> "TABLE::is_created() const"
"end_read_record(READ_RECORD*)" -> "TABLE::set_keyread(bool)"
"end_read_record(READ_RECORD*)" -> "filesort_free_buffers(TABLE*,bool)"
"end_read_record(READ_RECORD*)" -> "handler::ha_index_or_rnd_end()"
"end_read_record(READ_RECORD*)" -> "my_free(void*)"
"List<T>::delete_elements() [with T = Cached_item]" -> "base_list::empty()"
"List_iterator<T>::List_iterator(List<T>&) [with T = Semijoin_mat_exec]" -> "base_list_iterator::base_list_iterator(base_list&)"
"List_iterator<T>::operator++(int) [with T = Semijoin_mat_exec]" -> "base_list_iterator::next()"
"destroy_sj_tmp_tables(JOIN*)" -> "free_tmp_table(THD*,TABLE*)"
"destroy_sj_tmp_tables(JOIN*)" -> "handler::ha_index_or_rnd_end()"
"destroy_sj_tmp_tables(JOIN*)" -> "List_iterator<T>::List_iterator(List<T>&) [with T = TABLE]"
"destroy_sj_tmp_tables(JOIN*)" -> "List_iterator<T>::operator++(int) [with T = TABLE]"
"destroy_sj_tmp_tables(JOIN*)" -> "base_list::empty()"
"List_iterator<T>::List_iterator(List<T>&) [with T = TABLE]" -> "base_list_iterator::base_list_iterator(base_list&)"
"List_iterator<T>::operator++(int) [with T = TABLE]" -> "base_list_iterator::next()"
"check_prepared_statement(Prepared_statement*)" -> "my_message(uint,const char*,myf)"
"check_prepared_statement(Prepared_statement*)" -> "mysql_test_delete(Prepared_statement*,TABLE_LIST*)"
"check_prepared_statement(Prepared_statement*)" -> "LEX::first_lists_tables_same()"
"check_prepared_statement(Prepared_statement*)" -> "mysql_test_create_view(Prepared_statement*)"
"check_prepared_statement(Prepared_statement*)" -> "Statement::query_length() const"
"check_prepared_statement(Prepared_statement*)" -> "mysql_test_call_fields(Prepared_statement*,TABLE_LIST*,List<Item>*)"
"check_prepared_statement(Prepared_statement*)" -> "mysql_ha_rm_tables(THD*,TABLE_LIST*)"
"check_prepared_statement(Prepared_statement*)" -> "mysql_test_create_table(Prepared_statement*)"
"check_prepared_statement(Prepared_statement*)" -> "Opt_trace_object::Opt_trace_object(Opt_trace_context*,Opt_trace_context::feature_value)"
"check_prepared_statement(Prepared_statement*)" -> "mysql_test_insert_select(Prepared_statement*,TABLE_LIST*)"
"check_prepared_statement(Prepared_statement*)" -> "Name_resolution_context::resolve_in_table_list_only(TABLE_LIST*)"
"check_prepared_statement(Prepared_statement*)" -> "mysql_test_do_fields(Prepared_statement*,TABLE_LIST*,List<Item>*)"
"check_prepared_statement(Prepared_statement*)" -> "mysql_test_multidelete(Prepared_statement*,TABLE_LIST*)"
"check_prepared_statement(Prepared_statement*)" -> "Prepared_statement::is_sql_prepare() const"
"check_prepared_statement(Prepared_statement*)" -> "send_prep_stmt(Prepared_statement*,uint)"
"check_prepared_statement(Prepared_statement*)" -> "mysql_test_update(Prepared_statement*,TABLE_LIST*)"
"check_prepared_statement(Prepared_statement*)" -> "Opt_trace_array::Opt_trace_array(Opt_trace_context*,const char*,Opt_trace_context::feature_value)"
"check_prepared_statement(Prepared_statement*)" -> "mysql_test_insert(Prepared_statement*,TABLE_LIST*,List<Item>&,List<List<Item> >&,List<Item>&,List<Item>&,enum_duplicates)"
"check_prepared_statement(Prepared_statement*)" -> "mysql_test_select(Prepared_statement*,TABLE_LIST*)"
"check_prepared_statement(Prepared_statement*)" -> "THD::get_stmt_da()"
"check_prepared_statement(Prepared_statement*)" -> "Statement::query() const"
"check_prepared_statement(Prepared_statement*)" -> "mysql_test_multiupdate(Prepared_statement*,TABLE_LIST*,bool)"
"check_prepared_statement(Prepared_statement*)" -> "mysql_test_set_fields(Prepared_statement*,TABLE_LIST*,List<set_var_base>*)"
"check_prepared_statement(Prepared_statement*)" -> "Diagnostics_area::opt_clear_warning_info(ulonglong)"
"check_prepared_statement(Prepared_statement*)" -> "_current_thd()"
"check_prepared_statement(Prepared_statement*)" -> "open_temporary_tables(THD*,TABLE_LIST*)"
"check_prepared_statement(Prepared_statement*)" -> "Opt_trace_start::Opt_trace_start(THD*,TABLE_LIST*,enum_sql_command,List<set_var_base>*,const char*,size_t,sp_printable*,const CHARSET_INFO*)"
"mysql_test_delete(Prepared_statement*,TABLE_LIST*)" -> "my_error(int,myf,...)"
"mysql_test_delete(Prepared_statement*,TABLE_LIST*)" -> "open_normal_and_derived_tables(THD*,TABLE_LIST*,uint)"
"mysql_test_delete(Prepared_statement*,TABLE_LIST*)" -> "delete_precheck(THD*,TABLE_LIST*)"
"mysql_test_delete(Prepared_statement*,TABLE_LIST*)" -> "mysql_prepare_delete(THD*,TABLE_LIST*,Item**)"
"open_normal_and_derived_tables(THD*,TABLE_LIST*,uint)" -> "MDL_context::mdl_savepoint()"
"open_normal_and_derived_tables(THD*,TABLE_LIST*,uint)" -> "DML_prelocking_strategy::DML_prelocking_strategy()"
"open_normal_and_derived_tables(THD*,TABLE_LIST*,uint)" -> "mysql_handle_derived(LEX*,bool (*)(THD*,LEX*,TABLE_LIST*))"
"open_normal_and_derived_tables(THD*,TABLE_LIST*,uint)" -> "close_thread_tables(THD*)"
"open_normal_and_derived_tables(THD*,TABLE_LIST*,uint)" -> "MDL_context::rollback_to_savepoint(const MDL_savepoint&)"
"open_normal_and_derived_tables(THD*,TABLE_LIST*,uint)" -> "open_tables(THD*,TABLE_LIST**,uint*,uint,Prelocking_strategy*)"
"DML_prelocking_strategy::DML_prelocking_strategy()" -> "Prelocking_strategy::Prelocking_strategy()"
"mysql_handle_derived(LEX*,bool (*)(THD*,LEX*,TABLE_LIST*))" -> "mysql_handle_single_derived(LEX*,TABLE_LIST*,bool (*)(THD*,LEX*,TABLE_LIST*))"
"mysql_handle_derived(LEX*,bool (*)(THD*,LEX*,TABLE_LIST*))" -> "st_select_lex::next_select_in_list()"
"mysql_handle_single_derived(LEX*,TABLE_LIST*,bool (*)(THD*,LEX*,TABLE_LIST*))" -> "TABLE_LIST::is_view_or_derived() const"
"open_tables(THD*,TABLE_LIST**,uint*,uint,Prelocking_strategy*)" -> "Query_tables_list::requires_prelocking()"
"open_tables(THD*,TABLE_LIST**,uint*,uint,Prelocking_strategy*)" -> "THD::enter_stage(const PSI_stage_info*,PSI_stage_info*,const char*,const char*,unsigned int)"
"open_tables(THD*,TABLE_LIST**,uint*,uint,Prelocking_strategy*)" -> "Open_table_context::Open_table_context(THD*,uint)"
"open_tables(THD*,TABLE_LIST**,uint*,uint,Prelocking_strategy*)" -> "read_lock_type_for_table(THD*,Query_tables_list*,TABLE_LIST*,bool)"
"open_tables(THD*,TABLE_LIST**,uint*,uint,Prelocking_strategy*)" -> "Open_table_context::get_timeout() const"
"open_tables(THD*,TABLE_LIST**,uint*,uint,Prelocking_strategy*)" -> "Open_table_context::recover_from_failed_open()"
"open_tables(THD*,TABLE_LIST**,uint*,uint,Prelocking_strategy*)" -> "open_and_process_table(THD*,LEX*,TABLE_LIST*,uint*,uint,Prelocking_strategy*,bool,Open_table_context*)"
"open_tables(THD*,TABLE_LIST**,uint*,uint,Prelocking_strategy*)" -> "my_error(int,myf,...)"
"open_tables(THD*,TABLE_LIST**,uint*,uint,Prelocking_strategy*)" -> "open_tables_check_upgradable_mdl(THD*,TABLE_LIST*,TABLE_LIST*,uint)"
"open_tables(THD*,TABLE_LIST**,uint*,uint,Prelocking_strategy*)" -> "open_temporary_tables(THD*,TABLE_LIST*)"
"open_tables(THD*,TABLE_LIST**,uint*,uint,Prelocking_strategy*)" -> "lock_table_names(THD*,TABLE_LIST*,TABLE_LIST*,ulong,uint)"
"open_tables(THD*,TABLE_LIST**,uint*,uint,Prelocking_strategy*)" -> "Query_tables_list::mark_as_requiring_prelocking(TABLE_LIST**)"
"open_tables(THD*,TABLE_LIST**,uint*,uint,Prelocking_strategy*)" -> "open_and_process_routine(THD*,Query_tables_list*,Sroutine_hash_entry*,Prelocking_strategy*,bool,Open_table_context*,bool*,bool*)"
"open_tables(THD*,TABLE_LIST**,uint*,uint,Prelocking_strategy*)" -> "Open_table_context::can_recover_from_failed_open() const"
"open_tables(THD*,TABLE_LIST**,uint*,uint,Prelocking_strategy*)" -> "Query_tables_list::first_not_own_table()"
"open_tables(THD*,TABLE_LIST**,uint*,uint,Prelocking_strategy*)" -> "close_tables_for_reopen(THD*,TABLE_LIST**,const MDL_savepoint&)"
"open_tables(THD*,TABLE_LIST**,uint*,uint,Prelocking_strategy*)" -> "mysql_ha_flush(THD*)"
"open_tables(THD*,TABLE_LIST**,uint*,uint,Prelocking_strategy*)" -> "Open_table_context::start_of_statement_svp() const"
"read_lock_type_for_table(THD*,Query_tables_list*,TABLE_LIST*,bool)" -> "is_update_query(enum_sql_command)"
"read_lock_type_for_table(THD*,Query_tables_list*,TABLE_LIST*,bool)" -> "MYSQL_LOG::is_open()"
"Open_table_context::recover_from_failed_open()" -> "MDL_context::release_transactional_locks()"
"Open_table_context::recover_from_failed_open()" -> "lock_table_names(THD*,TABLE_LIST*,TABLE_LIST*,ulong,uint)"
"Open_table_context::recover_from_failed_open()" -> "Diagnostics_area::clear_warning_info(ulonglong)"
"Open_table_context::recover_from_failed_open()" -> "tdc_remove_table(THD*,enum_tdc_remove_table_type,const char*,const char*,bool)"
"Open_table_context::recover_from_failed_open()" -> "Open_table_context::get_timeout() const"
"Open_table_context::recover_from_failed_open()" -> "THD::clear_error()"
"Open_table_context::recover_from_failed_open()" -> "ha_create_table_from_engine(THD*,const char*,const char*)"
"Open_table_context::recover_from_failed_open()" -> "THD::get_stmt_da()"
"Open_table_context::recover_from_failed_open()" -> "auto_repair_table(THD*,TABLE_LIST*)"
"lock_table_names(THD*,TABLE_LIST*,TABLE_LIST*,ulong,uint)" -> "my_error(int,myf,...)"
"lock_table_names(THD*,TABLE_LIST*,TABLE_LIST*,ulong,uint)" -> "K>::Iterator::Iterator(Hash_set<T,K>&) [with T = TABLE_LIST,uchar* (* K)(const uchar*,size_t*,char) = schema_set_get_key,Hash_set<T,K> = Hash_set<TABLE_LIST,schema_set_get_key>]"
"lock_table_names(THD*,TABLE_LIST*,TABLE_LIST*,ulong,uint)" -> "MDL_request::MDL_request()"
"lock_table_names(THD*,TABLE_LIST*,TABLE_LIST*,ulong,uint)" -> "I>::push_front(T*) [with T = MDL_request,B = I_P_List_adapter<MDL_request,&MDL_request::next_in_list,&MDL_request::prev_in_list>,C = I_P_List_counter,I = I_P_List_no_push_back<MDL_request>]"
"lock_table_names(THD*,TABLE_LIST*,TABLE_LIST*,ulong,uint)" -> "K>::Iterator::operator++(int) [with T = TABLE_LIST,uchar* (* K)(const uchar*,size_t*,char) = schema_set_get_key]"
"lock_table_names(THD*,TABLE_LIST*,TABLE_LIST*,ulong,uint)" -> "MDL_context::acquire_locks(MDL_request_list*,ulong)"
"lock_table_names(THD*,TABLE_LIST*,TABLE_LIST*,ulong,uint)" -> "Global_read_lock::can_acquire_protection() const"
"lock_table_names(THD*,TABLE_LIST*,TABLE_LIST*,ulong,uint)" -> "MDL_request::init(MDL_key::enum_mdl_namespace,const char*,const char*,enum_mdl_type,enum_mdl_duration)"
"lock_table_names(THD*,TABLE_LIST*,TABLE_LIST*,ulong,uint)" -> "K>::insert(T*) [with T = TABLE_LIST,uchar* (* K)(const uchar*,size_t*,char) = schema_set_get_key]"
"lock_table_names(THD*,TABLE_LIST*,TABLE_LIST*,ulong,uint)" -> "K>::Hash_set() [with T = TABLE_LIST,uchar* (* K)(const uchar*,size_t*,char) = schema_set_get_key]"
"lock_table_names(THD*,TABLE_LIST*,TABLE_LIST*,ulong,uint)" -> "is_temporary_table(TABLE_LIST*)"
"lock_table_names(THD*,TABLE_LIST*,TABLE_LIST*,ulong,uint)" -> "I>::is_empty() const [with T = MDL_request,B = I_P_List_adapter<MDL_request,&MDL_request::next_in_list,&MDL_request::prev_in_list>,C = I_P_List_counter,I = I_P_List_no_push_back<MDL_request>]"
"lock_table_names(THD*,TABLE_LIST*,TABLE_LIST*,ulong,uint)" -> "I>::I_P_List() [with T = MDL_request,B = I_P_List_adapter<MDL_request,&MDL_request::next_in_list,&MDL_request::prev_in_list>,C = I_P_List_counter,I = I_P_List_no_push_back<MDL_request>]"
"I>::push_front(T*) [with T = MDL_request,B = I_P_List_adapter<MDL_request,&MDL_request::next_in_list,&MDL_request::prev_in_list>,C = I_P_List_counter,I = I_P_List_no_push_back<MDL_request>]" -> "I_P_List_no_push_back<T>::set_last(T**) [with T = MDL_request]"
"I>::push_front(T*) [with T = MDL_request,B = I_P_List_adapter<MDL_request,&MDL_request::next_in_list,&MDL_request::prev_in_list>,C = I_P_List_counter,I = I_P_List_no_push_back<MDL_request>]" -> "prev>::next_ptr(T*) [with T = MDL_request,T* T::* next = &MDL_request::next_in_list,T** T::* prev = &MDL_request::prev_in_list]"
"I>::push_front(T*) [with T = MDL_request,B = I_P_List_adapter<MDL_request,&MDL_request::next_in_list,&MDL_request::prev_in_list>,C = I_P_List_counter,I = I_P_List_no_push_back<MDL_request>]" -> "I_P_List_counter::inc()"
"I>::push_front(T*) [with T = MDL_request,B = I_P_List_adapter<MDL_request,&MDL_request::next_in_list,&MDL_request::prev_in_list>,C = I_P_List_counter,I = I_P_List_no_push_back<MDL_request>]" -> "prev>::prev_ptr(T*) [with T = MDL_request,T* T::* next = &MDL_request::next_in_list,T** T::* prev = &MDL_request::prev_in_list]"
"K>::Iterator::operator++(int) [with T = TABLE_LIST,uchar* (* K)(const uchar*,size_t*,char) = schema_set_get_key]" -> "my_hash_element(HASH*,ulong)"
"MDL_context::acquire_locks(MDL_request_list*,ulong)" -> "L>::operator++(int) [with T = MDL_request,L = I_P_List<MDL_request,I_P_List_adapter<MDL_request,&MDL_request::next_in_list,&MDL_request::prev_in_list>,I_P_List_counter>]"
"MDL_context::acquire_locks(MDL_request_list*,ulong)" -> "L>::I_P_List_iterator(const L&) [with T = MDL_request,L = I_P_List<MDL_request,I_P_List_adapter<MDL_request,&MDL_request::next_in_list,&MDL_request::prev_in_list>,I_P_List_counter>]"
"MDL_context::acquire_locks(MDL_request_list*,ulong)" -> "MDL_context::rollback_to_savepoint(const MDL_savepoint&)"
"MDL_context::acquire_locks(MDL_request_list*,ulong)" -> "MDL_context::acquire_lock(MDL_request*,ulong)"
"MDL_context::acquire_locks(MDL_request_list*,ulong)" -> "my_qsort(void*,size_t,size_t,qsort_cmp)"
"MDL_context::acquire_locks(MDL_request_list*,ulong)" -> "I_P_List_counter::elements() const"
"MDL_context::acquire_locks(MDL_request_list*,ulong)" -> "my_free(void*)"
"MDL_context::acquire_locks(MDL_request_list*,ulong)" -> "my_malloc(size_t,myf)"
"MDL_context::acquire_locks(MDL_request_list*,ulong)" -> "MDL_context::mdl_savepoint()"
"L>::operator++(int) [with T = MDL_request,L = I_P_List<MDL_request,I_P_List_adapter<MDL_request,&MDL_request::next_in_list,&MDL_request::prev_in_list>,I_P_List_counter>]" -> "prev>::next_ptr(T*) [with T = MDL_request,T* T::* next = &MDL_request::next_in_list,T** T::* prev = &MDL_request::prev_in_list]"
"K>::insert(T*) [with T = TABLE_LIST,uchar* (* K)(const uchar*,size_t*,char) = schema_set_get_key]" -> "my_hash_insert(HASH*,const uchar*)"
"K>::insert(T*) [with T = TABLE_LIST,uchar* (* K)(const uchar*,size_t*,char) = schema_set_get_key]" -> "my_hash_search(const HASH*,const uchar*,size_t)"
"K>::insert(T*) [with T = TABLE_LIST,uchar* (* K)(const uchar*,size_t*,char) = schema_set_get_key]" -> "_my_hash_init(HASH*,uint,CHARSET_INFO*,my_hash_function,ulong,size_t,size_t,my_hash_get_key,void (*)(void*),uint)"
"K>::insert(T*) [with T = TABLE_LIST,uchar* (* K)(const uchar*,size_t*,char) = schema_set_get_key]" -> "schema_set_get_key(const uchar*,size_t*,my_bool)"
"K>::Hash_set() [with T = TABLE_LIST,uchar* (* K)(const uchar*,size_t*,char) = schema_set_get_key]" -> "memset(void*,int,size_t)"
"I>::I_P_List() [with T = MDL_request,B = I_P_List_adapter<MDL_request,&MDL_request::next_in_list,&MDL_request::prev_in_list>,C = I_P_List_counter,I = I_P_List_no_push_back<MDL_request>]" -> "I_P_List_no_push_back<T>::I_P_List_no_push_back(T**) [with T = MDL_request]"
"I>::I_P_List() [with T = MDL_request,B = I_P_List_adapter<MDL_request,&MDL_request::next_in_list,&MDL_request::prev_in_list>,C = I_P_List_counter,I = I_P_List_no_push_back<MDL_request>]" -> "I_P_List_counter::I_P_List_counter()"
"Diagnostics_area::clear_warning_info(ulonglong)" -> "Diagnostics_area::get_warning_info()"
"Diagnostics_area::clear_warning_info(ulonglong)" -> "Warning_info::clear(ulonglong)"
"ha_create_table_from_engine(THD*,const char*,const char*)" -> "writefrm(const char*,const uchar*,size_t)"
"ha_create_table_from_engine(THD*,const char*,const char*)" -> "build_table_filename(char*,size_t,const char*,const char*,const char*,uint)"
"ha_create_table_from_engine(THD*,const char*,const char*)" -> "handler::ha_create(const char*,TABLE*,HA_CREATE_INFO*)"
"ha_create_table_from_engine(THD*,const char*,const char*)" -> "TABLE::TABLE()"
"ha_create_table_from_engine(THD*,const char*,const char*)" -> "memset(void*,int,size_t)"
"ha_create_table_from_engine(THD*,const char*,const char*)" -> "st_ha_create_information::st_ha_create_information()"
"ha_create_table_from_engine(THD*,const char*,const char*)" -> "get_canonical_filename(handler*,const char*,char*)"
"ha_create_table_from_engine(THD*,const char*,const char*)" -> "free_table_share(TABLE_SHARE*)"
"ha_create_table_from_engine(THD*,const char*,const char*)" -> "closefrm(TABLE*,bool)"
"ha_create_table_from_engine(THD*,const char*,const char*)" -> "update_create_info_from_table(HA_CREATE_INFO*,TABLE*)"
"ha_create_table_from_engine(THD*,const char*,const char*)" -> "open_table_def(THD*,TABLE_SHARE*,uint)"
"ha_create_table_from_engine(THD*,const char*,const char*)" -> "ha_discover(THD*,const char*,const char*,uchar**,size_t*)"
"ha_create_table_from_engine(THD*,const char*,const char*)" -> "my_free(void*)"
"ha_create_table_from_engine(THD*,const char*,const char*)" -> "TABLE_SHARE::TABLE_SHARE()"
"ha_create_table_from_engine(THD*,const char*,const char*)" -> "open_table_from_share(THD*,TABLE_SHARE*,const char*,uint,uint,uint,TABLE*,bool)"
"ha_create_table_from_engine(THD*,const char*,const char*)" -> "init_tmp_table_share(THD*,TABLE_SHARE*,const char*,uint,const char*,const char*)"
"writefrm(const char*,const uchar*,size_t)" -> "inline_mysql_file_create(const char*,int,int,myf)"
"writefrm(const char*,const uchar*,size_t)" -> "inline_mysql_file_write(File,const uchar*,size_t,myf)"
"writefrm(const char*,const uchar*,size_t)" -> "fn_format(char*,const char*,const char*,const char*,uint)"
"writefrm(const char*,const uchar*,size_t)" -> "inline_mysql_file_close(File,myf)"
"inline_mysql_file_create(const char*,int,int,myf)" -> "my_create(const char*,int,int,myf)"
"handler::ha_create(const char*,TABLE*,HA_CREATE_INFO*)" -> "handler::mark_trx_read_write()"
"TABLE::TABLE()" -> "Filesort_info::Filesort_info()"
"TABLE::TABLE()" -> "Bitmap<64u>::Bitmap()"
"Filesort_info::Filesort_info()" -> "Filesort_buffer::Filesort_buffer()"
"Filesort_buffer::Filesort_buffer()" -> "Bounds_checked_array<Element_type>::Bounds_checked_array() [with Element_type = unsigned char*]"
"get_canonical_filename(handler*,const char*,char*)" -> "__builtin_strcpy(char*,const char*)"
"get_canonical_filename(handler*,const char*,char*)" -> "handler::ha_table_flags() const"
"get_canonical_filename(handler*,const char*,char*)" -> "is_prefix(const char*,const char*)"
"TABLE_SHARE::TABLE_SHARE()" -> "I>::I_P_List() [with T = Wait_for_flush,B = I_P_List_adapter<Wait_for_flush,&Wait_for_flush::next_in_share,&Wait_for_flush::prev_in_share>,C = I_P_List_null_counter,I = I_P_List_no_push_back<Wait_for_flush>]"
"TABLE_SHARE::TABLE_SHARE()" -> "Table_id::Table_id()"
"TABLE_SHARE::TABLE_SHARE()" -> "Bitmap<64u>::Bitmap()"
"I>::I_P_List() [with T = Wait_for_flush,B = I_P_List_adapter<Wait_for_flush,&Wait_for_flush::next_in_share,&Wait_for_flush::prev_in_share>,C = I_P_List_null_counter,I = I_P_List_no_push_back<Wait_for_flush>]" -> "I_P_List_null_counter::I_P_List_null_counter()"
"I>::I_P_List() [with T = Wait_for_flush,B = I_P_List_adapter<Wait_for_flush,&Wait_for_flush::next_in_share,&Wait_for_flush::prev_in_share>,C = I_P_List_null_counter,I = I_P_List_no_push_back<Wait_for_flush>]" -> "I_P_List_no_push_back<T>::I_P_List_no_push_back(T**) [with T = Wait_for_flush]"
"init_tmp_table_share(THD*,TABLE_SHARE*,const char*,uint,const char*,const char*)" -> "Table_id::operator=(ulonglong)"
"init_tmp_table_share(THD*,TABLE_SHARE*,const char*,uint,const char*,const char*)" -> "memset(void*,int,size_t)"
"init_tmp_table_share(THD*,TABLE_SHARE*,const char*,uint,const char*,const char*)" -> "init_sql_alloc(MEM_ROOT*,uint,uint)"
"init_tmp_table_share(THD*,TABLE_SHARE*,const char*,uint,const char*,const char*)" -> "strlen(const char*)"
"init_tmp_table_share(THD*,TABLE_SHARE*,const char*,uint,const char*,const char*)" -> "I>::empty() [with T = Wait_for_flush,B = I_P_List_adapter<Wait_for_flush,&Wait_for_flush::next_in_share,&Wait_for_flush::prev_in_share>,C = I_P_List_null_counter,I = I_P_List_no_push_back<Wait_for_flush>]"
"auto_repair_table(THD*,TABLE_LIST*)" -> "inline_mysql_mutex_unlock(mysql_mutex_t*)"
"auto_repair_table(THD*,TABLE_LIST*)" -> "open_table_from_share(THD*,TABLE_SHARE*,const char*,uint,uint,uint,TABLE*,bool)"
"auto_repair_table(THD*,TABLE_LIST*)" -> "my_error(int,myf,...)"
"auto_repair_table(THD*,TABLE_LIST*)" -> "my_free(void*)"
"auto_repair_table(THD*,TABLE_LIST*)" -> "get_table_share(THD*,TABLE_LIST*,const char*,uint,uint,int*,my_hash_value_type)"
"auto_repair_table(THD*,TABLE_LIST*)" -> "THD::clear_error()"
"auto_repair_table(THD*,TABLE_LIST*)" -> "my_malloc(size_t,myf)"
"auto_repair_table(THD*,TABLE_LIST*)" -> "release_table_share(TABLE_SHARE*)"
"auto_repair_table(THD*,TABLE_LIST*)" -> "get_table_def_key(const TABLE_LIST*,const char**)"
"auto_repair_table(THD*,TABLE_LIST*)" -> "closefrm(TABLE*,bool)"
"auto_repair_table(THD*,TABLE_LIST*)" -> "inline_mysql_mutex_lock(mysql_mutex_t*)"
"auto_repair_table(THD*,TABLE_LIST*)" -> "my_calc_hash(const HASH*,const uchar*,size_t)"
"auto_repair_table(THD*,TABLE_LIST*)" -> "handler::ha_check_and_repair(THD*)"
"auto_repair_table(THD*,TABLE_LIST*)" -> "sql_print_error(const char*,...)"
"auto_repair_table(THD*,TABLE_LIST*)" -> "Table_cache_manager::unlock_all_and_tdc()"
"auto_repair_table(THD*,TABLE_LIST*)" -> "tdc_remove_table(THD*,enum_tdc_remove_table_type,const char*,const char*,bool)"
"auto_repair_table(THD*,TABLE_LIST*)" -> "Table_cache_manager::lock_all_and_tdc()"
"handler::ha_check_and_repair(THD*)" -> "handler::mark_trx_read_write()"
"open_and_process_table(THD*,LEX*,TABLE_LIST*,uint*,uint,Prelocking_strategy*,bool,Open_table_context*)" -> "open_temporary_table(THD*,TABLE_LIST*)"
"open_and_process_table(THD*,LEX*,TABLE_LIST*,uint*,uint,Prelocking_strategy*,bool,Open_table_context*)" -> "Query_tables_list::requires_prelocking()"
"open_and_process_table(THD*,LEX*,TABLE_LIST*,uint*,uint,Prelocking_strategy*,bool,Open_table_context*)" -> "Repair_mrg_table_error_handler::Repair_mrg_table_error_handler()"
"open_and_process_table(THD*,LEX*,TABLE_LIST*,uint*,uint,Prelocking_strategy*,bool,Open_table_context*)" -> "mysql_schema_table(THD*,LEX*,TABLE_LIST*)"
"open_and_process_table(THD*,LEX*,TABLE_LIST*,uint*,uint,Prelocking_strategy*,bool,Open_table_context*)" -> "THD::push_internal_handler(Internal_error_handler*)"
"open_and_process_table(THD*,LEX*,TABLE_LIST*,uint*,uint,Prelocking_strategy*,bool,Open_table_context*)" -> "check_and_update_table_version(THD*,TABLE_LIST*,TABLE_SHARE*)"
"open_and_process_table(THD*,LEX*,TABLE_LIST*,uint*,uint,Prelocking_strategy*,bool,Open_table_context*)" -> "Repair_mrg_table_error_handler::safely_trapped_errors()"
"open_and_process_table(THD*,LEX*,TABLE_LIST*,uint*,uint,Prelocking_strategy*,bool,Open_table_context*)" -> "Query_tables_list::mark_as_requiring_prelocking(TABLE_LIST**)"
"open_and_process_table(THD*,LEX*,TABLE_LIST*,uint*,uint,Prelocking_strategy*,bool,Open_table_context*)" -> "Open_table_context::can_recover_from_failed_open() const"
"open_and_process_table(THD*,LEX*,TABLE_LIST*,uint*,uint,Prelocking_strategy*,bool,Open_table_context*)" -> "my_hash_free(HASH*)"
"open_and_process_table(THD*,LEX*,TABLE_LIST*,uint*,uint,Prelocking_strategy*,bool,Open_table_context*)" -> "open_table_get_mdl_lock(THD*,Open_table_context*,MDL_request*,uint,MDL_ticket**)"
"open_and_process_table(THD*,LEX*,TABLE_LIST*,uint*,uint,Prelocking_strategy*,bool,Open_table_context*)" -> "No_such_table_error_handler::safely_trapped_errors()"
"open_and_process_table(THD*,LEX*,TABLE_LIST*,uint*,uint,Prelocking_strategy*,bool,Open_table_context*)" -> "open_table(THD*,TABLE_LIST*,Open_table_context*)"
"open_and_process_table(THD*,LEX*,TABLE_LIST*,uint*,uint,Prelocking_strategy*,bool,Open_table_context*)" -> "THD::pop_internal_handler()"
"open_and_process_table(THD*,LEX*,TABLE_LIST*,uint*,uint,Prelocking_strategy*,bool,Open_table_context*)" -> "No_such_table_error_handler::No_such_table_error_handler()"
"open_temporary_table(THD*,TABLE_LIST*)" -> "my_error(int,myf,...)"
"open_temporary_table(THD*,TABLE_LIST*)" -> "find_temporary_table(THD*,const TABLE_LIST*)"
"open_temporary_table(THD*,TABLE_LIST*)" -> "TABLE::init(THD*,TABLE_LIST*)"
"find_temporary_table(THD*,const TABLE_LIST*)" -> "get_table_def_key(const TABLE_LIST*,const char**)"
"find_temporary_table(THD*,const TABLE_LIST*)" -> "memcmp(const void*,const void*,size_t)"
"Repair_mrg_table_error_handler::Repair_mrg_table_error_handler()" -> "Internal_error_handler::Internal_error_handler()"
"mysql_schema_table(THD*,LEX*,TABLE_LIST*)" -> "List_iterator_fast<T>::List_iterator_fast(List<T>&) [with T = Item]"
"mysql_schema_table(THD*,LEX*,TABLE_LIST*)" -> "Simple_cstring::ptr() const"
"mysql_schema_table(THD*,LEX*,TABLE_LIST*)" -> "Query_arena::alloc(size_t)"
"mysql_schema_table(THD*,LEX*,TABLE_LIST*)" -> "List_iterator_fast<T>::operator++(int) [with T = Item]"
"No_such_table_error_handler::No_such_table_error_handler()" -> "Internal_error_handler::Internal_error_handler()"
"open_tables_check_upgradable_mdl(THD*,TABLE_LIST*,TABLE_LIST*,uint)" -> "find_table_for_mdl_upgrade(THD*,const char*,const char*,bool)"
"open_tables_check_upgradable_mdl(THD*,TABLE_LIST*,TABLE_LIST*,uint)" -> "is_temporary_table(TABLE_LIST*)"
"open_temporary_tables(THD*,TABLE_LIST*)" -> "Query_tables_list::first_not_own_table()"
"open_temporary_tables(THD*,TABLE_LIST*)" -> "open_temporary_table(THD*,TABLE_LIST*)"
"open_and_process_routine(THD*,Query_tables_list*,Sroutine_hash_entry*,Prelocking_strategy*,bool,Open_table_context*,bool*,bool*)" -> "sp_head::modifies_data() const"
"open_and_process_routine(THD*,Query_tables_list*,Sroutine_hash_entry*,Prelocking_strategy*,bool,Open_table_context*,bool*,bool*)" -> "check_and_update_routine_version(THD*,Sroutine_hash_entry*,sp_head*)"
"open_and_process_routine(THD*,Query_tables_list*,Sroutine_hash_entry*,Prelocking_strategy*,bool,Open_table_context*,bool*,bool*)" -> "THD::push_internal_handler(Internal_error_handler*)"
"open_and_process_routine(THD*,Query_tables_list*,Sroutine_hash_entry*,Prelocking_strategy*,bool,Open_table_context*,bool*,bool*)" -> "MDL_context::acquire_lock(MDL_request*,ulong)"
"open_and_process_routine(THD*,Query_tables_list*,Sroutine_hash_entry*,Prelocking_strategy*,bool,Open_table_context*,bool*,bool*)" -> "sp_cache_routine(THD*,Sroutine_hash_entry*,bool,sp_head**)"
"open_and_process_routine(THD*,Query_tables_list*,Sroutine_hash_entry*,Prelocking_strategy*,bool,Open_table_context*,bool*,bool*)" -> "MDL_key::mdl_namespace() const"
"open_and_process_routine(THD*,Query_tables_list*,Sroutine_hash_entry*,Prelocking_strategy*,bool,Open_table_context*,bool*,bool*)" -> "MDL_deadlock_handler::MDL_deadlock_handler(Open_table_context*)"
"open_and_process_routine(THD*,Query_tables_list*,Sroutine_hash_entry*,Prelocking_strategy*,bool,Open_table_context*,bool*,bool*)" -> "THD::pop_internal_handler()"
"open_and_process_routine(THD*,Query_tables_list*,Sroutine_hash_entry*,Prelocking_strategy*,bool,Open_table_context*,bool*,bool*)" -> "Open_table_context::get_timeout() const"
"check_and_update_routine_version(THD*,Sroutine_hash_entry*,sp_head*)" -> "sp_cache_version()"
"check_and_update_routine_version(THD*,Sroutine_hash_entry*,sp_head*)" -> "sp_head::sp_cache_version() const"
"check_and_update_routine_version(THD*,Sroutine_hash_entry*,sp_head*)" -> "Open_tables_state::get_reprepare_observer() const"
"check_and_update_routine_version(THD*,Sroutine_hash_entry*,sp_head*)" -> "sp_head::is_invoked() const"
"check_and_update_routine_version(THD*,Sroutine_hash_entry*,sp_head*)" -> "Reprepare_observer::report_error(THD*)"
"sp_cache_routine(THD*,Sroutine_hash_entry*,bool,sp_head**)" -> "MDL_key::mdl_namespace() const"
"sp_cache_routine(THD*,Sroutine_hash_entry*,bool,sp_head**)" -> "sp_name::sp_name(const MDL_key*,char*)"
"sp_cache_routine(THD*,Sroutine_hash_entry*,bool,sp_head**)" -> "sp_cache_routine(THD*,enum_sp_type,sp_name*,bool,sp_head**)"
"sp_name::sp_name(const MDL_key*,char*)" -> "MDL_key::db_name_length() const"
"sp_name::sp_name(const MDL_key*,char*)" -> "Sql_alloc::Sql_alloc()"
"sp_name::sp_name(const MDL_key*,char*)" -> "__builtin_strcpy(char*,const char*)"
"sp_name::sp_name(const MDL_key*,char*)" -> "MDL_key::db_name() const"
"sp_name::sp_name(const MDL_key*,char*)" -> "strxmov(char*,const char*,...)"
"sp_name::sp_name(const MDL_key*,char*)" -> "MDL_key::name() const"
"sp_name::sp_name(const MDL_key*,char*)" -> "MDL_key::name_length() const"
"sp_cache_routine(THD*,enum_sp_type,sp_name*,bool,sp_head**)" -> "my_error(int,myf,...)"
"sp_cache_routine(THD*,enum_sp_type,sp_name*,bool,sp_head**)" -> "THD::is_error() const"
"sp_cache_routine(THD*,enum_sp_type,sp_name*,bool,sp_head**)" -> "sp_cache_flush_obsolete(sp_cache**,sp_head**)"
"sp_cache_routine(THD*,enum_sp_type,sp_name*,bool,sp_head**)" -> "db_find_routine(THD*,enum_sp_type,sp_name*,sp_head**)"
"sp_cache_routine(THD*,enum_sp_type,sp_name*,bool,sp_head**)" -> "THD::clear_error()"
"sp_cache_routine(THD*,enum_sp_type,sp_name*,bool,sp_head**)" -> "memcpy(void*,const void*,size_t)"
"sp_cache_routine(THD*,enum_sp_type,sp_name*,bool,sp_head**)" -> "sp_cache_insert(sp_cache**,sp_head*)"
"sp_cache_routine(THD*,enum_sp_type,sp_name*,bool,sp_head**)" -> "sp_cache_lookup(sp_cache**,sp_name*)"
"sp_cache_flush_obsolete(sp_cache**,sp_head**)" -> "sp_head::is_invoked() const"
"sp_cache_flush_obsolete(sp_cache**,sp_head**)" -> "sp_head::sp_cache_version() const"
"sp_cache_flush_obsolete(sp_cache**,sp_head**)" -> "sp_cache::remove(sp_head*)"
"sp_cache::remove(sp_head*)" -> "my_hash_delete(HASH*,uchar*)"
"db_find_routine(THD*,enum_sp_type,sp_name*,sp_head**)" -> "Query_arena::strmake(const char*,size_t)"
"db_find_routine(THD*,enum_sp_type,sp_name*,sp_head**)" -> "Stored_routine_creation_ctx::load_from_db(THD*,const sp_name*,TABLE*)"
"db_find_routine(THD*,enum_sp_type,sp_name*,sp_head**)" -> "String::String(char*,uint32,const CHARSET_INFO*)"
"db_find_routine(THD*,enum_sp_type,sp_name*,sp_head**)" -> "String::length() const"
"db_find_routine(THD*,enum_sp_type,sp_name*,sp_head**)" -> "memset(void*,int,size_t)"
"db_find_routine(THD*,enum_sp_type,sp_name*,sp_head**)" -> "close_system_tables(THD*,Open_tables_backup*)"
"db_find_routine(THD*,enum_sp_type,sp_name*,sp_head**)" -> "String::ptr() const"
"db_find_routine(THD*,enum_sp_type,sp_name*,sp_head**)" -> "get_field(MEM_ROOT*,Field*)"
"db_find_routine(THD*,enum_sp_type,sp_name*,sp_head**)" -> "db_find_routine_aux(THD*,enum_sp_type,sp_name*,TABLE*)"
"db_find_routine(THD*,enum_sp_type,sp_name*,sp_head**)" -> "open_proc_table_for_read(THD*,Open_tables_backup*)"
"db_find_routine(THD*,enum_sp_type,sp_name*,sp_head**)" -> "Open_tables_backup::Open_tables_backup()"
"db_find_routine(THD*,enum_sp_type,sp_name*,sp_head**)" -> "db_load_routine(THD*,enum_sp_type,sp_name*,sp_head**,sql_mode_t,const char*,const char*,const char*,st_sp_chistics&,const char*,longlong,longlong,Stored_program_creation_ctx*)"
"Stored_routine_creation_ctx::load_from_db(THD*,const sp_name*,TABLE*)" -> "sql_print_warning(const char*,...)"
"Stored_routine_creation_ctx::load_from_db(THD*,const sp_name*,TABLE*)" -> "get_default_db_collation(THD*,const char*)"
"Stored_routine_creation_ctx::load_from_db(THD*,const sp_name*,TABLE*)" -> "load_collation(MEM_ROOT*,Field*,const CHARSET_INFO*,const CHARSET_INFO**)"
"Stored_routine_creation_ctx::load_from_db(THD*,const sp_name*,TABLE*)" -> "_current_thd()"
"Stored_routine_creation_ctx::load_from_db(THD*,const sp_name*,TABLE*)" -> "Query_arena::strmake(const char*,size_t)"
"Stored_routine_creation_ctx::load_from_db(THD*,const sp_name*,TABLE*)" -> "push_warning_printf(THD*,Sql_condition::enum_warning_level,uint,const char*,...)"
"Stored_routine_creation_ctx::load_from_db(THD*,const sp_name*,TABLE*)" -> "Stored_routine_creation_ctx::Stored_routine_creation_ctx(const CHARSET_INFO*,const CHARSET_INFO*,const CHARSET_INFO*)"
"Stored_routine_creation_ctx::load_from_db(THD*,const sp_name*,TABLE*)" -> "load_charset(MEM_ROOT*,Field*,const CHARSET_INFO*,const CHARSET_INFO**)"
"load_collation(MEM_ROOT*,Field*,const CHARSET_INFO*,const CHARSET_INFO**)" -> "get_charset_by_name(const char*,myf)"
"load_collation(MEM_ROOT*,Field*,const CHARSET_INFO*,const CHARSET_INFO**)" -> "String::c_ptr()"
"load_collation(MEM_ROOT*,Field*,const CHARSET_INFO*,const CHARSET_INFO**)" -> "get_field(MEM_ROOT*,Field*,String*)"
"load_collation(MEM_ROOT*,Field*,const CHARSET_INFO*,const CHARSET_INFO**)" -> "String::String()"
"get_field(MEM_ROOT*,Field*,String*)" -> "String::String(char*,uint32,const CHARSET_INFO*)"
"get_field(MEM_ROOT*,Field*,String*)" -> "Field::val_str(String*)"
"get_field(MEM_ROOT*,Field*,String*)" -> "String::length() const"
"get_field(MEM_ROOT*,Field*,String*)" -> "String::set(char*,uint32,const CHARSET_INFO*)"
"get_field(MEM_ROOT*,Field*,String*)" -> "String::ptr() const"
"get_field(MEM_ROOT*,Field*,String*)" -> "strmake_root(MEM_ROOT*,const char*,size_t)"
"get_field(MEM_ROOT*,Field*,String*)" -> "String::length(uint32)"
"Stored_routine_creation_ctx::Stored_routine_creation_ctx(const CHARSET_INFO*,const CHARSET_INFO*,const CHARSET_INFO*)" -> "Sql_alloc::Sql_alloc()"
"Stored_routine_creation_ctx::Stored_routine_creation_ctx(const CHARSET_INFO*,const CHARSET_INFO*,const CHARSET_INFO*)" -> "Stored_program_creation_ctx::Stored_program_creation_ctx(const CHARSET_INFO*,const CHARSET_INFO*,const CHARSET_INFO*)"
"load_charset(MEM_ROOT*,Field*,const CHARSET_INFO*,const CHARSET_INFO**)" -> "String::String()"
"load_charset(MEM_ROOT*,Field*,const CHARSET_INFO*,const CHARSET_INFO**)" -> "get_charset_by_csname(const char*,uint,myf)"
"load_charset(MEM_ROOT*,Field*,const CHARSET_INFO*,const CHARSET_INFO**)" -> "get_field(MEM_ROOT*,Field*,String*)"
"load_charset(MEM_ROOT*,Field*,const CHARSET_INFO*,const CHARSET_INFO**)" -> "String::c_ptr()"
"close_system_tables(THD*,Open_tables_backup*)" -> "LEX::restore_backup_query_tables_list(Query_tables_list*)"
"close_system_tables(THD*,Open_tables_backup*)" -> "THD::restore_backup_open_tables_state(Open_tables_backup*)"
"close_system_tables(THD*,Open_tables_backup*)" -> "LEX::reset_n_backup_query_tables_list(Query_tables_list*)"
"close_system_tables(THD*,Open_tables_backup*)" -> "Query_tables_list::Query_tables_list()"
"close_system_tables(THD*,Open_tables_backup*)" -> "close_thread_tables(THD*)"
"LEX::restore_backup_query_tables_list(Query_tables_list*)" -> "Query_tables_list::destroy_query_tables_list()"
"LEX::restore_backup_query_tables_list(Query_tables_list*)" -> "Query_tables_list::set_query_tables_list(Query_tables_list*)"
"Query_tables_list::destroy_query_tables_list()" -> "my_hash_free(HASH*)"
"Query_tables_list::set_query_tables_list(Query_tables_list*)" -> "__builtin_memcpy(void*,const void*,long unsigned int)"
"THD::restore_backup_open_tables_state(Open_tables_backup*)" -> "MDL_context::rollback_to_savepoint(const MDL_savepoint&)"
"THD::restore_backup_open_tables_state(Open_tables_backup*)" -> "Open_tables_state::set_open_tables_state(Open_tables_state*)"
"Open_tables_state::set_open_tables_state(Open_tables_state*)" -> "Open_tables_state::push_reprepare_observer(Reprepare_observer*)"
"Open_tables_state::set_open_tables_state(Open_tables_state*)" -> "Dynamic_array<Elem>::elements() const [with Elem = Reprepare_observer*]"
"Open_tables_state::set_open_tables_state(Open_tables_state*)" -> "Open_tables_state::reset_reprepare_observers()"
"Open_tables_state::set_open_tables_state(Open_tables_state*)" -> "Dynamic_array<Elem>::at(int) [with Elem = Reprepare_observer*]"
"Open_tables_state::push_reprepare_observer(Reprepare_observer*)" -> "Dynamic_array<Elem>::append(const Elem&) [with Elem = Reprepare_observer*]"
"Dynamic_array<Elem>::append(const Elem&) [with Elem = Reprepare_observer*]" -> "insert_dynamic(DYNAMIC_ARRAY*,const void*)"
"LEX::reset_n_backup_query_tables_list(Query_tables_list*)" -> "Query_tables_list::reset_query_tables_list(bool)"
"LEX::reset_n_backup_query_tables_list(Query_tables_list*)" -> "Query_tables_list::set_query_tables_list(Query_tables_list*)"
"get_field(MEM_ROOT*,Field*)" -> "Field::val_str(String*)"
"get_field(MEM_ROOT*,Field*)" -> "alloc_root(MEM_ROOT*,size_t)"
"get_field(MEM_ROOT*,Field*)" -> "String::length() const"
"get_field(MEM_ROOT*,Field*)" -> "memcpy(void*,const void*,size_t)"
"get_field(MEM_ROOT*,Field*)" -> "String::String(char*,uint32,const CHARSET_INFO*)"
"get_field(MEM_ROOT*,Field*)" -> "String::ptr() const"
"db_find_routine_aux(THD*,enum_sp_type,sp_name*,TABLE*)" -> "handler::ha_index_read_idx_map(uchar*,uint,const uchar*,key_part_map,ha_rkey_function)"
"db_find_routine_aux(THD*,enum_sp_type,sp_name*,TABLE*)" -> "key_copy(uchar*,uchar*,KEY*,uint)"
"ha_innobase::index_read(uchar*,const uchar*,uint,ha_rkey_function)" -> "abort()"
"ha_innobase::index_read(uchar*,const uchar*,uint,ha_rkey_function)" -> "convert_error_code_to_mysql(dberr_t,ulint,THD*)"
"ha_innobase::index_read(uchar*,const uchar*,uint,ha_rkey_function)" -> "row_search_for_mysql(unsigned char*,ulint,row_prebuilt_t*,ulint,ulint)"
"ha_innobase::index_read(uchar*,const uchar*,uint,ha_rkey_function)" -> "thd_to_trx(THD*)"
"ha_innobase::index_read(uchar*,const uchar*,uint,ha_rkey_function)" -> "handler::ha_statistic_increment(ulonglong system_status_var::*) const"
"ha_innobase::index_read(uchar*,const uchar*,uint,ha_rkey_function)" -> "ha_innobase::build_template(bool)"
"ha_innobase::index_read(uchar*,const uchar*,uint,ha_rkey_function)" -> "innobase_srv_conc_enter_innodb(trx_t*)"
"ha_innobase::index_read(uchar*,const uchar*,uint,ha_rkey_function)" -> "row_sel_convert_mysql_key_to_innobase(dtuple_t*,unsigned char*,ulint,dict_index_t*,const unsigned char*,ulint,trx_t*)"
"ha_innobase::index_read(uchar*,const uchar*,uint,ha_rkey_function)" -> "Indexer>::add(size_t,Type) [with Type = long unsigned int,int N = 64,Indexer = thread_id_indexer_t,size_t = long unsigned int]"
"ha_innobase::index_read(uchar*,const uchar*,uint,ha_rkey_function)" -> "ib_senderrf(THD*,ib_log_level_t,ib_uint32_t,...)"
"ha_innobase::index_read(uchar*,const uchar*,uint,ha_rkey_function)" -> "convert_search_mode_to_innobase(ha_rkey_function)"
"ha_innobase::index_read(uchar*,const uchar*,uint,ha_rkey_function)" -> "dtuple_set_n_fields(dtuple_t*,ulint)"
"ha_innobase::index_read(uchar*,const uchar*,uint,ha_rkey_function)" -> "dict_index_is_corrupted(const dict_index_t*)"
"ha_innobase::index_read(uchar*,const uchar*,uint,ha_rkey_function)" -> "innobase_srv_conc_exit_innodb(trx_t*)"
"ha_innobase::index_read(uchar*,const uchar*,uint,ha_rkey_function)" -> "__builtin_expect(long int,long int)"
"ha_innobase::index_read(uchar*,const uchar*,uint,ha_rkey_function)" -> "ut_dbg_assertion_failed(const char*,const char*,ulint)"
"convert_error_code_to_mysql(dberr_t,ulint,THD*)" -> "thd_mark_transaction_to_rollback(THD*,bool)"
"convert_error_code_to_mysql(dberr_t,ulint,THD*)" -> "dict_tf_get_format(ulint)"
"convert_error_code_to_mysql(dberr_t,ulint,THD*)" -> "my_error(int,myf,...)"
"convert_error_code_to_mysql(dberr_t,ulint,THD*)" -> "my_printf_error(uint,const char*,myf,...)"
"convert_error_code_to_mysql(dberr_t,ulint,THD*)" -> "push_warning_printf(THD*,Sql_condition::enum_warning_level,uint,const char*,...)"
"convert_error_code_to_mysql(dberr_t,ulint,THD*)" -> "page_get_free_space_of_empty(ulint)"
"thd_mark_transaction_to_rollback(THD*,bool)" -> "mark_transaction_to_rollback(THD*,bool)"
"row_search_for_mysql(unsigned char*,ulint,row_prebuilt_t*,ulint,ulint)" -> "lock_clust_rec_cons_read_sees(const rec_t*,dict_index_t*,const ulint*,read_view_t*)"
"row_search_for_mysql(unsigned char*,ulint,row_prebuilt_t*,ulint,ulint)" -> "lock_sec_rec_cons_read_sees(const rec_t*,const read_view_t*)"
"row_search_for_mysql(unsigned char*,ulint,row_prebuilt_t*,ulint,ulint)" -> "que_thr_move_to_run_state_for_mysql(que_thr_t*,trx_t*)"
"row_search_for_mysql(unsigned char*,ulint,row_prebuilt_t*,ulint,ulint)" -> "ut_print_name(FILE*,const trx_t*,ulint,const char*)"
"row_search_for_mysql(unsigned char*,ulint,row_prebuilt_t*,ulint,ulint)" -> "rec_get_deleted_flag(const rec_t*,ulint)"
"row_search_for_mysql(unsigned char*,ulint,row_prebuilt_t*,ulint,ulint)" -> "btr_pcur_move_to_next(btr_pcur_t*,mtr_t*)"
"row_search_for_mysql(unsigned char*,ulint,row_prebuilt_t*,ulint,ulint)" -> "dtuple_contains_null(const dtuple_t*)"
"row_search_for_mysql(unsigned char*,ulint,row_prebuilt_t*,ulint,ulint)" -> "page_align(const void*)"
"row_search_for_mysql(unsigned char*,ulint,row_prebuilt_t*,ulint,ulint)" -> "btr_pcur_open_with_no_init_func(dict_index_t*,const dtuple_t*,ulint,ulint,btr_pcur_t*,ulint,const char*,ulint,mtr_t*)"
"row_search_for_mysql(unsigned char*,ulint,row_prebuilt_t*,ulint,ulint)" -> "dict_index_is_corrupted(const dict_index_t*)"
"row_search_for_mysql(unsigned char*,ulint,row_prebuilt_t*,ulint,ulint)" -> "row_sel_build_prev_vers_for_mysql(read_view_t*,dict_index_t*,row_prebuilt_t*,const rec_t*,ulint**,mem_heap_t**,rec_t**,mtr_t*)"
"row_search_for_mysql(unsigned char*,ulint,row_prebuilt_t*,ulint,ulint)" -> "row_sel_build_committed_vers_for_mysql(dict_index_t*,row_prebuilt_t*,const rec_t*,ulint**,mem_heap_t**,const rec_t**,mtr_t*)"
"row_search_for_mysql(unsigned char*,ulint,row_prebuilt_t*,ulint,ulint)" -> "trx_is_interrupted(const trx_t*)"
"row_search_for_mysql(unsigned char*,ulint,row_prebuilt_t*,ulint,ulint)" -> "putc(int,FILE*)"
"row_search_for_mysql(unsigned char*,ulint,row_prebuilt_t*,ulint,ulint)" -> "abort()"
"row_search_for_mysql(unsigned char*,ulint,row_prebuilt_t*,ulint,ulint)" -> "dict_index_is_unique(const dict_index_t*)"
"row_search_for_mysql(unsigned char*,ulint,row_prebuilt_t*,ulint,ulint)" -> "dict_index_name_print(FILE*,const trx_t*,const dict_index_t*)"
"row_search_for_mysql(unsigned char*,ulint,row_prebuilt_t*,ulint,ulint)" -> "que_thr_stop_for_mysql(que_thr_t*)"
"row_search_for_mysql(unsigned char*,ulint,row_prebuilt_t*,ulint,ulint)" -> "memcpy(void*,const void*,size_t)"
"row_search_for_mysql(unsigned char*,ulint,row_prebuilt_t*,ulint,ulint)" -> "btr_pcur_open_at_index_side(bool,dict_index_t*,ulint,btr_pcur_t*,bool,ulint,mtr_t*)"
"row_search_for_mysql(unsigned char*,ulint,row_prebuilt_t*,ulint,ulint)" -> "page_rec_is_supremum(const rec_t*)"
"row_search_for_mysql(unsigned char*,ulint,row_prebuilt_t*,ulint,ulint)" -> "cmp_dtuple_rec(const dtuple_t*,const rec_t*,const ulint*)"
"row_search_for_mysql(unsigned char*,ulint,row_prebuilt_t*,ulint,ulint)" -> "row_sel_store_row_id_to_prebuilt(row_prebuilt_t*,const rec_t*,const dict_index_t*,const ulint*)"
"row_search_for_mysql(unsigned char*,ulint,row_prebuilt_t*,ulint,ulint)" -> "lock_trx_handle_wait(trx_t*)"
"row_search_for_mysql(unsigned char*,ulint,row_prebuilt_t*,ulint,ulint)" -> "btr_index_rec_validate(const rec_t*,const dict_index_t*,ulint)"
"row_search_for_mysql(unsigned char*,ulint,row_prebuilt_t*,ulint,ulint)" -> "btr_pcur_move_to_prev(btr_pcur_t*,mtr_t*)"
"row_search_for_mysql(unsigned char*,ulint,row_prebuilt_t*,ulint,ulint)" -> "rec_validate(const rec_t*,const ulint*)"
"row_search_for_mysql(unsigned char*,ulint,row_prebuilt_t*,ulint,ulint)" -> "row_mysql_handle_errors(dberr_t*,trx_t*,que_thr_t*,trx_savept_t*)"
"row_search_for_mysql(unsigned char*,ulint,row_prebuilt_t*,ulint,ulint)" -> "trx_print(FILE*,const trx_t*,ulint)"
"row_search_for_mysql(unsigned char*,ulint,row_prebuilt_t*,ulint,ulint)" -> "pfs_rw_lock_s_lock_func(rw_lock_t*,ulint,const char*,ulint)"
"row_search_for_mysql(unsigned char*,ulint,row_prebuilt_t*,ulint,ulint)" -> "pfs_rw_lock_s_unlock_func(rw_lock_t*)"
"row_search_for_mysql(unsigned char*,ulint,row_prebuilt_t*,ulint,ulint)" -> "__builtin_fwrite(const void*,size_t,size_t,FILE*)"
"row_search_for_mysql(unsigned char*,ulint,row_prebuilt_t*,ulint,ulint)" -> "sel_restore_position_for_mysql(ulint*,ulint,btr_pcur_t*,ulint,mtr_t*)"
"row_search_for_mysql(unsigned char*,ulint,row_prebuilt_t*,ulint,ulint)" -> "row_search_idx_cond_check(unsigned char*,row_prebuilt_t*,const rec_t*,const ulint*)"
"row_search_for_mysql(unsigned char*,ulint,row_prebuilt_t*,ulint,ulint)" -> "page_rec_get_next_const(const rec_t*)"
"row_search_for_mysql(unsigned char*,ulint,row_prebuilt_t*,ulint,ulint)" -> "rec_offs_set_n_alloc(ulint*,ulint)"
"row_search_for_mysql(unsigned char*,ulint,row_prebuilt_t*,ulint,ulint)" -> "mem_heap_free_func(mem_heap_t*,const char*,ulint)"
"row_search_for_mysql(unsigned char*,ulint,row_prebuilt_t*,ulint,ulint)" -> "mtr_commit(mtr_t*)"
"row_search_for_mysql(unsigned char*,ulint,row_prebuilt_t*,ulint,ulint)" -> "trx_start_if_not_started_low(trx_t*)"
"row_search_for_mysql(unsigned char*,ulint,row_prebuilt_t*,ulint,ulint)" -> "page_rec_is_infimum(const rec_t*)"
"row_search_for_mysql(unsigned char*,ulint,row_prebuilt_t*,ulint,ulint)" -> "lock_table(ulint,dict_table_t*,lock_mode,que_thr_t*)"
"row_search_for_mysql(unsigned char*,ulint,row_prebuilt_t*,ulint,ulint)" -> "fputc(int,FILE*)"
"row_search_for_mysql(unsigned char*,ulint,row_prebuilt_t*,ulint,ulint)" -> "que_thr_stop_for_mysql_no_error(que_thr_t*,trx_t*)"
"row_search_for_mysql(unsigned char*,ulint,row_prebuilt_t*,ulint,ulint)" -> "page_get_page_no(const ib_page_t*)"
"row_search_for_mysql(unsigned char*,ulint,row_prebuilt_t*,ulint,ulint)" -> "mtr_start(mtr_t*)"
"row_search_for_mysql(unsigned char*,ulint,row_prebuilt_t*,ulint,ulint)" -> "row_sel_fetch_last_buf(row_prebuilt_t*)"
"row_search_for_mysql(unsigned char*,ulint,row_prebuilt_t*,ulint,ulint)" -> "btr_pcur_store_position(btr_pcur_t*,mtr_t*)"
"row_search_for_mysql(unsigned char*,ulint,row_prebuilt_t*,ulint,ulint)" -> "dict_table_is_discarded(const dict_table_t*)"
"row_search_for_mysql(unsigned char*,ulint,row_prebuilt_t*,ulint,ulint)" -> "rec_offs_size(const ulint*)"
"row_search_for_mysql(unsigned char*,ulint,row_prebuilt_t*,ulint,ulint)" -> "rw_lock_get_writer(const rw_lock_t*)"
"row_search_for_mysql(unsigned char*,ulint,row_prebuilt_t*,ulint,ulint)" -> "__builtin_expect(long int,long int)"
"row_search_for_mysql(unsigned char*,ulint,row_prebuilt_t*,ulint,ulint)" -> "mem_analyze_corruption(void*)"
"row_search_for_mysql(unsigned char*,ulint,row_prebuilt_t*,ulint,ulint)" -> "dtuple_get_n_fields_cmp(const dtuple_t*)"
"row_search_for_mysql(unsigned char*,ulint,row_prebuilt_t*,ulint,ulint)" -> "fprintf(FILE*,const char*,...)"
"row_search_for_mysql(unsigned char*,ulint,row_prebuilt_t*,ulint,ulint)" -> "row_sel_store_mysql_rec(unsigned char*,row_prebuilt_t*,const rec_t*,ulint,const dict_index_t*,const ulint*)"
"row_search_for_mysql(unsigned char*,ulint,row_prebuilt_t*,ulint,ulint)" -> "rec_offs_extra_size(const ulint*)"
"row_search_for_mysql(unsigned char*,ulint,row_prebuilt_t*,ulint,ulint)" -> "dtuple_get_n_fields(const dtuple_t*)"
"row_search_for_mysql(unsigned char*,ulint,row_prebuilt_t*,ulint,ulint)" -> "rec_get_offsets_func(const rec_t*,const dict_index_t*,ulint*,ulint,mem_heap_t**)"
"row_search_for_mysql(unsigned char*,ulint,row_prebuilt_t*,ulint,ulint)" -> "row_sel_dequeue_cached_row_for_mysql(unsigned char*,row_prebuilt_t*)"
"row_search_for_mysql(unsigned char*,ulint,row_prebuilt_t*,ulint,ulint)" -> "thd_is_select(const THD*)"
"row_search_for_mysql(unsigned char*,ulint,row_prebuilt_t*,ulint,ulint)" -> "ut_print_timestamp(FILE*)"
"row_search_for_mysql(unsigned char*,ulint,row_prebuilt_t*,ulint,ulint)" -> "row_sel_try_search_shortcut_for_mysql(const rec_t**,row_prebuilt_t*,ulint**,mem_heap_t**,mtr_t*)"
"row_search_for_mysql(unsigned char*,ulint,row_prebuilt_t*,ulint,ulint)" -> "rec_get_next_offs(const rec_t*,ulint)"
"row_search_for_mysql(unsigned char*,ulint,row_prebuilt_t*,ulint,ulint)" -> "dict_index_get_n_unique(const dict_index_t*)"
"row_search_for_mysql(unsigned char*,ulint,row_prebuilt_t*,ulint,ulint)" -> "ut_dbg_assertion_failed(const char*,const char*,ulint)"
"row_search_for_mysql(unsigned char*,ulint,row_prebuilt_t*,ulint,ulint)" -> "row_sel_get_clust_rec_for_mysql(row_prebuilt_t*,dict_index_t*,const rec_t*,que_thr_t*,const rec_t**,ulint**,mem_heap_t**,mtr_t*)"
"row_search_for_mysql(unsigned char*,ulint,row_prebuilt_t*,ulint,ulint)" -> "page_offset(const void*)"
"row_search_for_mysql(unsigned char*,ulint,row_prebuilt_t*,ulint,ulint)" -> "buf_page_print(const unsigned char*,ulint,ulint)"
"row_search_for_mysql(unsigned char*,ulint,row_prebuilt_t*,ulint,ulint)" -> "row_unlock_for_mysql(row_prebuilt_t*,ulint)"
"row_search_for_mysql(unsigned char*,ulint,row_prebuilt_t*,ulint,ulint)" -> "dict_index_is_clust(const dict_index_t*)"
"row_search_for_mysql(unsigned char*,ulint,row_prebuilt_t*,ulint,ulint)" -> "btr_pcur_move_to_last_on_page(btr_pcur_t*,mtr_t*)"
"row_search_for_mysql(unsigned char*,ulint,row_prebuilt_t*,ulint,ulint)" -> "row_prebuild_sel_graph(row_prebuilt_t*)"
"row_search_for_mysql(unsigned char*,ulint,row_prebuilt_t*,ulint,ulint)" -> "cmp_dtuple_is_prefix_of_rec(const dtuple_t*,const rec_t*,const ulint*)"
"row_search_for_mysql(unsigned char*,ulint,row_prebuilt_t*,ulint,ulint)" -> "que_fork_get_first_thr(que_fork_t*)"
"row_search_for_mysql(unsigned char*,ulint,row_prebuilt_t*,ulint,ulint)" -> "mach_write_to_4(unsigned char*,ulint)"
"row_search_for_mysql(unsigned char*,ulint,row_prebuilt_t*,ulint,ulint)" -> "trx_assign_read_view(trx_t*)"
"row_search_for_mysql(unsigned char*,ulint,row_prebuilt_t*,ulint,ulint)" -> "sel_set_rec_lock(const buf_block_t*,const rec_t*,dict_index_t*,const ulint*,ulint,ulint,que_thr_t*)"
"row_search_for_mysql(unsigned char*,ulint,row_prebuilt_t*,ulint,ulint)" -> "row_sel_enqueue_cache_row_for_mysql(unsigned char*,row_prebuilt_t*)"
"row_search_for_mysql(unsigned char*,ulint,row_prebuilt_t*,ulint,ulint)" -> "dict_table_is_comp(const dict_table_t*)"
"lock_clust_rec_cons_read_sees(const rec_t*,dict_index_t*,const ulint*,read_view_t*)" -> "read_view_sees_trx_id(const read_view_t*,trx_id_t)"
"lock_clust_rec_cons_read_sees(const rec_t*,dict_index_t*,const ulint*,read_view_t*)" -> "row_get_rec_trx_id(const rec_t*,const dict_index_t*,const ulint*)"
"read_view_sees_trx_id(const read_view_t*,trx_id_t)" -> "abort()"
"read_view_sees_trx_id(const read_view_t*,trx_id_t)" -> "__builtin_expect(long int,long int)"
"read_view_sees_trx_id(const read_view_t*,trx_id_t)" -> "ut_dbg_assertion_failed(const char*,const char*,ulint)"
"ut_dbg_assertion_failed(const char*,const char*,ulint)" -> "os_thread_pf(os_thread_id_t)"
"ut_dbg_assertion_failed(const char*,const char*,ulint)" -> "__builtin_fwrite(const void*,size_t,size_t,FILE*)"
"ut_dbg_assertion_failed(const char*,const char*,ulint)" -> "innobase_basename(const char*)"
"ut_dbg_assertion_failed(const char*,const char*,ulint)" -> "os_thread_get_curr_id()"
"ut_dbg_assertion_failed(const char*,const char*,ulint)" -> "fprintf(FILE*,const char*,...)"
"ut_dbg_assertion_failed(const char*,const char*,ulint)" -> "ut_print_timestamp(FILE*)"
"innobase_basename(const char*)" -> "dirname_length(const char*)"
"os_thread_get_curr_id()" -> "pthread_self()"
"ut_print_timestamp(FILE*)" -> "fprintf(FILE*,const char*,...)"
"ut_print_timestamp(FILE*)" -> "localtime_r(const time_t*,tm*)"
"ut_print_timestamp(FILE*)" -> "time(time_t*)"
"row_get_rec_trx_id(const rec_t*,const dict_index_t*,const ulint*)" -> "trx_read_trx_id(const unsigned char*)"
"row_get_rec_trx_id(const rec_t*,const dict_index_t*,const ulint*)" -> "row_get_trx_id_offset(const dict_index_t*,const ulint*)"
"trx_read_trx_id(const unsigned char*)" -> "mach_read_from_6(const unsigned char*)"
"mach_read_from_6(const unsigned char*)" -> "ut_ull_create(ulint,ulint)"
"mach_read_from_6(const unsigned char*)" -> "mach_read_from_2(const unsigned char*)"
"mach_read_from_6(const unsigned char*)" -> "mach_read_from_4(const unsigned char*)"
"mach_read_from_4(const unsigned char*)" -> "__assert_fail(const char*,const char*,unsigned int,const char*)"
"row_get_trx_id_offset(const dict_index_t*,const ulint*)" -> "dict_index_get_sys_col_pos(const dict_index_t*,ulint)"
"row_get_trx_id_offset(const dict_index_t*,const ulint*)" -> "rec_get_nth_field_offs(const ulint*,ulint,ulint*)"
"dict_index_get_sys_col_pos(const dict_index_t*,ulint)" -> "dict_index_is_clust(const dict_index_t*)"
"dict_index_get_sys_col_pos(const dict_index_t*,ulint)" -> "dict_col_get_clust_pos(const dict_col_t*,const dict_index_t*)"
"dict_index_get_sys_col_pos(const dict_index_t*,ulint)" -> "dict_index_get_nth_col_pos(const dict_index_t*,ulint)"
"dict_index_get_sys_col_pos(const dict_index_t*,ulint)" -> "dict_table_get_sys_col_no(const dict_table_t*,ulint)"
"dict_index_get_nth_col_pos(const dict_index_t*,ulint)" -> "dict_index_get_nth_col_or_prefix_pos(const dict_index_t*,ulint,ulint)"
"dict_index_get_nth_col_or_prefix_pos(const dict_index_t*,ulint,ulint)" -> "dict_index_is_clust(const dict_index_t*)"
"dict_index_get_nth_col_or_prefix_pos(const dict_index_t*,ulint,ulint)" -> "dict_index_get_n_fields(const dict_index_t*)"
"dict_index_get_nth_col_or_prefix_pos(const dict_index_t*,ulint,ulint)" -> "dict_col_get_clust_pos(const dict_col_t*,const dict_index_t*)"
"lock_sec_rec_cons_read_sees(const rec_t*,const read_view_t*)" -> "recv_recovery_is_on()"
"lock_sec_rec_cons_read_sees(const rec_t*,const read_view_t*)" -> "page_align(const void*)"
"lock_sec_rec_cons_read_sees(const rec_t*,const read_view_t*)" -> "page_get_max_trx_id(const ib_page_t*)"
"page_align(const void*)" -> "ut_align_down(const void*,ulint)"
"page_get_max_trx_id(const ib_page_t*)" -> "mach_read_from_8(const unsigned char*)"
"mach_read_from_8(const unsigned char*)" -> "mach_read_from_4(const unsigned char*)"
"que_thr_move_to_run_state_for_mysql(que_thr_t*,trx_t*)" -> "mem_analyze_corruption(void*)"
"que_thr_move_to_run_state_for_mysql(que_thr_t*,trx_t*)" -> "abort()"
"que_thr_move_to_run_state_for_mysql(que_thr_t*,trx_t*)" -> "fprintf(FILE*,const char*,...)"
"que_thr_move_to_run_state_for_mysql(que_thr_t*,trx_t*)" -> "ut_dbg_assertion_failed(const char*,const char*,ulint)"
"mem_analyze_corruption(void*)" -> "__builtin_fwrite(const void*,size_t,size_t,FILE*)"
"mem_analyze_corruption(void*)" -> "fprintf(FILE*,const char*,...)"
"mem_analyze_corruption(void*)" -> "ut_print_buf(FILE*,const void*,ulint)"
"rec_get_deleted_flag(const rec_t*,ulint)" -> "rec_get_bit_field_1(const rec_t*,ulint,ulint,ulint)"
"rec_get_bit_field_1(const rec_t*,ulint,ulint,ulint)" -> "mach_read_from_1(const unsigned char*)"
"btr_pcur_move_to_next(btr_pcur_t*,mtr_t*)" -> "btr_pcur_move_to_next_on_page(btr_pcur_t*)"
"btr_pcur_move_to_next(btr_pcur_t*,mtr_t*)" -> "btr_pcur_is_after_last_on_page(const btr_pcur_t*)"
"btr_pcur_move_to_next(btr_pcur_t*,mtr_t*)" -> "btr_pcur_move_to_next_page(btr_pcur_t*,mtr_t*)"
"btr_pcur_move_to_next(btr_pcur_t*,mtr_t*)" -> "btr_pcur_is_after_last_in_tree(btr_pcur_t*,mtr_t*)"
"btr_pcur_move_to_next_on_page(btr_pcur_t*)" -> "page_cur_move_to_next(page_cur_t*)"
"page_cur_move_to_next(page_cur_t*)" -> "page_rec_get_next(rec_t*)"
"page_rec_get_next(rec_t*)" -> "page_rec_get_next_low(const rec_t*,ulint)"
"page_rec_get_next(rec_t*)" -> "page_rec_is_comp(const rec_t*)"
"page_rec_get_next_low(const rec_t*,ulint)" -> "abort()"
"page_rec_get_next_low(const rec_t*,ulint)" -> "rec_get_next_offs(const rec_t*,ulint)"
"page_rec_get_next_low(const rec_t*,ulint)" -> "fprintf(FILE*,const char*,...)"
"page_rec_get_next_low(const rec_t*,ulint)" -> "buf_page_print(const unsigned char*,ulint,ulint)"
"page_rec_get_next_low(const rec_t*,ulint)" -> "page_align(const void*)"
"page_rec_get_next_low(const rec_t*,ulint)" -> "page_get_page_no(const ib_page_t*)"
"page_rec_get_next_low(const rec_t*,ulint)" -> "page_offset(const void*)"
"page_rec_get_next_low(const rec_t*,ulint)" -> "ut_dbg_assertion_failed(const char*,const char*,ulint)"
"page_rec_get_next_low(const rec_t*,ulint)" -> "page_get_space_id(const ib_page_t*)"
"rec_get_next_offs(const rec_t*,ulint)" -> "mach_read_from_2(const unsigned char*)"
"rec_get_next_offs(const rec_t*,ulint)" -> "ut_align_offset(const void*,ulint)"
"buf_page_print(const unsigned char*,ulint,ulint)" -> "btr_page_get_index_id(const ib_page_t*)"
"buf_page_print(const unsigned char*,ulint,ulint)" -> "page_zip_calc_checksum(const void*,ulint,srv_checksum_algorithm_t)"
"buf_page_print(const unsigned char*,ulint,ulint)" -> "buf_calc_page_crc32(const unsigned char*)"
"buf_page_print(const unsigned char*,ulint,ulint)" -> "mach_read_from_8(const unsigned char*)"
"buf_page_print(const unsigned char*,ulint,ulint)" -> "fprintf(FILE*,const char*,...)"
"buf_page_print(const unsigned char*,ulint,ulint)" -> "buf_calc_page_new_checksum(const unsigned char*)"
"buf_page_print(const unsigned char*,ulint,ulint)" -> "dict_index_find_on_id_low(index_id_t)"
"buf_page_print(const unsigned char*,ulint,ulint)" -> "dict_index_name_print(FILE*,const trx_t*,const dict_index_t*)"
"buf_page_print(const unsigned char*,ulint,ulint)" -> "mach_read_from_4(const unsigned char*)"
"buf_page_print(const unsigned char*,ulint,ulint)" -> "ut_print_buf(FILE*,const void*,ulint)"
"buf_page_print(const unsigned char*,ulint,ulint)" -> "buf_checksum_algorithm_name(srv_checksum_algorithm_t)"
"buf_page_print(const unsigned char*,ulint,ulint)" -> "__builtin_fwrite(const void*,size_t,size_t,FILE*)"
"buf_page_print(const unsigned char*,ulint,ulint)" -> "fil_page_get_type(const unsigned char*)"
"buf_page_print(const unsigned char*,ulint,ulint)" -> "buf_calc_page_old_checksum(const unsigned char*)"
"buf_page_print(const unsigned char*,ulint,ulint)" -> "ut_print_timestamp(FILE*)"
"buf_page_print(const unsigned char*,ulint,ulint)" -> "mach_read_from_2(const unsigned char*)"
"btr_page_get_index_id(const ib_page_t*)" -> "mach_read_from_8(const unsigned char*)"
"page_zip_calc_checksum(const void*,ulint,srv_checksum_algorithm_t)" -> "abort()"
"page_zip_calc_checksum(const void*,ulint,srv_checksum_algorithm_t)" -> "adler32(uLong,const Bytef*,uInt)"
"page_zip_calc_checksum(const void*,ulint,srv_checksum_algorithm_t)" -> "ut_dbg_assertion_failed(const char*,const char*,ulint)"
"buf_calc_page_new_checksum(const unsigned char*)" -> "ut_fold_binary(const unsigned char*,ulint)"
"ut_fold_binary(const unsigned char*,ulint)" -> "ut_fold_ulint_pair(ulint,ulint)"
"ut_fold_binary(const unsigned char*,ulint)" -> "__assert_fail(const char*,const char*,unsigned int,const char*)"
"dict_index_find_on_id_low(index_id_t)" -> "dict_table_find_index_on_id(const dict_table_t*,index_id_t)"
"dict_index_name_print(FILE*,const trx_t*,const dict_index_t*)" -> "ut_print_name(FILE*,const trx_t*,ulint,const char*)"
"dict_index_name_print(FILE*,const trx_t*,const dict_index_t*)" -> "__builtin_fwrite(const void*,size_t,size_t,FILE*)"
"fil_page_get_type(const unsigned char*)" -> "mach_read_from_2(const unsigned char*)"
"buf_calc_page_old_checksum(const unsigned char*)" -> "ut_fold_binary(const unsigned char*,ulint)"
"page_get_page_no(const ib_page_t*)" -> "mach_read_from_4(const unsigned char*)"
"page_offset(const void*)" -> "ut_align_offset(const void*,ulint)"
"page_get_space_id(const ib_page_t*)" -> "mach_read_from_4(const unsigned char*)"
"page_rec_is_comp(const rec_t*)" -> "page_align(const void*)"
"page_rec_is_comp(const rec_t*)" -> "page_is_comp(const ib_page_t*)"
"page_is_comp(const ib_page_t*)" -> "page_header_get_field(const ib_page_t*,ulint)"
"page_header_get_field(const ib_page_t*,ulint)" -> "mach_read_from_2(const unsigned char*)"
"btr_pcur_is_after_last_on_page(const btr_pcur_t*)" -> "page_cur_is_after_last(const page_cur_t*)"
"page_cur_is_after_last(const page_cur_t*)" -> "page_rec_is_supremum(const rec_t*)"
"page_rec_is_supremum(const rec_t*)" -> "page_offset(const void*)"
"page_rec_is_supremum(const rec_t*)" -> "page_rec_is_supremum_low(ulint)"
"btr_pcur_move_to_next_page(btr_pcur_t*,mtr_t*)" -> "buf_block_get_zip_size(const buf_block_t*)"
"btr_pcur_move_to_next_page(btr_pcur_t*,mtr_t*)" -> "btr_leaf_page_release(buf_block_t*,ulint,mtr_t*)"
"btr_pcur_move_to_next_page(btr_pcur_t*,mtr_t*)" -> "btr_page_get_next(const ib_page_t*,mtr_t*)"
"btr_pcur_move_to_next_page(btr_pcur_t*,mtr_t*)" -> "buf_block_get_page_no(const buf_block_t*)"
"btr_pcur_move_to_next_page(btr_pcur_t*,mtr_t*)" -> "btr_block_get_func(ulint,ulint,ulint,ulint,const char*,ulint,mtr_t*)"
"btr_pcur_move_to_next_page(btr_pcur_t*,mtr_t*)" -> "buf_block_get_space(const buf_block_t*)"
"btr_pcur_move_to_next_page(btr_pcur_t*,mtr_t*)" -> "abort()"
"btr_pcur_move_to_next_page(btr_pcur_t*,mtr_t*)" -> "page_cur_set_before_first(const buf_block_t*,page_cur_t*)"
"btr_pcur_move_to_next_page(btr_pcur_t*,mtr_t*)" -> "__builtin_expect(long int,long int)"
"btr_pcur_move_to_next_page(btr_pcur_t*,mtr_t*)" -> "ut_dbg_assertion_failed(const char*,const char*,ulint)"
"btr_pcur_move_to_next_page(btr_pcur_t*,mtr_t*)" -> "page_check_dir(const ib_page_t*)"
"btr_pcur_move_to_next_page(btr_pcur_t*,mtr_t*)" -> "page_is_comp(const ib_page_t*)"
"btr_pcur_move_to_next_page(btr_pcur_t*,mtr_t*)" -> "btr_page_get_prev(const ib_page_t*,mtr_t*)"
"btr_leaf_page_release(buf_block_t*,ulint,mtr_t*)" -> "mtr_memo_release(mtr_t*,void*,ulint)"
"mtr_memo_release(mtr_t*,void*,ulint)" -> "dyn_block_get_used(const dyn_block_t*)"
"mtr_memo_release(mtr_t*,void*,ulint)" -> "mtr_memo_slot_release_func(mtr_memo_slot_t*)"
"mtr_memo_release(mtr_t*,void*,ulint)" -> "dyn_block_get_data(const dyn_block_t*)"
"mtr_memo_slot_release_func(mtr_memo_slot_t*)" -> "buf_page_release(buf_block_t*,ulint)"
"mtr_memo_slot_release_func(mtr_memo_slot_t*)" -> "pfs_rw_lock_s_unlock_func(rw_lock_t*)"
"mtr_memo_slot_release_func(mtr_memo_slot_t*)" -> "pfs_rw_lock_x_unlock_func(rw_lock_t*)"
"buf_page_release(buf_block_t*,ulint)" -> "pfs_rw_lock_s_unlock_func(rw_lock_t*)"
"buf_page_release(buf_block_t*,ulint)" -> "ut_dbg_assertion_failed(const char*,const char*,ulint)"
"buf_page_release(buf_block_t*,ulint)" -> "buf_block_get_state(const buf_block_t*)"
"buf_page_release(buf_block_t*,ulint)" -> "pfs_rw_lock_x_unlock_func(rw_lock_t*)"
"buf_page_release(buf_block_t*,ulint)" -> "__builtin_expect(long int,long int)"
"buf_page_release(buf_block_t*,ulint)" -> "buf_block_unfix(buf_block_t*)"
"buf_page_release(buf_block_t*,ulint)" -> "abort()"
"pfs_rw_lock_s_unlock_func(rw_lock_t*)" -> "rw_lock_s_unlock_func(rw_lock_t*)"
"rw_lock_s_unlock_func(rw_lock_t*)" -> "sync_array_object_signalled()"
"rw_lock_s_unlock_func(rw_lock_t*)" -> "os_event_set(os_event_t)"
"rw_lock_s_unlock_func(rw_lock_t*)" -> "rw_lock_lock_word_incr(rw_lock_t*,ulint)"
"sync_array_object_signalled()" -> "__sync_add_and_fetch_8(volatile void*,long unsigned int)"
"os_event_set(os_event_t)" -> "pfs_os_fast_mutex_unlock(os_fast_mutex_t*)"
"os_event_set(os_event_t)" -> "os_cond_broadcast(os_cond_t*)"
"os_event_set(os_event_t)" -> "ut_dbg_assertion_failed(const char*,const char*,ulint)"
"os_event_set(os_event_t)" -> "pfs_os_fast_mutex_lock(os_fast_mutex_t*,const char*,ulint)"
"os_event_set(os_event_t)" -> "__builtin_expect(long int,long int)"
"os_event_set(os_event_t)" -> "abort()"
"pfs_os_fast_mutex_unlock(os_fast_mutex_t*)" -> "os_fast_mutex_unlock_func(fast_mutex_t*)"
"os_fast_mutex_unlock_func(fast_mutex_t*)" -> "pthread_mutex_unlock(pthread_mutex_t*)"
"os_cond_broadcast(os_cond_t*)" -> "__builtin_expect(long int,long int)"
"os_cond_broadcast(os_cond_t*)" -> "ut_dbg_assertion_failed(const char*,const char*,ulint)"
"os_cond_broadcast(os_cond_t*)" -> "abort()"
"os_cond_broadcast(os_cond_t*)" -> "pthread_cond_broadcast(pthread_cond_t*)"
"pfs_os_fast_mutex_lock(os_fast_mutex_t*,const char*,ulint)" -> "os_fast_mutex_lock_func(fast_mutex_t*)"
"os_fast_mutex_lock_func(fast_mutex_t*)" -> "pthread_mutex_lock(pthread_mutex_t*)"
"rw_lock_lock_word_incr(rw_lock_t*,ulint)" -> "__sync_add_and_fetch_8(volatile void*,long unsigned int)"
"buf_block_get_state(const buf_block_t*)" -> "buf_page_get_state(const buf_page_t*)"
"pfs_rw_lock_x_unlock_func(rw_lock_t*)" -> "rw_lock_x_unlock_func(rw_lock_t*)"
"rw_lock_x_unlock_func(rw_lock_t*)" -> "rw_lock_reset_waiter_flag(rw_lock_t*)"
"rw_lock_x_unlock_func(rw_lock_t*)" -> "os_event_set(os_event_t)"
"rw_lock_x_unlock_func(rw_lock_t*)" -> "sync_array_object_signalled()"
"rw_lock_x_unlock_func(rw_lock_t*)" -> "rw_lock_lock_word_incr(rw_lock_t*,ulint)"
"rw_lock_reset_waiter_flag(rw_lock_t*)" -> "__sync_bool_compare_and_swap_8(volatile void*,long unsigned int,long unsigned int)"
"buf_block_unfix(buf_block_t*)" -> "__sync_sub_and_fetch_4(volatile void*,unsigned int)"
"btr_page_get_next(const ib_page_t*,mtr_t*)" -> "mach_read_from_4(const unsigned char*)"
"buf_block_get_page_no(const buf_block_t*)" -> "ut_dbg_assertion_failed(const char*,const char*,ulint)"
"buf_block_get_page_no(const buf_block_t*)" -> "__builtin_expect(long int,long int)"
"buf_block_get_page_no(const buf_block_t*)" -> "abort()"
"buf_block_get_page_no(const buf_block_t*)" -> "buf_block_get_state(const buf_block_t*)"
"btr_block_get_func(ulint,ulint,ulint,ulint,const char*,ulint,mtr_t*)" -> "buf_page_get_gen(ulint,ulint,ulint,ulint,buf_block_t*,ulint,const char*,ulint,mtr_t*)"
"buf_page_get_gen(ulint,ulint,ulint,ulint,buf_block_t*,ulint,const char*,ulint,mtr_t*)" -> "buf_pool_get(ulint,ulint)"
"buf_page_get_gen(ulint,ulint,ulint,ulint,buf_block_t*,ulint,const char*,ulint,mtr_t*)" -> "buf_page_free_descriptor(buf_page_t*)"
"buf_page_get_gen(ulint,ulint,ulint,ulint,buf_block_t*,ulint,const char*,ulint,mtr_t*)" -> "buf_block_fix(buf_block_t*)"
"buf_page_get_gen(ulint,ulint,ulint,ulint,buf_block_t*,ulint,const char*,ulint,mtr_t*)" -> "buf_block_set_io_fix(buf_block_t*,buf_io_fix)"
"buf_page_get_gen(ulint,ulint,ulint,ulint,buf_block_t*,ulint,const char*,ulint,mtr_t*)" -> "buf_pool_watch_set(ulint,ulint,ulint)"
"buf_page_get_gen(ulint,ulint,ulint,ulint,buf_block_t*,ulint,const char*,ulint,mtr_t*)" -> "buf_block_get_state(const buf_block_t*)"
"buf_page_get_gen(ulint,ulint,ulint,ulint,buf_block_t*,ulint,const char*,ulint,mtr_t*)" -> "__builtin_expect(long int,long int)"
"buf_page_get_gen(ulint,ulint,ulint,ulint,buf_block_t*,ulint,const char*,ulint,mtr_t*)" -> "buf_block_is_uncompressed(buf_pool_t*,const buf_block_t*)"
"buf_page_get_gen(ulint,ulint,ulint,ulint,buf_block_t*,ulint,const char*,ulint,mtr_t*)" -> "ibuf_inside(const mtr_t*)"
"buf_page_get_gen(ulint,ulint,ulint,ulint,buf_block_t*,ulint,const char*,ulint,mtr_t*)" -> "buf_page_set_accessed(buf_page_t*)"
"buf_page_get_gen(ulint,ulint,ulint,ulint,buf_block_t*,ulint,const char*,ulint,mtr_t*)" -> "buf_read_ahead_random(ulint,ulint,ulint,ulint)"
"buf_page_get_gen(ulint,ulint,ulint,ulint,buf_block_t*,ulint,const char*,ulint,mtr_t*)" -> "lock_rec_hash(ulint,ulint)"
"buf_page_get_gen(ulint,ulint,ulint,ulint,buf_block_t*,ulint,const char*,ulint,mtr_t*)" -> "hash_get_lock(hash_table_t*,ulint)"
"buf_page_get_gen(ulint,ulint,ulint,ulint,buf_block_t*,ulint,const char*,ulint,mtr_t*)" -> "ut_dbg_assertion_failed(const char*,const char*,ulint)"
"buf_page_get_gen(ulint,ulint,ulint,ulint,buf_block_t*,ulint,const char*,ulint,mtr_t*)" -> "mtr_memo_push(mtr_t*,void*,ulint)"
"buf_page_get_gen(ulint,ulint,ulint,ulint,buf_block_t*,ulint,const char*,ulint,mtr_t*)" -> "os_thread_sleep(ulint)"
"buf_page_get_gen(ulint,ulint,ulint,ulint,buf_block_t*,ulint,const char*,ulint,mtr_t*)" -> "buf_page_get_state(const buf_page_t*)"
"buf_page_get_gen(ulint,ulint,ulint,ulint,buf_block_t*,ulint,const char*,ulint,mtr_t*)" -> "buf_read_ahead_linear(ulint,ulint,ulint,ulint)"
"buf_page_get_gen(ulint,ulint,ulint,ulint,buf_block_t*,ulint,const char*,ulint,mtr_t*)" -> "fprintf(FILE*,const char*,...)"
"buf_page_get_gen(ulint,ulint,ulint,ulint,buf_block_t*,ulint,const char*,ulint,mtr_t*)" -> "abort()"
"buf_page_get_gen(ulint,ulint,ulint,ulint,buf_block_t*,ulint,const char*,ulint,mtr_t*)" -> "ibuf_merge_or_delete_for_page(buf_block_t*,ulint,ulint,ulint,ulint)"
"buf_page_get_gen(ulint,ulint,ulint,ulint,buf_block_t*,ulint,const char*,ulint,mtr_t*)" -> "pfs_rw_lock_x_lock_func(rw_lock_t*,ulint,const char*,ulint)"
"buf_page_get_gen(ulint,ulint,ulint,ulint,buf_block_t*,ulint,const char*,ulint,mtr_t*)" -> "pfs_mutex_enter_func(ib_mutex_t*,const char*,ulint)"
"buf_page_get_gen(ulint,ulint,ulint,ulint,buf_block_t*,ulint,const char*,ulint,mtr_t*)" -> "pfs_rw_lock_x_unlock_func(rw_lock_t*)"
"buf_page_get_gen(ulint,ulint,ulint,ulint,buf_block_t*,ulint,const char*,ulint,mtr_t*)" -> "buf_relocate(buf_page_t*,buf_page_t*)"
"buf_page_get_gen(ulint,ulint,ulint,ulint,buf_block_t*,ulint,const char*,ulint,mtr_t*)" -> "buf_block_unfix(buf_block_t*)"
"buf_page_get_gen(ulint,ulint,ulint,ulint,buf_block_t*,ulint,const char*,ulint,mtr_t*)" -> "pfs_rw_lock_s_lock_func(rw_lock_t*,ulint,const char*,ulint)"
"buf_page_get_gen(ulint,ulint,ulint,ulint,buf_block_t*,ulint,const char*,ulint,mtr_t*)" -> "buf_page_hash_get_low(buf_pool_t*,ulint,ulint,ulint)"
"buf_page_get_gen(ulint,ulint,ulint,ulint,buf_block_t*,ulint,const char*,ulint,mtr_t*)" -> "buf_unzip_LRU_add_block(buf_block_t*,ulint)"
"buf_page_get_gen(ulint,ulint,ulint,ulint,buf_block_t*,ulint,const char*,ulint,mtr_t*)" -> "buf_flush_relocate_on_flush_list(buf_page_t*,buf_page_t*)"
"buf_page_get_gen(ulint,ulint,ulint,ulint,buf_block_t*,ulint,const char*,ulint,mtr_t*)" -> "pfs_rw_lock_s_unlock_func(rw_lock_t*)"
"buf_page_get_gen(ulint,ulint,ulint,ulint,buf_block_t*,ulint,const char*,ulint,mtr_t*)" -> "buf_page_get_io_fix(const buf_page_t*)"
"buf_page_get_gen(ulint,ulint,ulint,ulint,buf_block_t*,ulint,const char*,ulint,mtr_t*)" -> "buf_LRU_block_free_non_file_page(buf_block_t*)"
"buf_page_get_gen(ulint,ulint,ulint,ulint,buf_block_t*,ulint,const char*,ulint,mtr_t*)" -> "buf_page_make_young_if_needed(buf_page_t*)"
"buf_page_get_gen(ulint,ulint,ulint,ulint,buf_block_t*,ulint,const char*,ulint,mtr_t*)" -> "buf_zip_decompress(buf_block_t*,ulint)"
"buf_page_get_gen(ulint,ulint,ulint,ulint,buf_block_t*,ulint,const char*,ulint,mtr_t*)" -> "buf_LRU_get_free_block(buf_pool_t*)"
"buf_page_get_gen(ulint,ulint,ulint,ulint,buf_block_t*,ulint,const char*,ulint,mtr_t*)" -> "buf_pool_watch_is_sentinel(buf_pool_t*,const buf_page_t*)"
"buf_page_get_gen(ulint,ulint,ulint,ulint,buf_block_t*,ulint,const char*,ulint,mtr_t*)" -> "buf_wait_for_read(buf_block_t*)"
"buf_page_get_gen(ulint,ulint,ulint,ulint,buf_block_t*,ulint,const char*,ulint,mtr_t*)" -> "buf_page_address_fold(ulint,ulint)"
"buf_page_get_gen(ulint,ulint,ulint,ulint,buf_block_t*,ulint,const char*,ulint,mtr_t*)" -> "buf_read_page(ulint,ulint,ulint)"
"buf_page_get_gen(ulint,ulint,ulint,ulint,buf_block_t*,ulint,const char*,ulint,mtr_t*)" -> "pfs_mutex_exit_func(ib_mutex_t*)"
"buf_page_get_gen(ulint,ulint,ulint,ulint,buf_block_t*,ulint,const char*,ulint,mtr_t*)" -> "buf_page_get_mutex(const buf_page_t*)"
"buf_page_get_gen(ulint,ulint,ulint,ulint,buf_block_t*,ulint,const char*,ulint,mtr_t*)" -> "buf_block_init_low(buf_block_t*)"
"buf_page_get_gen(ulint,ulint,ulint,ulint,buf_block_t*,ulint,const char*,ulint,mtr_t*)" -> "buf_page_is_accessed(const buf_page_t*)"
"buf_page_get_gen(ulint,ulint,ulint,ulint,buf_block_t*,ulint,const char*,ulint,mtr_t*)" -> "__sync_sub_and_fetch_4(volatile void*,unsigned int)"
"buf_pool_get(ulint,ulint)" -> "buf_page_address_fold(ulint,ulint)"
"buf_page_free_descriptor(buf_page_t*)" -> "ut_free(void*)"
"ut_free(void*)" -> "abort()"
"ut_free(void*)" -> "__builtin_expect(long int,long int)"
"ut_free(void*)" -> "ut_list_remove(List&,Type&,size_t) [with List = ut_list_base<ut_mem_block_t>,Type = ut_mem_block_t,size_t = long unsigned int]"
"ut_free(void*)" -> "free(void*)"
"ut_free(void*)" -> "pfs_os_fast_mutex_unlock(os_fast_mutex_t*)"
"ut_free(void*)" -> "pfs_os_fast_mutex_lock(os_fast_mutex_t*,const char*,ulint)"
"ut_free(void*)" -> "ut_dbg_assertion_failed(const char*,const char*,ulint)"
"ut_list_remove(List&,Type&,size_t) [with List = ut_list_base<ut_mem_block_t>,Type = ut_mem_block_t,size_t = long unsigned int]" -> "__builtin_expect(long int,long int)"
"ut_list_remove(List&,Type&,size_t) [with List = ut_list_base<ut_mem_block_t>,Type = ut_mem_block_t,size_t = long unsigned int]" -> "abort()"
"ut_list_remove(List&,Type&,size_t) [with List = ut_list_base<ut_mem_block_t>,Type = ut_mem_block_t,size_t = long unsigned int]" -> "ut_elem_get_node(Type&,size_t) [with Type = ut_mem_block_t,size_t = long unsigned int]"
"ut_list_remove(List&,Type&,size_t) [with List = ut_list_base<ut_mem_block_t>,Type = ut_mem_block_t,size_t = long unsigned int]" -> "ut_dbg_assertion_failed(const char*,const char*,ulint)"
"ut_elem_get_node(Type&,size_t) [with Type = ut_mem_block_t,size_t = long unsigned int]" -> "abort()"
"ut_elem_get_node(Type&,size_t) [with Type = ut_mem_block_t,size_t = long unsigned int]" -> "__builtin_expect(long int,long int)"
"ut_elem_get_node(Type&,size_t) [with Type = ut_mem_block_t,size_t = long unsigned int]" -> "ut_dbg_assertion_failed(const char*,const char*,ulint)"
"buf_block_fix(buf_block_t*)" -> "__sync_add_and_fetch_4(volatile void*,unsigned int)"
"buf_block_set_io_fix(buf_block_t*,buf_io_fix)" -> "buf_page_set_io_fix(buf_page_t*,buf_io_fix)"
"buf_pool_watch_set(ulint,ulint,ulint)" -> "hash_unlock_x_all_but(hash_table_t*,rw_lock_t*)"
"buf_pool_watch_set(ulint,ulint,ulint)" -> "abort()"
"buf_pool_watch_set(ulint,ulint,ulint)" -> "hash_calc_hash(ulint,hash_table_t*)"
"buf_pool_watch_set(ulint,ulint,ulint)" -> "buf_page_hash_get_low(buf_pool_t*,ulint,ulint,ulint)"
"buf_pool_watch_set(ulint,ulint,ulint)" -> "ut_dbg_assertion_failed(const char*,const char*,ulint)"
"buf_pool_watch_set(ulint,ulint,ulint)" -> "hash_get_nth_cell(hash_table_t*,ulint)"
"buf_pool_watch_set(ulint,ulint,ulint)" -> "__sync_add_and_fetch_4(volatile void*,unsigned int)"
"buf_pool_watch_set(ulint,ulint,ulint)" -> "__builtin_expect(long int,long int)"
"buf_pool_watch_set(ulint,ulint,ulint)" -> "buf_pool_get(ulint,ulint)"
"buf_pool_watch_set(ulint,ulint,ulint)" -> "pfs_rw_lock_x_unlock_func(rw_lock_t*)"
"buf_pool_watch_set(ulint,ulint,ulint)" -> "pfs_mutex_exit_func(ib_mutex_t*)"
"buf_pool_watch_set(ulint,ulint,ulint)" -> "hash_lock_x_all(hash_table_t*)"
"buf_pool_watch_set(ulint,ulint,ulint)" -> "hash_get_lock(hash_table_t*,ulint)"
"buf_pool_watch_set(ulint,ulint,ulint)" -> "buf_pool_watch_is_sentinel(buf_pool_t*,const buf_page_t*)"
"buf_pool_watch_set(ulint,ulint,ulint)" -> "pfs_mutex_enter_func(ib_mutex_t*,const char*,ulint)"
"hash_unlock_x_all_but(hash_table_t*,rw_lock_t*)" -> "__builtin_expect(long int,long int)"
"hash_unlock_x_all_but(hash_table_t*,rw_lock_t*)" -> "pfs_rw_lock_x_unlock_func(rw_lock_t*)"
"hash_calc_hash(ulint,hash_table_t*)" -> "ut_hash_ulint(ulint,ulint)"
"buf_page_hash_get_low(buf_pool_t*,ulint,ulint,ulint)" -> "hash_get_nth_cell(hash_table_t*,ulint)"
"buf_page_hash_get_low(buf_pool_t*,ulint,ulint,ulint)" -> "__builtin_expect(long int,long int)"
"buf_page_hash_get_low(buf_pool_t*,ulint,ulint,ulint)" -> "hash_calc_hash(ulint,hash_table_t*)"
"buf_page_hash_get_low(buf_pool_t*,ulint,ulint,ulint)" -> "buf_page_in_file(const buf_page_t*)"
"buf_page_hash_get_low(buf_pool_t*,ulint,ulint,ulint)" -> "abort()"
"buf_page_hash_get_low(buf_pool_t*,ulint,ulint,ulint)" -> "ut_dbg_assertion_failed(const char*,const char*,ulint)"
"buf_page_in_file(const buf_page_t*)" -> "buf_page_get_state(const buf_page_t*)"
"buf_page_in_file(const buf_page_t*)" -> "abort()"
"buf_page_in_file(const buf_page_t*)" -> "ut_dbg_assertion_failed(const char*,const char*,ulint)"
"pfs_mutex_exit_func(ib_mutex_t*)" -> "mutex_exit_func(ib_mutex_t*)"
"mutex_exit_func(ib_mutex_t*)" -> "mutex_get_waiters(const ib_mutex_t*)"
"mutex_exit_func(ib_mutex_t*)" -> "mutex_signal_object(ib_mutex_t*)"
"mutex_exit_func(ib_mutex_t*)" -> "mutex_reset_lock_word(ib_mutex_t*)"
"mutex_signal_object(ib_mutex_t*)" -> "os_event_set(os_event_t)"
"mutex_signal_object(ib_mutex_t*)" -> "sync_array_object_signalled()"
"mutex_signal_object(ib_mutex_t*)" -> "mutex_set_waiters(ib_mutex_t*,ulint)"
"mutex_reset_lock_word(ib_mutex_t*)" -> "__sync_lock_test_and_set_1(volatile void*,unsigned char)"
"hash_lock_x_all(hash_table_t*)" -> "pfs_rw_lock_x_lock_func(rw_lock_t*,ulint,const char*,ulint)"
"pfs_rw_lock_x_lock_func(rw_lock_t*,ulint,const char*,ulint)" -> "rw_lock_x_lock_func(rw_lock_t*,ulint,const char*,ulint)"
"rw_lock_x_lock_func(rw_lock_t*,ulint,const char*,ulint)" -> "os_thread_yield()"
"rw_lock_x_lock_func(rw_lock_t*,ulint,const char*,ulint)" -> "ut_rnd_interval(ulint,ulint)"
"rw_lock_x_lock_func(rw_lock_t*,ulint,const char*,ulint)" -> "ut_delay(ulint)"
"rw_lock_x_lock_func(rw_lock_t*,ulint,const char*,ulint)" -> "Indexer>::add(size_t,Type) [with Type = long int,int N = 64,Indexer = thread_id_indexer_t,size_t = long unsigned int]"
"rw_lock_x_lock_func(rw_lock_t*,ulint,const char*,ulint)" -> "sync_array_free_cell(sync_array_t*,ulint)"
"rw_lock_x_lock_func(rw_lock_t*,ulint,const char*,ulint)" -> "rw_lock_set_waiter_flag(rw_lock_t*)"
"rw_lock_x_lock_func(rw_lock_t*,ulint,const char*,ulint)" -> "sync_array_wait_event(sync_array_t*,ulint)"
"rw_lock_x_lock_func(rw_lock_t*,ulint,const char*,ulint)" -> "rw_lock_x_lock_low(rw_lock_t*,ulint,const char*,ulint)"
"rw_lock_x_lock_func(rw_lock_t*,ulint,const char*,ulint)" -> "os_thread_get_curr_id()"
"rw_lock_x_lock_func(rw_lock_t*,ulint,const char*,ulint)" -> "sync_array_get_and_reserve_cell(void*,ulint,const char*,ulint,ulint*)"
"os_thread_yield()" -> "sched_yield()"
"ut_rnd_interval(ulint,ulint)" -> "ut_rnd_gen_ulint()"
"ut_rnd_gen_ulint()" -> "ut_rnd_gen_next_ulint(ulint)"
"Indexer>::add(size_t,Type) [with Type = long int,int N = 64,Indexer = thread_id_indexer_t,size_t = long unsigned int]" -> "N>::offset(size_t) const [with Type = long int,int N = 64,size_t = long unsigned int]"
"sync_array_free_cell(sync_array_t*,ulint)" -> "sync_array_get_nth_cell(sync_array_t*,ulint)"
"sync_array_free_cell(sync_array_t*,ulint)" -> "ut_dbg_assertion_failed(const char*,const char*,ulint)"
"sync_array_free_cell(sync_array_t*,ulint)" -> "sync_array_exit(sync_array_t*)"
"sync_array_free_cell(sync_array_t*,ulint)" -> "sync_array_enter(sync_array_t*)"
"sync_array_free_cell(sync_array_t*,ulint)" -> "abort()"
"sync_array_free_cell(sync_array_t*,ulint)" -> "__builtin_expect(long int,long int)"
"sync_array_get_nth_cell(sync_array_t*,ulint)" -> "__builtin_expect(long int,long int)"
"sync_array_get_nth_cell(sync_array_t*,ulint)" -> "ut_dbg_assertion_failed(const char*,const char*,ulint)"
"sync_array_get_nth_cell(sync_array_t*,ulint)" -> "abort()"
"sync_array_exit(sync_array_t*)" -> "os_mutex_exit(os_ib_mutex_t)"
"os_mutex_exit(os_ib_mutex_t)" -> "__builtin_expect(long int,long int)"
"os_mutex_exit(os_ib_mutex_t)" -> "ut_dbg_assertion_failed(const char*,const char*,ulint)"
"os_mutex_exit(os_ib_mutex_t)" -> "abort()"
"os_mutex_exit(os_ib_mutex_t)" -> "pfs_os_fast_mutex_unlock(os_fast_mutex_t*)"
"sync_array_enter(sync_array_t*)" -> "os_mutex_enter(os_ib_mutex_t)"
"os_mutex_enter(os_ib_mutex_t)" -> "pfs_os_fast_mutex_lock(os_fast_mutex_t*,const char*,ulint)"
"os_mutex_enter(os_ib_mutex_t)" -> "abort()"
"os_mutex_enter(os_ib_mutex_t)" -> "ut_dbg_assertion_failed(const char*,const char*,ulint)"
"os_mutex_enter(os_ib_mutex_t)" -> "__builtin_expect(long int,long int)"
"rw_lock_set_waiter_flag(rw_lock_t*)" -> "__sync_bool_compare_and_swap_8(volatile void*,long unsigned int,long unsigned int)"
"sync_array_wait_event(sync_array_t*,ulint)" -> "ut_dbg_assertion_failed(const char*,const char*,ulint)"
"sync_array_wait_event(sync_array_t*,ulint)" -> "sync_array_free_cell(sync_array_t*,ulint)"
"sync_array_wait_event(sync_array_t*,ulint)" -> "sync_cell_get_event(sync_cell_t*)"
"sync_array_wait_event(sync_array_t*,ulint)" -> "sync_array_enter(sync_array_t*)"
"sync_array_wait_event(sync_array_t*,ulint)" -> "os_event_wait_low(os_event_t,ib_int64_t)"
"sync_array_wait_event(sync_array_t*,ulint)" -> "__builtin_expect(long int,long int)"
"sync_array_wait_event(sync_array_t*,ulint)" -> "abort()"
"sync_array_wait_event(sync_array_t*,ulint)" -> "sync_array_exit(sync_array_t*)"
"sync_array_wait_event(sync_array_t*,ulint)" -> "sync_array_get_nth_cell(sync_array_t*,ulint)"
"os_event_wait_low(os_event_t,ib_int64_t)" -> "pfs_os_fast_mutex_unlock(os_fast_mutex_t*)"
"os_event_wait_low(os_event_t,ib_int64_t)" -> "pfs_os_fast_mutex_lock(os_fast_mutex_t*,const char*,ulint)"
"os_event_wait_low(os_event_t,ib_int64_t)" -> "os_cond_wait(os_cond_t*,os_fast_mutex_t*)"
"os_cond_wait(os_cond_t*,os_fast_mutex_t*)" -> "pthread_cond_wait(pthread_cond_t*,pthread_mutex_t*)"
"os_cond_wait(os_cond_t*,os_fast_mutex_t*)" -> "abort()"
"os_cond_wait(os_cond_t*,os_fast_mutex_t*)" -> "__builtin_expect(long int,long int)"
"os_cond_wait(os_cond_t*,os_fast_mutex_t*)" -> "ut_dbg_assertion_failed(const char*,const char*,ulint)"
"rw_lock_x_lock_low(rw_lock_t*,ulint,const char*,ulint)" -> "abort()"
"rw_lock_x_lock_low(rw_lock_t*,ulint,const char*,ulint)" -> "os_thread_eq(os_thread_id_t,os_thread_id_t)"
"rw_lock_x_lock_low(rw_lock_t*,ulint,const char*,ulint)" -> "rw_lock_set_writer_id_and_recursion_flag(rw_lock_t*,ulint)"
"rw_lock_x_lock_low(rw_lock_t*,ulint,const char*,ulint)" -> "rw_lock_x_lock_wait(rw_lock_t*,const char*,ulint)"
"rw_lock_x_lock_low(rw_lock_t*,ulint,const char*,ulint)" -> "ut_dbg_assertion_failed(const char*,const char*,ulint)"
"rw_lock_x_lock_low(rw_lock_t*,ulint,const char*,ulint)" -> "os_thread_get_curr_id()"
"rw_lock_x_lock_low(rw_lock_t*,ulint,const char*,ulint)" -> "rw_lock_lock_word_decr(rw_lock_t*,ulint)"
"rw_lock_x_lock_low(rw_lock_t*,ulint,const char*,ulint)" -> "__builtin_expect(long int,long int)"
"os_thread_eq(os_thread_id_t,os_thread_id_t)" -> "pthread_equal(pthread_t,pthread_t)"
"rw_lock_set_writer_id_and_recursion_flag(rw_lock_t*,ulint)" -> "abort()"
"rw_lock_set_writer_id_and_recursion_flag(rw_lock_t*,ulint)" -> "__sync_bool_compare_and_swap_8(volatile void*,long unsigned int,long unsigned int)"
"rw_lock_set_writer_id_and_recursion_flag(rw_lock_t*,ulint)" -> "ut_dbg_assertion_failed(const char*,const char*,ulint)"
"rw_lock_set_writer_id_and_recursion_flag(rw_lock_t*,ulint)" -> "os_thread_get_curr_id()"
"rw_lock_set_writer_id_and_recursion_flag(rw_lock_t*,ulint)" -> "__builtin_expect(long int,long int)"
"rw_lock_x_lock_wait(rw_lock_t*,const char*,ulint)" -> "sync_array_free_cell(sync_array_t*,ulint)"
"rw_lock_x_lock_wait(rw_lock_t*,const char*,ulint)" -> "os_thread_get_curr_id()"
"rw_lock_x_lock_wait(rw_lock_t*,const char*,ulint)" -> "Indexer>::add(size_t,Type) [with Type = long int,int N = 64,Indexer = thread_id_indexer_t,size_t = long unsigned int]"
"rw_lock_x_lock_wait(rw_lock_t*,const char*,ulint)" -> "sync_array_wait_event(sync_array_t*,ulint)"
"rw_lock_x_lock_wait(rw_lock_t*,const char*,ulint)" -> "ut_rnd_interval(ulint,ulint)"
"rw_lock_x_lock_wait(rw_lock_t*,const char*,ulint)" -> "sync_array_get_and_reserve_cell(void*,ulint,const char*,ulint,ulint*)"
"rw_lock_x_lock_wait(rw_lock_t*,const char*,ulint)" -> "ut_delay(ulint)"
"sync_array_get_and_reserve_cell(void*,ulint,const char*,ulint,ulint*)" -> "__builtin_expect(long int,long int)"
"sync_array_get_and_reserve_cell(void*,ulint,const char*,ulint,ulint*)" -> "sync_array_reserve_cell(sync_array_t*,void*,ulint,const char*,ulint,ulint*)"
"sync_array_get_and_reserve_cell(void*,ulint,const char*,ulint,ulint*)" -> "ut_dbg_assertion_failed(const char*,const char*,ulint)"
"sync_array_get_and_reserve_cell(void*,ulint,const char*,ulint,ulint*)" -> "sync_array_get()"
"sync_array_get_and_reserve_cell(void*,ulint,const char*,ulint,ulint*)" -> "abort()"
"sync_array_reserve_cell(sync_array_t*,void*,ulint,const char*,ulint,ulint*)" -> "sync_array_exit(sync_array_t*)"
"sync_array_reserve_cell(sync_array_t*,void*,ulint,const char*,ulint,ulint*)" -> "ut_time()"
"sync_array_reserve_cell(sync_array_t*,void*,ulint,const char*,ulint,ulint*)" -> "os_thread_get_curr_id()"
"sync_array_reserve_cell(sync_array_t*,void*,ulint,const char*,ulint,ulint*)" -> "ut_dbg_assertion_failed(const char*,const char*,ulint)"
"sync_array_reserve_cell(sync_array_t*,void*,ulint,const char*,ulint,ulint*)" -> "sync_cell_get_event(sync_cell_t*)"
"sync_array_reserve_cell(sync_array_t*,void*,ulint,const char*,ulint,ulint*)" -> "__builtin_expect(long int,long int)"
"sync_array_reserve_cell(sync_array_t*,void*,ulint,const char*,ulint,ulint*)" -> "abort()"
"sync_array_reserve_cell(sync_array_t*,void*,ulint,const char*,ulint,ulint*)" -> "os_event_reset(os_event_t)"
"sync_array_reserve_cell(sync_array_t*,void*,ulint,const char*,ulint,ulint*)" -> "sync_array_get_nth_cell(sync_array_t*,ulint)"
"sync_array_reserve_cell(sync_array_t*,void*,ulint,const char*,ulint,ulint*)" -> "sync_array_enter(sync_array_t*)"
"os_event_reset(os_event_t)" -> "abort()"
"os_event_reset(os_event_t)" -> "__builtin_expect(long int,long int)"
"os_event_reset(os_event_t)" -> "ut_dbg_assertion_failed(const char*,const char*,ulint)"
"os_event_reset(os_event_t)" -> "pfs_os_fast_mutex_unlock(os_fast_mutex_t*)"
"os_event_reset(os_event_t)" -> "pfs_os_fast_mutex_lock(os_fast_mutex_t*,const char*,ulint)"
"sync_array_get()" -> "__sync_add_and_fetch_8(volatile void*,long unsigned int)"
"rw_lock_lock_word_decr(rw_lock_t*,ulint)" -> "__sync_bool_compare_and_swap_8(volatile void*,long unsigned int,long unsigned int)"
"hash_get_lock(hash_table_t*,ulint)" -> "hash_get_nth_lock(hash_table_t*,ulint)"
"hash_get_lock(hash_table_t*,ulint)" -> "hash_get_sync_obj_index(hash_table_t*,ulint)"
"hash_get_sync_obj_index(hash_table_t*,ulint)" -> "hash_calc_hash(ulint,hash_table_t*)"
"pfs_mutex_enter_func(ib_mutex_t*,const char*,ulint)" -> "mutex_enter_func(ib_mutex_t*,const char*,ulint)"
"mutex_enter_func(ib_mutex_t*,const char*,ulint)" -> "mutex_spin_wait(ib_mutex_t*,const char*,ulint)"
"mutex_enter_func(ib_mutex_t*,const char*,ulint)" -> "ib_mutex_test_and_set(ib_mutex_t*)"
"mutex_spin_wait(ib_mutex_t*,const char*,ulint)" -> "mutex_set_waiters(ib_mutex_t*,ulint)"
"mutex_spin_wait(ib_mutex_t*,const char*,ulint)" -> "ib_mutex_test_and_set(ib_mutex_t*)"
"mutex_spin_wait(ib_mutex_t*,const char*,ulint)" -> "Indexer>::add(size_t,Type) [with Type = long int,int N = 64,Indexer = thread_id_indexer_t,size_t = long unsigned int]"
"mutex_spin_wait(ib_mutex_t*,const char*,ulint)" -> "ut_rnd_interval(ulint,ulint)"
"mutex_spin_wait(ib_mutex_t*,const char*,ulint)" -> "sync_array_get_and_reserve_cell(void*,ulint,const char*,ulint,ulint*)"
"mutex_spin_wait(ib_mutex_t*,const char*,ulint)" -> "os_thread_yield()"
"mutex_spin_wait(ib_mutex_t*,const char*,ulint)" -> "sync_array_wait_event(sync_array_t*,ulint)"
"mutex_spin_wait(ib_mutex_t*,const char*,ulint)" -> "mutex_get_lock_word(const ib_mutex_t*)"
"mutex_spin_wait(ib_mutex_t*,const char*,ulint)" -> "ut_delay(ulint)"
"mutex_spin_wait(ib_mutex_t*,const char*,ulint)" -> "os_thread_get_curr_id()"
"mutex_spin_wait(ib_mutex_t*,const char*,ulint)" -> "sync_array_free_cell(sync_array_t*,ulint)"
"ib_mutex_test_and_set(ib_mutex_t*)" -> "__sync_lock_test_and_set_1(volatile void*,unsigned char)"
"buf_block_is_uncompressed(buf_pool_t*,const buf_block_t*)" -> "buf_pointer_is_block_field_instance(buf_pool_t*,const void*)"
"buf_page_set_accessed(buf_page_t*)" -> "__builtin_expect(long int,long int)"
"buf_page_set_accessed(buf_page_t*)" -> "abort()"
"buf_page_set_accessed(buf_page_t*)" -> "ut_time_ms()"
"buf_page_set_accessed(buf_page_t*)" -> "buf_page_in_file(const buf_page_t*)"
"buf_page_set_accessed(buf_page_t*)" -> "ut_dbg_assertion_failed(const char*,const char*,ulint)"
"buf_read_ahead_random(ulint,ulint,ulint,ulint)" -> "fil_space_get_version(ulint)"
"buf_read_ahead_random(ulint,ulint,ulint,ulint)" -> "buf_page_peek_if_young(const buf_page_t*)"
"buf_read_ahead_random(ulint,ulint,ulint,ulint)" -> "trx_sys_hdr_page(ulint,ulint)"
"buf_read_ahead_random(ulint,ulint,ulint,ulint)" -> "os_aio_simulated_wake_handler_threads()"
"buf_read_ahead_random(ulint,ulint,ulint,ulint)" -> "pfs_mutex_enter_func(ib_mutex_t*,const char*,ulint)"
"buf_read_ahead_random(ulint,ulint,ulint,ulint)" -> "buf_read_page_low(dberr_t*,bool,ulint,ulint,ulint,ulint,ib_int64_t,ulint)"
"buf_read_ahead_random(ulint,ulint,ulint,ulint)" -> "ut_print_timestamp(FILE*)"
"buf_read_ahead_random(ulint,ulint,ulint,ulint)" -> "fil_space_get_size(ulint)"
"buf_read_ahead_random(ulint,ulint,ulint,ulint)" -> "ut_2_power_up(ulint)"
"buf_read_ahead_random(ulint,ulint,ulint,ulint)" -> "buf_page_hash_get_locked(buf_pool_t*,ulint,ulint,rw_lock_t**,ulint)"
"buf_read_ahead_random(ulint,ulint,ulint,ulint)" -> "ut_min(ulint,ulint)"
"buf_read_ahead_random(ulint,ulint,ulint,ulint)" -> "pfs_mutex_exit_func(ib_mutex_t*)"
"buf_read_ahead_random(ulint,ulint,ulint,ulint)" -> "ibuf_bitmap_page(ulint,ulint)"
"buf_read_ahead_random(ulint,ulint,ulint,ulint)" -> "buf_pool_get(ulint,ulint)"
"buf_read_ahead_random(ulint,ulint,ulint,ulint)" -> "fprintf(FILE*,const char*,...)"
"buf_read_ahead_random(ulint,ulint,ulint,ulint)" -> "Indexer>::add(Type) [with Type = long unsigned int,int N = 1,Indexer = single_indexer_t]"
"buf_read_ahead_random(ulint,ulint,ulint,ulint)" -> "buf_page_is_accessed(const buf_page_t*)"
"fil_space_get_version(ulint)" -> "pfs_mutex_exit_func(ib_mutex_t*)"
"fil_space_get_version(ulint)" -> "pfs_mutex_enter_func(ib_mutex_t*,const char*,ulint)"
"fil_space_get_version(ulint)" -> "fil_space_get_by_id(ulint)"
"fil_space_get_by_id(ulint)" -> "hash_calc_hash(ulint,hash_table_t*)"
"fil_space_get_by_id(ulint)" -> "hash_get_nth_cell(hash_table_t*,ulint)"
"buf_page_peek_if_young(const buf_page_t*)" -> "buf_pool_from_bpage(const buf_page_t*)"
"os_aio_simulated_wake_handler_threads()" -> "os_aio_simulated_wake_handler_thread(ulint)"
"os_aio_simulated_wake_handler_thread(ulint)" -> "os_mutex_exit(os_ib_mutex_t)"
"os_aio_simulated_wake_handler_thread(ulint)" -> "os_aio_array_get_nth_slot(os_aio_array_t*,ulint)"
"os_aio_simulated_wake_handler_thread(ulint)" -> "os_aio_get_array_and_local_segment(os_aio_array_t**,ulint)"
"os_aio_simulated_wake_handler_thread(ulint)" -> "os_event_set(os_event_t)"
"os_aio_simulated_wake_handler_thread(ulint)" -> "os_mutex_enter(os_ib_mutex_t)"
"os_aio_array_get_nth_slot(os_aio_array_t*,ulint)" -> "ut_dbg_assertion_failed(const char*,const char*,ulint)"
"os_aio_array_get_nth_slot(os_aio_array_t*,ulint)" -> "__builtin_expect(long int,long int)"
"os_aio_array_get_nth_slot(os_aio_array_t*,ulint)" -> "abort()"
"os_aio_get_array_and_local_segment(os_aio_array_t**,ulint)" -> "abort()"
"os_aio_get_array_and_local_segment(os_aio_array_t**,ulint)" -> "ut_dbg_assertion_failed(const char*,const char*,ulint)"
"os_aio_get_array_and_local_segment(os_aio_array_t**,ulint)" -> "__builtin_expect(long int,long int)"
"buf_read_page_low(dberr_t*,bool,ulint,ulint,ulint,ulint,ib_int64_t,ulint)" -> "ut_dbg_assertion_failed(const char*,const char*,ulint)"
"buf_read_page_low(dberr_t*,bool,ulint,ulint,ulint,ulint,ib_int64_t,ulint)" -> "abort()"
"buf_read_page_low(dberr_t*,bool,ulint,ulint,ulint,ulint,ib_int64_t,ulint)" -> "thd_wait_begin(THD*,int)"
"buf_read_page_low(dberr_t*,bool,ulint,ulint,ulint,ulint,ib_int64_t,ulint)" -> "buf_read_page_handle_error(buf_page_t*)"
"buf_read_page_low(dberr_t*,bool,ulint,ulint,ulint,ulint,ib_int64_t,ulint)" -> "fil_io(ulint,bool,ulint,ulint,ulint,ulint,ulint,void*,void*)"
"buf_read_page_low(dberr_t*,bool,ulint,ulint,ulint,ulint,ib_int64_t,ulint)" -> "fprintf(FILE*,const char*,...)"
"buf_read_page_low(dberr_t*,bool,ulint,ulint,ulint,ulint,ib_int64_t,ulint)" -> "buf_dblwr_page_inside(ulint)"
"buf_read_page_low(dberr_t*,bool,ulint,ulint,ulint,ulint,ib_int64_t,ulint)" -> "__builtin_expect(long int,long int)"
"buf_read_page_low(dberr_t*,bool,ulint,ulint,ulint,ulint,ib_int64_t,ulint)" -> "buf_page_init_for_read(dberr_t*,ulint,ulint,ulint,ulint,ib_int64_t,ulint)"
"buf_read_page_low(dberr_t*,bool,ulint,ulint,ulint,ulint,ib_int64_t,ulint)" -> "buf_page_get_state(const buf_page_t*)"
"buf_read_page_low(dberr_t*,bool,ulint,ulint,ulint,ulint,ib_int64_t,ulint)" -> "ut_print_timestamp(FILE*)"
"buf_read_page_low(dberr_t*,bool,ulint,ulint,ulint,ulint,ib_int64_t,ulint)" -> "ibuf_bitmap_page(ulint,ulint)"
"buf_read_page_low(dberr_t*,bool,ulint,ulint,ulint,ulint,ib_int64_t,ulint)" -> "thd_wait_end(THD*)"
"buf_read_page_low(dberr_t*,bool,ulint,ulint,ulint,ulint,ib_int64_t,ulint)" -> "buf_page_io_complete(buf_page_t*)"
"buf_read_page_low(dberr_t*,bool,ulint,ulint,ulint,ulint,ib_int64_t,ulint)" -> "trx_sys_hdr_page(ulint,ulint)"
"buf_read_page_handle_error(buf_page_t*)" -> "buf_pool_from_bpage(const buf_page_t*)"
"buf_read_page_handle_error(buf_page_t*)" -> "buf_page_get_mutex(const buf_page_t*)"
"buf_read_page_handle_error(buf_page_t*)" -> "buf_page_set_io_fix(buf_page_t*,buf_io_fix)"
"buf_read_page_handle_error(buf_page_t*)" -> "buf_LRU_free_one_page(buf_page_t*)"
"buf_read_page_handle_error(buf_page_t*)" -> "pfs_rw_lock_x_unlock_func(rw_lock_t*)"
"buf_read_page_handle_error(buf_page_t*)" -> "pfs_mutex_enter_func(ib_mutex_t*,const char*,ulint)"
"buf_read_page_handle_error(buf_page_t*)" -> "pfs_mutex_exit_func(ib_mutex_t*)"
"buf_read_page_handle_error(buf_page_t*)" -> "buf_page_get_state(const buf_page_t*)"
"buf_page_get_mutex(const buf_page_t*)" -> "ut_dbg_assertion_failed(const char*,const char*,ulint)"
"buf_page_get_mutex(const buf_page_t*)" -> "buf_pool_from_bpage(const buf_page_t*)"
"buf_page_get_mutex(const buf_page_t*)" -> "buf_page_get_state(const buf_page_t*)"
"buf_page_get_mutex(const buf_page_t*)" -> "abort()"
"buf_LRU_free_one_page(buf_page_t*)" -> "buf_page_address_fold(ulint,ulint)"
"buf_LRU_free_one_page(buf_page_t*)" -> "pfs_mutex_enter_func(ib_mutex_t*,const char*,ulint)"
"buf_LRU_free_one_page(buf_page_t*)" -> "buf_pool_from_bpage(const buf_page_t*)"
"buf_LRU_free_one_page(buf_page_t*)" -> "hash_get_lock(hash_table_t*,ulint)"
"buf_LRU_free_one_page(buf_page_t*)" -> "buf_LRU_block_free_hashed_page(buf_block_t*)"
"buf_LRU_free_one_page(buf_page_t*)" -> "pfs_rw_lock_x_lock_func(rw_lock_t*,ulint,const char*,ulint)"
"buf_LRU_free_one_page(buf_page_t*)" -> "buf_LRU_block_remove_hashed(buf_page_t*,bool)"
"buf_LRU_free_one_page(buf_page_t*)" -> "buf_page_get_mutex(const buf_page_t*)"
"buf_LRU_block_free_hashed_page(buf_block_t*)" -> "buf_block_set_state(buf_block_t*,buf_page_state)"
"buf_LRU_block_free_hashed_page(buf_block_t*)" -> "pfs_mutex_enter_func(ib_mutex_t*,const char*,ulint)"
"buf_LRU_block_free_hashed_page(buf_block_t*)" -> "buf_LRU_block_free_non_file_page(buf_block_t*)"
"buf_LRU_block_free_hashed_page(buf_block_t*)" -> "pfs_mutex_exit_func(ib_mutex_t*)"
"buf_block_set_state(buf_block_t*,buf_page_state)" -> "buf_page_set_state(buf_page_t*,buf_page_state)"
"buf_LRU_block_free_non_file_page(buf_block_t*)" -> "memset(void*,int,size_t)"
"buf_LRU_block_free_non_file_page(buf_block_t*)" -> "buf_buddy_free(buf_pool_t*,void*,ulint)"
"buf_LRU_block_free_non_file_page(buf_block_t*)" -> "pfs_mutex_exit_func(ib_mutex_t*)"
"buf_LRU_block_free_non_file_page(buf_block_t*)" -> "ut_list_prepend(List&,Type&,size_t) [with List = ut_list_base<buf_page_t>,Type = buf_page_t,size_t = long unsigned int]"
"buf_LRU_block_free_non_file_page(buf_block_t*)" -> "page_zip_set_size(page_zip_des_t*,ulint)"
"buf_LRU_block_free_non_file_page(buf_block_t*)" -> "buf_pool_from_block(const buf_block_t*)"
"buf_LRU_block_free_non_file_page(buf_block_t*)" -> "page_zip_get_size(const page_zip_des_t*)"
"buf_LRU_block_free_non_file_page(buf_block_t*)" -> "ut_dbg_assertion_failed(const char*,const char*,ulint)"
"buf_LRU_block_free_non_file_page(buf_block_t*)" -> "pfs_mutex_enter_func(ib_mutex_t*,const char*,ulint)"
"buf_LRU_block_free_non_file_page(buf_block_t*)" -> "buf_block_set_state(buf_block_t*,buf_page_state)"
"buf_LRU_block_free_non_file_page(buf_block_t*)" -> "abort()"
"buf_LRU_block_free_non_file_page(buf_block_t*)" -> "buf_block_get_state(const buf_block_t*)"
"buf_buddy_free(buf_pool_t*,void*,ulint)" -> "buf_buddy_free_low(buf_pool_t*,void*,ulint)"
"buf_buddy_free(buf_pool_t*,void*,ulint)" -> "buf_buddy_get_slot(ulint)"
"buf_buddy_free_low(buf_pool_t*,void*,ulint)" -> "buf_buddy_get(unsigned char*,ulint)"
"buf_buddy_free_low(buf_pool_t*,void*,ulint)" -> "buf_buddy_block_free(buf_pool_t*,void*)"
"buf_buddy_free_low(buf_pool_t*,void*,ulint)" -> "buf_buddy_add_to_free(buf_pool_t*,buf_buddy_free_t*,ulint)"
"buf_buddy_free_low(buf_pool_t*,void*,ulint)" -> "ut_align_down(const void*,ulint)"
"buf_buddy_free_low(buf_pool_t*,void*,ulint)" -> "buf_buddy_relocate(buf_pool_t*,void*,void*,ulint)"
"buf_buddy_free_low(buf_pool_t*,void*,ulint)" -> "buf_buddy_is_free(buf_buddy_free_t*,ulint)"
"buf_buddy_free_low(buf_pool_t*,void*,ulint)" -> "buf_buddy_remove_from_free(buf_pool_t*,buf_buddy_free_t*,ulint)"
"buf_buddy_block_free(buf_pool_t*,void*)" -> "buf_page_get_state(const buf_page_t*)"
"buf_buddy_block_free(buf_pool_t*,void*)" -> "pfs_mutex_exit_func(ib_mutex_t*)"
"buf_buddy_block_free(buf_pool_t*,void*)" -> "__builtin_expect(long int,long int)"
"buf_buddy_block_free(buf_pool_t*,void*)" -> "buf_LRU_block_free_non_file_page(buf_block_t*)"
"buf_buddy_block_free(buf_pool_t*,void*)" -> "hash_calc_hash(ulint,hash_table_t*)"
"buf_buddy_block_free(buf_pool_t*,void*)" -> "ut_dbg_assertion_failed(const char*,const char*,ulint)"
"buf_buddy_block_free(buf_pool_t*,void*)" -> "abort()"
"buf_buddy_block_free(buf_pool_t*,void*)" -> "hash_get_nth_cell(hash_table_t*,ulint)"
"buf_buddy_block_free(buf_pool_t*,void*)" -> "ut_align_offset(const void*,ulint)"
"buf_buddy_block_free(buf_pool_t*,void*)" -> "pfs_mutex_enter_func(ib_mutex_t*,const char*,ulint)"
"buf_buddy_add_to_free(buf_pool_t*,buf_buddy_free_t*,ulint)" -> "ut_list_prepend(List&,Type&,size_t) [with List = ut_list_base<buf_buddy_free_t>,Type = buf_buddy_free_t,size_t = long unsigned int]"
"buf_buddy_add_to_free(buf_pool_t*,buf_buddy_free_t*,ulint)" -> "buf_buddy_stamp_free(buf_buddy_free_t*,ulint)"
"ut_list_prepend(List&,Type&,size_t) [with List = ut_list_base<buf_buddy_free_t>,Type = buf_buddy_free_t,size_t = long unsigned int]" -> "ut_elem_get_node(Type&,size_t) [with Type = buf_buddy_free_t,size_t = long unsigned int]"
"ut_elem_get_node(Type&,size_t) [with Type = buf_buddy_free_t,size_t = long unsigned int]" -> "abort()"
"ut_elem_get_node(Type&,size_t) [with Type = buf_buddy_free_t,size_t = long unsigned int]" -> "ut_dbg_assertion_failed(const char*,const char*,ulint)"
"ut_elem_get_node(Type&,size_t) [with Type = buf_buddy_free_t,size_t = long unsigned int]" -> "__builtin_expect(long int,long int)"
"buf_buddy_stamp_free(buf_buddy_free_t*,ulint)" -> "mach_write_to_4(unsigned char*,ulint)"
"buf_buddy_relocate(buf_pool_t*,void*,void*,ulint)" -> "buf_page_address_fold(ulint,ulint)"
"buf_buddy_relocate(buf_pool_t*,void*,void*,ulint)" -> "ut_time_us(ullint*)"
"buf_buddy_relocate(buf_pool_t*,void*,void*,ulint)" -> "pfs_mutex_enter_func(ib_mutex_t*,const char*,ulint)"
"buf_buddy_relocate(buf_pool_t*,void*,void*,ulint)" -> "ut_dbg_assertion_failed(const char*,const char*,ulint)"
"buf_buddy_relocate(buf_pool_t*,void*,void*,ulint)" -> "memcpy(void*,const void*,size_t)"
"buf_buddy_relocate(buf_pool_t*,void*,void*,ulint)" -> "buf_page_get_mutex(const buf_page_t*)"
"buf_buddy_relocate(buf_pool_t*,void*,void*,ulint)" -> "page_zip_get_size(const page_zip_des_t*)"
"buf_buddy_relocate(buf_pool_t*,void*,void*,ulint)" -> "mach_read_from_4(const unsigned char*)"
"buf_buddy_relocate(buf_pool_t*,void*,void*,ulint)" -> "pfs_rw_lock_x_unlock_func(rw_lock_t*)"
"buf_buddy_relocate(buf_pool_t*,void*,void*,ulint)" -> "buf_page_hash_get_low(buf_pool_t*,ulint,ulint,ulint)"
"buf_buddy_relocate(buf_pool_t*,void*,void*,ulint)" -> "__builtin_expect(long int,long int)"
"buf_buddy_relocate(buf_pool_t*,void*,void*,ulint)" -> "hash_get_lock(hash_table_t*,ulint)"
"buf_buddy_relocate(buf_pool_t*,void*,void*,ulint)" -> "pfs_mutex_exit_func(ib_mutex_t*)"
"buf_buddy_relocate(buf_pool_t*,void*,void*,ulint)" -> "buf_page_can_relocate(const buf_page_t*)"
"buf_buddy_relocate(buf_pool_t*,void*,void*,ulint)" -> "pfs_rw_lock_x_lock_func(rw_lock_t*,ulint,const char*,ulint)"
"buf_buddy_relocate(buf_pool_t*,void*,void*,ulint)" -> "abort()"
"buf_page_can_relocate(const buf_page_t*)" -> "buf_page_get_io_fix(const buf_page_t*)"
"buf_buddy_is_free(buf_buddy_free_t*,ulint)" -> "buf_buddy_stamp_is_free(const buf_buddy_free_t*)"
"buf_buddy_stamp_is_free(const buf_buddy_free_t*)" -> "mach_read_from_4(const unsigned char*)"
"buf_buddy_remove_from_free(buf_pool_t*,buf_buddy_free_t*,ulint)" -> "memset(void*,int,size_t)"
"buf_buddy_remove_from_free(buf_pool_t*,buf_buddy_free_t*,ulint)" -> "ut_list_remove(List&,Type&,size_t) [with List = ut_list_base<buf_buddy_free_t>,Type = buf_buddy_free_t,size_t = long unsigned int]"
"ut_list_remove(List&,Type&,size_t) [with List = ut_list_base<buf_buddy_free_t>,Type = buf_buddy_free_t,size_t = long unsigned int]" -> "abort()"
"ut_list_remove(List&,Type&,size_t) [with List = ut_list_base<buf_buddy_free_t>,Type = buf_buddy_free_t,size_t = long unsigned int]" -> "ut_elem_get_node(Type&,size_t) [with Type = buf_buddy_free_t,size_t = long unsigned int]"
"ut_list_remove(List&,Type&,size_t) [with List = ut_list_base<buf_buddy_free_t>,Type = buf_buddy_free_t,size_t = long unsigned int]" -> "__builtin_expect(long int,long int)"
"ut_list_remove(List&,Type&,size_t) [with List = ut_list_base<buf_buddy_free_t>,Type = buf_buddy_free_t,size_t = long unsigned int]" -> "ut_dbg_assertion_failed(const char*,const char*,ulint)"
"ut_list_prepend(List&,Type&,size_t) [with List = ut_list_base<buf_page_t>,Type = buf_page_t,size_t = long unsigned int]" -> "ut_elem_get_node(Type&,size_t) [with Type = buf_page_t,size_t = long unsigned int]"
"ut_elem_get_node(Type&,size_t) [with Type = buf_page_t,size_t = long unsigned int]" -> "__builtin_expect(long int,long int)"
"ut_elem_get_node(Type&,size_t) [with Type = buf_page_t,size_t = long unsigned int]" -> "abort()"
"ut_elem_get_node(Type&,size_t) [with Type = buf_page_t,size_t = long unsigned int]" -> "ut_dbg_assertion_failed(const char*,const char*,ulint)"
"buf_pool_from_block(const buf_block_t*)" -> "buf_pool_from_bpage(const buf_page_t*)"
"buf_LRU_block_remove_hashed(buf_page_t*,bool)" -> "buf_buddy_free(buf_pool_t*,void*,ulint)"
"buf_LRU_block_remove_hashed(buf_page_t*,bool)" -> "buf_page_address_fold(ulint,ulint)"
"buf_LRU_block_remove_hashed(buf_page_t*,bool)" -> "memcpy(void*,const void*,size_t)"
"buf_LRU_block_remove_hashed(buf_page_t*,bool)" -> "page_zip_set_size(page_zip_des_t*,ulint)"
"buf_LRU_block_remove_hashed(buf_page_t*,bool)" -> "ut_print_buf(FILE*,const void*,ulint)"
"buf_LRU_block_remove_hashed(buf_page_t*,bool)" -> "__builtin_fwrite(const void*,size_t,size_t,FILE*)"
"buf_LRU_block_remove_hashed(buf_page_t*,bool)" -> "buf_pool_from_bpage(const buf_page_t*)"
"buf_LRU_block_remove_hashed(buf_page_t*,bool)" -> "hash_get_lock(hash_table_t*,ulint)"
"buf_LRU_block_remove_hashed(buf_page_t*,bool)" -> "ut_dbg_assertion_failed(const char*,const char*,ulint)"
"buf_LRU_block_remove_hashed(buf_page_t*,bool)" -> "buf_block_modify_clock_inc(buf_block_t*)"
"buf_LRU_block_remove_hashed(buf_page_t*,bool)" -> "_IO_putc(int,_IO_FILE*)"
"buf_LRU_block_remove_hashed(buf_page_t*,bool)" -> "buf_page_get_zip_size(const buf_page_t*)"
"buf_LRU_block_remove_hashed(buf_page_t*,bool)" -> "__builtin_expect(long int,long int)"
"buf_LRU_block_remove_hashed(buf_page_t*,bool)" -> "buf_page_get_state(const buf_page_t*)"
"buf_LRU_block_remove_hashed(buf_page_t*,bool)" -> "pfs_mutex_exit_func(ib_mutex_t*)"
"buf_LRU_block_remove_hashed(buf_page_t*,bool)" -> "page_zip_get_size(const page_zip_des_t*)"
"buf_LRU_block_remove_hashed(buf_page_t*,bool)" -> "abort()"
"buf_LRU_block_remove_hashed(buf_page_t*,bool)" -> "buf_page_set_state(buf_page_t*,buf_page_state)"
"buf_LRU_block_remove_hashed(buf_page_t*,bool)" -> "buf_page_free_descriptor(buf_page_t*)"
"buf_LRU_block_remove_hashed(buf_page_t*,bool)" -> "buf_page_hash_get_low(buf_pool_t*,ulint,ulint,ulint)"
"buf_LRU_block_remove_hashed(buf_page_t*,bool)" -> "hash_get_nth_cell(hash_table_t*,ulint)"
"buf_LRU_block_remove_hashed(buf_page_t*,bool)" -> "ut_print_timestamp(FILE*)"
"buf_LRU_block_remove_hashed(buf_page_t*,bool)" -> "pfs_rw_lock_x_unlock_func(rw_lock_t*)"
"buf_LRU_block_remove_hashed(buf_page_t*,bool)" -> "buf_LRU_remove_block(buf_page_t*)"
"buf_LRU_block_remove_hashed(buf_page_t*,bool)" -> "fil_page_get_type(const unsigned char*)"
"buf_LRU_block_remove_hashed(buf_page_t*,bool)" -> "fprintf(FILE*,const char*,...)"
"buf_LRU_block_remove_hashed(buf_page_t*,bool)" -> "hash_calc_hash(ulint,hash_table_t*)"
"buf_LRU_block_remove_hashed(buf_page_t*,bool)" -> "buf_page_get_io_fix(const buf_page_t*)"
"buf_LRU_block_remove_hashed(buf_page_t*,bool)" -> "memset(void*,int,size_t)"
"buf_LRU_remove_block(buf_page_t*)" -> "ut_list_remove(List&,Type&,size_t) [with List = ut_list_base<buf_page_t>,Type = buf_page_t,size_t = long unsigned int]"
"buf_LRU_remove_block(buf_page_t*)" -> "buf_page_is_old(const buf_page_t*)"
"buf_LRU_remove_block(buf_page_t*)" -> "page_zip_get_size(const page_zip_des_t*)"
"buf_LRU_remove_block(buf_page_t*)" -> "buf_unzip_LRU_remove_block_if_needed(buf_page_t*)"
"buf_LRU_remove_block(buf_page_t*)" -> "abort()"
"buf_LRU_remove_block(buf_page_t*)" -> "buf_page_in_file(const buf_page_t*)"
"buf_LRU_remove_block(buf_page_t*)" -> "ut_dbg_assertion_failed(const char*,const char*,ulint)"
"buf_LRU_remove_block(buf_page_t*)" -> "__builtin_expect(long int,long int)"
"buf_LRU_remove_block(buf_page_t*)" -> "buf_LRU_old_adjust_len(buf_pool_t*)"
"buf_LRU_remove_block(buf_page_t*)" -> "buf_pool_from_bpage(const buf_page_t*)"
"buf_LRU_remove_block(buf_page_t*)" -> "buf_page_set_old(buf_page_t*,ulint)"
"ut_list_remove(List&,Type&,size_t) [with List = ut_list_base<buf_page_t>,Type = buf_page_t,size_t = long unsigned int]" -> "abort()"
"ut_list_remove(List&,Type&,size_t) [with List = ut_list_base<buf_page_t>,Type = buf_page_t,size_t = long unsigned int]" -> "ut_dbg_assertion_failed(const char*,const char*,ulint)"
"ut_list_remove(List&,Type&,size_t) [with List = ut_list_base<buf_page_t>,Type = buf_page_t,size_t = long unsigned int]" -> "__builtin_expect(long int,long int)"
"ut_list_remove(List&,Type&,size_t) [with List = ut_list_base<buf_page_t>,Type = buf_page_t,size_t = long unsigned int]" -> "ut_elem_get_node(Type&,size_t) [with Type = buf_page_t,size_t = long unsigned int]"
"buf_unzip_LRU_remove_block_if_needed(buf_page_t*)" -> "ut_list_remove(List&,Type&,size_t) [with List = ut_list_base<buf_block_t>,Type = buf_block_t,size_t = long unsigned int]"
"buf_unzip_LRU_remove_block_if_needed(buf_page_t*)" -> "buf_pool_from_bpage(const buf_page_t*)"
"buf_unzip_LRU_remove_block_if_needed(buf_page_t*)" -> "buf_page_belongs_to_unzip_LRU(const buf_page_t*)"
"ut_list_remove(List&,Type&,size_t) [with List = ut_list_base<buf_block_t>,Type = buf_block_t,size_t = long unsigned int]" -> "abort()"
"ut_list_remove(List&,Type&,size_t) [with List = ut_list_base<buf_block_t>,Type = buf_block_t,size_t = long unsigned int]" -> "ut_elem_get_node(Type&,size_t) [with Type = buf_block_t,size_t = long unsigned int]"
"ut_list_remove(List&,Type&,size_t) [with List = ut_list_base<buf_block_t>,Type = buf_block_t,size_t = long unsigned int]" -> "__builtin_expect(long int,long int)"
"ut_list_remove(List&,Type&,size_t) [with List = ut_list_base<buf_block_t>,Type = buf_block_t,size_t = long unsigned int]" -> "ut_dbg_assertion_failed(const char*,const char*,ulint)"
"ut_elem_get_node(Type&,size_t) [with Type = buf_block_t,size_t = long unsigned int]" -> "abort()"
"ut_elem_get_node(Type&,size_t) [with Type = buf_block_t,size_t = long unsigned int]" -> "ut_dbg_assertion_failed(const char*,const char*,ulint)"
"ut_elem_get_node(Type&,size_t) [with Type = buf_block_t,size_t = long unsigned int]" -> "__builtin_expect(long int,long int)"
"buf_page_belongs_to_unzip_LRU(const buf_page_t*)" -> "buf_page_get_state(const buf_page_t*)"
"buf_LRU_old_adjust_len(buf_pool_t*)" -> "ut_min(ulint,ulint)"
"buf_LRU_old_adjust_len(buf_pool_t*)" -> "__builtin_expect(long int,long int)"
"buf_LRU_old_adjust_len(buf_pool_t*)" -> "ut_dbg_assertion_failed(const char*,const char*,ulint)"
"buf_LRU_old_adjust_len(buf_pool_t*)" -> "abort()"
"buf_LRU_old_adjust_len(buf_pool_t*)" -> "buf_page_set_old(buf_page_t*,ulint)"
"buf_page_set_old(buf_page_t*,ulint)" -> "buf_page_in_file(const buf_page_t*)"
"buf_page_set_old(buf_page_t*,ulint)" -> "__builtin_expect(long int,long int)"
"buf_page_set_old(buf_page_t*,ulint)" -> "abort()"
"buf_page_set_old(buf_page_t*,ulint)" -> "ut_dbg_assertion_failed(const char*,const char*,ulint)"
"fil_io(ulint,bool,ulint,ulint,ulint,ulint,ulint,void*,void*)" -> "pfs_mutex_exit_func(ib_mutex_t*)"
"fil_io(ulint,bool,ulint,ulint,ulint,ulint,ulint,void*,void*)" -> "fil_node_complete_io(fil_node_t*,fil_system_t*,ulint)"
"fil_io(ulint,bool,ulint,ulint,ulint,ulint,ulint,void*,void*)" -> "pfs_mutex_enter_func(ib_mutex_t*,const char*,ulint)"
"fil_io(ulint,bool,ulint,ulint,ulint,ulint,ulint,void*,void*)" -> "ibuf_page_low(ulint,ulint,ulint,const char*,ulint,mtr_t*)"
"fil_io(ulint,bool,ulint,ulint,ulint,ulint,ulint,void*,void*)" -> "pfs_os_aio_func(ulint,ulint,const char*,os_file_t,void*,os_offset_t,ulint,fil_node_t*,void*,const char*,ulint)"
"fil_io(ulint,bool,ulint,ulint,ulint,ulint,ulint,void*,void*)" -> "Indexer>::add(Type) [with Type = long unsigned int,int N = 1,Indexer = single_indexer_t]"
"fil_io(ulint,bool,ulint,ulint,ulint,ulint,ulint,void*,void*)" -> "fil_space_get_by_id(ulint)"
"fil_io(ulint,bool,ulint,ulint,ulint,ulint,ulint,void*,void*)" -> "fil_mutex_enter_and_prepare_for_io(ulint)"
"fil_io(ulint,bool,ulint,ulint,ulint,ulint,ulint,void*,void*)" -> "fil_node_prepare_for_io(fil_node_t*,fil_system_t*,fil_space_t*)"
"fil_io(ulint,bool,ulint,ulint,ulint,ulint,ulint,void*,void*)" -> "ib_logf(ib_log_level_t,const char*,...)"
"fil_io(ulint,bool,ulint,ulint,ulint,ulint,ulint,void*,void*)" -> "ut_dbg_assertion_failed(const char*,const char*,ulint)"
"fil_io(ulint,bool,ulint,ulint,ulint,ulint,ulint,void*,void*)" -> "fil_report_invalid_page_access(ulint,ulint,const char*,ulint,ulint,ulint)"
"fil_io(ulint,bool,ulint,ulint,ulint,ulint,ulint,void*,void*)" -> "abort()"
"fil_io(ulint,bool,ulint,ulint,ulint,ulint,ulint,void*,void*)" -> "__builtin_expect(long int,long int)"
"fil_node_complete_io(fil_node_t*,fil_system_t*,ulint)" -> "abort()"
"fil_node_complete_io(fil_node_t*,fil_system_t*,ulint)" -> "fil_space_belongs_in_lru(const fil_space_t*)"
"fil_node_complete_io(fil_node_t*,fil_system_t*,ulint)" -> "__builtin_expect(long int,long int)"
"fil_node_complete_io(fil_node_t*,fil_system_t*,ulint)" -> "ut_dbg_assertion_failed(const char*,const char*,ulint)"
"fil_node_complete_io(fil_node_t*,fil_system_t*,ulint)" -> "ut_list_prepend(List&,Type&,size_t) [with List = ut_list_base<fil_space_t>,Type = fil_space_t,size_t = long unsigned int]"
"fil_node_complete_io(fil_node_t*,fil_system_t*,ulint)" -> "ut_list_prepend(List&,Type&,size_t) [with List = ut_list_base<fil_node_t>,Type = fil_node_t,size_t = long unsigned int]"
"ut_list_prepend(List&,Type&,size_t) [with List = ut_list_base<fil_space_t>,Type = fil_space_t,size_t = long unsigned int]" -> "ut_elem_get_node(Type&,size_t) [with Type = fil_space_t,size_t = long unsigned int]"
"ut_elem_get_node(Type&,size_t) [with Type = fil_space_t,size_t = long unsigned int]" -> "__builtin_expect(long int,long int)"
"ut_elem_get_node(Type&,size_t) [with Type = fil_space_t,size_t = long unsigned int]" -> "abort()"
"ut_elem_get_node(Type&,size_t) [with Type = fil_space_t,size_t = long unsigned int]" -> "ut_dbg_assertion_failed(const char*,const char*,ulint)"
"ut_list_prepend(List&,Type&,size_t) [with List = ut_list_base<fil_node_t>,Type = fil_node_t,size_t = long unsigned int]" -> "ut_elem_get_node(Type&,size_t) [with Type = fil_node_t,size_t = long unsigned int]"
"ut_elem_get_node(Type&,size_t) [with Type = fil_node_t,size_t = long unsigned int]" -> "abort()"
"ut_elem_get_node(Type&,size_t) [with Type = fil_node_t,size_t = long unsigned int]" -> "ut_dbg_assertion_failed(const char*,const char*,ulint)"
"ut_elem_get_node(Type&,size_t) [with Type = fil_node_t,size_t = long unsigned int]" -> "__builtin_expect(long int,long int)"
"ibuf_page_low(ulint,ulint,ulint,const char*,ulint,mtr_t*)" -> "ibuf_fixed_addr_page(ulint,ulint,ulint)"
"ibuf_page_low(ulint,ulint,ulint,const char*,ulint,mtr_t*)" -> "mtr_commit(mtr_t*)"
"ibuf_page_low(ulint,ulint,ulint,const char*,ulint,mtr_t*)" -> "ibuf_bitmap_get_map_page_func(ulint,ulint,ulint,const char*,ulint,mtr_t*)"
"ibuf_page_low(ulint,ulint,ulint,const char*,ulint,mtr_t*)" -> "mtr_start(mtr_t*)"
"ibuf_page_low(ulint,ulint,ulint,const char*,ulint,mtr_t*)" -> "ibuf_bitmap_page_get_bits_low(const ib_page_t*,ulint,ulint,ulint)"
"ibuf_fixed_addr_page(ulint,ulint,ulint)" -> "ibuf_bitmap_page(ulint,ulint)"
"mtr_commit(mtr_t*)" -> "mtr_log_reserve_and_write(mtr_t*)"
"mtr_commit(mtr_t*)" -> "mtr_memo_pop_all(mtr_t*)"
"mtr_commit(mtr_t*)" -> "dyn_array_free(dyn_array_t*)"
"mtr_log_reserve_and_write(mtr_t*)" -> "mlog_catenate_ulint(mtr_t*,ulint,ulint)"
"mtr_log_reserve_and_write(mtr_t*)" -> "dyn_block_get_data(const dyn_block_t*)"
"mtr_log_reserve_and_write(mtr_t*)" -> "dyn_block_get_used(const dyn_block_t*)"
"mtr_log_reserve_and_write(mtr_t*)" -> "log_reserve_and_open(ulint)"
"mtr_log_reserve_and_write(mtr_t*)" -> "mtr_add_dirtied_pages_to_flush_list(mtr_t*)"
"mtr_log_reserve_and_write(mtr_t*)" -> "log_close()"
"mtr_log_reserve_and_write(mtr_t*)" -> "dyn_array_get_data_size(const dyn_array_t*)"
"mtr_log_reserve_and_write(mtr_t*)" -> "log_write_low(unsigned char*,ulint)"
"mtr_log_reserve_and_write(mtr_t*)" -> "log_reserve_and_write_fast(const void*,ulint,lsn_t*)"
"mlog_catenate_ulint(mtr_t*,ulint,ulint)" -> "mach_write_to_2(unsigned char*,ulint)"
"mlog_catenate_ulint(mtr_t*,ulint,ulint)" -> "mach_write_to_4(unsigned char*,ulint)"
"mlog_catenate_ulint(mtr_t*,ulint,ulint)" -> "mtr_get_log_mode(mtr_t*)"
"mlog_catenate_ulint(mtr_t*,ulint,ulint)" -> "mach_write_to_1(unsigned char*,ulint)"
"mlog_catenate_ulint(mtr_t*,ulint,ulint)" -> "dyn_array_push(dyn_array_t*,ulint)"
"dyn_array_push(dyn_array_t*,ulint)" -> "dyn_array_add_block(dyn_array_t*)"
"dyn_array_add_block(dyn_array_t*)" -> "mem_heap_alloc(mem_heap_t*,ulint)"
"dyn_array_add_block(dyn_array_t*)" -> "ut_list_prepend(List&,Type&,size_t) [with List = ut_list_base<dyn_block_t>,Type = dyn_block_t,size_t = long unsigned int]"
"dyn_array_add_block(dyn_array_t*)" -> "ut_list_append(List&,Type&,size_t) [with List = ut_list_base<dyn_block_t>,Type = dyn_block_t,size_t = long unsigned int]"
"dyn_array_add_block(dyn_array_t*)" -> "mem_heap_create_func(ulint,ulint)"
"mem_heap_alloc(mem_heap_t*,ulint)" -> "mem_block_get_free(mem_block_t*)"
"mem_heap_alloc(mem_heap_t*,ulint)" -> "mem_block_set_free(mem_block_t*,ulint)"
"mem_heap_alloc(mem_heap_t*,ulint)" -> "mem_block_get_len(mem_block_t*)"
"mem_heap_alloc(mem_heap_t*,ulint)" -> "mem_heap_add_block(mem_heap_t*,ulint)"
"mem_heap_add_block(mem_heap_t*,ulint)" -> "ut_dbg_assertion_failed(const char*,const char*,ulint)"
"mem_heap_add_block(mem_heap_t*,ulint)" -> "mem_block_get_len(mem_block_t*)"
"mem_heap_add_block(mem_heap_t*,ulint)" -> "__builtin_expect(long int,long int)"
"mem_heap_add_block(mem_heap_t*,ulint)" -> "abort()"
"mem_heap_add_block(mem_heap_t*,ulint)" -> "mem_heap_create_block_func(mem_heap_t*,ulint,ulint)"
"mem_heap_add_block(mem_heap_t*,ulint)" -> "ut_list_insert(List&,Type&,Type&,size_t) [with List = ut_list_base<mem_block_info_t>,Type = mem_block_info_t,size_t = long unsigned int]"
"mem_heap_create_block_func(mem_heap_t*,ulint,ulint)" -> "mem_block_set_start(mem_block_t*,ulint)"
"mem_heap_create_block_func(mem_heap_t*,ulint,ulint)" -> "ib_logf(ib_log_level_t,const char*,...)"
"mem_heap_create_block_func(mem_heap_t*,ulint,ulint)" -> "mem_analyze_corruption(void*)"
"mem_heap_create_block_func(mem_heap_t*,ulint,ulint)" -> "mem_block_set_len(mem_block_t*,ulint)"
"mem_heap_create_block_func(mem_heap_t*,ulint,ulint)" -> "mem_block_set_type(mem_block_t*,ulint)"
"mem_heap_create_block_func(mem_heap_t*,ulint,ulint)" -> "__builtin_expect(long int,long int)"
"mem_heap_create_block_func(mem_heap_t*,ulint,ulint)" -> "buf_block_alloc(buf_pool_t*)"
"mem_heap_create_block_func(mem_heap_t*,ulint,ulint)" -> "mem_block_set_free(mem_block_t*,ulint)"
"mem_heap_create_block_func(mem_heap_t*,ulint,ulint)" -> "mem_area_alloc(ulint*,mem_pool_t*)"
"ib_logf(ib_log_level_t,const char*,...)" -> "sql_print_error(const char*,...)"
"ib_logf(ib_log_level_t,const char*,...)" -> "ut_dbg_assertion_failed(const char*,const char*,ulint)"
"ib_logf(ib_log_level_t,const char*,...)" -> "__builtin_expect(long int,long int)"
"ib_logf(ib_log_level_t,const char*,...)" -> "abort()"
"ib_logf(ib_log_level_t,const char*,...)" -> "sql_print_warning(const char*,...)"
"ib_logf(ib_log_level_t,const char*,...)" -> "__builtin_va_end(__va_list_tag*)"
"ib_logf(ib_log_level_t,const char*,...)" -> "free(void*)"
"ib_logf(ib_log_level_t,const char*,...)" -> "sql_print_information(const char*,...)"
"ib_logf(ib_log_level_t,const char*,...)" -> "vasprintf(char**,const char*,__va_list_tag*)"
"ib_logf(ib_log_level_t,const char*,...)" -> "__builtin_va_start(__va_list_tag*,...)"
"buf_block_alloc(buf_pool_t*)" -> "buf_LRU_get_free_block(buf_pool_t*)"
"buf_block_alloc(buf_pool_t*)" -> "buf_pool_from_array(ulint)"
"buf_block_alloc(buf_pool_t*)" -> "buf_block_set_state(buf_block_t*,buf_page_state)"
"buf_LRU_get_free_block(buf_pool_t*)" -> "pfs_mutex_exit_func(ib_mutex_t*)"
"buf_LRU_get_free_block(buf_pool_t*)" -> "buf_flush_wait_batch_end(buf_pool_t*,buf_flush_t)"
"buf_LRU_get_free_block(buf_pool_t*)" -> "buf_LRU_check_size_of_non_data_objects(const buf_pool_t*)"
"buf_LRU_get_free_block(buf_pool_t*)" -> "ut_print_timestamp(FILE*)"
"buf_LRU_get_free_block(buf_pool_t*)" -> "pfs_mutex_enter_func(ib_mutex_t*,const char*,ulint)"
"buf_LRU_get_free_block(buf_pool_t*)" -> "os_thread_sleep(ulint)"
"buf_LRU_get_free_block(buf_pool_t*)" -> "memset(void*,int,size_t)"
"buf_LRU_get_free_block(buf_pool_t*)" -> "Indexer>::add(size_t,Type) [with Type = long unsigned int,int N = 1,Indexer = single_indexer_t,size_t = long unsigned int]"
"buf_LRU_get_free_block(buf_pool_t*)" -> "buf_flush_single_page_from_LRU(buf_pool_t*)"
"buf_LRU_get_free_block(buf_pool_t*)" -> "buf_LRU_scan_and_free_block(buf_pool_t*,ulint)"
"buf_LRU_get_free_block(buf_pool_t*)" -> "buf_LRU_get_free_only(buf_pool_t*)"
"buf_LRU_get_free_block(buf_pool_t*)" -> "fprintf(FILE*,const char*,...)"
"buf_LRU_get_free_block(buf_pool_t*)" -> "os_event_set(os_event_t)"
"buf_flush_wait_batch_end(buf_pool_t*,buf_flush_t)" -> "buf_pool_from_array(ulint)"
"buf_flush_wait_batch_end(buf_pool_t*,buf_flush_t)" -> "thd_wait_end(THD*)"
"buf_flush_wait_batch_end(buf_pool_t*,buf_flush_t)" -> "thd_wait_begin(THD*,int)"
"buf_flush_wait_batch_end(buf_pool_t*,buf_flush_t)" -> "os_event_wait_low(os_event_t,ib_int64_t)"
"buf_LRU_check_size_of_non_data_objects(const buf_pool_t*)" -> "abort()"
"buf_LRU_check_size_of_non_data_objects(const buf_pool_t*)" -> "os_event_set(os_event_t)"
"buf_LRU_check_size_of_non_data_objects(const buf_pool_t*)" -> "ut_dbg_assertion_failed(const char*,const char*,ulint)"
"buf_LRU_check_size_of_non_data_objects(const buf_pool_t*)" -> "fprintf(FILE*,const char*,...)"
"buf_LRU_check_size_of_non_data_objects(const buf_pool_t*)" -> "ut_print_timestamp(FILE*)"
"os_thread_sleep(ulint)" -> "select(int,fd_set*,fd_set*,fd_set*,timeval*)"
"Indexer>::add(size_t,Type) [with Type = long unsigned int,int N = 1,Indexer = single_indexer_t,size_t = long unsigned int]" -> "N>::offset(size_t) const [with Type = long unsigned int,int N = 1,size_t = long unsigned int]"
"buf_flush_single_page_from_LRU(buf_pool_t*)" -> "pfs_mutex_exit_func(ib_mutex_t*)"
"buf_flush_single_page_from_LRU(buf_pool_t*)" -> "buf_flush_ready_for_replace(buf_page_t*)"
"buf_flush_single_page_from_LRU(buf_pool_t*)" -> "pfs_mutex_enter_func(ib_mutex_t*,const char*,ulint)"
"buf_flush_single_page_from_LRU(buf_pool_t*)" -> "buf_page_get_mutex(const buf_page_t*)"
"buf_flush_single_page_from_LRU(buf_pool_t*)" -> "buf_flush_page(buf_pool_t*,buf_page_t*,buf_flush_t,bool)"
"buf_flush_single_page_from_LRU(buf_pool_t*)" -> "buf_LRU_evict_from_unzip_LRU(buf_pool_t*)"
"buf_flush_single_page_from_LRU(buf_pool_t*)" -> "buf_LRU_free_page(buf_page_t*,bool)"
"buf_flush_single_page_from_LRU(buf_pool_t*)" -> "buf_flush_ready_for_flush(buf_page_t*,buf_flush_t)"
"buf_flush_ready_for_replace(buf_page_t*)" -> "buf_page_get_state(const buf_page_t*)"
"buf_flush_ready_for_replace(buf_page_t*)" -> "_IO_putc(int,_IO_FILE*)"
"buf_flush_ready_for_replace(buf_page_t*)" -> "ut_print_timestamp(FILE*)"
"buf_flush_ready_for_replace(buf_page_t*)" -> "fprintf(FILE*,const char*,...)"
"buf_flush_ready_for_replace(buf_page_t*)" -> "buf_page_get_io_fix(const buf_page_t*)"
"buf_flush_ready_for_replace(buf_page_t*)" -> "ut_print_buf(FILE*,const void*,ulint)"
"buf_flush_ready_for_replace(buf_page_t*)" -> "buf_page_in_file(const buf_page_t*)"
"buf_flush_page(buf_pool_t*,buf_page_t*,buf_flush_t,bool)" -> "pfs_rw_lock_s_lock_low(rw_lock_t*,ulint,const char*,ulint)"
"buf_flush_page(buf_pool_t*,buf_page_t*,buf_flush_t,bool)" -> "buf_flush_write_block_low(buf_page_t*,buf_flush_t,bool)"
"buf_flush_page(buf_pool_t*,buf_page_t*,buf_flush_t,bool)" -> "pfs_mutex_exit_func(ib_mutex_t*)"
"buf_flush_page(buf_pool_t*,buf_page_t*,buf_flush_t,bool)" -> "buf_page_set_io_fix(buf_page_t*,buf_io_fix)"
"buf_flush_page(buf_pool_t*,buf_page_t*,buf_flush_t,bool)" -> "buf_page_get_mutex(const buf_page_t*)"
"buf_flush_page(buf_pool_t*,buf_page_t*,buf_flush_t,bool)" -> "buf_page_set_flush_type(buf_page_t*,buf_flush_t)"
"buf_flush_page(buf_pool_t*,buf_page_t*,buf_flush_t,bool)" -> "buf_page_get_state(const buf_page_t*)"
"buf_flush_page(buf_pool_t*,buf_page_t*,buf_flush_t,bool)" -> "buf_dblwr_flush_buffered_writes()"
"buf_flush_page(buf_pool_t*,buf_page_t*,buf_flush_t,bool)" -> "pfs_rw_lock_s_lock_func(rw_lock_t*,ulint,const char*,ulint)"
"buf_flush_page(buf_pool_t*,buf_page_t*,buf_flush_t,bool)" -> "os_event_reset(os_event_t)"
"pfs_rw_lock_s_lock_low(rw_lock_t*,ulint,const char*,ulint)" -> "rw_lock_s_lock_low(rw_lock_t*,ulint,const char*,ulint)"
"rw_lock_s_lock_low(rw_lock_t*,ulint,const char*,ulint)" -> "rw_lock_lock_word_decr(rw_lock_t*,ulint)"
"buf_flush_write_block_low(buf_page_t*,buf_flush_t,bool)" -> "ut_dbg_assertion_failed(const char*,const char*,ulint)"
"buf_flush_write_block_low(buf_page_t*,buf_flush_t,bool)" -> "fil_flush(ulint)"
"buf_flush_write_block_low(buf_page_t*,buf_flush_t,bool)" -> "abort()"
"buf_flush_write_block_low(buf_page_t*,buf_flush_t,bool)" -> "memset(void*,int,size_t)"
"buf_flush_write_block_low(buf_page_t*,buf_flush_t,bool)" -> "page_zip_verify_checksum(const void*,ulint)"
"buf_flush_write_block_low(buf_page_t*,buf_flush_t,bool)" -> "buf_page_get_page_no(const buf_page_t*)"
"buf_flush_write_block_low(buf_page_t*,buf_flush_t,bool)" -> "buf_page_get_zip_size(const buf_page_t*)"
"buf_flush_write_block_low(buf_page_t*,buf_flush_t,bool)" -> "buf_page_io_complete(buf_page_t*)"
"buf_flush_write_block_low(buf_page_t*,buf_flush_t,bool)" -> "buf_dblwr_add_to_batch(buf_page_t*)"
"buf_flush_write_block_low(buf_page_t*,buf_flush_t,bool)" -> "log_write_up_to(lsn_t,ulint,ulint)"
"buf_flush_write_block_low(buf_page_t*,buf_flush_t,bool)" -> "buf_page_get_state(const buf_page_t*)"
"buf_flush_write_block_low(buf_page_t*,buf_flush_t,bool)" -> "buf_flush_init_for_writing(unsigned char*,void*,lsn_t)"
"buf_flush_write_block_low(buf_page_t*,buf_flush_t,bool)" -> "mach_write_to_8(void*,ib_uint64_t)"
"buf_flush_write_block_low(buf_page_t*,buf_flush_t,bool)" -> "buf_page_get_space(const buf_page_t*)"
"buf_flush_write_block_low(buf_page_t*,buf_flush_t,bool)" -> "__builtin_expect(long int,long int)"
"buf_flush_write_block_low(buf_page_t*,buf_flush_t,bool)" -> "fil_io(ulint,bool,ulint,ulint,ulint,ulint,ulint,void*,void*)"
"buf_flush_write_block_low(buf_page_t*,buf_flush_t,bool)" -> "buf_dblwr_write_single_page(buf_page_t*,bool)"
"fil_flush(ulint)" -> "os_event_wait_low(os_event_t,ib_int64_t)"
"fil_flush(ulint)" -> "pfs_mutex_exit_func(ib_mutex_t*)"
"fil_flush(ulint)" -> "pfs_os_file_flush_func(os_file_t,const char*,ulint)"
"fil_flush(ulint)" -> "fil_space_get_by_id(ulint)"
"fil_flush(ulint)" -> "os_event_set(os_event_t)"
"fil_flush(ulint)" -> "os_event_reset(os_event_t)"
"fil_flush(ulint)" -> "ut_list_remove(List&,Type&,size_t) [with List = ut_list_base<fil_space_t>,Type = fil_space_t,size_t = long unsigned int]"
"fil_flush(ulint)" -> "__builtin_expect(long int,long int)"
"fil_flush(ulint)" -> "ut_dbg_assertion_failed(const char*,const char*,ulint)"
"fil_flush(ulint)" -> "abort()"
"fil_flush(ulint)" -> "fil_space_is_flushed(fil_space_t*)"
"fil_flush(ulint)" -> "pfs_mutex_enter_func(ib_mutex_t*,const char*,ulint)"
"pfs_os_file_flush_func(os_file_t,const char*,ulint)" -> "__builtin_expect(long int,long int)"
"pfs_os_file_flush_func(os_file_t,const char*,ulint)" -> "os_file_flush_func(os_file_t)"
"os_file_flush_func(os_file_t)" -> "ut_dbg_assertion_failed(const char*,const char*,ulint)"
"os_file_flush_func(os_file_t)" -> "os_file_handle_error(const char*,const char*)"
"os_file_flush_func(os_file_t)" -> "os_file_fsync(os_file_t)"
"os_file_flush_func(os_file_t)" -> "abort()"
"os_file_flush_func(os_file_t)" -> "ib_logf(ib_log_level_t,const char*,...)"
"os_file_flush_func(os_file_t)" -> "__errno_location()"
"os_file_handle_error(const char*,const char*)" -> "os_file_handle_error_cond_exit(const char*,const char*,ulint,ulint)"
"os_file_handle_error_cond_exit(const char*,const char*,ulint,ulint)" -> "ut_print_timestamp(FILE*)"
"os_file_handle_error_cond_exit(const char*,const char*,ulint,ulint)" -> "os_file_get_last_error_low(bool,bool)"
"os_file_handle_error_cond_exit(const char*,const char*,ulint,ulint)" -> "__builtin_fwrite(const void*,size_t,size_t,FILE*)"
"os_file_handle_error_cond_exit(const char*,const char*,ulint,ulint)" -> "ib_logf(ib_log_level_t,const char*,...)"
"os_file_handle_error_cond_exit(const char*,const char*,ulint,ulint)" -> "fprintf(FILE*,const char*,...)"
"os_file_handle_error_cond_exit(const char*,const char*,ulint,ulint)" -> "fflush(FILE*)"
"os_file_handle_error_cond_exit(const char*,const char*,ulint,ulint)" -> "exit(int)"
"os_file_handle_error_cond_exit(const char*,const char*,ulint,ulint)" -> "os_thread_sleep(ulint)"
"os_file_get_last_error_low(bool,bool)" -> "__builtin_fwrite(const void*,size_t,size_t,FILE*)"
"os_file_get_last_error_low(bool,bool)" -> "__errno_location()"
"os_file_get_last_error_low(bool,bool)" -> "fflush(FILE*)"
"os_file_get_last_error_low(bool,bool)" -> "strerror(int)"
"os_file_get_last_error_low(bool,bool)" -> "ut_print_timestamp(FILE*)"
"os_file_get_last_error_low(bool,bool)" -> "fprintf(FILE*,const char*,...)"
"os_file_fsync(os_file_t)" -> "ut_print_timestamp(FILE*)"
"os_file_fsync(os_file_t)" -> "__errno_location()"
"os_file_fsync(os_file_t)" -> "__builtin_fwrite(const void*,size_t,size_t,FILE*)"
"os_file_fsync(os_file_t)" -> "fsync(int)"
"ut_list_remove(List&,Type&,size_t) [with List = ut_list_base<fil_space_t>,Type = fil_space_t,size_t = long unsigned int]" -> "abort()"
"ut_list_remove(List&,Type&,size_t) [with List = ut_list_base<fil_space_t>,Type = fil_space_t,size_t = long unsigned int]" -> "ut_dbg_assertion_failed(const char*,const char*,ulint)"
"ut_list_remove(List&,Type&,size_t) [with List = ut_list_base<fil_space_t>,Type = fil_space_t,size_t = long unsigned int]" -> "__builtin_expect(long int,long int)"
"ut_list_remove(List&,Type&,size_t) [with List = ut_list_base<fil_space_t>,Type = fil_space_t,size_t = long unsigned int]" -> "ut_elem_get_node(Type&,size_t) [with Type = fil_space_t,size_t = long unsigned int]"
"page_zip_verify_checksum(const void*,ulint)" -> "page_zip_calc_checksum(const void*,ulint,srv_checksum_algorithm_t)"
"page_zip_verify_checksum(const void*,ulint)" -> "mach_read_from_4(const unsigned char*)"
"buf_page_get_page_no(const buf_page_t*)" -> "__builtin_expect(long int,long int)"
"buf_page_get_page_no(const buf_page_t*)" -> "ut_dbg_assertion_failed(const char*,const char*,ulint)"
"buf_page_get_page_no(const buf_page_t*)" -> "abort()"
"buf_page_get_page_no(const buf_page_t*)" -> "buf_page_in_file(const buf_page_t*)"
"buf_page_io_complete(buf_page_t*)" -> "ut_dbg_assertion_failed(const char*,const char*,ulint)"
"buf_page_io_complete(buf_page_t*)" -> "buf_page_in_file(const buf_page_t*)"
"buf_page_io_complete(buf_page_t*)" -> "fprintf(FILE*,const char*,...)"
"buf_page_io_complete(buf_page_t*)" -> "pfs_rw_lock_s_unlock_func(rw_lock_t*)"
"buf_page_io_complete(buf_page_t*)" -> "mach_read_from_4(const unsigned char*)"
"buf_page_io_complete(buf_page_t*)" -> "abort()"
"buf_page_io_complete(buf_page_t*)" -> "recv_recover_page_func(ulint,buf_block_t*)"
"buf_page_io_complete(buf_page_t*)" -> "buf_mark_space_corrupt(buf_page_t*)"
"buf_page_io_complete(buf_page_t*)" -> "ibuf_merge_or_delete_for_page(buf_block_t*,ulint,ulint,ulint,ulint)"
"buf_page_io_complete(buf_page_t*)" -> "buf_page_print(const unsigned char*,ulint,ulint)"
"buf_page_io_complete(buf_page_t*)" -> "buf_page_set_io_fix(buf_page_t*,buf_io_fix)"
"buf_page_io_complete(buf_page_t*)" -> "buf_page_get_state(const buf_page_t*)"
"buf_page_io_complete(buf_page_t*)" -> "__builtin_fwrite(const void*,size_t,size_t,FILE*)"
"buf_page_io_complete(buf_page_t*)" -> "buf_dblwr_page_inside(ulint)"
"buf_page_io_complete(buf_page_t*)" -> "buf_page_get_mutex(const buf_page_t*)"
"buf_page_io_complete(buf_page_t*)" -> "recv_recovery_is_on()"
"buf_page_io_complete(buf_page_t*)" -> "buf_zip_decompress(buf_block_t*,ulint)"
"buf_page_io_complete(buf_page_t*)" -> "buf_pool_from_bpage(const buf_page_t*)"
"buf_page_io_complete(buf_page_t*)" -> "buf_page_get_zip_size(const buf_page_t*)"
"buf_page_io_complete(buf_page_t*)" -> "ut_print_timestamp(FILE*)"
"buf_page_io_complete(buf_page_t*)" -> "pfs_mutex_enter_func(ib_mutex_t*,const char*,ulint)"
"buf_page_io_complete(buf_page_t*)" -> "pfs_rw_lock_x_unlock_func(rw_lock_t*)"
"buf_page_io_complete(buf_page_t*)" -> "buf_page_monitor(const buf_page_t*,buf_io_fix)"
"buf_page_io_complete(buf_page_t*)" -> "buf_page_get_io_fix(const buf_page_t*)"
"buf_page_io_complete(buf_page_t*)" -> "buf_page_is_corrupted(bool,const unsigned char*,ulint)"
"buf_page_io_complete(buf_page_t*)" -> "__builtin_expect(long int,long int)"
"buf_page_io_complete(buf_page_t*)" -> "pfs_mutex_exit_func(ib_mutex_t*)"
"buf_page_io_complete(buf_page_t*)" -> "buf_flush_write_complete(buf_page_t*)"
"recv_recover_page_func(ulint,buf_block_t*)" -> "buf_flush_recv_note_modification(buf_block_t*,lsn_t,lsn_t)"
"recv_recover_page_func(ulint,buf_block_t*)" -> "pfs_mutex_exit_func(ib_mutex_t*)"
"recv_recover_page_func(ulint,buf_block_t*)" -> "abort()"
"recv_recover_page_func(ulint,buf_block_t*)" -> "mach_write_to_8(void*,ib_uint64_t)"
"recv_recover_page_func(ulint,buf_block_t*)" -> "recv_parse_or_apply_log_rec_body(unsigned char,unsigned char*,unsigned char*,buf_block_t*,mtr_t*,ulint)"
"recv_recover_page_func(ulint,buf_block_t*)" -> "recv_get_fil_addr_struct(ulint,ulint)"
"recv_recover_page_func(ulint,buf_block_t*)" -> "buf_page_get_known_nowait(ulint,buf_block_t*,ulint,const char*,ulint,mtr_t*)"
"recv_recover_page_func(ulint,buf_block_t*)" -> "pfs_mutex_enter_func(ib_mutex_t*,const char*,ulint)"
"recv_recover_page_func(ulint,buf_block_t*)" -> "mtr_commit(mtr_t*)"
"recv_recover_page_func(ulint,buf_block_t*)" -> "ut_dbg_assertion_failed(const char*,const char*,ulint)"
"recv_recover_page_func(ulint,buf_block_t*)" -> "buf_page_get_newest_modification(const buf_page_t*)"
"recv_recover_page_func(ulint,buf_block_t*)" -> "mem_alloc_func(ulint,ulint*)"
"recv_recover_page_func(ulint,buf_block_t*)" -> "buf_block_get_page_no(const buf_block_t*)"
"recv_recover_page_func(ulint,buf_block_t*)" -> "mtr_start(mtr_t*)"
"recv_recover_page_func(ulint,buf_block_t*)" -> "mtr_set_log_mode(mtr_t*,ulint)"
"recv_recover_page_func(ulint,buf_block_t*)" -> "mach_read_from_8(const unsigned char*)"
"recv_recover_page_func(ulint,buf_block_t*)" -> "buf_block_get_space(const buf_block_t*)"
"recv_recover_page_func(ulint,buf_block_t*)" -> "recv_data_copy_to_buf(unsigned char*,recv_t*)"
"recv_recover_page_func(ulint,buf_block_t*)" -> "__builtin_expect(long int,long int)"
"recv_recover_page_func(ulint,buf_block_t*)" -> "memset(void*,int,size_t)"
"recv_recover_page_func(ulint,buf_block_t*)" -> "rw_lock_x_lock_move_ownership(rw_lock_t*)"
"recv_recover_page_func(ulint,buf_block_t*)" -> "mem_free_func(void*,const char*,ulint)"
"buf_flush_recv_note_modification(buf_block_t*,lsn_t,lsn_t)" -> "buf_pool_from_block(const buf_block_t*)"
"buf_flush_recv_note_modification(buf_block_t*,lsn_t,lsn_t)" -> "buf_flush_insert_sorted_into_flush_list(buf_pool_t*,buf_block_t*,lsn_t)"
"buf_flush_recv_note_modification(buf_block_t*,lsn_t,lsn_t)" -> "pfs_mutex_enter_func(ib_mutex_t*,const char*,ulint)"
"buf_flush_recv_note_modification(buf_block_t*,lsn_t,lsn_t)" -> "pfs_mutex_exit_func(ib_mutex_t*)"
"buf_flush_insert_sorted_into_flush_list(buf_pool_t*,buf_block_t*,lsn_t)" -> "buf_flush_insert_in_flush_rbt(buf_page_t*)"
"buf_flush_insert_sorted_into_flush_list(buf_pool_t*,buf_block_t*,lsn_t)" -> "incr_flush_list_size_in_bytes(buf_block_t*,buf_pool_t*)"
"buf_flush_insert_sorted_into_flush_list(buf_pool_t*,buf_block_t*,lsn_t)" -> "pfs_mutex_enter_func(ib_mutex_t*,const char*,ulint)"
"buf_flush_insert_sorted_into_flush_list(buf_pool_t*,buf_block_t*,lsn_t)" -> "ut_list_insert(List&,Type&,Type&,size_t) [with List = ut_list_base<buf_page_t>,Type = buf_page_t,size_t = long unsigned int]"
"buf_flush_insert_sorted_into_flush_list(buf_pool_t*,buf_block_t*,lsn_t)" -> "ut_list_prepend(List&,Type&,size_t) [with List = ut_list_base<buf_page_t>,Type = buf_page_t,size_t = long unsigned int]"
"buf_flush_insert_sorted_into_flush_list(buf_pool_t*,buf_block_t*,lsn_t)" -> "pfs_mutex_exit_func(ib_mutex_t*)"
"buf_flush_insert_in_flush_rbt(buf_page_t*)" -> "abort()"
"buf_flush_insert_in_flush_rbt(buf_page_t*)" -> "buf_pool_from_bpage(const buf_page_t*)"
"buf_flush_insert_in_flush_rbt(buf_page_t*)" -> "rbt_insert(ib_rbt_t*,const void*,const void*)"
"buf_flush_insert_in_flush_rbt(buf_page_t*)" -> "ut_dbg_assertion_failed(const char*,const char*,ulint)"
"buf_flush_insert_in_flush_rbt(buf_page_t*)" -> "__builtin_expect(long int,long int)"
"buf_flush_insert_in_flush_rbt(buf_page_t*)" -> "rbt_prev(const ib_rbt_t*,const ib_rbt_node_t*)"
"rbt_insert(ib_rbt_t*,const void*,const void*)" -> "ut_malloc_low(ulint,ulint)"
"rbt_insert(ib_rbt_t*,const void*,const void*)" -> "rbt_balance_tree(const ib_rbt_t*,ib_rbt_node_t*)"
"rbt_insert(ib_rbt_t*,const void*,const void*)" -> "rbt_tree_insert(ib_rbt_t*,const void*,ib_rbt_node_t*)"
"rbt_insert(ib_rbt_t*,const void*,const void*)" -> "memcpy(void*,const void*,size_t)"
"ut_malloc_low(ulint,ulint)" -> "ut_print_timestamp(FILE*)"
"ut_malloc_low(ulint,ulint)" -> "pfs_os_fast_mutex_lock(os_fast_mutex_t*,const char*,ulint)"
"ut_malloc_low(ulint,ulint)" -> "os_thread_sleep(ulint)"
"ut_malloc_low(ulint,ulint)" -> "__builtin_expect(long int,long int)"
"ut_malloc_low(ulint,ulint)" -> "pfs_os_fast_mutex_unlock(os_fast_mutex_t*)"
"ut_malloc_low(ulint,ulint)" -> "fflush(FILE*)"
"ut_malloc_low(ulint,ulint)" -> "abort()"
"ut_malloc_low(ulint,ulint)" -> "malloc(size_t)"
"ut_malloc_low(ulint,ulint)" -> "ut_dbg_assertion_failed(const char*,const char*,ulint)"
"ut_malloc_low(ulint,ulint)" -> "ut_list_prepend(List&,Type&,size_t) [with List = ut_list_base<ut_mem_block_t>,Type = ut_mem_block_t,size_t = long unsigned int]"
"ut_malloc_low(ulint,ulint)" -> "__builtin_fwrite(const void*,size_t,size_t,FILE*)"
"ut_malloc_low(ulint,ulint)" -> "fprintf(FILE*,const char*,...)"
"ut_malloc_low(ulint,ulint)" -> "__errno_location()"
"ut_list_prepend(List&,Type&,size_t) [with List = ut_list_base<ut_mem_block_t>,Type = ut_mem_block_t,size_t = long unsigned int]" -> "ut_elem_get_node(Type&,size_t) [with Type = ut_mem_block_t,size_t = long unsigned int]"
"rbt_balance_tree(const ib_rbt_t*,ib_rbt_node_t*)" -> "rbt_rotate_left(const ib_rbt_node_t*,ib_rbt_node_t*)"
"rbt_balance_tree(const ib_rbt_t*,ib_rbt_node_t*)" -> "rbt_rotate_right(const ib_rbt_node_t*,ib_rbt_node_t*)"
"rbt_tree_insert(ib_rbt_t*,const void*,ib_rbt_node_t*)" -> "rbt_tree_add_child(const ib_rbt_t*,ib_rbt_bound_t*,ib_rbt_node_t*)"
"rbt_tree_insert(ib_rbt_t*,const void*,ib_rbt_node_t*)" -> "ut_dbg_assertion_failed(const char*,const char*,ulint)"
"rbt_tree_insert(ib_rbt_t*,const void*,ib_rbt_node_t*)" -> "abort()"
"rbt_tree_insert(ib_rbt_t*,const void*,ib_rbt_node_t*)" -> "__builtin_expect(long int,long int)"
"rbt_tree_add_child(const ib_rbt_t*,ib_rbt_bound_t*,ib_rbt_node_t*)" -> "abort()"
"rbt_tree_add_child(const ib_rbt_t*,ib_rbt_bound_t*,ib_rbt_node_t*)" -> "__builtin_expect(long int,long int)"
"rbt_tree_add_child(const ib_rbt_t*,ib_rbt_bound_t*,ib_rbt_node_t*)" -> "ut_dbg_assertion_failed(const char*,const char*,ulint)"
"rbt_prev(const ib_rbt_t*,const ib_rbt_node_t*)" -> "rbt_find_predecessor(const ib_rbt_t*,const ib_rbt_node_t*)"
"incr_flush_list_size_in_bytes(buf_block_t*,buf_pool_t*)" -> "page_zip_get_size(const page_zip_des_t*)"
"ut_list_insert(List&,Type&,Type&,size_t) [with List = ut_list_base<buf_page_t>,Type = buf_page_t,size_t = long unsigned int]" -> "ut_elem_get_node(Type&,size_t) [with Type = buf_page_t,size_t = long unsigned int]"
"mach_write_to_8(void*,ib_uint64_t)" -> "mach_write_to_4(unsigned char*,ulint)"
"recv_parse_or_apply_log_rec_body(unsigned char,unsigned char*,unsigned char*,buf_block_t*,mtr_t*,ulint)" -> "page_parse_copy_rec_list_to_created_page(unsigned char*,unsigned char*,buf_block_t*,dict_index_t*,mtr_t*)"
"recv_parse_or_apply_log_rec_body(unsigned char,unsigned char*,unsigned char*,buf_block_t*,mtr_t*,ulint)" -> "dict_mem_table_free(dict_table_t*)"
"recv_parse_or_apply_log_rec_body(unsigned char,unsigned char*,unsigned char*,buf_block_t*,mtr_t*,ulint)" -> "__builtin_expect(long int,long int)"
"recv_parse_or_apply_log_rec_body(unsigned char,unsigned char*,unsigned char*,buf_block_t*,mtr_t*,ulint)" -> "page_zip_parse_compress(unsigned char*,unsigned char*,ib_page_t*,page_zip_des_t*)"
"recv_parse_or_apply_log_rec_body(unsigned char,unsigned char*,unsigned char*,buf_block_t*,mtr_t*,ulint)" -> "fil_op_log_parse_or_replay(unsigned char*,unsigned char*,ulint,ulint,ulint)"
"recv_parse_or_apply_log_rec_body(unsigned char,unsigned char*,unsigned char*,buf_block_t*,mtr_t*,ulint)" -> "page_cur_parse_insert_rec(ulint,unsigned char*,unsigned char*,buf_block_t*,dict_index_t*,mtr_t*)"
"recv_parse_or_apply_log_rec_body(unsigned char,unsigned char*,unsigned char*,buf_block_t*,mtr_t*,ulint)" -> "btr_parse_page_reorganize(unsigned char*,unsigned char*,dict_index_t*,bool,buf_block_t*,mtr_t*)"
"recv_parse_or_apply_log_rec_body(unsigned char,unsigned char*,unsigned char*,buf_block_t*,mtr_t*,ulint)" -> "page_parse_create(unsigned char*,unsigned char*,ulint,buf_block_t*,mtr_t*)"
"recv_parse_or_apply_log_rec_body(unsigned char,unsigned char*,unsigned char*,buf_block_t*,mtr_t*,ulint)" -> "page_zip_parse_write_header(unsigned char*,unsigned char*,ib_page_t*,page_zip_des_t*)"
"recv_parse_or_apply_log_rec_body(unsigned char,unsigned char*,unsigned char*,buf_block_t*,mtr_t*,ulint)" -> "dict_mem_index_free(dict_index_t*)"
"recv_parse_or_apply_log_rec_body(unsigned char,unsigned char*,unsigned char*,buf_block_t*,mtr_t*,ulint)" -> "dict_table_is_comp(const dict_table_t*)"
"recv_parse_or_apply_log_rec_body(unsigned char,unsigned char*,unsigned char*,buf_block_t*,mtr_t*,ulint)" -> "page_zip_parse_compress_no_data(unsigned char*,unsigned char*,ib_page_t*,page_zip_des_t*,dict_index_t*)"
"recv_parse_or_apply_log_rec_body(unsigned char,unsigned char*,unsigned char*,buf_block_t*,mtr_t*,ulint)" -> "btr_parse_set_min_rec_mark(unsigned char*,unsigned char*,ulint,ib_page_t*,mtr_t*)"
"recv_parse_or_apply_log_rec_body(unsigned char,unsigned char*,unsigned char*,buf_block_t*,mtr_t*,ulint)" -> "fsp_parse_init_file_page(unsigned char*,unsigned char*,buf_block_t*)"
"recv_parse_or_apply_log_rec_body(unsigned char,unsigned char*,unsigned char*,buf_block_t*,mtr_t*,ulint)" -> "trx_undo_parse_discard_latest(unsigned char*,unsigned char*,ib_page_t*,mtr_t*)"
"recv_parse_or_apply_log_rec_body(unsigned char,unsigned char*,unsigned char*,buf_block_t*,mtr_t*,ulint)" -> "trx_undo_parse_page_header(ulint,unsigned char*,unsigned char*,ib_page_t*,mtr_t*)"
"recv_parse_or_apply_log_rec_body(unsigned char,unsigned char*,unsigned char*,buf_block_t*,mtr_t*,ulint)" -> "trx_undo_parse_page_init(unsigned char*,unsigned char*,ib_page_t*,mtr_t*)"
"recv_parse_or_apply_log_rec_body(unsigned char,unsigned char*,unsigned char*,buf_block_t*,mtr_t*,ulint)" -> "page_cur_parse_delete_rec(unsigned char*,unsigned char*,buf_block_t*,dict_index_t*,mtr_t*)"
"recv_parse_or_apply_log_rec_body(unsigned char,unsigned char*,unsigned char*,buf_block_t*,mtr_t*,ulint)" -> "mlog_parse_string(unsigned char*,unsigned char*,unsigned char*,void*)"
"recv_parse_or_apply_log_rec_body(unsigned char,unsigned char*,unsigned char*,buf_block_t*,mtr_t*,ulint)" -> "page_is_comp(const ib_page_t*)"
"recv_parse_or_apply_log_rec_body(unsigned char,unsigned char*,unsigned char*,buf_block_t*,mtr_t*,ulint)" -> "mlog_parse_nbytes(ulint,unsigned char*,unsigned char*,unsigned char*,void*)"
"recv_parse_or_apply_log_rec_body(unsigned char,unsigned char*,unsigned char*,buf_block_t*,mtr_t*,ulint)" -> "abort()"
"recv_parse_or_apply_log_rec_body(unsigned char,unsigned char*,unsigned char*,buf_block_t*,mtr_t*,ulint)" -> "btr_cur_parse_del_mark_set_sec_rec(unsigned char*,unsigned char*,ib_page_t*,page_zip_des_t*)"
"recv_parse_or_apply_log_rec_body(unsigned char,unsigned char*,unsigned char*,buf_block_t*,mtr_t*,ulint)" -> "page_zip_parse_write_blob_ptr(unsigned char*,unsigned char*,ib_page_t*,page_zip_des_t*)"
"recv_parse_or_apply_log_rec_body(unsigned char,unsigned char*,unsigned char*,buf_block_t*,mtr_t*,ulint)" -> "page_zip_parse_write_node_ptr(unsigned char*,unsigned char*,ib_page_t*,page_zip_des_t*)"
"recv_parse_or_apply_log_rec_body(unsigned char,unsigned char*,unsigned char*,buf_block_t*,mtr_t*,ulint)" -> "ibuf_parse_bitmap_init(unsigned char*,unsigned char*,buf_block_t*,mtr_t*)"
"recv_parse_or_apply_log_rec_body(unsigned char,unsigned char*,unsigned char*,buf_block_t*,mtr_t*,ulint)" -> "trx_undo_parse_erase_page_end(unsigned char*,unsigned char*,ib_page_t*,mtr_t*)"
"recv_parse_or_apply_log_rec_body(unsigned char,unsigned char*,unsigned char*,buf_block_t*,mtr_t*,ulint)" -> "btr_cur_parse_update_in_place(unsigned char*,unsigned char*,ib_page_t*,page_zip_des_t*,dict_index_t*)"
"recv_parse_or_apply_log_rec_body(unsigned char,unsigned char*,unsigned char*,buf_block_t*,mtr_t*,ulint)" -> "mlog_parse_index(unsigned char*,const unsigned char*,ulint,dict_index_t**)"
"recv_parse_or_apply_log_rec_body(unsigned char,unsigned char*,unsigned char*,buf_block_t*,mtr_t*,ulint)" -> "ut_dbg_assertion_failed(const char*,const char*,ulint)"
"recv_parse_or_apply_log_rec_body(unsigned char,unsigned char*,unsigned char*,buf_block_t*,mtr_t*,ulint)" -> "btr_cur_parse_del_mark_set_clust_rec(unsigned char*,unsigned char*,ib_page_t*,page_zip_des_t*,dict_index_t*)"
"recv_parse_or_apply_log_rec_body(unsigned char,unsigned char*,unsigned char*,buf_block_t*,mtr_t*,ulint)" -> "page_parse_delete_rec_list(unsigned char,unsigned char*,unsigned char*,buf_block_t*,dict_index_t*,mtr_t*)"
"recv_parse_or_apply_log_rec_body(unsigned char,unsigned char*,unsigned char*,buf_block_t*,mtr_t*,ulint)" -> "trx_undo_parse_add_undo_rec(unsigned char*,unsigned char*,ib_page_t*)"
"page_parse_copy_rec_list_to_created_page(unsigned char*,unsigned char*,buf_block_t*,dict_index_t*,mtr_t*)" -> "page_header_set_field(ib_page_t*,page_zip_des_t*,ulint,ulint)"
"page_parse_copy_rec_list_to_created_page(unsigned char*,unsigned char*,buf_block_t*,dict_index_t*,mtr_t*)" -> "page_cur_parse_insert_rec(ulint,unsigned char*,unsigned char*,buf_block_t*,dict_index_t*,mtr_t*)"
"page_parse_copy_rec_list_to_created_page(unsigned char*,unsigned char*,buf_block_t*,dict_index_t*,mtr_t*)" -> "__builtin_expect(long int,long int)"
"page_parse_copy_rec_list_to_created_page(unsigned char*,unsigned char*,buf_block_t*,dict_index_t*,mtr_t*)" -> "page_header_set_ptr(ib_page_t*,page_zip_des_t*,ulint,const unsigned char*)"
"page_parse_copy_rec_list_to_created_page(unsigned char*,unsigned char*,buf_block_t*,dict_index_t*,mtr_t*)" -> "abort()"
"page_parse_copy_rec_list_to_created_page(unsigned char*,unsigned char*,buf_block_t*,dict_index_t*,mtr_t*)" -> "ut_dbg_assertion_failed(const char*,const char*,ulint)"
"page_parse_copy_rec_list_to_created_page(unsigned char*,unsigned char*,buf_block_t*,dict_index_t*,mtr_t*)" -> "mach_read_from_4(const unsigned char*)"
"page_header_set_field(ib_page_t*,page_zip_des_t*,ulint,ulint)" -> "page_zip_write_header(page_zip_des_t*,const unsigned char*,ulint,mtr_t*)"
"page_header_set_field(ib_page_t*,page_zip_des_t*,ulint,ulint)" -> "mach_write_to_2(unsigned char*,ulint)"
"page_zip_write_header(page_zip_des_t*,const unsigned char*,ulint,mtr_t*)" -> "page_zip_write_header_log(const unsigned char*,ulint,mtr_t*)"
"page_zip_write_header(page_zip_des_t*,const unsigned char*,ulint,mtr_t*)" -> "page_offset(const void*)"
"page_zip_write_header(page_zip_des_t*,const unsigned char*,ulint,mtr_t*)" -> "memcpy(void*,const void*,size_t)"
"page_zip_write_header_log(const unsigned char*,ulint,mtr_t*)" -> "page_offset(const void*)"
"page_zip_write_header_log(const unsigned char*,ulint,mtr_t*)" -> "mlog_write_initial_log_record_fast(const unsigned char*,unsigned char,unsigned char*,mtr_t*)"
"page_zip_write_header_log(const unsigned char*,ulint,mtr_t*)" -> "mlog_catenate_string(mtr_t*,const unsigned char*,ulint)"
"page_zip_write_header_log(const unsigned char*,ulint,mtr_t*)" -> "__builtin_expect(long int,long int)"
"page_zip_write_header_log(const unsigned char*,ulint,mtr_t*)" -> "mlog_close(mtr_t*,unsigned char*)"
"page_zip_write_header_log(const unsigned char*,ulint,mtr_t*)" -> "mlog_open(mtr_t*,ulint)"
"mlog_write_initial_log_record_fast(const unsigned char*,unsigned char,unsigned char*,mtr_t*)" -> "ut_align_down(const void*,ulint)"
"mlog_write_initial_log_record_fast(const unsigned char*,unsigned char,unsigned char*,mtr_t*)" -> "mach_write_compressed(unsigned char*,ulint)"
"mlog_write_initial_log_record_fast(const unsigned char*,unsigned char,unsigned char*,mtr_t*)" -> "mach_write_to_1(unsigned char*,ulint)"
"mlog_write_initial_log_record_fast(const unsigned char*,unsigned char,unsigned char*,mtr_t*)" -> "mach_read_from_4(const unsigned char*)"
"mlog_write_initial_log_record_fast(const unsigned char*,unsigned char,unsigned char*,mtr_t*)" -> "fprintf(FILE*,const char*,...)"
"mach_write_compressed(unsigned char*,ulint)" -> "mach_write_to_3(unsigned char*,ulint)"
"mach_write_compressed(unsigned char*,ulint)" -> "mach_write_to_4(unsigned char*,ulint)"
"mach_write_compressed(unsigned char*,ulint)" -> "mach_write_to_1(unsigned char*,ulint)"
"mach_write_compressed(unsigned char*,ulint)" -> "mach_write_to_2(unsigned char*,ulint)"
"mlog_catenate_string(mtr_t*,const unsigned char*,ulint)" -> "mtr_get_log_mode(mtr_t*)"
"mlog_catenate_string(mtr_t*,const unsigned char*,ulint)" -> "dyn_push_string(dyn_array_t*,const unsigned char*,ulint)"
"dyn_push_string(dyn_array_t*,const unsigned char*,ulint)" -> "dyn_array_push(dyn_array_t*,ulint)"
"dyn_push_string(dyn_array_t*,const unsigned char*,ulint)" -> "memcpy(void*,const void*,size_t)"
"mlog_close(mtr_t*,unsigned char*)" -> "dyn_array_close(dyn_array_t*,const unsigned char*)"
"mlog_open(mtr_t*,ulint)" -> "mtr_get_log_mode(mtr_t*)"
"mlog_open(mtr_t*,ulint)" -> "dyn_array_open(dyn_array_t*,ulint)"
"dyn_array_open(dyn_array_t*,ulint)" -> "abort()"
"dyn_array_open(dyn_array_t*,ulint)" -> "__builtin_expect(long int,long int)"
"dyn_array_open(dyn_array_t*,ulint)" -> "dyn_array_add_block(dyn_array_t*)"
"dyn_array_open(dyn_array_t*,ulint)" -> "ut_dbg_assertion_failed(const char*,const char*,ulint)"
"page_cur_parse_insert_rec(ulint,unsigned char*,unsigned char*,buf_block_t*,dict_index_t*,mtr_t*)" -> "mem_heap_free_func(mem_heap_t*,const char*,ulint)"
"page_cur_parse_insert_rec(ulint,unsigned char*,unsigned char*,buf_block_t*,dict_index_t*,mtr_t*)" -> "mem_free_func(void*,const char*,ulint)"
"page_cur_parse_insert_rec(ulint,unsigned char*,unsigned char*,buf_block_t*,dict_index_t*,mtr_t*)" -> "__builtin_fwrite(const void*,size_t,size_t,FILE*)"
"page_cur_parse_insert_rec(ulint,unsigned char*,unsigned char*,buf_block_t*,dict_index_t*,mtr_t*)" -> "ut_print_buf(FILE*,const void*,ulint)"
"page_cur_parse_insert_rec(ulint,unsigned char*,unsigned char*,buf_block_t*,dict_index_t*,mtr_t*)" -> "rec_set_info_bits_old(rec_t*,ulint)"
"page_cur_parse_insert_rec(ulint,unsigned char*,unsigned char*,buf_block_t*,dict_index_t*,mtr_t*)" -> "buf_page_print(const unsigned char*,ulint,ulint)"
"page_cur_parse_insert_rec(ulint,unsigned char*,unsigned char*,buf_block_t*,dict_index_t*,mtr_t*)" -> "abort()"
"page_cur_parse_insert_rec(ulint,unsigned char*,unsigned char*,buf_block_t*,dict_index_t*,mtr_t*)" -> "page_is_comp(const ib_page_t*)"
"page_cur_parse_insert_rec(ulint,unsigned char*,unsigned char*,buf_block_t*,dict_index_t*,mtr_t*)" -> "page_offset(const void*)"
"page_cur_parse_insert_rec(ulint,unsigned char*,unsigned char*,buf_block_t*,dict_index_t*,mtr_t*)" -> "_IO_putc(int,_IO_FILE*)"
"page_cur_parse_insert_rec(ulint,unsigned char*,unsigned char*,buf_block_t*,dict_index_t*,mtr_t*)" -> "ut_dbg_assertion_failed(const char*,const char*,ulint)"
"page_cur_parse_insert_rec(ulint,unsigned char*,unsigned char*,buf_block_t*,dict_index_t*,mtr_t*)" -> "__builtin_expect(long int,long int)"
"page_cur_parse_insert_rec(ulint,unsigned char*,unsigned char*,buf_block_t*,dict_index_t*,mtr_t*)" -> "rec_offs_extra_size(const ulint*)"
"page_cur_parse_insert_rec(ulint,unsigned char*,unsigned char*,buf_block_t*,dict_index_t*,mtr_t*)" -> "rec_get_info_and_status_bits(const rec_t*,ulint)"
"page_cur_parse_insert_rec(ulint,unsigned char*,unsigned char*,buf_block_t*,dict_index_t*,mtr_t*)" -> "fprintf(FILE*,const char*,...)"
"page_cur_parse_insert_rec(ulint,unsigned char*,unsigned char*,buf_block_t*,dict_index_t*,mtr_t*)" -> "mem_alloc_func(ulint,ulint*)"
"page_cur_parse_insert_rec(ulint,unsigned char*,unsigned char*,buf_block_t*,dict_index_t*,mtr_t*)" -> "mach_parse_compressed(unsigned char*,unsigned char*,ulint*)"
"page_cur_parse_insert_rec(ulint,unsigned char*,unsigned char*,buf_block_t*,dict_index_t*,mtr_t*)" -> "rec_offs_size(const ulint*)"
"page_cur_parse_insert_rec(ulint,unsigned char*,unsigned char*,buf_block_t*,dict_index_t*,mtr_t*)" -> "rec_set_info_and_status_bits(rec_t*,ulint)"
"page_cur_parse_insert_rec(ulint,unsigned char*,unsigned char*,buf_block_t*,dict_index_t*,mtr_t*)" -> "mach_read_from_2(const unsigned char*)"
"page_cur_parse_insert_rec(ulint,unsigned char*,unsigned char*,buf_block_t*,dict_index_t*,mtr_t*)" -> "rec_offs_set_n_alloc(ulint*,ulint)"
"page_cur_parse_insert_rec(ulint,unsigned char*,unsigned char*,buf_block_t*,dict_index_t*,mtr_t*)" -> "page_cur_rec_insert(page_cur_t*,const rec_t*,dict_index_t*,ulint*,mtr_t*)"
"page_cur_parse_insert_rec(ulint,unsigned char*,unsigned char*,buf_block_t*,dict_index_t*,mtr_t*)" -> "mach_read_from_1(const unsigned char*)"
"page_cur_parse_insert_rec(ulint,unsigned char*,unsigned char*,buf_block_t*,dict_index_t*,mtr_t*)" -> "page_rec_get_prev(rec_t*)"
"page_cur_parse_insert_rec(ulint,unsigned char*,unsigned char*,buf_block_t*,dict_index_t*,mtr_t*)" -> "page_get_supremum_offset(const ib_page_t*)"
"page_cur_parse_insert_rec(ulint,unsigned char*,unsigned char*,buf_block_t*,dict_index_t*,mtr_t*)" -> "rec_get_offsets_func(const rec_t*,const dict_index_t*,ulint*,ulint,mem_heap_t**)"
"page_cur_parse_insert_rec(ulint,unsigned char*,unsigned char*,buf_block_t*,dict_index_t*,mtr_t*)" -> "ut_memcpy(void*,const void*,ulint)"
"page_cur_parse_insert_rec(ulint,unsigned char*,unsigned char*,buf_block_t*,dict_index_t*,mtr_t*)" -> "page_cur_position(const rec_t*,const buf_block_t*,page_cur_t*)"
"mem_heap_free_func(mem_heap_t*,const char*,ulint)" -> "mem_heap_free_block_free(mem_heap_t*)"
"mem_heap_free_func(mem_heap_t*,const char*,ulint)" -> "mem_heap_block_free(mem_heap_t*,mem_block_t*)"
"mem_heap_free_block_free(mem_heap_t*)" -> "__builtin_expect(long int,long int)"
"mem_heap_free_block_free(mem_heap_t*)" -> "buf_block_free(buf_block_t*)"
"buf_block_free(buf_block_t*)" -> "buf_block_get_state(const buf_block_t*)"
"buf_block_free(buf_block_t*)" -> "abort()"
"buf_block_free(buf_block_t*)" -> "pfs_mutex_enter_func(ib_mutex_t*,const char*,ulint)"
"buf_block_free(buf_block_t*)" -> "pfs_mutex_exit_func(ib_mutex_t*)"
"buf_block_free(buf_block_t*)" -> "buf_LRU_block_free_non_file_page(buf_block_t*)"
"buf_block_free(buf_block_t*)" -> "ut_dbg_assertion_failed(const char*,const char*,ulint)"
"buf_block_free(buf_block_t*)" -> "__builtin_expect(long int,long int)"
"buf_block_free(buf_block_t*)" -> "buf_pool_from_bpage(const buf_page_t*)"
"mem_heap_block_free(mem_heap_t*,mem_block_t*)" -> "ut_list_remove(List&,Type&,size_t) [with List = ut_list_base<mem_block_info_t>,Type = mem_block_info_t,size_t = long unsigned int]"
"mem_heap_block_free(mem_heap_t*,mem_block_t*)" -> "mem_area_free(void*,mem_pool_t*)"
"mem_heap_block_free(mem_heap_t*,mem_block_t*)" -> "buf_block_free(buf_block_t*)"
"mem_heap_block_free(mem_heap_t*,mem_block_t*)" -> "mem_analyze_corruption(void*)"
"ut_list_remove(List&,Type&,size_t) [with List = ut_list_base<mem_block_info_t>,Type = mem_block_info_t,size_t = long unsigned int]" -> "__builtin_expect(long int,long int)"
"ut_list_remove(List&,Type&,size_t) [with List = ut_list_base<mem_block_info_t>,Type = mem_block_info_t,size_t = long unsigned int]" -> "ut_elem_get_node(Type&,size_t) [with Type = mem_block_info_t,size_t = long unsigned int]"
"ut_list_remove(List&,Type&,size_t) [with List = ut_list_base<mem_block_info_t>,Type = mem_block_info_t,size_t = long unsigned int]" -> "abort()"
"ut_list_remove(List&,Type&,size_t) [with List = ut_list_base<mem_block_info_t>,Type = mem_block_info_t,size_t = long unsigned int]" -> "ut_dbg_assertion_failed(const char*,const char*,ulint)"
"ut_elem_get_node(Type&,size_t) [with Type = mem_block_info_t,size_t = long unsigned int]" -> "abort()"
"ut_elem_get_node(Type&,size_t) [with Type = mem_block_info_t,size_t = long unsigned int]" -> "ut_dbg_assertion_failed(const char*,const char*,ulint)"
"ut_elem_get_node(Type&,size_t) [with Type = mem_block_info_t,size_t = long unsigned int]" -> "__builtin_expect(long int,long int)"
"mem_area_free(void*,mem_pool_t*)" -> "__builtin_fwrite(const void*,size_t,size_t,FILE*)"
"mem_area_free(void*,mem_pool_t*)" -> "mem_area_get_buddy(mem_area_t*,ulint,mem_pool_t*)"
"mem_area_free(void*,mem_pool_t*)" -> "ut_free(void*)"
"mem_area_free(void*,mem_pool_t*)" -> "__builtin_expect(long int,long int)"
"mem_area_free(void*,mem_pool_t*)" -> "mem_area_set_free(mem_area_t*,ulint)"
"mem_area_free(void*,mem_pool_t*)" -> "abort()"
"mem_area_free(void*,mem_pool_t*)" -> "fprintf(FILE*,const char*,...)"
"mem_area_free(void*,mem_pool_t*)" -> "ut_2_log(ulint)"
"mem_area_free(void*,mem_pool_t*)" -> "mem_pool_mutex_enter(mem_pool_t*)"
"mem_area_free(void*,mem_pool_t*)" -> "ut_2_exp(ulint)"
"mem_area_free(void*,mem_pool_t*)" -> "mem_analyze_corruption(void*)"
"mem_area_free(void*,mem_pool_t*)" -> "mem_pool_mutex_exit(mem_pool_t*)"
"mem_area_free(void*,mem_pool_t*)" -> "mem_area_get_free(mem_area_t*)"
"mem_area_free(void*,mem_pool_t*)" -> "mem_area_get_size(mem_area_t*)"
"mem_area_free(void*,mem_pool_t*)" -> "mem_area_set_size(mem_area_t*,ulint)"
"mem_area_free(void*,mem_pool_t*)" -> "free(void*)"
"mem_area_free(void*,mem_pool_t*)" -> "ut_list_remove(List&,Type&,size_t) [with List = ut_list_base<mem_area_t>,Type = mem_area_t,size_t = long unsigned int]"
"mem_area_free(void*,mem_pool_t*)" -> "ut_list_prepend(List&,Type&,size_t) [with List = ut_list_base<mem_area_t>,Type = mem_area_t,size_t = long unsigned int]"
"mem_area_free(void*,mem_pool_t*)" -> "mem_area_free(void*,mem_pool_t*)"
"mem_area_free(void*,mem_pool_t*)" -> "ut_dbg_assertion_failed(const char*,const char*,ulint)"
"mem_pool_mutex_enter(mem_pool_t*)" -> "pfs_mutex_enter_func(ib_mutex_t*,const char*,ulint)"
"mem_pool_mutex_exit(mem_pool_t*)" -> "pfs_mutex_exit_func(ib_mutex_t*)"
"ut_list_remove(List&,Type&,size_t) [with List = ut_list_base<mem_area_t>,Type = mem_area_t,size_t = long unsigned int]" -> "abort()"
"ut_list_remove(List&,Type&,size_t) [with List = ut_list_base<mem_area_t>,Type = mem_area_t,size_t = long unsigned int]" -> "__builtin_expect(long int,long int)"
"ut_list_remove(List&,Type&,size_t) [with List = ut_list_base<mem_area_t>,Type = mem_area_t,size_t = long unsigned int]" -> "ut_dbg_assertion_failed(const char*,const char*,ulint)"
"ut_list_remove(List&,Type&,size_t) [with List = ut_list_base<mem_area_t>,Type = mem_area_t,size_t = long unsigned int]" -> "ut_elem_get_node(Type&,size_t) [with Type = mem_area_t,size_t = long unsigned int]"
"ut_elem_get_node(Type&,size_t) [with Type = mem_area_t,size_t = long unsigned int]" -> "abort()"
"ut_elem_get_node(Type&,size_t) [with Type = mem_area_t,size_t = long unsigned int]" -> "__builtin_expect(long int,long int)"
"ut_elem_get_node(Type&,size_t) [with Type = mem_area_t,size_t = long unsigned int]" -> "ut_dbg_assertion_failed(const char*,const char*,ulint)"
"ut_list_prepend(List&,Type&,size_t) [with List = ut_list_base<mem_area_t>,Type = mem_area_t,size_t = long unsigned int]" -> "ut_elem_get_node(Type&,size_t) [with Type = mem_area_t,size_t = long unsigned int]"
"mem_free_func(void*,const char*,ulint)" -> "mem_heap_free_func(mem_heap_t*,const char*,ulint)"
"rec_set_info_bits_old(rec_t*,ulint)" -> "rec_set_bit_field_1(rec_t*,ulint,ulint,ulint,ulint)"
"rec_set_bit_field_1(rec_t*,ulint,ulint,ulint,ulint)" -> "mach_write_to_1(unsigned char*,ulint)"
"rec_set_bit_field_1(rec_t*,ulint,ulint,ulint,ulint)" -> "mach_read_from_1(const unsigned char*)"
"rec_get_info_and_status_bits(const rec_t*,ulint)" -> "rec_get_info_bits(const rec_t*,ulint)"
"rec_get_info_and_status_bits(const rec_t*,ulint)" -> "rec_get_status(const rec_t*)"
"rec_get_info_bits(const rec_t*,ulint)" -> "rec_get_bit_field_1(const rec_t*,ulint,ulint,ulint)"
"rec_get_status(const rec_t*)" -> "rec_get_bit_field_1(const rec_t*,ulint,ulint,ulint)"
"mem_alloc_func(ulint,ulint*)" -> "mem_heap_create_func(ulint,ulint)"
"mem_alloc_func(ulint,ulint*)" -> "mem_block_get_free(mem_block_t*)"
"mem_alloc_func(ulint,ulint*)" -> "mem_heap_alloc(mem_heap_t*,ulint)"
"mem_alloc_func(ulint,ulint*)" -> "abort()"
"mem_alloc_func(ulint,ulint*)" -> "ut_dbg_assertion_failed(const char*,const char*,ulint)"
"mem_alloc_func(ulint,ulint*)" -> "__builtin_expect(long int,long int)"
"mem_alloc_func(ulint,ulint*)" -> "mem_block_get_len(mem_block_t*)"
"mem_heap_create_func(ulint,ulint)" -> "mem_heap_create_block_func(mem_heap_t*,ulint,ulint)"
"mem_heap_create_func(ulint,ulint)" -> "ut_list_prepend(List&,Type&,size_t) [with List = ut_list_base<mem_block_info_t>,Type = mem_block_info_t,size_t = long unsigned int]"
"ut_list_prepend(List&,Type&,size_t) [with List = ut_list_base<mem_block_info_t>,Type = mem_block_info_t,size_t = long unsigned int]" -> "ut_elem_get_node(Type&,size_t) [with Type = mem_block_info_t,size_t = long unsigned int]"
"mach_parse_compressed(unsigned char*,unsigned char*,ulint*)" -> "mach_read_from_2(const unsigned char*)"
"mach_parse_compressed(unsigned char*,unsigned char*,ulint*)" -> "mach_read_from_1(const unsigned char*)"
"mach_parse_compressed(unsigned char*,unsigned char*,ulint*)" -> "mach_read_from_3(const unsigned char*)"
"mach_parse_compressed(unsigned char*,unsigned char*,ulint*)" -> "mach_read_from_4(const unsigned char*)"
"rec_offs_size(const ulint*)" -> "rec_offs_data_size(const ulint*)"
"rec_offs_size(const ulint*)" -> "rec_offs_extra_size(const ulint*)"
"rec_offs_data_size(const ulint*)" -> "rec_offs_n_fields(const ulint*)"
"rec_set_info_and_status_bits(rec_t*,ulint)" -> "rec_set_status(rec_t*,ulint)"
"rec_set_info_and_status_bits(rec_t*,ulint)" -> "rec_set_info_bits_new(rec_t*,ulint)"
"rec_set_status(rec_t*,ulint)" -> "rec_set_bit_field_1(rec_t*,ulint,ulint,ulint,ulint)"
"rec_set_info_bits_new(rec_t*,ulint)" -> "rec_set_bit_field_1(rec_t*,ulint,ulint,ulint,ulint)"
"page_cur_rec_insert(page_cur_t*,const rec_t*,dict_index_t*,ulint*,mtr_t*)" -> "page_cur_insert_rec_zip(page_cur_t*,dict_index_t*,const rec_t*,ulint*,mtr_t*)"
"page_cur_rec_insert(page_cur_t*,const rec_t*,dict_index_t*,ulint*,mtr_t*)" -> "page_cur_insert_rec_low(rec_t*,dict_index_t*,const rec_t*,ulint*,mtr_t*)"
"page_cur_insert_rec_zip(page_cur_t*,dict_index_t*,const rec_t*,ulint*,mtr_t*)" -> "page_mem_alloc_free(ib_page_t*,page_zip_des_t*,rec_t*,ulint)"
"page_cur_insert_rec_zip(page_cur_t*,dict_index_t*,const rec_t*,ulint*,mtr_t*)" -> "rec_get_next_offs(const rec_t*,ulint)"
"page_cur_insert_rec_zip(page_cur_t*,dict_index_t*,const rec_t*,ulint*,mtr_t*)" -> "ut_dbg_assertion_failed(const char*,const char*,ulint)"
"page_cur_insert_rec_zip(page_cur_t*,dict_index_t*,const rec_t*,ulint*,mtr_t*)" -> "page_align(const void*)"
"page_cur_insert_rec_zip(page_cur_t*,dict_index_t*,const rec_t*,ulint*,mtr_t*)" -> "page_zip_reorganize(buf_block_t*,dict_index_t*,mtr_t*)"
"page_cur_insert_rec_zip(page_cur_t*,dict_index_t*,const rec_t*,ulint*,mtr_t*)" -> "mem_heap_free_func(mem_heap_t*,const char*,ulint)"
"page_cur_insert_rec_zip(page_cur_t*,dict_index_t*,const rec_t*,ulint*,mtr_t*)" -> "page_zip_write_rec(page_zip_des_t*,const unsigned char*,dict_index_t*,const ulint*,ulint)"
"page_cur_insert_rec_zip(page_cur_t*,dict_index_t*,const rec_t*,ulint*,mtr_t*)" -> "__builtin_expect(long int,long int)"
"page_cur_insert_rec_zip(page_cur_t*,dict_index_t*,const rec_t*,ulint*,mtr_t*)" -> "page_header_set_ptr(ib_page_t*,page_zip_des_t*,ulint,const unsigned char*)"
"page_cur_insert_rec_zip(page_cur_t*,dict_index_t*,const rec_t*,ulint*,mtr_t*)" -> "rec_get_next_ptr(rec_t*,ulint)"
"page_cur_insert_rec_zip(page_cur_t*,dict_index_t*,const rec_t*,ulint*,mtr_t*)" -> "page_zip_dir_insert(page_zip_des_t*,const unsigned char*,const unsigned char*,unsigned char*)"
"page_cur_insert_rec_zip(page_cur_t*,dict_index_t*,const rec_t*,ulint*,mtr_t*)" -> "page_rec_set_next(rec_t*,const rec_t*)"
"page_cur_insert_rec_zip(page_cur_t*,dict_index_t*,const rec_t*,ulint*,mtr_t*)" -> "rec_get_nth_field_offs(const ulint*,ulint,ulint*)"
"page_cur_insert_rec_zip(page_cur_t*,dict_index_t*,const rec_t*,ulint*,mtr_t*)" -> "page_zip_compress_write_log_no_data(ulint,const ib_page_t*,dict_index_t*,mtr_t*)"
"page_cur_insert_rec_zip(page_cur_t*,dict_index_t*,const rec_t*,ulint*,mtr_t*)" -> "rec_offs_size(const ulint*)"
"page_cur_insert_rec_zip(page_cur_t*,dict_index_t*,const rec_t*,ulint*,mtr_t*)" -> "page_zip_decompress(page_zip_des_t*,ib_page_t*,ulint)"
"page_cur_insert_rec_zip(page_cur_t*,dict_index_t*,const rec_t*,ulint*,mtr_t*)" -> "page_cur_insert_rec_low(rec_t*,dict_index_t*,const rec_t*,ulint*,mtr_t*)"
"page_cur_insert_rec_zip(page_cur_t*,dict_index_t*,const rec_t*,ulint*,mtr_t*)" -> "page_is_leaf(const ib_page_t*)"
"page_cur_insert_rec_zip(page_cur_t*,dict_index_t*,const rec_t*,ulint*,mtr_t*)" -> "page_mem_alloc_heap(ib_page_t*,page_zip_des_t*,ulint,ulint*)"
"page_cur_insert_rec_zip(page_cur_t*,dict_index_t*,const rec_t*,ulint*,mtr_t*)" -> "page_zip_compress(page_zip_des_t*,const ib_page_t*,dict_index_t*,ulint,mtr_t*)"
"page_cur_insert_rec_zip(page_cur_t*,dict_index_t*,const rec_t*,ulint*,mtr_t*)" -> "page_get_max_insert_size(const ib_page_t*,ulint)"
"page_cur_insert_rec_zip(page_cur_t*,dict_index_t*,const rec_t*,ulint*,mtr_t*)" -> "page_rec_get_n_recs_before(const rec_t*)"
"page_cur_insert_rec_zip(page_cur_t*,dict_index_t*,const rec_t*,ulint*,mtr_t*)" -> "page_header_get_offs(const ib_page_t*,ulint)"
"page_cur_insert_rec_zip(page_cur_t*,dict_index_t*,const rec_t*,ulint*,mtr_t*)" -> "rec_offs_extra_size(const ulint*)"
"page_cur_insert_rec_zip(page_cur_t*,dict_index_t*,const rec_t*,ulint*,mtr_t*)" -> "rec_offs_set_n_alloc(ulint*,ulint)"
"page_cur_insert_rec_zip(page_cur_t*,dict_index_t*,const rec_t*,ulint*,mtr_t*)" -> "page_zip_dir_add_slot(page_zip_des_t*,ulint)"
"page_cur_insert_rec_zip(page_cur_t*,dict_index_t*,const rec_t*,ulint*,mtr_t*)" -> "rec_set_n_owned_new(rec_t*,page_zip_des_t*,ulint)"
"page_cur_insert_rec_zip(page_cur_t*,dict_index_t*,const rec_t*,ulint*,mtr_t*)" -> "page_dir_split_slot(ib_page_t*,page_zip_des_t*,ulint)"
"page_cur_insert_rec_zip(page_cur_t*,dict_index_t*,const rec_t*,ulint*,mtr_t*)" -> "page_rec_get_nth(ib_page_t*,ulint)"
"page_cur_insert_rec_zip(page_cur_t*,dict_index_t*,const rec_t*,ulint*,mtr_t*)" -> "recv_recovery_is_on()"
"page_cur_insert_rec_zip(page_cur_t*,dict_index_t*,const rec_t*,ulint*,mtr_t*)" -> "abort()"
"page_cur_insert_rec_zip(page_cur_t*,dict_index_t*,const rec_t*,ulint*,mtr_t*)" -> "btr_page_reorganize_low(bool,ulint,page_cur_t*,dict_index_t*,mtr_t*)"
"page_cur_insert_rec_zip(page_cur_t*,dict_index_t*,const rec_t*,ulint*,mtr_t*)" -> "page_has_garbage(const ib_page_t*)"
"page_cur_insert_rec_zip(page_cur_t*,dict_index_t*,const rec_t*,ulint*,mtr_t*)" -> "rec_set_heap_no_new(rec_t*,ulint)"
"page_cur_insert_rec_zip(page_cur_t*,dict_index_t*,const rec_t*,ulint*,mtr_t*)" -> "rec_copy(void*,const rec_t*,const ulint*)"
"page_cur_insert_rec_zip(page_cur_t*,dict_index_t*,const rec_t*,ulint*,mtr_t*)" -> "page_create_zip(buf_block_t*,dict_index_t*,ulint,trx_id_t,mtr_t*)"
"page_cur_insert_rec_zip(page_cur_t*,dict_index_t*,const rec_t*,ulint*,mtr_t*)" -> "rec_get_offsets_func(const rec_t*,const dict_index_t*,ulint*,ulint,mem_heap_t**)"
"page_cur_insert_rec_zip(page_cur_t*,dict_index_t*,const rec_t*,ulint*,mtr_t*)" -> "memset(void*,int,size_t)"
"page_cur_insert_rec_zip(page_cur_t*,dict_index_t*,const rec_t*,ulint*,mtr_t*)" -> "page_zip_available(const page_zip_des_t*,ulint,ulint,ulint)"
"page_cur_insert_rec_zip(page_cur_t*,dict_index_t*,const rec_t*,ulint*,mtr_t*)" -> "page_get_max_insert_size_after_reorganize(const ib_page_t*,ulint)"
"page_cur_insert_rec_zip(page_cur_t*,dict_index_t*,const rec_t*,ulint*,mtr_t*)" -> "page_get_n_recs(const ib_page_t*)"
"page_cur_insert_rec_zip(page_cur_t*,dict_index_t*,const rec_t*,ulint*,mtr_t*)" -> "rec_offs_data_size(const ulint*)"
"page_cur_insert_rec_zip(page_cur_t*,dict_index_t*,const rec_t*,ulint*,mtr_t*)" -> "page_rec_get_next(rec_t*)"
"page_cur_insert_rec_zip(page_cur_t*,dict_index_t*,const rec_t*,ulint*,mtr_t*)" -> "page_rec_get_next_low(const rec_t*,ulint)"
"page_cur_insert_rec_zip(page_cur_t*,dict_index_t*,const rec_t*,ulint*,mtr_t*)" -> "page_rec_find_owner_rec(rec_t*)"
"page_cur_insert_rec_zip(page_cur_t*,dict_index_t*,const rec_t*,ulint*,mtr_t*)" -> "dict_index_is_clust(const dict_index_t*)"
"page_cur_insert_rec_zip(page_cur_t*,dict_index_t*,const rec_t*,ulint*,mtr_t*)" -> "page_dir_find_owner_slot(const rec_t*)"
"page_cur_insert_rec_zip(page_cur_t*,dict_index_t*,const rec_t*,ulint*,mtr_t*)" -> "rec_get_heap_no_new(const rec_t*)"
"page_cur_insert_rec_zip(page_cur_t*,dict_index_t*,const rec_t*,ulint*,mtr_t*)" -> "page_header_set_field(ib_page_t*,page_zip_des_t*,ulint,ulint)"
"page_cur_insert_rec_zip(page_cur_t*,dict_index_t*,const rec_t*,ulint*,mtr_t*)" -> "page_is_empty(const ib_page_t*)"
"page_cur_insert_rec_zip(page_cur_t*,dict_index_t*,const rec_t*,ulint*,mtr_t*)" -> "dict_index_get_sys_col_pos(const dict_index_t*,ulint)"
"page_cur_insert_rec_zip(page_cur_t*,dict_index_t*,const rec_t*,ulint*,mtr_t*)" -> "page_cur_insert_rec_write_log(rec_t*,ulint,rec_t*,dict_index_t*,mtr_t*)"
"page_cur_insert_rec_zip(page_cur_t*,dict_index_t*,const rec_t*,ulint*,mtr_t*)" -> "page_header_get_field(const ib_page_t*,ulint)"
"page_cur_insert_rec_zip(page_cur_t*,dict_index_t*,const rec_t*,ulint*,mtr_t*)" -> "rec_get_n_owned_new(const rec_t*)"
"page_mem_alloc_free(ib_page_t*,page_zip_des_t*,rec_t*,ulint)" -> "page_header_set_ptr(ib_page_t*,page_zip_des_t*,ulint,const unsigned char*)"
"page_mem_alloc_free(ib_page_t*,page_zip_des_t*,rec_t*,ulint)" -> "page_header_get_field(const ib_page_t*,ulint)"
"page_mem_alloc_free(ib_page_t*,page_zip_des_t*,rec_t*,ulint)" -> "page_header_set_field(ib_page_t*,page_zip_des_t*,ulint,ulint)"
"page_header_set_ptr(ib_page_t*,page_zip_des_t*,ulint,const unsigned char*)" -> "page_header_set_field(ib_page_t*,page_zip_des_t*,ulint,ulint)"
"page_zip_reorganize(buf_block_t*,dict_index_t*,mtr_t*)" -> "page_zip_compress(page_zip_des_t*,const ib_page_t*,dict_index_t*,ulint,mtr_t*)"
"page_zip_reorganize(buf_block_t*,dict_index_t*,mtr_t*)" -> "page_copy_rec_list_end_no_locks(buf_block_t*,buf_block_t*,rec_t*,dict_index_t*,mtr_t*)"
"page_zip_reorganize(buf_block_t*,dict_index_t*,mtr_t*)" -> "buf_pool_from_block(const buf_block_t*)"
"page_zip_reorganize(buf_block_t*,dict_index_t*,mtr_t*)" -> "page_get_max_trx_id(const ib_page_t*)"
"page_zip_reorganize(buf_block_t*,dict_index_t*,mtr_t*)" -> "mtr_set_log_mode(mtr_t*,ulint)"
"page_zip_reorganize(buf_block_t*,dict_index_t*,mtr_t*)" -> "page_create(buf_block_t*,mtr_t*,ulint)"
"page_zip_reorganize(buf_block_t*,dict_index_t*,mtr_t*)" -> "page_get_infimum_offset(const ib_page_t*)"
"page_zip_reorganize(buf_block_t*,dict_index_t*,mtr_t*)" -> "dict_index_is_clust(const dict_index_t*)"
"page_zip_reorganize(buf_block_t*,dict_index_t*,mtr_t*)" -> "buf_block_free(buf_block_t*)"
"page_zip_reorganize(buf_block_t*,dict_index_t*,mtr_t*)" -> "buf_block_alloc(buf_pool_t*)"
"page_zip_reorganize(buf_block_t*,dict_index_t*,mtr_t*)" -> "buf_frame_copy(unsigned char*,const buf_frame_t*)"
"page_zip_reorganize(buf_block_t*,dict_index_t*,mtr_t*)" -> "page_set_max_trx_id(buf_block_t*,page_zip_des_t*,trx_id_t,mtr_t*)"
"page_zip_reorganize(buf_block_t*,dict_index_t*,mtr_t*)" -> "lock_move_reorganize_page(const buf_block_t*,const buf_block_t*)"
"page_zip_reorganize(buf_block_t*,dict_index_t*,mtr_t*)" -> "btr_search_drop_page_hash_index(buf_block_t*)"
"page_zip_reorganize(buf_block_t*,dict_index_t*,mtr_t*)" -> "page_is_leaf(const ib_page_t*)"
"page_zip_compress(page_zip_des_t*,const ib_page_t*,dict_index_t*,ulint,mtr_t*)" -> "dict_index_get_n_fields(const dict_index_t*)"
"page_zip_compress(page_zip_des_t*,const ib_page_t*,dict_index_t*,ulint,mtr_t*)" -> "deflateInit2_(z_streamp,int,int,int,int,int,const char*,int)"
"page_zip_compress(page_zip_des_t*,const ib_page_t*,dict_index_t*,ulint,mtr_t*)" -> "page_zip_get_size(const page_zip_des_t*)"
"page_zip_compress(page_zip_des_t*,const ib_page_t*,dict_index_t*,ulint,mtr_t*)" -> "memcpy(void*,const void*,size_t)"
"page_zip_compress(page_zip_des_t*,const ib_page_t*,dict_index_t*,ulint,mtr_t*)" -> "page_is_leaf(const ib_page_t*)"
"page_zip_compress(page_zip_des_t*,const ib_page_t*,dict_index_t*,ulint,mtr_t*)" -> "pfs_mutex_enter_func(ib_mutex_t*,const char*,ulint)"
"page_zip_compress(page_zip_des_t*,const ib_page_t*,dict_index_t*,ulint,mtr_t*)" -> "_Alloc>::operator[](const key_type&) [with _Key = long unsigned int,_Tp = page_zip_stat_t,_Compare = std::less<long unsigned int>,_Alloc = std::allocator<std::pair<const long unsigned int,page_zip_stat_t> >,std::map<_Key,_Tp,_Compare,_Alloc>::mapped_type = page_zip_stat_t,std::map<_Key,_Tp,_Compare,_Alloc>::key_type = long unsigned int]"
"page_zip_compress(page_zip_des_t*,const ib_page_t*,dict_index_t*,ulint,mtr_t*)" -> "deflate(z_streamp,int)"
"page_zip_compress(page_zip_des_t*,const ib_page_t*,dict_index_t*,ulint,mtr_t*)" -> "page_dir_get_n_heap(const ib_page_t*)"
"page_zip_compress(page_zip_des_t*,const ib_page_t*,dict_index_t*,ulint,mtr_t*)" -> "dict_index_get_sys_col_pos(const dict_index_t*,ulint)"
"page_zip_compress(page_zip_des_t*,const ib_page_t*,dict_index_t*,ulint,mtr_t*)" -> "dict_index_get_n_unique_in_tree(const dict_index_t*)"
"page_zip_compress(page_zip_des_t*,const ib_page_t*,dict_index_t*,ulint,mtr_t*)" -> "page_zip_compress_clust(z_stream*,const rec_t**,ulint,dict_index_t*,ulint*,ulint,unsigned char*,unsigned char*,mem_heap_t*)"
"page_zip_compress(page_zip_des_t*,const ib_page_t*,dict_index_t*,ulint,mtr_t*)" -> "memset(void*,int,size_t)"
"page_zip_compress(page_zip_des_t*,const ib_page_t*,dict_index_t*,ulint,mtr_t*)" -> "dict_index_is_clust(const dict_index_t*)"
"page_zip_compress(page_zip_des_t*,const ib_page_t*,dict_index_t*,ulint,mtr_t*)" -> "pfs_mutex_exit_func(ib_mutex_t*)"
"page_zip_compress(page_zip_des_t*,const ib_page_t*,dict_index_t*,ulint,mtr_t*)" -> "page_get_n_recs(const ib_page_t*)"
"page_zip_compress(page_zip_des_t*,const ib_page_t*,dict_index_t*,ulint,mtr_t*)" -> "mem_heap_zalloc(mem_heap_t*,ulint)"
"page_zip_compress(page_zip_des_t*,const ib_page_t*,dict_index_t*,ulint,mtr_t*)" -> "rec_get_next_offs(const rec_t*,ulint)"
"page_zip_compress(page_zip_des_t*,const ib_page_t*,dict_index_t*,ulint,mtr_t*)" -> "dict_index_zip_success(dict_index_t*)"
"page_zip_compress(page_zip_des_t*,const ib_page_t*,dict_index_t*,ulint,mtr_t*)" -> "abort()"
"page_zip_compress(page_zip_des_t*,const ib_page_t*,dict_index_t*,ulint,mtr_t*)" -> "page_zip_compress_write_log(const page_zip_des_t*,const ib_page_t*,dict_index_t*,mtr_t*)"
"page_zip_compress(page_zip_des_t*,const ib_page_t*,dict_index_t*,ulint,mtr_t*)" -> "mem_heap_create_func(ulint,ulint)"
"page_zip_compress(page_zip_des_t*,const ib_page_t*,dict_index_t*,ulint,mtr_t*)" -> "page_is_empty(const ib_page_t*)"
"page_zip_compress(page_zip_des_t*,const ib_page_t*,dict_index_t*,ulint,mtr_t*)" -> "mem_heap_alloc(mem_heap_t*,ulint)"
"page_zip_compress(page_zip_des_t*,const ib_page_t*,dict_index_t*,ulint,mtr_t*)" -> "page_zip_dir_encode(const ib_page_t*,unsigned char*,const rec_t**)"
"page_zip_compress(page_zip_des_t*,const ib_page_t*,dict_index_t*,ulint,mtr_t*)" -> "page_zip_set_alloc(void*,mem_heap_t*)"
"page_zip_compress(page_zip_des_t*,const ib_page_t*,dict_index_t*,ulint,mtr_t*)" -> "dict_index_zip_failure(dict_index_t*)"
"page_zip_compress(page_zip_des_t*,const ib_page_t*,dict_index_t*,ulint,mtr_t*)" -> "page_zip_fields_encode(ulint,dict_index_t*,ulint,unsigned char*)"
"page_zip_compress(page_zip_des_t*,const ib_page_t*,dict_index_t*,ulint,mtr_t*)" -> "fil_page_get_type(const unsigned char*)"
"page_zip_compress(page_zip_des_t*,const ib_page_t*,dict_index_t*,ulint,mtr_t*)" -> "page_header_get_field(const ib_page_t*,ulint)"
"page_zip_compress(page_zip_des_t*,const ib_page_t*,dict_index_t*,ulint,mtr_t*)" -> "memcmp(const void*,const void*,size_t)"
"page_zip_compress(page_zip_des_t*,const ib_page_t*,dict_index_t*,ulint,mtr_t*)" -> "page_zip_compress_sec(z_stream*,const rec_t**,ulint)"
"page_zip_compress(page_zip_des_t*,const ib_page_t*,dict_index_t*,ulint,mtr_t*)" -> "mem_heap_free_func(mem_heap_t*,const char*,ulint)"
"page_zip_compress(page_zip_des_t*,const ib_page_t*,dict_index_t*,ulint,mtr_t*)" -> "__builtin_expect(long int,long int)"
"page_zip_compress(page_zip_des_t*,const ib_page_t*,dict_index_t*,ulint,mtr_t*)" -> "deflateEnd(z_streamp)"
"page_zip_compress(page_zip_des_t*,const ib_page_t*,dict_index_t*,ulint,mtr_t*)" -> "page_zip_compress_node_ptrs(z_stream*,const rec_t**,ulint,dict_index_t*,unsigned char*,mem_heap_t*)"
"page_zip_compress(page_zip_des_t*,const ib_page_t*,dict_index_t*,ulint,mtr_t*)" -> "ut_dbg_assertion_failed(const char*,const char*,ulint)"
"page_zip_compress(page_zip_des_t*,const ib_page_t*,dict_index_t*,ulint,mtr_t*)" -> "page_is_comp(const ib_page_t*)"
"page_zip_compress(page_zip_des_t*,const ib_page_t*,dict_index_t*,ulint,mtr_t*)" -> "ut_time_us(ullint*)"
"_Alloc>::operator[](const key_type&) [with _Key = long unsigned int,_Tp = page_zip_stat_t,_Compare = std::less<long unsigned int>,_Alloc = std::allocator<std::pair<const long unsigned int,page_zip_stat_t> >,std::map<_Key,_Tp,_Compare,_Alloc>::mapped_type = page_zip_stat_t,std::map<_Key,_Tp,_Compare,_Alloc>::key_type = long unsigned int]" -> "std::_Rb_tree_iterator<_Tp>::operator==(const _Self&) const [with _Tp = std::pair<const long unsigned int,page_zip_stat_t>,std::_Rb_tree_iterator<_Tp>::_Self = std::_Rb_tree_iterator<std::pair<const long unsigned int,page_zip_stat_t> >]"
"_Alloc>::operator[](const key_type&) [with _Key = long unsigned int,_Tp = page_zip_stat_t,_Compare = std::less<long unsigned int>,_Alloc = std::allocator<std::pair<const long unsigned int,page_zip_stat_t> >,std::map<_Key,_Tp,_Compare,_Alloc>::mapped_type = page_zip_stat_t,std::map<_Key,_Tp,_Compare,_Alloc>::key_type = long unsigned int]" -> "_Alloc>::end() [with _Key = long unsigned int,_Tp = page_zip_stat_t,_Compare = std::less<long unsigned int>,_Alloc = std::allocator<std::pair<const long unsigned int,page_zip_stat_t> >,std::map<_Key,_Tp,_Compare,_Alloc>::iterator = std::_Rb_tree_iterator<std::pair<const long unsigned int,page_zip_stat_t> >]"
"_Alloc>::operator[](const key_type&) [with _Key = long unsigned int,_Tp = page_zip_stat_t,_Compare = std::less<long unsigned int>,_Alloc = std::allocator<std::pair<const long unsigned int,page_zip_stat_t> >,std::map<_Key,_Tp,_Compare,_Alloc>::mapped_type = page_zip_stat_t,std::map<_Key,_Tp,_Compare,_Alloc>::key_type = long unsigned int]" -> "page_zip_stat_t::page_zip_stat_t()"
"_Alloc>::operator[](const key_type&) [with _Key = long unsigned int,_Tp = page_zip_stat_t,_Compare = std::less<long unsigned int>,_Alloc = std::allocator<std::pair<const long unsigned int,page_zip_stat_t> >,std::map<_Key,_Tp,_Compare,_Alloc>::mapped_type = page_zip_stat_t,std::map<_Key,_Tp,_Compare,_Alloc>::key_type = long unsigned int]" -> "_Alloc>::insert(std::map<_Key,_Tp,_Compare,_Alloc>::iterator,const value_type&) [with _Key = long unsigned int,_Tp = page_zip_stat_t,_Compare = std::less<long unsigned int>,_Alloc = std::allocator<std::pair<const long unsigned int,page_zip_stat_t> >,std::map<_Key,_Tp,_Compare,_Alloc>::iterator = std::_Rb_tree_iterator<std::pair<const long unsigned int,page_zip_stat_t> >,std::map<_Key,_Tp,_Compare,_Alloc>::value_type = std::pair<const long unsigned int,page_zip_stat_t>]"
"_Alloc>::operator[](const key_type&) [with _Key = long unsigned int,_Tp = page_zip_stat_t,_Compare = std::less<long unsigned int>,_Alloc = std::allocator<std::pair<const long unsigned int,page_zip_stat_t> >,std::map<_Key,_Tp,_Compare,_Alloc>::mapped_type = page_zip_stat_t,std::map<_Key,_Tp,_Compare,_Alloc>::key_type = long unsigned int]" -> "_Alloc>::key_comp() const [with _Key = long unsigned int,_Tp = page_zip_stat_t,_Compare = std::less<long unsigned int>,_Alloc = std::allocator<std::pair<const long unsigned int,page_zip_stat_t> >,std::map<_Key,_Tp,_Compare,_Alloc>::key_compare = std::less<long unsigned int>]"
"_Alloc>::operator[](const key_type&) [with _Key = long unsigned int,_Tp = page_zip_stat_t,_Compare = std::less<long unsigned int>,_Alloc = std::allocator<std::pair<const long unsigned int,page_zip_stat_t> >,std::map<_Key,_Tp,_Compare,_Alloc>::mapped_type = page_zip_stat_t,std::map<_Key,_Tp,_Compare,_Alloc>::key_type = long unsigned int]" -> "_Alloc>::lower_bound(const key_type&) [with _Key = long unsigned int,_Tp = page_zip_stat_t,_Compare = std::less<long unsigned int>,_Alloc = std::allocator<std::pair<const long unsigned int,page_zip_stat_t> >,std::map<_Key,_Tp,_Compare,_Alloc>::iterator = std::_Rb_tree_iterator<std::pair<const long unsigned int,page_zip_stat_t> >,std::map<_Key,_Tp,_Compare,_Alloc>::key_type = long unsigned int]"
"_Alloc>::operator[](const key_type&) [with _Key = long unsigned int,_Tp = page_zip_stat_t,_Compare = std::less<long unsigned int>,_Alloc = std::allocator<std::pair<const long unsigned int,page_zip_stat_t> >,std::map<_Key,_Tp,_Compare,_Alloc>::mapped_type = page_zip_stat_t,std::map<_Key,_Tp,_Compare,_Alloc>::key_type = long unsigned int]" -> "std::_Rb_tree_iterator<_Tp>::operator*() const [with _Tp = std::pair<const long unsigned int,page_zip_stat_t>,std::_Rb_tree_iterator<_Tp>::reference = std::pair<const long unsigned int,page_zip_stat_t>&]"
"_Alloc>::operator[](const key_type&) [with _Key = long unsigned int,_Tp = page_zip_stat_t,_Compare = std::less<long unsigned int>,_Alloc = std::allocator<std::pair<const long unsigned int,page_zip_stat_t> >,std::map<_Key,_Tp,_Compare,_Alloc>::mapped_type = page_zip_stat_t,std::map<_Key,_Tp,_Compare,_Alloc>::key_type = long unsigned int]" -> "std::less<_Tp>::operator()(const _Tp&,const _Tp&) const [with _Tp = long unsigned int]"
"_Alloc>::operator[](const key_type&) [with _Key = long unsigned int,_Tp = page_zip_stat_t,_Compare = std::less<long unsigned int>,_Alloc = std::allocator<std::pair<const long unsigned int,page_zip_stat_t> >,std::map<_Key,_Tp,_Compare,_Alloc>::mapped_type = page_zip_stat_t,std::map<_Key,_Tp,_Compare,_Alloc>::key_type = long unsigned int]" -> "_T2>::pair(const _T1&,const _T2&) [with _T1 = const long unsigned int,_T2 = page_zip_stat_t]"
"_Alloc>::end() [with _Key = long unsigned int,_Tp = page_zip_stat_t,_Compare = std::less<long unsigned int>,_Alloc = std::allocator<std::pair<const long unsigned int,page_zip_stat_t> >,std::map<_Key,_Tp,_Compare,_Alloc>::iterator = std::_Rb_tree_iterator<std::pair<const long unsigned int,page_zip_stat_t> >]" -> "_Alloc>::end() [with _Key = long unsigned int,_Val = std::pair<const long unsigned int,page_zip_stat_t>,_KeyOfValue = std::_Select1st<std::pair<const long unsigned int,page_zip_stat_t> >,_Compare = std::less<long unsigned int>,_Alloc = std::allocator<std::pair<const long unsigned int,page_zip_stat_t> >,std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::iterator = std::_Rb_tree_iterator<std::pair<const long unsigned int,page_zip_stat_t> >]"
"_Alloc>::end() [with _Key = long unsigned int,_Val = std::pair<const long unsigned int,page_zip_stat_t>,_KeyOfValue = std::_Select1st<std::pair<const long unsigned int,page_zip_stat_t> >,_Compare = std::less<long unsigned int>,_Alloc = std::allocator<std::pair<const long unsigned int,page_zip_stat_t> >,std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::iterator = std::_Rb_tree_iterator<std::pair<const long unsigned int,page_zip_stat_t> >]" -> "std::_Rb_tree_iterator<_Tp>::_Rb_tree_iterator(std::_Rb_tree_iterator<_Tp>::_Link_type) [with _Tp = std::pair<const long unsigned int,page_zip_stat_t>,std::_Rb_tree_iterator<_Tp>::_Link_type = std::_Rb_tree_node<std::pair<const long unsigned int,page_zip_stat_t> >*]"
"_Alloc>::insert(std::map<_Key,_Tp,_Compare,_Alloc>::iterator,const value_type&) [with _Key = long unsigned int,_Tp = page_zip_stat_t,_Compare = std::less<long unsigned int>,_Alloc = std::allocator<std::pair<const long unsigned int,page_zip_stat_t> >,std::map<_Key,_Tp,_Compare,_Alloc>::iterator = std::_Rb_tree_iterator<std::pair<const long unsigned int,page_zip_stat_t> >,std::map<_Key,_Tp,_Compare,_Alloc>::value_type = std::pair<const long unsigned int,page_zip_stat_t>]" -> "std::_Rb_tree_const_iterator<_Tp>::_Rb_tree_const_iterator(const iterator&) [with _Tp = std::pair<const long unsigned int,page_zip_stat_t>,std::_Rb_tree_const_iterator<_Tp>::iterator = std::_Rb_tree_iterator<std::pair<const long unsigned int,page_zip_stat_t> >]"
"_Alloc>::insert(std::map<_Key,_Tp,_Compare,_Alloc>::iterator,const value_type&) [with _Key = long unsigned int,_Tp = page_zip_stat_t,_Compare = std::less<long unsigned int>,_Alloc = std::allocator<std::pair<const long unsigned int,page_zip_stat_t> >,std::map<_Key,_Tp,_Compare,_Alloc>::iterator = std::_Rb_tree_iterator<std::pair<const long unsigned int,page_zip_stat_t> >,std::map<_Key,_Tp,_Compare,_Alloc>::value_type = std::pair<const long unsigned int,page_zip_stat_t>]" -> "_Alloc>::_M_insert_unique_(std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::const_iterator,const _Val&) [with _Key = long unsigned int,_Val = std::pair<const long unsigned int,page_zip_stat_t>,_KeyOfValue = std::_Select1st<std::pair<const long unsigned int,page_zip_stat_t> >,_Compare = std::less<long unsigned int>,_Alloc = std::allocator<std::pair<const long unsigned int,page_zip_stat_t> >,std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::iterator = std::_Rb_tree_iterator<std::pair<const long unsigned int,page_zip_stat_t> >,std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::const_iterator = std::_Rb_tree_const_iterator<std::pair<const long unsigned int,page_zip_stat_t> >]"
"_Alloc>::_M_insert_unique_(std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::const_iterator,const _Val&) [with _Key = long unsigned int,_Val = std::pair<const long unsigned int,page_zip_stat_t>,_KeyOfValue = std::_Select1st<std::pair<const long unsigned int,page_zip_stat_t> >,_Compare = std::less<long unsigned int>,_Alloc = std::allocator<std::pair<const long unsigned int,page_zip_stat_t> >,std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::iterator = std::_Rb_tree_iterator<std::pair<const long unsigned int,page_zip_stat_t> >,std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::const_iterator = std::_Rb_tree_const_iterator<std::pair<const long unsigned int,page_zip_stat_t> >]" -> "_Alloc>::_S_right(std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::_Const_Base_ptr) [with _Key = long unsigned int,_Val = std::pair<const long unsigned int,page_zip_stat_t>,_KeyOfValue = std::_Select1st<std::pair<const long unsigned int,page_zip_stat_t> >,_Compare = std::less<long unsigned int>,_Alloc = std::allocator<std::pair<const long unsigned int,page_zip_stat_t> >,std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::_Const_Link_type = const std::_Rb_tree_node<std::pair<const long unsigned int,page_zip_stat_t> >*,std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::_Const_Base_ptr = const std::_Rb_tree_node_base*]"
"_Alloc>::_M_insert_unique_(std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::const_iterator,const _Val&) [with _Key = long unsigned int,_Val = std::pair<const long unsigned int,page_zip_stat_t>,_KeyOfValue = std::_Select1st<std::pair<const long unsigned int,page_zip_stat_t> >,_Compare = std::less<long unsigned int>,_Alloc = std::allocator<std::pair<const long unsigned int,page_zip_stat_t> >,std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::iterator = std::_Rb_tree_iterator<std::pair<const long unsigned int,page_zip_stat_t> >,std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::const_iterator = std::_Rb_tree_const_iterator<std::pair<const long unsigned int,page_zip_stat_t> >]" -> "std::less<_Tp>::operator()(const _Tp&,const _Tp&) const [with _Tp = long unsigned int]"
"_Alloc>::_M_insert_unique_(std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::const_iterator,const _Val&) [with _Key = long unsigned int,_Val = std::pair<const long unsigned int,page_zip_stat_t>,_KeyOfValue = std::_Select1st<std::pair<const long unsigned int,page_zip_stat_t> >,_Compare = std::less<long unsigned int>,_Alloc = std::allocator<std::pair<const long unsigned int,page_zip_stat_t> >,std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::iterator = std::_Rb_tree_iterator<std::pair<const long unsigned int,page_zip_stat_t> >,std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::const_iterator = std::_Rb_tree_const_iterator<std::pair<const long unsigned int,page_zip_stat_t> >]" -> "std::_Select1st<_Pair>::operator()(const _Pair&) const [with _Pair = std::pair<const long unsigned int,page_zip_stat_t>,typename _Pair::first_type = const long unsigned int]"
"_Alloc>::_M_insert_unique_(std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::const_iterator,const _Val&) [with _Key = long unsigned int,_Val = std::pair<const long unsigned int,page_zip_stat_t>,_KeyOfValue = std::_Select1st<std::pair<const long unsigned int,page_zip_stat_t> >,_Compare = std::less<long unsigned int>,_Alloc = std::allocator<std::pair<const long unsigned int,page_zip_stat_t> >,std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::iterator = std::_Rb_tree_iterator<std::pair<const long unsigned int,page_zip_stat_t> >,std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::const_iterator = std::_Rb_tree_const_iterator<std::pair<const long unsigned int,page_zip_stat_t> >]" -> "_Alloc>::_M_insert_(std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::_Const_Base_ptr,std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::_Const_Base_ptr,const _Val&) [with _Key = long unsigned int,_Val = std::pair<const long unsigned int,page_zip_stat_t>,_KeyOfValue = std::_Select1st<std::pair<const long unsigned int,page_zip_stat_t> >,_Compare = std::less<long unsigned int>,_Alloc = std::allocator<std::pair<const long unsigned int,page_zip_stat_t> >,std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::iterator = std::_Rb_tree_iterator<std::pair<const long unsigned int,page_zip_stat_t> >,std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::_Const_Base_ptr = const std::_Rb_tree_node_base*]"
"_Alloc>::_M_insert_unique_(std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::const_iterator,const _Val&) [with _Key = long unsigned int,_Val = std::pair<const long unsigned int,page_zip_stat_t>,_KeyOfValue = std::_Select1st<std::pair<const long unsigned int,page_zip_stat_t> >,_Compare = std::less<long unsigned int>,_Alloc = std::allocator<std::pair<const long unsigned int,page_zip_stat_t> >,std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::iterator = std::_Rb_tree_iterator<std::pair<const long unsigned int,page_zip_stat_t> >,std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::const_iterator = std::_Rb_tree_const_iterator<std::pair<const long unsigned int,page_zip_stat_t> >]" -> "_Alloc>::_M_rightmost() [with _Key = long unsigned int,_Val = std::pair<const long unsigned int,page_zip_stat_t>,_KeyOfValue = std::_Select1st<std::pair<const long unsigned int,page_zip_stat_t> >,_Compare = std::less<long unsigned int>,_Alloc = std::allocator<std::pair<const long unsigned int,page_zip_stat_t> >,std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::_Base_ptr = std::_Rb_tree_node_base*]"
"_Alloc>::_M_insert_unique_(std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::const_iterator,const _Val&) [with _Key = long unsigned int,_Val = std::pair<const long unsigned int,page_zip_stat_t>,_KeyOfValue = std::_Select1st<std::pair<const long unsigned int,page_zip_stat_t> >,_Compare = std::less<long unsigned int>,_Alloc = std::allocator<std::pair<const long unsigned int,page_zip_stat_t> >,std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::iterator = std::_Rb_tree_iterator<std::pair<const long unsigned int,page_zip_stat_t> >,std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::const_iterator = std::_Rb_tree_const_iterator<std::pair<const long unsigned int,page_zip_stat_t> >]" -> "_Alloc>::_M_leftmost() [with _Key = long unsigned int,_Val = std::pair<const long unsigned int,page_zip_stat_t>,_KeyOfValue = std::_Select1st<std::pair<const long unsigned int,page_zip_stat_t> >,_Compare = std::less<long unsigned int>,_Alloc = std::allocator<std::pair<const long unsigned int,page_zip_stat_t> >,std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::_Base_ptr = std::_Rb_tree_node_base*]"
"_Alloc>::_M_insert_unique_(std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::const_iterator,const _Val&) [with _Key = long unsigned int,_Val = std::pair<const long unsigned int,page_zip_stat_t>,_KeyOfValue = std::_Select1st<std::pair<const long unsigned int,page_zip_stat_t> >,_Compare = std::less<long unsigned int>,_Alloc = std::allocator<std::pair<const long unsigned int,page_zip_stat_t> >,std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::iterator = std::_Rb_tree_iterator<std::pair<const long unsigned int,page_zip_stat_t> >,std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::const_iterator = std::_Rb_tree_const_iterator<std::pair<const long unsigned int,page_zip_stat_t> >]" -> "_Alloc>::_M_end() [with _Key = long unsigned int,_Val = std::pair<const long unsigned int,page_zip_stat_t>,_KeyOfValue = std::_Select1st<std::pair<const long unsigned int,page_zip_stat_t> >,_Compare = std::less<long unsigned int>,_Alloc = std::allocator<std::pair<const long unsigned int,page_zip_stat_t> >,std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::_Link_type = std::_Rb_tree_node<std::pair<const long unsigned int,page_zip_stat_t> >*]"
"_Alloc>::_M_insert_unique_(std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::const_iterator,const _Val&) [with _Key = long unsigned int,_Val = std::pair<const long unsigned int,page_zip_stat_t>,_KeyOfValue = std::_Select1st<std::pair<const long unsigned int,page_zip_stat_t> >,_Compare = std::less<long unsigned int>,_Alloc = std::allocator<std::pair<const long unsigned int,page_zip_stat_t> >,std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::iterator = std::_Rb_tree_iterator<std::pair<const long unsigned int,page_zip_stat_t> >,std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::const_iterator = std::_Rb_tree_const_iterator<std::pair<const long unsigned int,page_zip_stat_t> >]" -> "_Alloc>::_M_insert_unique(const _Val&) [with _Key = long unsigned int,_Val = std::pair<const long unsigned int,page_zip_stat_t>,_KeyOfValue = std::_Select1st<std::pair<const long unsigned int,page_zip_stat_t> >,_Compare = std::less<long unsigned int>,_Alloc = std::allocator<std::pair<const long unsigned int,page_zip_stat_t> >]"
"_Alloc>::_M_insert_unique_(std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::const_iterator,const _Val&) [with _Key = long unsigned int,_Val = std::pair<const long unsigned int,page_zip_stat_t>,_KeyOfValue = std::_Select1st<std::pair<const long unsigned int,page_zip_stat_t> >,_Compare = std::less<long unsigned int>,_Alloc = std::allocator<std::pair<const long unsigned int,page_zip_stat_t> >,std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::iterator = std::_Rb_tree_iterator<std::pair<const long unsigned int,page_zip_stat_t> >,std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::const_iterator = std::_Rb_tree_const_iterator<std::pair<const long unsigned int,page_zip_stat_t> >]" -> "_Alloc>::_S_key(std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::_Const_Base_ptr) [with _Key = long unsigned int,_Val = std::pair<const long unsigned int,page_zip_stat_t>,_KeyOfValue = std::_Select1st<std::pair<const long unsigned int,page_zip_stat_t> >,_Compare = std::less<long unsigned int>,_Alloc = std::allocator<std::pair<const long unsigned int,page_zip_stat_t> >,std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::_Const_Base_ptr = const std::_Rb_tree_node_base*]"
"_Alloc>::_M_insert_unique_(std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::const_iterator,const _Val&) [with _Key = long unsigned int,_Val = std::pair<const long unsigned int,page_zip_stat_t>,_KeyOfValue = std::_Select1st<std::pair<const long unsigned int,page_zip_stat_t> >,_Compare = std::less<long unsigned int>,_Alloc = std::allocator<std::pair<const long unsigned int,page_zip_stat_t> >,std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::iterator = std::_Rb_tree_iterator<std::pair<const long unsigned int,page_zip_stat_t> >,std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::const_iterator = std::_Rb_tree_const_iterator<std::pair<const long unsigned int,page_zip_stat_t> >]" -> "std::_Rb_tree_const_iterator<_Tp>::_M_const_cast() const [with _Tp = std::pair<const long unsigned int,page_zip_stat_t>,std::_Rb_tree_const_iterator<_Tp>::iterator = std::_Rb_tree_iterator<std::pair<const long unsigned int,page_zip_stat_t> >]"
"_Alloc>::_M_insert_unique_(std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::const_iterator,const _Val&) [with _Key = long unsigned int,_Val = std::pair<const long unsigned int,page_zip_stat_t>,_KeyOfValue = std::_Select1st<std::pair<const long unsigned int,page_zip_stat_t> >,_Compare = std::less<long unsigned int>,_Alloc = std::allocator<std::pair<const long unsigned int,page_zip_stat_t> >,std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::iterator = std::_Rb_tree_iterator<std::pair<const long unsigned int,page_zip_stat_t> >,std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::const_iterator = std::_Rb_tree_const_iterator<std::pair<const long unsigned int,page_zip_stat_t> >]" -> "std::_Rb_tree_const_iterator<_Tp>::operator++() [with _Tp = std::pair<const long unsigned int,page_zip_stat_t>,std::_Rb_tree_const_iterator<_Tp>::_Self = std::_Rb_tree_const_iterator<std::pair<const long unsigned int,page_zip_stat_t> >]"
"_Alloc>::_M_insert_unique_(std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::const_iterator,const _Val&) [with _Key = long unsigned int,_Val = std::pair<const long unsigned int,page_zip_stat_t>,_KeyOfValue = std::_Select1st<std::pair<const long unsigned int,page_zip_stat_t> >,_Compare = std::less<long unsigned int>,_Alloc = std::allocator<std::pair<const long unsigned int,page_zip_stat_t> >,std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::iterator = std::_Rb_tree_iterator<std::pair<const long unsigned int,page_zip_stat_t> >,std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::const_iterator = std::_Rb_tree_const_iterator<std::pair<const long unsigned int,page_zip_stat_t> >]" -> "_Alloc>::size() const [with _Key = long unsigned int,_Val = std::pair<const long unsigned int,page_zip_stat_t>,_KeyOfValue = std::_Select1st<std::pair<const long unsigned int,page_zip_stat_t> >,_Compare = std::less<long unsigned int>,_Alloc = std::allocator<std::pair<const long unsigned int,page_zip_stat_t> >,std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::size_type = long unsigned int]"
"_Alloc>::_M_insert_unique_(std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::const_iterator,const _Val&) [with _Key = long unsigned int,_Val = std::pair<const long unsigned int,page_zip_stat_t>,_KeyOfValue = std::_Select1st<std::pair<const long unsigned int,page_zip_stat_t> >,_Compare = std::less<long unsigned int>,_Alloc = std::allocator<std::pair<const long unsigned int,page_zip_stat_t> >,std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::iterator = std::_Rb_tree_iterator<std::pair<const long unsigned int,page_zip_stat_t> >,std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::const_iterator = std::_Rb_tree_const_iterator<std::pair<const long unsigned int,page_zip_stat_t> >]" -> "std::_Rb_tree_const_iterator<_Tp>::operator--() [with _Tp = std::pair<const long unsigned int,page_zip_stat_t>,std::_Rb_tree_const_iterator<_Tp>::_Self = std::_Rb_tree_const_iterator<std::pair<const long unsigned int,page_zip_stat_t> >]"
"_Alloc>::_M_insert_(std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::_Const_Base_ptr,std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::_Const_Base_ptr,const _Val&) [with _Key = long unsigned int,_Val = std::pair<const long unsigned int,page_zip_stat_t>,_KeyOfValue = std::_Select1st<std::pair<const long unsigned int,page_zip_stat_t> >,_Compare = std::less<long unsigned int>,_Alloc = std::allocator<std::pair<const long unsigned int,page_zip_stat_t> >,std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::iterator = std::_Rb_tree_iterator<std::pair<const long unsigned int,page_zip_stat_t> >,std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::_Const_Base_ptr = const std::_Rb_tree_node_base*]" -> "std::_Rb_tree_insert_and_rebalance(bool,std::_Rb_tree_node_base*,std::_Rb_tree_node_base*,std::_Rb_tree_node_base&)"
"_Alloc>::_M_insert_(std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::_Const_Base_ptr,std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::_Const_Base_ptr,const _Val&) [with _Key = long unsigned int,_Val = std::pair<const long unsigned int,page_zip_stat_t>,_KeyOfValue = std::_Select1st<std::pair<const long unsigned int,page_zip_stat_t> >,_Compare = std::less<long unsigned int>,_Alloc = std::allocator<std::pair<const long unsigned int,page_zip_stat_t> >,std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::iterator = std::_Rb_tree_iterator<std::pair<const long unsigned int,page_zip_stat_t> >,std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::_Const_Base_ptr = const std::_Rb_tree_node_base*]" -> "std::_Select1st<_Pair>::operator()(const _Pair&) const [with _Pair = std::pair<const long unsigned int,page_zip_stat_t>,typename _Pair::first_type = const long unsigned int]"
"_Alloc>::_M_insert_(std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::_Const_Base_ptr,std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::_Const_Base_ptr,const _Val&) [with _Key = long unsigned int,_Val = std::pair<const long unsigned int,page_zip_stat_t>,_KeyOfValue = std::_Select1st<std::pair<const long unsigned int,page_zip_stat_t> >,_Compare = std::less<long unsigned int>,_Alloc = std::allocator<std::pair<const long unsigned int,page_zip_stat_t> >,std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::iterator = std::_Rb_tree_iterator<std::pair<const long unsigned int,page_zip_stat_t> >,std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::_Const_Base_ptr = const std::_Rb_tree_node_base*]" -> "std::less<_Tp>::operator()(const _Tp&,const _Tp&) const [with _Tp = long unsigned int]"
"_Alloc>::_M_insert_(std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::_Const_Base_ptr,std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::_Const_Base_ptr,const _Val&) [with _Key = long unsigned int,_Val = std::pair<const long unsigned int,page_zip_stat_t>,_KeyOfValue = std::_Select1st<std::pair<const long unsigned int,page_zip_stat_t> >,_Compare = std::less<long unsigned int>,_Alloc = std::allocator<std::pair<const long unsigned int,page_zip_stat_t> >,std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::iterator = std::_Rb_tree_iterator<std::pair<const long unsigned int,page_zip_stat_t> >,std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::_Const_Base_ptr = const std::_Rb_tree_node_base*]" -> "std::_Rb_tree_iterator<_Tp>::_Rb_tree_iterator(std::_Rb_tree_iterator<_Tp>::_Link_type) [with _Tp = std::pair<const long unsigned int,page_zip_stat_t>,std::_Rb_tree_iterator<_Tp>::_Link_type = std::_Rb_tree_node<std::pair<const long unsigned int,page_zip_stat_t> >*]"
"_Alloc>::_M_insert_(std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::_Const_Base_ptr,std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::_Const_Base_ptr,const _Val&) [with _Key = long unsigned int,_Val = std::pair<const long unsigned int,page_zip_stat_t>,_KeyOfValue = std::_Select1st<std::pair<const long unsigned int,page_zip_stat_t> >,_Compare = std::less<long unsigned int>,_Alloc = std::allocator<std::pair<const long unsigned int,page_zip_stat_t> >,std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::iterator = std::_Rb_tree_iterator<std::pair<const long unsigned int,page_zip_stat_t> >,std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::_Const_Base_ptr = const std::_Rb_tree_node_base*]" -> "_Alloc>::_M_create_node(const value_type&) [with _Key = long unsigned int,_Val = std::pair<const long unsigned int,page_zip_stat_t>,_KeyOfValue = std::_Select1st<std::pair<const long unsigned int,page_zip_stat_t> >,_Compare = std::less<long unsigned int>,_Alloc = std::allocator<std::pair<const long unsigned int,page_zip_stat_t> >,std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::_Link_type = std::_Rb_tree_node<std::pair<const long unsigned int,page_zip_stat_t> >*,std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::value_type = std::pair<const long unsigned int,page_zip_stat_t>]"
"_Alloc>::_M_insert_(std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::_Const_Base_ptr,std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::_Const_Base_ptr,const _Val&) [with _Key = long unsigned int,_Val = std::pair<const long unsigned int,page_zip_stat_t>,_KeyOfValue = std::_Select1st<std::pair<const long unsigned int,page_zip_stat_t> >,_Compare = std::less<long unsigned int>,_Alloc = std::allocator<std::pair<const long unsigned int,page_zip_stat_t> >,std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::iterator = std::_Rb_tree_iterator<std::pair<const long unsigned int,page_zip_stat_t> >,std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::_Const_Base_ptr = const std::_Rb_tree_node_base*]" -> "_Alloc>::_S_key(std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::_Const_Base_ptr) [with _Key = long unsigned int,_Val = std::pair<const long unsigned int,page_zip_stat_t>,_KeyOfValue = std::_Select1st<std::pair<const long unsigned int,page_zip_stat_t> >,_Compare = std::less<long unsigned int>,_Alloc = std::allocator<std::pair<const long unsigned int,page_zip_stat_t> >,std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::_Const_Base_ptr = const std::_Rb_tree_node_base*]"
"_Alloc>::_M_insert_(std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::_Const_Base_ptr,std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::_Const_Base_ptr,const _Val&) [with _Key = long unsigned int,_Val = std::pair<const long unsigned int,page_zip_stat_t>,_KeyOfValue = std::_Select1st<std::pair<const long unsigned int,page_zip_stat_t> >,_Compare = std::less<long unsigned int>,_Alloc = std::allocator<std::pair<const long unsigned int,page_zip_stat_t> >,std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::iterator = std::_Rb_tree_iterator<std::pair<const long unsigned int,page_zip_stat_t> >,std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::_Const_Base_ptr = const std::_Rb_tree_node_base*]" -> "_Alloc>::_M_end() [with _Key = long unsigned int,_Val = std::pair<const long unsigned int,page_zip_stat_t>,_KeyOfValue = std::_Select1st<std::pair<const long unsigned int,page_zip_stat_t> >,_Compare = std::less<long unsigned int>,_Alloc = std::allocator<std::pair<const long unsigned int,page_zip_stat_t> >,std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::_Link_type = std::_Rb_tree_node<std::pair<const long unsigned int,page_zip_stat_t> >*]"
"_Alloc>::_M_create_node(const value_type&) [with _Key = long unsigned int,_Val = std::pair<const long unsigned int,page_zip_stat_t>,_KeyOfValue = std::_Select1st<std::pair<const long unsigned int,page_zip_stat_t> >,_Compare = std::less<long unsigned int>,_Alloc = std::allocator<std::pair<const long unsigned int,page_zip_stat_t> >,std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::_Link_type = std::_Rb_tree_node<std::pair<const long unsigned int,page_zip_stat_t> >*,std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::value_type = std::pair<const long unsigned int,page_zip_stat_t>]" -> "_Alloc>::get_allocator() const [with _Key = long unsigned int,_Val = std::pair<const long unsigned int,page_zip_stat_t>,_KeyOfValue = std::_Select1st<std::pair<const long unsigned int,page_zip_stat_t> >,_Compare = std::less<long unsigned int>,_Alloc = std::allocator<std::pair<const long unsigned int,page_zip_stat_t> >,std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::allocator_type = std::allocator<std::pair<const long unsigned int,page_zip_stat_t> >]"
"_Alloc>::_M_create_node(const value_type&) [with _Key = long unsigned int,_Val = std::pair<const long unsigned int,page_zip_stat_t>,_KeyOfValue = std::_Select1st<std::pair<const long unsigned int,page_zip_stat_t> >,_Compare = std::less<long unsigned int>,_Alloc = std::allocator<std::pair<const long unsigned int,page_zip_stat_t> >,std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::_Link_type = std::_Rb_tree_node<std::pair<const long unsigned int,page_zip_stat_t> >*,std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::value_type = std::pair<const long unsigned int,page_zip_stat_t>]" -> "_Alloc>::_M_get_node() [with _Key = long unsigned int,_Val = std::pair<const long unsigned int,page_zip_stat_t>,_KeyOfValue = std::_Select1st<std::pair<const long unsigned int,page_zip_stat_t> >,_Compare = std::less<long unsigned int>,_Alloc = std::allocator<std::pair<const long unsigned int,page_zip_stat_t> >,std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::_Link_type = std::_Rb_tree_node<std::pair<const long unsigned int,page_zip_stat_t> >*]"
"_Alloc>::_M_create_node(const value_type&) [with _Key = long unsigned int,_Val = std::pair<const long unsigned int,page_zip_stat_t>,_KeyOfValue = std::_Select1st<std::pair<const long unsigned int,page_zip_stat_t> >,_Compare = std::less<long unsigned int>,_Alloc = std::allocator<std::pair<const long unsigned int,page_zip_stat_t> >,std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::_Link_type = std::_Rb_tree_node<std::pair<const long unsigned int,page_zip_stat_t> >*,std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::value_type = std::pair<const long unsigned int,page_zip_stat_t>]" -> "__gnu_cxx::new_allocator<_Tp>::construct(__gnu_cxx::new_allocator<_Tp>::pointer,const _Tp&) [with _Tp = std::pair<const long unsigned int,page_zip_stat_t>,__gnu_cxx::new_allocator<_Tp>::pointer = std::pair<const long unsigned int,page_zip_stat_t>*]"
"_Alloc>::_M_create_node(const value_type&) [with _Key = long unsigned int,_Val = std::pair<const long unsigned int,page_zip_stat_t>,_KeyOfValue = std::_Select1st<std::pair<const long unsigned int,page_zip_stat_t> >,_Compare = std::less<long unsigned int>,_Alloc = std::allocator<std::pair<const long unsigned int,page_zip_stat_t> >,std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::_Link_type = std::_Rb_tree_node<std::pair<const long unsigned int,page_zip_stat_t> >*,std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::value_type = std::pair<const long unsigned int,page_zip_stat_t>]" -> "_Alloc>::_M_put_node(std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::_Link_type) [with _Key = long unsigned int,_Val = std::pair<const long unsigned int,page_zip_stat_t>,_KeyOfValue = std::_Select1st<std::pair<const long unsigned int,page_zip_stat_t> >,_Compare = std::less<long unsigned int>,_Alloc = std::allocator<std::pair<const long unsigned int,page_zip_stat_t> >,std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::_Link_type = std::_Rb_tree_node<std::pair<const long unsigned int,page_zip_stat_t> >*]"
"_Alloc>::_M_create_node(const value_type&) [with _Key = long unsigned int,_Val = std::pair<const long unsigned int,page_zip_stat_t>,_KeyOfValue = std::_Select1st<std::pair<const long unsigned int,page_zip_stat_t> >,_Compare = std::less<long unsigned int>,_Alloc = std::allocator<std::pair<const long unsigned int,page_zip_stat_t> >,std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::_Link_type = std::_Rb_tree_node<std::pair<const long unsigned int,page_zip_stat_t> >*,std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::value_type = std::pair<const long unsigned int,page_zip_stat_t>]" -> "std::__addressof(_Tp&) [with _Tp = std::pair<const long unsigned int,page_zip_stat_t>]"
"_Alloc>::_M_create_node(const value_type&) [with _Key = long unsigned int,_Val = std::pair<const long unsigned int,page_zip_stat_t>,_KeyOfValue = std::_Select1st<std::pair<const long unsigned int,page_zip_stat_t> >,_Compare = std::less<long unsigned int>,_Alloc = std::allocator<std::pair<const long unsigned int,page_zip_stat_t> >,std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::_Link_type = std::_Rb_tree_node<std::pair<const long unsigned int,page_zip_stat_t> >*,std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::value_type = std::pair<const long unsigned int,page_zip_stat_t>]" -> "__cxa_begin_catch(void*)"
"_Alloc>::_M_create_node(const value_type&) [with _Key = long unsigned int,_Val = std::pair<const long unsigned int,page_zip_stat_t>,_KeyOfValue = std::_Select1st<std::pair<const long unsigned int,page_zip_stat_t> >,_Compare = std::less<long unsigned int>,_Alloc = std::allocator<std::pair<const long unsigned int,page_zip_stat_t> >,std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::_Link_type = std::_Rb_tree_node<std::pair<const long unsigned int,page_zip_stat_t> >*,std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::value_type = std::pair<const long unsigned int,page_zip_stat_t>]" -> "__cxa_rethrow()"
"_Alloc>::_M_create_node(const value_type&) [with _Key = long unsigned int,_Val = std::pair<const long unsigned int,page_zip_stat_t>,_KeyOfValue = std::_Select1st<std::pair<const long unsigned int,page_zip_stat_t> >,_Compare = std::less<long unsigned int>,_Alloc = std::allocator<std::pair<const long unsigned int,page_zip_stat_t> >,std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::_Link_type = std::_Rb_tree_node<std::pair<const long unsigned int,page_zip_stat_t> >*,std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::value_type = std::pair<const long unsigned int,page_zip_stat_t>]" -> "__cxa_end_catch()"
"_Alloc>::_M_create_node(const value_type&) [with _Key = long unsigned int,_Val = std::pair<const long unsigned int,page_zip_stat_t>,_KeyOfValue = std::_Select1st<std::pair<const long unsigned int,page_zip_stat_t> >,_Compare = std::less<long unsigned int>,_Alloc = std::allocator<std::pair<const long unsigned int,page_zip_stat_t> >,std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::_Link_type = std::_Rb_tree_node<std::pair<const long unsigned int,page_zip_stat_t> >*,std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::value_type = std::pair<const long unsigned int,page_zip_stat_t>]" -> "__builtin_eh_pointer(int)"
"_Alloc>::get_allocator() const [with _Key = long unsigned int,_Val = std::pair<const long unsigned int,page_zip_stat_t>,_KeyOfValue = std::_Select1st<std::pair<const long unsigned int,page_zip_stat_t> >,_Compare = std::less<long unsigned int>,_Alloc = std::allocator<std::pair<const long unsigned int,page_zip_stat_t> >,std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::allocator_type = std::allocator<std::pair<const long unsigned int,page_zip_stat_t> >]" -> "_Alloc>::_M_get_Node_allocator() const [with _Key = long unsigned int,_Val = std::pair<const long unsigned int,page_zip_stat_t>,_KeyOfValue = std::_Select1st<std::pair<const long unsigned int,page_zip_stat_t> >,_Compare = std::less<long unsigned int>,_Alloc = std::allocator<std::pair<const long unsigned int,page_zip_stat_t> >,std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::_Node_allocator = std::allocator<std::_Rb_tree_node<std::pair<const long unsigned int,page_zip_stat_t> > >]"
"_Alloc>::get_allocator() const [with _Key = long unsigned int,_Val = std::pair<const long unsigned int,page_zip_stat_t>,_KeyOfValue = std::_Select1st<std::pair<const long unsigned int,page_zip_stat_t> >,_Compare = std::less<long unsigned int>,_Alloc = std::allocator<std::pair<const long unsigned int,page_zip_stat_t> >,std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::allocator_type = std::allocator<std::pair<const long unsigned int,page_zip_stat_t> >]" -> "std::allocator<_Tp>::allocator(const std::allocator<_Tp1>&) [with _Tp1 = std::_Rb_tree_node<std::pair<const long unsigned int,page_zip_stat_t> >,_Tp = std::pair<const long unsigned int,page_zip_stat_t>]"
"std::allocator<_Tp>::allocator(const std::allocator<_Tp1>&) [with _Tp1 = std::_Rb_tree_node<std::pair<const long unsigned int,page_zip_stat_t> >,_Tp = std::pair<const long unsigned int,page_zip_stat_t>]" -> "__gnu_cxx::new_allocator<_Tp>::new_allocator() [with _Tp = std::pair<const long unsigned int,page_zip_stat_t>]"
"_Alloc>::_M_get_node() [with _Key = long unsigned int,_Val = std::pair<const long unsigned int,page_zip_stat_t>,_KeyOfValue = std::_Select1st<std::pair<const long unsigned int,page_zip_stat_t> >,_Compare = std::less<long unsigned int>,_Alloc = std::allocator<std::pair<const long unsigned int,page_zip_stat_t> >,std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::_Link_type = std::_Rb_tree_node<std::pair<const long unsigned int,page_zip_stat_t> >*]" -> "__gnu_cxx::new_allocator<_Tp>::allocate(__gnu_cxx::new_allocator<_Tp>::size_type,const void*) [with _Tp = std::_Rb_tree_node<std::pair<const long unsigned int,page_zip_stat_t> >,__gnu_cxx::new_allocator<_Tp>::pointer = std::_Rb_tree_node<std::pair<const long unsigned int,page_zip_stat_t> >*,__gnu_cxx::new_allocator<_Tp>::size_type = long unsigned int]"
"__gnu_cxx::new_allocator<_Tp>::allocate(__gnu_cxx::new_allocator<_Tp>::size_type,const void*) [with _Tp = std::_Rb_tree_node<std::pair<const long unsigned int,page_zip_stat_t> >,__gnu_cxx::new_allocator<_Tp>::pointer = std::_Rb_tree_node<std::pair<const long unsigned int,page_zip_stat_t> >*,__gnu_cxx::new_allocator<_Tp>::size_type = long unsigned int]" -> "__gnu_cxx::new_allocator<_Tp>::max_size() const [with _Tp = std::_Rb_tree_node<std::pair<const long unsigned int,page_zip_stat_t> >,__gnu_cxx::new_allocator<_Tp>::size_type = long unsigned int]"
"__gnu_cxx::new_allocator<_Tp>::allocate(__gnu_cxx::new_allocator<_Tp>::size_type,const void*) [with _Tp = std::_Rb_tree_node<std::pair<const long unsigned int,page_zip_stat_t> >,__gnu_cxx::new_allocator<_Tp>::pointer = std::_Rb_tree_node<std::pair<const long unsigned int,page_zip_stat_t> >*,__gnu_cxx::new_allocator<_Tp>::size_type = long unsigned int]" -> "std::__throw_bad_alloc()"
"_Alloc>::_M_put_node(std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::_Link_type) [with _Key = long unsigned int,_Val = std::pair<const long unsigned int,page_zip_stat_t>,_KeyOfValue = std::_Select1st<std::pair<const long unsigned int,page_zip_stat_t> >,_Compare = std::less<long unsigned int>,_Alloc = std::allocator<std::pair<const long unsigned int,page_zip_stat_t> >,std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::_Link_type = std::_Rb_tree_node<std::pair<const long unsigned int,page_zip_stat_t> >*]" -> "__gnu_cxx::new_allocator<_Tp>::deallocate(__gnu_cxx::new_allocator<_Tp>::pointer,__gnu_cxx::new_allocator<_Tp>::size_type) [with _Tp = std::_Rb_tree_node<std::pair<const long unsigned int,page_zip_stat_t> >,__gnu_cxx::new_allocator<_Tp>::pointer = std::_Rb_tree_node<std::pair<const long unsigned int,page_zip_stat_t> >*,__gnu_cxx::new_allocator<_Tp>::size_type = long unsigned int]"
"_Alloc>::_S_key(std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::_Const_Base_ptr) [with _Key = long unsigned int,_Val = std::pair<const long unsigned int,page_zip_stat_t>,_KeyOfValue = std::_Select1st<std::pair<const long unsigned int,page_zip_stat_t> >,_Compare = std::less<long unsigned int>,_Alloc = std::allocator<std::pair<const long unsigned int,page_zip_stat_t> >,std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::_Const_Base_ptr = const std::_Rb_tree_node_base*]" -> "std::_Select1st<_Pair>::operator()(const _Pair&) const [with _Pair = std::pair<const long unsigned int,page_zip_stat_t>,typename _Pair::first_type = const long unsigned int]"
"_Alloc>::_S_key(std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::_Const_Base_ptr) [with _Key = long unsigned int,_Val = std::pair<const long unsigned int,page_zip_stat_t>,_KeyOfValue = std::_Select1st<std::pair<const long unsigned int,page_zip_stat_t> >,_Compare = std::less<long unsigned int>,_Alloc = std::allocator<std::pair<const long unsigned int,page_zip_stat_t> >,std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::_Const_Base_ptr = const std::_Rb_tree_node_base*]" -> "_Alloc>::_S_value(std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::_Const_Base_ptr) [with _Key = long unsigned int,_Val = std::pair<const long unsigned int,page_zip_stat_t>,_KeyOfValue = std::_Select1st<std::pair<const long unsigned int,page_zip_stat_t> >,_Compare = std::less<long unsigned int>,_Alloc = std::allocator<std::pair<const long unsigned int,page_zip_stat_t> >,std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::const_reference = const std::pair<const long unsigned int,page_zip_stat_t>&,std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::value_type = std::pair<const long unsigned int,page_zip_stat_t>,std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::_Const_Base_ptr = const std::_Rb_tree_node_base*]"
"_Alloc>::_M_insert_unique(const _Val&) [with _Key = long unsigned int,_Val = std::pair<const long unsigned int,page_zip_stat_t>,_KeyOfValue = std::_Select1st<std::pair<const long unsigned int,page_zip_stat_t> >,_Compare = std::less<long unsigned int>,_Alloc = std::allocator<std::pair<const long unsigned int,page_zip_stat_t> >]" -> "std::_Rb_tree_iterator<_Tp>::operator==(const _Self&) const [with _Tp = std::pair<const long unsigned int,page_zip_stat_t>,std::_Rb_tree_iterator<_Tp>::_Self = std::_Rb_tree_iterator<std::pair<const long unsigned int,page_zip_stat_t> >]"
"_Alloc>::_M_insert_unique(const _Val&) [with _Key = long unsigned int,_Val = std::pair<const long unsigned int,page_zip_stat_t>,_KeyOfValue = std::_Select1st<std::pair<const long unsigned int,page_zip_stat_t> >,_Compare = std::less<long unsigned int>,_Alloc = std::allocator<std::pair<const long unsigned int,page_zip_stat_t> >]" -> "_Alloc>::_S_key(std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::_Const_Base_ptr) [with _Key = long unsigned int,_Val = std::pair<const long unsigned int,page_zip_stat_t>,_KeyOfValue = std::_Select1st<std::pair<const long unsigned int,page_zip_stat_t> >,_Compare = std::less<long unsigned int>,_Alloc = std::allocator<std::pair<const long unsigned int,page_zip_stat_t> >,std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::_Const_Base_ptr = const std::_Rb_tree_node_base*]"
"_Alloc>::_M_insert_unique(const _Val&) [with _Key = long unsigned int,_Val = std::pair<const long unsigned int,page_zip_stat_t>,_KeyOfValue = std::_Select1st<std::pair<const long unsigned int,page_zip_stat_t> >,_Compare = std::less<long unsigned int>,_Alloc = std::allocator<std::pair<const long unsigned int,page_zip_stat_t> >]" -> "_Alloc>::_M_begin() [with _Key = long unsigned int,_Val = std::pair<const long unsigned int,page_zip_stat_t>,_KeyOfValue = std::_Select1st<std::pair<const long unsigned int,page_zip_stat_t> >,_Compare = std::less<long unsigned int>,_Alloc = std::allocator<std::pair<const long unsigned int,page_zip_stat_t> >,std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::_Link_type = std::_Rb_tree_node<std::pair<const long unsigned int,page_zip_stat_t> >*]"
"_Alloc>::_M_insert_unique(const _Val&) [with _Key = long unsigned int,_Val = std::pair<const long unsigned int,page_zip_stat_t>,_KeyOfValue = std::_Select1st<std::pair<const long unsigned int,page_zip_stat_t> >,_Compare = std::less<long unsigned int>,_Alloc = std::allocator<std::pair<const long unsigned int,page_zip_stat_t> >]" -> "_Alloc>::_S_key(std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::_Const_Link_type) [with _Key = long unsigned int,_Val = std::pair<const long unsigned int,page_zip_stat_t>,_KeyOfValue = std::_Select1st<std::pair<const long unsigned int,page_zip_stat_t> >,_Compare = std::less<long unsigned int>,_Alloc = std::allocator<std::pair<const long unsigned int,page_zip_stat_t> >,std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::_Const_Link_type = const std::_Rb_tree_node<std::pair<const long unsigned int,page_zip_stat_t> >*]"
"_Alloc>::_M_insert_unique(const _Val&) [with _Key = long unsigned int,_Val = std::pair<const long unsigned int,page_zip_stat_t>,_KeyOfValue = std::_Select1st<std::pair<const long unsigned int,page_zip_stat_t> >,_Compare = std::less<long unsigned int>,_Alloc = std::allocator<std::pair<const long unsigned int,page_zip_stat_t> >]" -> "_Alloc>::_S_right(std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::_Base_ptr) [with _Key = long unsigned int,_Val = std::pair<const long unsigned int,page_zip_stat_t>,_KeyOfValue = std::_Select1st<std::pair<const long unsigned int,page_zip_stat_t> >,_Compare = std::less<long unsigned int>,_Alloc = std::allocator<std::pair<const long unsigned int,page_zip_stat_t> >,std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::_Link_type = std::_Rb_tree_node<std::pair<const long unsigned int,page_zip_stat_t> >*,std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::_Base_ptr = std::_Rb_tree_node_base*]"
"_Alloc>::_M_insert_unique(const _Val&) [with _Key = long unsigned int,_Val = std::pair<const long unsigned int,page_zip_stat_t>,_KeyOfValue = std::_Select1st<std::pair<const long unsigned int,page_zip_stat_t> >,_Compare = std::less<long unsigned int>,_Alloc = std::allocator<std::pair<const long unsigned int,page_zip_stat_t> >]" -> "_Alloc>::_M_insert_(std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::_Const_Base_ptr,std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::_Const_Base_ptr,const _Val&) [with _Key = long unsigned int,_Val = std::pair<const long unsigned int,page_zip_stat_t>,_KeyOfValue = std::_Select1st<std::pair<const long unsigned int,page_zip_stat_t> >,_Compare = std::less<long unsigned int>,_Alloc = std::allocator<std::pair<const long unsigned int,page_zip_stat_t> >,std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::iterator = std::_Rb_tree_iterator<std::pair<const long unsigned int,page_zip_stat_t> >,std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::_Const_Base_ptr = const std::_Rb_tree_node_base*]"
"_Alloc>::_M_insert_unique(const _Val&) [with _Key = long unsigned int,_Val = std::pair<const long unsigned int,page_zip_stat_t>,_KeyOfValue = std::_Select1st<std::pair<const long unsigned int,page_zip_stat_t> >,_Compare = std::less<long unsigned int>,_Alloc = std::allocator<std::pair<const long unsigned int,page_zip_stat_t> >]" -> "std::_Select1st<_Pair>::operator()(const _Pair&) const [with _Pair = std::pair<const long unsigned int,page_zip_stat_t>,typename _Pair::first_type = const long unsigned int]"
"_Alloc>::_M_insert_unique(const _Val&) [with _Key = long unsigned int,_Val = std::pair<const long unsigned int,page_zip_stat_t>,_KeyOfValue = std::_Select1st<std::pair<const long unsigned int,page_zip_stat_t> >,_Compare = std::less<long unsigned int>,_Alloc = std::allocator<std::pair<const long unsigned int,page_zip_stat_t> >]" -> "_Alloc>::_M_end() [with _Key = long unsigned int,_Val = std::pair<const long unsigned int,page_zip_stat_t>,_KeyOfValue = std::_Select1st<std::pair<const long unsigned int,page_zip_stat_t> >,_Compare = std::less<long unsigned int>,_Alloc = std::allocator<std::pair<const long unsigned int,page_zip_stat_t> >,std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::_Link_type = std::_Rb_tree_node<std::pair<const long unsigned int,page_zip_stat_t> >*]"
"_Alloc>::_M_insert_unique(const _Val&) [with _Key = long unsigned int,_Val = std::pair<const long unsigned int,page_zip_stat_t>,_KeyOfValue = std::_Select1st<std::pair<const long unsigned int,page_zip_stat_t> >,_Compare = std::less<long unsigned int>,_Alloc = std::allocator<std::pair<const long unsigned int,page_zip_stat_t> >]" -> "std::_Rb_tree_iterator<_Tp>::operator--() [with _Tp = std::pair<const long unsigned int,page_zip_stat_t>,std::_Rb_tree_iterator<_Tp>::_Self = std::_Rb_tree_iterator<std::pair<const long unsigned int,page_zip_stat_t> >]"
"_Alloc>::_M_insert_unique(const _Val&) [with _Key = long unsigned int,_Val = std::pair<const long unsigned int,page_zip_stat_t>,_KeyOfValue = std::_Select1st<std::pair<const long unsigned int,page_zip_stat_t> >,_Compare = std::less<long unsigned int>,_Alloc = std::allocator<std::pair<const long unsigned int,page_zip_stat_t> >]" -> "std::less<_Tp>::operator()(const _Tp&,const _Tp&) const [with _Tp = long unsigned int]"
"_Alloc>::_M_insert_unique(const _Val&) [with _Key = long unsigned int,_Val = std::pair<const long unsigned int,page_zip_stat_t>,_KeyOfValue = std::_Select1st<std::pair<const long unsigned int,page_zip_stat_t> >,_Compare = std::less<long unsigned int>,_Alloc = std::allocator<std::pair<const long unsigned int,page_zip_stat_t> >]" -> "_Alloc>::begin() [with _Key = long unsigned int,_Val = std::pair<const long unsigned int,page_zip_stat_t>,_KeyOfValue = std::_Select1st<std::pair<const long unsigned int,page_zip_stat_t> >,_Compare = std::less<long unsigned int>,_Alloc = std::allocator<std::pair<const long unsigned int,page_zip_stat_t> >,std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::iterator = std::_Rb_tree_iterator<std::pair<const long unsigned int,page_zip_stat_t> >]"
"_Alloc>::_M_insert_unique(const _Val&) [with _Key = long unsigned int,_Val = std::pair<const long unsigned int,page_zip_stat_t>,_KeyOfValue = std::_Select1st<std::pair<const long unsigned int,page_zip_stat_t> >,_Compare = std::less<long unsigned int>,_Alloc = std::allocator<std::pair<const long unsigned int,page_zip_stat_t> >]" -> "std::_Rb_tree_iterator<_Tp>::_Rb_tree_iterator(std::_Rb_tree_iterator<_Tp>::_Link_type) [with _Tp = std::pair<const long unsigned int,page_zip_stat_t>,std::_Rb_tree_iterator<_Tp>::_Link_type = std::_Rb_tree_node<std::pair<const long unsigned int,page_zip_stat_t> >*]"
"_Alloc>::_M_insert_unique(const _Val&) [with _Key = long unsigned int,_Val = std::pair<const long unsigned int,page_zip_stat_t>,_KeyOfValue = std::_Select1st<std::pair<const long unsigned int,page_zip_stat_t> >,_Compare = std::less<long unsigned int>,_Alloc = std::allocator<std::pair<const long unsigned int,page_zip_stat_t> >]" -> "_T2>::pair(const _T1&,const _T2&) [with _T1 = std::_Rb_tree_iterator<std::pair<const long unsigned int,page_zip_stat_t> >,_T2 = bool]"
"_Alloc>::_M_insert_unique(const _Val&) [with _Key = long unsigned int,_Val = std::pair<const long unsigned int,page_zip_stat_t>,_KeyOfValue = std::_Select1st<std::pair<const long unsigned int,page_zip_stat_t> >,_Compare = std::less<long unsigned int>,_Alloc = std::allocator<std::pair<const long unsigned int,page_zip_stat_t> >]" -> "_Alloc>::_S_left(std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::_Base_ptr) [with _Key = long unsigned int,_Val = std::pair<const long unsigned int,page_zip_stat_t>,_KeyOfValue = std::_Select1st<std::pair<const long unsigned int,page_zip_stat_t> >,_Compare = std::less<long unsigned int>,_Alloc = std::allocator<std::pair<const long unsigned int,page_zip_stat_t> >,std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::_Link_type = std::_Rb_tree_node<std::pair<const long unsigned int,page_zip_stat_t> >*,std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::_Base_ptr = std::_Rb_tree_node_base*]"
"_Alloc>::_S_key(std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::_Const_Link_type) [with _Key = long unsigned int,_Val = std::pair<const long unsigned int,page_zip_stat_t>,_KeyOfValue = std::_Select1st<std::pair<const long unsigned int,page_zip_stat_t> >,_Compare = std::less<long unsigned int>,_Alloc = std::allocator<std::pair<const long unsigned int,page_zip_stat_t> >,std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::_Const_Link_type = const std::_Rb_tree_node<std::pair<const long unsigned int,page_zip_stat_t> >*]" -> "_Alloc>::_S_value(std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::_Const_Link_type) [with _Key = long unsigned int,_Val = std::pair<const long unsigned int,page_zip_stat_t>,_KeyOfValue = std::_Select1st<std::pair<const long unsigned int,page_zip_stat_t> >,_Compare = std::less<long unsigned int>,_Alloc = std::allocator<std::pair<const long unsigned int,page_zip_stat_t> >,std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::const_reference = const std::pair<const long unsigned int,page_zip_stat_t>&,std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::value_type = std::pair<const long unsigned int,page_zip_stat_t>,std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::_Const_Link_type = const std::_Rb_tree_node<std::pair<const long unsigned int,page_zip_stat_t> >*]"
"_Alloc>::_S_key(std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::_Const_Link_type) [with _Key = long unsigned int,_Val = std::pair<const long unsigned int,page_zip_stat_t>,_KeyOfValue = std::_Select1st<std::pair<const long unsigned int,page_zip_stat_t> >,_Compare = std::less<long unsigned int>,_Alloc = std::allocator<std::pair<const long unsigned int,page_zip_stat_t> >,std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::_Const_Link_type = const std::_Rb_tree_node<std::pair<const long unsigned int,page_zip_stat_t> >*]" -> "std::_Select1st<_Pair>::operator()(const _Pair&) const [with _Pair = std::pair<const long unsigned int,page_zip_stat_t>,typename _Pair::first_type = const long unsigned int]"
"std::_Rb_tree_iterator<_Tp>::operator--() [with _Tp = std::pair<const long unsigned int,page_zip_stat_t>,std::_Rb_tree_iterator<_Tp>::_Self = std::_Rb_tree_iterator<std::pair<const long unsigned int,page_zip_stat_t> >]" -> "std::_Rb_tree_decrement(std::_Rb_tree_node_base*)"
"_Alloc>::begin() [with _Key = long unsigned int,_Val = std::pair<const long unsigned int,page_zip_stat_t>,_KeyOfValue = std::_Select1st<std::pair<const long unsigned int,page_zip_stat_t> >,_Compare = std::less<long unsigned int>,_Alloc = std::allocator<std::pair<const long unsigned int,page_zip_stat_t> >,std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::iterator = std::_Rb_tree_iterator<std::pair<const long unsigned int,page_zip_stat_t> >]" -> "std::_Rb_tree_iterator<_Tp>::_Rb_tree_iterator(std::_Rb_tree_iterator<_Tp>::_Link_type) [with _Tp = std::pair<const long unsigned int,page_zip_stat_t>,std::_Rb_tree_iterator<_Tp>::_Link_type = std::_Rb_tree_node<std::pair<const long unsigned int,page_zip_stat_t> >*]"
"std::_Rb_tree_const_iterator<_Tp>::_M_const_cast() const [with _Tp = std::pair<const long unsigned int,page_zip_stat_t>,std::_Rb_tree_const_iterator<_Tp>::iterator = std::_Rb_tree_iterator<std::pair<const long unsigned int,page_zip_stat_t> >]" -> "std::_Rb_tree_iterator<_Tp>::_Rb_tree_iterator(std::_Rb_tree_iterator<_Tp>::_Link_type) [with _Tp = std::pair<const long unsigned int,page_zip_stat_t>,std::_Rb_tree_iterator<_Tp>::_Link_type = std::_Rb_tree_node<std::pair<const long unsigned int,page_zip_stat_t> >*]"
"std::_Rb_tree_const_iterator<_Tp>::operator++() [with _Tp = std::pair<const long unsigned int,page_zip_stat_t>,std::_Rb_tree_const_iterator<_Tp>::_Self = std::_Rb_tree_const_iterator<std::pair<const long unsigned int,page_zip_stat_t> >]" -> "std::_Rb_tree_increment(const std::_Rb_tree_node_base*)"
"std::_Rb_tree_const_iterator<_Tp>::operator--() [with _Tp = std::pair<const long unsigned int,page_zip_stat_t>,std::_Rb_tree_const_iterator<_Tp>::_Self = std::_Rb_tree_const_iterator<std::pair<const long unsigned int,page_zip_stat_t> >]" -> "std::_Rb_tree_decrement(const std::_Rb_tree_node_base*)"
"_Alloc>::key_comp() const [with _Key = long unsigned int,_Tp = page_zip_stat_t,_Compare = std::less<long unsigned int>,_Alloc = std::allocator<std::pair<const long unsigned int,page_zip_stat_t> >,std::map<_Key,_Tp,_Compare,_Alloc>::key_compare = std::less<long unsigned int>]" -> "_Alloc>::key_comp() const [with _Key = long unsigned int,_Val = std::pair<const long unsigned int,page_zip_stat_t>,_KeyOfValue = std::_Select1st<std::pair<const long unsigned int,page_zip_stat_t> >,_Compare = std::less<long unsigned int>,_Alloc = std::allocator<std::pair<const long unsigned int,page_zip_stat_t> >]"
"_Alloc>::lower_bound(const key_type&) [with _Key = long unsigned int,_Tp = page_zip_stat_t,_Compare = std::less<long unsigned int>,_Alloc = std::allocator<std::pair<const long unsigned int,page_zip_stat_t> >,std::map<_Key,_Tp,_Compare,_Alloc>::iterator = std::_Rb_tree_iterator<std::pair<const long unsigned int,page_zip_stat_t> >,std::map<_Key,_Tp,_Compare,_Alloc>::key_type = long unsigned int]" -> "_Alloc>::lower_bound(const key_type&) [with _Key = long unsigned int,_Val = std::pair<const long unsigned int,page_zip_stat_t>,_KeyOfValue = std::_Select1st<std::pair<const long unsigned int,page_zip_stat_t> >,_Compare = std::less<long unsigned int>,_Alloc = std::allocator<std::pair<const long unsigned int,page_zip_stat_t> >,std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::iterator = std::_Rb_tree_iterator<std::pair<const long unsigned int,page_zip_stat_t> >,std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::key_type = long unsigned int]"
"_Alloc>::lower_bound(const key_type&) [with _Key = long unsigned int,_Val = std::pair<const long unsigned int,page_zip_stat_t>,_KeyOfValue = std::_Select1st<std::pair<const long unsigned int,page_zip_stat_t> >,_Compare = std::less<long unsigned int>,_Alloc = std::allocator<std::pair<const long unsigned int,page_zip_stat_t> >,std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::iterator = std::_Rb_tree_iterator<std::pair<const long unsigned int,page_zip_stat_t> >,std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::key_type = long unsigned int]" -> "_Alloc>::_M_begin() [with _Key = long unsigned int,_Val = std::pair<const long unsigned int,page_zip_stat_t>,_KeyOfValue = std::_Select1st<std::pair<const long unsigned int,page_zip_stat_t> >,_Compare = std::less<long unsigned int>,_Alloc = std::allocator<std::pair<const long unsigned int,page_zip_stat_t> >,std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::_Link_type = std::_Rb_tree_node<std::pair<const long unsigned int,page_zip_stat_t> >*]"
"_Alloc>::lower_bound(const key_type&) [with _Key = long unsigned int,_Val = std::pair<const long unsigned int,page_zip_stat_t>,_KeyOfValue = std::_Select1st<std::pair<const long unsigned int,page_zip_stat_t> >,_Compare = std::less<long unsigned int>,_Alloc = std::allocator<std::pair<const long unsigned int,page_zip_stat_t> >,std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::iterator = std::_Rb_tree_iterator<std::pair<const long unsigned int,page_zip_stat_t> >,std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::key_type = long unsigned int]" -> "_Alloc>::_M_lower_bound(std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::_Link_type,std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::_Link_type,const _Key&) [with _Key = long unsigned int,_Val = std::pair<const long unsigned int,page_zip_stat_t>,_KeyOfValue = std::_Select1st<std::pair<const long unsigned int,page_zip_stat_t> >,_Compare = std::less<long unsigned int>,_Alloc = std::allocator<std::pair<const long unsigned int,page_zip_stat_t> >,std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::iterator = std::_Rb_tree_iterator<std::pair<const long unsigned int,page_zip_stat_t> >,std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::_Link_type = std::_Rb_tree_node<std::pair<const long unsigned int,page_zip_stat_t> >*]"
"_Alloc>::lower_bound(const key_type&) [with _Key = long unsigned int,_Val = std::pair<const long unsigned int,page_zip_stat_t>,_KeyOfValue = std::_Select1st<std::pair<const long unsigned int,page_zip_stat_t> >,_Compare = std::less<long unsigned int>,_Alloc = std::allocator<std::pair<const long unsigned int,page_zip_stat_t> >,std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::iterator = std::_Rb_tree_iterator<std::pair<const long unsigned int,page_zip_stat_t> >,std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::key_type = long unsigned int]" -> "_Alloc>::_M_end() [with _Key = long unsigned int,_Val = std::pair<const long unsigned int,page_zip_stat_t>,_KeyOfValue = std::_Select1st<std::pair<const long unsigned int,page_zip_stat_t> >,_Compare = std::less<long unsigned int>,_Alloc = std::allocator<std::pair<const long unsigned int,page_zip_stat_t> >,std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::_Link_type = std::_Rb_tree_node<std::pair<const long unsigned int,page_zip_stat_t> >*]"
"_Alloc>::_M_lower_bound(std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::_Link_type,std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::_Link_type,const _Key&) [with _Key = long unsigned int,_Val = std::pair<const long unsigned int,page_zip_stat_t>,_KeyOfValue = std::_Select1st<std::pair<const long unsigned int,page_zip_stat_t> >,_Compare = std::less<long unsigned int>,_Alloc = std::allocator<std::pair<const long unsigned int,page_zip_stat_t> >,std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::iterator = std::_Rb_tree_iterator<std::pair<const long unsigned int,page_zip_stat_t> >,std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::_Link_type = std::_Rb_tree_node<std::pair<const long unsigned int,page_zip_stat_t> >*]" -> "std::less<_Tp>::operator()(const _Tp&,const _Tp&) const [with _Tp = long unsigned int]"
"_Alloc>::_M_lower_bound(std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::_Link_type,std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::_Link_type,const _Key&) [with _Key = long unsigned int,_Val = std::pair<const long unsigned int,page_zip_stat_t>,_KeyOfValue = std::_Select1st<std::pair<const long unsigned int,page_zip_stat_t> >,_Compare = std::less<long unsigned int>,_Alloc = std::allocator<std::pair<const long unsigned int,page_zip_stat_t> >,std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::iterator = std::_Rb_tree_iterator<std::pair<const long unsigned int,page_zip_stat_t> >,std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::_Link_type = std::_Rb_tree_node<std::pair<const long unsigned int,page_zip_stat_t> >*]" -> "_Alloc>::_S_right(std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::_Base_ptr) [with _Key = long unsigned int,_Val = std::pair<const long unsigned int,page_zip_stat_t>,_KeyOfValue = std::_Select1st<std::pair<const long unsigned int,page_zip_stat_t> >,_Compare = std::less<long unsigned int>,_Alloc = std::allocator<std::pair<const long unsigned int,page_zip_stat_t> >,std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::_Link_type = std::_Rb_tree_node<std::pair<const long unsigned int,page_zip_stat_t> >*,std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::_Base_ptr = std::_Rb_tree_node_base*]"
"_Alloc>::_M_lower_bound(std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::_Link_type,std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::_Link_type,const _Key&) [with _Key = long unsigned int,_Val = std::pair<const long unsigned int,page_zip_stat_t>,_KeyOfValue = std::_Select1st<std::pair<const long unsigned int,page_zip_stat_t> >,_Compare = std::less<long unsigned int>,_Alloc = std::allocator<std::pair<const long unsigned int,page_zip_stat_t> >,std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::iterator = std::_Rb_tree_iterator<std::pair<const long unsigned int,page_zip_stat_t> >,std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::_Link_type = std::_Rb_tree_node<std::pair<const long unsigned int,page_zip_stat_t> >*]" -> "_Alloc>::_S_key(std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::_Const_Link_type) [with _Key = long unsigned int,_Val = std::pair<const long unsigned int,page_zip_stat_t>,_KeyOfValue = std::_Select1st<std::pair<const long unsigned int,page_zip_stat_t> >,_Compare = std::less<long unsigned int>,_Alloc = std::allocator<std::pair<const long unsigned int,page_zip_stat_t> >,std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::_Const_Link_type = const std::_Rb_tree_node<std::pair<const long unsigned int,page_zip_stat_t> >*]"
"_Alloc>::_M_lower_bound(std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::_Link_type,std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::_Link_type,const _Key&) [with _Key = long unsigned int,_Val = std::pair<const long unsigned int,page_zip_stat_t>,_KeyOfValue = std::_Select1st<std::pair<const long unsigned int,page_zip_stat_t> >,_Compare = std::less<long unsigned int>,_Alloc = std::allocator<std::pair<const long unsigned int,page_zip_stat_t> >,std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::iterator = std::_Rb_tree_iterator<std::pair<const long unsigned int,page_zip_stat_t> >,std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::_Link_type = std::_Rb_tree_node<std::pair<const long unsigned int,page_zip_stat_t> >*]" -> "_Alloc>::_S_left(std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::_Base_ptr) [with _Key = long unsigned int,_Val = std::pair<const long unsigned int,page_zip_stat_t>,_KeyOfValue = std::_Select1st<std::pair<const long unsigned int,page_zip_stat_t> >,_Compare = std::less<long unsigned int>,_Alloc = std::allocator<std::pair<const long unsigned int,page_zip_stat_t> >,std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::_Link_type = std::_Rb_tree_node<std::pair<const long unsigned int,page_zip_stat_t> >*,std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::_Base_ptr = std::_Rb_tree_node_base*]"
"_Alloc>::_M_lower_bound(std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::_Link_type,std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::_Link_type,const _Key&) [with _Key = long unsigned int,_Val = std::pair<const long unsigned int,page_zip_stat_t>,_KeyOfValue = std::_Select1st<std::pair<const long unsigned int,page_zip_stat_t> >,_Compare = std::less<long unsigned int>,_Alloc = std::allocator<std::pair<const long unsigned int,page_zip_stat_t> >,std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::iterator = std::_Rb_tree_iterator<std::pair<const long unsigned int,page_zip_stat_t> >,std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::_Link_type = std::_Rb_tree_node<std::pair<const long unsigned int,page_zip_stat_t> >*]" -> "std::_Rb_tree_iterator<_Tp>::_Rb_tree_iterator(std::_Rb_tree_iterator<_Tp>::_Link_type) [with _Tp = std::pair<const long unsigned int,page_zip_stat_t>,std::_Rb_tree_iterator<_Tp>::_Link_type = std::_Rb_tree_node<std::pair<const long unsigned int,page_zip_stat_t> >*]"
"page_dir_get_n_heap(const ib_page_t*)" -> "page_header_get_field(const ib_page_t*,ulint)"
"dict_index_get_n_unique_in_tree(const dict_index_t*)" -> "dict_index_is_clust(const dict_index_t*)"
"dict_index_get_n_unique_in_tree(const dict_index_t*)" -> "dict_index_get_n_fields(const dict_index_t*)"
"dict_index_get_n_unique_in_tree(const dict_index_t*)" -> "dict_index_get_n_unique(const dict_index_t*)"
"page_zip_compress_clust(z_stream*,const rec_t**,ulint,dict_index_t*,ulint*,ulint,unsigned char*,unsigned char*,mem_heap_t*)" -> "__builtin_expect(long int,long int)"
"page_zip_compress_clust(z_stream*,const rec_t**,ulint,dict_index_t*,ulint*,ulint,unsigned char*,unsigned char*,mem_heap_t*)" -> "memcpy(void*,const void*,size_t)"
"page_zip_compress_clust(z_stream*,const rec_t**,ulint,dict_index_t*,ulint*,ulint,unsigned char*,unsigned char*,mem_heap_t*)" -> "rec_get_heap_no_new(const rec_t*)"
"page_zip_compress_clust(z_stream*,const rec_t**,ulint,dict_index_t*,ulint*,ulint,unsigned char*,unsigned char*,mem_heap_t*)" -> "deflate(z_streamp,int)"
"page_zip_compress_clust(z_stream*,const rec_t**,ulint,dict_index_t*,ulint*,ulint,unsigned char*,unsigned char*,mem_heap_t*)" -> "rec_get_nth_field_offs(const ulint*,ulint,ulint*)"
"page_zip_compress_clust(z_stream*,const rec_t**,ulint,dict_index_t*,ulint*,ulint,unsigned char*,unsigned char*,mem_heap_t*)" -> "rec_get_offsets_func(const rec_t*,const dict_index_t*,ulint*,ulint,mem_heap_t**)"
"page_zip_compress_clust(z_stream*,const rec_t**,ulint,dict_index_t*,ulint*,ulint,unsigned char*,unsigned char*,mem_heap_t*)" -> "rec_offs_data_size(const ulint*)"
"page_zip_compress_clust(z_stream*,const rec_t**,ulint,dict_index_t*,ulint*,ulint,unsigned char*,unsigned char*,mem_heap_t*)" -> "page_zip_compress_clust_ext(z_stream*,const rec_t*,const ulint*,ulint,unsigned char*,unsigned char*,unsigned char**,ulint*)"
"page_zip_compress_clust(z_stream*,const rec_t**,ulint,dict_index_t*,ulint*,ulint,unsigned char*,unsigned char*,mem_heap_t*)" -> "rec_offs_any_extern(const ulint*)"
"rec_get_heap_no_new(const rec_t*)" -> "rec_get_bit_field_2(const rec_t*,ulint,ulint,ulint)"
"rec_get_bit_field_2(const rec_t*,ulint,ulint,ulint)" -> "mach_read_from_2(const unsigned char*)"
"rec_get_offsets_func(const rec_t*,const dict_index_t*,ulint*,ulint,mem_heap_t**)" -> "dict_index_get_n_unique_in_tree(const dict_index_t*)"
"rec_get_offsets_func(const rec_t*,const dict_index_t*,ulint*,ulint,mem_heap_t**)" -> "mem_heap_alloc(mem_heap_t*,ulint)"
"rec_get_offsets_func(const rec_t*,const dict_index_t*,ulint*,ulint,mem_heap_t**)" -> "rec_offs_set_n_alloc(ulint*,ulint)"
"rec_get_offsets_func(const rec_t*,const dict_index_t*,ulint*,ulint,mem_heap_t**)" -> "mem_heap_create_func(ulint,ulint)"
"rec_get_offsets_func(const rec_t*,const dict_index_t*,ulint*,ulint,mem_heap_t**)" -> "abort()"
"rec_get_offsets_func(const rec_t*,const dict_index_t*,ulint*,ulint,mem_heap_t**)" -> "ut_dbg_assertion_failed(const char*,const char*,ulint)"
"rec_get_offsets_func(const rec_t*,const dict_index_t*,ulint*,ulint,mem_heap_t**)" -> "rec_offs_set_n_fields(ulint*,ulint)"
"rec_get_offsets_func(const rec_t*,const dict_index_t*,ulint*,ulint,mem_heap_t**)" -> "__builtin_expect(long int,long int)"
"rec_get_offsets_func(const rec_t*,const dict_index_t*,ulint*,ulint,mem_heap_t**)" -> "dict_index_get_n_fields(const dict_index_t*)"
"rec_get_offsets_func(const rec_t*,const dict_index_t*,ulint*,ulint,mem_heap_t**)" -> "rec_get_n_fields_old(const rec_t*)"
"rec_get_offsets_func(const rec_t*,const dict_index_t*,ulint*,ulint,mem_heap_t**)" -> "rec_get_status(const rec_t*)"
"rec_get_offsets_func(const rec_t*,const dict_index_t*,ulint*,ulint,mem_heap_t**)" -> "dict_table_is_comp(const dict_table_t*)"
"rec_get_offsets_func(const rec_t*,const dict_index_t*,ulint*,ulint,mem_heap_t**)" -> "rec_init_offsets(const rec_t*,const dict_index_t*,ulint*)"
"rec_get_offsets_func(const rec_t*,const dict_index_t*,ulint*,ulint,mem_heap_t**)" -> "rec_offs_get_n_alloc(const ulint*)"
"rec_get_n_fields_old(const rec_t*)" -> "rec_get_bit_field_2(const rec_t*,ulint,ulint,ulint)"
"rec_init_offsets(const rec_t*,const dict_index_t*,ulint*)" -> "rec_1_get_field_end_info(const rec_t*,ulint)"
"rec_init_offsets(const rec_t*,const dict_index_t*,ulint*)" -> "__builtin_expect(long int,long int)"
"rec_init_offsets(const rec_t*,const dict_index_t*,ulint*)" -> "dict_table_is_comp(const dict_table_t*)"
"rec_init_offsets(const rec_t*,const dict_index_t*,ulint*)" -> "ut_dbg_assertion_failed(const char*,const char*,ulint)"
"rec_init_offsets(const rec_t*,const dict_index_t*,ulint*)" -> "dict_field_get_col(const dict_field_t*)"
"rec_init_offsets(const rec_t*,const dict_index_t*,ulint*)" -> "rec_get_1byte_offs_flag(const rec_t*)"
"rec_init_offsets(const rec_t*,const dict_index_t*,ulint*)" -> "rec_init_offsets_comp_ordinary(const rec_t*,bool,const dict_index_t*,ulint*)"
"rec_init_offsets(const rec_t*,const dict_index_t*,ulint*)" -> "dict_index_get_n_unique_in_tree(const dict_index_t*)"
"rec_init_offsets(const rec_t*,const dict_index_t*,ulint*)" -> "abort()"
"rec_init_offsets(const rec_t*,const dict_index_t*,ulint*)" -> "rec_2_get_field_end_info(const rec_t*,ulint)"
"rec_init_offsets(const rec_t*,const dict_index_t*,ulint*)" -> "rec_offs_n_fields(const ulint*)"
"rec_init_offsets(const rec_t*,const dict_index_t*,ulint*)" -> "rec_get_status(const rec_t*)"
"rec_1_get_field_end_info(const rec_t*,ulint)" -> "mach_read_from_1(const unsigned char*)"
"rec_get_1byte_offs_flag(const rec_t*)" -> "rec_get_bit_field_1(const rec_t*,ulint,ulint,ulint)"
"rec_init_offsets_comp_ordinary(const rec_t*,bool,const dict_index_t*,ulint*)" -> "__builtin_expect(long int,long int)"
"rec_init_offsets_comp_ordinary(const rec_t*,bool,const dict_index_t*,ulint*)" -> "dict_col_get_fixed_size(const dict_col_t*,ulint)"
"rec_init_offsets_comp_ordinary(const rec_t*,bool,const dict_index_t*,ulint*)" -> "dict_table_is_comp(const dict_table_t*)"
"rec_init_offsets_comp_ordinary(const rec_t*,bool,const dict_index_t*,ulint*)" -> "rec_offs_n_fields(const ulint*)"
"rec_init_offsets_comp_ordinary(const rec_t*,bool,const dict_index_t*,ulint*)" -> "dict_field_get_col(const dict_field_t*)"
"dict_col_get_fixed_size(const dict_col_t*,ulint)" -> "dtype_get_fixed_size_low(ulint,ulint,ulint,ulint,ulint)"
"dtype_get_fixed_size_low(ulint,ulint,ulint,ulint,ulint)" -> "ut_dbg_assertion_failed(const char*,const char*,ulint)"
"dtype_get_fixed_size_low(ulint,ulint,ulint,ulint,ulint)" -> "abort()"
"dtype_get_fixed_size_low(ulint,ulint,ulint,ulint,ulint)" -> "__builtin_expect(long int,long int)"
"rec_2_get_field_end_info(const rec_t*,ulint)" -> "mach_read_from_2(const unsigned char*)"
"page_zip_compress_clust_ext(z_stream*,const rec_t*,const ulint*,ulint,unsigned char*,unsigned char*,unsigned char**,ulint*)" -> "rec_get_heap_no_new(const rec_t*)"
"page_zip_compress_clust_ext(z_stream*,const rec_t*,const ulint*,ulint,unsigned char*,unsigned char*,unsigned char**,ulint*)" -> "page_zip_dir_find_low(unsigned char*,unsigned char*,ulint)"
"page_zip_compress_clust_ext(z_stream*,const rec_t*,const ulint*,ulint,unsigned char*,unsigned char*,unsigned char**,ulint*)" -> "rec_offs_n_fields(const ulint*)"
"page_zip_compress_clust_ext(z_stream*,const rec_t*,const ulint*,ulint,unsigned char*,unsigned char*,unsigned char**,ulint*)" -> "rec_offs_nth_extern(const ulint*,ulint)"
"page_zip_compress_clust_ext(z_stream*,const rec_t*,const ulint*,ulint,unsigned char*,unsigned char*,unsigned char**,ulint*)" -> "__builtin_expect(long int,long int)"
"page_zip_compress_clust_ext(z_stream*,const rec_t*,const ulint*,ulint,unsigned char*,unsigned char*,unsigned char**,ulint*)" -> "deflate(z_streamp,int)"
"page_zip_compress_clust_ext(z_stream*,const rec_t*,const ulint*,ulint,unsigned char*,unsigned char*,unsigned char**,ulint*)" -> "memcpy(void*,const void*,size_t)"
"page_zip_compress_clust_ext(z_stream*,const rec_t*,const ulint*,ulint,unsigned char*,unsigned char*,unsigned char**,ulint*)" -> "page_offset(const void*)"
"page_zip_compress_clust_ext(z_stream*,const rec_t*,const ulint*,ulint,unsigned char*,unsigned char*,unsigned char**,ulint*)" -> "rec_get_nth_field_offs(const ulint*,ulint,ulint*)"
"page_zip_dir_find_low(unsigned char*,unsigned char*,ulint)" -> "mach_read_from_2(const unsigned char*)"
"page_get_n_recs(const ib_page_t*)" -> "page_header_get_field(const ib_page_t*,ulint)"
"mem_heap_zalloc(mem_heap_t*,ulint)" -> "mem_heap_alloc(mem_heap_t*,ulint)"
"mem_heap_zalloc(mem_heap_t*,ulint)" -> "memset(void*,int,size_t)"
"dict_index_zip_success(dict_index_t*)" -> "pfs_os_fast_mutex_unlock(os_fast_mutex_t*)"
"dict_index_zip_success(dict_index_t*)" -> "dict_index_zip_pad_update(zip_pad_info_t*,ulint)"
"dict_index_zip_success(dict_index_t*)" -> "pfs_os_fast_mutex_lock(os_fast_mutex_t*,const char*,ulint)"
"dict_index_zip_pad_update(zip_pad_info_t*,ulint)" -> "__sync_add_and_fetch_8(volatile void*,long unsigned int)"
"dict_index_zip_pad_update(zip_pad_info_t*,ulint)" -> "__sync_sub_and_fetch_8(volatile void*,long unsigned int)"
"page_zip_compress_write_log(const page_zip_des_t*,const ib_page_t*,dict_index_t*,mtr_t*)" -> "page_is_leaf(const ib_page_t*)"
"page_zip_compress_write_log(const page_zip_des_t*,const ib_page_t*,dict_index_t*,mtr_t*)" -> "page_dir_get_n_heap(const ib_page_t*)"
"page_zip_compress_write_log(const page_zip_des_t*,const ib_page_t*,dict_index_t*,mtr_t*)" -> "mach_write_to_2(unsigned char*,ulint)"
"page_zip_compress_write_log(const page_zip_des_t*,const ib_page_t*,dict_index_t*,mtr_t*)" -> "dict_index_is_clust(const dict_index_t*)"
"page_zip_compress_write_log(const page_zip_des_t*,const ib_page_t*,dict_index_t*,mtr_t*)" -> "__builtin_expect(long int,long int)"
"page_zip_compress_write_log(const page_zip_des_t*,const ib_page_t*,dict_index_t*,mtr_t*)" -> "mlog_close(mtr_t*,unsigned char*)"
"page_zip_compress_write_log(const page_zip_des_t*,const ib_page_t*,dict_index_t*,mtr_t*)" -> "abort()"
"page_zip_compress_write_log(const page_zip_des_t*,const ib_page_t*,dict_index_t*,mtr_t*)" -> "mlog_write_initial_log_record_fast(const unsigned char*,unsigned char,unsigned char*,mtr_t*)"
"page_zip_compress_write_log(const page_zip_des_t*,const ib_page_t*,dict_index_t*,mtr_t*)" -> "page_zip_get_size(const page_zip_des_t*)"
"page_zip_compress_write_log(const page_zip_des_t*,const ib_page_t*,dict_index_t*,mtr_t*)" -> "mlog_open(mtr_t*,ulint)"
"page_zip_compress_write_log(const page_zip_des_t*,const ib_page_t*,dict_index_t*,mtr_t*)" -> "mlog_catenate_string(mtr_t*,const unsigned char*,ulint)"
"page_zip_compress_write_log(const page_zip_des_t*,const ib_page_t*,dict_index_t*,mtr_t*)" -> "ut_dbg_assertion_failed(const char*,const char*,ulint)"
"page_zip_dir_encode(const ib_page_t*,unsigned char*,const rec_t**)" -> "rec_get_n_owned_new(const rec_t*)"
"page_zip_dir_encode(const ib_page_t*,unsigned char*,const rec_t**)" -> "rec_get_heap_no_new(const rec_t*)"
"page_zip_dir_encode(const ib_page_t*,unsigned char*,const rec_t**)" -> "__builtin_expect(long int,long int)"
"page_zip_dir_encode(const ib_page_t*,unsigned char*,const rec_t**)" -> "page_dir_get_n_heap(const ib_page_t*)"
"page_zip_dir_encode(const ib_page_t*,unsigned char*,const rec_t**)" -> "ut_dbg_assertion_failed(const char*,const char*,ulint)"
"page_zip_dir_encode(const ib_page_t*,unsigned char*,const rec_t**)" -> "rec_get_info_bits(const rec_t*,ulint)"
"page_zip_dir_encode(const ib_page_t*,unsigned char*,const rec_t**)" -> "mach_write_to_2(unsigned char*,ulint)"
"page_zip_dir_encode(const ib_page_t*,unsigned char*,const rec_t**)" -> "page_is_leaf(const ib_page_t*)"
"page_zip_dir_encode(const ib_page_t*,unsigned char*,const rec_t**)" -> "page_header_get_field(const ib_page_t*,ulint)"
"page_zip_dir_encode(const ib_page_t*,unsigned char*,const rec_t**)" -> "rec_get_status(const rec_t*)"
"page_zip_dir_encode(const ib_page_t*,unsigned char*,const rec_t**)" -> "abort()"
"page_zip_dir_encode(const ib_page_t*,unsigned char*,const rec_t**)" -> "mach_read_from_4(const unsigned char*)"
"page_zip_dir_encode(const ib_page_t*,unsigned char*,const rec_t**)" -> "rec_get_next_offs(const rec_t*,ulint)"
"rec_get_n_owned_new(const rec_t*)" -> "rec_get_bit_field_1(const rec_t*,ulint,ulint,ulint)"
"dict_index_zip_failure(dict_index_t*)" -> "pfs_os_fast_mutex_lock(os_fast_mutex_t*,const char*,ulint)"
"dict_index_zip_failure(dict_index_t*)" -> "dict_index_zip_pad_update(zip_pad_info_t*,ulint)"
"dict_index_zip_failure(dict_index_t*)" -> "pfs_os_fast_mutex_unlock(os_fast_mutex_t*)"
"page_zip_fields_encode(ulint,dict_index_t*,ulint,unsigned char*)" -> "__builtin_expect(long int,long int)"
"page_zip_fields_encode(ulint,dict_index_t*,ulint,unsigned char*)" -> "dict_field_get_col(const dict_field_t*)"
"page_zip_fields_encode(ulint,dict_index_t*,ulint,unsigned char*)" -> "page_zip_fixed_field_encode(unsigned char*,ulint)"
"page_zip_fixed_field_encode(unsigned char*,ulint)" -> "__builtin_expect(long int,long int)"
"page_zip_compress_sec(z_stream*,const rec_t**,ulint)" -> "deflate(z_streamp,int)"
"page_zip_compress_sec(z_stream*,const rec_t**,ulint)" -> "__builtin_expect(long int,long int)"
"page_zip_compress_node_ptrs(z_stream*,const rec_t**,ulint,dict_index_t*,unsigned char*,mem_heap_t*)" -> "rec_get_heap_no_new(const rec_t*)"
"page_zip_compress_node_ptrs(z_stream*,const rec_t**,ulint,dict_index_t*,unsigned char*,mem_heap_t*)" -> "deflate(z_streamp,int)"
"page_zip_compress_node_ptrs(z_stream*,const rec_t**,ulint,dict_index_t*,unsigned char*,mem_heap_t*)" -> "__builtin_expect(long int,long int)"
"page_zip_compress_node_ptrs(z_stream*,const rec_t**,ulint,dict_index_t*,unsigned char*,mem_heap_t*)" -> "rec_get_offsets_func(const rec_t*,const dict_index_t*,ulint*,ulint,mem_heap_t**)"
"page_zip_compress_node_ptrs(z_stream*,const rec_t**,ulint,dict_index_t*,unsigned char*,mem_heap_t*)" -> "memcpy(void*,const void*,size_t)"
"page_zip_compress_node_ptrs(z_stream*,const rec_t**,ulint,dict_index_t*,unsigned char*,mem_heap_t*)" -> "rec_offs_data_size(const ulint*)"
"page_copy_rec_list_end_no_locks(buf_block_t*,buf_block_t*,rec_t*,dict_index_t*,mtr_t*)" -> "mach_read_from_2(const unsigned char*)"
"page_copy_rec_list_end_no_locks(buf_block_t*,buf_block_t*,rec_t*,dict_index_t*,mtr_t*)" -> "page_cur_insert_rec_low(rec_t*,dict_index_t*,const rec_t*,ulint*,mtr_t*)"
"page_copy_rec_list_end_no_locks(buf_block_t*,buf_block_t*,rec_t*,dict_index_t*,mtr_t*)" -> "page_align(const void*)"
"page_copy_rec_list_end_no_locks(buf_block_t*,buf_block_t*,rec_t*,dict_index_t*,mtr_t*)" -> "page_cur_is_after_last(const page_cur_t*)"
"page_copy_rec_list_end_no_locks(buf_block_t*,buf_block_t*,rec_t*,dict_index_t*,mtr_t*)" -> "__builtin_expect(long int,long int)"
"page_copy_rec_list_end_no_locks(buf_block_t*,buf_block_t*,rec_t*,dict_index_t*,mtr_t*)" -> "btr_corruption_report(const buf_block_t*,const dict_index_t*)"
"page_copy_rec_list_end_no_locks(buf_block_t*,buf_block_t*,rec_t*,dict_index_t*,mtr_t*)" -> "page_is_comp(const ib_page_t*)"
"page_copy_rec_list_end_no_locks(buf_block_t*,buf_block_t*,rec_t*,dict_index_t*,mtr_t*)" -> "mem_heap_free_func(mem_heap_t*,const char*,ulint)"
"page_copy_rec_list_end_no_locks(buf_block_t*,buf_block_t*,rec_t*,dict_index_t*,mtr_t*)" -> "dict_table_is_comp(const dict_table_t*)"
"page_copy_rec_list_end_no_locks(buf_block_t*,buf_block_t*,rec_t*,dict_index_t*,mtr_t*)" -> "buf_page_print(const unsigned char*,ulint,ulint)"
"page_copy_rec_list_end_no_locks(buf_block_t*,buf_block_t*,rec_t*,dict_index_t*,mtr_t*)" -> "fprintf(FILE*,const char*,...)"
"page_copy_rec_list_end_no_locks(buf_block_t*,buf_block_t*,rec_t*,dict_index_t*,mtr_t*)" -> "rec_offs_set_n_alloc(ulint*,ulint)"
"page_copy_rec_list_end_no_locks(buf_block_t*,buf_block_t*,rec_t*,dict_index_t*,mtr_t*)" -> "page_rec_is_comp(const rec_t*)"
"page_copy_rec_list_end_no_locks(buf_block_t*,buf_block_t*,rec_t*,dict_index_t*,mtr_t*)" -> "page_cur_position(const rec_t*,const buf_block_t*,page_cur_t*)"
"page_copy_rec_list_end_no_locks(buf_block_t*,buf_block_t*,rec_t*,dict_index_t*,mtr_t*)" -> "ut_print_timestamp(FILE*)"
"page_copy_rec_list_end_no_locks(buf_block_t*,buf_block_t*,rec_t*,dict_index_t*,mtr_t*)" -> "page_offset(const void*)"
"page_copy_rec_list_end_no_locks(buf_block_t*,buf_block_t*,rec_t*,dict_index_t*,mtr_t*)" -> "page_cur_is_before_first(const page_cur_t*)"
"page_copy_rec_list_end_no_locks(buf_block_t*,buf_block_t*,rec_t*,dict_index_t*,mtr_t*)" -> "page_get_infimum_offset(const ib_page_t*)"
"page_copy_rec_list_end_no_locks(buf_block_t*,buf_block_t*,rec_t*,dict_index_t*,mtr_t*)" -> "ut_dbg_assertion_failed(const char*,const char*,ulint)"
"page_copy_rec_list_end_no_locks(buf_block_t*,buf_block_t*,rec_t*,dict_index_t*,mtr_t*)" -> "rec_get_offsets_func(const rec_t*,const dict_index_t*,ulint*,ulint,mem_heap_t**)"
"page_copy_rec_list_end_no_locks(buf_block_t*,buf_block_t*,rec_t*,dict_index_t*,mtr_t*)" -> "page_cur_move_to_next(page_cur_t*)"
"page_copy_rec_list_end_no_locks(buf_block_t*,buf_block_t*,rec_t*,dict_index_t*,mtr_t*)" -> "abort()"
"page_cur_insert_rec_low(rec_t*,dict_index_t*,const rec_t*,ulint*,mtr_t*)" -> "page_is_comp(const ib_page_t*)"
"page_cur_insert_rec_low(rec_t*,dict_index_t*,const rec_t*,ulint*,mtr_t*)" -> "page_get_n_recs(const ib_page_t*)"
"page_cur_insert_rec_low(rec_t*,dict_index_t*,const rec_t*,ulint*,mtr_t*)" -> "rec_get_next_ptr(rec_t*,ulint)"
"page_cur_insert_rec_low(rec_t*,dict_index_t*,const rec_t*,ulint*,mtr_t*)" -> "rec_get_heap_no_new(const rec_t*)"
"page_cur_insert_rec_low(rec_t*,dict_index_t*,const rec_t*,ulint*,mtr_t*)" -> "page_dir_split_slot(ib_page_t*,page_zip_des_t*,ulint)"
"page_cur_insert_rec_low(rec_t*,dict_index_t*,const rec_t*,ulint*,mtr_t*)" -> "page_header_set_ptr(ib_page_t*,page_zip_des_t*,ulint,const unsigned char*)"
"page_cur_insert_rec_low(rec_t*,dict_index_t*,const rec_t*,ulint*,mtr_t*)" -> "page_rec_get_next(rec_t*)"
"page_cur_insert_rec_low(rec_t*,dict_index_t*,const rec_t*,ulint*,mtr_t*)" -> "page_header_get_offs(const ib_page_t*,ulint)"
"page_cur_insert_rec_low(rec_t*,dict_index_t*,const rec_t*,ulint*,mtr_t*)" -> "rec_set_n_owned_new(rec_t*,page_zip_des_t*,ulint)"
"page_cur_insert_rec_low(rec_t*,dict_index_t*,const rec_t*,ulint*,mtr_t*)" -> "mem_heap_free_func(mem_heap_t*,const char*,ulint)"
"page_cur_insert_rec_low(rec_t*,dict_index_t*,const rec_t*,ulint*,mtr_t*)" -> "page_header_get_field(const ib_page_t*,ulint)"
"page_cur_insert_rec_low(rec_t*,dict_index_t*,const rec_t*,ulint*,mtr_t*)" -> "page_cur_insert_rec_write_log(rec_t*,ulint,rec_t*,dict_index_t*,mtr_t*)"
"page_cur_insert_rec_low(rec_t*,dict_index_t*,const rec_t*,ulint*,mtr_t*)" -> "page_mem_alloc_free(ib_page_t*,page_zip_des_t*,rec_t*,ulint)"
"page_cur_insert_rec_low(rec_t*,dict_index_t*,const rec_t*,ulint*,mtr_t*)" -> "rec_offs_size(const ulint*)"
"page_cur_insert_rec_low(rec_t*,dict_index_t*,const rec_t*,ulint*,mtr_t*)" -> "rec_set_n_owned_old(rec_t*,ulint)"
"page_cur_insert_rec_low(rec_t*,dict_index_t*,const rec_t*,ulint*,mtr_t*)" -> "rec_get_heap_no_old(const rec_t*)"
"page_cur_insert_rec_low(rec_t*,dict_index_t*,const rec_t*,ulint*,mtr_t*)" -> "rec_get_offsets_func(const rec_t*,const dict_index_t*,ulint*,ulint,mem_heap_t**)"
"page_cur_insert_rec_low(rec_t*,dict_index_t*,const rec_t*,ulint*,mtr_t*)" -> "page_align(const void*)"
"page_cur_insert_rec_low(rec_t*,dict_index_t*,const rec_t*,ulint*,mtr_t*)" -> "rec_get_n_owned_new(const rec_t*)"
"page_cur_insert_rec_low(rec_t*,dict_index_t*,const rec_t*,ulint*,mtr_t*)" -> "rec_get_n_owned_old(const rec_t*)"
"page_cur_insert_rec_low(rec_t*,dict_index_t*,const rec_t*,ulint*,mtr_t*)" -> "page_header_set_field(ib_page_t*,page_zip_des_t*,ulint,ulint)"
"page_cur_insert_rec_low(rec_t*,dict_index_t*,const rec_t*,ulint*,mtr_t*)" -> "rec_set_heap_no_new(rec_t*,ulint)"
"page_cur_insert_rec_low(rec_t*,dict_index_t*,const rec_t*,ulint*,mtr_t*)" -> "rec_offs_set_n_alloc(ulint*,ulint)"
"page_cur_insert_rec_low(rec_t*,dict_index_t*,const rec_t*,ulint*,mtr_t*)" -> "rec_copy(void*,const rec_t*,const ulint*)"
"page_cur_insert_rec_low(rec_t*,dict_index_t*,const rec_t*,ulint*,mtr_t*)" -> "page_dir_find_owner_slot(const rec_t*)"
"page_cur_insert_rec_low(rec_t*,dict_index_t*,const rec_t*,ulint*,mtr_t*)" -> "__builtin_expect(long int,long int)"
"page_cur_insert_rec_low(rec_t*,dict_index_t*,const rec_t*,ulint*,mtr_t*)" -> "rec_set_heap_no_old(rec_t*,ulint)"
"page_cur_insert_rec_low(rec_t*,dict_index_t*,const rec_t*,ulint*,mtr_t*)" -> "page_rec_find_owner_rec(rec_t*)"
"page_cur_insert_rec_low(rec_t*,dict_index_t*,const rec_t*,ulint*,mtr_t*)" -> "page_rec_set_next(rec_t*,const rec_t*)"
"page_cur_insert_rec_low(rec_t*,dict_index_t*,const rec_t*,ulint*,mtr_t*)" -> "rec_offs_extra_size(const ulint*)"
"page_cur_insert_rec_low(rec_t*,dict_index_t*,const rec_t*,ulint*,mtr_t*)" -> "page_mem_alloc_heap(ib_page_t*,page_zip_des_t*,ulint,ulint*)"
"rec_get_next_ptr(rec_t*,ulint)" -> "rec_get_next_ptr_const(const rec_t*,ulint)"
"rec_get_next_ptr_const(const rec_t*,ulint)" -> "ut_align_offset(const void*,ulint)"
"rec_get_next_ptr_const(const rec_t*,ulint)" -> "ut_align_down(const void*,ulint)"
"rec_get_next_ptr_const(const rec_t*,ulint)" -> "mach_read_from_2(const unsigned char*)"
"page_dir_split_slot(ib_page_t*,page_zip_des_t*,ulint)" -> "page_dir_slot_get_rec(const page_dir_slot_t*)"
"page_dir_split_slot(ib_page_t*,page_zip_des_t*,ulint)" -> "page_dir_slot_get_n_owned(const page_dir_slot_t*)"
"page_dir_split_slot(ib_page_t*,page_zip_des_t*,ulint)" -> "page_dir_add_slot(ib_page_t*,page_zip_des_t*,ulint)"
"page_dir_split_slot(ib_page_t*,page_zip_des_t*,ulint)" -> "page_dir_slot_set_n_owned(page_dir_slot_t*,page_zip_des_t*,ulint)"
"page_dir_split_slot(ib_page_t*,page_zip_des_t*,ulint)" -> "page_rec_get_next(rec_t*)"
"page_dir_split_slot(ib_page_t*,page_zip_des_t*,ulint)" -> "page_dir_slot_set_rec(page_dir_slot_t*,rec_t*)"
"page_dir_slot_get_rec(const page_dir_slot_t*)" -> "page_align(const void*)"
"page_dir_slot_get_rec(const page_dir_slot_t*)" -> "mach_read_from_2(const unsigned char*)"
"page_dir_slot_get_n_owned(const page_dir_slot_t*)" -> "rec_get_n_owned_old(const rec_t*)"
"page_dir_slot_get_n_owned(const page_dir_slot_t*)" -> "rec_get_n_owned_new(const rec_t*)"
"page_dir_slot_get_n_owned(const page_dir_slot_t*)" -> "page_dir_slot_get_rec(const page_dir_slot_t*)"
"page_dir_slot_get_n_owned(const page_dir_slot_t*)" -> "page_rec_is_comp(const rec_t*)"
"rec_get_n_owned_old(const rec_t*)" -> "rec_get_bit_field_1(const rec_t*,ulint,ulint,ulint)"
"page_dir_add_slot(ib_page_t*,page_zip_des_t*,ulint)" -> "memmove(void*,const void*,size_t)"
"page_dir_add_slot(ib_page_t*,page_zip_des_t*,ulint)" -> "page_dir_set_n_slots(ib_page_t*,page_zip_des_t*,ulint)"
"page_dir_add_slot(ib_page_t*,page_zip_des_t*,ulint)" -> "page_dir_get_n_slots(const ib_page_t*)"
"page_dir_set_n_slots(ib_page_t*,page_zip_des_t*,ulint)" -> "page_header_set_field(ib_page_t*,page_zip_des_t*,ulint,ulint)"
"page_dir_get_n_slots(const ib_page_t*)" -> "page_header_get_field(const ib_page_t*,ulint)"
"page_dir_slot_set_n_owned(page_dir_slot_t*,page_zip_des_t*,ulint)" -> "page_rec_is_comp(const rec_t*)"
"page_dir_slot_set_n_owned(page_dir_slot_t*,page_zip_des_t*,ulint)" -> "rec_set_n_owned_old(rec_t*,ulint)"
"page_dir_slot_set_n_owned(page_dir_slot_t*,page_zip_des_t*,ulint)" -> "rec_set_n_owned_new(rec_t*,page_zip_des_t*,ulint)"
"page_dir_slot_set_n_owned(page_dir_slot_t*,page_zip_des_t*,ulint)" -> "page_dir_slot_get_rec(const page_dir_slot_t*)"
"rec_set_n_owned_old(rec_t*,ulint)" -> "rec_set_bit_field_1(rec_t*,ulint,ulint,ulint,ulint)"
"rec_set_n_owned_new(rec_t*,page_zip_des_t*,ulint)" -> "rec_get_status(const rec_t*)"
"rec_set_n_owned_new(rec_t*,page_zip_des_t*,ulint)" -> "rec_set_bit_field_1(rec_t*,ulint,ulint,ulint,ulint)"
"rec_set_n_owned_new(rec_t*,page_zip_des_t*,ulint)" -> "page_zip_rec_set_owned(page_zip_des_t*,const unsigned char*,ulint)"
"page_zip_rec_set_owned(page_zip_des_t*,const unsigned char*,ulint)" -> "ut_dbg_assertion_failed(const char*,const char*,ulint)"
"page_zip_rec_set_owned(page_zip_des_t*,const unsigned char*,ulint)" -> "__builtin_expect(long int,long int)"
"page_zip_rec_set_owned(page_zip_des_t*,const unsigned char*,ulint)" -> "page_zip_dir_find(page_zip_des_t*,ulint)"
"page_zip_rec_set_owned(page_zip_des_t*,const unsigned char*,ulint)" -> "abort()"
"page_zip_rec_set_owned(page_zip_des_t*,const unsigned char*,ulint)" -> "page_offset(const void*)"
"page_zip_dir_find(page_zip_des_t*,ulint)" -> "page_zip_dir_user_size(const page_zip_des_t*)"
"page_zip_dir_find(page_zip_des_t*,ulint)" -> "page_zip_get_size(const page_zip_des_t*)"
"page_zip_dir_find(page_zip_des_t*,ulint)" -> "page_zip_dir_find_low(unsigned char*,unsigned char*,ulint)"
"page_zip_dir_user_size(const page_zip_des_t*)" -> "page_get_n_recs(const ib_page_t*)"
"page_dir_slot_set_rec(page_dir_slot_t*,rec_t*)" -> "page_offset(const void*)"
"page_dir_slot_set_rec(page_dir_slot_t*,rec_t*)" -> "mach_write_to_2(unsigned char*,ulint)"
"page_header_get_offs(const ib_page_t*,ulint)" -> "page_header_get_field(const ib_page_t*,ulint)"
"page_cur_insert_rec_write_log(rec_t*,ulint,rec_t*,dict_index_t*,mtr_t*)" -> "rec_get_offsets_func(const rec_t*,const dict_index_t*,ulint*,ulint,mem_heap_t**)"
"page_cur_insert_rec_write_log(rec_t*,ulint,rec_t*,dict_index_t*,mtr_t*)" -> "mach_write_to_1(unsigned char*,ulint)"
"page_cur_insert_rec_write_log(rec_t*,ulint,rec_t*,dict_index_t*,mtr_t*)" -> "mlog_catenate_string(mtr_t*,const unsigned char*,ulint)"
"page_cur_insert_rec_write_log(rec_t*,ulint,rec_t*,dict_index_t*,mtr_t*)" -> "page_offset(const void*)"
"page_cur_insert_rec_write_log(rec_t*,ulint,rec_t*,dict_index_t*,mtr_t*)" -> "page_rec_is_comp(const rec_t*)"
"page_cur_insert_rec_write_log(rec_t*,ulint,rec_t*,dict_index_t*,mtr_t*)" -> "mach_write_to_2(unsigned char*,ulint)"
"page_cur_insert_rec_write_log(rec_t*,ulint,rec_t*,dict_index_t*,mtr_t*)" -> "rec_offs_set_n_alloc(ulint*,ulint)"
"page_cur_insert_rec_write_log(rec_t*,ulint,rec_t*,dict_index_t*,mtr_t*)" -> "page_rec_get_base_extra_size(const rec_t*)"
"page_cur_insert_rec_write_log(rec_t*,ulint,rec_t*,dict_index_t*,mtr_t*)" -> "mlog_close(mtr_t*,unsigned char*)"
"page_cur_insert_rec_write_log(rec_t*,ulint,rec_t*,dict_index_t*,mtr_t*)" -> "mem_heap_free_func(mem_heap_t*,const char*,ulint)"
"page_cur_insert_rec_write_log(rec_t*,ulint,rec_t*,dict_index_t*,mtr_t*)" -> "ut_dbg_assertion_failed(const char*,const char*,ulint)"
"page_cur_insert_rec_write_log(rec_t*,ulint,rec_t*,dict_index_t*,mtr_t*)" -> "__builtin_expect(long int,long int)"
"page_cur_insert_rec_write_log(rec_t*,ulint,rec_t*,dict_index_t*,mtr_t*)" -> "mtr_get_log_mode(mtr_t*)"
"page_cur_insert_rec_write_log(rec_t*,ulint,rec_t*,dict_index_t*,mtr_t*)" -> "mlog_write_initial_log_record_fast(const unsigned char*,unsigned char,unsigned char*,mtr_t*)"
"page_cur_insert_rec_write_log(rec_t*,ulint,rec_t*,dict_index_t*,mtr_t*)" -> "memcpy(void*,const void*,size_t)"
"page_cur_insert_rec_write_log(rec_t*,ulint,rec_t*,dict_index_t*,mtr_t*)" -> "rec_get_info_and_status_bits(const rec_t*,ulint)"
"page_cur_insert_rec_write_log(rec_t*,ulint,rec_t*,dict_index_t*,mtr_t*)" -> "ut_min(ulint,ulint)"
"page_cur_insert_rec_write_log(rec_t*,ulint,rec_t*,dict_index_t*,mtr_t*)" -> "rec_offs_size(const ulint*)"
"page_cur_insert_rec_write_log(rec_t*,ulint,rec_t*,dict_index_t*,mtr_t*)" -> "mach_write_compressed(unsigned char*,ulint)"
"page_cur_insert_rec_write_log(rec_t*,ulint,rec_t*,dict_index_t*,mtr_t*)" -> "mlog_open(mtr_t*,ulint)"
"page_cur_insert_rec_write_log(rec_t*,ulint,rec_t*,dict_index_t*,mtr_t*)" -> "rec_offs_extra_size(const ulint*)"
"page_cur_insert_rec_write_log(rec_t*,ulint,rec_t*,dict_index_t*,mtr_t*)" -> "mlog_open_and_write_index(mtr_t*,const unsigned char*,const dict_index_t*,unsigned char,ulint)"
"page_cur_insert_rec_write_log(rec_t*,ulint,rec_t*,dict_index_t*,mtr_t*)" -> "abort()"
"page_rec_get_base_extra_size(const rec_t*)" -> "page_rec_is_comp(const rec_t*)"
"mlog_open_and_write_index(mtr_t*,const unsigned char*,const dict_index_t*,unsigned char,ulint)" -> "__builtin_expect(long int,long int)"
"mlog_open_and_write_index(mtr_t*,const unsigned char*,const dict_index_t*,unsigned char,ulint)" -> "mlog_close(mtr_t*,unsigned char*)"
"mlog_open_and_write_index(mtr_t*,const unsigned char*,const dict_index_t*,unsigned char,ulint)" -> "mlog_write_initial_log_record_fast(const unsigned char*,unsigned char,unsigned char*,mtr_t*)"
"mlog_open_and_write_index(mtr_t*,const unsigned char*,const dict_index_t*,unsigned char,ulint)" -> "ut_dbg_assertion_failed(const char*,const char*,ulint)"
"mlog_open_and_write_index(mtr_t*,const unsigned char*,const dict_index_t*,unsigned char,ulint)" -> "dict_index_get_n_fields(const dict_index_t*)"
"mlog_open_and_write_index(mtr_t*,const unsigned char*,const dict_index_t*,unsigned char,ulint)" -> "abort()"
"mlog_open_and_write_index(mtr_t*,const unsigned char*,const dict_index_t*,unsigned char,ulint)" -> "dict_index_get_n_unique_in_tree(const dict_index_t*)"
"mlog_open_and_write_index(mtr_t*,const unsigned char*,const dict_index_t*,unsigned char,ulint)" -> "mlog_open(mtr_t*,ulint)"
"mlog_open_and_write_index(mtr_t*,const unsigned char*,const dict_index_t*,unsigned char,ulint)" -> "page_rec_is_comp(const rec_t*)"
"mlog_open_and_write_index(mtr_t*,const unsigned char*,const dict_index_t*,unsigned char,ulint)" -> "dict_field_get_col(const dict_field_t*)"
"mlog_open_and_write_index(mtr_t*,const unsigned char*,const dict_index_t*,unsigned char,ulint)" -> "mach_write_to_2(unsigned char*,ulint)"
"rec_get_heap_no_old(const rec_t*)" -> "rec_get_bit_field_2(const rec_t*,ulint,ulint,ulint)"
"rec_set_heap_no_new(rec_t*,ulint)" -> "rec_set_bit_field_2(rec_t*,ulint,ulint,ulint,ulint)"
"rec_set_bit_field_2(rec_t*,ulint,ulint,ulint,ulint)" -> "mach_write_to_2(unsigned char*,ulint)"
"rec_set_bit_field_2(rec_t*,ulint,ulint,ulint,ulint)" -> "mach_read_from_2(const unsigned char*)"
"rec_copy(void*,const rec_t*,const ulint*)" -> "ut_memcpy(void*,const void*,ulint)"
"rec_copy(void*,const rec_t*,const ulint*)" -> "rec_offs_data_size(const ulint*)"
"rec_copy(void*,const rec_t*,const ulint*)" -> "rec_offs_extra_size(const ulint*)"
"ut_memcpy(void*,const void*,ulint)" -> "memcpy(void*,const void*,size_t)"
"page_dir_find_owner_slot(const rec_t*)" -> "__builtin_fwrite(const void*,size_t,size_t,FILE*)"
"page_dir_find_owner_slot(const rec_t*)" -> "mach_encode_2(ulint)"
"page_dir_find_owner_slot(const rec_t*)" -> "rec_print_old(FILE*,const rec_t*)"
"page_dir_find_owner_slot(const rec_t*)" -> "page_dir_get_n_slots(const ib_page_t*)"
"page_dir_find_owner_slot(const rec_t*)" -> "buf_page_print(const unsigned char*,ulint,ulint)"
"page_dir_find_owner_slot(const rec_t*)" -> "rec_get_n_owned_old(const rec_t*)"
"page_dir_find_owner_slot(const rec_t*)" -> "page_get_page_no(const ib_page_t*)"
"page_dir_find_owner_slot(const rec_t*)" -> "rec_get_n_owned_new(const rec_t*)"
"page_dir_find_owner_slot(const rec_t*)" -> "abort()"
"page_dir_find_owner_slot(const rec_t*)" -> "fprintf(FILE*,const char*,...)"
"page_dir_find_owner_slot(const rec_t*)" -> "__builtin_expect(long int,long int)"
"page_dir_find_owner_slot(const rec_t*)" -> "mach_decode_2(uint16)"
"page_dir_find_owner_slot(const rec_t*)" -> "page_align(const void*)"
"page_dir_find_owner_slot(const rec_t*)" -> "ut_dbg_assertion_failed(const char*,const char*,ulint)"
"page_dir_find_owner_slot(const rec_t*)" -> "rec_get_next_ptr_const(const rec_t*,ulint)"
"page_dir_find_owner_slot(const rec_t*)" -> "page_is_comp(const ib_page_t*)"
"mach_encode_2(ulint)" -> "mach_write_to_2(unsigned char*,ulint)"
"rec_print_old(FILE*,const rec_t*)" -> "rec_get_info_bits(const rec_t*,ulint)"
"rec_print_old(FILE*,const rec_t*)" -> "fprintf(FILE*,const char*,...)"
"rec_print_old(FILE*,const rec_t*)" -> "_IO_putc(int,_IO_FILE*)"
"rec_print_old(FILE*,const rec_t*)" -> "rec_get_nth_field_size(const rec_t*,ulint)"
"rec_print_old(FILE*,const rec_t*)" -> "ut_print_buf(FILE*,const void*,ulint)"
"rec_print_old(FILE*,const rec_t*)" -> "rec_get_n_fields_old(const rec_t*)"
"rec_print_old(FILE*,const rec_t*)" -> "rec_validate_old(const rec_t*)"
"rec_print_old(FILE*,const rec_t*)" -> "rec_get_1byte_offs_flag(const rec_t*)"
"rec_print_old(FILE*,const rec_t*)" -> "rec_get_nth_field_offs_old(const rec_t*,ulint,ulint*)"
"rec_get_nth_field_size(const rec_t*,ulint)" -> "rec_get_field_start_offs(const rec_t*,ulint)"
"rec_get_field_start_offs(const rec_t*,ulint)" -> "rec_2_get_field_start_offs(const rec_t*,ulint)"
"rec_get_field_start_offs(const rec_t*,ulint)" -> "rec_get_1byte_offs_flag(const rec_t*)"
"rec_get_field_start_offs(const rec_t*,ulint)" -> "rec_1_get_field_start_offs(const rec_t*,ulint)"
"rec_2_get_field_start_offs(const rec_t*,ulint)" -> "rec_2_get_prev_field_end_info(const rec_t*,ulint)"
"rec_2_get_prev_field_end_info(const rec_t*,ulint)" -> "mach_read_from_2(const unsigned char*)"
"rec_1_get_field_start_offs(const rec_t*,ulint)" -> "rec_1_get_prev_field_end_info(const rec_t*,ulint)"
"rec_1_get_prev_field_end_info(const rec_t*,ulint)" -> "mach_read_from_1(const unsigned char*)"
"rec_validate_old(const rec_t*)" -> "__builtin_expect(long int,long int)"
"rec_validate_old(const rec_t*)" -> "fprintf(FILE*,const char*,...)"
"rec_validate_old(const rec_t*)" -> "rec_get_n_fields_old(const rec_t*)"
"rec_validate_old(const rec_t*)" -> "ut_dbg_assertion_failed(const char*,const char*,ulint)"
"rec_validate_old(const rec_t*)" -> "rec_get_data_size_old(const rec_t*)"
"rec_validate_old(const rec_t*)" -> "abort()"
"rec_validate_old(const rec_t*)" -> "rec_get_nth_field_size(const rec_t*,ulint)"
"rec_validate_old(const rec_t*)" -> "rec_get_nth_field_offs_old(const rec_t*,ulint,ulint*)"
"rec_get_data_size_old(const rec_t*)" -> "rec_get_field_start_offs(const rec_t*,ulint)"
"rec_get_data_size_old(const rec_t*)" -> "rec_get_n_fields_old(const rec_t*)"
"rec_get_nth_field_offs_old(const rec_t*,ulint,ulint*)" -> "rec_2_get_field_start_offs(const rec_t*,ulint)"
"rec_get_nth_field_offs_old(const rec_t*,ulint,ulint*)" -> "__builtin_expect(long int,long int)"
"rec_get_nth_field_offs_old(const rec_t*,ulint,ulint*)" -> "rec_get_n_fields_old(const rec_t*)"
"rec_get_nth_field_offs_old(const rec_t*,ulint,ulint*)" -> "rec_2_get_field_end_info(const rec_t*,ulint)"
"rec_get_nth_field_offs_old(const rec_t*,ulint,ulint*)" -> "rec_1_get_field_end_info(const rec_t*,ulint)"
"rec_get_nth_field_offs_old(const rec_t*,ulint,ulint*)" -> "rec_1_get_field_start_offs(const rec_t*,ulint)"
"rec_get_nth_field_offs_old(const rec_t*,ulint,ulint*)" -> "ut_dbg_assertion_failed(const char*,const char*,ulint)"
"rec_get_nth_field_offs_old(const rec_t*,ulint,ulint*)" -> "rec_get_1byte_offs_flag(const rec_t*)"
"rec_get_nth_field_offs_old(const rec_t*,ulint,ulint*)" -> "abort()"
"mach_decode_2(uint16)" -> "mach_read_from_2(const unsigned char*)"
"rec_set_heap_no_old(rec_t*,ulint)" -> "rec_set_bit_field_2(rec_t*,ulint,ulint,ulint,ulint)"
"page_rec_find_owner_rec(rec_t*)" -> "rec_get_n_owned_old(const rec_t*)"
"page_rec_find_owner_rec(rec_t*)" -> "rec_get_n_owned_new(const rec_t*)"
"page_rec_find_owner_rec(rec_t*)" -> "page_rec_is_comp(const rec_t*)"
"page_rec_find_owner_rec(rec_t*)" -> "page_rec_get_next(rec_t*)"
"page_rec_set_next(rec_t*,const rec_t*)" -> "page_offset(const void*)"
"page_rec_set_next(rec_t*,const rec_t*)" -> "page_rec_is_comp(const rec_t*)"
"page_rec_set_next(rec_t*,const rec_t*)" -> "rec_set_next_offs_old(rec_t*,ulint)"
"page_rec_set_next(rec_t*,const rec_t*)" -> "rec_set_next_offs_new(rec_t*,ulint)"
"rec_set_next_offs_old(rec_t*,ulint)" -> "mach_write_to_2(unsigned char*,ulint)"
"rec_set_next_offs_new(rec_t*,ulint)" -> "ut_align_offset(const void*,ulint)"
"rec_set_next_offs_new(rec_t*,ulint)" -> "mach_write_to_2(unsigned char*,ulint)"
"page_mem_alloc_heap(ib_page_t*,page_zip_des_t*,ulint,ulint*)" -> "page_dir_set_n_heap(ib_page_t*,page_zip_des_t*,ulint)"
"page_mem_alloc_heap(ib_page_t*,page_zip_des_t*,ulint,ulint*)" -> "page_get_max_insert_size(const ib_page_t*,ulint)"
"page_mem_alloc_heap(ib_page_t*,page_zip_des_t*,ulint,ulint*)" -> "page_header_set_ptr(ib_page_t*,page_zip_des_t*,ulint,const unsigned char*)"
"page_mem_alloc_heap(ib_page_t*,page_zip_des_t*,ulint,ulint*)" -> "page_header_get_offs(const ib_page_t*,ulint)"
"page_mem_alloc_heap(ib_page_t*,page_zip_des_t*,ulint,ulint*)" -> "page_dir_get_n_heap(const ib_page_t*)"
"page_dir_set_n_heap(ib_page_t*,page_zip_des_t*,ulint)" -> "page_header_set_field(ib_page_t*,page_zip_des_t*,ulint,ulint)"
"page_dir_set_n_heap(ib_page_t*,page_zip_des_t*,ulint)" -> "page_header_get_field(const ib_page_t*,ulint)"
"page_get_max_insert_size(const ib_page_t*,ulint)" -> "page_get_free_space_of_empty(ulint)"
"page_get_max_insert_size(const ib_page_t*,ulint)" -> "page_is_comp(const ib_page_t*)"
"page_get_max_insert_size(const ib_page_t*,ulint)" -> "page_dir_get_n_heap(const ib_page_t*)"
"page_get_max_insert_size(const ib_page_t*,ulint)" -> "page_header_get_field(const ib_page_t*,ulint)"
"page_get_max_insert_size(const ib_page_t*,ulint)" -> "page_dir_calc_reserved_space(ulint)"
"btr_corruption_report(const buf_block_t*,const dict_index_t*)" -> "buf_block_get_space(const buf_block_t*)"
"btr_corruption_report(const buf_block_t*,const dict_index_t*)" -> "buf_page_print(const unsigned char*,ulint,ulint)"
"btr_corruption_report(const buf_block_t*,const dict_index_t*)" -> "fprintf(FILE*,const char*,...)"
"btr_corruption_report(const buf_block_t*,const dict_index_t*)" -> "buf_block_get_zip_size(const buf_block_t*)"
"btr_corruption_report(const buf_block_t*,const dict_index_t*)" -> "buf_block_get_page_no(const buf_block_t*)"
"buf_block_get_space(const buf_block_t*)" -> "buf_block_get_state(const buf_block_t*)"
"buf_block_get_space(const buf_block_t*)" -> "__builtin_expect(long int,long int)"
"buf_block_get_space(const buf_block_t*)" -> "ut_dbg_assertion_failed(const char*,const char*,ulint)"
"buf_block_get_space(const buf_block_t*)" -> "abort()"
"page_cur_is_before_first(const page_cur_t*)" -> "page_rec_is_infimum(const rec_t*)"
"page_rec_is_infimum(const rec_t*)" -> "page_rec_is_infimum_low(ulint)"
"page_rec_is_infimum(const rec_t*)" -> "page_offset(const void*)"
"page_get_infimum_offset(const ib_page_t*)" -> "page_is_comp(const ib_page_t*)"
"page_create(buf_block_t*,mtr_t*,ulint)" -> "page_create_write_log(buf_frame_t*,mtr_t*,ulint)"
"page_create(buf_block_t*,mtr_t*,ulint)" -> "page_create_low(buf_block_t*,ulint)"
"page_create_write_log(buf_frame_t*,mtr_t*,ulint)" -> "mlog_write_initial_log_record(const unsigned char*,unsigned char,mtr_t*)"
"mlog_write_initial_log_record(const unsigned char*,unsigned char,mtr_t*)" -> "mlog_close(mtr_t*,unsigned char*)"
"mlog_write_initial_log_record(const unsigned char*,unsigned char,mtr_t*)" -> "mlog_open(mtr_t*,ulint)"
"mlog_write_initial_log_record(const unsigned char*,unsigned char,mtr_t*)" -> "mlog_write_initial_log_record_fast(const unsigned char*,unsigned char,unsigned char*,mtr_t*)"
"page_create_low(buf_block_t*,ulint)" -> "dtuple_set_info_bits(dtuple_t*,ulint)"
"page_create_low(buf_block_t*,ulint)" -> "page_dir_slot_set_rec(page_dir_slot_t*,rec_t*)"
"page_create_low(buf_block_t*,ulint)" -> "dtuple_create(mem_heap_t*,ulint)"
"page_create_low(buf_block_t*,ulint)" -> "rec_get_offsets_func(const rec_t*,const dict_index_t*,ulint*,ulint,mem_heap_t**)"
"page_create_low(buf_block_t*,ulint)" -> "rec_set_heap_no_new(rec_t*,ulint)"
"page_create_low(buf_block_t*,ulint)" -> "rec_set_n_owned_old(rec_t*,ulint)"
"page_create_low(buf_block_t*,ulint)" -> "dfield_set_data(dfield_t*,const void*,ulint)"
"page_create_low(buf_block_t*,ulint)" -> "rec_offs_data_size(const ulint*)"
"page_create_low(buf_block_t*,ulint)" -> "rec_set_n_owned_new(rec_t*,page_zip_des_t*,ulint)"
"page_create_low(buf_block_t*,ulint)" -> "rec_convert_dtuple_to_rec(unsigned char*,const dict_index_t*,const dtuple_t*,ulint)"
"page_create_low(buf_block_t*,ulint)" -> "rec_set_next_offs_old(rec_t*,ulint)"
"page_create_low(buf_block_t*,ulint)" -> "__builtin_expect(long int,long int)"
"page_create_low(buf_block_t*,ulint)" -> "rec_set_heap_no_old(rec_t*,ulint)"
"page_create_low(buf_block_t*,ulint)" -> "buf_block_modify_clock_inc(buf_block_t*)"
"page_create_low(buf_block_t*,ulint)" -> "page_offset(const void*)"
"page_create_low(buf_block_t*,ulint)" -> "page_header_set_field(ib_page_t*,page_zip_des_t*,ulint,ulint)"
"page_create_low(buf_block_t*,ulint)" -> "page_header_set_ptr(ib_page_t*,page_zip_des_t*,ulint,const unsigned char*)"
"page_create_low(buf_block_t*,ulint)" -> "fil_page_set_type(unsigned char*,ulint)"
"page_create_low(buf_block_t*,ulint)" -> "ut_dbg_assertion_failed(const char*,const char*,ulint)"
"page_create_low(buf_block_t*,ulint)" -> "mem_heap_create_func(ulint,ulint)"
"page_create_low(buf_block_t*,ulint)" -> "mem_heap_free_func(mem_heap_t*,const char*,ulint)"
"page_create_low(buf_block_t*,ulint)" -> "rec_set_next_offs_new(rec_t*,ulint)"
"page_create_low(buf_block_t*,ulint)" -> "abort()"
"page_create_low(buf_block_t*,ulint)" -> "memset(void*,int,size_t)"
"page_create_low(buf_block_t*,ulint)" -> "dtype_set(dtype_t*,ulint,ulint,ulint)"
"page_create_low(buf_block_t*,ulint)" -> "page_set_max_trx_id(buf_block_t*,page_zip_des_t*,trx_id_t,mtr_t*)"
"dtuple_create(mem_heap_t*,ulint)" -> "mem_heap_alloc(mem_heap_t*,ulint)"
"dtuple_create(mem_heap_t*,ulint)" -> "dtuple_create_from_mem(void*,ulint,ulint)"
"dtuple_create_from_mem(void*,ulint,ulint)" -> "ut_dbg_assertion_failed(const char*,const char*,ulint)"
"dtuple_create_from_mem(void*,ulint,ulint)" -> "__builtin_expect(long int,long int)"
"dtuple_create_from_mem(void*,ulint,ulint)" -> "abort()"
"rec_convert_dtuple_to_rec(unsigned char*,const dict_index_t*,const dtuple_t*,ulint)" -> "dict_table_is_comp(const dict_table_t*)"
"rec_convert_dtuple_to_rec(unsigned char*,const dict_index_t*,const dtuple_t*,ulint)" -> "rec_convert_dtuple_to_rec_new(unsigned char*,const dict_index_t*,const dtuple_t*)"
"rec_convert_dtuple_to_rec(unsigned char*,const dict_index_t*,const dtuple_t*,ulint)" -> "rec_convert_dtuple_to_rec_old(unsigned char*,const dtuple_t*,ulint)"
"rec_convert_dtuple_to_rec_new(unsigned char*,const dict_index_t*,const dtuple_t*)" -> "dtuple_get_info_bits(const dtuple_t*)"
"rec_convert_dtuple_to_rec_new(unsigned char*,const dict_index_t*,const dtuple_t*)" -> "rec_get_converted_size_comp(const dict_index_t*,ulint,const dfield_t*,ulint,ulint*)"
"rec_convert_dtuple_to_rec_new(unsigned char*,const dict_index_t*,const dtuple_t*)" -> "rec_set_info_and_status_bits(rec_t*,ulint)"
"rec_convert_dtuple_to_rec_new(unsigned char*,const dict_index_t*,const dtuple_t*)" -> "rec_convert_dtuple_to_rec_comp(rec_t*,const dict_index_t*,const dfield_t*,ulint,ulint,bool)"
"rec_get_converted_size_comp(const dict_index_t*,ulint,const dfield_t*,ulint,ulint*)" -> "abort()"
"rec_get_converted_size_comp(const dict_index_t*,ulint,const dfield_t*,ulint,ulint*)" -> "rec_get_converted_size_comp_prefix_low(const dict_index_t*,const dfield_t*,ulint,ulint*,bool)"
"rec_get_converted_size_comp(const dict_index_t*,ulint,const dfield_t*,ulint,ulint*)" -> "ut_dbg_assertion_failed(const char*,const char*,ulint)"
"rec_get_converted_size_comp(const dict_index_t*,ulint,const dfield_t*,ulint,ulint*)" -> "__builtin_expect(long int,long int)"
"rec_get_converted_size_comp_prefix_low(const dict_index_t*,const dfield_t*,ulint,ulint*,bool)" -> "dfield_is_null(const dfield_t*)"
"rec_get_converted_size_comp_prefix_low(const dict_index_t*,const dfield_t*,ulint,ulint*,bool)" -> "dfield_get_len(const dfield_t*)"
"rec_get_converted_size_comp_prefix_low(const dict_index_t*,const dfield_t*,ulint,ulint*,bool)" -> "dict_field_get_col(const dict_field_t*)"
"rec_get_converted_size_comp_prefix_low(const dict_index_t*,const dfield_t*,ulint,ulint*,bool)" -> "dfield_is_ext(const dfield_t*)"
"rec_get_converted_size_comp_prefix_low(const dict_index_t*,const dfield_t*,ulint,ulint*,bool)" -> "dict_col_get_fixed_size(const dict_col_t*,ulint)"
"rec_get_converted_size_comp_prefix_low(const dict_index_t*,const dfield_t*,ulint,ulint*,bool)" -> "dict_table_is_comp(const dict_table_t*)"
"rec_convert_dtuple_to_rec_comp(rec_t*,const dict_index_t*,const dfield_t*,ulint,ulint,bool)" -> "dict_table_is_comp(const dict_table_t*)"
"rec_convert_dtuple_to_rec_comp(rec_t*,const dict_index_t*,const dfield_t*,ulint,ulint,bool)" -> "abort()"
"rec_convert_dtuple_to_rec_comp(rec_t*,const dict_index_t*,const dfield_t*,ulint,ulint,bool)" -> "dict_col_get_fixed_size(const dict_col_t*,ulint)"
"rec_convert_dtuple_to_rec_comp(rec_t*,const dict_index_t*,const dfield_t*,ulint,ulint,bool)" -> "memset(void*,int,size_t)"
"rec_convert_dtuple_to_rec_comp(rec_t*,const dict_index_t*,const dfield_t*,ulint,ulint,bool)" -> "dfield_is_ext(const dfield_t*)"
"rec_convert_dtuple_to_rec_comp(rec_t*,const dict_index_t*,const dfield_t*,ulint,ulint,bool)" -> "dfield_get_len(const dfield_t*)"
"rec_convert_dtuple_to_rec_comp(rec_t*,const dict_index_t*,const dfield_t*,ulint,ulint,bool)" -> "ut_dbg_assertion_failed(const char*,const char*,ulint)"
"rec_convert_dtuple_to_rec_comp(rec_t*,const dict_index_t*,const dfield_t*,ulint,ulint,bool)" -> "dtype_get_prtype(const dtype_t*)"
"rec_convert_dtuple_to_rec_comp(rec_t*,const dict_index_t*,const dfield_t*,ulint,ulint,bool)" -> "dfield_is_null(const dfield_t*)"
"rec_convert_dtuple_to_rec_comp(rec_t*,const dict_index_t*,const dfield_t*,ulint,ulint,bool)" -> "dtype_get_mtype(const dtype_t*)"
"rec_convert_dtuple_to_rec_comp(rec_t*,const dict_index_t*,const dfield_t*,ulint,ulint,bool)" -> "__builtin_expect(long int,long int)"
"rec_convert_dtuple_to_rec_comp(rec_t*,const dict_index_t*,const dfield_t*,ulint,ulint,bool)" -> "dtype_get_len(const dtype_t*)"
"rec_convert_dtuple_to_rec_comp(rec_t*,const dict_index_t*,const dfield_t*,ulint,ulint,bool)" -> "memcpy(void*,const void*,size_t)"
"rec_convert_dtuple_to_rec_old(unsigned char*,const dtuple_t*,ulint)" -> "data_write_sql_null(unsigned char*,ulint)"
"rec_convert_dtuple_to_rec_old(unsigned char*,const dtuple_t*,ulint)" -> "dtuple_get_info_bits(const dtuple_t*)"
"rec_convert_dtuple_to_rec_old(unsigned char*,const dtuple_t*,ulint)" -> "dtuple_get_data_size(const dtuple_t*,ulint)"
"rec_convert_dtuple_to_rec_old(unsigned char*,const dtuple_t*,ulint)" -> "rec_set_info_bits_old(rec_t*,ulint)"
"rec_convert_dtuple_to_rec_old(unsigned char*,const dtuple_t*,ulint)" -> "dfield_is_null(const dfield_t*)"
"rec_convert_dtuple_to_rec_old(unsigned char*,const dtuple_t*,ulint)" -> "dtuple_get_n_fields(const dtuple_t*)"
"rec_convert_dtuple_to_rec_old(unsigned char*,const dtuple_t*,ulint)" -> "dfield_get_len(const dfield_t*)"
"rec_convert_dtuple_to_rec_old(unsigned char*,const dtuple_t*,ulint)" -> "dtype_get_sql_null_size(const dtype_t*,ulint)"
"rec_convert_dtuple_to_rec_old(unsigned char*,const dtuple_t*,ulint)" -> "dfield_is_ext(const dfield_t*)"
"rec_convert_dtuple_to_rec_old(unsigned char*,const dtuple_t*,ulint)" -> "memcpy(void*,const void*,size_t)"
"rec_convert_dtuple_to_rec_old(unsigned char*,const dtuple_t*,ulint)" -> "rec_get_converted_extra_size(ulint,ulint,ulint)"
"rec_convert_dtuple_to_rec_old(unsigned char*,const dtuple_t*,ulint)" -> "rec_2_set_field_end_info(rec_t*,ulint,ulint)"
"rec_convert_dtuple_to_rec_old(unsigned char*,const dtuple_t*,ulint)" -> "rec_set_1byte_offs_flag(rec_t*,ulint)"
"rec_convert_dtuple_to_rec_old(unsigned char*,const dtuple_t*,ulint)" -> "rec_1_set_field_end_info(rec_t*,ulint,ulint)"
"rec_convert_dtuple_to_rec_old(unsigned char*,const dtuple_t*,ulint)" -> "rec_set_n_fields_old(rec_t*,ulint)"
"data_write_sql_null(unsigned char*,ulint)" -> "memset(void*,int,size_t)"
"dtuple_get_data_size(const dtuple_t*,ulint)" -> "dfield_get_len(const dfield_t*)"
"dtuple_get_data_size(const dtuple_t*,ulint)" -> "dtype_get_sql_null_size(const dtype_t*,ulint)"
"dtype_get_sql_null_size(const dtype_t*,ulint)" -> "dtype_get_fixed_size_low(ulint,ulint,ulint,ulint,ulint)"
"rec_2_set_field_end_info(rec_t*,ulint,ulint)" -> "mach_write_to_2(unsigned char*,ulint)"
"rec_set_1byte_offs_flag(rec_t*,ulint)" -> "rec_set_bit_field_1(rec_t*,ulint,ulint,ulint,ulint)"
"rec_1_set_field_end_info(rec_t*,ulint,ulint)" -> "mach_write_to_1(unsigned char*,ulint)"
"rec_set_n_fields_old(rec_t*,ulint)" -> "rec_set_bit_field_2(rec_t*,ulint,ulint,ulint,ulint)"
"fil_page_set_type(unsigned char*,ulint)" -> "mach_write_to_2(unsigned char*,ulint)"
"dtype_set(dtype_t*,ulint,ulint,ulint)" -> "dtype_set_mblen(dtype_t*)"
"dtype_set_mblen(dtype_t*)" -> "dtype_set_mbminmaxlen(dtype_t*,ulint,ulint)"
"dtype_set_mblen(dtype_t*)" -> "dtype_get_mblen(ulint,ulint,ulint*,ulint*)"
"dtype_get_mblen(ulint,ulint,ulint*,ulint*)" -> "innobase_get_cset_width(ulint,ulint*,ulint*)"
"dtype_get_mblen(ulint,ulint,ulint*,ulint*)" -> "dtype_is_string_type(ulint)"
"dtype_get_mblen(ulint,ulint,ulint*,ulint*)" -> "dtype_get_charset_coll(ulint)"
"innobase_get_cset_width(ulint,ulint*,ulint*)" -> "_current_thd()"
"innobase_get_cset_width(ulint,ulint*,ulint*)" -> "abort()"
"innobase_get_cset_width(ulint,ulint*,ulint*)" -> "__builtin_expect(long int,long int)"
"innobase_get_cset_width(ulint,ulint*,ulint*)" -> "sql_print_warning(const char*,...)"
"innobase_get_cset_width(ulint,ulint*,ulint*)" -> "thd_sql_command(const THD*)"
"innobase_get_cset_width(ulint,ulint*,ulint*)" -> "ut_dbg_assertion_failed(const char*,const char*,ulint)"
"page_set_max_trx_id(buf_block_t*,page_zip_des_t*,trx_id_t,mtr_t*)" -> "mlog_write_ull(unsigned char*,ib_uint64_t,mtr_t*)"
"page_set_max_trx_id(buf_block_t*,page_zip_des_t*,trx_id_t,mtr_t*)" -> "mach_write_to_8(void*,ib_uint64_t)"
"page_set_max_trx_id(buf_block_t*,page_zip_des_t*,trx_id_t,mtr_t*)" -> "page_zip_write_header(page_zip_des_t*,const unsigned char*,ulint,mtr_t*)"
"mlog_write_ull(unsigned char*,ib_uint64_t,mtr_t*)" -> "mlog_open(mtr_t*,ulint)"
"mlog_write_ull(unsigned char*,ib_uint64_t,mtr_t*)" -> "mach_write_to_2(unsigned char*,ulint)"
"mlog_write_ull(unsigned char*,ib_uint64_t,mtr_t*)" -> "mach_ull_write_compressed(unsigned char*,ib_uint64_t)"
"mlog_write_ull(unsigned char*,ib_uint64_t,mtr_t*)" -> "mlog_write_initial_log_record_fast(const unsigned char*,unsigned char,unsigned char*,mtr_t*)"
"mlog_write_ull(unsigned char*,ib_uint64_t,mtr_t*)" -> "page_offset(const void*)"
"mlog_write_ull(unsigned char*,ib_uint64_t,mtr_t*)" -> "mach_write_to_8(void*,ib_uint64_t)"
"mlog_write_ull(unsigned char*,ib_uint64_t,mtr_t*)" -> "mlog_close(mtr_t*,unsigned char*)"
"mach_ull_write_compressed(unsigned char*,ib_uint64_t)" -> "mach_write_compressed(unsigned char*,ulint)"
"mach_ull_write_compressed(unsigned char*,ib_uint64_t)" -> "mach_write_to_4(unsigned char*,ulint)"
"buf_frame_copy(unsigned char*,const buf_frame_t*)" -> "ut_memcpy(void*,const void*,ulint)"
"lock_move_reorganize_page(const buf_block_t*,const buf_block_t*)" -> "lock_rec_copy(const ib_lock_t*,mem_heap_t*)"
"lock_move_reorganize_page(const buf_block_t*,const buf_block_t*)" -> "lock_rec_get_nth_bit(const ib_lock_t*,ulint)"
"lock_move_reorganize_page(const buf_block_t*,const buf_block_t*)" -> "pfs_mutex_enter_func(ib_mutex_t*,const char*,ulint)"
"lock_move_reorganize_page(const buf_block_t*,const buf_block_t*)" -> "page_is_comp(const ib_page_t*)"
"lock_move_reorganize_page(const buf_block_t*,const buf_block_t*)" -> "mem_heap_create_func(ulint,ulint)"
"lock_move_reorganize_page(const buf_block_t*,const buf_block_t*)" -> "rec_get_heap_no_new(const rec_t*)"
"lock_move_reorganize_page(const buf_block_t*,const buf_block_t*)" -> "__builtin_expect(long int,long int)"
"lock_move_reorganize_page(const buf_block_t*,const buf_block_t*)" -> "lock_rec_get_first_on_page(const buf_block_t*)"
"lock_move_reorganize_page(const buf_block_t*,const buf_block_t*)" -> "pfs_mutex_exit_func(ib_mutex_t*)"
"lock_move_reorganize_page(const buf_block_t*,const buf_block_t*)" -> "lock_rec_add_to_queue(ulint,const buf_block_t*,ulint,dict_index_t*,trx_t*,ulint)"
"lock_move_reorganize_page(const buf_block_t*,const buf_block_t*)" -> "ut_list_append(List&,Type&,size_t) [with List = ut_list_base<ib_lock_t>,Type = ib_lock_t,size_t = long unsigned int]"
"lock_move_reorganize_page(const buf_block_t*,const buf_block_t*)" -> "page_cur_move_to_next(page_cur_t*)"
"lock_move_reorganize_page(const buf_block_t*,const buf_block_t*)" -> "rec_get_heap_no_old(const rec_t*)"
"lock_move_reorganize_page(const buf_block_t*,const buf_block_t*)" -> "lock_rec_bitmap_reset(ib_lock_t*)"
"lock_move_reorganize_page(const buf_block_t*,const buf_block_t*)" -> "lock_get_wait(const ib_lock_t*)"
"lock_move_reorganize_page(const buf_block_t*,const buf_block_t*)" -> "page_cur_set_before_first(const buf_block_t*,page_cur_t*)"
"lock_move_reorganize_page(const buf_block_t*,const buf_block_t*)" -> "lock_rec_get_next_on_page(ib_lock_t*)"
"lock_move_reorganize_page(const buf_block_t*,const buf_block_t*)" -> "lock_reset_lock_and_trx_wait(ib_lock_t*)"
"lock_move_reorganize_page(const buf_block_t*,const buf_block_t*)" -> "mem_heap_free_func(mem_heap_t*,const char*,ulint)"
"lock_rec_copy(const ib_lock_t*,mem_heap_t*)" -> "mem_heap_dup(mem_heap_t*,const void*,ulint)"
"lock_rec_copy(const ib_lock_t*,mem_heap_t*)" -> "lock_rec_get_n_bits(const ib_lock_t*)"
"mem_heap_dup(mem_heap_t*,const void*,ulint)" -> "memcpy(void*,const void*,size_t)"
"mem_heap_dup(mem_heap_t*,const void*,ulint)" -> "mem_heap_alloc(mem_heap_t*,ulint)"
"lock_rec_get_first_on_page(const buf_block_t*)" -> "buf_block_get_page_no(const buf_block_t*)"
"lock_rec_get_first_on_page(const buf_block_t*)" -> "buf_block_get_lock_hash_val(const buf_block_t*)"
"lock_rec_get_first_on_page(const buf_block_t*)" -> "hash_get_nth_cell(hash_table_t*,ulint)"
"lock_rec_get_first_on_page(const buf_block_t*)" -> "buf_block_get_space(const buf_block_t*)"
"lock_rec_add_to_queue(ulint,const buf_block_t*,ulint,dict_index_t*,trx_t*,ulint)" -> "lock_rec_set_nth_bit(ib_lock_t*,ulint)"
"lock_rec_add_to_queue(ulint,const buf_block_t*,ulint,dict_index_t*,trx_t*,ulint)" -> "lock_rec_find_similar_on_page(ulint,ulint,ib_lock_t*,const trx_t*)"
"lock_rec_add_to_queue(ulint,const buf_block_t*,ulint,dict_index_t*,trx_t*,ulint)" -> "lock_get_wait(const ib_lock_t*)"
"lock_rec_add_to_queue(ulint,const buf_block_t*,ulint,dict_index_t*,trx_t*,ulint)" -> "__builtin_expect(long int,long int)"
"lock_rec_add_to_queue(ulint,const buf_block_t*,ulint,dict_index_t*,trx_t*,ulint)" -> "lock_rec_get_next_on_page(ib_lock_t*)"
"lock_rec_add_to_queue(ulint,const buf_block_t*,ulint,dict_index_t*,trx_t*,ulint)" -> "lock_rec_get_nth_bit(const ib_lock_t*,ulint)"
"lock_rec_add_to_queue(ulint,const buf_block_t*,ulint,dict_index_t*,trx_t*,ulint)" -> "lock_rec_get_first_on_page(const buf_block_t*)"
"lock_rec_add_to_queue(ulint,const buf_block_t*,ulint,dict_index_t*,trx_t*,ulint)" -> "lock_rec_create(ulint,const buf_block_t*,ulint,dict_index_t*,trx_t*,ulint)"
"lock_rec_find_similar_on_page(ulint,ulint,ib_lock_t*,const trx_t*)" -> "lock_rec_get_next_on_page(ib_lock_t*)"
"lock_rec_find_similar_on_page(ulint,ulint,ib_lock_t*,const trx_t*)" -> "lock_rec_get_n_bits(const ib_lock_t*)"
"lock_rec_get_next_on_page(ib_lock_t*)" -> "lock_rec_get_next_on_page_const(const ib_lock_t*)"
"lock_rec_create(ulint,const buf_block_t*,ulint,dict_index_t*,trx_t*,ulint)" -> "__builtin_expect(long int,long int)"
"lock_rec_create(ulint,const buf_block_t*,ulint,dict_index_t*,trx_t*,ulint)" -> "abort()"
"lock_rec_create(ulint,const buf_block_t*,ulint,dict_index_t*,trx_t*,ulint)" -> "mem_heap_alloc(mem_heap_t*,ulint)"
"lock_rec_create(ulint,const buf_block_t*,ulint,dict_index_t*,trx_t*,ulint)" -> "pfs_mutex_exit_func(ib_mutex_t*)"
"lock_rec_create(ulint,const buf_block_t*,ulint,dict_index_t*,trx_t*,ulint)" -> "hash_get_nth_cell(hash_table_t*,ulint)"
"lock_rec_create(ulint,const buf_block_t*,ulint,dict_index_t*,trx_t*,ulint)" -> "ut_dbg_assertion_failed(const char*,const char*,ulint)"
"lock_rec_create(ulint,const buf_block_t*,ulint,dict_index_t*,trx_t*,ulint)" -> "lock_rec_bitmap_reset(ib_lock_t*)"
"lock_rec_create(ulint,const buf_block_t*,ulint,dict_index_t*,trx_t*,ulint)" -> "dict_table_is_comp(const dict_table_t*)"
"lock_rec_create(ulint,const buf_block_t*,ulint,dict_index_t*,trx_t*,ulint)" -> "lock_rec_set_nth_bit(ib_lock_t*,ulint)"
"lock_rec_create(ulint,const buf_block_t*,ulint,dict_index_t*,trx_t*,ulint)" -> "ut_list_append(List&,Type&,size_t) [with List = ut_list_base<ib_lock_t>,Type = ib_lock_t,size_t = long unsigned int]"
"lock_rec_create(ulint,const buf_block_t*,ulint,dict_index_t*,trx_t*,ulint)" -> "page_dir_get_n_heap(const ib_page_t*)"
"lock_rec_create(ulint,const buf_block_t*,ulint,dict_index_t*,trx_t*,ulint)" -> "buf_block_get_page_no(const buf_block_t*)"
"lock_rec_create(ulint,const buf_block_t*,ulint,dict_index_t*,trx_t*,ulint)" -> "pfs_mutex_enter_func(ib_mutex_t*,const char*,ulint)"
"lock_rec_create(ulint,const buf_block_t*,ulint,dict_index_t*,trx_t*,ulint)" -> "page_is_comp(const ib_page_t*)"
"lock_rec_create(ulint,const buf_block_t*,ulint,dict_index_t*,trx_t*,ulint)" -> "hash_calc_hash(ulint,hash_table_t*)"
"lock_rec_create(ulint,const buf_block_t*,ulint,dict_index_t*,trx_t*,ulint)" -> "lock_set_lock_and_trx_wait(ib_lock_t*,trx_t*)"
"lock_rec_create(ulint,const buf_block_t*,ulint,dict_index_t*,trx_t*,ulint)" -> "buf_block_get_space(const buf_block_t*)"
"lock_rec_create(ulint,const buf_block_t*,ulint,dict_index_t*,trx_t*,ulint)" -> "btr_corruption_report(const buf_block_t*,const dict_index_t*)"
"lock_rec_create(ulint,const buf_block_t*,ulint,dict_index_t*,trx_t*,ulint)" -> "lock_rec_fold(ulint,ulint)"
"lock_rec_bitmap_reset(ib_lock_t*)" -> "lock_rec_get_n_bits(const ib_lock_t*)"
"lock_rec_bitmap_reset(ib_lock_t*)" -> "memset(void*,int,size_t)"
"ut_list_append(List&,Type&,size_t) [with List = ut_list_base<ib_lock_t>,Type = ib_lock_t,size_t = long unsigned int]" -> "ut_elem_get_node(Type&,size_t) [with Type = ib_lock_t,size_t = long unsigned int]"
"ut_elem_get_node(Type&,size_t) [with Type = ib_lock_t,size_t = long unsigned int]" -> "ut_dbg_assertion_failed(const char*,const char*,ulint)"
"ut_elem_get_node(Type&,size_t) [with Type = ib_lock_t,size_t = long unsigned int]" -> "abort()"
"ut_elem_get_node(Type&,size_t) [with Type = ib_lock_t,size_t = long unsigned int]" -> "__builtin_expect(long int,long int)"
"lock_rec_fold(ulint,ulint)" -> "ut_fold_ulint_pair(ulint,ulint)"
"page_cur_set_before_first(const buf_block_t*,page_cur_t*)" -> "page_get_infimum_offset(const ib_page_t*)"
"btr_search_drop_page_hash_index(buf_block_t*)" -> "mem_heap_free_func(mem_heap_t*,const char*,ulint)"
"btr_search_drop_page_hash_index(buf_block_t*)" -> "rec_fold(const rec_t*,const ulint*,ulint,ulint,index_id_t)"
"btr_search_drop_page_hash_index(buf_block_t*)" -> "pfs_rw_lock_x_lock_func(rw_lock_t*,ulint,const char*,ulint)"
"btr_search_drop_page_hash_index(buf_block_t*)" -> "pfs_rw_lock_s_lock_func(rw_lock_t*,ulint,const char*,ulint)"
"btr_search_drop_page_hash_index(buf_block_t*)" -> "page_rec_is_supremum(const rec_t*)"
"btr_search_drop_page_hash_index(buf_block_t*)" -> "page_is_comp(const ib_page_t*)"
"btr_search_drop_page_hash_index(buf_block_t*)" -> "rec_get_offsets_func(const rec_t*,const dict_index_t*,ulint*,ulint,mem_heap_t**)"
"btr_search_drop_page_hash_index(buf_block_t*)" -> "btr_page_get_index_id(const ib_page_t*)"
"btr_search_drop_page_hash_index(buf_block_t*)" -> "ut_dbg_assertion_failed(const char*,const char*,ulint)"
"btr_search_drop_page_hash_index(buf_block_t*)" -> "page_rec_is_comp(const rec_t*)"
"btr_search_drop_page_hash_index(buf_block_t*)" -> "page_rec_get_next_low(const rec_t*,ulint)"
"btr_search_drop_page_hash_index(buf_block_t*)" -> "ha_remove_all_nodes_to_page(hash_table_t*,ulint,const ib_page_t*)"
"btr_search_drop_page_hash_index(buf_block_t*)" -> "page_get_n_recs(const ib_page_t*)"
"btr_search_drop_page_hash_index(buf_block_t*)" -> "pfs_rw_lock_s_unlock_func(rw_lock_t*)"
"btr_search_drop_page_hash_index(buf_block_t*)" -> "rec_offs_n_fields(const ulint*)"
"btr_search_drop_page_hash_index(buf_block_t*)" -> "__builtin_expect(long int,long int)"
"btr_search_drop_page_hash_index(buf_block_t*)" -> "page_get_infimum_offset(const ib_page_t*)"
"btr_search_drop_page_hash_index(buf_block_t*)" -> "abort()"
"btr_search_drop_page_hash_index(buf_block_t*)" -> "dict_index_is_ibuf(const dict_index_t*)"
"btr_search_drop_page_hash_index(buf_block_t*)" -> "pfs_rw_lock_x_unlock_func(rw_lock_t*)"
"btr_search_drop_page_hash_index(buf_block_t*)" -> "btr_search_get_info(dict_index_t*)"
"btr_search_drop_page_hash_index(buf_block_t*)" -> "mem_free_func(void*,const char*,ulint)"
"btr_search_drop_page_hash_index(buf_block_t*)" -> "mem_alloc_func(ulint,ulint*)"
"rec_fold(const rec_t*,const ulint*,ulint,ulint,index_id_t)" -> "ut_fold_binary(const unsigned char*,ulint)"
"rec_fold(const rec_t*,const ulint*,ulint,ulint,index_id_t)" -> "rec_offs_n_fields(const ulint*)"
"rec_fold(const rec_t*,const ulint*,ulint,ulint,index_id_t)" -> "rec_get_nth_field_offs(const ulint*,ulint,ulint*)"
"rec_fold(const rec_t*,const ulint*,ulint,ulint,index_id_t)" -> "ut_fold_ulint_pair(ulint,ulint)"
"rec_fold(const rec_t*,const ulint*,ulint,ulint,index_id_t)" -> "ut_fold_ull(ib_uint64_t)"
"ut_fold_ull(ib_uint64_t)" -> "ut_fold_ulint_pair(ulint,ulint)"
"pfs_rw_lock_s_lock_func(rw_lock_t*,ulint,const char*,ulint)" -> "rw_lock_s_lock_func(rw_lock_t*,ulint,const char*,ulint)"
"rw_lock_s_lock_func(rw_lock_t*,ulint,const char*,ulint)" -> "rw_lock_s_lock_spin(rw_lock_t*,ulint,const char*,ulint)"
"rw_lock_s_lock_func(rw_lock_t*,ulint,const char*,ulint)" -> "rw_lock_s_lock_low(rw_lock_t*,ulint,const char*,ulint)"
"rw_lock_s_lock_spin(rw_lock_t*,ulint,const char*,ulint)" -> "ut_rnd_interval(ulint,ulint)"
"rw_lock_s_lock_spin(rw_lock_t*,ulint,const char*,ulint)" -> "os_thread_yield()"
"rw_lock_s_lock_spin(rw_lock_t*,ulint,const char*,ulint)" -> "os_thread_get_curr_id()"
"rw_lock_s_lock_spin(rw_lock_t*,ulint,const char*,ulint)" -> "Indexer>::add(size_t,Type) [with Type = long int,int N = 64,Indexer = thread_id_indexer_t,size_t = long unsigned int]"
"rw_lock_s_lock_spin(rw_lock_t*,ulint,const char*,ulint)" -> "rw_lock_s_lock_low(rw_lock_t*,ulint,const char*,ulint)"
"rw_lock_s_lock_spin(rw_lock_t*,ulint,const char*,ulint)" -> "sync_array_get_and_reserve_cell(void*,ulint,const char*,ulint,ulint*)"
"rw_lock_s_lock_spin(rw_lock_t*,ulint,const char*,ulint)" -> "sync_array_free_cell(sync_array_t*,ulint)"
"rw_lock_s_lock_spin(rw_lock_t*,ulint,const char*,ulint)" -> "sync_array_wait_event(sync_array_t*,ulint)"
"rw_lock_s_lock_spin(rw_lock_t*,ulint,const char*,ulint)" -> "rw_lock_set_waiter_flag(rw_lock_t*)"
"rw_lock_s_lock_spin(rw_lock_t*,ulint,const char*,ulint)" -> "ut_delay(ulint)"
"ha_remove_all_nodes_to_page(hash_table_t*,ulint,const ib_page_t*)" -> "page_align(const void*)"
"ha_remove_all_nodes_to_page(hash_table_t*,ulint,const ib_page_t*)" -> "ha_delete_hash_node(hash_table_t*,ha_node_t*)"
"ha_remove_all_nodes_to_page(hash_table_t*,ulint,const ib_page_t*)" -> "ha_node_get_data(const ha_node_t*)"
"ha_remove_all_nodes_to_page(hash_table_t*,ulint,const ib_page_t*)" -> "ha_chain_get_next(ha_node_t*)"
"ha_remove_all_nodes_to_page(hash_table_t*,ulint,const ib_page_t*)" -> "ha_chain_get_first(hash_table_t*,ulint)"
"ha_delete_hash_node(hash_table_t*,ha_node_t*)" -> "abort()"
"ha_delete_hash_node(hash_table_t*,ha_node_t*)" -> "mem_heap_free_top(mem_heap_t*,ulint)"
"ha_delete_hash_node(hash_table_t*,ha_node_t*)" -> "hash_get_nth_cell(hash_table_t*,ulint)"
"ha_delete_hash_node(hash_table_t*,ha_node_t*)" -> "hash_get_heap(hash_table_t*,ulint)"
"ha_delete_hash_node(hash_table_t*,ha_node_t*)" -> "hash_calc_hash(ulint,hash_table_t*)"
"ha_delete_hash_node(hash_table_t*,ha_node_t*)" -> "__builtin_expect(long int,long int)"
"ha_delete_hash_node(hash_table_t*,ha_node_t*)" -> "ut_dbg_assertion_failed(const char*,const char*,ulint)"
"ha_delete_hash_node(hash_table_t*,ha_node_t*)" -> "mem_heap_get_top(mem_heap_t*,ulint)"
"mem_heap_free_top(mem_heap_t*,ulint)" -> "mem_heap_block_free(mem_heap_t*,mem_block_t*)"
"mem_heap_free_top(mem_heap_t*,ulint)" -> "mem_block_get_start(mem_block_t*)"
"mem_heap_free_top(mem_heap_t*,ulint)" -> "mem_block_set_free(mem_block_t*,ulint)"
"mem_heap_free_top(mem_heap_t*,ulint)" -> "mem_block_get_free(mem_block_t*)"
"hash_get_heap(hash_table_t*,ulint)" -> "hash_get_nth_heap(hash_table_t*,ulint)"
"hash_get_heap(hash_table_t*,ulint)" -> "hash_get_sync_obj_index(hash_table_t*,ulint)"
"mem_heap_get_top(mem_heap_t*,ulint)" -> "mem_block_get_free(mem_block_t*)"
"ha_chain_get_first(hash_table_t*,ulint)" -> "hash_calc_hash(ulint,hash_table_t*)"
"ha_chain_get_first(hash_table_t*,ulint)" -> "hash_get_nth_cell(hash_table_t*,ulint)"
"page_zip_write_rec(page_zip_des_t*,const unsigned char*,dict_index_t*,const ulint*,ulint)" -> "rec_get_heap_no_new(const rec_t*)"
"page_zip_write_rec(page_zip_des_t*,const unsigned char*,dict_index_t*,const ulint*,ulint)" -> "dict_index_is_clust(const dict_index_t*)"
"page_zip_write_rec(page_zip_des_t*,const unsigned char*,dict_index_t*,const ulint*,ulint)" -> "page_is_leaf(const ib_page_t*)"
"page_zip_write_rec(page_zip_des_t*,const unsigned char*,dict_index_t*,const ulint*,ulint)" -> "abort()"
"page_zip_write_rec(page_zip_des_t*,const unsigned char*,dict_index_t*,const ulint*,ulint)" -> "rec_get_nth_field_offs(const ulint*,ulint,ulint*)"
"page_zip_write_rec(page_zip_des_t*,const unsigned char*,dict_index_t*,const ulint*,ulint)" -> "page_zip_write_rec_ext(page_zip_des_t*,const ib_page_t*,const unsigned char*,dict_index_t*,const ulint*,ulint,ulint,ulint,unsigned char*,unsigned char*)"
"page_zip_write_rec(page_zip_des_t*,const unsigned char*,dict_index_t*,const ulint*,ulint)" -> "rec_offs_any_extern(const ulint*)"
"page_zip_write_rec(page_zip_des_t*,const unsigned char*,dict_index_t*,const ulint*,ulint)" -> "rec_offs_extra_size(const ulint*)"
"page_zip_write_rec(page_zip_des_t*,const unsigned char*,dict_index_t*,const ulint*,ulint)" -> "page_offset(const void*)"
"page_zip_write_rec(page_zip_des_t*,const unsigned char*,dict_index_t*,const ulint*,ulint)" -> "ut_dbg_assertion_failed(const char*,const char*,ulint)"
"page_zip_write_rec(page_zip_des_t*,const unsigned char*,dict_index_t*,const ulint*,ulint)" -> "__builtin_expect(long int,long int)"
"page_zip_write_rec(page_zip_des_t*,const unsigned char*,dict_index_t*,const ulint*,ulint)" -> "page_zip_dir_find(page_zip_des_t*,ulint)"
"page_zip_write_rec(page_zip_des_t*,const unsigned char*,dict_index_t*,const ulint*,ulint)" -> "page_zip_dir_start_offs(const page_zip_des_t*,ulint)"
"page_zip_write_rec(page_zip_des_t*,const unsigned char*,dict_index_t*,const ulint*,ulint)" -> "memcpy(void*,const void*,size_t)"
"page_zip_write_rec(page_zip_des_t*,const unsigned char*,dict_index_t*,const ulint*,ulint)" -> "rec_get_deleted_flag(const rec_t*,ulint)"
"page_zip_write_rec(page_zip_des_t*,const unsigned char*,dict_index_t*,const ulint*,ulint)" -> "rec_offs_data_size(const ulint*)"
"page_zip_write_rec(page_zip_des_t*,const unsigned char*,dict_index_t*,const ulint*,ulint)" -> "page_align(const void*)"
"page_zip_write_rec(page_zip_des_t*,const unsigned char*,dict_index_t*,const ulint*,ulint)" -> "dict_index_get_sys_col_pos(const dict_index_t*,ulint)"
"page_zip_write_rec(page_zip_des_t*,const unsigned char*,dict_index_t*,const ulint*,ulint)" -> "page_zip_dir_elems(const page_zip_des_t*)"
"page_zip_write_rec_ext(page_zip_des_t*,const ib_page_t*,const unsigned char*,dict_index_t*,const ulint*,ulint,ulint,ulint,unsigned char*,unsigned char*)" -> "rec_offs_nth_extern(const ulint*,ulint)"
"page_zip_write_rec_ext(page_zip_des_t*,const ib_page_t*,const unsigned char*,dict_index_t*,const ulint*,ulint,ulint,ulint,unsigned char*,unsigned char*)" -> "memmove(void*,const void*,size_t)"
"page_zip_write_rec_ext(page_zip_des_t*,const ib_page_t*,const unsigned char*,dict_index_t*,const ulint*,ulint,ulint,ulint,unsigned char*,unsigned char*)" -> "rec_offs_data_size(const ulint*)"
"page_zip_write_rec_ext(page_zip_des_t*,const ib_page_t*,const unsigned char*,dict_index_t*,const ulint*,ulint,ulint,ulint,unsigned char*,unsigned char*)" -> "abort()"
"page_zip_write_rec_ext(page_zip_des_t*,const ib_page_t*,const unsigned char*,dict_index_t*,const ulint*,ulint,ulint,ulint,unsigned char*,unsigned char*)" -> "memcpy(void*,const void*,size_t)"
"page_zip_write_rec_ext(page_zip_des_t*,const ib_page_t*,const unsigned char*,dict_index_t*,const ulint*,ulint,ulint,ulint,unsigned char*,unsigned char*)" -> "rec_offs_n_extern(const ulint*)"
"page_zip_write_rec_ext(page_zip_des_t*,const ib_page_t*,const unsigned char*,dict_index_t*,const ulint*,ulint,ulint,ulint,unsigned char*,unsigned char*)" -> "ut_dbg_assertion_failed(const char*,const char*,ulint)"
"page_zip_write_rec_ext(page_zip_des_t*,const ib_page_t*,const unsigned char*,dict_index_t*,const ulint*,ulint,ulint,ulint,unsigned char*,unsigned char*)" -> "page_zip_get_n_prev_extern(const page_zip_des_t*,const rec_t*,const dict_index_t*)"
"page_zip_write_rec_ext(page_zip_des_t*,const ib_page_t*,const unsigned char*,dict_index_t*,const ulint*,ulint,ulint,ulint,unsigned char*,unsigned char*)" -> "rec_offs_n_fields(const ulint*)"
"page_zip_write_rec_ext(page_zip_des_t*,const ib_page_t*,const unsigned char*,dict_index_t*,const ulint*,ulint,ulint,ulint,unsigned char*,unsigned char*)" -> "rec_get_nth_field_offs(const ulint*,ulint,ulint*)"
"page_zip_write_rec_ext(page_zip_des_t*,const ib_page_t*,const unsigned char*,dict_index_t*,const ulint*,ulint,ulint,ulint,unsigned char*,unsigned char*)" -> "page_dir_get_n_heap(const ib_page_t*)"
"page_zip_write_rec_ext(page_zip_des_t*,const ib_page_t*,const unsigned char*,dict_index_t*,const ulint*,ulint,ulint,ulint,unsigned char*,unsigned char*)" -> "__builtin_expect(long int,long int)"
"rec_offs_n_extern(const ulint*)" -> "rec_offs_any_extern(const ulint*)"
"rec_offs_n_extern(const ulint*)" -> "rec_offs_nth_extern(const ulint*,ulint)"
"rec_offs_n_extern(const ulint*)" -> "rec_offs_n_fields(const ulint*)"
"page_zip_get_n_prev_extern(const page_zip_des_t*,const rec_t*,const dict_index_t*)" -> "rec_get_heap_no_new(const rec_t*)"
"page_zip_get_n_prev_extern(const page_zip_des_t*,const rec_t*,const dict_index_t*)" -> "page_zip_dir_get(const page_zip_des_t*,ulint)"
"page_zip_get_n_prev_extern(const page_zip_des_t*,const rec_t*,const dict_index_t*)" -> "page_align(const void*)"
"page_zip_get_n_prev_extern(const page_zip_des_t*,const rec_t*,const dict_index_t*)" -> "page_get_n_recs(const ib_page_t*)"
"page_zip_get_n_prev_extern(const page_zip_des_t*,const rec_t*,const dict_index_t*)" -> "rec_get_n_extern_new(const rec_t*,const dict_index_t*,ulint)"
"page_zip_get_n_prev_extern(const page_zip_des_t*,const rec_t*,const dict_index_t*)" -> "__builtin_expect(long int,long int)"
"page_zip_dir_get(const page_zip_des_t*,ulint)" -> "mach_read_from_2(const unsigned char*)"
"page_zip_dir_get(const page_zip_des_t*,ulint)" -> "page_zip_get_size(const page_zip_des_t*)"
"rec_get_n_extern_new(const rec_t*,const dict_index_t*,ulint)" -> "dict_field_get_col(const dict_field_t*)"
"rec_get_n_extern_new(const rec_t*,const dict_index_t*,ulint)" -> "dict_index_get_n_fields(const dict_index_t*)"
"rec_get_n_extern_new(const rec_t*,const dict_index_t*,ulint)" -> "__builtin_expect(long int,long int)"
"page_zip_dir_start_offs(const page_zip_des_t*,ulint)" -> "page_zip_get_size(const page_zip_des_t*)"
"page_zip_dir_elems(const page_zip_des_t*)" -> "page_dir_get_n_heap(const ib_page_t*)"
"page_zip_dir_insert(page_zip_des_t*,const unsigned char*,const unsigned char*,unsigned char*)" -> "page_zip_dir_find(page_zip_des_t*,ulint)"
"page_zip_dir_insert(page_zip_des_t*,const unsigned char*,const unsigned char*,unsigned char*)" -> "page_dir_get_n_heap(const ib_page_t*)"
"page_zip_dir_insert(page_zip_des_t*,const unsigned char*,const unsigned char*,unsigned char*)" -> "mach_write_to_2(unsigned char*,ulint)"
"page_zip_dir_insert(page_zip_des_t*,const unsigned char*,const unsigned char*,unsigned char*)" -> "abort()"
"page_zip_dir_insert(page_zip_des_t*,const unsigned char*,const unsigned char*,unsigned char*)" -> "page_zip_get_size(const page_zip_des_t*)"
"page_zip_dir_insert(page_zip_des_t*,const unsigned char*,const unsigned char*,unsigned char*)" -> "memmove(void*,const void*,size_t)"
"page_zip_dir_insert(page_zip_des_t*,const unsigned char*,const unsigned char*,unsigned char*)" -> "__builtin_expect(long int,long int)"
"page_zip_dir_insert(page_zip_des_t*,const unsigned char*,const unsigned char*,unsigned char*)" -> "page_offset(const void*)"
"page_zip_dir_insert(page_zip_des_t*,const unsigned char*,const unsigned char*,unsigned char*)" -> "page_zip_dir_user_size(const page_zip_des_t*)"
"page_zip_dir_insert(page_zip_des_t*,const unsigned char*,const unsigned char*,unsigned char*)" -> "page_zip_dir_find_low(unsigned char*,unsigned char*,ulint)"
"page_zip_dir_insert(page_zip_des_t*,const unsigned char*,const unsigned char*,unsigned char*)" -> "page_rec_is_infimum(const rec_t*)"
"page_zip_dir_insert(page_zip_des_t*,const unsigned char*,const unsigned char*,unsigned char*)" -> "ut_dbg_assertion_failed(const char*,const char*,ulint)"
"page_zip_compress_write_log_no_data(ulint,const ib_page_t*,dict_index_t*,mtr_t*)" -> "mlog_open_and_write_index(mtr_t*,const unsigned char*,const dict_index_t*,unsigned char,ulint)"
"page_zip_compress_write_log_no_data(ulint,const ib_page_t*,dict_index_t*,mtr_t*)" -> "mach_write_to_1(unsigned char*,ulint)"
"page_zip_compress_write_log_no_data(ulint,const ib_page_t*,dict_index_t*,mtr_t*)" -> "mlog_close(mtr_t*,unsigned char*)"
"page_zip_decompress(page_zip_des_t*,ib_page_t*,ulint)" -> "page_zip_dir_decode(const page_zip_des_t*,ib_page_t*,rec_t**,rec_t**,ulint)"
"page_zip_decompress(page_zip_des_t*,ib_page_t*,ulint)" -> "page_is_empty(const ib_page_t*)"
"page_zip_decompress(page_zip_des_t*,ib_page_t*,ulint)" -> "memcpy(void*,const void*,size_t)"
"page_zip_decompress(page_zip_des_t*,ib_page_t*,ulint)" -> "page_zip_decompress_clust(page_zip_des_t*,z_stream*,rec_t**,ulint,dict_index_t*,ulint,ulint*,mem_heap_t*)"
"page_zip_decompress(page_zip_des_t*,ib_page_t*,ulint)" -> "page_is_comp(const ib_page_t*)"
"page_zip_decompress(page_zip_des_t*,ib_page_t*,ulint)" -> "__builtin_expect(long int,long int)"
"page_zip_decompress(page_zip_des_t*,ib_page_t*,ulint)" -> "dict_index_get_n_fields(const dict_index_t*)"
"page_zip_decompress(page_zip_des_t*,ib_page_t*,ulint)" -> "page_zip_decompress_sec(page_zip_des_t*,z_stream*,rec_t**,ulint,dict_index_t*,ulint*)"
"page_zip_decompress(page_zip_des_t*,ib_page_t*,ulint)" -> "page_zip_decompress_node_ptrs(page_zip_des_t*,z_stream*,rec_t**,ulint,dict_index_t*,ulint*,mem_heap_t*)"
"page_zip_decompress(page_zip_des_t*,ib_page_t*,ulint)" -> "ut_dbg_assertion_failed(const char*,const char*,ulint)"
"page_zip_decompress(page_zip_des_t*,ib_page_t*,ulint)" -> "_Alloc>::operator[](const key_type&) [with _Key = long unsigned int,_Tp = page_zip_stat_t,_Compare = std::less<long unsigned int>,_Alloc = std::allocator<std::pair<const long unsigned int,page_zip_stat_t> >,std::map<_Key,_Tp,_Compare,_Alloc>::mapped_type = page_zip_stat_t,std::map<_Key,_Tp,_Compare,_Alloc>::key_type = long unsigned int]"
"page_zip_decompress(page_zip_des_t*,ib_page_t*,ulint)" -> "page_is_leaf(const ib_page_t*)"
"page_zip_decompress(page_zip_des_t*,ib_page_t*,ulint)" -> "mem_heap_create_func(ulint,ulint)"
"page_zip_decompress(page_zip_des_t*,ib_page_t*,ulint)" -> "inflate(z_streamp,int)"
"page_zip_decompress(page_zip_des_t*,ib_page_t*,ulint)" -> "page_zip_set_extra_bytes(const page_zip_des_t*,ib_page_t*,ulint)"
"page_zip_decompress(page_zip_des_t*,ib_page_t*,ulint)" -> "mem_heap_alloc(mem_heap_t*,ulint)"
"page_zip_decompress(page_zip_des_t*,ib_page_t*,ulint)" -> "page_zip_set_alloc(void*,mem_heap_t*)"
"page_zip_decompress(page_zip_des_t*,ib_page_t*,ulint)" -> "page_zip_get_size(const page_zip_des_t*)"
"page_zip_decompress(page_zip_des_t*,ib_page_t*,ulint)" -> "mach_read_from_4(const unsigned char*)"
"page_zip_decompress(page_zip_des_t*,ib_page_t*,ulint)" -> "abort()"
"page_zip_decompress(page_zip_des_t*,ib_page_t*,ulint)" -> "btr_page_get_index_id(const ib_page_t*)"
"page_zip_decompress(page_zip_des_t*,ib_page_t*,ulint)" -> "page_zip_fields_free(dict_index_t*)"
"page_zip_decompress(page_zip_des_t*,ib_page_t*,ulint)" -> "ut_time_us(ullint*)"
"page_zip_decompress(page_zip_des_t*,ib_page_t*,ulint)" -> "pfs_mutex_enter_func(ib_mutex_t*,const char*,ulint)"
"page_zip_decompress(page_zip_des_t*,ib_page_t*,ulint)" -> "page_zip_fields_decode(const unsigned char*,const unsigned char*,ulint*)"
"page_zip_decompress(page_zip_des_t*,ib_page_t*,ulint)" -> "mem_heap_free_func(mem_heap_t*,const char*,ulint)"
"page_zip_decompress(page_zip_des_t*,ib_page_t*,ulint)" -> "page_dir_get_n_heap(const ib_page_t*)"
"page_zip_decompress(page_zip_des_t*,ib_page_t*,ulint)" -> "rec_set_next_offs_new(rec_t*,ulint)"
"page_zip_decompress(page_zip_des_t*,ib_page_t*,ulint)" -> "pfs_mutex_exit_func(ib_mutex_t*)"
"page_zip_decompress(page_zip_des_t*,ib_page_t*,ulint)" -> "inflateInit2_(z_streamp,int,const char*,int)"
"page_zip_decompress(page_zip_des_t*,ib_page_t*,ulint)" -> "page_zip_dir_get(const page_zip_des_t*,ulint)"
"page_zip_dir_decode(const page_zip_des_t*,ib_page_t*,rec_t**,rec_t**,ulint)" -> "mach_write_to_2(unsigned char*,ulint)"
"page_zip_dir_decode(const page_zip_des_t*,ib_page_t*,rec_t**,rec_t**,ulint)" -> "__builtin_expect(long int,long int)"
"page_zip_dir_decode(const page_zip_des_t*,ib_page_t*,rec_t**,rec_t**,ulint)" -> "__builtin_prefetch(const void*,...)"
"page_zip_dir_decode(const page_zip_des_t*,ib_page_t*,rec_t**,rec_t**,ulint)" -> "memset(void*,int,size_t)"
"page_zip_dir_decode(const page_zip_des_t*,ib_page_t*,rec_t**,rec_t**,ulint)" -> "page_get_n_recs(const ib_page_t*)"
"page_zip_dir_decode(const page_zip_des_t*,ib_page_t*,rec_t**,rec_t**,ulint)" -> "page_zip_dir_sort(rec_t**,rec_t**,ulint,ulint)"
"page_zip_dir_decode(const page_zip_des_t*,ib_page_t*,rec_t**,rec_t**,ulint)" -> "page_dir_get_n_slots(const ib_page_t*)"
"page_zip_dir_decode(const page_zip_des_t*,ib_page_t*,rec_t**,rec_t**,ulint)" -> "page_zip_dir_get(const page_zip_des_t*,ulint)"
"page_zip_dir_sort(rec_t**,rec_t**,ulint,ulint)" -> "memcpy(void*,const void*,size_t)"
"page_zip_dir_sort(rec_t**,rec_t**,ulint,ulint)" -> "page_zip_dir_sort(rec_t**,rec_t**,ulint,ulint)"
"page_zip_dir_sort(rec_t**,rec_t**,ulint,ulint)" -> "page_zip_dir_cmp(const rec_t*,const rec_t*)"
"page_zip_decompress_clust(page_zip_des_t*,z_stream*,rec_t**,ulint,dict_index_t*,ulint,ulint*,mem_heap_t*)" -> "rec_get_offsets_func(const rec_t*,const dict_index_t*,ulint*,ulint,mem_heap_t**)"
"page_zip_decompress_clust(page_zip_des_t*,z_stream*,rec_t**,ulint,dict_index_t*,ulint,ulint*,mem_heap_t*)" -> "rec_offs_nth_extern(const ulint*,ulint)"
"page_zip_decompress_clust(page_zip_des_t*,z_stream*,rec_t**,ulint,dict_index_t*,ulint,ulint*,mem_heap_t*)" -> "memcpy(void*,const void*,size_t)"
"page_zip_decompress_clust(page_zip_des_t*,z_stream*,rec_t**,ulint,dict_index_t*,ulint,ulint*,mem_heap_t*)" -> "page_zip_get_size(const page_zip_des_t*)"
"page_zip_decompress_clust(page_zip_des_t*,z_stream*,rec_t**,ulint,dict_index_t*,ulint,ulint*,mem_heap_t*)" -> "abort()"
"page_zip_decompress_clust(page_zip_des_t*,z_stream*,rec_t**,ulint,dict_index_t*,ulint,ulint*,mem_heap_t*)" -> "page_align(const void*)"
"page_zip_decompress_clust(page_zip_des_t*,z_stream*,rec_t**,ulint,dict_index_t*,ulint,ulint*,mem_heap_t*)" -> "page_zip_decompress_heap_no(z_stream*,rec_t*,ulint&)"
"page_zip_decompress_clust(page_zip_des_t*,z_stream*,rec_t**,ulint,dict_index_t*,ulint,ulint*,mem_heap_t*)" -> "page_zip_apply_log(const unsigned char*,ulint,rec_t**,ulint,ulint,ulint,dict_index_t*,ulint*)"
"page_zip_decompress_clust(page_zip_des_t*,z_stream*,rec_t**,ulint,dict_index_t*,ulint,ulint*,mem_heap_t*)" -> "page_zip_get_trailer_len(const page_zip_des_t*,ulint)"
"page_zip_decompress_clust(page_zip_des_t*,z_stream*,rec_t**,ulint,dict_index_t*,ulint,ulint*,mem_heap_t*)" -> "page_header_get_field(const ib_page_t*,ulint)"
"page_zip_decompress_clust(page_zip_des_t*,z_stream*,rec_t**,ulint,dict_index_t*,ulint,ulint*,mem_heap_t*)" -> "inflateEnd(z_streamp)"
"page_zip_decompress_clust(page_zip_des_t*,z_stream*,rec_t**,ulint,dict_index_t*,ulint,ulint*,mem_heap_t*)" -> "page_zip_decompress_clust_ext(z_stream*,rec_t*,const ulint*,ulint)"
"page_zip_decompress_clust(page_zip_des_t*,z_stream*,rec_t**,ulint,dict_index_t*,ulint,ulint*,mem_heap_t*)" -> "rec_get_nth_field_offs(const ulint*,ulint,ulint*)"
"page_zip_decompress_clust(page_zip_des_t*,z_stream*,rec_t**,ulint,dict_index_t*,ulint,ulint*,mem_heap_t*)" -> "rec_offs_n_fields(const ulint*)"
"page_zip_decompress_clust(page_zip_des_t*,z_stream*,rec_t**,ulint,dict_index_t*,ulint,ulint*,mem_heap_t*)" -> "page_zip_dir_find_free(page_zip_des_t*,ulint)"
"page_zip_decompress_clust(page_zip_des_t*,z_stream*,rec_t**,ulint,dict_index_t*,ulint,ulint*,mem_heap_t*)" -> "rec_offs_any_extern(const ulint*)"
"page_zip_decompress_clust(page_zip_des_t*,z_stream*,rec_t**,ulint,dict_index_t*,ulint,ulint*,mem_heap_t*)" -> "page_zip_dir_start_offs(const page_zip_des_t*,ulint)"
"page_zip_decompress_clust(page_zip_des_t*,z_stream*,rec_t**,ulint,dict_index_t*,ulint,ulint*,mem_heap_t*)" -> "dict_index_is_clust(const dict_index_t*)"
"page_zip_decompress_clust(page_zip_des_t*,z_stream*,rec_t**,ulint,dict_index_t*,ulint,ulint*,mem_heap_t*)" -> "rec_offs_data_size(const ulint*)"
"page_zip_decompress_clust(page_zip_des_t*,z_stream*,rec_t**,ulint,dict_index_t*,ulint,ulint*,mem_heap_t*)" -> "__builtin_expect(long int,long int)"
"page_zip_decompress_clust(page_zip_des_t*,z_stream*,rec_t**,ulint,dict_index_t*,ulint,ulint*,mem_heap_t*)" -> "memset(void*,int,size_t)"
"page_zip_decompress_clust(page_zip_des_t*,z_stream*,rec_t**,ulint,dict_index_t*,ulint,ulint*,mem_heap_t*)" -> "ut_dbg_assertion_failed(const char*,const char*,ulint)"
"page_zip_decompress_clust(page_zip_des_t*,z_stream*,rec_t**,ulint,dict_index_t*,ulint,ulint*,mem_heap_t*)" -> "page_offset(const void*)"
"page_zip_decompress_clust(page_zip_des_t*,z_stream*,rec_t**,ulint,dict_index_t*,ulint,ulint*,mem_heap_t*)" -> "inflate(z_streamp,int)"
"page_zip_decompress_clust(page_zip_des_t*,z_stream*,rec_t**,ulint,dict_index_t*,ulint,ulint*,mem_heap_t*)" -> "page_dir_get_n_slots(const ib_page_t*)"
"page_zip_decompress_heap_no(z_stream*,rec_t*,ulint&)" -> "mach_write_to_2(unsigned char*,ulint)"
"page_zip_apply_log(const unsigned char*,ulint,rec_t**,ulint,ulint,ulint,dict_index_t*,ulint*)" -> "__builtin_expect(long int,long int)"
"page_zip_apply_log(const unsigned char*,ulint,rec_t**,ulint,ulint,ulint,dict_index_t*,ulint*)" -> "rec_offs_any_extern(const ulint*)"
"page_zip_apply_log(const unsigned char*,ulint,rec_t**,ulint,ulint,ulint,dict_index_t*,ulint*)" -> "page_zip_apply_log_ext(rec_t*,const ulint*,ulint,const unsigned char*,const unsigned char*)"
"page_zip_apply_log(const unsigned char*,ulint,rec_t**,ulint,ulint,ulint,dict_index_t*,ulint*)" -> "rec_get_offsets_func(const rec_t*,const dict_index_t*,ulint*,ulint,mem_heap_t**)"
"page_zip_apply_log(const unsigned char*,ulint,rec_t**,ulint,ulint,ulint,dict_index_t*,ulint*)" -> "rec_get_nth_field_offs(const ulint*,ulint,ulint*)"
"page_zip_apply_log(const unsigned char*,ulint,rec_t**,ulint,ulint,ulint,dict_index_t*,ulint*)" -> "rec_get_offsets_reverse(const unsigned char*,const dict_index_t*,ulint,ulint*)"
"page_zip_apply_log(const unsigned char*,ulint,rec_t**,ulint,ulint,ulint,dict_index_t*,ulint*)" -> "mach_write_to_2(unsigned char*,ulint)"
"page_zip_apply_log(const unsigned char*,ulint,rec_t**,ulint,ulint,ulint,dict_index_t*,ulint*)" -> "mem_heap_free_func(mem_heap_t*,const char*,ulint)"
"page_zip_apply_log(const unsigned char*,ulint,rec_t**,ulint,ulint,ulint,dict_index_t*,ulint*)" -> "rec_offs_data_size(const ulint*)"
"page_zip_apply_log(const unsigned char*,ulint,rec_t**,ulint,ulint,ulint,dict_index_t*,ulint*)" -> "memcpy(void*,const void*,size_t)"
"page_zip_apply_log(const unsigned char*,ulint,rec_t**,ulint,ulint,ulint,dict_index_t*,ulint*)" -> "memset(void*,int,size_t)"
"page_zip_apply_log(const unsigned char*,ulint,rec_t**,ulint,ulint,ulint,dict_index_t*,ulint*)" -> "rec_offs_extra_size(const ulint*)"
"page_zip_apply_log_ext(rec_t*,const ulint*,ulint,const unsigned char*,const unsigned char*)" -> "rec_get_nth_field_offs(const ulint*,ulint,ulint*)"
"page_zip_apply_log_ext(rec_t*,const ulint*,ulint,const unsigned char*,const unsigned char*)" -> "memcpy(void*,const void*,size_t)"
"page_zip_apply_log_ext(rec_t*,const ulint*,ulint,const unsigned char*,const unsigned char*)" -> "rec_offs_nth_extern(const ulint*,ulint)"
"page_zip_apply_log_ext(rec_t*,const ulint*,ulint,const unsigned char*,const unsigned char*)" -> "rec_offs_data_size(const ulint*)"
"page_zip_apply_log_ext(rec_t*,const ulint*,ulint,const unsigned char*,const unsigned char*)" -> "rec_offs_n_fields(const ulint*)"
"page_zip_apply_log_ext(rec_t*,const ulint*,ulint,const unsigned char*,const unsigned char*)" -> "__builtin_expect(long int,long int)"
"rec_get_offsets_reverse(const unsigned char*,const dict_index_t*,ulint,ulint*)" -> "dict_field_get_col(const dict_field_t*)"
"rec_get_offsets_reverse(const unsigned char*,const dict_index_t*,ulint,ulint*)" -> "dict_index_get_n_unique_in_tree(const dict_index_t*)"
"rec_get_offsets_reverse(const unsigned char*,const dict_index_t*,ulint,ulint*)" -> "__builtin_expect(long int,long int)"
"rec_get_offsets_reverse(const unsigned char*,const dict_index_t*,ulint,ulint*)" -> "dict_index_get_n_fields(const dict_index_t*)"
"rec_get_offsets_reverse(const unsigned char*,const dict_index_t*,ulint,ulint*)" -> "abort()"
"rec_get_offsets_reverse(const unsigned char*,const dict_index_t*,ulint,ulint*)" -> "rec_offs_n_fields(const ulint*)"
"rec_get_offsets_reverse(const unsigned char*,const dict_index_t*,ulint,ulint*)" -> "ut_dbg_assertion_failed(const char*,const char*,ulint)"
"rec_get_offsets_reverse(const unsigned char*,const dict_index_t*,ulint,ulint*)" -> "rec_offs_set_n_fields(ulint*,ulint)"
"rec_get_offsets_reverse(const unsigned char*,const dict_index_t*,ulint,ulint*)" -> "rec_offs_get_n_alloc(const ulint*)"
"page_zip_get_trailer_len(const page_zip_des_t*,ulint)" -> "page_dir_get_n_heap(const ib_page_t*)"
"page_zip_get_trailer_len(const page_zip_des_t*,ulint)" -> "page_is_leaf(const ib_page_t*)"
"page_zip_decompress_clust_ext(z_stream*,rec_t*,const ulint*,ulint)" -> "rec_offs_n_fields(const ulint*)"
"page_zip_decompress_clust_ext(z_stream*,rec_t*,const ulint*,ulint)" -> "rec_offs_nth_extern(const ulint*,ulint)"
"page_zip_decompress_clust_ext(z_stream*,rec_t*,const ulint*,ulint)" -> "__builtin_expect(long int,long int)"
"page_zip_decompress_clust_ext(z_stream*,rec_t*,const ulint*,ulint)" -> "rec_get_nth_field_offs(const ulint*,ulint,ulint*)"
"page_zip_decompress_clust_ext(z_stream*,rec_t*,const ulint*,ulint)" -> "memset(void*,int,size_t)"
"page_zip_decompress_clust_ext(z_stream*,rec_t*,const ulint*,ulint)" -> "inflate(z_streamp,int)"
"page_zip_dir_find_free(page_zip_des_t*,ulint)" -> "page_zip_dir_find_low(unsigned char*,unsigned char*,ulint)"
"page_zip_dir_find_free(page_zip_des_t*,ulint)" -> "page_zip_dir_size(const page_zip_des_t*)"
"page_zip_dir_find_free(page_zip_des_t*,ulint)" -> "page_zip_dir_user_size(const page_zip_des_t*)"
"page_zip_dir_find_free(page_zip_des_t*,ulint)" -> "page_zip_get_size(const page_zip_des_t*)"
"page_zip_dir_size(const page_zip_des_t*)" -> "page_zip_dir_elems(const page_zip_des_t*)"
"page_zip_decompress_sec(page_zip_des_t*,z_stream*,rec_t**,ulint,dict_index_t*,ulint*)" -> "page_dir_get_n_slots(const ib_page_t*)"
"page_zip_decompress_sec(page_zip_des_t*,z_stream*,rec_t**,ulint,dict_index_t*,ulint*)" -> "page_align(const void*)"
"page_zip_decompress_sec(page_zip_des_t*,z_stream*,rec_t**,ulint,dict_index_t*,ulint*)" -> "dict_index_is_clust(const dict_index_t*)"
"page_zip_decompress_sec(page_zip_des_t*,z_stream*,rec_t**,ulint,dict_index_t*,ulint*)" -> "page_zip_get_size(const page_zip_des_t*)"
"page_zip_decompress_sec(page_zip_des_t*,z_stream*,rec_t**,ulint,dict_index_t*,ulint*)" -> "ut_dbg_assertion_failed(const char*,const char*,ulint)"
"page_zip_decompress_sec(page_zip_des_t*,z_stream*,rec_t**,ulint,dict_index_t*,ulint*)" -> "inflateEnd(z_streamp)"
"page_zip_decompress_sec(page_zip_des_t*,z_stream*,rec_t**,ulint,dict_index_t*,ulint*)" -> "inflate(z_streamp,int)"
"page_zip_decompress_sec(page_zip_des_t*,z_stream*,rec_t**,ulint,dict_index_t*,ulint*)" -> "memset(void*,int,size_t)"
"page_zip_decompress_sec(page_zip_des_t*,z_stream*,rec_t**,ulint,dict_index_t*,ulint*)" -> "__builtin_expect(long int,long int)"
"page_zip_decompress_sec(page_zip_des_t*,z_stream*,rec_t**,ulint,dict_index_t*,ulint*)" -> "page_zip_decompress_heap_no(z_stream*,rec_t*,ulint&)"
"page_zip_decompress_sec(page_zip_des_t*,z_stream*,rec_t**,ulint,dict_index_t*,ulint*)" -> "page_zip_get_trailer_len(const page_zip_des_t*,ulint)"
"page_zip_decompress_sec(page_zip_des_t*,z_stream*,rec_t**,ulint,dict_index_t*,ulint*)" -> "abort()"
"page_zip_decompress_sec(page_zip_des_t*,z_stream*,rec_t**,ulint,dict_index_t*,ulint*)" -> "page_header_get_field(const ib_page_t*,ulint)"
"page_zip_decompress_sec(page_zip_des_t*,z_stream*,rec_t**,ulint,dict_index_t*,ulint*)" -> "page_zip_apply_log(const unsigned char*,ulint,rec_t**,ulint,ulint,ulint,dict_index_t*,ulint*)"
"page_zip_decompress_sec(page_zip_des_t*,z_stream*,rec_t**,ulint,dict_index_t*,ulint*)" -> "page_offset(const void*)"
"page_zip_decompress_node_ptrs(page_zip_des_t*,z_stream*,rec_t**,ulint,dict_index_t*,ulint*,mem_heap_t*)" -> "rec_offs_data_size(const ulint*)"
"page_zip_decompress_node_ptrs(page_zip_des_t*,z_stream*,rec_t**,ulint,dict_index_t*,ulint*,mem_heap_t*)" -> "page_offset(const void*)"
"page_zip_decompress_node_ptrs(page_zip_des_t*,z_stream*,rec_t**,ulint,dict_index_t*,ulint*,mem_heap_t*)" -> "dict_index_is_clust(const dict_index_t*)"
"page_zip_decompress_node_ptrs(page_zip_des_t*,z_stream*,rec_t**,ulint,dict_index_t*,ulint*,mem_heap_t*)" -> "__builtin_expect(long int,long int)"
"page_zip_decompress_node_ptrs(page_zip_des_t*,z_stream*,rec_t**,ulint,dict_index_t*,ulint*,mem_heap_t*)" -> "abort()"
"page_zip_decompress_node_ptrs(page_zip_des_t*,z_stream*,rec_t**,ulint,dict_index_t*,ulint*,mem_heap_t*)" -> "page_zip_get_size(const page_zip_des_t*)"
"page_zip_decompress_node_ptrs(page_zip_des_t*,z_stream*,rec_t**,ulint,dict_index_t*,ulint*,mem_heap_t*)" -> "rec_get_offsets_func(const rec_t*,const dict_index_t*,ulint*,ulint,mem_heap_t**)"
"page_zip_decompress_node_ptrs(page_zip_des_t*,z_stream*,rec_t**,ulint,dict_index_t*,ulint*,mem_heap_t*)" -> "page_dir_get_n_slots(const ib_page_t*)"
"page_zip_decompress_node_ptrs(page_zip_des_t*,z_stream*,rec_t**,ulint,dict_index_t*,ulint*,mem_heap_t*)" -> "memset(void*,int,size_t)"
"page_zip_decompress_node_ptrs(page_zip_des_t*,z_stream*,rec_t**,ulint,dict_index_t*,ulint*,mem_heap_t*)" -> "page_header_get_field(const ib_page_t*,ulint)"
"page_zip_decompress_node_ptrs(page_zip_des_t*,z_stream*,rec_t**,ulint,dict_index_t*,ulint*,mem_heap_t*)" -> "ut_dbg_assertion_failed(const char*,const char*,ulint)"
"page_zip_decompress_node_ptrs(page_zip_des_t*,z_stream*,rec_t**,ulint,dict_index_t*,ulint*,mem_heap_t*)" -> "memcpy(void*,const void*,size_t)"
"page_zip_decompress_node_ptrs(page_zip_des_t*,z_stream*,rec_t**,ulint,dict_index_t*,ulint*,mem_heap_t*)" -> "page_zip_dir_start_offs(const page_zip_des_t*,ulint)"
"page_zip_decompress_node_ptrs(page_zip_des_t*,z_stream*,rec_t**,ulint,dict_index_t*,ulint*,mem_heap_t*)" -> "page_zip_decompress_heap_no(z_stream*,rec_t*,ulint&)"
"page_zip_decompress_node_ptrs(page_zip_des_t*,z_stream*,rec_t**,ulint,dict_index_t*,ulint*,mem_heap_t*)" -> "inflateEnd(z_streamp)"
"page_zip_decompress_node_ptrs(page_zip_des_t*,z_stream*,rec_t**,ulint,dict_index_t*,ulint*,mem_heap_t*)" -> "page_zip_apply_log(const unsigned char*,ulint,rec_t**,ulint,ulint,ulint,dict_index_t*,ulint*)"
"page_zip_decompress_node_ptrs(page_zip_des_t*,z_stream*,rec_t**,ulint,dict_index_t*,ulint*,mem_heap_t*)" -> "page_align(const void*)"
"page_zip_decompress_node_ptrs(page_zip_des_t*,z_stream*,rec_t**,ulint,dict_index_t*,ulint*,mem_heap_t*)" -> "page_zip_get_trailer_len(const page_zip_des_t*,ulint)"
"page_zip_decompress_node_ptrs(page_zip_des_t*,z_stream*,rec_t**,ulint,dict_index_t*,ulint*,mem_heap_t*)" -> "inflate(z_streamp,int)"
"page_zip_set_extra_bytes(const page_zip_des_t*,ib_page_t*,ulint)" -> "page_get_n_recs(const ib_page_t*)"
"page_zip_set_extra_bytes(const page_zip_des_t*,ib_page_t*,ulint)" -> "rec_set_next_offs_new(rec_t*,ulint)"
"page_zip_set_extra_bytes(const page_zip_des_t*,ib_page_t*,ulint)" -> "page_dir_get_n_heap(const ib_page_t*)"
"page_zip_set_extra_bytes(const page_zip_des_t*,ib_page_t*,ulint)" -> "__builtin_expect(long int,long int)"
"page_zip_set_extra_bytes(const page_zip_des_t*,ib_page_t*,ulint)" -> "page_zip_dir_get(const page_zip_des_t*,ulint)"
"page_zip_fields_free(dict_index_t*)" -> "mem_heap_free_func(mem_heap_t*,const char*,ulint)"
"page_zip_fields_free(dict_index_t*)" -> "dict_mem_table_free(dict_table_t*)"
"page_zip_fields_free(dict_index_t*)" -> "pfs_os_fast_mutex_free(os_fast_mutex_t*)"
"dict_mem_table_free(dict_table_t*)" -> "fts_optimize_remove_table(dict_table_t*)"
"dict_mem_table_free(dict_table_t*)" -> "dict_table_has_fts_index(dict_table_t*)"
"dict_mem_table_free(dict_table_t*)" -> "mem_heap_free_func(mem_heap_t*,const char*,ulint)"
"dict_mem_table_free(dict_table_t*)" -> "dict_table_stats_latch_destroy(dict_table_t*)"
"dict_mem_table_free(dict_table_t*)" -> "fts_free(dict_table_t*)"
"dict_mem_table_free(dict_table_t*)" -> "ut_free(void*)"
"dict_mem_table_free(dict_table_t*)" -> "pfs_mutex_free_func(ib_mutex_t*)"
"fts_optimize_remove_table(dict_table_t*)" -> "os_event_wait_low(os_event_t,ib_int64_t)"
"fts_optimize_remove_table(dict_table_t*)" -> "os_event_free(os_event_t)"
"fts_optimize_remove_table(dict_table_t*)" -> "fts_optimize_create_msg(fts_msg_type_t,void*)"
"fts_optimize_remove_table(dict_table_t*)" -> "ib_wqueue_add(ib_wqueue_t*,void*,mem_heap_t*)"
"fts_optimize_remove_table(dict_table_t*)" -> "os_event_create()"
"fts_optimize_remove_table(dict_table_t*)" -> "ib_logf(ib_log_level_t,const char*,...)"
"fts_optimize_remove_table(dict_table_t*)" -> "mem_heap_alloc(mem_heap_t*,ulint)"
"os_event_free(os_event_t)" -> "os_mutex_exit(os_ib_mutex_t)"
"os_event_free(os_event_t)" -> "ut_dbg_assertion_failed(const char*,const char*,ulint)"
"os_event_free(os_event_t)" -> "ut_list_remove(List&,Type&,size_t) [with List = ut_list_base<os_event>,Type = os_event,size_t = long unsigned int]"
"os_event_free(os_event_t)" -> "pfs_os_fast_mutex_free(os_fast_mutex_t*)"
"os_event_free(os_event_t)" -> "os_mutex_enter(os_ib_mutex_t)"
"os_event_free(os_event_t)" -> "ut_free(void*)"
"os_event_free(os_event_t)" -> "__builtin_expect(long int,long int)"
"os_event_free(os_event_t)" -> "abort()"
"os_event_free(os_event_t)" -> "os_cond_destroy(os_cond_t*)"
"ut_list_remove(List&,Type&,size_t) [with List = ut_list_base<os_event>,Type = os_event,size_t = long unsigned int]" -> "abort()"
"ut_list_remove(List&,Type&,size_t) [with List = ut_list_base<os_event>,Type = os_event,size_t = long unsigned int]" -> "__builtin_expect(long int,long int)"
"ut_list_remove(List&,Type&,size_t) [with List = ut_list_base<os_event>,Type = os_event,size_t = long unsigned int]" -> "ut_dbg_assertion_failed(const char*,const char*,ulint)"
"ut_list_remove(List&,Type&,size_t) [with List = ut_list_base<os_event>,Type = os_event,size_t = long unsigned int]" -> "ut_elem_get_node(Type&,size_t) [with Type = os_event,size_t = long unsigned int]"
"ut_elem_get_node(Type&,size_t) [with Type = os_event,size_t = long unsigned int]" -> "__builtin_expect(long int,long int)"
"ut_elem_get_node(Type&,size_t) [with Type = os_event,size_t = long unsigned int]" -> "abort()"
"ut_elem_get_node(Type&,size_t) [with Type = os_event,size_t = long unsigned int]" -> "ut_dbg_assertion_failed(const char*,const char*,ulint)"
"pfs_os_fast_mutex_free(os_fast_mutex_t*)" -> "os_fast_mutex_free_func(fast_mutex_t*)"
"os_fast_mutex_free_func(fast_mutex_t*)" -> "_IO_putc(int,_IO_FILE*)"
"os_fast_mutex_free_func(fast_mutex_t*)" -> "os_mutex_enter(os_ib_mutex_t)"
"os_fast_mutex_free_func(fast_mutex_t*)" -> "__builtin_expect(long int,long int)"
"os_fast_mutex_free_func(fast_mutex_t*)" -> "fprintf(FILE*,const char*,...)"
"os_fast_mutex_free_func(fast_mutex_t*)" -> "ut_print_timestamp(FILE*)"
"os_fast_mutex_free_func(fast_mutex_t*)" -> "pthread_mutex_destroy(pthread_mutex_t*)"
"os_fast_mutex_free_func(fast_mutex_t*)" -> "ut_print_buf(FILE*,const void*,ulint)"
"os_fast_mutex_free_func(fast_mutex_t*)" -> "os_mutex_exit(os_ib_mutex_t)"
"os_cond_destroy(os_cond_t*)" -> "ut_dbg_assertion_failed(const char*,const char*,ulint)"
"os_cond_destroy(os_cond_t*)" -> "__builtin_expect(long int,long int)"
"os_cond_destroy(os_cond_t*)" -> "pthread_cond_destroy(pthread_cond_t*)"
"os_cond_destroy(os_cond_t*)" -> "abort()"
"fts_optimize_create_msg(fts_msg_type_t,void*)" -> "mem_heap_create_func(ulint,ulint)"
"fts_optimize_create_msg(fts_msg_type_t,void*)" -> "mem_heap_alloc(mem_heap_t*,ulint)"
"ib_wqueue_add(ib_wqueue_t*,void*,mem_heap_t*)" -> "ib_list_add_last(ib_list_t*,void*,mem_heap_t*)"
"ib_wqueue_add(ib_wqueue_t*,void*,mem_heap_t*)" -> "os_event_set(os_event_t)"
"ib_wqueue_add(ib_wqueue_t*,void*,mem_heap_t*)" -> "pfs_mutex_exit_func(ib_mutex_t*)"
"ib_wqueue_add(ib_wqueue_t*,void*,mem_heap_t*)" -> "pfs_mutex_enter_func(ib_mutex_t*,const char*,ulint)"
"ib_list_add_last(ib_list_t*,void*,mem_heap_t*)" -> "ib_list_get_last(ib_list_t*)"
"ib_list_add_last(ib_list_t*,void*,mem_heap_t*)" -> "ib_list_add_after(ib_list_t*,ib_list_node_t*,void*,mem_heap_t*)"
"ib_list_add_after(ib_list_t*,ib_list_node_t*,void*,mem_heap_t*)" -> "__builtin_expect(long int,long int)"
"ib_list_add_after(ib_list_t*,ib_list_node_t*,void*,mem_heap_t*)" -> "abort()"
"ib_list_add_after(ib_list_t*,ib_list_node_t*,void*,mem_heap_t*)" -> "mem_heap_alloc(mem_heap_t*,ulint)"
"ib_list_add_after(ib_list_t*,ib_list_node_t*,void*,mem_heap_t*)" -> "ut_dbg_assertion_failed(const char*,const char*,ulint)"
"os_event_create()" -> "os_cond_init(os_cond_t*)"
"os_event_create()" -> "os_mutex_enter(os_ib_mutex_t)"
"os_event_create()" -> "ut_malloc_low(ulint,ulint)"
"os_event_create()" -> "pfs_os_fast_mutex_init(PSI_mutex_key,os_fast_mutex_t*)"
"os_event_create()" -> "ut_list_prepend(List&,Type&,size_t) [with List = ut_list_base<os_event>,Type = os_event,size_t = long unsigned int]"
"os_event_create()" -> "os_mutex_exit(os_ib_mutex_t)"
"os_cond_init(os_cond_t*)" -> "ut_dbg_assertion_failed(const char*,const char*,ulint)"
"os_cond_init(os_cond_t*)" -> "abort()"
"os_cond_init(os_cond_t*)" -> "__builtin_expect(long int,long int)"
"os_cond_init(os_cond_t*)" -> "pthread_cond_init(pthread_cond_t*,const pthread_condattr_t*)"
"pfs_os_fast_mutex_init(PSI_mutex_key,os_fast_mutex_t*)" -> "os_fast_mutex_init_func(fast_mutex_t*)"
"os_fast_mutex_init_func(fast_mutex_t*)" -> "__builtin_expect(long int,long int)"
"os_fast_mutex_init_func(fast_mutex_t*)" -> "abort()"
"os_fast_mutex_init_func(fast_mutex_t*)" -> "pthread_mutex_init(pthread_mutex_t*,const pthread_mutexattr_t*)"
"os_fast_mutex_init_func(fast_mutex_t*)" -> "os_mutex_enter(os_ib_mutex_t)"
"os_fast_mutex_init_func(fast_mutex_t*)" -> "ut_dbg_assertion_failed(const char*,const char*,ulint)"
"os_fast_mutex_init_func(fast_mutex_t*)" -> "os_mutex_exit(os_ib_mutex_t)"
"ut_list_prepend(List&,Type&,size_t) [with List = ut_list_base<os_event>,Type = os_event,size_t = long unsigned int]" -> "ut_elem_get_node(Type&,size_t) [with Type = os_event,size_t = long unsigned int]"
"dict_table_stats_latch_destroy(dict_table_t*)" -> "dict_table_stats_latch_free(dict_table_t*)"
"dict_table_stats_latch_free(dict_table_t*)" -> "pfs_rw_lock_free_func(rw_lock_t*)"
"pfs_rw_lock_free_func(rw_lock_t*)" -> "rw_lock_free_func(rw_lock_t*)"
"rw_lock_free_func(rw_lock_t*)" -> "pfs_mutex_exit_func(ib_mutex_t*)"
"rw_lock_free_func(rw_lock_t*)" -> "abort()"
"rw_lock_free_func(rw_lock_t*)" -> "os_event_free(os_event_t)"
"rw_lock_free_func(rw_lock_t*)" -> "ut_dbg_assertion_failed(const char*,const char*,ulint)"
"rw_lock_free_func(rw_lock_t*)" -> "__builtin_expect(long int,long int)"
"rw_lock_free_func(rw_lock_t*)" -> "ut_list_remove(List&,Type&,size_t) [with List = ut_list_base<rw_lock_t>,Type = rw_lock_t,size_t = long unsigned int]"
"rw_lock_free_func(rw_lock_t*)" -> "pfs_mutex_enter_func(ib_mutex_t*,const char*,ulint)"
"ut_list_remove(List&,Type&,size_t) [with List = ut_list_base<rw_lock_t>,Type = rw_lock_t,size_t = long unsigned int]" -> "__builtin_expect(long int,long int)"
"ut_list_remove(List&,Type&,size_t) [with List = ut_list_base<rw_lock_t>,Type = rw_lock_t,size_t = long unsigned int]" -> "abort()"
"ut_list_remove(List&,Type&,size_t) [with List = ut_list_base<rw_lock_t>,Type = rw_lock_t,size_t = long unsigned int]" -> "ut_dbg_assertion_failed(const char*,const char*,ulint)"
"ut_list_remove(List&,Type&,size_t) [with List = ut_list_base<rw_lock_t>,Type = rw_lock_t,size_t = long unsigned int]" -> "ut_elem_get_node(Type&,size_t) [with Type = rw_lock_t,size_t = long unsigned int]"
"ut_elem_get_node(Type&,size_t) [with Type = rw_lock_t,size_t = long unsigned int]" -> "__builtin_expect(long int,long int)"
"ut_elem_get_node(Type&,size_t) [with Type = rw_lock_t,size_t = long unsigned int]" -> "ut_dbg_assertion_failed(const char*,const char*,ulint)"
"ut_elem_get_node(Type&,size_t) [with Type = rw_lock_t,size_t = long unsigned int]" -> "abort()"
"fts_free(dict_table_t*)" -> "fts_cache_destroy(fts_cache_t*)"
"fts_free(dict_table_t*)" -> "pfs_mutex_free_func(ib_mutex_t*)"
"fts_free(dict_table_t*)" -> "fts_cache_clear(fts_cache_t*)"
"fts_free(dict_table_t*)" -> "mem_heap_free_func(mem_heap_t*,const char*,ulint)"
"fts_cache_destroy(fts_cache_t*)" -> "mem_heap_free_func(mem_heap_t*,const char*,ulint)"
"fts_cache_destroy(fts_cache_t*)" -> "pfs_rw_lock_free_func(rw_lock_t*)"
"fts_cache_destroy(fts_cache_t*)" -> "pfs_mutex_free_func(ib_mutex_t*)"
"fts_cache_destroy(fts_cache_t*)" -> "rbt_free(ib_rbt_t*)"
"pfs_mutex_free_func(ib_mutex_t*)" -> "mutex_free_func(ib_mutex_t*)"
"mutex_free_func(ib_mutex_t*)" -> "pfs_mutex_enter_func(ib_mutex_t*,const char*,ulint)"
"mutex_free_func(ib_mutex_t*)" -> "pfs_mutex_exit_func(ib_mutex_t*)"
"mutex_free_func(ib_mutex_t*)" -> "abort()"
"mutex_free_func(ib_mutex_t*)" -> "__builtin_expect(long int,long int)"
"mutex_free_func(ib_mutex_t*)" -> "os_event_free(os_event_t)"
"mutex_free_func(ib_mutex_t*)" -> "mutex_get_lock_word(const ib_mutex_t*)"
"mutex_free_func(ib_mutex_t*)" -> "ut_list_remove(List&,Type&,size_t) [with List = ut_list_base<ib_mutex_t>,Type = ib_mutex_t,size_t = long unsigned int]"
"mutex_free_func(ib_mutex_t*)" -> "mutex_get_waiters(const ib_mutex_t*)"
"mutex_free_func(ib_mutex_t*)" -> "ut_dbg_assertion_failed(const char*,const char*,ulint)"
"ut_list_remove(List&,Type&,size_t) [with List = ut_list_base<ib_mutex_t>,Type = ib_mutex_t,size_t = long unsigned int]" -> "ut_elem_get_node(Type&,size_t) [with Type = ib_mutex_t,size_t = long unsigned int]"
"ut_list_remove(List&,Type&,size_t) [with List = ut_list_base<ib_mutex_t>,Type = ib_mutex_t,size_t = long unsigned int]" -> "__builtin_expect(long int,long int)"
"ut_list_remove(List&,Type&,size_t) [with List = ut_list_base<ib_mutex_t>,Type = ib_mutex_t,size_t = long unsigned int]" -> "abort()"
"ut_list_remove(List&,Type&,size_t) [with List = ut_list_base<ib_mutex_t>,Type = ib_mutex_t,size_t = long unsigned int]" -> "ut_dbg_assertion_failed(const char*,const char*,ulint)"
"ut_elem_get_node(Type&,size_t) [with Type = ib_mutex_t,size_t = long unsigned int]" -> "ut_dbg_assertion_failed(const char*,const char*,ulint)"
"ut_elem_get_node(Type&,size_t) [with Type = ib_mutex_t,size_t = long unsigned int]" -> "abort()"
"ut_elem_get_node(Type&,size_t) [with Type = ib_mutex_t,size_t = long unsigned int]" -> "__builtin_expect(long int,long int)"
"rbt_free(ib_rbt_t*)" -> "ut_free(void*)"
"rbt_free(ib_rbt_t*)" -> "rbt_free_node(ib_rbt_node_t*,ib_rbt_node_t*)"
"rbt_free_node(ib_rbt_node_t*,ib_rbt_node_t*)" -> "ut_free(void*)"
"rbt_free_node(ib_rbt_node_t*,ib_rbt_node_t*)" -> "rbt_free_node(ib_rbt_node_t*,ib_rbt_node_t*)"
"fts_cache_clear(fts_cache_t*)" -> "ib_vector_size(const ib_vector_t*)"
"fts_cache_clear(fts_cache_t*)" -> "fts_words_free(ib_rbt_t*)"
"fts_cache_clear(fts_cache_t*)" -> "ib_vector_get(ib_vector_t*,ulint)"
"fts_cache_clear(fts_cache_t*)" -> "pfs_mutex_enter_func(ib_mutex_t*,const char*,ulint)"
"fts_cache_clear(fts_cache_t*)" -> "fts_que_graph_free_check_lock(fts_table_t*,const fts_index_cache_t*,que_t*)"
"fts_cache_clear(fts_cache_t*)" -> "mem_heap_free_func(mem_heap_t*,const char*,ulint)"
"fts_cache_clear(fts_cache_t*)" -> "rbt_free(ib_rbt_t*)"
"fts_cache_clear(fts_cache_t*)" -> "pfs_mutex_exit_func(ib_mutex_t*)"
"fts_words_free(ib_rbt_t*)" -> "ib_vector_size(const ib_vector_t*)"
"fts_words_free(ib_rbt_t*)" -> "ut_free(void*)"
"fts_words_free(ib_rbt_t*)" -> "ib_vector_get(ib_vector_t*,ulint)"
"fts_words_free(ib_rbt_t*)" -> "rbt_remove_node(ib_rbt_t*,const ib_rbt_node_t*)"
"fts_words_free(ib_rbt_t*)" -> "rbt_first(const ib_rbt_t*)"
"ib_vector_get(ib_vector_t*,ulint)" -> "__builtin_expect(long int,long int)"
"ib_vector_get(ib_vector_t*,ulint)" -> "ut_dbg_assertion_failed(const char*,const char*,ulint)"
"ib_vector_get(ib_vector_t*,ulint)" -> "abort()"
"rbt_remove_node(ib_rbt_t*,const ib_rbt_node_t*)" -> "rbt_remove_node_and_rebalance(ib_rbt_t*,ib_rbt_node_t*)"
"rbt_remove_node_and_rebalance(ib_rbt_t*,ib_rbt_node_t*)" -> "__builtin_expect(long int,long int)"
"rbt_remove_node_and_rebalance(ib_rbt_t*,ib_rbt_node_t*)" -> "abort()"
"rbt_remove_node_and_rebalance(ib_rbt_t*,ib_rbt_node_t*)" -> "rbt_detach_node(const ib_rbt_t*,ib_rbt_node_t*)"
"rbt_remove_node_and_rebalance(ib_rbt_t*,ib_rbt_node_t*)" -> "rbt_balance_left(const ib_rbt_node_t*,ib_rbt_node_t*,ib_rbt_node_t*)"
"rbt_remove_node_and_rebalance(ib_rbt_t*,ib_rbt_node_t*)" -> "rbt_balance_right(const ib_rbt_node_t*,ib_rbt_node_t*,ib_rbt_node_t*)"
"rbt_remove_node_and_rebalance(ib_rbt_t*,ib_rbt_node_t*)" -> "ut_dbg_assertion_failed(const char*,const char*,ulint)"
"rbt_detach_node(const ib_rbt_t*,ib_rbt_node_t*)" -> "rbt_replace_node(ib_rbt_node_t*,ib_rbt_node_t*)"
"rbt_detach_node(const ib_rbt_t*,ib_rbt_node_t*)" -> "abort()"
"rbt_detach_node(const ib_rbt_t*,ib_rbt_node_t*)" -> "rbt_eject_node(ib_rbt_node_t*,ib_rbt_node_t*)"
"rbt_detach_node(const ib_rbt_t*,ib_rbt_node_t*)" -> "__builtin_expect(long int,long int)"
"rbt_detach_node(const ib_rbt_t*,ib_rbt_node_t*)" -> "ut_dbg_assertion_failed(const char*,const char*,ulint)"
"rbt_detach_node(const ib_rbt_t*,ib_rbt_node_t*)" -> "rbt_find_successor(const ib_rbt_t*,const ib_rbt_node_t*)"
"rbt_replace_node(ib_rbt_node_t*,ib_rbt_node_t*)" -> "rbt_eject_node(ib_rbt_node_t*,ib_rbt_node_t*)"
"rbt_eject_node(ib_rbt_node_t*,ib_rbt_node_t*)" -> "abort()"
"rbt_eject_node(ib_rbt_node_t*,ib_rbt_node_t*)" -> "ut_dbg_assertion_failed(const char*,const char*,ulint)"
"rbt_balance_left(const ib_rbt_node_t*,ib_rbt_node_t*,ib_rbt_node_t*)" -> "rbt_rotate_left(const ib_rbt_node_t*,ib_rbt_node_t*)"
"rbt_balance_left(const ib_rbt_node_t*,ib_rbt_node_t*,ib_rbt_node_t*)" -> "abort()"
"rbt_balance_left(const ib_rbt_node_t*,ib_rbt_node_t*,ib_rbt_node_t*)" -> "__builtin_expect(long int,long int)"
"rbt_balance_left(const ib_rbt_node_t*,ib_rbt_node_t*,ib_rbt_node_t*)" -> "ut_dbg_assertion_failed(const char*,const char*,ulint)"
"rbt_balance_left(const ib_rbt_node_t*,ib_rbt_node_t*,ib_rbt_node_t*)" -> "rbt_rotate_right(const ib_rbt_node_t*,ib_rbt_node_t*)"
"rbt_balance_right(const ib_rbt_node_t*,ib_rbt_node_t*,ib_rbt_node_t*)" -> "rbt_rotate_right(const ib_rbt_node_t*,ib_rbt_node_t*)"
"rbt_balance_right(const ib_rbt_node_t*,ib_rbt_node_t*,ib_rbt_node_t*)" -> "abort()"
"rbt_balance_right(const ib_rbt_node_t*,ib_rbt_node_t*,ib_rbt_node_t*)" -> "rbt_rotate_left(const ib_rbt_node_t*,ib_rbt_node_t*)"
"rbt_balance_right(const ib_rbt_node_t*,ib_rbt_node_t*,ib_rbt_node_t*)" -> "__builtin_expect(long int,long int)"
"rbt_balance_right(const ib_rbt_node_t*,ib_rbt_node_t*,ib_rbt_node_t*)" -> "ut_dbg_assertion_failed(const char*,const char*,ulint)"
"fts_que_graph_free_check_lock(fts_table_t*,const fts_index_cache_t*,que_t*)" -> "pfs_mutex_enter_func(ib_mutex_t*,const char*,ulint)"
"fts_que_graph_free_check_lock(fts_table_t*,const fts_index_cache_t*,que_t*)" -> "que_graph_free(que_t*)"
"fts_que_graph_free_check_lock(fts_table_t*,const fts_index_cache_t*,que_t*)" -> "pfs_mutex_exit_func(ib_mutex_t*)"
"que_graph_free(que_t*)" -> "que_graph_free_recursive(que_node_t*)"
"que_graph_free(que_t*)" -> "mem_heap_free_func(mem_heap_t*,const char*,ulint)"
"que_graph_free(que_t*)" -> "sym_tab_free_private(sym_tab_t*)"
"que_graph_free(que_t*)" -> "pars_info_free(pars_info_t*)"
"que_graph_free_recursive(que_node_t*)" -> "abort()"
"que_graph_free_recursive(que_node_t*)" -> "fprintf(FILE*,const char*,...)"
"que_graph_free_recursive(que_node_t*)" -> "mem_analyze_corruption(void*)"
"que_graph_free_recursive(que_node_t*)" -> "mem_heap_free_func(mem_heap_t*,const char*,ulint)"
"que_graph_free_recursive(que_node_t*)" -> "que_graph_free_recursive(que_node_t*)"
"que_graph_free_recursive(que_node_t*)" -> "que_graph_free_stat_list(que_node_t*)"
"que_graph_free_recursive(que_node_t*)" -> "btr_pcur_free_for_mysql(btr_pcur_t*)"
"que_graph_free_recursive(que_node_t*)" -> "que_node_get_type(que_node_t*)"
"que_graph_free_recursive(que_node_t*)" -> "ut_dbg_assertion_failed(const char*,const char*,ulint)"
"que_graph_free_recursive(que_node_t*)" -> "sel_node_free_private(sel_node_t*)"
"que_graph_free_stat_list(que_node_t*)" -> "que_graph_free_recursive(que_node_t*)"
"que_graph_free_stat_list(que_node_t*)" -> "que_node_get_next(que_node_t*)"
"btr_pcur_free_for_mysql(btr_pcur_t*)" -> "btr_pcur_reset(btr_pcur_t*)"
"btr_pcur_free_for_mysql(btr_pcur_t*)" -> "mem_free_func(void*,const char*,ulint)"
"btr_pcur_reset(btr_pcur_t*)" -> "mem_free_func(void*,const char*,ulint)"
"sel_node_free_private(sel_node_t*)" -> "btr_pcur_close(btr_pcur_t*)"
"sel_node_free_private(sel_node_t*)" -> "mem_heap_free_func(mem_heap_t*,const char*,ulint)"
"sel_node_free_private(sel_node_t*)" -> "sel_node_get_nth_plan(sel_node_t*,ulint)"
"btr_pcur_close(btr_pcur_t*)" -> "mem_free_func(void*,const char*,ulint)"
"sym_tab_free_private(sym_tab_t*)" -> "que_graph_free_recursive(que_node_t*)"
"sym_tab_free_private(sym_tab_t*)" -> "eval_node_free_val_buf(que_node_t*)"
"sym_tab_free_private(sym_tab_t*)" -> "dict_table_close(dict_table_t*,ulint,ulint)"
"sym_tab_free_private(sym_tab_t*)" -> "sel_col_prefetch_buf_free(sel_buf_t*)"
"eval_node_free_val_buf(que_node_t*)" -> "ut_dbg_assertion_failed(const char*,const char*,ulint)"
"eval_node_free_val_buf(que_node_t*)" -> "mem_free_func(void*,const char*,ulint)"
"eval_node_free_val_buf(que_node_t*)" -> "abort()"
"eval_node_free_val_buf(que_node_t*)" -> "__builtin_expect(long int,long int)"
"eval_node_free_val_buf(que_node_t*)" -> "que_node_get_val_buf_size(que_node_t*)"
"eval_node_free_val_buf(que_node_t*)" -> "que_node_get_val(que_node_t*)"
"dict_table_close(dict_table_t*,ulint,ulint)" -> "ut_dbg_assertion_failed(const char*,const char*,ulint)"
"dict_table_close(dict_table_t*,ulint,ulint)" -> "strchr(char*,int)"
"dict_table_close(dict_table_t*,ulint,ulint)" -> "dict_stats_is_persistent_enabled(const dict_table_t*)"
"dict_table_close(dict_table_t*,ulint,ulint)" -> "__builtin_expect(long int,long int)"
"dict_table_close(dict_table_t*,ulint,ulint)" -> "pfs_mutex_enter_func(ib_mutex_t*,const char*,ulint)"
"dict_table_close(dict_table_t*,ulint,ulint)" -> "dict_table_try_drop_aborted(dict_table_t*,table_id_t,ulint)"
"dict_table_close(dict_table_t*,ulint,ulint)" -> "pfs_mutex_exit_func(ib_mutex_t*)"
"dict_table_close(dict_table_t*,ulint,ulint)" -> "abort()"
"dict_table_close(dict_table_t*,ulint,ulint)" -> "dict_stats_deinit(dict_table_t*)"
"dict_table_try_drop_aborted(dict_table_t*,table_id_t,ulint)" -> "row_mysql_lock_data_dictionary_func(trx_t*,const char*,ulint)"
"dict_table_try_drop_aborted(dict_table_t*,table_id_t,ulint)" -> "row_mysql_unlock_data_dictionary(trx_t*)"
"dict_table_try_drop_aborted(dict_table_t*,table_id_t,ulint)" -> "trx_free_for_background(trx_t*)"
"dict_table_try_drop_aborted(dict_table_t*,table_id_t,ulint)" -> "trx_allocate_for_background()"
"dict_table_try_drop_aborted(dict_table_t*,table_id_t,ulint)" -> "trx_commit_for_mysql(trx_t*)"
"dict_table_try_drop_aborted(dict_table_t*,table_id_t,ulint)" -> "trx_set_dict_operation(trx_t*,trx_dict_op_t)"
"dict_table_try_drop_aborted(dict_table_t*,table_id_t,ulint)" -> "dict_table_open_on_id_low(table_id_t,dict_err_ignore_t)"
"dict_table_try_drop_aborted(dict_table_t*,table_id_t,ulint)" -> "row_merge_drop_indexes(trx_t*,dict_table_t*,ulint)"
"row_mysql_lock_data_dictionary_func(trx_t*,const char*,ulint)" -> "pfs_rw_lock_x_lock_func(rw_lock_t*,ulint,const char*,ulint)"
"row_mysql_lock_data_dictionary_func(trx_t*,const char*,ulint)" -> "__builtin_expect(long int,long int)"
"row_mysql_lock_data_dictionary_func(trx_t*,const char*,ulint)" -> "pfs_mutex_enter_func(ib_mutex_t*,const char*,ulint)"
"row_mysql_lock_data_dictionary_func(trx_t*,const char*,ulint)" -> "ut_dbg_assertion_failed(const char*,const char*,ulint)"
"row_mysql_lock_data_dictionary_func(trx_t*,const char*,ulint)" -> "abort()"
"row_mysql_unlock_data_dictionary(trx_t*)" -> "pfs_mutex_exit_func(ib_mutex_t*)"
"row_mysql_unlock_data_dictionary(trx_t*)" -> "abort()"
"row_mysql_unlock_data_dictionary(trx_t*)" -> "ut_dbg_assertion_failed(const char*,const char*,ulint)"
"row_mysql_unlock_data_dictionary(trx_t*)" -> "__builtin_expect(long int,long int)"
"row_mysql_unlock_data_dictionary(trx_t*)" -> "pfs_rw_lock_x_unlock_func(rw_lock_t*)"
"trx_free_for_background(trx_t*)" -> "putc(int,FILE*)"
"trx_free_for_background(trx_t*)" -> "trx_free(trx_t*)"
"trx_free_for_background(trx_t*)" -> "ut_dbg_assertion_failed(const char*,const char*,ulint)"
"trx_free_for_background(trx_t*)" -> "ib_logf(ib_log_level_t,const char*,...)"
"trx_free_for_background(trx_t*)" -> "abort()"
"trx_free_for_background(trx_t*)" -> "ut_print_buf(FILE*,const void*,ulint)"
"trx_free_for_background(trx_t*)" -> "trx_print(FILE*,const trx_t*,ulint)"
"trx_free_for_background(trx_t*)" -> "srv_conc_force_exit_innodb(trx_t*)"
"trx_free_for_background(trx_t*)" -> "__builtin_expect(long int,long int)"
"trx_free(trx_t*)" -> "ib_vector_free(ib_vector_t*)"
"trx_free(trx_t*)" -> "trx_undo_arr_free(trx_undo_arr_t*)"
"trx_free(trx_t*)" -> "mem_free_func(void*,const char*,ulint)"
"trx_free(trx_t*)" -> "ib_vector_is_empty(const ib_vector_t*)"
"trx_free(trx_t*)" -> "ut_dbg_assertion_failed(const char*,const char*,ulint)"
"trx_free(trx_t*)" -> "__builtin_expect(long int,long int)"
"trx_free(trx_t*)" -> "abort()"
"trx_free(trx_t*)" -> "pfs_mutex_free_func(ib_mutex_t*)"
"trx_free(trx_t*)" -> "mem_heap_free_func(mem_heap_t*,const char*,ulint)"
"ib_vector_free(ib_vector_t*)" -> "mem_heap_free_func(mem_heap_t*,const char*,ulint)"
"ib_vector_free(ib_vector_t*)" -> "ib_ut_allocator_free(ib_alloc_t*)"
"ib_ut_allocator_free(ib_alloc_t*)" -> "ut_free(void*)"
"trx_undo_arr_free(trx_undo_arr_t*)" -> "mem_heap_free_func(mem_heap_t*,const char*,ulint)"
"ib_vector_is_empty(const ib_vector_t*)" -> "ib_vector_size(const ib_vector_t*)"
"trx_print(FILE*,const trx_t*,ulint)" -> "pfs_mutex_enter_func(ib_mutex_t*,const char*,ulint)"
"trx_print(FILE*,const trx_t*,ulint)" -> "pfs_mutex_exit_func(ib_mutex_t*)"
"trx_print(FILE*,const trx_t*,ulint)" -> "lock_number_of_rows_locked(const trx_lock_t*)"
"trx_print(FILE*,const trx_t*,ulint)" -> "mem_heap_get_size(mem_heap_t*)"
"trx_print(FILE*,const trx_t*,ulint)" -> "trx_print_low(FILE*,const trx_t*,ulint,ulint,ulint,ulint)"
"lock_number_of_rows_locked(const trx_lock_t*)" -> "lock_get_type_low(const ib_lock_t*)"
"lock_number_of_rows_locked(const trx_lock_t*)" -> "lock_rec_get_nth_bit(const ib_lock_t*,ulint)"
"lock_number_of_rows_locked(const trx_lock_t*)" -> "lock_rec_get_n_bits(const ib_lock_t*)"
"trx_print_low(FILE*,const trx_t*,ulint,ulint,ulint,ulint)" -> "fprintf(FILE*,const char*,...)"
"trx_print_low(FILE*,const trx_t*,ulint,ulint,ulint,ulint)" -> "time(time_t*)"
"trx_print_low(FILE*,const trx_t*,ulint,ulint,ulint,ulint)" -> "innobase_mysql_print_thd(FILE*,THD*,uint)"
"trx_print_low(FILE*,const trx_t*,ulint,ulint,ulint,ulint)" -> "fputs(const char*,FILE*)"
"trx_print_low(FILE*,const trx_t*,ulint,ulint,ulint,ulint)" -> "putc(int,FILE*)"
"trx_print_low(FILE*,const trx_t*,ulint,ulint,ulint,ulint)" -> "__builtin_fwrite(const void*,size_t,size_t,FILE*)"
"trx_print_low(FILE*,const trx_t*,ulint,ulint,ulint,ulint)" -> "difftime(time_t,time_t)"
"innobase_mysql_print_thd(FILE*,THD*,uint)" -> "thd_security_context(THD*,char*,unsigned int,unsigned int)"
"innobase_mysql_print_thd(FILE*,THD*,uint)" -> "fputs(const char*,FILE*)"
"innobase_mysql_print_thd(FILE*,THD*,uint)" -> "putc(int,FILE*)"
"thd_security_context(THD*,char*,unsigned int,unsigned int)" -> "memcpy(void*,const void*,size_t)"
"thd_security_context(THD*,char*,unsigned int,unsigned int)" -> "Security_context::get_ip()"
"thd_security_context(THD*,char*,unsigned int,unsigned int)" -> "String::append(char)"
"thd_security_context(THD*,char*,unsigned int,unsigned int)" -> "my_snprintf(char*,size_t,const char*,...)"
"thd_security_context(THD*,char*,unsigned int,unsigned int)" -> "String::append(const char*,uint32)"
"thd_security_context(THD*,char*,unsigned int,unsigned int)" -> "String::c_ptr_quick()"
"thd_security_context(THD*,char*,unsigned int,unsigned int)" -> "inline_mysql_mutex_lock(mysql_mutex_t*)"
"thd_security_context(THD*,char*,unsigned int,unsigned int)" -> "String::c_ptr_safe()"
"thd_security_context(THD*,char*,unsigned int,unsigned int)" -> "Security_context::get_host()"
"thd_security_context(THD*,char*,unsigned int,unsigned int)" -> "String::length() const"
"thd_security_context(THD*,char*,unsigned int,unsigned int)" -> "std::min(const _Tp&,const _Tp&) [with _Tp = unsigned int]"
"thd_security_context(THD*,char*,unsigned int,unsigned int)" -> "Statement::query_length() const"
"thd_security_context(THD*,char*,unsigned int,unsigned int)" -> "Statement::query() const"
"thd_security_context(THD*,char*,unsigned int,unsigned int)" -> "String::length(uint32)"
"thd_security_context(THD*,char*,unsigned int,unsigned int)" -> "inline_mysql_mutex_unlock(mysql_mutex_t*)"
"thd_security_context(THD*,char*,unsigned int,unsigned int)" -> "String::String(char*,uint32,const CHARSET_INFO*)"
"thd_security_context(THD*,char*,unsigned int,unsigned int)" -> "String::ptr() const"
"thd_security_context(THD*,char*,unsigned int,unsigned int)" -> "String::append(const char*)"
"srv_conc_force_exit_innodb(trx_t*)" -> "thd_is_replication_slave_thread(THD*)"
"srv_conc_force_exit_innodb(trx_t*)" -> "srv_conc_exit_innodb_with_atomics(trx_t*)"
"thd_is_replication_slave_thread(THD*)" -> "thd_slave_thread(const THD*)"
"srv_conc_exit_innodb_with_atomics(trx_t*)" -> "__sync_sub_and_fetch_8(volatile void*,long unsigned int)"
"trx_allocate_for_background()" -> "trx_create()"
"trx_create()" -> "mem_heap_create_func(ulint,ulint)"
"trx_create()" -> "mem_alloc_func(ulint,ulint*)"
"trx_create()" -> "pfs_mutex_create_func(mysql_pfs_key_t,ib_mutex_t*,const char*,ulint)"
"trx_create()" -> "ib_vector_create(ib_alloc_t*,ulint,ulint)"
"trx_create()" -> "memset(void*,int,size_t)"
"trx_create()" -> "ib_heap_allocator_create(mem_heap_t*)"
"pfs_mutex_create_func(mysql_pfs_key_t,ib_mutex_t*,const char*,ulint)" -> "mutex_create_func(ib_mutex_t*,const char*,ulint)"
"mutex_create_func(ib_mutex_t*,const char*,ulint)" -> "os_event_create()"
"mutex_create_func(ib_mutex_t*,const char*,ulint)" -> "mutex_set_waiters(ib_mutex_t*,ulint)"
"mutex_create_func(ib_mutex_t*,const char*,ulint)" -> "pfs_mutex_exit_func(ib_mutex_t*)"
"mutex_create_func(ib_mutex_t*,const char*,ulint)" -> "mutex_reset_lock_word(ib_mutex_t*)"
"mutex_create_func(ib_mutex_t*,const char*,ulint)" -> "ut_list_prepend(List&,Type&,size_t) [with List = ut_list_base<ib_mutex_t>,Type = ib_mutex_t,size_t = long unsigned int]"
"mutex_create_func(ib_mutex_t*,const char*,ulint)" -> "pfs_mutex_enter_func(ib_mutex_t*,const char*,ulint)"
"ut_list_prepend(List&,Type&,size_t) [with List = ut_list_base<ib_mutex_t>,Type = ib_mutex_t,size_t = long unsigned int]" -> "ut_elem_get_node(Type&,size_t) [with Type = ib_mutex_t,size_t = long unsigned int]"
"ib_vector_create(ib_alloc_t*,ulint,ulint)" -> "ut_dbg_assertion_failed(const char*,const char*,ulint)"
"ib_vector_create(ib_alloc_t*,ulint,ulint)" -> "__builtin_expect(long int,long int)"
"ib_vector_create(ib_alloc_t*,ulint,ulint)" -> "abort()"
"ib_heap_allocator_create(mem_heap_t*)" -> "mem_heap_alloc(mem_heap_t*,ulint)"
"trx_commit_for_mysql(trx_t*)" -> "ut_dbg_assertion_failed(const char*,const char*,ulint)"
"trx_commit_for_mysql(trx_t*)" -> "abort()"
"trx_commit_for_mysql(trx_t*)" -> "trx_commit(trx_t*)"
"trx_commit_for_mysql(trx_t*)" -> "__builtin_expect(long int,long int)"
"trx_commit_for_mysql(trx_t*)" -> "trx_start_low(trx_t*)"
"trx_commit_for_mysql(trx_t*)" -> "thd_supports_xa(THD*)"
"trx_commit(trx_t*)" -> "mtr_start(mtr_t*)"
"trx_commit(trx_t*)" -> "trx_commit_low(trx_t*,mtr_t*)"
"mtr_start(mtr_t*)" -> "dyn_array_create(dyn_array_t*)"
"trx_commit_low(trx_t*,mtr_t*)" -> "ut_dbg_assertion_failed(const char*,const char*,ulint)"
"trx_commit_low(trx_t*,mtr_t*)" -> "abort()"
"trx_commit_low(trx_t*,mtr_t*)" -> "trx_write_serialisation_history(trx_t*,mtr_t*)"
"trx_commit_low(trx_t*,mtr_t*)" -> "trx_commit_in_memory(trx_t*,lsn_t)"
"trx_commit_low(trx_t*,mtr_t*)" -> "__builtin_expect(long int,long int)"
"trx_commit_low(trx_t*,mtr_t*)" -> "fts_commit(trx_t*)"
"trx_commit_low(trx_t*,mtr_t*)" -> "mtr_commit(mtr_t*)"
"trx_write_serialisation_history(trx_t*,mtr_t*)" -> "pfs_mutex_exit_func(ib_mutex_t*)"
"trx_write_serialisation_history(trx_t*,mtr_t*)" -> "trx_undo_update_cleanup(trx_t*,ib_page_t*,mtr_t*)"
"trx_write_serialisation_history(trx_t*,mtr_t*)" -> "pfs_mutex_enter_func(ib_mutex_t*,const char*,ulint)"
"trx_write_serialisation_history(trx_t*,mtr_t*)" -> "trx_serialisation_number_get(trx_t*)"
"trx_write_serialisation_history(trx_t*,mtr_t*)" -> "trx_undo_set_state_at_finish(trx_undo_t*,mtr_t*)"
"trx_write_serialisation_history(trx_t*,mtr_t*)" -> "trx_sys_update_mysql_binlog_offset(const char*,ib_int64_t,ulint,mtr_t*)"
"trx_undo_update_cleanup(trx_t*,ib_page_t*,mtr_t*)" -> "ut_list_remove(List&,Type&,size_t) [with List = ut_list_base<trx_undo_t>,Type = trx_undo_t,size_t = long unsigned int]"
"trx_undo_update_cleanup(trx_t*,ib_page_t*,mtr_t*)" -> "ut_list_prepend(List&,Type&,size_t) [with List = ut_list_base<trx_undo_t>,Type = trx_undo_t,size_t = long unsigned int]"
"trx_undo_update_cleanup(trx_t*,ib_page_t*,mtr_t*)" -> "trx_purge_add_update_undo_to_history(trx_t*,ib_page_t*,mtr_t*)"
"trx_undo_update_cleanup(trx_t*,ib_page_t*,mtr_t*)" -> "trx_undo_mem_free(trx_undo_t*)"
"ut_list_remove(List&,Type&,size_t) [with List = ut_list_base<trx_undo_t>,Type = trx_undo_t,size_t = long unsigned int]" -> "ut_elem_get_node(Type&,size_t) [with Type = trx_undo_t,size_t = long unsigned int]"
"ut_list_remove(List&,Type&,size_t) [with List = ut_list_base<trx_undo_t>,Type = trx_undo_t,size_t = long unsigned int]" -> "ut_dbg_assertion_failed(const char*,const char*,ulint)"
"ut_list_remove(List&,Type&,size_t) [with List = ut_list_base<trx_undo_t>,Type = trx_undo_t,size_t = long unsigned int]" -> "abort()"
"ut_list_remove(List&,Type&,size_t) [with List = ut_list_base<trx_undo_t>,Type = trx_undo_t,size_t = long unsigned int]" -> "__builtin_expect(long int,long int)"
"ut_elem_get_node(Type&,size_t) [with Type = trx_undo_t,size_t = long unsigned int]" -> "abort()"
"ut_elem_get_node(Type&,size_t) [with Type = trx_undo_t,size_t = long unsigned int]" -> "ut_dbg_assertion_failed(const char*,const char*,ulint)"
"ut_elem_get_node(Type&,size_t) [with Type = trx_undo_t,size_t = long unsigned int]" -> "__builtin_expect(long int,long int)"
"ut_list_prepend(List&,Type&,size_t) [with List = ut_list_base<trx_undo_t>,Type = trx_undo_t,size_t = long unsigned int]" -> "ut_elem_get_node(Type&,size_t) [with Type = trx_undo_t,size_t = long unsigned int]"
"trx_purge_add_update_undo_to_history(trx_t*,ib_page_t*,mtr_t*)" -> "trx_rsegf_get(ulint,ulint,ulint,mtr_t*)"
"trx_purge_add_update_undo_to_history(trx_t*,ib_page_t*,mtr_t*)" -> "__builtin_expect(long int,long int)"
"trx_purge_add_update_undo_to_history(trx_t*,ib_page_t*,mtr_t*)" -> "fprintf(FILE*,const char*,...)"
"trx_purge_add_update_undo_to_history(trx_t*,ib_page_t*,mtr_t*)" -> "mlog_write_ulint(unsigned char*,ulint,unsigned char,mtr_t*)"
"trx_purge_add_update_undo_to_history(trx_t*,ib_page_t*,mtr_t*)" -> "trx_rsegf_set_nth_undo(trx_rsegf_t*,ulint,ulint,mtr_t*)"
"trx_purge_add_update_undo_to_history(trx_t*,ib_page_t*,mtr_t*)" -> "mlog_write_ull(unsigned char*,ib_uint64_t,mtr_t*)"
"trx_purge_add_update_undo_to_history(trx_t*,ib_page_t*,mtr_t*)" -> "flst_add_first(flst_base_node_t*,flst_node_t*,mtr_t*)"
"trx_purge_add_update_undo_to_history(trx_t*,ib_page_t*,mtr_t*)" -> "__sync_add_and_fetch_8(volatile void*,long unsigned int)"
"trx_purge_add_update_undo_to_history(trx_t*,ib_page_t*,mtr_t*)" -> "mtr_read_ulint(const unsigned char*,ulint,mtr_t*)"
"trx_purge_add_update_undo_to_history(trx_t*,ib_page_t*,mtr_t*)" -> "srv_wake_purge_thread_if_not_active()"
"trx_purge_add_update_undo_to_history(trx_t*,ib_page_t*,mtr_t*)" -> "abort()"
"trx_purge_add_update_undo_to_history(trx_t*,ib_page_t*,mtr_t*)" -> "ut_dbg_assertion_failed(const char*,const char*,ulint)"
"trx_rsegf_get(ulint,ulint,ulint,mtr_t*)" -> "buf_page_get_gen(ulint,ulint,ulint,ulint,buf_block_t*,ulint,const char*,ulint,mtr_t*)"
"mlog_write_ulint(unsigned char*,ulint,unsigned char,mtr_t*)" -> "mach_write_to_2(unsigned char*,ulint)"
"mlog_write_ulint(unsigned char*,ulint,unsigned char,mtr_t*)" -> "page_offset(const void*)"
"mlog_write_ulint(unsigned char*,ulint,unsigned char,mtr_t*)" -> "mach_write_to_4(unsigned char*,ulint)"
"mlog_write_ulint(unsigned char*,ulint,unsigned char,mtr_t*)" -> "mach_write_compressed(unsigned char*,ulint)"
"mlog_write_ulint(unsigned char*,ulint,unsigned char,mtr_t*)" -> "mlog_close(mtr_t*,unsigned char*)"
"mlog_write_ulint(unsigned char*,ulint,unsigned char,mtr_t*)" -> "ut_dbg_assertion_failed(const char*,const char*,ulint)"
"mlog_write_ulint(unsigned char*,ulint,unsigned char,mtr_t*)" -> "mlog_open(mtr_t*,ulint)"
"mlog_write_ulint(unsigned char*,ulint,unsigned char,mtr_t*)" -> "mach_write_to_1(unsigned char*,ulint)"
"mlog_write_ulint(unsigned char*,ulint,unsigned char,mtr_t*)" -> "abort()"
"mlog_write_ulint(unsigned char*,ulint,unsigned char,mtr_t*)" -> "mlog_write_initial_log_record_fast(const unsigned char*,unsigned char,unsigned char*,mtr_t*)"
"trx_rsegf_set_nth_undo(trx_rsegf_t*,ulint,ulint,mtr_t*)" -> "ut_dbg_assertion_failed(const char*,const char*,ulint)"
"trx_rsegf_set_nth_undo(trx_rsegf_t*,ulint,ulint,mtr_t*)" -> "abort()"
"trx_rsegf_set_nth_undo(trx_rsegf_t*,ulint,ulint,mtr_t*)" -> "mlog_write_ulint(unsigned char*,ulint,unsigned char,mtr_t*)"
"trx_rsegf_set_nth_undo(trx_rsegf_t*,ulint,ulint,mtr_t*)" -> "fprintf(FILE*,const char*,...)"
"flst_add_first(flst_base_node_t*,flst_node_t*,mtr_t*)" -> "flst_get_len(const flst_base_node_t*,mtr_t*)"
"flst_add_first(flst_base_node_t*,flst_node_t*,mtr_t*)" -> "buf_ptr_get_fsp_addr(const void*,ulint*,fil_addr_t*)"
"flst_add_first(flst_base_node_t*,flst_node_t*,mtr_t*)" -> "flst_add_to_empty(flst_base_node_t*,flst_node_t*,mtr_t*)"
"flst_add_first(flst_base_node_t*,flst_node_t*,mtr_t*)" -> "fil_space_get_zip_size(ulint)"
"flst_add_first(flst_base_node_t*,flst_node_t*,mtr_t*)" -> "page_align(const void*)"
"flst_add_first(flst_base_node_t*,flst_node_t*,mtr_t*)" -> "flst_insert_before(flst_base_node_t*,flst_node_t*,flst_node_t*,mtr_t*)"
"flst_add_first(flst_base_node_t*,flst_node_t*,mtr_t*)" -> "fut_get_ptr(ulint,ulint,fil_addr_t,ulint,mtr_t*)"
"flst_add_first(flst_base_node_t*,flst_node_t*,mtr_t*)" -> "flst_get_first(const flst_base_node_t*,mtr_t*)"
"flst_get_len(const flst_base_node_t*,mtr_t*)" -> "mtr_read_ulint(const unsigned char*,ulint,mtr_t*)"
"mtr_read_ulint(const unsigned char*,ulint,mtr_t*)" -> "mach_read_ulint(const unsigned char*,ulint)"
"mach_read_ulint(const unsigned char*,ulint)" -> "mach_read_from_2(const unsigned char*)"
"mach_read_ulint(const unsigned char*,ulint)" -> "ut_dbg_assertion_failed(const char*,const char*,ulint)"
"mach_read_ulint(const unsigned char*,ulint)" -> "mach_read_from_4(const unsigned char*)"
"mach_read_ulint(const unsigned char*,ulint)" -> "abort()"
"mach_read_ulint(const unsigned char*,ulint)" -> "mach_read_from_1(const unsigned char*)"
"buf_ptr_get_fsp_addr(const void*,ulint*,fil_addr_t*)" -> "mach_read_from_4(const unsigned char*)"
"buf_ptr_get_fsp_addr(const void*,ulint*,fil_addr_t*)" -> "ut_align_down(const void*,ulint)"
"buf_ptr_get_fsp_addr(const void*,ulint*,fil_addr_t*)" -> "ut_align_offset(const void*,ulint)"
"flst_add_to_empty(flst_base_node_t*,flst_node_t*,mtr_t*)" -> "abort()"
"flst_add_to_empty(flst_base_node_t*,flst_node_t*,mtr_t*)" -> "flst_write_addr(fil_faddr_t*,fil_addr_t,mtr_t*)"
"flst_add_to_empty(flst_base_node_t*,flst_node_t*,mtr_t*)" -> "mlog_write_ulint(unsigned char*,ulint,unsigned char,mtr_t*)"
"flst_add_to_empty(flst_base_node_t*,flst_node_t*,mtr_t*)" -> "__builtin_expect(long int,long int)"
"flst_add_to_empty(flst_base_node_t*,flst_node_t*,mtr_t*)" -> "ut_dbg_assertion_failed(const char*,const char*,ulint)"
"flst_add_to_empty(flst_base_node_t*,flst_node_t*,mtr_t*)" -> "buf_ptr_get_fsp_addr(const void*,ulint*,fil_addr_t*)"
"flst_add_to_empty(flst_base_node_t*,flst_node_t*,mtr_t*)" -> "flst_get_len(const flst_base_node_t*,mtr_t*)"
"flst_write_addr(fil_faddr_t*,fil_addr_t,mtr_t*)" -> "ut_align_offset(const void*,ulint)"
"flst_write_addr(fil_faddr_t*,fil_addr_t,mtr_t*)" -> "ut_dbg_assertion_failed(const char*,const char*,ulint)"
"flst_write_addr(fil_faddr_t*,fil_addr_t,mtr_t*)" -> "mlog_write_ulint(unsigned char*,ulint,unsigned char,mtr_t*)"
"flst_write_addr(fil_faddr_t*,fil_addr_t,mtr_t*)" -> "abort()"
"flst_write_addr(fil_faddr_t*,fil_addr_t,mtr_t*)" -> "__builtin_expect(long int,long int)"
"fil_space_get_zip_size(ulint)" -> "fil_space_get_flags(ulint)"
"fil_space_get_zip_size(ulint)" -> "fsp_flags_get_zip_size(ulint)"
"fil_space_get_flags(ulint)" -> "pfs_mutex_exit_func(ib_mutex_t*)"
"fil_space_get_flags(ulint)" -> "fil_space_get_space(ulint)"
"fil_space_get_flags(ulint)" -> "pfs_mutex_enter_func(ib_mutex_t*,const char*,ulint)"
"fil_space_get_space(ulint)" -> "fil_node_prepare_for_io(fil_node_t*,fil_system_t*,fil_space_t*)"
"fil_space_get_space(ulint)" -> "fil_node_complete_io(fil_node_t*,fil_system_t*,ulint)"
"fil_space_get_space(ulint)" -> "fil_mutex_enter_and_prepare_for_io(ulint)"
"fil_space_get_space(ulint)" -> "ut_dbg_assertion_failed(const char*,const char*,ulint)"
"fil_space_get_space(ulint)" -> "pfs_mutex_exit_func(ib_mutex_t*)"
"fil_space_get_space(ulint)" -> "fil_space_get_by_id(ulint)"
"fil_space_get_space(ulint)" -> "abort()"
"fil_space_get_space(ulint)" -> "__builtin_expect(long int,long int)"
"fil_node_prepare_for_io(fil_node_t*,fil_system_t*,fil_space_t*)" -> "fprintf(FILE*,const char*,...)"
"fil_node_prepare_for_io(fil_node_t*,fil_system_t*,fil_space_t*)" -> "ut_list_remove(List&,Type&,size_t) [with List = ut_list_base<fil_node_t>,Type = fil_node_t,size_t = long unsigned int]"
"fil_node_prepare_for_io(fil_node_t*,fil_system_t*,fil_space_t*)" -> "ut_dbg_assertion_failed(const char*,const char*,ulint)"
"fil_node_prepare_for_io(fil_node_t*,fil_system_t*,fil_space_t*)" -> "__builtin_expect(long int,long int)"
"fil_node_prepare_for_io(fil_node_t*,fil_system_t*,fil_space_t*)" -> "fil_node_open_file(fil_node_t*,fil_system_t*,fil_space_t*)"
"fil_node_prepare_for_io(fil_node_t*,fil_system_t*,fil_space_t*)" -> "ut_print_timestamp(FILE*)"
"fil_node_prepare_for_io(fil_node_t*,fil_system_t*,fil_space_t*)" -> "abort()"
"fil_node_prepare_for_io(fil_node_t*,fil_system_t*,fil_space_t*)" -> "fil_space_belongs_in_lru(const fil_space_t*)"
"ut_list_remove(List&,Type&,size_t) [with List = ut_list_base<fil_node_t>,Type = fil_node_t,size_t = long unsigned int]" -> "abort()"
"ut_list_remove(List&,Type&,size_t) [with List = ut_list_base<fil_node_t>,Type = fil_node_t,size_t = long unsigned int]" -> "ut_dbg_assertion_failed(const char*,const char*,ulint)"
"ut_list_remove(List&,Type&,size_t) [with List = ut_list_base<fil_node_t>,Type = fil_node_t,size_t = long unsigned int]" -> "ut_elem_get_node(Type&,size_t) [with Type = fil_node_t,size_t = long unsigned int]"
"ut_list_remove(List&,Type&,size_t) [with List = ut_list_base<fil_node_t>,Type = fil_node_t,size_t = long unsigned int]" -> "__builtin_expect(long int,long int)"
"fil_node_open_file(fil_node_t*,fil_system_t*,fil_space_t*)" -> "fprintf(FILE*,const char*,...)"
"fil_node_open_file(fil_node_t*,fil_system_t*,fil_space_t*)" -> "__builtin_expect(long int,long int)"
"fil_node_open_file(fil_node_t*,fil_system_t*,fil_space_t*)" -> "fsp_header_get_flags(const ib_page_t*)"
"fil_node_open_file(fil_node_t*,fil_system_t*,fil_space_t*)" -> "abort()"
"fil_node_open_file(fil_node_t*,fil_system_t*,fil_space_t*)" -> "ut_free(void*)"
"fil_node_open_file(fil_node_t*,fil_system_t*,fil_space_t*)" -> "ut_print_timestamp(FILE*)"
"fil_node_open_file(fil_node_t*,fil_system_t*,fil_space_t*)" -> "ut_dbg_assertion_failed(const char*,const char*,ulint)"
"fil_node_open_file(fil_node_t*,fil_system_t*,fil_space_t*)" -> "fsp_flags_get_zip_size(ulint)"
"fil_node_open_file(fil_node_t*,fil_system_t*,fil_space_t*)" -> "fsp_flags_is_compressed(ulint)"
"fil_node_open_file(fil_node_t*,fil_system_t*,fil_space_t*)" -> "fsp_flags_get_page_size(ulint)"
"fil_node_open_file(fil_node_t*,fil_system_t*,fil_space_t*)" -> "os_file_get_size(os_file_t)"
"fil_node_open_file(fil_node_t*,fil_system_t*,fil_space_t*)" -> "ib_logf(ib_log_level_t,const char*,...)"
"fil_node_open_file(fil_node_t*,fil_system_t*,fil_space_t*)" -> "pfs_os_file_read_func(os_file_t,void*,os_offset_t,ulint,const char*,ulint)"
"fil_node_open_file(fil_node_t*,fil_system_t*,fil_space_t*)" -> "ut_list_prepend(List&,Type&,size_t) [with List = ut_list_base<fil_node_t>,Type = fil_node_t,size_t = long unsigned int]"
"fil_node_open_file(fil_node_t*,fil_system_t*,fil_space_t*)" -> "fil_space_belongs_in_lru(const fil_space_t*)"
"fil_node_open_file(fil_node_t*,fil_system_t*,fil_space_t*)" -> "os_file_get_last_error(bool)"
"fil_node_open_file(fil_node_t*,fil_system_t*,fil_space_t*)" -> "pfs_os_file_create_simple_no_error_handling_func(mysql_pfs_key_t,const char*,ulint,ulint,ulint*,const char*,ulint)"
"fil_node_open_file(fil_node_t*,fil_system_t*,fil_space_t*)" -> "ut_malloc_low(ulint,ulint)"
"fil_node_open_file(fil_node_t*,fil_system_t*,fil_space_t*)" -> "pfs_os_file_close_func(os_file_t,const char*,ulint)"
"fil_node_open_file(fil_node_t*,fil_system_t*,fil_space_t*)" -> "ut_align(const void*,ulint)"
"fil_node_open_file(fil_node_t*,fil_system_t*,fil_space_t*)" -> "pfs_os_file_create_func(mysql_pfs_key_t,const char*,ulint,ulint,ulint,ulint*,const char*,ulint)"
"fil_node_open_file(fil_node_t*,fil_system_t*,fil_space_t*)" -> "fsp_header_get_space_id(const ib_page_t*)"
"fsp_header_get_flags(const ib_page_t*)" -> "mach_read_from_4(const unsigned char*)"
"fsp_flags_get_zip_size(ulint)" -> "__assert_fail(const char*,const char*,unsigned int,const char*)"
"fsp_flags_get_page_size(ulint)" -> "__assert_fail(const char*,const char*,unsigned int,const char*)"
"fsp_flags_get_page_size(ulint)" -> "__builtin_expect(long int,long int)"
"os_file_get_size(os_file_t)" -> "lseek(int,__off64_t,int)"
"pfs_os_file_read_func(os_file_t,void*,os_offset_t,ulint,const char*,ulint)" -> "os_file_read_func(os_file_t,void*,os_offset_t,ulint)"
"pfs_os_file_read_func(os_file_t,void*,os_offset_t,ulint,const char*,ulint)" -> "__builtin_expect(long int,long int)"
"os_file_read_func(os_file_t,void*,os_offset_t,ulint)" -> "fflush(FILE*)"
"os_file_read_func(os_file_t,void*,os_offset_t,ulint)" -> "ut_dbg_assertion_failed(const char*,const char*,ulint)"
"os_file_read_func(os_file_t,void*,os_offset_t,ulint)" -> "os_file_handle_error(const char*,const char*)"
"os_file_read_func(os_file_t,void*,os_offset_t,ulint)" -> "abort()"
"os_file_read_func(os_file_t,void*,os_offset_t,ulint)" -> "__errno_location()"
"os_file_read_func(os_file_t,void*,os_offset_t,ulint)" -> "ib_logf(ib_log_level_t,const char*,...)"
"os_file_read_func(os_file_t,void*,os_offset_t,ulint)" -> "fprintf(FILE*,const char*,...)"
"os_file_read_func(os_file_t,void*,os_offset_t,ulint)" -> "os_file_pread(os_file_t,void*,ulint,os_offset_t)"
"os_file_pread(os_file_t,void*,ulint,os_offset_t)" -> "__sync_sub_and_fetch_8(volatile void*,long unsigned int)"
"os_file_pread(os_file_t,void*,ulint,os_offset_t)" -> "__sync_add_and_fetch_8(volatile void*,long unsigned int)"
"os_file_pread(os_file_t,void*,ulint,os_offset_t)" -> "pread(int,void*,size_t,__off64_t)"
"os_file_get_last_error(bool)" -> "os_file_get_last_error_low(bool,bool)"
"pfs_os_file_create_simple_no_error_handling_func(mysql_pfs_key_t,const char*,ulint,ulint,ulint*,const char*,ulint)" -> "__builtin_expect(long int,long int)"
"pfs_os_file_create_simple_no_error_handling_func(mysql_pfs_key_t,const char*,ulint,ulint,ulint*,const char*,ulint)" -> "os_file_create_simple_no_error_handling_func(const char*,ulint,ulint,ulint*)"
"os_file_create_simple_no_error_handling_func(const char*,ulint,ulint,ulint*)" -> "os_file_lock(int,const char*)"
"os_file_create_simple_no_error_handling_func(const char*,ulint,ulint,ulint*)" -> "open(const char*,int,...)"
"os_file_create_simple_no_error_handling_func(const char*,ulint,ulint,ulint*)" -> "ut_dbg_assertion_failed(const char*,const char*,ulint)"
"os_file_create_simple_no_error_handling_func(const char*,ulint,ulint,ulint*)" -> "close(int)"
"os_file_create_simple_no_error_handling_func(const char*,ulint,ulint,ulint*)" -> "__builtin_expect(long int,long int)"
"os_file_create_simple_no_error_handling_func(const char*,ulint,ulint,ulint*)" -> "abort()"
"os_file_create_simple_no_error_handling_func(const char*,ulint,ulint,ulint*)" -> "ib_logf(ib_log_level_t,const char*,...)"
"os_file_lock(int,const char*)" -> "__errno_location()"
"os_file_lock(int,const char*)" -> "ib_logf(ib_log_level_t,const char*,...)"
"os_file_lock(int,const char*)" -> "fcntl(int,int,...)"
"pfs_os_file_close_func(os_file_t,const char*,ulint)" -> "__builtin_expect(long int,long int)"
"pfs_os_file_close_func(os_file_t,const char*,ulint)" -> "os_file_close_func(os_file_t)"
"os_file_close_func(os_file_t)" -> "close(int)"
"os_file_close_func(os_file_t)" -> "os_file_handle_error(const char*,const char*)"
"pfs_os_file_create_func(mysql_pfs_key_t,const char*,ulint,ulint,ulint,ulint*,const char*,ulint)" -> "__builtin_expect(long int,long int)"
"pfs_os_file_create_func(mysql_pfs_key_t,const char*,ulint,ulint,ulint,ulint*,const char*,ulint)" -> "os_file_create_func(const char*,ulint,ulint,ulint,ulint*)"
"os_file_create_func(const char*,ulint,ulint,ulint,ulint*)" -> "close(int)"
"os_file_create_func(const char*,ulint,ulint,ulint,ulint*)" -> "open(const char*,int,...)"
"os_file_create_func(const char*,ulint,ulint,ulint,ulint*)" -> "os_file_lock(int,const char*)"
"os_file_create_func(const char*,ulint,ulint,ulint,ulint*)" -> "ib_logf(ib_log_level_t,const char*,...)"
"os_file_create_func(const char*,ulint,ulint,ulint,ulint*)" -> "ut_dbg_assertion_failed(const char*,const char*,ulint)"
"os_file_create_func(const char*,ulint,ulint,ulint,ulint*)" -> "abort()"
"os_file_create_func(const char*,ulint,ulint,ulint,ulint*)" -> "__builtin_expect(long int,long int)"
"os_file_create_func(const char*,ulint,ulint,ulint,ulint*)" -> "os_file_handle_error(const char*,const char*)"
"os_file_create_func(const char*,ulint,ulint,ulint,ulint*)" -> "os_thread_sleep(ulint)"
"os_file_create_func(const char*,ulint,ulint,ulint,ulint*)" -> "os_file_handle_error_no_exit(const char*,const char*,ulint)"
"os_file_create_func(const char*,ulint,ulint,ulint,ulint*)" -> "os_file_set_nocache(int,const char*,const char*)"
"os_file_handle_error_no_exit(const char*,const char*,ulint)" -> "os_file_handle_error_cond_exit(const char*,const char*,ulint,ulint)"
"os_file_set_nocache(int,const char*,const char*)" -> "fcntl(int,int,...)"
"os_file_set_nocache(int,const char*,const char*)" -> "ib_logf(ib_log_level_t,const char*,...)"
"os_file_set_nocache(int,const char*,const char*)" -> "__errno_location()"
"os_file_set_nocache(int,const char*,const char*)" -> "strerror(int)"
"fsp_header_get_space_id(const ib_page_t*)" -> "mach_read_from_4(const unsigned char*)"
"fsp_header_get_space_id(const ib_page_t*)" -> "ib_logf(ib_log_level_t,const char*,...)"
"fil_mutex_enter_and_prepare_for_io(ulint)" -> "__builtin_fwrite(const void*,size_t,size_t,FILE*)"
"fil_mutex_enter_and_prepare_for_io(ulint)" -> "fil_flush_file_spaces(ulint)"
"fil_mutex_enter_and_prepare_for_io(ulint)" -> "os_aio_simulated_wake_handler_threads()"
"fil_mutex_enter_and_prepare_for_io(ulint)" -> "ut_print_timestamp(FILE*)"
"fil_mutex_enter_and_prepare_for_io(ulint)" -> "fil_space_get_by_id(ulint)"
"fil_mutex_enter_and_prepare_for_io(ulint)" -> "fprintf(FILE*,const char*,...)"
"fil_mutex_enter_and_prepare_for_io(ulint)" -> "fil_try_to_close_file_in_LRU(ulint)"
"fil_mutex_enter_and_prepare_for_io(ulint)" -> "ut_print_filename(FILE*,const char*)"
"fil_mutex_enter_and_prepare_for_io(ulint)" -> "os_thread_sleep(ulint)"
"fil_mutex_enter_and_prepare_for_io(ulint)" -> "pfs_mutex_enter_func(ib_mutex_t*,const char*,ulint)"
"fil_mutex_enter_and_prepare_for_io(ulint)" -> "pfs_mutex_exit_func(ib_mutex_t*)"
"fil_flush_file_spaces(ulint)" -> "fil_flush(ulint)"
"fil_flush_file_spaces(ulint)" -> "mem_alloc_func(ulint,ulint*)"
"fil_flush_file_spaces(ulint)" -> "pfs_mutex_enter_func(ib_mutex_t*,const char*,ulint)"
"fil_flush_file_spaces(ulint)" -> "pfs_mutex_exit_func(ib_mutex_t*)"
"fil_flush_file_spaces(ulint)" -> "mem_free_func(void*,const char*,ulint)"
"fil_try_to_close_file_in_LRU(ulint)" -> "fil_node_close_file(fil_node_t*,fil_system_t*)"
"fil_try_to_close_file_in_LRU(ulint)" -> "ut_print_filename(FILE*,const char*)"
"fil_try_to_close_file_in_LRU(ulint)" -> "__builtin_fwrite(const void*,size_t,size_t,FILE*)"
"fil_try_to_close_file_in_LRU(ulint)" -> "fprintf(FILE*,const char*,...)"
"fil_node_close_file(fil_node_t*,fil_system_t*)" -> "pfs_os_file_close_func(os_file_t,const char*,ulint)"
"fil_node_close_file(fil_node_t*,fil_system_t*)" -> "__builtin_expect(long int,long int)"
"fil_node_close_file(fil_node_t*,fil_system_t*)" -> "abort()"
"fil_node_close_file(fil_node_t*,fil_system_t*)" -> "fil_space_belongs_in_lru(const fil_space_t*)"
"fil_node_close_file(fil_node_t*,fil_system_t*)" -> "ut_list_remove(List&,Type&,size_t) [with List = ut_list_base<fil_node_t>,Type = fil_node_t,size_t = long unsigned int]"
"fil_node_close_file(fil_node_t*,fil_system_t*)" -> "ut_dbg_assertion_failed(const char*,const char*,ulint)"
"flst_insert_before(flst_base_node_t*,flst_node_t*,flst_node_t*,mtr_t*)" -> "flst_get_len(const flst_base_node_t*,mtr_t*)"
"flst_insert_before(flst_base_node_t*,flst_node_t*,flst_node_t*,mtr_t*)" -> "flst_get_prev_addr(const flst_node_t*,mtr_t*)"
"flst_insert_before(flst_base_node_t*,flst_node_t*,flst_node_t*,mtr_t*)" -> "mlog_write_ulint(unsigned char*,ulint,unsigned char,mtr_t*)"
"flst_insert_before(flst_base_node_t*,flst_node_t*,flst_node_t*,mtr_t*)" -> "fut_get_ptr(ulint,ulint,fil_addr_t,ulint,mtr_t*)"
"flst_insert_before(flst_base_node_t*,flst_node_t*,flst_node_t*,mtr_t*)" -> "fil_space_get_zip_size(ulint)"
"flst_insert_before(flst_base_node_t*,flst_node_t*,flst_node_t*,mtr_t*)" -> "buf_ptr_get_fsp_addr(const void*,ulint*,fil_addr_t*)"
"flst_insert_before(flst_base_node_t*,flst_node_t*,flst_node_t*,mtr_t*)" -> "flst_write_addr(fil_faddr_t*,fil_addr_t,mtr_t*)"
"flst_insert_before(flst_base_node_t*,flst_node_t*,flst_node_t*,mtr_t*)" -> "fil_addr_is_null(fil_addr_t)"
"flst_get_prev_addr(const flst_node_t*,mtr_t*)" -> "flst_read_addr(const fil_faddr_t*,mtr_t*)"
"flst_read_addr(const fil_faddr_t*,mtr_t*)" -> "__builtin_expect(long int,long int)"
"flst_read_addr(const fil_faddr_t*,mtr_t*)" -> "ut_align_offset(const void*,ulint)"
"flst_read_addr(const fil_faddr_t*,mtr_t*)" -> "mtr_read_ulint(const unsigned char*,ulint,mtr_t*)"
"flst_read_addr(const fil_faddr_t*,mtr_t*)" -> "ut_dbg_assertion_failed(const char*,const char*,ulint)"
"flst_read_addr(const fil_faddr_t*,mtr_t*)" -> "abort()"
"fut_get_ptr(ulint,ulint,fil_addr_t,ulint,mtr_t*)" -> "buf_page_get_gen(ulint,ulint,ulint,ulint,buf_block_t*,ulint,const char*,ulint,mtr_t*)"
"flst_get_first(const flst_base_node_t*,mtr_t*)" -> "flst_read_addr(const fil_faddr_t*,mtr_t*)"
"srv_wake_purge_thread_if_not_active()" -> "srv_release_threads(srv_thread_type,ulint)"
"srv_release_threads(srv_thread_type,ulint)" -> "pfs_mutex_enter_func(ib_mutex_t*,const char*,ulint)"
"srv_release_threads(srv_thread_type,ulint)" -> "ut_dbg_assertion_failed(const char*,const char*,ulint)"
"srv_release_threads(srv_thread_type,ulint)" -> "srv_slot_get_type(const srv_slot_t*)"
"srv_release_threads(srv_thread_type,ulint)" -> "os_event_set(os_event_t)"
"srv_release_threads(srv_thread_type,ulint)" -> "abort()"
"srv_release_threads(srv_thread_type,ulint)" -> "pfs_mutex_exit_func(ib_mutex_t*)"
"srv_release_threads(srv_thread_type,ulint)" -> "__builtin_expect(long int,long int)"
"trx_undo_mem_free(trx_undo_t*)" -> "ut_dbg_assertion_failed(const char*,const char*,ulint)"
"trx_undo_mem_free(trx_undo_t*)" -> "abort()"
"trx_undo_mem_free(trx_undo_t*)" -> "mem_free_func(void*,const char*,ulint)"
"trx_undo_mem_free(trx_undo_t*)" -> "fprintf(FILE*,const char*,...)"
"trx_serialisation_number_get(trx_t*)" -> "ut_dbg_assertion_failed(const char*,const char*,ulint)"
"trx_serialisation_number_get(trx_t*)" -> "pfs_mutex_enter_func(ib_mutex_t*,const char*,ulint)"
"trx_serialisation_number_get(trx_t*)" -> "__builtin_expect(long int,long int)"
"trx_serialisation_number_get(trx_t*)" -> "trx_sys_get_new_trx_id()"
"trx_serialisation_number_get(trx_t*)" -> "pfs_mutex_exit_func(ib_mutex_t*)"
"trx_serialisation_number_get(trx_t*)" -> "ib_bh_push(ib_bh_t*,const void*)"
"trx_serialisation_number_get(trx_t*)" -> "abort()"
"trx_sys_get_new_trx_id()" -> "trx_sys_flush_max_trx_id()"
"trx_sys_flush_max_trx_id()" -> "mtr_commit(mtr_t*)"
"trx_sys_flush_max_trx_id()" -> "mtr_start(mtr_t*)"
"trx_sys_flush_max_trx_id()" -> "mlog_write_ull(unsigned char*,ib_uint64_t,mtr_t*)"
"trx_sys_flush_max_trx_id()" -> "trx_sysf_get(mtr_t*)"
"trx_sysf_get(mtr_t*)" -> "buf_page_get_gen(ulint,ulint,ulint,ulint,buf_block_t*,ulint,const char*,ulint,mtr_t*)"
"ib_bh_push(ib_bh_t*,const void*)" -> "ib_bh_get(ib_bh_t*,ulint)"
"ib_bh_push(ib_bh_t*,const void*)" -> "ib_bh_is_full(const ib_bh_t*)"
"ib_bh_push(ib_bh_t*,const void*)" -> "ib_bh_set(ib_bh_t*,ulint,const void*)"
"ib_bh_push(ib_bh_t*,const void*)" -> "ib_bh_is_empty(const ib_bh_t*)"
"ib_bh_get(ib_bh_t*,ulint)" -> "__builtin_expect(long int,long int)"
"ib_bh_get(ib_bh_t*,ulint)" -> "abort()"
"ib_bh_get(ib_bh_t*,ulint)" -> "ut_dbg_assertion_failed(const char*,const char*,ulint)"
"ib_bh_get(ib_bh_t*,ulint)" -> "ib_bh_size(const ib_bh_t*)"
"ib_bh_is_full(const ib_bh_t*)" -> "ib_bh_size(const ib_bh_t*)"
"ib_bh_set(ib_bh_t*,ulint,const void*)" -> "ib_bh_get(ib_bh_t*,ulint)"
"ib_bh_set(ib_bh_t*,ulint,const void*)" -> "ut_memcpy(void*,const void*,ulint)"
"ib_bh_is_empty(const ib_bh_t*)" -> "ib_bh_size(const ib_bh_t*)"
"trx_undo_set_state_at_finish(trx_undo_t*,mtr_t*)" -> "trx_undo_page_get(ulint,ulint,ulint,mtr_t*)"
"trx_undo_set_state_at_finish(trx_undo_t*,mtr_t*)" -> "mach_read_from_2(const unsigned char*)"
"trx_undo_set_state_at_finish(trx_undo_t*,mtr_t*)" -> "ut_dbg_assertion_failed(const char*,const char*,ulint)"
"trx_undo_set_state_at_finish(trx_undo_t*,mtr_t*)" -> "fprintf(FILE*,const char*,...)"
"trx_undo_set_state_at_finish(trx_undo_t*,mtr_t*)" -> "mlog_write_ulint(unsigned char*,ulint,unsigned char,mtr_t*)"
"trx_undo_set_state_at_finish(trx_undo_t*,mtr_t*)" -> "mem_analyze_corruption(void*)"
"trx_undo_set_state_at_finish(trx_undo_t*,mtr_t*)" -> "abort()"
"trx_undo_page_get(ulint,ulint,ulint,mtr_t*)" -> "buf_page_get_gen(ulint,ulint,ulint,ulint,buf_block_t*,ulint,const char*,ulint,mtr_t*)"
"trx_sys_update_mysql_binlog_offset(const char*,ib_int64_t,ulint,mtr_t*)" -> "ut_strlen(const char*)"
"trx_sys_update_mysql_binlog_offset(const char*,ib_int64_t,ulint,mtr_t*)" -> "mlog_write_string(unsigned char*,const unsigned char*,ulint,mtr_t*)"
"trx_sys_update_mysql_binlog_offset(const char*,ib_int64_t,ulint,mtr_t*)" -> "strcmp(const char*,const char*)"
"trx_sys_update_mysql_binlog_offset(const char*,ib_int64_t,ulint,mtr_t*)" -> "mlog_write_ulint(unsigned char*,ulint,unsigned char,mtr_t*)"
"trx_sys_update_mysql_binlog_offset(const char*,ib_int64_t,ulint,mtr_t*)" -> "trx_sysf_get(mtr_t*)"
"trx_sys_update_mysql_binlog_offset(const char*,ib_int64_t,ulint,mtr_t*)" -> "mach_read_from_4(const unsigned char*)"
"ut_strlen(const char*)" -> "strlen(const char*)"
"mlog_write_string(unsigned char*,const unsigned char*,ulint,mtr_t*)" -> "abort()"
"mlog_write_string(unsigned char*,const unsigned char*,ulint,mtr_t*)" -> "mlog_log_string(unsigned char*,ulint,mtr_t*)"
"mlog_write_string(unsigned char*,const unsigned char*,ulint,mtr_t*)" -> "__builtin_expect(long int,long int)"
"mlog_write_string(unsigned char*,const unsigned char*,ulint,mtr_t*)" -> "ut_dbg_assertion_failed(const char*,const char*,ulint)"
"mlog_write_string(unsigned char*,const unsigned char*,ulint,mtr_t*)" -> "memcpy(void*,const void*,size_t)"
"mlog_log_string(unsigned char*,ulint,mtr_t*)" -> "mach_write_to_2(unsigned char*,ulint)"
"mlog_log_string(unsigned char*,ulint,mtr_t*)" -> "page_offset(const void*)"
"mlog_log_string(unsigned char*,ulint,mtr_t*)" -> "mlog_catenate_string(mtr_t*,const unsigned char*,ulint)"
"mlog_log_string(unsigned char*,ulint,mtr_t*)" -> "mlog_write_initial_log_record_fast(const unsigned char*,unsigned char,unsigned char*,mtr_t*)"
"mlog_log_string(unsigned char*,ulint,mtr_t*)" -> "mlog_close(mtr_t*,unsigned char*)"
"mlog_log_string(unsigned char*,ulint,mtr_t*)" -> "mlog_open(mtr_t*,ulint)"
"trx_commit_in_memory(trx_t*,lsn_t)" -> "ut_list_remove(List&,Type&,size_t) [with List = ut_list_base<trx_t>,Type = trx_t,size_t = long unsigned int]"
"trx_commit_in_memory(trx_t*,lsn_t)" -> "trx_roll_savepoints_free(trx_t*,trx_named_savept_t*)"
"trx_commit_in_memory(trx_t*,lsn_t)" -> "abort()"
"trx_commit_in_memory(trx_t*,lsn_t)" -> "read_view_remove(read_view_t*,bool)"
"trx_commit_in_memory(trx_t*,lsn_t)" -> "ut_dbg_assertion_failed(const char*,const char*,ulint)"
"trx_commit_in_memory(trx_t*,lsn_t)" -> "mem_heap_empty(mem_heap_t*)"
"trx_commit_in_memory(trx_t*,lsn_t)" -> "trx_finalize_for_fts(trx_t*,bool)"
"trx_commit_in_memory(trx_t*,lsn_t)" -> "__builtin_expect(long int,long int)"
"trx_commit_in_memory(trx_t*,lsn_t)" -> "srv_active_wake_master_thread()"
"trx_commit_in_memory(trx_t*,lsn_t)" -> "lock_trx_release_locks(trx_t*)"
"trx_commit_in_memory(trx_t*,lsn_t)" -> "trx_undo_insert_cleanup(trx_t*)"
"trx_commit_in_memory(trx_t*,lsn_t)" -> "pfs_mutex_enter_func(ib_mutex_t*,const char*,ulint)"
"trx_commit_in_memory(trx_t*,lsn_t)" -> "thd_requested_durability(const THD*)"
"trx_commit_in_memory(trx_t*,lsn_t)" -> "trx_flush_log_if_needed(lsn_t,trx_t*)"
"trx_commit_in_memory(trx_t*,lsn_t)" -> "pfs_mutex_exit_func(ib_mutex_t*)"
"ut_list_remove(List&,Type&,size_t) [with List = ut_list_base<trx_t>,Type = trx_t,size_t = long unsigned int]" -> "abort()"
"ut_list_remove(List&,Type&,size_t) [with List = ut_list_base<trx_t>,Type = trx_t,size_t = long unsigned int]" -> "__builtin_expect(long int,long int)"
"ut_list_remove(List&,Type&,size_t) [with List = ut_list_base<trx_t>,Type = trx_t,size_t = long unsigned int]" -> "ut_dbg_assertion_failed(const char*,const char*,ulint)"
"ut_list_remove(List&,Type&,size_t) [with List = ut_list_base<trx_t>,Type = trx_t,size_t = long unsigned int]" -> "ut_elem_get_node(Type&,size_t) [with Type = trx_t,size_t = long unsigned int]"
"ut_elem_get_node(Type&,size_t) [with Type = trx_t,size_t = long unsigned int]" -> "ut_dbg_assertion_failed(const char*,const char*,ulint)"
"ut_elem_get_node(Type&,size_t) [with Type = trx_t,size_t = long unsigned int]" -> "abort()"
"ut_elem_get_node(Type&,size_t) [with Type = trx_t,size_t = long unsigned int]" -> "__builtin_expect(long int,long int)"
"trx_roll_savepoints_free(trx_t*,trx_named_savept_t*)" -> "trx_roll_savepoint_free(trx_t*,trx_named_savept_t*)"
"trx_roll_savepoint_free(trx_t*,trx_named_savept_t*)" -> "mem_free_func(void*,const char*,ulint)"
"trx_roll_savepoint_free(trx_t*,trx_named_savept_t*)" -> "ut_list_remove(List&,Type&,size_t) [with List = ut_list_base<trx_named_savept_t>,Type = trx_named_savept_t,size_t = long unsigned int]"
"ut_list_remove(List&,Type&,size_t) [with List = ut_list_base<trx_named_savept_t>,Type = trx_named_savept_t,size_t = long unsigned int]" -> "abort()"
"ut_list_remove(List&,Type&,size_t) [with List = ut_list_base<trx_named_savept_t>,Type = trx_named_savept_t,size_t = long unsigned int]" -> "ut_elem_get_node(Type&,size_t) [with Type = trx_named_savept_t,size_t = long unsigned int]"
"ut_list_remove(List&,Type&,size_t) [with List = ut_list_base<trx_named_savept_t>,Type = trx_named_savept_t,size_t = long unsigned int]" -> "ut_dbg_assertion_failed(const char*,const char*,ulint)"
"ut_list_remove(List&,Type&,size_t) [with List = ut_list_base<trx_named_savept_t>,Type = trx_named_savept_t,size_t = long unsigned int]" -> "__builtin_expect(long int,long int)"
"ut_elem_get_node(Type&,size_t) [with Type = trx_named_savept_t,size_t = long unsigned int]" -> "__builtin_expect(long int,long int)"
"ut_elem_get_node(Type&,size_t) [with Type = trx_named_savept_t,size_t = long unsigned int]" -> "ut_dbg_assertion_failed(const char*,const char*,ulint)"
"ut_elem_get_node(Type&,size_t) [with Type = trx_named_savept_t,size_t = long unsigned int]" -> "abort()"
"read_view_remove(read_view_t*,bool)" -> "pfs_mutex_exit_func(ib_mutex_t*)"
"read_view_remove(read_view_t*,bool)" -> "pfs_mutex_enter_func(ib_mutex_t*,const char*,ulint)"
"read_view_remove(read_view_t*,bool)" -> "ut_list_remove(List&,Type&,size_t) [with List = ut_list_base<read_view_t>,Type = read_view_t,size_t = long unsigned int]"
"ut_list_remove(List&,Type&,size_t) [with List = ut_list_base<read_view_t>,Type = read_view_t,size_t = long unsigned int]" -> "ut_elem_get_node(Type&,size_t) [with Type = read_view_t,size_t = long unsigned int]"
"ut_list_remove(List&,Type&,size_t) [with List = ut_list_base<read_view_t>,Type = read_view_t,size_t = long unsigned int]" -> "__builtin_expect(long int,long int)"
"ut_list_remove(List&,Type&,size_t) [with List = ut_list_base<read_view_t>,Type = read_view_t,size_t = long unsigned int]" -> "ut_dbg_assertion_failed(const char*,const char*,ulint)"
"ut_list_remove(List&,Type&,size_t) [with List = ut_list_base<read_view_t>,Type = read_view_t,size_t = long unsigned int]" -> "abort()"
"ut_elem_get_node(Type&,size_t) [with Type = read_view_t,size_t = long unsigned int]" -> "ut_dbg_assertion_failed(const char*,const char*,ulint)"
"ut_elem_get_node(Type&,size_t) [with Type = read_view_t,size_t = long unsigned int]" -> "abort()"
"ut_elem_get_node(Type&,size_t) [with Type = read_view_t,size_t = long unsigned int]" -> "__builtin_expect(long int,long int)"
"mem_heap_empty(mem_heap_t*)" -> "mem_heap_free_block_free(mem_heap_t*)"
"mem_heap_empty(mem_heap_t*)" -> "mem_block_get_start(mem_block_t*)"
"mem_heap_empty(mem_heap_t*)" -> "mem_heap_free_heap_top(mem_heap_t*,unsigned char*)"
"mem_heap_free_heap_top(mem_heap_t*,unsigned char*)" -> "mem_block_get_start(mem_block_t*)"
"mem_heap_free_heap_top(mem_heap_t*,unsigned char*)" -> "mem_heap_block_free(mem_heap_t*,mem_block_t*)"
"mem_heap_free_heap_top(mem_heap_t*,unsigned char*)" -> "mem_block_get_free(mem_block_t*)"
"mem_heap_free_heap_top(mem_heap_t*,unsigned char*)" -> "mem_block_set_free(mem_block_t*,ulint)"
"trx_finalize_for_fts(trx_t*,bool)" -> "ib_vector_last(ib_vector_t*)"
"trx_finalize_for_fts(trx_t*,bool)" -> "fts_trx_free(fts_trx_t*)"
"trx_finalize_for_fts(trx_t*,bool)" -> "rbt_next(const ib_rbt_t*,const ib_rbt_node_t*)"
"trx_finalize_for_fts(trx_t*,bool)" -> "rbt_first(const ib_rbt_t*)"
"trx_finalize_for_fts(trx_t*,bool)" -> "trx_finalize_for_fts_table(fts_trx_table_t*)"
"ib_vector_last(ib_vector_t*)" -> "abort()"
"ib_vector_last(ib_vector_t*)" -> "ib_vector_size(const ib_vector_t*)"
"ib_vector_last(ib_vector_t*)" -> "ib_vector_get(ib_vector_t*,ulint)"
"ib_vector_last(ib_vector_t*)" -> "__builtin_expect(long int,long int)"
"ib_vector_last(ib_vector_t*)" -> "ut_dbg_assertion_failed(const char*,const char*,ulint)"
"fts_trx_free(fts_trx_t*)" -> "mem_heap_free_func(mem_heap_t*,const char*,ulint)"
"fts_trx_free(fts_trx_t*)" -> "__builtin_expect(long int,long int)"
"fts_trx_free(fts_trx_t*)" -> "ut_dbg_assertion_failed(const char*,const char*,ulint)"
"fts_trx_free(fts_trx_t*)" -> "abort()"
"fts_trx_free(fts_trx_t*)" -> "ib_vector_size(const ib_vector_t*)"
"fts_trx_free(fts_trx_t*)" -> "fts_savepoint_free(fts_savepoint_t*)"
"fts_trx_free(fts_trx_t*)" -> "ib_vector_get(ib_vector_t*,ulint)"
"fts_savepoint_free(fts_savepoint_t*)" -> "ut_free(void*)"
"fts_savepoint_free(fts_savepoint_t*)" -> "rbt_first(const ib_rbt_t*)"
"fts_savepoint_free(fts_savepoint_t*)" -> "que_graph_free(que_t*)"
"fts_savepoint_free(fts_savepoint_t*)" -> "pfs_mutex_exit_func(ib_mutex_t*)"
"fts_savepoint_free(fts_savepoint_t*)" -> "abort()"
"fts_savepoint_free(fts_savepoint_t*)" -> "__builtin_expect(long int,long int)"
"fts_savepoint_free(fts_savepoint_t*)" -> "rbt_free(ib_rbt_t*)"
"fts_savepoint_free(fts_savepoint_t*)" -> "ut_dbg_assertion_failed(const char*,const char*,ulint)"
"fts_savepoint_free(fts_savepoint_t*)" -> "pfs_mutex_enter_func(ib_mutex_t*,const char*,ulint)"
"fts_savepoint_free(fts_savepoint_t*)" -> "rbt_remove_node(ib_rbt_t*,const ib_rbt_node_t*)"
"fts_savepoint_free(fts_savepoint_t*)" -> "fts_trx_table_rows_free(ib_rbt_t*)"
"fts_savepoint_free(fts_savepoint_t*)" -> "fts_doc_ids_free(fts_doc_ids_t*)"
"fts_trx_table_rows_free(ib_rbt_t*)" -> "ib_vector_free(ib_vector_t*)"
"fts_trx_table_rows_free(ib_rbt_t*)" -> "abort()"
"fts_trx_table_rows_free(ib_rbt_t*)" -> "ut_free(void*)"
"fts_trx_table_rows_free(ib_rbt_t*)" -> "ut_dbg_assertion_failed(const char*,const char*,ulint)"
"fts_trx_table_rows_free(ib_rbt_t*)" -> "rbt_free(ib_rbt_t*)"
"fts_trx_table_rows_free(ib_rbt_t*)" -> "rbt_remove_node(ib_rbt_t*,const ib_rbt_node_t*)"
"fts_trx_table_rows_free(ib_rbt_t*)" -> "rbt_first(const ib_rbt_t*)"
"fts_trx_table_rows_free(ib_rbt_t*)" -> "__builtin_expect(long int,long int)"
"fts_doc_ids_free(fts_doc_ids_t*)" -> "mem_heap_free_func(mem_heap_t*,const char*,ulint)"
"fts_doc_ids_free(fts_doc_ids_t*)" -> "memset(void*,int,size_t)"
"rbt_next(const ib_rbt_t*,const ib_rbt_node_t*)" -> "rbt_find_successor(const ib_rbt_t*,const ib_rbt_node_t*)"
"trx_finalize_for_fts_table(fts_trx_table_t*)" -> "pfs_mutex_enter_func(ib_mutex_t*,const char*,ulint)"
"trx_finalize_for_fts_table(fts_trx_table_t*)" -> "ut_dbg_assertion_failed(const char*,const char*,ulint)"
"trx_finalize_for_fts_table(fts_trx_table_t*)" -> "abort()"
"trx_finalize_for_fts_table(fts_trx_table_t*)" -> "ib_wqueue_add(ib_wqueue_t*,void*,mem_heap_t*)"
"trx_finalize_for_fts_table(fts_trx_table_t*)" -> "__builtin_expect(long int,long int)"
"trx_finalize_for_fts_table(fts_trx_table_t*)" -> "pfs_mutex_exit_func(ib_mutex_t*)"
"srv_active_wake_master_thread()" -> "srv_slot_get_type(const srv_slot_t*)"
"srv_active_wake_master_thread()" -> "__builtin_expect(long int,long int)"
"srv_active_wake_master_thread()" -> "srv_inc_activity_count()"
"srv_active_wake_master_thread()" -> "pfs_mutex_enter_func(ib_mutex_t*,const char*,ulint)"
"srv_active_wake_master_thread()" -> "abort()"
"srv_active_wake_master_thread()" -> "os_event_set(os_event_t)"
"srv_active_wake_master_thread()" -> "ut_dbg_assertion_failed(const char*,const char*,ulint)"
"srv_active_wake_master_thread()" -> "pfs_mutex_exit_func(ib_mutex_t*)"
"srv_inc_activity_count()" -> "Indexer>::inc() [with Type = long unsigned int,int N = 1,Indexer = single_indexer_t]"
"Indexer>::inc() [with Type = long unsigned int,int N = 1,Indexer = single_indexer_t]" -> "Indexer>::add(Type) [with Type = long unsigned int,int N = 1,Indexer = single_indexer_t]"
"Indexer>::add(Type) [with Type = long unsigned int,int N = 1,Indexer = single_indexer_t]" -> "N>::get_rnd_index() const [with Type = long unsigned int,int N = 1,size_t = long unsigned int]"
"Indexer>::add(Type) [with Type = long unsigned int,int N = 1,Indexer = single_indexer_t]" -> "N>::offset(size_t) const [with Type = long unsigned int,int N = 1,size_t = long unsigned int]"
"lock_trx_release_locks(trx_t*)" -> "trx_state_eq(const trx_t*,trx_state_t)"
"lock_trx_release_locks(trx_t*)" -> "__builtin_expect(long int,long int)"
"lock_trx_release_locks(trx_t*)" -> "pfs_mutex_exit_func(ib_mutex_t*)"
"lock_trx_release_locks(trx_t*)" -> "pfs_mutex_enter_func(ib_mutex_t*,const char*,ulint)"
"lock_trx_release_locks(trx_t*)" -> "lock_release(trx_t*)"
"lock_trx_release_locks(trx_t*)" -> "ut_dbg_assertion_failed(const char*,const char*,ulint)"
"lock_trx_release_locks(trx_t*)" -> "abort()"
"lock_release(trx_t*)" -> "lock_get_type_low(const ib_lock_t*)"
"lock_release(trx_t*)" -> "pfs_mutex_enter_func(ib_mutex_t*,const char*,ulint)"
"lock_release(trx_t*)" -> "pfs_mutex_exit_func(ib_mutex_t*)"
"lock_release(trx_t*)" -> "__builtin_expect(long int,long int)"
"lock_release(trx_t*)" -> "abort()"
"lock_release(trx_t*)" -> "lock_get_mode(const ib_lock_t*)"
"lock_release(trx_t*)" -> "trx_sys_get_max_trx_id()"
"lock_release(trx_t*)" -> "ib_vector_reset(ib_vector_t*)"
"lock_release(trx_t*)" -> "mem_heap_empty(mem_heap_t*)"
"lock_release(trx_t*)" -> "ut_dbg_assertion_failed(const char*,const char*,ulint)"
"lock_release(trx_t*)" -> "lock_rec_dequeue_from_page(ib_lock_t*)"
"lock_release(trx_t*)" -> "lock_table_dequeue(ib_lock_t*)"
"lock_release(trx_t*)" -> "ib_vector_is_empty(const ib_vector_t*)"
"lock_rec_dequeue_from_page(ib_lock_t*)" -> "hash_get_nth_cell(hash_table_t*,ulint)"
"lock_rec_dequeue_from_page(ib_lock_t*)" -> "lock_rec_has_to_wait_in_queue(const ib_lock_t*)"
"lock_rec_dequeue_from_page(ib_lock_t*)" -> "lock_rec_get_first_on_page_addr(ulint,ulint)"
"lock_rec_dequeue_from_page(ib_lock_t*)" -> "ut_list_remove(List&,Type&,size_t) [with List = ut_list_base<ib_lock_t>,Type = ib_lock_t,size_t = long unsigned int]"
"lock_rec_dequeue_from_page(ib_lock_t*)" -> "lock_rec_fold(ulint,ulint)"
"lock_rec_dequeue_from_page(ib_lock_t*)" -> "lock_grant(ib_lock_t*)"
"lock_rec_dequeue_from_page(ib_lock_t*)" -> "ut_dbg_assertion_failed(const char*,const char*,ulint)"
"lock_rec_dequeue_from_page(ib_lock_t*)" -> "abort()"
"lock_rec_dequeue_from_page(ib_lock_t*)" -> "hash_calc_hash(ulint,hash_table_t*)"
"lock_rec_dequeue_from_page(ib_lock_t*)" -> "__builtin_expect(long int,long int)"
"lock_rec_dequeue_from_page(ib_lock_t*)" -> "lock_rec_get_next_on_page(ib_lock_t*)"
"lock_rec_dequeue_from_page(ib_lock_t*)" -> "lock_get_wait(const ib_lock_t*)"
"lock_rec_has_to_wait_in_queue(const ib_lock_t*)" -> "lock_rec_get_n_bits(const ib_lock_t*)"
"lock_rec_has_to_wait_in_queue(const ib_lock_t*)" -> "lock_has_to_wait(const ib_lock_t*,const ib_lock_t*)"
"lock_rec_has_to_wait_in_queue(const ib_lock_t*)" -> "lock_rec_get_first_on_page_addr(ulint,ulint)"
"lock_rec_has_to_wait_in_queue(const ib_lock_t*)" -> "lock_rec_find_set_bit(const ib_lock_t*)"
"lock_rec_has_to_wait_in_queue(const ib_lock_t*)" -> "lock_rec_get_next_on_page_const(const ib_lock_t*)"
"lock_has_to_wait(const ib_lock_t*,const ib_lock_t*)" -> "lock_mode_compatible(lock_mode,lock_mode)"
"lock_has_to_wait(const ib_lock_t*,const ib_lock_t*)" -> "lock_get_mode(const ib_lock_t*)"
"lock_has_to_wait(const ib_lock_t*,const ib_lock_t*)" -> "lock_rec_has_to_wait(const trx_t*,ulint,const ib_lock_t*,ulint)"
"lock_has_to_wait(const ib_lock_t*,const ib_lock_t*)" -> "lock_get_type_low(const ib_lock_t*)"
"lock_has_to_wait(const ib_lock_t*,const ib_lock_t*)" -> "lock_rec_get_nth_bit(const ib_lock_t*,ulint)"
"lock_rec_has_to_wait(const trx_t*,ulint,const ib_lock_t*,ulint)" -> "lock_rec_get_insert_intention(const ib_lock_t*)"
"lock_rec_has_to_wait(const trx_t*,ulint,const ib_lock_t*,ulint)" -> "lock_rec_get_rec_not_gap(const ib_lock_t*)"
"lock_rec_has_to_wait(const trx_t*,ulint,const ib_lock_t*,ulint)" -> "lock_rec_get_gap(const ib_lock_t*)"
"lock_rec_has_to_wait(const trx_t*,ulint,const ib_lock_t*,ulint)" -> "lock_mode_compatible(lock_mode,lock_mode)"
"lock_rec_has_to_wait(const trx_t*,ulint,const ib_lock_t*,ulint)" -> "lock_get_mode(const ib_lock_t*)"
"lock_rec_get_first_on_page_addr(ulint,ulint)" -> "lock_rec_hash(ulint,ulint)"
"lock_rec_get_first_on_page_addr(ulint,ulint)" -> "hash_get_nth_cell(hash_table_t*,ulint)"
"lock_rec_hash(ulint,ulint)" -> "lock_rec_fold(ulint,ulint)"
"lock_rec_hash(ulint,ulint)" -> "hash_calc_hash(ulint,hash_table_t*)"
"lock_rec_find_set_bit(const ib_lock_t*)" -> "lock_rec_get_nth_bit(const ib_lock_t*,ulint)"
"lock_rec_find_set_bit(const ib_lock_t*)" -> "lock_rec_get_n_bits(const ib_lock_t*)"
"ut_list_remove(List&,Type&,size_t) [with List = ut_list_base<ib_lock_t>,Type = ib_lock_t,size_t = long unsigned int]" -> "abort()"
"ut_list_remove(List&,Type&,size_t) [with List = ut_list_base<ib_lock_t>,Type = ib_lock_t,size_t = long unsigned int]" -> "ut_elem_get_node(Type&,size_t) [with Type = ib_lock_t,size_t = long unsigned int]"
"ut_list_remove(List&,Type&,size_t) [with List = ut_list_base<ib_lock_t>,Type = ib_lock_t,size_t = long unsigned int]" -> "ut_dbg_assertion_failed(const char*,const char*,ulint)"
"ut_list_remove(List&,Type&,size_t) [with List = ut_list_base<ib_lock_t>,Type = ib_lock_t,size_t = long unsigned int]" -> "__builtin_expect(long int,long int)"
"lock_grant(ib_lock_t*)" -> "__builtin_fwrite(const void*,size_t,size_t,FILE*)"
"lock_grant(ib_lock_t*)" -> "pfs_mutex_exit_func(ib_mutex_t*)"
"lock_grant(ib_lock_t*)" -> "__builtin_expect(long int,long int)"
"lock_grant(ib_lock_t*)" -> "pfs_mutex_enter_func(ib_mutex_t*,const char*,ulint)"
"lock_grant(ib_lock_t*)" -> "lock_wait_release_thread_if_suspended(que_thr_t*)"
"lock_grant(ib_lock_t*)" -> "que_thr_end_lock_wait(trx_t*)"
"lock_grant(ib_lock_t*)" -> "lock_get_mode(const ib_lock_t*)"
"lock_grant(ib_lock_t*)" -> "ib_vector_push(ib_vector_t*,const void*)"
"lock_grant(ib_lock_t*)" -> "lock_reset_lock_and_trx_wait(ib_lock_t*)"
"lock_wait_release_thread_if_suspended(que_thr_t*)" -> "os_event_set(os_event_t)"
"lock_wait_release_thread_if_suspended(que_thr_t*)" -> "thr_get_trx(que_thr_t*)"
"que_thr_end_lock_wait(trx_t*)" -> "__builtin_expect(long int,long int)"
"que_thr_end_lock_wait(trx_t*)" -> "que_thr_move_to_run_state(que_thr_t*)"
"que_thr_end_lock_wait(trx_t*)" -> "abort()"
"que_thr_end_lock_wait(trx_t*)" -> "ut_dbg_assertion_failed(const char*,const char*,ulint)"
"que_thr_move_to_run_state(que_thr_t*)" -> "thr_get_trx(que_thr_t*)"
"ib_vector_push(ib_vector_t*,const void*)" -> "ib_vector_resize(ib_vector_t*)"
"ib_vector_push(ib_vector_t*,const void*)" -> "memcpy(void*,const void*,size_t)"
"lock_table_dequeue(ib_lock_t*)" -> "lock_grant(ib_lock_t*)"
"lock_table_dequeue(ib_lock_t*)" -> "abort()"
"lock_table_dequeue(ib_lock_t*)" -> "lock_get_wait(const ib_lock_t*)"
"lock_table_dequeue(ib_lock_t*)" -> "lock_get_type_low(const ib_lock_t*)"
"lock_table_dequeue(ib_lock_t*)" -> "__builtin_expect(long int,long int)"
"lock_table_dequeue(ib_lock_t*)" -> "lock_table_has_to_wait_in_queue(const ib_lock_t*)"
"lock_table_dequeue(ib_lock_t*)" -> "lock_table_remove_low(ib_lock_t*)"
"lock_table_dequeue(ib_lock_t*)" -> "ut_dbg_assertion_failed(const char*,const char*,ulint)"
"lock_table_has_to_wait_in_queue(const ib_lock_t*)" -> "lock_has_to_wait(const ib_lock_t*,const ib_lock_t*)"
"lock_table_remove_low(ib_lock_t*)" -> "abort()"
"lock_table_remove_low(ib_lock_t*)" -> "lock_table_remove_autoinc_lock(ib_lock_t*,trx_t*)"
"lock_table_remove_low(ib_lock_t*)" -> "ut_list_remove(List&,Type&,size_t) [with List = ut_list_base<ib_lock_t>,Type = ib_lock_t,size_t = long unsigned int]"
"lock_table_remove_low(ib_lock_t*)" -> "__builtin_expect(long int,long int)"
"lock_table_remove_low(ib_lock_t*)" -> "ut_dbg_assertion_failed(const char*,const char*,ulint)"
"lock_table_remove_low(ib_lock_t*)" -> "lock_get_wait(const ib_lock_t*)"
"lock_table_remove_low(ib_lock_t*)" -> "ib_vector_is_empty(const ib_vector_t*)"
"lock_table_remove_low(ib_lock_t*)" -> "lock_get_mode(const ib_lock_t*)"
"lock_table_remove_autoinc_lock(ib_lock_t*,trx_t*)" -> "abort()"
"lock_table_remove_autoinc_lock(ib_lock_t*,trx_t*)" -> "lock_table_pop_autoinc_locks(trx_t*)"
"lock_table_remove_autoinc_lock(ib_lock_t*,trx_t*)" -> "ib_vector_get(ib_vector_t*,ulint)"
"lock_table_remove_autoinc_lock(ib_lock_t*,trx_t*)" -> "ib_vector_set(ib_vector_t*,ulint,void*)"
"lock_table_remove_autoinc_lock(ib_lock_t*,trx_t*)" -> "ut_dbg_assertion_failed(const char*,const char*,ulint)"
"lock_table_remove_autoinc_lock(ib_lock_t*,trx_t*)" -> "__builtin_expect(long int,long int)"
"lock_table_remove_autoinc_lock(ib_lock_t*,trx_t*)" -> "ib_vector_size(const ib_vector_t*)"
"lock_table_pop_autoinc_locks(trx_t*)" -> "ib_vector_pop(ib_vector_t*)"
"lock_table_pop_autoinc_locks(trx_t*)" -> "ib_vector_is_empty(const ib_vector_t*)"
"lock_table_pop_autoinc_locks(trx_t*)" -> "ib_vector_get_last(ib_vector_t*)"
"ib_vector_pop(ib_vector_t*)" -> "ut_dbg_assertion_failed(const char*,const char*,ulint)"
"ib_vector_pop(ib_vector_t*)" -> "ib_vector_last(ib_vector_t*)"
"ib_vector_pop(ib_vector_t*)" -> "__builtin_expect(long int,long int)"
"ib_vector_pop(ib_vector_t*)" -> "abort()"
"ib_vector_get_last(ib_vector_t*)" -> "ib_vector_get(ib_vector_t*,ulint)"
"ib_vector_get_last(ib_vector_t*)" -> "ut_dbg_assertion_failed(const char*,const char*,ulint)"
"ib_vector_get_last(ib_vector_t*)" -> "__builtin_expect(long int,long int)"
"ib_vector_get_last(ib_vector_t*)" -> "abort()"
"ib_vector_set(ib_vector_t*,ulint,void*)" -> "abort()"
"ib_vector_set(ib_vector_t*,ulint,void*)" -> "__builtin_expect(long int,long int)"
"ib_vector_set(ib_vector_t*,ulint,void*)" -> "memcpy(void*,const void*,size_t)"
"ib_vector_set(ib_vector_t*,ulint,void*)" -> "ut_dbg_assertion_failed(const char*,const char*,ulint)"
"trx_undo_insert_cleanup(trx_t*)" -> "pfs_mutex_enter_func(ib_mutex_t*,const char*,ulint)"
"trx_undo_insert_cleanup(trx_t*)" -> "trx_undo_seg_free(trx_undo_t*)"
"trx_undo_insert_cleanup(trx_t*)" -> "ut_list_prepend(List&,Type&,size_t) [with List = ut_list_base<trx_undo_t>,Type = trx_undo_t,size_t = long unsigned int]"
"trx_undo_insert_cleanup(trx_t*)" -> "trx_undo_mem_free(trx_undo_t*)"
"trx_undo_insert_cleanup(trx_t*)" -> "ut_list_remove(List&,Type&,size_t) [with List = ut_list_base<trx_undo_t>,Type = trx_undo_t,size_t = long unsigned int]"
"trx_undo_insert_cleanup(trx_t*)" -> "pfs_mutex_exit_func(ib_mutex_t*)"
"trx_undo_seg_free(trx_undo_t*)" -> "pfs_mutex_exit_func(ib_mutex_t*)"
"trx_undo_seg_free(trx_undo_t*)" -> "mtr_commit(mtr_t*)"
"trx_undo_seg_free(trx_undo_t*)" -> "trx_undo_page_get(ulint,ulint,ulint,mtr_t*)"
"trx_undo_seg_free(trx_undo_t*)" -> "trx_rsegf_get(ulint,ulint,ulint,mtr_t*)"
"trx_undo_seg_free(trx_undo_t*)" -> "pfs_mutex_enter_func(ib_mutex_t*,const char*,ulint)"
"trx_undo_seg_free(trx_undo_t*)" -> "trx_rsegf_set_nth_undo(trx_rsegf_t*,ulint,ulint,mtr_t*)"
"trx_undo_seg_free(trx_undo_t*)" -> "fseg_free_step(fseg_header_t*,mtr_t*)"
"trx_undo_seg_free(trx_undo_t*)" -> "mtr_start(mtr_t*)"
"fseg_free_step(fseg_header_t*,mtr_t*)" -> "fprintf(FILE*,const char*,...)"
"fseg_free_step(fseg_header_t*,mtr_t*)" -> "__builtin_expect(long int,long int)"
"fseg_free_step(fseg_header_t*,mtr_t*)" -> "fseg_get_nth_frag_page_no(fseg_inode_t*,ulint,mtr_t*)"
"fseg_free_step(fseg_header_t*,mtr_t*)" -> "fil_space_get_latch(ulint,ulint*)"
"fseg_free_step(fseg_header_t*,mtr_t*)" -> "fseg_free_page_low(fseg_inode_t*,ulint,ulint,ulint,mtr_t*)"
"fseg_free_step(fseg_header_t*,mtr_t*)" -> "abort()"
"fseg_free_step(fseg_header_t*,mtr_t*)" -> "mtr_x_lock_func(rw_lock_t*,const char*,ulint,mtr_t*)"
"fseg_free_step(fseg_header_t*,mtr_t*)" -> "fsp_free_seg_inode(ulint,ulint,fseg_inode_t*,mtr_t*)"
"fseg_free_step(fseg_header_t*,mtr_t*)" -> "page_get_page_no(const ib_page_t*)"
"fseg_free_step(fseg_header_t*,mtr_t*)" -> "ut_dbg_assertion_failed(const char*,const char*,ulint)"
"fseg_free_step(fseg_header_t*,mtr_t*)" -> "xdes_get_offset(const xdes_t*)"
"fseg_free_step(fseg_header_t*,mtr_t*)" -> "xdes_get_descriptor(ulint,ulint,ulint,mtr_t*)"
"fseg_free_step(fseg_header_t*,mtr_t*)" -> "fseg_free_extent(fseg_inode_t*,ulint,ulint,ulint,mtr_t*)"
"fseg_free_step(fseg_header_t*,mtr_t*)" -> "xdes_mtr_get_bit(const xdes_t*,ulint,ulint,mtr_t*)"
"fseg_free_step(fseg_header_t*,mtr_t*)" -> "fseg_find_last_used_frag_page_slot(fseg_inode_t*,mtr_t*)"
"fseg_free_step(fseg_header_t*,mtr_t*)" -> "page_get_space_id(const ib_page_t*)"
"fseg_free_step(fseg_header_t*,mtr_t*)" -> "page_align(const void*)"
"fseg_free_step(fseg_header_t*,mtr_t*)" -> "fseg_get_first_extent(fseg_inode_t*,ulint,ulint,mtr_t*)"
"fseg_free_step(fseg_header_t*,mtr_t*)" -> "fseg_inode_try_get(fseg_header_t*,ulint,ulint,mtr_t*)"
"fseg_free_step(fseg_header_t*,mtr_t*)" -> "fsp_flags_get_zip_size(ulint)"
"fseg_get_nth_frag_page_no(fseg_inode_t*,ulint,mtr_t*)" -> "mach_read_from_4(const unsigned char*)"
"fil_space_get_latch(ulint,ulint*)" -> "pfs_mutex_exit_func(ib_mutex_t*)"
"fil_space_get_latch(ulint,ulint*)" -> "abort()"
"fil_space_get_latch(ulint,ulint*)" -> "__builtin_expect(long int,long int)"
"fil_space_get_latch(ulint,ulint*)" -> "pfs_mutex_enter_func(ib_mutex_t*,const char*,ulint)"
"fil_space_get_latch(ulint,ulint*)" -> "fil_space_get_by_id(ulint)"
"fil_space_get_latch(ulint,ulint*)" -> "ut_dbg_assertion_failed(const char*,const char*,ulint)"
"fseg_free_page_low(fseg_inode_t*,ulint,ulint,ulint,mtr_t*)" -> "xdes_is_full(const xdes_t*,mtr_t*)"
"fseg_free_page_low(fseg_inode_t*,ulint,ulint,ulint,mtr_t*)" -> "fsp_free_page(ulint,ulint,ulint,mtr_t*)"
"fseg_free_page_low(fseg_inode_t*,ulint,ulint,ulint,mtr_t*)" -> "btr_search_drop_page_hash_when_freed(ulint,ulint,ulint)"
"fseg_free_page_low(fseg_inode_t*,ulint,ulint,ulint,mtr_t*)" -> "fseg_get_nth_frag_page_no(fseg_inode_t*,ulint,mtr_t*)"
"fseg_free_page_low(fseg_inode_t*,ulint,ulint,ulint,mtr_t*)" -> "mtr_read_ulint(const unsigned char*,ulint,mtr_t*)"
"fseg_free_page_low(fseg_inode_t*,ulint,ulint,ulint,mtr_t*)" -> "xdes_set_bit(xdes_t*,ulint,ulint,ulint,mtr_t*)"
"fseg_free_page_low(fseg_inode_t*,ulint,ulint,ulint,mtr_t*)" -> "abort()"
"fseg_free_page_low(fseg_inode_t*,ulint,ulint,ulint,mtr_t*)" -> "mach_read_from_8(const unsigned char*)"
"fseg_free_page_low(fseg_inode_t*,ulint,ulint,ulint,mtr_t*)" -> "fsp_free_extent(ulint,ulint,ulint,mtr_t*)"
"fseg_free_page_low(fseg_inode_t*,ulint,ulint,ulint,mtr_t*)" -> "xdes_mtr_get_bit(const xdes_t*,ulint,ulint,mtr_t*)"
"fseg_free_page_low(fseg_inode_t*,ulint,ulint,ulint,mtr_t*)" -> "mlog_write_ulint(unsigned char*,ulint,unsigned char,mtr_t*)"
"fseg_free_page_low(fseg_inode_t*,ulint,ulint,ulint,mtr_t*)" -> "flst_remove(flst_base_node_t*,flst_node_t*,mtr_t*)"
"fseg_free_page_low(fseg_inode_t*,ulint,ulint,ulint,mtr_t*)" -> "fseg_set_nth_frag_page_no(fseg_inode_t*,ulint,ulint,mtr_t*)"
"fseg_free_page_low(fseg_inode_t*,ulint,ulint,ulint,mtr_t*)" -> "xdes_is_free(const xdes_t*,mtr_t*)"
"fseg_free_page_low(fseg_inode_t*,ulint,ulint,ulint,mtr_t*)" -> "_IO_putc(int,_IO_FILE*)"
"fseg_free_page_low(fseg_inode_t*,ulint,ulint,ulint,mtr_t*)" -> "ut_dbg_assertion_failed(const char*,const char*,ulint)"
"fseg_free_page_low(fseg_inode_t*,ulint,ulint,ulint,mtr_t*)" -> "__builtin_expect(long int,long int)"
"fseg_free_page_low(fseg_inode_t*,ulint,ulint,ulint,mtr_t*)" -> "__builtin_fwrite(const void*,size_t,size_t,FILE*)"
"fseg_free_page_low(fseg_inode_t*,ulint,ulint,ulint,mtr_t*)" -> "fprintf(FILE*,const char*,...)"
"fseg_free_page_low(fseg_inode_t*,ulint,ulint,ulint,mtr_t*)" -> "xdes_get_state(const xdes_t*,mtr_t*)"
"fseg_free_page_low(fseg_inode_t*,ulint,ulint,ulint,mtr_t*)" -> "xdes_get_descriptor(ulint,ulint,ulint,mtr_t*)"
"fseg_free_page_low(fseg_inode_t*,ulint,ulint,ulint,mtr_t*)" -> "ut_print_buf(FILE*,const void*,ulint)"
"fseg_free_page_low(fseg_inode_t*,ulint,ulint,ulint,mtr_t*)" -> "flst_add_last(flst_base_node_t*,flst_node_t*,mtr_t*)"
"xdes_is_full(const xdes_t*,mtr_t*)" -> "xdes_get_n_used(const xdes_t*,mtr_t*)"
"xdes_get_n_used(const xdes_t*,mtr_t*)" -> "xdes_mtr_get_bit(const xdes_t*,ulint,ulint,mtr_t*)"
"xdes_mtr_get_bit(const xdes_t*,ulint,ulint,mtr_t*)" -> "xdes_get_bit(const xdes_t*,ulint,ulint)"
"xdes_get_bit(const xdes_t*,ulint,ulint)" -> "mach_read_ulint(const unsigned char*,ulint)"
"xdes_get_bit(const xdes_t*,ulint,ulint)" -> "ut_bit_get_nth(ulint,ulint)"
"fsp_free_page(ulint,ulint,ulint,mtr_t*)" -> "fsp_free_extent(ulint,ulint,ulint,mtr_t*)"
"fsp_free_page(ulint,ulint,ulint,mtr_t*)" -> "flst_add_last(flst_base_node_t*,flst_node_t*,mtr_t*)"
"fsp_free_page(ulint,ulint,ulint,mtr_t*)" -> "fprintf(FILE*,const char*,...)"
"fsp_free_page(ulint,ulint,ulint,mtr_t*)" -> "fsp_get_space_header(ulint,ulint,mtr_t*)"
"fsp_free_page(ulint,ulint,ulint,mtr_t*)" -> "ut_print_buf(FILE*,const void*,ulint)"
"fsp_free_page(ulint,ulint,ulint,mtr_t*)" -> "mtr_read_ulint(const unsigned char*,ulint,mtr_t*)"
"fsp_free_page(ulint,ulint,ulint,mtr_t*)" -> "xdes_is_free(const xdes_t*,mtr_t*)"
"fsp_free_page(ulint,ulint,ulint,mtr_t*)" -> "ut_dbg_assertion_failed(const char*,const char*,ulint)"
"fsp_free_page(ulint,ulint,ulint,mtr_t*)" -> "_IO_putc(int,_IO_FILE*)"
"fsp_free_page(ulint,ulint,ulint,mtr_t*)" -> "xdes_set_state(xdes_t*,ulint,mtr_t*)"
"fsp_free_page(ulint,ulint,ulint,mtr_t*)" -> "xdes_mtr_get_bit(const xdes_t*,ulint,ulint,mtr_t*)"
"fsp_free_page(ulint,ulint,ulint,mtr_t*)" -> "flst_remove(flst_base_node_t*,flst_node_t*,mtr_t*)"
"fsp_free_page(ulint,ulint,ulint,mtr_t*)" -> "__builtin_fwrite(const void*,size_t,size_t,FILE*)"
"fsp_free_page(ulint,ulint,ulint,mtr_t*)" -> "__builtin_expect(long int,long int)"
"fsp_free_page(ulint,ulint,ulint,mtr_t*)" -> "abort()"
"fsp_free_page(ulint,ulint,ulint,mtr_t*)" -> "xdes_get_state(const xdes_t*,mtr_t*)"
"fsp_free_page(ulint,ulint,ulint,mtr_t*)" -> "xdes_get_descriptor_with_space_hdr(fsp_header_t*,ulint,ulint,mtr_t*)"
"fsp_free_page(ulint,ulint,ulint,mtr_t*)" -> "xdes_set_bit(xdes_t*,ulint,ulint,ulint,mtr_t*)"
"fsp_free_page(ulint,ulint,ulint,mtr_t*)" -> "mlog_write_ulint(unsigned char*,ulint,unsigned char,mtr_t*)"
"fsp_free_extent(ulint,ulint,ulint,mtr_t*)" -> "flst_add_last(flst_base_node_t*,flst_node_t*,mtr_t*)"
"fsp_free_extent(ulint,ulint,ulint,mtr_t*)" -> "xdes_get_descriptor_with_space_hdr(fsp_header_t*,ulint,ulint,mtr_t*)"
"fsp_free_extent(ulint,ulint,ulint,mtr_t*)" -> "xdes_get_state(const xdes_t*,mtr_t*)"
"fsp_free_extent(ulint,ulint,ulint,mtr_t*)" -> "ut_print_buf(FILE*,const void*,ulint)"
"fsp_free_extent(ulint,ulint,ulint,mtr_t*)" -> "ut_dbg_assertion_failed(const char*,const char*,ulint)"
"fsp_free_extent(ulint,ulint,ulint,mtr_t*)" -> "_IO_putc(int,_IO_FILE*)"
"fsp_free_extent(ulint,ulint,ulint,mtr_t*)" -> "xdes_init(xdes_t*,mtr_t*)"
"fsp_free_extent(ulint,ulint,ulint,mtr_t*)" -> "abort()"
"fsp_free_extent(ulint,ulint,ulint,mtr_t*)" -> "fsp_get_space_header(ulint,ulint,mtr_t*)"
"flst_add_last(flst_base_node_t*,flst_node_t*,mtr_t*)" -> "flst_add_to_empty(flst_base_node_t*,flst_node_t*,mtr_t*)"
"flst_add_last(flst_base_node_t*,flst_node_t*,mtr_t*)" -> "flst_get_len(const flst_base_node_t*,mtr_t*)"
"flst_add_last(flst_base_node_t*,flst_node_t*,mtr_t*)" -> "buf_ptr_get_fsp_addr(const void*,ulint*,fil_addr_t*)"
"flst_add_last(flst_base_node_t*,flst_node_t*,mtr_t*)" -> "page_align(const void*)"
"flst_add_last(flst_base_node_t*,flst_node_t*,mtr_t*)" -> "flst_insert_after(flst_base_node_t*,flst_node_t*,flst_node_t*,mtr_t*)"
"flst_add_last(flst_base_node_t*,flst_node_t*,mtr_t*)" -> "fut_get_ptr(ulint,ulint,fil_addr_t,ulint,mtr_t*)"
"flst_add_last(flst_base_node_t*,flst_node_t*,mtr_t*)" -> "flst_get_last(const flst_base_node_t*,mtr_t*)"
"flst_add_last(flst_base_node_t*,flst_node_t*,mtr_t*)" -> "fil_space_get_zip_size(ulint)"
"flst_insert_after(flst_base_node_t*,flst_node_t*,flst_node_t*,mtr_t*)" -> "fut_get_ptr(ulint,ulint,fil_addr_t,ulint,mtr_t*)"
"flst_insert_after(flst_base_node_t*,flst_node_t*,flst_node_t*,mtr_t*)" -> "flst_get_len(const flst_base_node_t*,mtr_t*)"
"flst_insert_after(flst_base_node_t*,flst_node_t*,flst_node_t*,mtr_t*)" -> "mlog_write_ulint(unsigned char*,ulint,unsigned char,mtr_t*)"
"flst_insert_after(flst_base_node_t*,flst_node_t*,flst_node_t*,mtr_t*)" -> "buf_ptr_get_fsp_addr(const void*,ulint*,fil_addr_t*)"
"flst_insert_after(flst_base_node_t*,flst_node_t*,flst_node_t*,mtr_t*)" -> "flst_get_next_addr(const flst_node_t*,mtr_t*)"
"flst_insert_after(flst_base_node_t*,flst_node_t*,flst_node_t*,mtr_t*)" -> "fil_addr_is_null(fil_addr_t)"
"flst_insert_after(flst_base_node_t*,flst_node_t*,flst_node_t*,mtr_t*)" -> "flst_write_addr(fil_faddr_t*,fil_addr_t,mtr_t*)"
"flst_insert_after(flst_base_node_t*,flst_node_t*,flst_node_t*,mtr_t*)" -> "fil_space_get_zip_size(ulint)"
"flst_get_next_addr(const flst_node_t*,mtr_t*)" -> "flst_read_addr(const fil_faddr_t*,mtr_t*)"
"flst_get_last(const flst_base_node_t*,mtr_t*)" -> "flst_read_addr(const fil_faddr_t*,mtr_t*)"
"xdes_get_descriptor_with_space_hdr(fsp_header_t*,ulint,ulint,mtr_t*)" -> "mach_read_from_4(const unsigned char*)"
"xdes_get_descriptor_with_space_hdr(fsp_header_t*,ulint,ulint,mtr_t*)" -> "xdes_calc_descriptor_index(ulint,ulint)"
"xdes_get_descriptor_with_space_hdr(fsp_header_t*,ulint,ulint,mtr_t*)" -> "fsp_flags_get_zip_size(ulint)"
"xdes_get_descriptor_with_space_hdr(fsp_header_t*,ulint,ulint,mtr_t*)" -> "buf_page_get_gen(ulint,ulint,ulint,ulint,buf_block_t*,ulint,const char*,ulint,mtr_t*)"
"xdes_get_descriptor_with_space_hdr(fsp_header_t*,ulint,ulint,mtr_t*)" -> "page_align(const void*)"
"xdes_get_descriptor_with_space_hdr(fsp_header_t*,ulint,ulint,mtr_t*)" -> "xdes_calc_descriptor_page(ulint,ulint)"
"xdes_get_state(const xdes_t*,mtr_t*)" -> "mtr_read_ulint(const unsigned char*,ulint,mtr_t*)"
"xdes_init(xdes_t*,mtr_t*)" -> "mlog_write_ulint(unsigned char*,ulint,unsigned char,mtr_t*)"
"xdes_init(xdes_t*,mtr_t*)" -> "xdes_set_state(xdes_t*,ulint,mtr_t*)"
"xdes_set_state(xdes_t*,ulint,mtr_t*)" -> "mlog_write_ulint(unsigned char*,ulint,unsigned char,mtr_t*)"
"fsp_get_space_header(ulint,ulint,mtr_t*)" -> "buf_page_get_gen(ulint,ulint,ulint,ulint,buf_block_t*,ulint,const char*,ulint,mtr_t*)"
"xdes_is_free(const xdes_t*,mtr_t*)" -> "xdes_get_n_used(const xdes_t*,mtr_t*)"
"flst_remove(flst_base_node_t*,flst_node_t*,mtr_t*)" -> "fil_addr_is_null(fil_addr_t)"
"flst_remove(flst_base_node_t*,flst_node_t*,mtr_t*)" -> "fil_space_get_zip_size(ulint)"
"flst_remove(flst_base_node_t*,flst_node_t*,mtr_t*)" -> "flst_get_len(const flst_base_node_t*,mtr_t*)"
"flst_remove(flst_base_node_t*,flst_node_t*,mtr_t*)" -> "buf_ptr_get_fsp_addr(const void*,ulint*,fil_addr_t*)"
"flst_remove(flst_base_node_t*,flst_node_t*,mtr_t*)" -> "flst_get_next_addr(const flst_node_t*,mtr_t*)"
"flst_remove(flst_base_node_t*,flst_node_t*,mtr_t*)" -> "fut_get_ptr(ulint,ulint,fil_addr_t,ulint,mtr_t*)"
"flst_remove(flst_base_node_t*,flst_node_t*,mtr_t*)" -> "page_align(const void*)"
"flst_remove(flst_base_node_t*,flst_node_t*,mtr_t*)" -> "flst_get_prev_addr(const flst_node_t*,mtr_t*)"
"flst_remove(flst_base_node_t*,flst_node_t*,mtr_t*)" -> "mlog_write_ulint(unsigned char*,ulint,unsigned char,mtr_t*)"
"flst_remove(flst_base_node_t*,flst_node_t*,mtr_t*)" -> "flst_write_addr(fil_faddr_t*,fil_addr_t,mtr_t*)"
"xdes_set_bit(xdes_t*,ulint,ulint,ulint,mtr_t*)" -> "mlog_write_ulint(unsigned char*,ulint,unsigned char,mtr_t*)"
"xdes_set_bit(xdes_t*,ulint,ulint,ulint,mtr_t*)" -> "mtr_read_ulint(const unsigned char*,ulint,mtr_t*)"
"xdes_set_bit(xdes_t*,ulint,ulint,ulint,mtr_t*)" -> "ut_bit_set_nth(ulint,ulint,ulint)"
"btr_search_drop_page_hash_when_freed(ulint,ulint,ulint)" -> "btr_search_drop_page_hash_index(buf_block_t*)"
"btr_search_drop_page_hash_when_freed(ulint,ulint,ulint)" -> "buf_page_get_gen(ulint,ulint,ulint,ulint,buf_block_t*,ulint,const char*,ulint,mtr_t*)"
"btr_search_drop_page_hash_when_freed(ulint,ulint,ulint)" -> "mtr_start(mtr_t*)"
"btr_search_drop_page_hash_when_freed(ulint,ulint,ulint)" -> "mtr_commit(mtr_t*)"
"fseg_set_nth_frag_page_no(fseg_inode_t*,ulint,ulint,mtr_t*)" -> "mlog_write_ulint(unsigned char*,ulint,unsigned char,mtr_t*)"
"xdes_get_descriptor(ulint,ulint,ulint,mtr_t*)" -> "buf_page_get_gen(ulint,ulint,ulint,ulint,buf_block_t*,ulint,const char*,ulint,mtr_t*)"
"xdes_get_descriptor(ulint,ulint,ulint,mtr_t*)" -> "xdes_get_descriptor_with_space_hdr(fsp_header_t*,ulint,ulint,mtr_t*)"
"mtr_x_lock_func(rw_lock_t*,const char*,ulint,mtr_t*)" -> "mtr_memo_push(mtr_t*,void*,ulint)"
"mtr_x_lock_func(rw_lock_t*,const char*,ulint,mtr_t*)" -> "pfs_rw_lock_x_lock_func(rw_lock_t*,ulint,const char*,ulint)"
"mtr_memo_push(mtr_t*,void*,ulint)" -> "dyn_array_push(dyn_array_t*,ulint)"
"mtr_memo_push(mtr_t*,void*,ulint)" -> "mtr_block_dirtied(const buf_block_t*)"
"fsp_free_seg_inode(ulint,ulint,fseg_inode_t*,mtr_t*)" -> "fsp_seg_inode_page_find_free(ib_page_t*,ulint,ulint,mtr_t*)"
"fsp_free_seg_inode(ulint,ulint,fseg_inode_t*,mtr_t*)" -> "page_align(const void*)"
"fsp_free_seg_inode(ulint,ulint,fseg_inode_t*,mtr_t*)" -> "page_get_page_no(const ib_page_t*)"
"fsp_free_seg_inode(ulint,ulint,fseg_inode_t*,mtr_t*)" -> "mlog_write_ull(unsigned char*,ib_uint64_t,mtr_t*)"
"fsp_free_seg_inode(ulint,ulint,fseg_inode_t*,mtr_t*)" -> "fsp_free_page(ulint,ulint,ulint,mtr_t*)"
"fsp_free_seg_inode(ulint,ulint,fseg_inode_t*,mtr_t*)" -> "flst_remove(flst_base_node_t*,flst_node_t*,mtr_t*)"
"fsp_free_seg_inode(ulint,ulint,fseg_inode_t*,mtr_t*)" -> "flst_add_last(flst_base_node_t*,flst_node_t*,mtr_t*)"
"fsp_free_seg_inode(ulint,ulint,fseg_inode_t*,mtr_t*)" -> "fsp_get_space_header(ulint,ulint,mtr_t*)"
"fsp_free_seg_inode(ulint,ulint,fseg_inode_t*,mtr_t*)" -> "fsp_seg_inode_page_find_used(ib_page_t*,ulint,mtr_t*)"
"fsp_free_seg_inode(ulint,ulint,fseg_inode_t*,mtr_t*)" -> "mlog_write_ulint(unsigned char*,ulint,unsigned char,mtr_t*)"
"fsp_seg_inode_page_find_free(ib_page_t*,ulint,ulint,mtr_t*)" -> "fsp_seg_inode_page_get_nth_inode(ib_page_t*,ulint,ulint,mtr_t*)"
"fsp_seg_inode_page_find_free(ib_page_t*,ulint,ulint,mtr_t*)" -> "mach_read_from_8(const unsigned char*)"
"fsp_seg_inode_page_find_used(ib_page_t*,ulint,mtr_t*)" -> "mach_read_from_8(const unsigned char*)"
"fsp_seg_inode_page_find_used(ib_page_t*,ulint,mtr_t*)" -> "fsp_seg_inode_page_get_nth_inode(ib_page_t*,ulint,ulint,mtr_t*)"
"xdes_get_offset(const xdes_t*)" -> "page_offset(const void*)"
"xdes_get_offset(const xdes_t*)" -> "page_align(const void*)"
"xdes_get_offset(const xdes_t*)" -> "page_get_page_no(const ib_page_t*)"
"fseg_free_extent(fseg_inode_t*,ulint,ulint,ulint,mtr_t*)" -> "fsp_free_extent(ulint,ulint,ulint,mtr_t*)"
"fseg_free_extent(fseg_inode_t*,ulint,ulint,ulint,mtr_t*)" -> "xdes_is_free(const xdes_t*,mtr_t*)"
"fseg_free_extent(fseg_inode_t*,ulint,ulint,ulint,mtr_t*)" -> "mtr_read_ulint(const unsigned char*,ulint,mtr_t*)"
"fseg_free_extent(fseg_inode_t*,ulint,ulint,ulint,mtr_t*)" -> "abort()"
"fseg_free_extent(fseg_inode_t*,ulint,ulint,ulint,mtr_t*)" -> "__builtin_expect(long int,long int)"
"fseg_free_extent(fseg_inode_t*,ulint,ulint,ulint,mtr_t*)" -> "xdes_get_state(const xdes_t*,mtr_t*)"
"fseg_free_extent(fseg_inode_t*,ulint,ulint,ulint,mtr_t*)" -> "xdes_get_descriptor(ulint,ulint,ulint,mtr_t*)"
"fseg_free_extent(fseg_inode_t*,ulint,ulint,ulint,mtr_t*)" -> "memcmp(const void*,const void*,size_t)"
"fseg_free_extent(fseg_inode_t*,ulint,ulint,ulint,mtr_t*)" -> "xdes_is_full(const xdes_t*,mtr_t*)"
"fseg_free_extent(fseg_inode_t*,ulint,ulint,ulint,mtr_t*)" -> "xdes_get_n_used(const xdes_t*,mtr_t*)"
"fseg_free_extent(fseg_inode_t*,ulint,ulint,ulint,mtr_t*)" -> "btr_search_drop_page_hash_when_freed(ulint,ulint,ulint)"
"fseg_free_extent(fseg_inode_t*,ulint,ulint,ulint,mtr_t*)" -> "xdes_mtr_get_bit(const xdes_t*,ulint,ulint,mtr_t*)"
"fseg_free_extent(fseg_inode_t*,ulint,ulint,ulint,mtr_t*)" -> "flst_remove(flst_base_node_t*,flst_node_t*,mtr_t*)"
"fseg_free_extent(fseg_inode_t*,ulint,ulint,ulint,mtr_t*)" -> "mlog_write_ulint(unsigned char*,ulint,unsigned char,mtr_t*)"
"fseg_free_extent(fseg_inode_t*,ulint,ulint,ulint,mtr_t*)" -> "ut_dbg_assertion_failed(const char*,const char*,ulint)"
"fseg_find_last_used_frag_page_slot(fseg_inode_t*,mtr_t*)" -> "fseg_get_nth_frag_page_no(fseg_inode_t*,ulint,mtr_t*)"
"fseg_get_first_extent(fseg_inode_t*,ulint,ulint,mtr_t*)" -> "flst_get_first(const flst_base_node_t*,mtr_t*)"
"fseg_get_first_extent(fseg_inode_t*,ulint,ulint,mtr_t*)" -> "xdes_lst_get_descriptor(ulint,ulint,fil_addr_t,mtr_t*)"
"fseg_get_first_extent(fseg_inode_t*,ulint,ulint,mtr_t*)" -> "flst_get_len(const flst_base_node_t*,mtr_t*)"
"xdes_lst_get_descriptor(ulint,ulint,fil_addr_t,mtr_t*)" -> "fut_get_ptr(ulint,ulint,fil_addr_t,ulint,mtr_t*)"
"fseg_inode_try_get(fseg_header_t*,ulint,ulint,mtr_t*)" -> "mach_read_from_4(const unsigned char*)"
"fseg_inode_try_get(fseg_header_t*,ulint,ulint,mtr_t*)" -> "mach_read_from_8(const unsigned char*)"
"fseg_inode_try_get(fseg_header_t*,ulint,ulint,mtr_t*)" -> "fut_get_ptr(ulint,ulint,fil_addr_t,ulint,mtr_t*)"
"fseg_inode_try_get(fseg_header_t*,ulint,ulint,mtr_t*)" -> "__builtin_expect(long int,long int)"
"fseg_inode_try_get(fseg_header_t*,ulint,ulint,mtr_t*)" -> "mach_read_from_2(const unsigned char*)"
"thd_requested_durability(const THD*)" -> "thd_get_durability_property(const THD*)"
"trx_flush_log_if_needed(lsn_t,trx_t*)" -> "trx_flush_log_if_needed_low(lsn_t)"
"trx_flush_log_if_needed_low(lsn_t)" -> "log_write_up_to(lsn_t,ulint,ulint)"
"trx_flush_log_if_needed_low(lsn_t)" -> "abort()"
"trx_flush_log_if_needed_low(lsn_t)" -> "ut_dbg_assertion_failed(const char*,const char*,ulint)"
"log_write_up_to(lsn_t,ulint,ulint)" -> "log_block_set_flush_bit(unsigned char*,ulint)"
"log_write_up_to(lsn_t,ulint,ulint)" -> "os_event_reset(os_event_t)"
"log_write_up_to(lsn_t,ulint,ulint)" -> "log_sys_check_flush_completion()"
"log_write_up_to(lsn_t,ulint,ulint)" -> "ut_memcpy(void*,const void*,ulint)"
"log_write_up_to(lsn_t,ulint,ulint)" -> "os_event_wait_low(os_event_t,ib_int64_t)"
"log_write_up_to(lsn_t,ulint,ulint)" -> "abort()"
"log_write_up_to(lsn_t,ulint,ulint)" -> "log_block_set_checkpoint_no(unsigned char*,ib_uint64_t)"
"log_write_up_to(lsn_t,ulint,ulint)" -> "ut_uint64_align_down(ib_uint64_t,ulint)"
"log_write_up_to(lsn_t,ulint,ulint)" -> "pfs_mutex_enter_func(ib_mutex_t*,const char*,ulint)"
"log_write_up_to(lsn_t,ulint,ulint)" -> "log_group_set_fields(log_group_t*,lsn_t)"
"log_write_up_to(lsn_t,ulint,ulint)" -> "fil_flush(ulint)"
"log_write_up_to(lsn_t,ulint,ulint)" -> "log_group_write_buf(log_group_t*,unsigned char*,ulint,lsn_t,ulint)"
"log_write_up_to(lsn_t,ulint,ulint)" -> "ut_dbg_assertion_failed(const char*,const char*,ulint)"
"log_write_up_to(lsn_t,ulint,ulint)" -> "pfs_mutex_exit_func(ib_mutex_t*)"
"log_write_up_to(lsn_t,ulint,ulint)" -> "log_group_check_flush_completion(log_group_t*)"
"log_write_up_to(lsn_t,ulint,ulint)" -> "log_flush_do_unlocks(ulint)"
"log_write_up_to(lsn_t,ulint,ulint)" -> "__builtin_expect(long int,long int)"
"log_block_set_flush_bit(unsigned char*,ulint)" -> "mach_write_to_4(unsigned char*,ulint)"
"log_block_set_flush_bit(unsigned char*,ulint)" -> "mach_read_from_4(const unsigned char*)"
"log_sys_check_flush_completion()" -> "ut_memmove(void*,const void*,ulint)"
"ut_memmove(void*,const void*,ulint)" -> "memmove(void*,const void*,size_t)"
"log_block_set_checkpoint_no(unsigned char*,ib_uint64_t)" -> "mach_write_to_4(unsigned char*,ulint)"
"log_group_set_fields(log_group_t*,lsn_t)" -> "log_group_calc_lsn_offset(lsn_t,const log_group_t*)"
"log_group_calc_lsn_offset(lsn_t,const log_group_t*)" -> "log_group_calc_real_offset(lsn_t,const log_group_t*)"
"log_group_calc_lsn_offset(lsn_t,const log_group_t*)" -> "log_group_get_capacity(const log_group_t*)"
"log_group_calc_lsn_offset(lsn_t,const log_group_t*)" -> "log_group_calc_size_offset(lsn_t,const log_group_t*)"
"log_group_write_buf(log_group_t*,unsigned char*,ulint,lsn_t,ulint)" -> "ut_dbg_assertion_failed(const char*,const char*,ulint)"
"log_group_write_buf(log_group_t*,unsigned char*,ulint,lsn_t,ulint)" -> "Indexer>::add(Type) [with Type = long unsigned int,int N = 1,Indexer = single_indexer_t]"
"log_group_write_buf(log_group_t*,unsigned char*,ulint,lsn_t,ulint)" -> "log_group_file_header_flush(log_group_t*,ulint,lsn_t)"
"log_group_write_buf(log_group_t*,unsigned char*,ulint,lsn_t,ulint)" -> "Indexer>::inc() [with Type = long unsigned int,int N = 1,Indexer = single_indexer_t]"
"log_group_write_buf(log_group_t*,unsigned char*,ulint,lsn_t,ulint)" -> "Indexer>::inc() [with Type = long int,int N = 1,Indexer = single_indexer_t]"
"log_group_write_buf(log_group_t*,unsigned char*,ulint,lsn_t,ulint)" -> "Indexer>::dec() [with Type = long int,int N = 1,Indexer = single_indexer_t]"
"log_group_write_buf(log_group_t*,unsigned char*,ulint,lsn_t,ulint)" -> "__builtin_expect(long int,long int)"
"log_group_write_buf(log_group_t*,unsigned char*,ulint,lsn_t,ulint)" -> "abort()"
"log_group_write_buf(log_group_t*,unsigned char*,ulint,lsn_t,ulint)" -> "fil_io(ulint,bool,ulint,ulint,ulint,ulint,ulint,void*,void*)"
"log_group_write_buf(log_group_t*,unsigned char*,ulint,lsn_t,ulint)" -> "log_group_calc_lsn_offset(lsn_t,const log_group_t*)"
"log_group_write_buf(log_group_t*,unsigned char*,ulint,lsn_t,ulint)" -> "log_block_store_checksum(unsigned char*)"
"log_group_file_header_flush(log_group_t*,ulint,lsn_t)" -> "fil_io(ulint,bool,ulint,ulint,ulint,ulint,ulint,void*,void*)"
"log_group_file_header_flush(log_group_t*,ulint,lsn_t)" -> "ut_dbg_assertion_failed(const char*,const char*,ulint)"
"log_group_file_header_flush(log_group_t*,ulint,lsn_t)" -> "abort()"
"log_group_file_header_flush(log_group_t*,ulint,lsn_t)" -> "Indexer>::dec() [with Type = long int,int N = 1,Indexer = single_indexer_t]"
"log_group_file_header_flush(log_group_t*,ulint,lsn_t)" -> "mach_write_to_8(void*,ib_uint64_t)"
"log_group_file_header_flush(log_group_t*,ulint,lsn_t)" -> "Indexer>::inc() [with Type = long int,int N = 1,Indexer = single_indexer_t]"
"log_group_file_header_flush(log_group_t*,ulint,lsn_t)" -> "mach_write_to_4(unsigned char*,ulint)"
"log_group_file_header_flush(log_group_t*,ulint,lsn_t)" -> "__builtin_expect(long int,long int)"
"log_group_file_header_flush(log_group_t*,ulint,lsn_t)" -> "memcpy(void*,const void*,size_t)"
"Indexer>::dec() [with Type = long int,int N = 1,Indexer = single_indexer_t]" -> "Indexer>::sub(Type) [with Type = long int,int N = 1,Indexer = single_indexer_t]"
"Indexer>::sub(Type) [with Type = long int,int N = 1,Indexer = single_indexer_t]" -> "N>::offset(size_t) const [with Type = long int,int N = 1,size_t = long unsigned int]"
"Indexer>::sub(Type) [with Type = long int,int N = 1,Indexer = single_indexer_t]" -> "N>::get_rnd_index() const [with Type = long int,int N = 1,size_t = long unsigned int]"
"Indexer>::inc() [with Type = long int,int N = 1,Indexer = single_indexer_t]" -> "Indexer>::add(Type) [with Type = long int,int N = 1,Indexer = single_indexer_t]"
"Indexer>::add(Type) [with Type = long int,int N = 1,Indexer = single_indexer_t]" -> "N>::offset(size_t) const [with Type = long int,int N = 1,size_t = long unsigned int]"
"Indexer>::add(Type) [with Type = long int,int N = 1,Indexer = single_indexer_t]" -> "N>::get_rnd_index() const [with Type = long int,int N = 1,size_t = long unsigned int]"
"log_block_store_checksum(unsigned char*)" -> "log_block_calc_checksum(const unsigned char*)"
"log_block_store_checksum(unsigned char*)" -> "log_block_set_checksum(unsigned char*,ulint)"
"log_block_set_checksum(unsigned char*,ulint)" -> "mach_write_to_4(unsigned char*,ulint)"
"log_flush_do_unlocks(ulint)" -> "os_event_set(os_event_t)"
"fts_commit(trx_t*)" -> "rbt_next(const ib_rbt_t*,const ib_rbt_node_t*)"
"fts_commit(trx_t*)" -> "rbt_first(const ib_rbt_t*)"
"fts_commit(trx_t*)" -> "ib_vector_last(ib_vector_t*)"
"fts_commit(trx_t*)" -> "fts_commit_table(fts_trx_table_t*)"
"fts_commit_table(fts_trx_table_t*)" -> "ut_dbg_assertion_failed(const char*,const char*,ulint)"
"fts_commit_table(fts_trx_table_t*)" -> "pfs_rw_lock_x_unlock_func(rw_lock_t*)"
"fts_commit_table(fts_trx_table_t*)" -> "abort()"
"fts_commit_table(fts_trx_table_t*)" -> "rbt_first(const ib_rbt_t*)"
"fts_commit_table(fts_trx_table_t*)" -> "fts_delete(fts_trx_table_t*,fts_trx_row_t*)"
"fts_commit_table(fts_trx_table_t*)" -> "fts_get_docs_create(fts_cache_t*)"
"fts_commit_table(fts_trx_table_t*)" -> "fts_add(fts_trx_table_t*,fts_trx_row_t*)"
"fts_commit_table(fts_trx_table_t*)" -> "trx_allocate_for_background()"
"fts_commit_table(fts_trx_table_t*)" -> "pfs_rw_lock_x_lock_func(rw_lock_t*,ulint,const char*,ulint)"
"fts_commit_table(fts_trx_table_t*)" -> "trx_free_for_background(trx_t*)"
"fts_commit_table(fts_trx_table_t*)" -> "fts_sql_commit(trx_t*)"
"fts_commit_table(fts_trx_table_t*)" -> "rbt_next(const ib_rbt_t*,const ib_rbt_node_t*)"
"fts_commit_table(fts_trx_table_t*)" -> "fts_modify(fts_trx_table_t*,fts_trx_row_t*)"
"fts_delete(fts_trx_table_t*,fts_trx_row_t*)" -> "que_graph_free(que_t*)"
"fts_delete(fts_trx_table_t*,fts_trx_row_t*)" -> "mach_write_to_8(void*,ib_uint64_t)"
"fts_delete(fts_trx_table_t*,fts_trx_row_t*)" -> "pars_info_free(pars_info_t*)"
"fts_delete(fts_trx_table_t*,fts_trx_row_t*)" -> "ut_dbg_assertion_failed(const char*,const char*,ulint)"
"fts_delete(fts_trx_table_t*,fts_trx_row_t*)" -> "fts_parse_sql(fts_table_t*,pars_info_t*,const char*)"
"fts_delete(fts_trx_table_t*,fts_trx_row_t*)" -> "abort()"
"fts_delete(fts_trx_table_t*,fts_trx_row_t*)" -> "__builtin_expect(long int,long int)"
"fts_delete(fts_trx_table_t*,fts_trx_row_t*)" -> "pars_info_bind_int8_literal(pars_info_t*,const char*,const ib_uint64_t*)"
"fts_delete(fts_trx_table_t*,fts_trx_row_t*)" -> "fts_eval_sql(trx_t*,que_t*)"
"fts_delete(fts_trx_table_t*,fts_trx_row_t*)" -> "pars_info_create()"
"fts_delete(fts_trx_table_t*,fts_trx_row_t*)" -> "pfs_mutex_enter_func(ib_mutex_t*,const char*,ulint)"
"fts_delete(fts_trx_table_t*,fts_trx_row_t*)" -> "pfs_mutex_exit_func(ib_mutex_t*)"
"pars_info_free(pars_info_t*)" -> "mem_heap_free_func(mem_heap_t*,const char*,ulint)"
"fts_parse_sql(fts_table_t*,pars_info_t*,const char*)" -> "strlen(const char*)"
"fts_parse_sql(fts_table_t*,pars_info_t*,const char*)" -> "ut_dbg_assertion_failed(const char*,const char*,ulint)"
"fts_parse_sql(fts_table_t*,pars_info_t*,const char*)" -> "ut_str3cat(const char*,const char*,const char*)"
"fts_parse_sql(fts_table_t*,pars_info_t*,const char*)" -> "mem_alloc_func(ulint,ulint*)"
"fts_parse_sql(fts_table_t*,pars_info_t*,const char*)" -> "__builtin_expect(long int,long int)"
"fts_parse_sql(fts_table_t*,pars_info_t*,const char*)" -> "strcpy(char*,const char*)"
"fts_parse_sql(fts_table_t*,pars_info_t*,const char*)" -> "pfs_mutex_exit_func(ib_mutex_t*)"
"fts_parse_sql(fts_table_t*,pars_info_t*,const char*)" -> "fts_get_table_name(const fts_table_t*)"
"fts_parse_sql(fts_table_t*,pars_info_t*,const char*)" -> "ut_strreplace(const char*,const char*,const char*)"
"fts_parse_sql(fts_table_t*,pars_info_t*,const char*)" -> "pfs_mutex_enter_func(ib_mutex_t*,const char*,ulint)"
"fts_parse_sql(fts_table_t*,pars_info_t*,const char*)" -> "mem_free_func(void*,const char*,ulint)"
"fts_parse_sql(fts_table_t*,pars_info_t*,const char*)" -> "abort()"
"fts_parse_sql(fts_table_t*,pars_info_t*,const char*)" -> "pars_sql(pars_info_t*,const char*)"
"ut_str3cat(const char*,const char*,const char*)" -> "memcpy(void*,const void*,size_t)"
"ut_str3cat(const char*,const char*,const char*)" -> "mem_alloc_func(ulint,ulint*)"
"ut_str3cat(const char*,const char*,const char*)" -> "strlen(const char*)"
"fts_get_table_name(const fts_table_t*)" -> "strlen(const char*)"
"fts_get_table_name(const fts_table_t*)" -> "sprintf(char*,const char*,...)"
"fts_get_table_name(const fts_table_t*)" -> "abort()"
"fts_get_table_name(const fts_table_t*)" -> "fts_get_table_name_prefix(const fts_table_t*)"
"fts_get_table_name(const fts_table_t*)" -> "ut_dbg_assertion_failed(const char*,const char*,ulint)"
"fts_get_table_name(const fts_table_t*)" -> "mem_free_func(void*,const char*,ulint)"
"fts_get_table_name(const fts_table_t*)" -> "__builtin_expect(long int,long int)"
"fts_get_table_name(const fts_table_t*)" -> "mem_alloc_func(ulint,ulint*)"
"fts_get_table_name_prefix(const fts_table_t*)" -> "abort()"
"fts_get_table_name_prefix(const fts_table_t*)" -> "memchr(const void*,int,size_t)"
"fts_get_table_name_prefix(const fts_table_t*)" -> "mem_alloc_func(ulint,ulint*)"
"fts_get_table_name_prefix(const fts_table_t*)" -> "sprintf(char*,const char*,...)"
"fts_get_table_name_prefix(const fts_table_t*)" -> "__builtin_expect(long int,long int)"
"fts_get_table_name_prefix(const fts_table_t*)" -> "strlen(const char*)"
"fts_get_table_name_prefix(const fts_table_t*)" -> "fts_get_table_id(const fts_table_t*,char*)"
"fts_get_table_name_prefix(const fts_table_t*)" -> "ut_dbg_assertion_failed(const char*,const char*,ulint)"
"memchr(const void*,int,size_t)" -> "__builtin_memchr(const void*,int,long unsigned int)"
"fts_get_table_id(const fts_table_t*,char*)" -> "ut_dbg_assertion_failed(const char*,const char*,ulint)"
"fts_get_table_id(const fts_table_t*,char*)" -> "fts_write_object_id(ib_id_t,char*,bool)"
"fts_get_table_id(const fts_table_t*,char*)" -> "abort()"
"fts_get_table_id(const fts_table_t*,char*)" -> "__builtin_expect(long int,long int)"
"fts_write_object_id(ib_id_t,char*,bool)" -> "sprintf(char*,const char*,...)"
"ut_strreplace(const char*,const char*,const char*)" -> "strlen(const char*)"
"ut_strreplace(const char*,const char*,const char*)" -> "mem_alloc_func(ulint,ulint*)"
"ut_strreplace(const char*,const char*,const char*)" -> "ut_strcount(const char*,const char*)"
"ut_strreplace(const char*,const char*,const char*)" -> "memcpy(void*,const void*,size_t)"
"ut_strreplace(const char*,const char*,const char*)" -> "strstr(const char*,const char*)"
"ut_strcount(const char*,const char*)" -> "strstr(const char*,const char*)"
"ut_strcount(const char*,const char*)" -> "strlen(const char*)"
"strstr(const char*,const char*)" -> "__builtin_strstr(const char*,const char*)"
"pars_sql(pars_info_t*,const char*)" -> "abort()"
"pars_sql(pars_info_t*,const char*)" -> "ut_dbg_assertion_failed(const char*,const char*,ulint)"
"pars_sql(pars_info_t*,const char*)" -> "mem_heap_dup(mem_heap_t*,const void*,ulint)"
"pars_sql(pars_info_t*,const char*)" -> "yyparse()"
"pars_sql(pars_info_t*,const char*)" -> "mem_heap_create_func(ulint,ulint)"
"pars_sql(pars_info_t*,const char*)" -> "__builtin_expect(long int,long int)"
"pars_sql(pars_info_t*,const char*)" -> "sym_tab_create(mem_heap_t*)"
"pars_sql(pars_info_t*,const char*)" -> "strlen(const char*)"
"yyparse()" -> "free(void*)"
"yyparse()" -> "que_node_list_add_last(que_node_t*,que_node_t*)"
"yyparse()" -> "pars_parameter_declaration(sym_node_t*,ulint,pars_res_word_t*)"
"yyparse()" -> "pars_update_statement(upd_node_t*,sym_node_t*,que_node_t*)"
"yyparse()" -> "pars_function_declaration(sym_node_t*)"
"yyparse()" -> "pars_select_list(que_node_t*,sym_node_t*)"
"yyparse()" -> "pars_open_statement(ulint,sym_node_t*)"
"yyparse()" -> "pars_stored_procedure_call(sym_node_t*)"
"yyparse()" -> "pars_rollback_statement()"
"yyparse()" -> "pars_return_statement()"
"yyparse()" -> "pars_column_assignment(sym_node_t*,que_node_t*)"
"yyparse()" -> "pars_order_by(sym_node_t*,pars_res_word_t*)"
"yyparse()" -> "pars_insert_statement(sym_node_t*,que_node_t*,sel_node_t*)"
"yyparse()" -> "yylex()"
"yyparse()" -> "pars_if_statement(que_node_t*,que_node_t*,que_node_t*)"
"yyparse()" -> "pars_assignment_statement(sym_node_t*,que_node_t*)"
"yyparse()" -> "pars_procedure_call(que_node_t*,que_node_t*)"
"yyparse()" -> "pars_procedure_definition(sym_node_t*,sym_node_t*,que_node_t*)"
"yyparse()" -> "pars_for_statement(sym_node_t*,que_node_t*,que_node_t*,que_node_t*)"
"yyparse()" -> "pars_commit_statement()"
"yyparse()" -> "pars_row_printf_statement(sel_node_t*)"
"yyparse()" -> "pars_select_statement(sel_node_t*,sym_node_t*,que_node_t*,pars_res_word_t*,pars_res_word_t*,order_node_t*)"
"yyparse()" -> "pars_cursor_declaration(sym_node_t*,sel_node_t*)"
"yyparse()" -> "pars_variable_declaration(sym_node_t*,pars_res_word_t*)"
"yyparse()" -> "pars_create_table(sym_node_t*,sym_node_t*,sym_node_t*,sym_node_t*,void*)"
"yyparse()" -> "pars_op(int,que_node_t*,que_node_t*)"
"yyparse()" -> "pars_fetch_statement(sym_node_t*,sym_node_t*,sym_node_t*)"
"yyparse()" -> "pars_column_def(sym_node_t*,pars_res_word_t*,sym_node_t*,void*,void*)"
"yyparse()" -> "pars_while_statement(que_node_t*,que_node_t*)"
"yyparse()" -> "pars_create_index(pars_res_word_t*,pars_res_word_t*,sym_node_t*,sym_node_t*,sym_node_t*)"
"yyparse()" -> "yydestruct(const char*,int,que_node_t**)"
"yyparse()" -> "pars_elsif_element(que_node_t*,que_node_t*)"
"yyparse()" -> "pars_update_statement_start(ulint,sym_node_t*,col_assign_node_t*)"
"yyparse()" -> "yyerror(const char*)"
"yyparse()" -> "pars_exit_statement()"
"yyparse()" -> "pars_func(que_node_t*,que_node_t*)"
"yyparse()" -> "sym_tab_add_int_lit(sym_tab_t*,ulint)"
"pars_parameter_declaration(sym_node_t*,ulint,pars_res_word_t*)" -> "abort()"
"pars_parameter_declaration(sym_node_t*,ulint,pars_res_word_t*)" -> "__builtin_expect(long int,long int)"
"pars_parameter_declaration(sym_node_t*,ulint,pars_res_word_t*)" -> "ut_dbg_assertion_failed(const char*,const char*,ulint)"
"pars_parameter_declaration(sym_node_t*,ulint,pars_res_word_t*)" -> "pars_variable_declaration(sym_node_t*,pars_res_word_t*)"
"pars_variable_declaration(sym_node_t*,pars_res_word_t*)" -> "pars_set_dfield_type(dfield_t*,pars_res_word_t*,ulint,ulint,ulint)"
"pars_variable_declaration(sym_node_t*,pars_res_word_t*)" -> "que_node_get_val(que_node_t*)"
"pars_set_dfield_type(dfield_t*,pars_res_word_t*,ulint,ulint,ulint)" -> "__builtin_expect(long int,long int)"
"pars_set_dfield_type(dfield_t*,pars_res_word_t*,ulint,ulint,ulint)" -> "dtype_set(dtype_t*,ulint,ulint,ulint)"
"pars_set_dfield_type(dfield_t*,pars_res_word_t*,ulint,ulint,ulint)" -> "ut_dbg_assertion_failed(const char*,const char*,ulint)"
"pars_set_dfield_type(dfield_t*,pars_res_word_t*,ulint,ulint,ulint)" -> "abort()"
"pars_update_statement(upd_node_t*,sym_node_t*,que_node_t*)" -> "__builtin_expect(long int,long int)"
"pars_update_statement(upd_node_t*,sym_node_t*,que_node_t*)" -> "pars_process_assign_list(upd_node_t*)"
"pars_update_statement(upd_node_t*,sym_node_t*,que_node_t*)" -> "sel_node_get_nth_plan(sel_node_t*,ulint)"
"pars_update_statement(upd_node_t*,sym_node_t*,que_node_t*)" -> "pars_select_list(que_node_t*,sym_node_t*)"
"pars_update_statement(upd_node_t*,sym_node_t*,que_node_t*)" -> "que_node_list_add_last(que_node_t*,que_node_t*)"
"pars_update_statement(upd_node_t*,sym_node_t*,que_node_t*)" -> "pars_select_statement(sel_node_t*,sym_node_t*,que_node_t*,pars_res_word_t*,pars_res_word_t*,order_node_t*)"
"pars_update_statement(upd_node_t*,sym_node_t*,que_node_t*)" -> "pars_retrieve_table_def(sym_node_t*)"
"pars_update_statement(upd_node_t*,sym_node_t*,que_node_t*)" -> "dict_index_is_clust(const dict_index_t*)"
"pars_update_statement(upd_node_t*,sym_node_t*,que_node_t*)" -> "abort()"
"pars_update_statement(upd_node_t*,sym_node_t*,que_node_t*)" -> "pars_resolve_exp_variables_and_types(sel_node_t*,que_node_t*)"
"pars_update_statement(upd_node_t*,sym_node_t*,que_node_t*)" -> "ut_dbg_assertion_failed(const char*,const char*,ulint)"
"pars_process_assign_list(upd_node_t*)" -> "pars_resolve_exp_columns(sym_node_t*,que_node_t*)"
"pars_process_assign_list(upd_node_t*)" -> "dict_table_is_comp(const dict_table_t*)"
"pars_process_assign_list(upd_node_t*)" -> "que_node_get_next(que_node_t*)"
"pars_process_assign_list(upd_node_t*)" -> "opt_find_all_cols(ulint,dict_index_t*,sym_node_list_t*,plan_t*,que_node_t*)"
"pars_process_assign_list(upd_node_t*)" -> "upd_create(ulint,mem_heap_t*)"
"pars_process_assign_list(upd_node_t*)" -> "dict_col_get_fixed_size(const dict_col_t*,ulint)"
"pars_process_assign_list(upd_node_t*)" -> "dict_index_get_nth_col(const dict_index_t*,ulint)"
"pars_process_assign_list(upd_node_t*)" -> "pars_resolve_exp_variables_and_types(sel_node_t*,que_node_t*)"
"pars_process_assign_list(upd_node_t*)" -> "upd_field_set_field_no(upd_field_t*,ulint,dict_index_t*,trx_t*)"
"pars_process_assign_list(upd_node_t*)" -> "row_upd_changes_some_index_ord_field_binary(const dict_table_t*,const upd_t*)"
"pars_process_assign_list(upd_node_t*)" -> "dict_index_get_nth_col_pos(const dict_index_t*,ulint)"
"pars_resolve_exp_columns(sym_node_t*,que_node_t*)" -> "ut_strlen(const char*)"
"pars_resolve_exp_columns(sym_node_t*,que_node_t*)" -> "dict_table_get_col_name(const dict_table_t*,ulint)"
"pars_resolve_exp_columns(sym_node_t*,que_node_t*)" -> "que_node_get_type(que_node_t*)"
"pars_resolve_exp_columns(sym_node_t*,que_node_t*)" -> "dict_col_copy_type(const dict_col_t*,dtype_t*)"
"pars_resolve_exp_columns(sym_node_t*,que_node_t*)" -> "ut_dbg_assertion_failed(const char*,const char*,ulint)"
"pars_resolve_exp_columns(sym_node_t*,que_node_t*)" -> "ut_memcmp(const void*,const void*,ulint)"
"pars_resolve_exp_columns(sym_node_t*,que_node_t*)" -> "pars_resolve_exp_columns(sym_node_t*,que_node_t*)"
"pars_resolve_exp_columns(sym_node_t*,que_node_t*)" -> "abort()"
"pars_resolve_exp_columns(sym_node_t*,que_node_t*)" -> "que_node_get_next(que_node_t*)"
"pars_resolve_exp_columns(sym_node_t*,que_node_t*)" -> "__builtin_expect(long int,long int)"
"pars_resolve_exp_columns(sym_node_t*,que_node_t*)" -> "dict_table_get_n_cols(const dict_table_t*)"
"dict_table_get_col_name(const dict_table_t*,ulint)" -> "strlen(const char*)"
"ut_memcmp(const void*,const void*,ulint)" -> "memcmp(const void*,const void*,size_t)"
"opt_find_all_cols(ulint,dict_index_t*,sym_node_list_t*,plan_t*,que_node_t*)" -> "que_node_get_type(que_node_t*)"
"opt_find_all_cols(ulint,dict_index_t*,sym_node_list_t*,plan_t*,que_node_t*)" -> "que_node_get_next(que_node_t*)"
"opt_find_all_cols(ulint,dict_index_t*,sym_node_list_t*,plan_t*,que_node_t*)" -> "ut_list_append(List&,Type&,size_t) [with List = ut_list_base<sym_node_t>,Type = sym_node_t,size_t = long unsigned int]"
"opt_find_all_cols(ulint,dict_index_t*,sym_node_list_t*,plan_t*,que_node_t*)" -> "opt_find_all_cols(ulint,dict_index_t*,sym_node_list_t*,plan_t*,que_node_t*)"
"opt_find_all_cols(ulint,dict_index_t*,sym_node_list_t*,plan_t*,que_node_t*)" -> "__builtin_expect(long int,long int)"
"opt_find_all_cols(ulint,dict_index_t*,sym_node_list_t*,plan_t*,que_node_t*)" -> "dict_index_is_clust(const dict_index_t*)"
"opt_find_all_cols(ulint,dict_index_t*,sym_node_list_t*,plan_t*,que_node_t*)" -> "abort()"
"opt_find_all_cols(ulint,dict_index_t*,sym_node_list_t*,plan_t*,que_node_t*)" -> "dict_index_get_nth_col_pos(const dict_index_t*,ulint)"
"opt_find_all_cols(ulint,dict_index_t*,sym_node_list_t*,plan_t*,que_node_t*)" -> "ut_dbg_assertion_failed(const char*,const char*,ulint)"
"ut_list_append(List&,Type&,size_t) [with List = ut_list_base<sym_node_t>,Type = sym_node_t,size_t = long unsigned int]" -> "ut_elem_get_node(Type&,size_t) [with Type = sym_node_t,size_t = long unsigned int]"
"ut_elem_get_node(Type&,size_t) [with Type = sym_node_t,size_t = long unsigned int]" -> "abort()"
"ut_elem_get_node(Type&,size_t) [with Type = sym_node_t,size_t = long unsigned int]" -> "__builtin_expect(long int,long int)"
"ut_elem_get_node(Type&,size_t) [with Type = sym_node_t,size_t = long unsigned int]" -> "ut_dbg_assertion_failed(const char*,const char*,ulint)"
"upd_create(ulint,mem_heap_t*)" -> "mem_heap_zalloc(mem_heap_t*,ulint)"
"dict_index_get_nth_col(const dict_index_t*,ulint)" -> "dict_field_get_col(const dict_field_t*)"
"pars_resolve_exp_variables_and_types(sel_node_t*,que_node_t*)" -> "__builtin_expect(long int,long int)"
"pars_resolve_exp_variables_and_types(sel_node_t*,que_node_t*)" -> "dfield_set_type(dfield_t*,const dtype_t*)"
"pars_resolve_exp_variables_and_types(sel_node_t*,que_node_t*)" -> "pars_resolve_exp_variables_and_types(sel_node_t*,que_node_t*)"
"pars_resolve_exp_variables_and_types(sel_node_t*,que_node_t*)" -> "que_node_get_type(que_node_t*)"
"pars_resolve_exp_variables_and_types(sel_node_t*,que_node_t*)" -> "ut_dbg_assertion_failed(const char*,const char*,ulint)"
"pars_resolve_exp_variables_and_types(sel_node_t*,que_node_t*)" -> "abort()"
"pars_resolve_exp_variables_and_types(sel_node_t*,que_node_t*)" -> "ut_memcmp(const void*,const void*,ulint)"
"pars_resolve_exp_variables_and_types(sel_node_t*,que_node_t*)" -> "que_node_get_data_type(que_node_t*)"
"pars_resolve_exp_variables_and_types(sel_node_t*,que_node_t*)" -> "que_node_get_val(que_node_t*)"
"pars_resolve_exp_variables_and_types(sel_node_t*,que_node_t*)" -> "ut_list_append(List&,Type&,size_t) [with List = ut_list_base<sym_node_t>,Type = sym_node_t,size_t = long unsigned int]"
"pars_resolve_exp_variables_and_types(sel_node_t*,que_node_t*)" -> "fprintf(FILE*,const char*,...)"
"pars_resolve_exp_variables_and_types(sel_node_t*,que_node_t*)" -> "pars_resolve_func_data_type(func_node_t*)"
"pars_resolve_exp_variables_and_types(sel_node_t*,que_node_t*)" -> "que_node_get_next(que_node_t*)"
"pars_resolve_func_data_type(func_node_t*)" -> "ut_dbg_assertion_failed(const char*,const char*,ulint)"
"pars_resolve_func_data_type(func_node_t*)" -> "que_node_get_type(que_node_t*)"
"pars_resolve_func_data_type(func_node_t*)" -> "dtype_copy(dtype_t*,const dtype_t*)"
"pars_resolve_func_data_type(func_node_t*)" -> "__builtin_expect(long int,long int)"
"pars_resolve_func_data_type(func_node_t*)" -> "pars_is_string_type(ulint)"
"pars_resolve_func_data_type(func_node_t*)" -> "dtype_set(dtype_t*,ulint,ulint,ulint)"
"pars_resolve_func_data_type(func_node_t*)" -> "abort()"
"pars_resolve_func_data_type(func_node_t*)" -> "que_node_get_data_type(que_node_t*)"
"pars_resolve_func_data_type(func_node_t*)" -> "dtype_get_mtype(const dtype_t*)"
"upd_field_set_field_no(upd_field_t*,ulint,dict_index_t*,trx_t*)" -> "fprintf(FILE*,const char*,...)"
"upd_field_set_field_no(upd_field_t*,ulint,dict_index_t*,trx_t*)" -> "dict_index_get_nth_col(const dict_index_t*,ulint)"
"upd_field_set_field_no(upd_field_t*,ulint,dict_index_t*,trx_t*)" -> "dict_col_copy_type(const dict_col_t*,dtype_t*)"
"upd_field_set_field_no(upd_field_t*,ulint,dict_index_t*,trx_t*)" -> "dict_index_name_print(FILE*,const trx_t*,const dict_index_t*)"
"upd_field_set_field_no(upd_field_t*,ulint,dict_index_t*,trx_t*)" -> "dict_index_get_n_fields(const dict_index_t*)"
"row_upd_changes_some_index_ord_field_binary(const dict_table_t*,const upd_t*)" -> "upd_get_n_fields(const upd_t*)"
"row_upd_changes_some_index_ord_field_binary(const dict_table_t*,const upd_t*)" -> "dict_field_get_col(const dict_field_t*)"
"pars_select_list(que_node_t*,sym_node_t*)" -> "sel_node_create(mem_heap_t*)"
"pars_select_list(que_node_t*,sym_node_t*)" -> "pars_resolve_exp_list_variables_and_types(sel_node_t*,que_node_t*)"
"sel_node_create(mem_heap_t*)" -> "mem_heap_alloc(mem_heap_t*,ulint)"
"pars_resolve_exp_list_variables_and_types(sel_node_t*,que_node_t*)" -> "pars_resolve_exp_variables_and_types(sel_node_t*,que_node_t*)"
"pars_resolve_exp_list_variables_and_types(sel_node_t*,que_node_t*)" -> "que_node_get_next(que_node_t*)"
"pars_select_statement(sel_node_t*,sym_node_t*,que_node_t*,pars_res_word_t*,pars_res_word_t*,order_node_t*)" -> "ut_dbg_assertion_failed(const char*,const char*,ulint)"
"pars_select_statement(sel_node_t*,sym_node_t*,que_node_t*,pars_res_word_t*,pars_res_word_t*,order_node_t*)" -> "opt_search_plan(sel_node_t*)"
"pars_select_statement(sel_node_t*,sym_node_t*,que_node_t*,pars_res_word_t*,pars_res_word_t*,order_node_t*)" -> "abort()"
"pars_select_statement(sel_node_t*,sym_node_t*,que_node_t*,pars_res_word_t*,pars_res_word_t*,order_node_t*)" -> "que_node_list_get_len(que_node_t*)"
"pars_select_statement(sel_node_t*,sym_node_t*,que_node_t*,pars_res_word_t*,pars_res_word_t*,order_node_t*)" -> "pars_resolve_exp_variables_and_types(sel_node_t*,que_node_t*)"
"pars_select_statement(sel_node_t*,sym_node_t*,que_node_t*,pars_res_word_t*,pars_res_word_t*,order_node_t*)" -> "__builtin_expect(long int,long int)"
"pars_select_statement(sel_node_t*,sym_node_t*,que_node_t*,pars_res_word_t*,pars_res_word_t*,order_node_t*)" -> "pars_resolve_exp_list_columns(sym_node_t*,que_node_t*)"
"pars_select_statement(sel_node_t*,sym_node_t*,que_node_t*,pars_res_word_t*,pars_res_word_t*,order_node_t*)" -> "pars_select_all_columns(sel_node_t*)"
"pars_select_statement(sel_node_t*,sym_node_t*,que_node_t*,pars_res_word_t*,pars_res_word_t*,order_node_t*)" -> "pars_resolve_exp_list_variables_and_types(sel_node_t*,que_node_t*)"
"pars_select_statement(sel_node_t*,sym_node_t*,que_node_t*,pars_res_word_t*,pars_res_word_t*,order_node_t*)" -> "pars_check_aggregate(sel_node_t*)"
"pars_select_statement(sel_node_t*,sym_node_t*,que_node_t*,pars_res_word_t*,pars_res_word_t*,order_node_t*)" -> "pars_resolve_exp_columns(sym_node_t*,que_node_t*)"
"pars_select_statement(sel_node_t*,sym_node_t*,que_node_t*,pars_res_word_t*,pars_res_word_t*,order_node_t*)" -> "pars_retrieve_table_list_defs(sym_node_t*)"
"opt_search_plan(sel_node_t*)" -> "opt_check_order_by(sel_node_t*)"
"opt_search_plan(sel_node_t*)" -> "opt_classify_cols(sel_node_t*,ulint)"
"opt_search_plan(sel_node_t*)" -> "opt_determine_and_normalize_test_conds(sel_node_t*,ulint)"
"opt_search_plan(sel_node_t*)" -> "que_node_get_next(que_node_t*)"
"opt_search_plan(sel_node_t*)" -> "opt_clust_access(sel_node_t*,ulint)"
"opt_search_plan(sel_node_t*)" -> "mem_heap_alloc(mem_heap_t*,ulint)"
"opt_search_plan(sel_node_t*)" -> "opt_search_plan_for_table(sel_node_t*,ulint,dict_table_t*)"
"opt_check_order_by(sel_node_t*)" -> "ut_dbg_assertion_failed(const char*,const char*,ulint)"
"opt_check_order_by(sel_node_t*)" -> "__builtin_expect(long int,long int)"
"opt_check_order_by(sel_node_t*)" -> "abort()"
"opt_check_order_by(sel_node_t*)" -> "sel_node_get_nth_plan(sel_node_t*,ulint)"
"opt_check_order_by(sel_node_t*)" -> "dict_index_get_nth_col_no(const dict_index_t*,ulint)"
"opt_check_order_by(sel_node_t*)" -> "dict_index_get_n_unique(const dict_index_t*)"
"dict_index_get_nth_col_no(const dict_index_t*,ulint)" -> "dict_index_get_nth_col(const dict_index_t*,ulint)"
"dict_index_get_nth_col_no(const dict_index_t*,ulint)" -> "dict_col_get_no(const dict_col_t*)"
"opt_classify_cols(sel_node_t*,ulint)" -> "que_node_get_next(que_node_t*)"
"opt_classify_cols(sel_node_t*,ulint)" -> "opt_find_copy_cols(sel_node_t*,ulint,func_node_t*)"
"opt_classify_cols(sel_node_t*,ulint)" -> "opt_find_all_cols(ulint,dict_index_t*,sym_node_list_t*,plan_t*,que_node_t*)"
"opt_classify_cols(sel_node_t*,ulint)" -> "sel_node_get_nth_plan(sel_node_t*,ulint)"
"opt_find_copy_cols(sel_node_t*,ulint,func_node_t*)" -> "opt_check_exp_determined_before(que_node_t*,sel_node_t*,ulint)"
"opt_find_copy_cols(sel_node_t*,ulint,func_node_t*)" -> "que_node_get_next(que_node_t*)"
"opt_find_copy_cols(sel_node_t*,ulint,func_node_t*)" -> "opt_find_copy_cols(sel_node_t*,ulint,func_node_t*)"
"opt_find_copy_cols(sel_node_t*,ulint,func_node_t*)" -> "opt_find_all_cols(ulint,dict_index_t*,sym_node_list_t*,plan_t*,que_node_t*)"
"opt_find_copy_cols(sel_node_t*,ulint,func_node_t*)" -> "sel_node_get_nth_plan(sel_node_t*,ulint)"
"opt_check_exp_determined_before(que_node_t*,sel_node_t*,ulint)" -> "ut_dbg_assertion_failed(const char*,const char*,ulint)"
"opt_check_exp_determined_before(que_node_t*,sel_node_t*,ulint)" -> "opt_check_exp_determined_before(que_node_t*,sel_node_t*,ulint)"
"opt_check_exp_determined_before(que_node_t*,sel_node_t*,ulint)" -> "que_node_get_type(que_node_t*)"
"opt_check_exp_determined_before(que_node_t*,sel_node_t*,ulint)" -> "que_node_get_next(que_node_t*)"
"opt_check_exp_determined_before(que_node_t*,sel_node_t*,ulint)" -> "__builtin_expect(long int,long int)"
"opt_check_exp_determined_before(que_node_t*,sel_node_t*,ulint)" -> "abort()"
"opt_check_exp_determined_before(que_node_t*,sel_node_t*,ulint)" -> "sel_node_get_nth_plan(sel_node_t*,ulint)"
"opt_determine_and_normalize_test_conds(sel_node_t*,ulint)" -> "opt_normalize_cmp_conds(func_node_t*,dict_table_t*)"
"opt_determine_and_normalize_test_conds(sel_node_t*,ulint)" -> "__builtin_expect(long int,long int)"
"opt_determine_and_normalize_test_conds(sel_node_t*,ulint)" -> "abort()"
"opt_determine_and_normalize_test_conds(sel_node_t*,ulint)" -> "ut_dbg_assertion_failed(const char*,const char*,ulint)"
"opt_determine_and_normalize_test_conds(sel_node_t*,ulint)" -> "sel_node_get_nth_plan(sel_node_t*,ulint)"
"opt_determine_and_normalize_test_conds(sel_node_t*,ulint)" -> "opt_find_test_conds(sel_node_t*,ulint,func_node_t*)"
"opt_normalize_cmp_conds(func_node_t*,dict_table_t*)" -> "que_node_list_add_last(que_node_t*,que_node_t*)"
"opt_normalize_cmp_conds(func_node_t*,dict_table_t*)" -> "opt_invert_cmp_op(int)"
"opt_normalize_cmp_conds(func_node_t*,dict_table_t*)" -> "que_node_get_type(que_node_t*)"
"opt_normalize_cmp_conds(func_node_t*,dict_table_t*)" -> "que_node_get_next(que_node_t*)"
"opt_invert_cmp_op(int)" -> "ut_dbg_assertion_failed(const char*,const char*,ulint)"
"opt_invert_cmp_op(int)" -> "abort()"
"opt_find_test_conds(sel_node_t*,ulint,func_node_t*)" -> "ut_list_append(List&,Type&,size_t) [with List = ut_list_base<func_node_t>,Type = func_node_t,size_t = long unsigned int]"
"opt_find_test_conds(sel_node_t*,ulint,func_node_t*)" -> "opt_classify_comparison(sel_node_t*,ulint,func_node_t*)"
"opt_find_test_conds(sel_node_t*,ulint,func_node_t*)" -> "sel_node_get_nth_plan(sel_node_t*,ulint)"
"opt_find_test_conds(sel_node_t*,ulint,func_node_t*)" -> "opt_find_test_conds(sel_node_t*,ulint,func_node_t*)"
"opt_find_test_conds(sel_node_t*,ulint,func_node_t*)" -> "que_node_get_next(que_node_t*)"
"ut_list_append(List&,Type&,size_t) [with List = ut_list_base<func_node_t>,Type = func_node_t,size_t = long unsigned int]" -> "ut_elem_get_node(Type&,size_t) [with Type = func_node_t,size_t = long unsigned int]"
"ut_elem_get_node(Type&,size_t) [with Type = func_node_t,size_t = long unsigned int]" -> "abort()"
"ut_elem_get_node(Type&,size_t) [with Type = func_node_t,size_t = long unsigned int]" -> "__builtin_expect(long int,long int)"
"ut_elem_get_node(Type&,size_t) [with Type = func_node_t,size_t = long unsigned int]" -> "ut_dbg_assertion_failed(const char*,const char*,ulint)"
"opt_classify_comparison(sel_node_t*,ulint,func_node_t*)" -> "dtuple_get_n_fields(const dtuple_t*)"
"opt_classify_comparison(sel_node_t*,ulint,func_node_t*)" -> "opt_is_arg(que_node_t*,func_node_t*)"
"opt_classify_comparison(sel_node_t*,ulint,func_node_t*)" -> "dict_index_get_nth_col_no(const dict_index_t*,ulint)"
"opt_classify_comparison(sel_node_t*,ulint,func_node_t*)" -> "sel_node_get_nth_plan(sel_node_t*,ulint)"
"opt_classify_comparison(sel_node_t*,ulint,func_node_t*)" -> "dict_index_get_n_fields(const dict_index_t*)"
"opt_classify_comparison(sel_node_t*,ulint,func_node_t*)" -> "opt_look_for_col_in_comparison_before(ulint,ulint,func_node_t*,sel_node_t*,ulint,ulint*)"
"opt_classify_comparison(sel_node_t*,ulint,func_node_t*)" -> "opt_check_exp_determined_before(que_node_t*,sel_node_t*,ulint)"
"opt_is_arg(que_node_t*,func_node_t*)" -> "que_node_get_next(que_node_t*)"
"opt_look_for_col_in_comparison_before(ulint,ulint,func_node_t*,sel_node_t*,ulint,ulint*)" -> "que_node_get_type(que_node_t*)"
"opt_look_for_col_in_comparison_before(ulint,ulint,func_node_t*,sel_node_t*,ulint,ulint*)" -> "ut_dbg_assertion_failed(const char*,const char*,ulint)"
"opt_look_for_col_in_comparison_before(ulint,ulint,func_node_t*,sel_node_t*,ulint,ulint*)" -> "abort()"
"opt_look_for_col_in_comparison_before(ulint,ulint,func_node_t*,sel_node_t*,ulint,ulint*)" -> "sel_node_get_nth_plan(sel_node_t*,ulint)"
"opt_look_for_col_in_comparison_before(ulint,ulint,func_node_t*,sel_node_t*,ulint,ulint*)" -> "__builtin_expect(long int,long int)"
"opt_look_for_col_in_comparison_before(ulint,ulint,func_node_t*,sel_node_t*,ulint,ulint*)" -> "que_node_get_next(que_node_t*)"
"opt_look_for_col_in_comparison_before(ulint,ulint,func_node_t*,sel_node_t*,ulint,ulint*)" -> "opt_check_exp_determined_before(que_node_t*,sel_node_t*,ulint)"
"opt_look_for_col_in_comparison_before(ulint,ulint,func_node_t*,sel_node_t*,ulint,ulint*)" -> "opt_invert_cmp_op(int)"
"opt_clust_access(sel_node_t*,ulint)" -> "mem_heap_alloc(mem_heap_t*,ulint)"
"opt_clust_access(sel_node_t*,ulint)" -> "dict_index_is_clust(const dict_index_t*)"
"opt_clust_access(sel_node_t*,ulint)" -> "abort()"
"opt_clust_access(sel_node_t*,ulint)" -> "__builtin_expect(long int,long int)"
"opt_clust_access(sel_node_t*,ulint)" -> "sel_node_get_nth_plan(sel_node_t*,ulint)"
"opt_clust_access(sel_node_t*,ulint)" -> "dtuple_create(mem_heap_t*,ulint)"
"opt_clust_access(sel_node_t*,ulint)" -> "dict_index_copy_types(dtuple_t*,const dict_index_t*,ulint)"
"opt_clust_access(sel_node_t*,ulint)" -> "fprintf(FILE*,const char*,...)"
"opt_clust_access(sel_node_t*,ulint)" -> "dict_index_get_n_unique(const dict_index_t*)"
"opt_clust_access(sel_node_t*,ulint)" -> "dict_index_get_nth_field_pos(const dict_index_t*,const dict_index_t*,ulint)"
"opt_clust_access(sel_node_t*,ulint)" -> "ut_dbg_assertion_failed(const char*,const char*,ulint)"
"dict_index_copy_types(dtuple_t*,const dict_index_t*,ulint)" -> "dict_field_get_col(const dict_field_t*)"
"dict_index_copy_types(dtuple_t*,const dict_index_t*,ulint)" -> "dict_index_is_univ(const dict_index_t*)"
"dict_index_copy_types(dtuple_t*,const dict_index_t*,ulint)" -> "dtuple_set_types_binary(dtuple_t*,ulint)"
"dict_index_copy_types(dtuple_t*,const dict_index_t*,ulint)" -> "dict_col_copy_type(const dict_col_t*,dtype_t*)"
"dtuple_set_types_binary(dtuple_t*,ulint)" -> "dtype_set(dtype_t*,ulint,ulint,ulint)"
"dict_index_get_nth_field_pos(const dict_index_t*,const dict_index_t*,ulint)" -> "dict_index_get_n_fields(const dict_index_t*)"
"opt_search_plan_for_table(sel_node_t*,ulint,dict_table_t*)" -> "opt_calc_n_fields_from_goodness(ulint)"
"opt_search_plan_for_table(sel_node_t*,ulint,dict_table_t*)" -> "dict_index_copy_types(dtuple_t*,const dict_index_t*,ulint)"
"opt_search_plan_for_table(sel_node_t*,ulint,dict_table_t*)" -> "dtuple_create(mem_heap_t*,ulint)"
"opt_search_plan_for_table(sel_node_t*,ulint,dict_table_t*)" -> "dict_index_is_clust(const dict_index_t*)"
"opt_search_plan_for_table(sel_node_t*,ulint,dict_table_t*)" -> "mem_heap_alloc(mem_heap_t*,ulint)"
"opt_search_plan_for_table(sel_node_t*,ulint,dict_table_t*)" -> "btr_pcur_init(btr_pcur_t*)"
"opt_search_plan_for_table(sel_node_t*,ulint,dict_table_t*)" -> "opt_calc_index_goodness(dict_index_t*,sel_node_t*,ulint,que_node_t**,ulint*)"
"opt_search_plan_for_table(sel_node_t*,ulint,dict_table_t*)" -> "sel_node_get_nth_plan(sel_node_t*,ulint)"
"opt_search_plan_for_table(sel_node_t*,ulint,dict_table_t*)" -> "ut_memcpy(void*,const void*,ulint)"
"opt_search_plan_for_table(sel_node_t*,ulint,dict_table_t*)" -> "dict_index_is_corrupted(const dict_index_t*)"
"opt_search_plan_for_table(sel_node_t*,ulint,dict_table_t*)" -> "dict_index_get_n_unique(const dict_index_t*)"
"opt_search_plan_for_table(sel_node_t*,ulint,dict_table_t*)" -> "opt_op_to_search_mode(ulint,ulint)"
"opt_calc_index_goodness(dict_index_t*,sel_node_t*,ulint,que_node_t**,ulint*)" -> "dict_index_is_clust(const dict_index_t*)"
"opt_calc_index_goodness(dict_index_t*,sel_node_t*,ulint,que_node_t**,ulint*)" -> "opt_look_for_col_in_cond_before(ulint,ulint,func_node_t*,sel_node_t*,ulint,ulint*)"
"opt_calc_index_goodness(dict_index_t*,sel_node_t*,ulint,que_node_t**,ulint*)" -> "dict_index_get_n_unique(const dict_index_t*)"
"opt_calc_index_goodness(dict_index_t*,sel_node_t*,ulint,que_node_t**,ulint*)" -> "dict_index_get_nth_col_no(const dict_index_t*,ulint)"
"opt_calc_index_goodness(dict_index_t*,sel_node_t*,ulint,que_node_t**,ulint*)" -> "dict_index_is_online_ddl(const dict_index_t*)"
"opt_calc_index_goodness(dict_index_t*,sel_node_t*,ulint,que_node_t**,ulint*)" -> "dict_index_get_n_unique_in_tree(const dict_index_t*)"
"opt_look_for_col_in_cond_before(ulint,ulint,func_node_t*,sel_node_t*,ulint,ulint*)" -> "opt_look_for_col_in_comparison_before(ulint,ulint,func_node_t*,sel_node_t*,ulint,ulint*)"
"opt_look_for_col_in_cond_before(ulint,ulint,func_node_t*,sel_node_t*,ulint,ulint*)" -> "que_node_get_next(que_node_t*)"
"opt_look_for_col_in_cond_before(ulint,ulint,func_node_t*,sel_node_t*,ulint,ulint*)" -> "ut_dbg_assertion_failed(const char*,const char*,ulint)"
"opt_look_for_col_in_cond_before(ulint,ulint,func_node_t*,sel_node_t*,ulint,ulint*)" -> "abort()"
"opt_look_for_col_in_cond_before(ulint,ulint,func_node_t*,sel_node_t*,ulint,ulint*)" -> "que_node_get_type(que_node_t*)"
"opt_look_for_col_in_cond_before(ulint,ulint,func_node_t*,sel_node_t*,ulint,ulint*)" -> "__builtin_expect(long int,long int)"
"opt_look_for_col_in_cond_before(ulint,ulint,func_node_t*,sel_node_t*,ulint,ulint*)" -> "opt_look_for_col_in_cond_before(ulint,ulint,func_node_t*,sel_node_t*,ulint,ulint*)"
"dict_index_is_online_ddl(const dict_index_t*)" -> "__builtin_expect(long int,long int)"
"dict_index_is_online_ddl(const dict_index_t*)" -> "dict_index_get_online_status(const dict_index_t*)"
"opt_op_to_search_mode(ulint,ulint)" -> "abort()"
"opt_op_to_search_mode(ulint,ulint)" -> "ut_dbg_assertion_failed(const char*,const char*,ulint)"
"opt_op_to_search_mode(ulint,ulint)" -> "__builtin_expect(long int,long int)"
"pars_resolve_exp_list_columns(sym_node_t*,que_node_t*)" -> "pars_resolve_exp_columns(sym_node_t*,que_node_t*)"
"pars_resolve_exp_list_columns(sym_node_t*,que_node_t*)" -> "que_node_get_next(que_node_t*)"
"pars_select_all_columns(sel_node_t*)" -> "que_node_get_next(que_node_t*)"
"pars_select_all_columns(sel_node_t*)" -> "dict_table_get_col_name(const dict_table_t*,ulint)"
"pars_select_all_columns(sel_node_t*)" -> "que_node_list_add_last(que_node_t*,que_node_t*)"
"pars_select_all_columns(sel_node_t*)" -> "ut_strlen(const char*)"
"pars_select_all_columns(sel_node_t*)" -> "dict_table_get_n_user_cols(const dict_table_t*)"
"pars_select_all_columns(sel_node_t*)" -> "sym_tab_add_id(sym_tab_t*,unsigned char*,ulint)"
"sym_tab_add_id(sym_tab_t*,unsigned char*,ulint)" -> "dfield_set_null(dfield_t*)"
"sym_tab_add_id(sym_tab_t*,unsigned char*,ulint)" -> "mem_heap_zalloc(mem_heap_t*,ulint)"
"sym_tab_add_id(sym_tab_t*,unsigned char*,ulint)" -> "mem_heap_strdupl(mem_heap_t*,const char*,ulint)"
"sym_tab_add_id(sym_tab_t*,unsigned char*,ulint)" -> "ut_list_append(List&,Type&,size_t) [with List = ut_list_base<sym_node_t>,Type = sym_node_t,size_t = long unsigned int]"
"dfield_set_null(dfield_t*)" -> "dfield_set_data(dfield_t*,const void*,ulint)"
"mem_heap_strdupl(mem_heap_t*,const char*,ulint)" -> "memcpy(void*,const void*,size_t)"
"mem_heap_strdupl(mem_heap_t*,const char*,ulint)" -> "mem_heap_alloc(mem_heap_t*,ulint)"
"pars_check_aggregate(sel_node_t*)" -> "abort()"
"pars_check_aggregate(sel_node_t*)" -> "ut_dbg_assertion_failed(const char*,const char*,ulint)"
"pars_check_aggregate(sel_node_t*)" -> "__builtin_expect(long int,long int)"
"pars_check_aggregate(sel_node_t*)" -> "que_node_get_type(que_node_t*)"
"pars_check_aggregate(sel_node_t*)" -> "que_node_get_next(que_node_t*)"
"pars_retrieve_table_list_defs(sym_node_t*)" -> "que_node_get_next(que_node_t*)"
"pars_retrieve_table_list_defs(sym_node_t*)" -> "pars_retrieve_table_def(sym_node_t*)"
"pars_retrieve_table_def(sym_node_t*)" -> "que_node_get_type(que_node_t*)"
"pars_retrieve_table_def(sym_node_t*)" -> "dict_table_open_on_name(const char*,ulint,ulint,dict_err_ignore_t)"
"pars_retrieve_table_def(sym_node_t*)" -> "__builtin_expect(long int,long int)"
"pars_retrieve_table_def(sym_node_t*)" -> "ut_dbg_assertion_failed(const char*,const char*,ulint)"
"pars_retrieve_table_def(sym_node_t*)" -> "abort()"
"dict_table_open_on_name(const char*,ulint,ulint,dict_err_ignore_t)" -> "dict_table_try_drop_aborted_and_mutex_exit(dict_table_t*,ulint)"
"dict_table_open_on_name(const char*,ulint,ulint,dict_err_ignore_t)" -> "dict_load_table(const char*,ulint,dict_err_ignore_t)"
"dict_table_open_on_name(const char*,ulint,ulint,dict_err_ignore_t)" -> "pfs_mutex_exit_func(ib_mutex_t*)"
"dict_table_open_on_name(const char*,ulint,ulint,dict_err_ignore_t)" -> "dict_table_check_if_in_cache_low(const char*)"
"dict_table_open_on_name(const char*,ulint,ulint,dict_err_ignore_t)" -> "ut_print_timestamp(FILE*)"
"dict_table_open_on_name(const char*,ulint,ulint,dict_err_ignore_t)" -> "dict_move_to_mru(dict_table_t*)"
"dict_table_open_on_name(const char*,ulint,ulint,dict_err_ignore_t)" -> "__builtin_fwrite(const void*,size_t,size_t,FILE*)"
"dict_table_open_on_name(const char*,ulint,ulint,dict_err_ignore_t)" -> "pfs_mutex_enter_func(ib_mutex_t*,const char*,ulint)"
"dict_table_open_on_name(const char*,ulint,ulint,dict_err_ignore_t)" -> "dict_table_move_from_lru_to_non_lru(dict_table_t*)"
"dict_table_open_on_name(const char*,ulint,ulint,dict_err_ignore_t)" -> "ut_print_name(FILE*,const trx_t*,ulint,const char*)"
"dict_table_try_drop_aborted_and_mutex_exit(dict_table_t*,ulint)" -> "dict_table_try_drop_aborted(dict_table_t*,table_id_t,ulint)"
"dict_table_try_drop_aborted_and_mutex_exit(dict_table_t*,ulint)" -> "pfs_mutex_exit_func(ib_mutex_t*)"
"dict_load_table(const char*,ulint,dict_err_ignore_t)" -> "ut_print_name(FILE*,const trx_t*,ulint,const char*)"
"dict_load_table(const char*,ulint,dict_err_ignore_t)" -> "dict_tf_to_fsp_flags(ulint)"
"dict_load_table(const char*,ulint,dict_err_ignore_t)" -> "ut_memcmp(const void*,const void*,ulint)"
"dict_load_table(const char*,ulint,dict_err_ignore_t)" -> "dict_table_add_system_columns(dict_table_t*,mem_heap_t*)"
"dict_load_table(const char*,ulint,dict_err_ignore_t)" -> "dtuple_create(mem_heap_t*,ulint)"
"dict_load_table(const char*,ulint,dict_err_ignore_t)" -> "btr_pcur_is_on_user_rec(const btr_pcur_t*)"
"dict_load_table(const char*,ulint,dict_err_ignore_t)" -> "dict_load_foreigns(const char*,const char**,bool,bool,dict_err_ignore_t)"
"dict_load_table(const char*,ulint,dict_err_ignore_t)" -> "dict_table_has_fts_index(dict_table_t*)"
"dict_load_table(const char*,ulint,dict_err_ignore_t)" -> "mem_heap_free_func(mem_heap_t*,const char*,ulint)"
"dict_load_table(const char*,ulint,dict_err_ignore_t)" -> "fprintf(FILE*,const char*,...)"
"dict_load_table(const char*,ulint,dict_err_ignore_t)" -> "ut_strlen(const char*)"
"dict_load_table(const char*,ulint,dict_err_ignore_t)" -> "rec_get_nth_field_offs_old(const rec_t*,ulint,ulint*)"
"dict_load_table(const char*,ulint,dict_err_ignore_t)" -> "dfield_set_data(dfield_t*,const void*,ulint)"
"dict_load_table(const char*,ulint,dict_err_ignore_t)" -> "btr_pcur_open_on_user_rec_func(dict_index_t*,const dtuple_t*,ulint,ulint,btr_pcur_t*,const char*,ulint,mtr_t*)"
"dict_load_table(const char*,ulint,dict_err_ignore_t)" -> "fil_space_for_table_exists_in_mem(ulint,const char*,ulint,ulint,bool,mem_heap_t*,table_id_t)"
"dict_load_table(const char*,ulint,dict_err_ignore_t)" -> "dict_index_is_corrupted(const dict_index_t*)"
"dict_load_table(const char*,ulint,dict_err_ignore_t)" -> "ut_print_timestamp(FILE*)"
"dict_load_table(const char*,ulint,dict_err_ignore_t)" -> "fil_open_single_table_tablespace(bool,bool,ulint,ulint,const char*,const char*)"
"dict_load_table(const char*,ulint,dict_err_ignore_t)" -> "__builtin_fwrite(const void*,size_t,size_t,FILE*)"
"dict_load_table(const char*,ulint,dict_err_ignore_t)" -> "mem_free_func(void*,const char*,ulint)"
"dict_load_table(const char*,ulint,dict_err_ignore_t)" -> "dict_index_copy_types(dtuple_t*,const dict_index_t*,ulint)"
"dict_load_table(const char*,ulint,dict_err_ignore_t)" -> "dict_load_table_low(const char*,const rec_t*,dict_table_t**)"
"dict_load_table(const char*,ulint,dict_err_ignore_t)" -> "fts_free(dict_table_t*)"
"dict_load_table(const char*,ulint,dict_err_ignore_t)" -> "mtr_commit(mtr_t*)"
"dict_load_table(const char*,ulint,dict_err_ignore_t)" -> "os_file_make_remote_pathname(const char*,const char*,const char*)"
"dict_load_table(const char*,ulint,dict_err_ignore_t)" -> "btr_pcur_close(btr_pcur_t*)"
"dict_load_table(const char*,ulint,dict_err_ignore_t)" -> "fts_optimize_add_table(dict_table_t*)"
"dict_load_table(const char*,ulint,dict_err_ignore_t)" -> "rec_get_deleted_flag(const rec_t*,ulint)"
"dict_load_table(const char*,ulint,dict_err_ignore_t)" -> "dict_table_get_low(const char*)"
"dict_load_table(const char*,ulint,dict_err_ignore_t)" -> "dict_get_and_save_data_dir_path(dict_table_t*,bool)"
"dict_load_table(const char*,ulint,dict_err_ignore_t)" -> "dict_load_indexes(dict_table_t*,mem_heap_t*,dict_err_ignore_t)"
"dict_load_table(const char*,ulint,dict_err_ignore_t)" -> "innobase_format_name(char*,ulint,const char*,ulint)"
"dict_load_table(const char*,ulint,dict_err_ignore_t)" -> "dict_index_is_clust(const dict_index_t*)"
"dict_load_table(const char*,ulint,dict_err_ignore_t)" -> "dict_table_add_to_cache(dict_table_t*,ulint,mem_heap_t*)"
"dict_load_table(const char*,ulint,dict_err_ignore_t)" -> "mtr_start(mtr_t*)"
"dict_load_table(const char*,ulint,dict_err_ignore_t)" -> "mem_heap_empty(mem_heap_t*)"
"dict_load_table(const char*,ulint,dict_err_ignore_t)" -> "dict_table_remove_from_cache(dict_table_t*)"
"dict_load_table(const char*,ulint,dict_err_ignore_t)" -> "ib_logf(ib_log_level_t,const char*,...)"
"dict_load_table(const char*,ulint,dict_err_ignore_t)" -> "dict_load_columns(dict_table_t*,mem_heap_t*)"
"dict_load_table(const char*,ulint,dict_err_ignore_t)" -> "mem_heap_create_func(ulint,ulint)"
"dict_tf_to_fsp_flags(ulint)" -> "__builtin_expect(long int,long int)"
"dict_tf_to_fsp_flags(ulint)" -> "abort()"
"dict_tf_to_fsp_flags(ulint)" -> "fsp_flags_is_valid(ulint)"
"dict_tf_to_fsp_flags(ulint)" -> "ut_dbg_assertion_failed(const char*,const char*,ulint)"
"dict_tf_to_fsp_flags(ulint)" -> "fsp_flags_set_page_size(ulint,ulint)"
"dict_table_add_system_columns(dict_table_t*,mem_heap_t*)" -> "dict_mem_table_add_col(dict_table_t*,mem_heap_t*,const char*,ulint,ulint,ulint)"
"dict_mem_table_add_col(dict_table_t*,mem_heap_t*,const char*,ulint,ulint,ulint)" -> "mem_heap_zalloc(mem_heap_t*,ulint)"
"dict_mem_table_add_col(dict_table_t*,mem_heap_t*,const char*,ulint,ulint,ulint)" -> "dict_add_col_name(const char*,ulint,const char*,mem_heap_t*)"
"dict_mem_table_add_col(dict_table_t*,mem_heap_t*,const char*,ulint,ulint,ulint)" -> "dict_mem_fill_column_struct(dict_col_t*,ulint,ulint,ulint,ulint)"
"dict_mem_table_add_col(dict_table_t*,mem_heap_t*,const char*,ulint,ulint,ulint)" -> "__builtin_expect(long int,long int)"
"dict_add_col_name(const char*,ulint,const char*,mem_heap_t*)" -> "mem_heap_alloc(mem_heap_t*,ulint)"
"dict_add_col_name(const char*,ulint,const char*,mem_heap_t*)" -> "strlen(const char*)"
"dict_add_col_name(const char*,ulint,const char*,mem_heap_t*)" -> "memcpy(void*,const void*,size_t)"
"dict_mem_fill_column_struct(dict_col_t*,ulint,ulint,ulint,ulint)" -> "dict_col_set_mbminmaxlen(dict_col_t*,ulint,ulint)"
"dict_mem_fill_column_struct(dict_col_t*,ulint,ulint,ulint,ulint)" -> "dtype_get_mblen(ulint,ulint,ulint*,ulint*)"
"btr_pcur_is_on_user_rec(const btr_pcur_t*)" -> "btr_pcur_is_before_first_on_page(const btr_pcur_t*)"
"btr_pcur_is_on_user_rec(const btr_pcur_t*)" -> "btr_pcur_is_after_last_on_page(const btr_pcur_t*)"
"btr_pcur_is_before_first_on_page(const btr_pcur_t*)" -> "page_cur_is_before_first(const page_cur_t*)"
"dict_load_foreigns(const char*,const char**,bool,bool,dict_err_ignore_t)" -> "__builtin_expect(long int,long int)"
"dict_load_foreigns(const char*,const char**,bool,bool,dict_err_ignore_t)" -> "__builtin_fwrite(const void*,size_t,size_t,FILE*)"
"dict_load_foreigns(const char*,const char**,bool,bool,dict_err_ignore_t)" -> "dtuple_create_from_mem(void*,ulint,ulint)"
"dict_load_foreigns(const char*,const char**,bool,bool,dict_err_ignore_t)" -> "cmp_data_data(ulint,ulint,const unsigned char*,ulint,const unsigned char*,ulint)"
"dict_load_foreigns(const char*,const char**,bool,bool,dict_err_ignore_t)" -> "memcpy(void*,const void*,size_t)"
"dict_load_foreigns(const char*,const char**,bool,bool,dict_err_ignore_t)" -> "rec_get_nth_field_offs_old(const rec_t*,ulint,ulint*)"
"dict_load_foreigns(const char*,const char**,bool,bool,dict_err_ignore_t)" -> "mtr_start(mtr_t*)"
"dict_load_foreigns(const char*,const char**,bool,bool,dict_err_ignore_t)" -> "dfield_get_len(const dfield_t*)"
"dict_load_foreigns(const char*,const char**,bool,bool,dict_err_ignore_t)" -> "btr_pcur_store_position(btr_pcur_t*,mtr_t*)"
"dict_load_foreigns(const char*,const char**,bool,bool,dict_err_ignore_t)" -> "mtr_commit(mtr_t*)"
"dict_load_foreigns(const char*,const char**,bool,bool,dict_err_ignore_t)" -> "btr_pcur_move_to_next_user_rec(btr_pcur_t*,mtr_t*)"
"dict_load_foreigns(const char*,const char**,bool,bool,dict_err_ignore_t)" -> "ut_memcmp(const void*,const void*,ulint)"
"dict_load_foreigns(const char*,const char**,bool,bool,dict_err_ignore_t)" -> "btr_pcur_restore_position_func(ulint,btr_pcur_t*,const char*,ulint,mtr_t*)"
"dict_load_foreigns(const char*,const char**,bool,bool,dict_err_ignore_t)" -> "rec_get_deleted_flag(const rec_t*,ulint)"
"dict_load_foreigns(const char*,const char**,bool,bool,dict_err_ignore_t)" -> "btr_pcur_is_on_user_rec(const btr_pcur_t*)"
"dict_load_foreigns(const char*,const char**,bool,bool,dict_err_ignore_t)" -> "dict_index_copy_types(dtuple_t*,const dict_index_t*,ulint)"
"dict_load_foreigns(const char*,const char**,bool,bool,dict_err_ignore_t)" -> "dfield_set_data(dfield_t*,const void*,ulint)"
"dict_load_foreigns(const char*,const char**,bool,bool,dict_err_ignore_t)" -> "dict_table_get_low(const char*)"
"dict_load_foreigns(const char*,const char**,bool,bool,dict_err_ignore_t)" -> "ut_strlen(const char*)"
"dict_load_foreigns(const char*,const char**,bool,bool,dict_err_ignore_t)" -> "btr_pcur_close(btr_pcur_t*)"
"dict_load_foreigns(const char*,const char**,bool,bool,dict_err_ignore_t)" -> "ut_dbg_assertion_failed(const char*,const char*,ulint)"
"dict_load_foreigns(const char*,const char**,bool,bool,dict_err_ignore_t)" -> "btr_pcur_open_on_user_rec_func(dict_index_t*,const dtuple_t*,ulint,ulint,btr_pcur_t*,const char*,ulint,mtr_t*)"
"dict_load_foreigns(const char*,const char**,bool,bool,dict_err_ignore_t)" -> "abort()"
"dict_load_foreigns(const char*,const char**,bool,bool,dict_err_ignore_t)" -> "dict_load_foreign(const char*,const char**,bool,bool,dict_err_ignore_t)"
"dict_load_foreigns(const char*,const char**,bool,bool,dict_err_ignore_t)" -> "innobase_get_lower_case_table_names()"
"cmp_data_data(ulint,ulint,const unsigned char*,ulint,const unsigned char*,ulint)" -> "cmp_data_data_slow(ulint,ulint,const unsigned char*,ulint,const unsigned char*,ulint)"
"cmp_data_data_slow(ulint,ulint,const unsigned char*,ulint,const unsigned char*,ulint)" -> "dtype_get_charset_coll(ulint)"
"cmp_data_data_slow(ulint,ulint,const unsigned char*,ulint,const unsigned char*,ulint)" -> "dtype_get_pad_char(ulint,ulint)"
"cmp_data_data_slow(ulint,ulint,const unsigned char*,ulint,const unsigned char*,ulint)" -> "cmp_whole_field(ulint,ulint,const unsigned char*,unsigned int,const unsigned char*,unsigned int)"
"cmp_data_data_slow(ulint,ulint,const unsigned char*,ulint,const unsigned char*,ulint)" -> "cmp_collate(ulint)"
"dtype_get_pad_char(ulint,ulint)" -> "dtype_get_charset_coll(ulint)"
"cmp_whole_field(ulint,ulint,const unsigned char*,unsigned int,const unsigned char*,unsigned int)" -> "dtype_get_charset_coll(ulint)"
"cmp_whole_field(ulint,ulint,const unsigned char*,unsigned int,const unsigned char*,unsigned int)" -> "mach_double_read(const unsigned char*)"
"cmp_whole_field(ulint,ulint,const unsigned char*,unsigned int,const unsigned char*,unsigned int)" -> "mach_float_read(const unsigned char*)"
"cmp_whole_field(ulint,ulint,const unsigned char*,unsigned int,const unsigned char*,unsigned int)" -> "ut_dbg_assertion_failed(const char*,const char*,ulint)"
"cmp_whole_field(ulint,ulint,const unsigned char*,unsigned int,const unsigned char*,unsigned int)" -> "innobase_mysql_cmp(int,uint,const unsigned char*,unsigned int,const unsigned char*,unsigned int)"
"cmp_whole_field(ulint,ulint,const unsigned char*,unsigned int,const unsigned char*,unsigned int)" -> "ut_print_timestamp(FILE*)"
"cmp_whole_field(ulint,ulint,const unsigned char*,unsigned int,const unsigned char*,unsigned int)" -> "abort()"
"cmp_whole_field(ulint,ulint,const unsigned char*,unsigned int,const unsigned char*,unsigned int)" -> "__builtin_fwrite(const void*,size_t,size_t,FILE*)"
"cmp_whole_field(ulint,ulint,const unsigned char*,unsigned int,const unsigned char*,unsigned int)" -> "fprintf(FILE*,const char*,...)"
"innobase_mysql_cmp(int,uint,const unsigned char*,unsigned int,const unsigned char*,unsigned int)" -> "abort()"
"innobase_mysql_cmp(int,uint,const unsigned char*,unsigned int,const unsigned char*,unsigned int)" -> "ut_dbg_assertion_failed(const char*,const char*,ulint)"
"innobase_mysql_cmp(int,uint,const unsigned char*,unsigned int,const unsigned char*,unsigned int)" -> "get_charset(uint,myf)"
"innobase_mysql_cmp(int,uint,const unsigned char*,unsigned int,const unsigned char*,unsigned int)" -> "sql_print_error(const char*,...)"
"btr_pcur_store_position(btr_pcur_t*,mtr_t*)" -> "page_offset(const void*)"
"btr_pcur_store_position(btr_pcur_t*,mtr_t*)" -> "page_rec_get_prev(rec_t*)"
"btr_pcur_store_position(btr_pcur_t*,mtr_t*)" -> "page_rec_is_supremum_low(ulint)"
"btr_pcur_store_position(btr_pcur_t*,mtr_t*)" -> "page_is_empty(const ib_page_t*)"
"btr_pcur_store_position(btr_pcur_t*,mtr_t*)" -> "btr_page_get_prev(const ib_page_t*,mtr_t*)"
"btr_pcur_store_position(btr_pcur_t*,mtr_t*)" -> "abort()"
"btr_pcur_store_position(btr_pcur_t*,mtr_t*)" -> "page_rec_get_next(rec_t*)"
"btr_pcur_store_position(btr_pcur_t*,mtr_t*)" -> "page_align(const void*)"
"btr_pcur_store_position(btr_pcur_t*,mtr_t*)" -> "page_rec_is_infimum_low(ulint)"
"btr_pcur_store_position(btr_pcur_t*,mtr_t*)" -> "ut_dbg_assertion_failed(const char*,const char*,ulint)"
"btr_pcur_store_position(btr_pcur_t*,mtr_t*)" -> "dict_index_copy_rec_order_prefix(const dict_index_t*,const rec_t*,ulint*,unsigned char**,ulint*)"
"btr_pcur_store_position(btr_pcur_t*,mtr_t*)" -> "buf_block_get_modify_clock(buf_block_t*)"
"btr_pcur_store_position(btr_pcur_t*,mtr_t*)" -> "btr_page_get_next(const ib_page_t*,mtr_t*)"
"btr_pcur_store_position(btr_pcur_t*,mtr_t*)" -> "__builtin_expect(long int,long int)"
"page_rec_get_prev(rec_t*)" -> "page_rec_get_prev_const(const rec_t*)"
"page_rec_get_prev_const(const rec_t*)" -> "page_dir_slot_get_rec(const page_dir_slot_t*)"
"page_rec_get_prev_const(const rec_t*)" -> "page_is_comp(const ib_page_t*)"
"page_rec_get_prev_const(const rec_t*)" -> "page_rec_get_next_low(const rec_t*,ulint)"
"page_rec_get_prev_const(const rec_t*)" -> "page_align(const void*)"
"page_rec_get_prev_const(const rec_t*)" -> "ut_dbg_assertion_failed(const char*,const char*,ulint)"
"page_rec_get_prev_const(const rec_t*)" -> "page_dir_find_owner_slot(const rec_t*)"
"page_rec_get_prev_const(const rec_t*)" -> "abort()"
"page_rec_get_prev_const(const rec_t*)" -> "__builtin_expect(long int,long int)"
"btr_page_get_prev(const ib_page_t*,mtr_t*)" -> "mach_read_from_4(const unsigned char*)"
"dict_index_copy_rec_order_prefix(const dict_index_t*,const rec_t*,ulint*,unsigned char**,ulint*)" -> "dict_index_is_univ(const dict_index_t*)"
"dict_index_copy_rec_order_prefix(const dict_index_t*,const rec_t*,ulint*,unsigned char**,ulint*)" -> "abort()"
"dict_index_copy_rec_order_prefix(const dict_index_t*,const rec_t*,ulint*,unsigned char**,ulint*)" -> "ut_dbg_assertion_failed(const char*,const char*,ulint)"
"dict_index_copy_rec_order_prefix(const dict_index_t*,const rec_t*,ulint*,unsigned char**,ulint*)" -> "__builtin_expect(long int,long int)"
"dict_index_copy_rec_order_prefix(const dict_index_t*,const rec_t*,ulint*,unsigned char**,ulint*)" -> "rec_copy_prefix_to_buf(const rec_t*,const dict_index_t*,ulint,unsigned char**,ulint*)"
"dict_index_copy_rec_order_prefix(const dict_index_t*,const rec_t*,ulint*,unsigned char**,ulint*)" -> "__builtin_prefetch(const void*,...)"
"dict_index_copy_rec_order_prefix(const dict_index_t*,const rec_t*,ulint*,unsigned char**,ulint*)" -> "dict_table_is_comp(const dict_table_t*)"
"dict_index_copy_rec_order_prefix(const dict_index_t*,const rec_t*,ulint*,unsigned char**,ulint*)" -> "dict_index_get_n_unique_in_tree(const dict_index_t*)"
"dict_index_copy_rec_order_prefix(const dict_index_t*,const rec_t*,ulint*,unsigned char**,ulint*)" -> "rec_get_n_fields_old(const rec_t*)"
"rec_copy_prefix_to_buf(const rec_t*,const dict_index_t*,ulint,unsigned char**,ulint*)" -> "ut_dbg_assertion_failed(const char*,const char*,ulint)"
"rec_copy_prefix_to_buf(const rec_t*,const dict_index_t*,ulint,unsigned char**,ulint*)" -> "__builtin_expect(long int,long int)"
"rec_copy_prefix_to_buf(const rec_t*,const dict_index_t*,ulint,unsigned char**,ulint*)" -> "mem_alloc_func(ulint,ulint*)"
"rec_copy_prefix_to_buf(const rec_t*,const dict_index_t*,ulint,unsigned char**,ulint*)" -> "dict_table_is_comp(const dict_table_t*)"
"rec_copy_prefix_to_buf(const rec_t*,const dict_index_t*,ulint,unsigned char**,ulint*)" -> "rec_copy_prefix_to_buf_old(const rec_t*,ulint,ulint,unsigned char**,ulint*)"
"rec_copy_prefix_to_buf(const rec_t*,const dict_index_t*,ulint,unsigned char**,ulint*)" -> "memcpy(void*,const void*,size_t)"
"rec_copy_prefix_to_buf(const rec_t*,const dict_index_t*,ulint,unsigned char**,ulint*)" -> "abort()"
"rec_copy_prefix_to_buf(const rec_t*,const dict_index_t*,ulint,unsigned char**,ulint*)" -> "rec_get_status(const rec_t*)"
"rec_copy_prefix_to_buf(const rec_t*,const dict_index_t*,ulint,unsigned char**,ulint*)" -> "mem_free_func(void*,const char*,ulint)"
"rec_copy_prefix_to_buf(const rec_t*,const dict_index_t*,ulint,unsigned char**,ulint*)" -> "__builtin_prefetch(const void*,...)"
"rec_copy_prefix_to_buf(const rec_t*,const dict_index_t*,ulint,unsigned char**,ulint*)" -> "dict_field_get_col(const dict_field_t*)"
"rec_copy_prefix_to_buf(const rec_t*,const dict_index_t*,ulint,unsigned char**,ulint*)" -> "rec_get_field_start_offs(const rec_t*,ulint)"
"rec_copy_prefix_to_buf_old(const rec_t*,ulint,ulint,unsigned char**,ulint*)" -> "ut_memcpy(void*,const void*,ulint)"
"rec_copy_prefix_to_buf_old(const rec_t*,ulint,ulint,unsigned char**,ulint*)" -> "rec_get_1byte_offs_flag(const rec_t*)"
"rec_copy_prefix_to_buf_old(const rec_t*,ulint,ulint,unsigned char**,ulint*)" -> "rec_set_n_fields_old(rec_t*,ulint)"
"rec_copy_prefix_to_buf_old(const rec_t*,ulint,ulint,unsigned char**,ulint*)" -> "mem_alloc_func(ulint,ulint*)"
"rec_copy_prefix_to_buf_old(const rec_t*,ulint,ulint,unsigned char**,ulint*)" -> "mem_free_func(void*,const char*,ulint)"
"btr_pcur_move_to_next_user_rec(btr_pcur_t*,mtr_t*)" -> "btr_pcur_is_after_last_in_tree(btr_pcur_t*,mtr_t*)"
"btr_pcur_move_to_next_user_rec(btr_pcur_t*,mtr_t*)" -> "btr_pcur_is_on_user_rec(const btr_pcur_t*)"
"btr_pcur_move_to_next_user_rec(btr_pcur_t*,mtr_t*)" -> "btr_pcur_move_to_next_on_page(btr_pcur_t*)"
"btr_pcur_move_to_next_user_rec(btr_pcur_t*,mtr_t*)" -> "btr_pcur_is_after_last_on_page(const btr_pcur_t*)"
"btr_pcur_move_to_next_user_rec(btr_pcur_t*,mtr_t*)" -> "btr_pcur_move_to_next_page(btr_pcur_t*,mtr_t*)"
"btr_pcur_is_after_last_in_tree(btr_pcur_t*,mtr_t*)" -> "btr_page_get_next(const ib_page_t*,mtr_t*)"
"btr_pcur_is_after_last_in_tree(btr_pcur_t*,mtr_t*)" -> "page_cur_is_after_last(const page_cur_t*)"
"btr_pcur_restore_position_func(ulint,btr_pcur_t*,const char*,ulint,mtr_t*)" -> "__builtin_expect(long int,long int)"
"btr_pcur_restore_position_func(ulint,btr_pcur_t*,const char*,ulint,mtr_t*)" -> "btr_cur_open_at_index_side_func(bool,dict_index_t*,ulint,btr_cur_t*,ulint,const char*,ulint,mtr_t*)"
"btr_pcur_restore_position_func(ulint,btr_pcur_t*,const char*,ulint,mtr_t*)" -> "cmp_dtuple_rec(const dtuple_t*,const rec_t*,const ulint*)"
"btr_pcur_restore_position_func(ulint,btr_pcur_t*,const char*,ulint,mtr_t*)" -> "rec_get_offsets_func(const rec_t*,const dict_index_t*,ulint*,ulint,mem_heap_t**)"
"btr_pcur_restore_position_func(ulint,btr_pcur_t*,const char*,ulint,mtr_t*)" -> "mem_heap_free_func(mem_heap_t*,const char*,ulint)"
"btr_pcur_restore_position_func(ulint,btr_pcur_t*,const char*,ulint,mtr_t*)" -> "mem_heap_create_func(ulint,ulint)"
"btr_pcur_restore_position_func(ulint,btr_pcur_t*,const char*,ulint,mtr_t*)" -> "dict_index_build_data_tuple(dict_index_t*,rec_t*,ulint,mem_heap_t*)"
"btr_pcur_restore_position_func(ulint,btr_pcur_t*,const char*,ulint,mtr_t*)" -> "abort()"
"btr_pcur_restore_position_func(ulint,btr_pcur_t*,const char*,ulint,mtr_t*)" -> "ut_dbg_assertion_failed(const char*,const char*,ulint)"
"btr_pcur_restore_position_func(ulint,btr_pcur_t*,const char*,ulint,mtr_t*)" -> "btr_pcur_store_position(btr_pcur_t*,mtr_t*)"
"btr_pcur_restore_position_func(ulint,btr_pcur_t*,const char*,ulint,mtr_t*)" -> "btr_pcur_open_with_no_init_func(dict_index_t*,const dtuple_t*,ulint,ulint,btr_pcur_t*,ulint,const char*,ulint,mtr_t*)"
"btr_pcur_restore_position_func(ulint,btr_pcur_t*,const char*,ulint,mtr_t*)" -> "buf_block_get_modify_clock(buf_block_t*)"
"btr_pcur_restore_position_func(ulint,btr_pcur_t*,const char*,ulint,mtr_t*)" -> "btr_pcur_is_on_user_rec(const btr_pcur_t*)"
"btr_pcur_restore_position_func(ulint,btr_pcur_t*,const char*,ulint,mtr_t*)" -> "buf_page_optimistic_get(ulint,buf_block_t*,ib_uint64_t,const char*,ulint,mtr_t*)"
"btr_cur_open_at_index_side_func(bool,dict_index_t*,ulint,btr_cur_t*,ulint,const char*,ulint,mtr_t*)" -> "dict_index_get_space(const dict_index_t*)"
"btr_cur_open_at_index_side_func(bool,dict_index_t*,ulint,btr_cur_t*,ulint,const char*,ulint,mtr_t*)" -> "page_cur_set_after_last(const buf_block_t*,page_cur_t*)"
"btr_cur_open_at_index_side_func(bool,dict_index_t*,ulint,btr_cur_t*,ulint,const char*,ulint,mtr_t*)" -> "btr_cur_add_path_info(btr_cur_t*,ulint,ulint)"
"btr_cur_open_at_index_side_func(bool,dict_index_t*,ulint,btr_cur_t*,ulint,const char*,ulint,mtr_t*)" -> "mtr_set_savepoint(mtr_t*)"
"btr_cur_open_at_index_side_func(bool,dict_index_t*,ulint,btr_cur_t*,ulint,const char*,ulint,mtr_t*)" -> "page_cur_move_to_prev(page_cur_t*)"
"btr_cur_open_at_index_side_func(bool,dict_index_t*,ulint,btr_cur_t*,ulint,const char*,ulint,mtr_t*)" -> "mtr_s_lock_func(rw_lock_t*,const char*,ulint,mtr_t*)"
"btr_cur_open_at_index_side_func(bool,dict_index_t*,ulint,btr_cur_t*,ulint,const char*,ulint,mtr_t*)" -> "__builtin_expect(long int,long int)"
"btr_cur_open_at_index_side_func(bool,dict_index_t*,ulint,btr_cur_t*,ulint,const char*,ulint,mtr_t*)" -> "page_cur_set_before_first(const buf_block_t*,page_cur_t*)"
"btr_cur_open_at_index_side_func(bool,dict_index_t*,ulint,btr_cur_t*,ulint,const char*,ulint,mtr_t*)" -> "abort()"
"btr_cur_open_at_index_side_func(bool,dict_index_t*,ulint,btr_cur_t*,ulint,const char*,ulint,mtr_t*)" -> "dict_index_get_page(const dict_index_t*)"
"btr_cur_open_at_index_side_func(bool,dict_index_t*,ulint,btr_cur_t*,ulint,const char*,ulint,mtr_t*)" -> "rec_get_offsets_func(const rec_t*,const dict_index_t*,ulint*,ulint,mem_heap_t**)"
"btr_cur_open_at_index_side_func(bool,dict_index_t*,ulint,btr_cur_t*,ulint,const char*,ulint,mtr_t*)" -> "buf_page_get_gen(ulint,ulint,ulint,ulint,buf_block_t*,ulint,const char*,ulint,mtr_t*)"
"btr_cur_open_at_index_side_func(bool,dict_index_t*,ulint,btr_cur_t*,ulint,const char*,ulint,mtr_t*)" -> "ut_dbg_assertion_failed(const char*,const char*,ulint)"
"btr_cur_open_at_index_side_func(bool,dict_index_t*,ulint,btr_cur_t*,ulint,const char*,ulint,mtr_t*)" -> "mem_heap_free_func(mem_heap_t*,const char*,ulint)"
"btr_cur_open_at_index_side_func(bool,dict_index_t*,ulint,btr_cur_t*,ulint,const char*,ulint,mtr_t*)" -> "mtr_release_s_latch_at_savepoint(mtr_t*,ulint,rw_lock_t*)"
"btr_cur_open_at_index_side_func(bool,dict_index_t*,ulint,btr_cur_t*,ulint,const char*,ulint,mtr_t*)" -> "mtr_x_lock_func(rw_lock_t*,const char*,ulint,mtr_t*)"
"btr_cur_open_at_index_side_func(bool,dict_index_t*,ulint,btr_cur_t*,ulint,const char*,ulint,mtr_t*)" -> "btr_node_ptr_get_child_page_no(const rec_t*,const ulint*)"
"btr_cur_open_at_index_side_func(bool,dict_index_t*,ulint,btr_cur_t*,ulint,const char*,ulint,mtr_t*)" -> "btr_page_get_level_low(const ib_page_t*)"
"btr_cur_open_at_index_side_func(bool,dict_index_t*,ulint,btr_cur_t*,ulint,const char*,ulint,mtr_t*)" -> "rec_offs_set_n_alloc(ulint*,ulint)"
"btr_cur_open_at_index_side_func(bool,dict_index_t*,ulint,btr_cur_t*,ulint,const char*,ulint,mtr_t*)" -> "page_cur_move_to_next(page_cur_t*)"
"btr_cur_open_at_index_side_func(bool,dict_index_t*,ulint,btr_cur_t*,ulint,const char*,ulint,mtr_t*)" -> "dict_index_get_lock(dict_index_t*)"
"btr_cur_open_at_index_side_func(bool,dict_index_t*,ulint,btr_cur_t*,ulint,const char*,ulint,mtr_t*)" -> "dict_table_zip_size(const dict_table_t*)"
"btr_cur_open_at_index_side_func(bool,dict_index_t*,ulint,btr_cur_t*,ulint,const char*,ulint,mtr_t*)" -> "btr_cur_latch_leaves(ib_page_t*,ulint,ulint,ulint,ulint,btr_cur_t*,mtr_t*)"
"page_cur_set_after_last(const buf_block_t*,page_cur_t*)" -> "page_get_supremum_offset(const ib_page_t*)"
"page_get_supremum_offset(const ib_page_t*)" -> "page_is_comp(const ib_page_t*)"
"btr_cur_add_path_info(btr_cur_t*,ulint,ulint)" -> "page_rec_get_n_recs_before(const rec_t*)"
"btr_cur_add_path_info(btr_cur_t*,ulint,ulint)" -> "page_get_page_no(const ib_page_t*)"
"btr_cur_add_path_info(btr_cur_t*,ulint,ulint)" -> "abort()"
"btr_cur_add_path_info(btr_cur_t*,ulint,ulint)" -> "ut_dbg_assertion_failed(const char*,const char*,ulint)"
"btr_cur_add_path_info(btr_cur_t*,ulint,ulint)" -> "btr_page_get_level_low(const ib_page_t*)"
"btr_cur_add_path_info(btr_cur_t*,ulint,ulint)" -> "__builtin_expect(long int,long int)"
"btr_cur_add_path_info(btr_cur_t*,ulint,ulint)" -> "page_align(const void*)"
"btr_cur_add_path_info(btr_cur_t*,ulint,ulint)" -> "page_get_n_recs(const ib_page_t*)"
"page_rec_get_n_recs_before(const rec_t*)" -> "rec_get_next_ptr_const(const rec_t*,ulint)"
"page_rec_get_n_recs_before(const rec_t*)" -> "rec_get_n_owned_old(const rec_t*)"
"page_rec_get_n_recs_before(const rec_t*)" -> "rec_get_n_owned_new(const rec_t*)"
"page_rec_get_n_recs_before(const rec_t*)" -> "page_dir_slot_get_rec(const page_dir_slot_t*)"
"page_rec_get_n_recs_before(const rec_t*)" -> "page_is_comp(const ib_page_t*)"
"page_rec_get_n_recs_before(const rec_t*)" -> "page_align(const void*)"
"btr_page_get_level_low(const ib_page_t*)" -> "mach_read_from_2(const unsigned char*)"
"mtr_set_savepoint(mtr_t*)" -> "dyn_array_get_data_size(const dyn_array_t*)"
"dyn_array_get_data_size(const dyn_array_t*)" -> "dyn_block_get_used(const dyn_block_t*)"
"page_cur_move_to_prev(page_cur_t*)" -> "page_rec_get_prev(rec_t*)"
"mtr_s_lock_func(rw_lock_t*,const char*,ulint,mtr_t*)" -> "pfs_rw_lock_s_lock_func(rw_lock_t*,ulint,const char*,ulint)"
"mtr_s_lock_func(rw_lock_t*,const char*,ulint,mtr_t*)" -> "mtr_memo_push(mtr_t*,void*,ulint)"
"mtr_release_s_latch_at_savepoint(mtr_t*,ulint,rw_lock_t*)" -> "pfs_rw_lock_s_unlock_func(rw_lock_t*)"
"mtr_release_s_latch_at_savepoint(mtr_t*,ulint,rw_lock_t*)" -> "dyn_array_get_element(const dyn_array_t*,ulint)"
"dyn_array_get_element(const dyn_array_t*,ulint)" -> "dyn_block_get_used(const dyn_block_t*)"
"btr_node_ptr_get_child_page_no(const rec_t*,const ulint*)" -> "page_align(const void*)"
"btr_node_ptr_get_child_page_no(const rec_t*,const ulint*)" -> "buf_page_print(const unsigned char*,ulint,ulint)"
"btr_node_ptr_get_child_page_no(const rec_t*,const ulint*)" -> "fprintf(FILE*,const char*,...)"
"btr_node_ptr_get_child_page_no(const rec_t*,const ulint*)" -> "rec_get_nth_field_offs(const ulint*,ulint,ulint*)"
"btr_node_ptr_get_child_page_no(const rec_t*,const ulint*)" -> "page_offset(const void*)"
"btr_node_ptr_get_child_page_no(const rec_t*,const ulint*)" -> "mach_read_from_4(const unsigned char*)"
"btr_node_ptr_get_child_page_no(const rec_t*,const ulint*)" -> "rec_offs_n_fields(const ulint*)"
"dict_table_zip_size(const dict_table_t*)" -> "dict_tf_get_zip_size(ulint)"
"btr_cur_latch_leaves(ib_page_t*,ulint,ulint,ulint,ulint,btr_cur_t*,mtr_t*)" -> "abort()"
"btr_cur_latch_leaves(ib_page_t*,ulint,ulint,ulint,ulint,btr_cur_t*,mtr_t*)" -> "__builtin_expect(long int,long int)"
"btr_cur_latch_leaves(ib_page_t*,ulint,ulint,ulint,ulint,btr_cur_t*,mtr_t*)" -> "btr_page_get_next(const ib_page_t*,mtr_t*)"
"btr_cur_latch_leaves(ib_page_t*,ulint,ulint,ulint,ulint,btr_cur_t*,mtr_t*)" -> "btr_block_get_func(ulint,ulint,ulint,ulint,const char*,ulint,mtr_t*)"
"btr_cur_latch_leaves(ib_page_t*,ulint,ulint,ulint,ulint,btr_cur_t*,mtr_t*)" -> "page_is_comp(const ib_page_t*)"
"btr_cur_latch_leaves(ib_page_t*,ulint,ulint,ulint,ulint,btr_cur_t*,mtr_t*)" -> "page_get_page_no(const ib_page_t*)"
"btr_cur_latch_leaves(ib_page_t*,ulint,ulint,ulint,ulint,btr_cur_t*,mtr_t*)" -> "ut_dbg_assertion_failed(const char*,const char*,ulint)"
"btr_cur_latch_leaves(ib_page_t*,ulint,ulint,ulint,ulint,btr_cur_t*,mtr_t*)" -> "btr_page_get_prev(const ib_page_t*,mtr_t*)"
"cmp_dtuple_rec(const dtuple_t*,const rec_t*,const ulint*)" -> "dtuple_get_n_fields_cmp(const dtuple_t*)"
"cmp_dtuple_rec(const dtuple_t*,const rec_t*,const ulint*)" -> "cmp_dtuple_rec_with_match_low(const dtuple_t*,const rec_t*,const ulint*,ulint,ulint*,ulint*)"
"cmp_dtuple_rec_with_match_low(const dtuple_t*,const rec_t*,const ulint*,ulint,ulint*,ulint*)" -> "cmp_whole_field(ulint,ulint,const unsigned char*,unsigned int,const unsigned char*,unsigned int)"
"cmp_dtuple_rec_with_match_low(const dtuple_t*,const rec_t*,const ulint*,ulint,ulint*,ulint*)" -> "dtype_get_charset_coll(ulint)"
"cmp_dtuple_rec_with_match_low(const dtuple_t*,const rec_t*,const ulint*,ulint,ulint*,ulint*)" -> "dfield_get_len(const dfield_t*)"
"cmp_dtuple_rec_with_match_low(const dtuple_t*,const rec_t*,const ulint*,ulint,ulint*,ulint*)" -> "__builtin_expect(long int,long int)"
"cmp_dtuple_rec_with_match_low(const dtuple_t*,const rec_t*,const ulint*,ulint,ulint*,ulint*)" -> "dtuple_get_info_bits(const dtuple_t*)"
"cmp_dtuple_rec_with_match_low(const dtuple_t*,const rec_t*,const ulint*,ulint,ulint*,ulint*)" -> "rec_offs_nth_extern(const ulint*,ulint)"
"cmp_dtuple_rec_with_match_low(const dtuple_t*,const rec_t*,const ulint*,ulint,ulint*,ulint*)" -> "rec_get_nth_field_offs(const ulint*,ulint,ulint*)"
"cmp_dtuple_rec_with_match_low(const dtuple_t*,const rec_t*,const ulint*,ulint,ulint*,ulint*)" -> "rec_get_info_bits(const rec_t*,ulint)"
"cmp_dtuple_rec_with_match_low(const dtuple_t*,const rec_t*,const ulint*,ulint,ulint*,ulint*)" -> "rec_offs_comp(const ulint*)"
"cmp_dtuple_rec_with_match_low(const dtuple_t*,const rec_t*,const ulint*,ulint,ulint*,ulint*)" -> "dtype_get_pad_char(ulint,ulint)"
"cmp_dtuple_rec_with_match_low(const dtuple_t*,const rec_t*,const ulint*,ulint,ulint*,ulint*)" -> "cmp_collate(ulint)"
"dict_index_build_data_tuple(dict_index_t*,rec_t*,ulint,mem_heap_t*)" -> "dtuple_create(mem_heap_t*,ulint)"
"dict_index_build_data_tuple(dict_index_t*,rec_t*,ulint,mem_heap_t*)" -> "rec_copy_prefix_to_dtuple(dtuple_t*,const rec_t*,const dict_index_t*,ulint,mem_heap_t*)"
"dict_index_build_data_tuple(dict_index_t*,rec_t*,ulint,mem_heap_t*)" -> "dict_index_copy_types(dtuple_t*,const dict_index_t*,ulint)"
"rec_copy_prefix_to_dtuple(dtuple_t*,const rec_t*,const dict_index_t*,ulint,mem_heap_t*)" -> "dict_table_is_comp(const dict_table_t*)"
"rec_copy_prefix_to_dtuple(dtuple_t*,const rec_t*,const dict_index_t*,ulint,mem_heap_t*)" -> "rec_get_nth_field_offs(const ulint*,ulint,ulint*)"
"rec_copy_prefix_to_dtuple(dtuple_t*,const rec_t*,const dict_index_t*,ulint,mem_heap_t*)" -> "dfield_set_data(dfield_t*,const void*,ulint)"
"rec_copy_prefix_to_dtuple(dtuple_t*,const rec_t*,const dict_index_t*,ulint,mem_heap_t*)" -> "dtuple_set_info_bits(dtuple_t*,ulint)"
"rec_copy_prefix_to_dtuple(dtuple_t*,const rec_t*,const dict_index_t*,ulint,mem_heap_t*)" -> "rec_offs_set_n_alloc(ulint*,ulint)"
"rec_copy_prefix_to_dtuple(dtuple_t*,const rec_t*,const dict_index_t*,ulint,mem_heap_t*)" -> "mem_heap_dup(mem_heap_t*,const void*,ulint)"
"rec_copy_prefix_to_dtuple(dtuple_t*,const rec_t*,const dict_index_t*,ulint,mem_heap_t*)" -> "rec_get_info_bits(const rec_t*,ulint)"
"rec_copy_prefix_to_dtuple(dtuple_t*,const rec_t*,const dict_index_t*,ulint,mem_heap_t*)" -> "dfield_set_null(dfield_t*)"
"rec_copy_prefix_to_dtuple(dtuple_t*,const rec_t*,const dict_index_t*,ulint,mem_heap_t*)" -> "rec_get_offsets_func(const rec_t*,const dict_index_t*,ulint*,ulint,mem_heap_t**)"
"btr_pcur_open_with_no_init_func(dict_index_t*,const dtuple_t*,ulint,ulint,btr_pcur_t*,ulint,const char*,ulint,mtr_t*)" -> "btr_cur_search_to_nth_level(dict_index_t*,ulint,const dtuple_t*,ulint,ulint,btr_cur_t*,ulint,const char*,ulint,mtr_t*)"
"btr_cur_search_to_nth_level(dict_index_t*,ulint,const dtuple_t*,ulint,ulint,btr_cur_t*,ulint,const char*,ulint,mtr_t*)" -> "ut_dbg_assertion_failed(const char*,const char*,ulint)"
"btr_cur_search_to_nth_level(dict_index_t*,ulint,const dtuple_t*,ulint,ulint,btr_cur_t*,ulint,const char*,ulint,mtr_t*)" -> "pfs_rw_lock_s_unlock_func(rw_lock_t*)"
"btr_cur_search_to_nth_level(dict_index_t*,ulint,const dtuple_t*,ulint,ulint,btr_cur_t*,ulint,const char*,ulint,mtr_t*)" -> "btr_cur_latch_leaves(ib_page_t*,ulint,ulint,ulint,ulint,btr_cur_t*,mtr_t*)"
"btr_cur_search_to_nth_level(dict_index_t*,ulint,const dtuple_t*,ulint,ulint,btr_cur_t*,ulint,const char*,ulint,mtr_t*)" -> "dict_index_get_lock(dict_index_t*)"
"btr_cur_search_to_nth_level(dict_index_t*,ulint,const dtuple_t*,ulint,ulint,btr_cur_t*,ulint,const char*,ulint,mtr_t*)" -> "btr_block_get_func(ulint,ulint,ulint,ulint,const char*,ulint,mtr_t*)"
"btr_cur_search_to_nth_level(dict_index_t*,ulint,const dtuple_t*,ulint,ulint,btr_cur_t*,ulint,const char*,ulint,mtr_t*)" -> "rec_offs_set_n_alloc(ulint*,ulint)"
"btr_cur_search_to_nth_level(dict_index_t*,ulint,const dtuple_t*,ulint,ulint,btr_cur_t*,ulint,const char*,ulint,mtr_t*)" -> "mem_heap_free_func(mem_heap_t*,const char*,ulint)"
"btr_cur_search_to_nth_level(dict_index_t*,ulint,const dtuple_t*,ulint,ulint,btr_cur_t*,ulint,const char*,ulint,mtr_t*)" -> "mtr_set_savepoint(mtr_t*)"
"btr_cur_search_to_nth_level(dict_index_t*,ulint,const dtuple_t*,ulint,ulint,btr_cur_t*,ulint,const char*,ulint,mtr_t*)" -> "btr_cur_add_path_info(btr_cur_t*,ulint,ulint)"
"btr_cur_search_to_nth_level(dict_index_t*,ulint,const dtuple_t*,ulint,ulint,btr_cur_t*,ulint,const char*,ulint,mtr_t*)" -> "mtr_release_s_latch_at_savepoint(mtr_t*,ulint,rw_lock_t*)"
"btr_cur_search_to_nth_level(dict_index_t*,ulint,const dtuple_t*,ulint,ulint,btr_cur_t*,ulint,const char*,ulint,mtr_t*)" -> "__builtin_expect(long int,long int)"
"btr_cur_search_to_nth_level(dict_index_t*,ulint,const dtuple_t*,ulint,ulint,btr_cur_t*,ulint,const char*,ulint,mtr_t*)" -> "dict_table_is_comp(const dict_table_t*)"
"btr_cur_search_to_nth_level(dict_index_t*,ulint,const dtuple_t*,ulint,ulint,btr_cur_t*,ulint,const char*,ulint,mtr_t*)" -> "ibuf_should_try(dict_index_t*,ulint)"
"btr_cur_search_to_nth_level(dict_index_t*,ulint,const dtuple_t*,ulint,ulint,btr_cur_t*,ulint,const char*,ulint,mtr_t*)" -> "dict_table_zip_size(const dict_table_t*)"
"btr_cur_search_to_nth_level(dict_index_t*,ulint,const dtuple_t*,ulint,ulint,btr_cur_t*,ulint,const char*,ulint,mtr_t*)" -> "page_is_comp(const ib_page_t*)"
"btr_cur_search_to_nth_level(dict_index_t*,ulint,const dtuple_t*,ulint,ulint,btr_cur_t*,ulint,const char*,ulint,mtr_t*)" -> "mtr_s_lock_func(rw_lock_t*,const char*,ulint,mtr_t*)"
"btr_cur_search_to_nth_level(dict_index_t*,ulint,const dtuple_t*,ulint,ulint,btr_cur_t*,ulint,const char*,ulint,mtr_t*)" -> "btr_page_get_level_low(const ib_page_t*)"
"btr_cur_search_to_nth_level(dict_index_t*,ulint,const dtuple_t*,ulint,ulint,btr_cur_t*,ulint,const char*,ulint,mtr_t*)" -> "rw_lock_get_writer(const rw_lock_t*)"
"btr_cur_search_to_nth_level(dict_index_t*,ulint,const dtuple_t*,ulint,ulint,btr_cur_t*,ulint,const char*,ulint,mtr_t*)" -> "mtr_x_lock_func(rw_lock_t*,const char*,ulint,mtr_t*)"
"btr_cur_search_to_nth_level(dict_index_t*,ulint,const dtuple_t*,ulint,ulint,btr_cur_t*,ulint,const char*,ulint,mtr_t*)" -> "btr_search_guess_on_hash(dict_index_t*,btr_search_t*,const dtuple_t*,ulint,ulint,btr_cur_t*,ulint,mtr_t*)"
"btr_cur_search_to_nth_level(dict_index_t*,ulint,const dtuple_t*,ulint,ulint,btr_cur_t*,ulint,const char*,ulint,mtr_t*)" -> "btr_search_get_info(dict_index_t*)"
"btr_cur_search_to_nth_level(dict_index_t*,ulint,const dtuple_t*,ulint,ulint,btr_cur_t*,ulint,const char*,ulint,mtr_t*)" -> "buf_page_get_gen(ulint,ulint,ulint,ulint,buf_block_t*,ulint,const char*,ulint,mtr_t*)"
"btr_cur_search_to_nth_level(dict_index_t*,ulint,const dtuple_t*,ulint,ulint,btr_cur_t*,ulint,const char*,ulint,mtr_t*)" -> "dict_index_get_space(const dict_index_t*)"
"btr_cur_search_to_nth_level(dict_index_t*,ulint,const dtuple_t*,ulint,ulint,btr_cur_t*,ulint,const char*,ulint,mtr_t*)" -> "dict_index_get_page(const dict_index_t*)"
"btr_cur_search_to_nth_level(dict_index_t*,ulint,const dtuple_t*,ulint,ulint,btr_cur_t*,ulint,const char*,ulint,mtr_t*)" -> "rec_get_offsets_func(const rec_t*,const dict_index_t*,ulint*,ulint,mem_heap_t**)"
"btr_cur_search_to_nth_level(dict_index_t*,ulint,const dtuple_t*,ulint,ulint,btr_cur_t*,ulint,const char*,ulint,mtr_t*)" -> "ibuf_insert(ibuf_op_t,const dtuple_t*,dict_index_t*,ulint,ulint,ulint,que_thr_t*)"
"btr_cur_search_to_nth_level(dict_index_t*,ulint,const dtuple_t*,ulint,ulint,btr_cur_t*,ulint,const char*,ulint,mtr_t*)" -> "abort()"
"btr_cur_search_to_nth_level(dict_index_t*,ulint,const dtuple_t*,ulint,ulint,btr_cur_t*,ulint,const char*,ulint,mtr_t*)" -> "btr_search_info_update(dict_index_t*,btr_cur_t*)"
"btr_cur_search_to_nth_level(dict_index_t*,ulint,const dtuple_t*,ulint,ulint,btr_cur_t*,ulint,const char*,ulint,mtr_t*)" -> "btr_corruption_report(const buf_block_t*,const dict_index_t*)"
"btr_cur_search_to_nth_level(dict_index_t*,ulint,const dtuple_t*,ulint,ulint,btr_cur_t*,ulint,const char*,ulint,mtr_t*)" -> "buf_pool_watch_unset(ulint,ulint)"
"btr_cur_search_to_nth_level(dict_index_t*,ulint,const dtuple_t*,ulint,ulint,btr_cur_t*,ulint,const char*,ulint,mtr_t*)" -> "pfs_rw_lock_s_lock_func(rw_lock_t*,ulint,const char*,ulint)"
"btr_cur_search_to_nth_level(dict_index_t*,ulint,const dtuple_t*,ulint,ulint,btr_cur_t*,ulint,const char*,ulint,mtr_t*)" -> "dict_index_is_ibuf(const dict_index_t*)"
"btr_cur_search_to_nth_level(dict_index_t*,ulint,const dtuple_t*,ulint,ulint,btr_cur_t*,ulint,const char*,ulint,mtr_t*)" -> "btr_node_ptr_get_child_page_no(const rec_t*,const ulint*)"
"btr_cur_search_to_nth_level(dict_index_t*,ulint,const dtuple_t*,ulint,ulint,btr_cur_t*,ulint,const char*,ulint,mtr_t*)" -> "row_purge_poss_sec(purge_node_t*,dict_index_t*,const dtuple_t*)"
"btr_cur_search_to_nth_level(dict_index_t*,ulint,const dtuple_t*,ulint,ulint,btr_cur_t*,ulint,const char*,ulint,mtr_t*)" -> "page_cur_search_with_match(const buf_block_t*,const dict_index_t*,const dtuple_t*,ulint,ulint*,ulint*,ulint*,ulint*,page_cur_t*)"
"ibuf_should_try(dict_index_t*,ulint)" -> "dict_index_is_unique(const dict_index_t*)"
"ibuf_should_try(dict_index_t*,ulint)" -> "dict_index_is_clust(const dict_index_t*)"
"btr_search_guess_on_hash(dict_index_t*,btr_search_t*,const dtuple_t*,ulint,ulint,btr_cur_t*,ulint,mtr_t*)" -> "buf_page_make_young(buf_page_t*)"
"btr_search_guess_on_hash(dict_index_t*,btr_search_t*,const dtuple_t*,ulint,ulint,btr_cur_t*,ulint,mtr_t*)" -> "pfs_rw_lock_s_unlock_func(rw_lock_t*)"
"btr_search_guess_on_hash(dict_index_t*,btr_search_t*,const dtuple_t*,ulint,ulint,btr_cur_t*,ulint,mtr_t*)" -> "buf_pool_from_bpage(const buf_page_t*)"
"btr_search_guess_on_hash(dict_index_t*,btr_search_t*,const dtuple_t*,ulint,ulint,btr_cur_t*,ulint,mtr_t*)" -> "pfs_rw_lock_s_lock_func(rw_lock_t*,ulint,const char*,ulint)"
"btr_search_guess_on_hash(dict_index_t*,btr_search_t*,const dtuple_t*,ulint,ulint,btr_cur_t*,ulint,mtr_t*)" -> "buf_block_align(const unsigned char*)"
"btr_search_guess_on_hash(dict_index_t*,btr_search_t*,const dtuple_t*,ulint,ulint,btr_cur_t*,ulint,mtr_t*)" -> "btr_leaf_page_release(buf_block_t*,ulint,mtr_t*)"
"btr_search_guess_on_hash(dict_index_t*,btr_search_t*,const dtuple_t*,ulint,ulint,btr_cur_t*,ulint,mtr_t*)" -> "btr_search_check_guess(btr_cur_t*,ulint,const dtuple_t*,ulint,mtr_t*)"
"btr_search_guess_on_hash(dict_index_t*,btr_search_t*,const dtuple_t*,ulint,ulint,btr_cur_t*,ulint,mtr_t*)" -> "ha_search_and_get_data(hash_table_t*,ulint)"
"btr_search_guess_on_hash(dict_index_t*,btr_search_t*,const dtuple_t*,ulint,ulint,btr_cur_t*,ulint,mtr_t*)" -> "btr_cur_position(dict_index_t*,rec_t*,buf_block_t*,btr_cur_t*)"
"btr_search_guess_on_hash(dict_index_t*,btr_search_t*,const dtuple_t*,ulint,ulint,btr_cur_t*,ulint,mtr_t*)" -> "btr_page_get_index_id(const ib_page_t*)"
"btr_search_guess_on_hash(dict_index_t*,btr_search_t*,const dtuple_t*,ulint,ulint,btr_cur_t*,ulint,mtr_t*)" -> "buf_page_peek_if_too_old(const buf_page_t*)"
"btr_search_guess_on_hash(dict_index_t*,btr_search_t*,const dtuple_t*,ulint,ulint,btr_cur_t*,ulint,mtr_t*)" -> "dtuple_fold(const dtuple_t*,ulint,ulint,index_id_t)"
"btr_search_guess_on_hash(dict_index_t*,btr_search_t*,const dtuple_t*,ulint,ulint,btr_cur_t*,ulint,mtr_t*)" -> "__builtin_expect(long int,long int)"
"btr_search_guess_on_hash(dict_index_t*,btr_search_t*,const dtuple_t*,ulint,ulint,btr_cur_t*,ulint,mtr_t*)" -> "buf_page_get_known_nowait(ulint,buf_block_t*,ulint,const char*,ulint,mtr_t*)"
"btr_search_guess_on_hash(dict_index_t*,btr_search_t*,const dtuple_t*,ulint,ulint,btr_cur_t*,ulint,mtr_t*)" -> "dtuple_get_n_fields(const dtuple_t*)"
"btr_search_guess_on_hash(dict_index_t*,btr_search_t*,const dtuple_t*,ulint,ulint,btr_cur_t*,ulint,mtr_t*)" -> "buf_block_get_state(const buf_block_t*)"
"buf_page_make_young(buf_page_t*)" -> "buf_LRU_make_block_young(buf_page_t*)"
"buf_page_make_young(buf_page_t*)" -> "buf_pool_from_bpage(const buf_page_t*)"
"buf_page_make_young(buf_page_t*)" -> "pfs_mutex_enter_func(ib_mutex_t*,const char*,ulint)"
"buf_page_make_young(buf_page_t*)" -> "pfs_mutex_exit_func(ib_mutex_t*)"
"buf_LRU_make_block_young(buf_page_t*)" -> "buf_LRU_add_block_low(buf_page_t*,ulint)"
"buf_LRU_make_block_young(buf_page_t*)" -> "buf_LRU_remove_block(buf_page_t*)"
"buf_LRU_make_block_young(buf_page_t*)" -> "buf_pool_from_bpage(const buf_page_t*)"
"buf_LRU_add_block_low(buf_page_t*,ulint)" -> "buf_page_in_file(const buf_page_t*)"
"buf_LRU_add_block_low(buf_page_t*,ulint)" -> "__builtin_expect(long int,long int)"
"buf_LRU_add_block_low(buf_page_t*,ulint)" -> "buf_unzip_LRU_add_block(buf_block_t*,ulint)"
"buf_LRU_add_block_low(buf_page_t*,ulint)" -> "ut_dbg_assertion_failed(const char*,const char*,ulint)"
"buf_LRU_add_block_low(buf_page_t*,ulint)" -> "buf_pool_from_bpage(const buf_page_t*)"
"buf_LRU_add_block_low(buf_page_t*,ulint)" -> "ut_list_insert(List&,Type&,Type&,size_t) [with List = ut_list_base<buf_page_t>,Type = buf_page_t,size_t = long unsigned int]"
"buf_LRU_add_block_low(buf_page_t*,ulint)" -> "abort()"
"buf_LRU_add_block_low(buf_page_t*,ulint)" -> "buf_page_belongs_to_unzip_LRU(const buf_page_t*)"
"buf_LRU_add_block_low(buf_page_t*,ulint)" -> "buf_page_set_old(buf_page_t*,ulint)"
"buf_LRU_add_block_low(buf_page_t*,ulint)" -> "incr_LRU_size_in_bytes(buf_page_t*,buf_pool_t*)"
"buf_LRU_add_block_low(buf_page_t*,ulint)" -> "buf_LRU_old_adjust_len(buf_pool_t*)"
"buf_LRU_add_block_low(buf_page_t*,ulint)" -> "ut_list_prepend(List&,Type&,size_t) [with List = ut_list_base<buf_page_t>,Type = buf_page_t,size_t = long unsigned int]"
"buf_LRU_add_block_low(buf_page_t*,ulint)" -> "buf_LRU_old_init(buf_pool_t*)"
"buf_unzip_LRU_add_block(buf_block_t*,ulint)" -> "ut_dbg_assertion_failed(const char*,const char*,ulint)"
"buf_unzip_LRU_add_block(buf_block_t*,ulint)" -> "abort()"
"buf_unzip_LRU_add_block(buf_block_t*,ulint)" -> "buf_pool_from_block(const buf_block_t*)"
"buf_unzip_LRU_add_block(buf_block_t*,ulint)" -> "__builtin_expect(long int,long int)"
"buf_unzip_LRU_add_block(buf_block_t*,ulint)" -> "ut_list_prepend(List&,Type&,size_t) [with List = ut_list_base<buf_block_t>,Type = buf_block_t,size_t = long unsigned int]"
"buf_unzip_LRU_add_block(buf_block_t*,ulint)" -> "buf_page_belongs_to_unzip_LRU(const buf_page_t*)"
"buf_unzip_LRU_add_block(buf_block_t*,ulint)" -> "ut_list_append(List&,Type&,size_t) [with List = ut_list_base<buf_block_t>,Type = buf_block_t,size_t = long unsigned int]"
"ut_list_prepend(List&,Type&,size_t) [with List = ut_list_base<buf_block_t>,Type = buf_block_t,size_t = long unsigned int]" -> "ut_elem_get_node(Type&,size_t) [with Type = buf_block_t,size_t = long unsigned int]"
"ut_list_append(List&,Type&,size_t) [with List = ut_list_base<buf_block_t>,Type = buf_block_t,size_t = long unsigned int]" -> "ut_elem_get_node(Type&,size_t) [with Type = buf_block_t,size_t = long unsigned int]"
"incr_LRU_size_in_bytes(buf_page_t*,buf_pool_t*)" -> "page_zip_get_size(const page_zip_des_t*)"
"buf_LRU_old_init(buf_pool_t*)" -> "ut_dbg_assertion_failed(const char*,const char*,ulint)"
"buf_LRU_old_init(buf_pool_t*)" -> "__builtin_expect(long int,long int)"
"buf_LRU_old_init(buf_pool_t*)" -> "buf_LRU_old_adjust_len(buf_pool_t*)"
"buf_LRU_old_init(buf_pool_t*)" -> "abort()"
"buf_block_align(const unsigned char*)" -> "buf_block_align_instance(buf_pool_t*,const unsigned char*)"
"buf_block_align(const unsigned char*)" -> "buf_pool_from_array(ulint)"
"buf_block_align(const unsigned char*)" -> "ut_dbg_assertion_failed(const char*,const char*,ulint)"
"buf_block_align(const unsigned char*)" -> "abort()"
"buf_block_align_instance(buf_pool_t*,const unsigned char*)" -> "__builtin_expect(long int,long int)"
"btr_search_check_guess(btr_cur_t*,ulint,const dtuple_t*,ulint,mtr_t*)" -> "rec_get_offsets_func(const rec_t*,const dict_index_t*,ulint*,ulint,mem_heap_t**)"
"btr_search_check_guess(btr_cur_t*,ulint,const dtuple_t*,ulint,mtr_t*)" -> "__builtin_expect(long int,long int)"
"btr_search_check_guess(btr_cur_t*,ulint,const dtuple_t*,ulint,mtr_t*)" -> "btr_page_get_prev(const ib_page_t*,mtr_t*)"
"btr_search_check_guess(btr_cur_t*,ulint,const dtuple_t*,ulint,mtr_t*)" -> "page_rec_get_next(rec_t*)"
"btr_search_check_guess(btr_cur_t*,ulint,const dtuple_t*,ulint,mtr_t*)" -> "page_rec_get_prev(rec_t*)"
"btr_search_check_guess(btr_cur_t*,ulint,const dtuple_t*,ulint,mtr_t*)" -> "rec_offs_set_n_alloc(ulint*,ulint)"
"btr_search_check_guess(btr_cur_t*,ulint,const dtuple_t*,ulint,mtr_t*)" -> "page_rec_is_infimum(const rec_t*)"
"btr_search_check_guess(btr_cur_t*,ulint,const dtuple_t*,ulint,mtr_t*)" -> "page_rec_is_supremum(const rec_t*)"
"btr_search_check_guess(btr_cur_t*,ulint,const dtuple_t*,ulint,mtr_t*)" -> "dict_index_get_n_unique_in_tree(const dict_index_t*)"
"btr_search_check_guess(btr_cur_t*,ulint,const dtuple_t*,ulint,mtr_t*)" -> "page_cmp_dtuple_rec_with_match(const dtuple_t*,const rec_t*,const ulint*,ulint*,ulint*)"
"btr_search_check_guess(btr_cur_t*,ulint,const dtuple_t*,ulint,mtr_t*)" -> "mem_heap_free_func(mem_heap_t*,const char*,ulint)"
"btr_search_check_guess(btr_cur_t*,ulint,const dtuple_t*,ulint,mtr_t*)" -> "page_align(const void*)"
"btr_search_check_guess(btr_cur_t*,ulint,const dtuple_t*,ulint,mtr_t*)" -> "btr_page_get_next(const ib_page_t*,mtr_t*)"
"page_cmp_dtuple_rec_with_match(const dtuple_t*,const rec_t*,const ulint*,ulint*,ulint*)" -> "dtuple_get_n_fields_cmp(const dtuple_t*)"
"page_cmp_dtuple_rec_with_match(const dtuple_t*,const rec_t*,const ulint*,ulint*,ulint*)" -> "page_offset(const void*)"
"page_cmp_dtuple_rec_with_match(const dtuple_t*,const rec_t*,const ulint*,ulint*,ulint*)" -> "cmp_dtuple_rec_with_match_low(const dtuple_t*,const rec_t*,const ulint*,ulint,ulint*,ulint*)"
"ha_search_and_get_data(hash_table_t*,ulint)" -> "ha_chain_get_next(ha_node_t*)"
"ha_search_and_get_data(hash_table_t*,ulint)" -> "ha_chain_get_first(hash_table_t*,ulint)"
"btr_cur_position(dict_index_t*,rec_t*,buf_block_t*,btr_cur_t*)" -> "page_cur_position(const rec_t*,const buf_block_t*,page_cur_t*)"
"buf_page_peek_if_too_old(const buf_page_t*)" -> "buf_pool_from_bpage(const buf_page_t*)"
"buf_page_peek_if_too_old(const buf_page_t*)" -> "ut_time_ms()"
"buf_page_peek_if_too_old(const buf_page_t*)" -> "buf_page_is_accessed(const buf_page_t*)"
"buf_page_peek_if_too_old(const buf_page_t*)" -> "buf_page_peek_if_young(const buf_page_t*)"
"dtuple_fold(const dtuple_t*,ulint,ulint,index_id_t)" -> "ut_fold_ulint_pair(ulint,ulint)"
"dtuple_fold(const dtuple_t*,ulint,ulint,index_id_t)" -> "dfield_get_len(const dfield_t*)"
"dtuple_fold(const dtuple_t*,ulint,ulint,index_id_t)" -> "ut_fold_binary(const unsigned char*,ulint)"
"dtuple_fold(const dtuple_t*,ulint,ulint,index_id_t)" -> "ut_fold_ull(ib_uint64_t)"
"buf_page_get_known_nowait(ulint,buf_block_t*,ulint,const char*,ulint,mtr_t*)" -> "__builtin_expect(long int,long int)"
"buf_page_get_known_nowait(ulint,buf_block_t*,ulint,const char*,ulint,mtr_t*)" -> "pfs_mutex_enter_func(ib_mutex_t*,const char*,ulint)"
"buf_page_get_known_nowait(ulint,buf_block_t*,ulint,const char*,ulint,mtr_t*)" -> "pfs_rw_lock_x_lock_func_nowait(rw_lock_t*,const char*,ulint)"
"buf_page_get_known_nowait(ulint,buf_block_t*,ulint,const char*,ulint,mtr_t*)" -> "mtr_memo_push(mtr_t*,void*,ulint)"
"buf_page_get_known_nowait(ulint,buf_block_t*,ulint,const char*,ulint,mtr_t*)" -> "buf_block_buf_fix_dec(buf_block_t*)"
"buf_page_get_known_nowait(ulint,buf_block_t*,ulint,const char*,ulint,mtr_t*)" -> "buf_page_make_young_if_needed(buf_page_t*)"
"buf_page_get_known_nowait(ulint,buf_block_t*,ulint,const char*,ulint,mtr_t*)" -> "buf_pool_from_block(const buf_block_t*)"
"buf_page_get_known_nowait(ulint,buf_block_t*,ulint,const char*,ulint,mtr_t*)" -> "abort()"
"buf_page_get_known_nowait(ulint,buf_block_t*,ulint,const char*,ulint,mtr_t*)" -> "pfs_rw_lock_s_lock_low(rw_lock_t*,ulint,const char*,ulint)"
"buf_page_get_known_nowait(ulint,buf_block_t*,ulint,const char*,ulint,mtr_t*)" -> "buf_page_set_accessed(buf_page_t*)"
"buf_page_get_known_nowait(ulint,buf_block_t*,ulint,const char*,ulint,mtr_t*)" -> "buf_block_get_state(const buf_block_t*)"
"buf_page_get_known_nowait(ulint,buf_block_t*,ulint,const char*,ulint,mtr_t*)" -> "ut_dbg_assertion_failed(const char*,const char*,ulint)"
"buf_page_get_known_nowait(ulint,buf_block_t*,ulint,const char*,ulint,mtr_t*)" -> "pfs_mutex_exit_func(ib_mutex_t*)"
"buf_page_get_known_nowait(ulint,buf_block_t*,ulint,const char*,ulint,mtr_t*)" -> "buf_block_buf_fix_inc_func(buf_block_t*)"
"pfs_rw_lock_x_lock_func_nowait(rw_lock_t*,const char*,ulint)" -> "rw_lock_x_lock_func_nowait(rw_lock_t*,const char*,ulint)"
"rw_lock_x_lock_func_nowait(rw_lock_t*,const char*,ulint)" -> "__sync_bool_compare_and_swap_8(volatile void*,long unsigned int,long unsigned int)"
"rw_lock_x_lock_func_nowait(rw_lock_t*,const char*,ulint)" -> "os_thread_get_curr_id()"
"rw_lock_x_lock_func_nowait(rw_lock_t*,const char*,ulint)" -> "os_thread_eq(os_thread_id_t,os_thread_id_t)"
"rw_lock_x_lock_func_nowait(rw_lock_t*,const char*,ulint)" -> "rw_lock_set_writer_id_and_recursion_flag(rw_lock_t*,ulint)"
"buf_block_buf_fix_dec(buf_block_t*)" -> "__sync_sub_and_fetch_4(volatile void*,unsigned int)"
"buf_page_make_young_if_needed(buf_page_t*)" -> "abort()"
"buf_page_make_young_if_needed(buf_page_t*)" -> "ut_dbg_assertion_failed(const char*,const char*,ulint)"
"buf_page_make_young_if_needed(buf_page_t*)" -> "buf_page_make_young(buf_page_t*)"
"buf_page_make_young_if_needed(buf_page_t*)" -> "buf_page_in_file(const buf_page_t*)"
"buf_page_make_young_if_needed(buf_page_t*)" -> "buf_page_peek_if_too_old(const buf_page_t*)"
"buf_page_make_young_if_needed(buf_page_t*)" -> "__builtin_expect(long int,long int)"
"buf_block_buf_fix_inc_func(buf_block_t*)" -> "__sync_add_and_fetch_4(volatile void*,unsigned int)"
"ibuf_insert(ibuf_op_t,const dtuple_t*,dict_index_t*,ulint,ulint,ulint,que_thr_t*)" -> "abort()"
"ibuf_insert(ibuf_op_t,const dtuple_t*,dict_index_t*,ulint,ulint,ulint,que_thr_t*)" -> "dict_table_is_comp(const dict_table_t*)"
"ibuf_insert(ibuf_op_t,const dtuple_t*,dict_index_t*,ulint,ulint,ulint,que_thr_t*)" -> "buf_pool_get(ulint,ulint)"
"ibuf_insert(ibuf_op_t,const dtuple_t*,dict_index_t*,ulint,ulint,ulint,que_thr_t*)" -> "buf_page_hash_get_locked(buf_pool_t*,ulint,ulint,rw_lock_t**,ulint)"
"ibuf_insert(ibuf_op_t,const dtuple_t*,dict_index_t*,ulint,ulint,ulint,que_thr_t*)" -> "page_get_free_space_of_empty(ulint)"
"ibuf_insert(ibuf_op_t,const dtuple_t*,dict_index_t*,ulint,ulint,ulint,que_thr_t*)" -> "__builtin_expect(long int,long int)"
"ibuf_insert(ibuf_op_t,const dtuple_t*,dict_index_t*,ulint,ulint,ulint,que_thr_t*)" -> "rec_get_converted_size(dict_index_t*,const dtuple_t*,ulint)"
"ibuf_insert(ibuf_op_t,const dtuple_t*,dict_index_t*,ulint,ulint,ulint,que_thr_t*)" -> "ibuf_insert_low(ulint,ibuf_op_t,ulint,const dtuple_t*,ulint,dict_index_t*,ulint,ulint,ulint,que_thr_t*)"
"ibuf_insert(ibuf_op_t,const dtuple_t*,dict_index_t*,ulint,ulint,ulint,que_thr_t*)" -> "dict_index_is_clust(const dict_index_t*)"
"ibuf_insert(ibuf_op_t,const dtuple_t*,dict_index_t*,ulint,ulint,ulint,que_thr_t*)" -> "ut_dbg_assertion_failed(const char*,const char*,ulint)"
"buf_page_hash_get_locked(buf_pool_t*,ulint,ulint,rw_lock_t**,ulint)" -> "buf_pool_watch_is_sentinel(buf_pool_t*,const buf_page_t*)"
"buf_page_hash_get_locked(buf_pool_t*,ulint,ulint,rw_lock_t**,ulint)" -> "pfs_rw_lock_x_lock_func(rw_lock_t*,ulint,const char*,ulint)"
"buf_page_hash_get_locked(buf_pool_t*,ulint,ulint,rw_lock_t**,ulint)" -> "pfs_rw_lock_s_unlock_func(rw_lock_t*)"
"buf_page_hash_get_locked(buf_pool_t*,ulint,ulint,rw_lock_t**,ulint)" -> "pfs_rw_lock_s_lock_func(rw_lock_t*,ulint,const char*,ulint)"
"buf_page_hash_get_locked(buf_pool_t*,ulint,ulint,rw_lock_t**,ulint)" -> "hash_get_lock(hash_table_t*,ulint)"
"buf_page_hash_get_locked(buf_pool_t*,ulint,ulint,rw_lock_t**,ulint)" -> "pfs_rw_lock_x_unlock_func(rw_lock_t*)"
"buf_page_hash_get_locked(buf_pool_t*,ulint,ulint,rw_lock_t**,ulint)" -> "buf_page_hash_get_low(buf_pool_t*,ulint,ulint,ulint)"
"buf_page_hash_get_locked(buf_pool_t*,ulint,ulint,rw_lock_t**,ulint)" -> "buf_page_address_fold(ulint,ulint)"
"rec_get_converted_size(dict_index_t*,const dtuple_t*,ulint)" -> "rec_get_converted_extra_size(ulint,ulint,ulint)"
"rec_get_converted_size(dict_index_t*,const dtuple_t*,ulint)" -> "dtuple_get_n_fields(const dtuple_t*)"
"rec_get_converted_size(dict_index_t*,const dtuple_t*,ulint)" -> "rec_get_converted_size_comp(const dict_index_t*,ulint,const dfield_t*,ulint,ulint*)"
"rec_get_converted_size(dict_index_t*,const dtuple_t*,ulint)" -> "dtuple_get_data_size(const dtuple_t*,ulint)"
"rec_get_converted_size(dict_index_t*,const dtuple_t*,ulint)" -> "dtuple_get_info_bits(const dtuple_t*)"
"rec_get_converted_size(dict_index_t*,const dtuple_t*,ulint)" -> "dict_table_is_comp(const dict_table_t*)"
"ibuf_insert_low(ulint,ibuf_op_t,ulint,const dtuple_t*,ulint,dict_index_t*,ulint,ulint,ulint,que_thr_t*)" -> "ibuf_get_volume_buffered(const btr_pcur_t*,ulint,ulint,lint*,mtr_t*)"
"ibuf_insert_low(ulint,ibuf_op_t,ulint,const dtuple_t*,ulint,dict_index_t*,ulint,ulint,ulint,que_thr_t*)" -> "ibuf_mtr_start(mtr_t*)"
"ibuf_insert_low(ulint,ibuf_op_t,ulint,const dtuple_t*,ulint,dict_index_t*,ulint,ulint,ulint,que_thr_t*)" -> "pfs_mutex_enter_func(ib_mutex_t*,const char*,ulint)"
"ibuf_insert_low(ulint,ibuf_op_t,ulint,const dtuple_t*,ulint,dict_index_t*,ulint,ulint,ulint,que_thr_t*)" -> "btr_pcur_close(btr_pcur_t*)"
"ibuf_insert_low(ulint,ibuf_op_t,ulint,const dtuple_t*,ulint,dict_index_t*,ulint,ulint,ulint,que_thr_t*)" -> "ibuf_tree_root_get(mtr_t*)"
"ibuf_insert_low(ulint,ibuf_op_t,ulint,const dtuple_t*,ulint,dict_index_t*,ulint,ulint,ulint,que_thr_t*)" -> "btr_pcur_open_low(dict_index_t*,ulint,const dtuple_t*,ulint,ulint,btr_pcur_t*,const char*,ulint,mtr_t*)"
"ibuf_insert_low(ulint,ibuf_op_t,ulint,const dtuple_t*,ulint,dict_index_t*,ulint,ulint,ulint,que_thr_t*)" -> "ibuf_add_free_page()"
"ibuf_insert_low(ulint,ibuf_op_t,ulint,const dtuple_t*,ulint,dict_index_t*,ulint,ulint,ulint,que_thr_t*)" -> "mach_write_to_2(unsigned char*,ulint)"
"ibuf_insert_low(ulint,ibuf_op_t,ulint,const dtuple_t*,ulint,dict_index_t*,ulint,ulint,ulint,que_thr_t*)" -> "abort()"
"ibuf_insert_low(ulint,ibuf_op_t,ulint,const dtuple_t*,ulint,dict_index_t*,ulint,ulint,ulint,que_thr_t*)" -> "ibuf_data_enough_free_for_insert()"
"ibuf_insert_low(ulint,ibuf_op_t,ulint,const dtuple_t*,ulint,dict_index_t*,ulint,ulint,ulint,que_thr_t*)" -> "page_dir_calc_reserved_space(ulint)"
"ibuf_insert_low(ulint,ibuf_op_t,ulint,const dtuple_t*,ulint,dict_index_t*,ulint,ulint,ulint,que_thr_t*)" -> "page_is_empty(const ib_page_t*)"
"ibuf_insert_low(ulint,ibuf_op_t,ulint,const dtuple_t*,ulint,dict_index_t*,ulint,ulint,ulint,que_thr_t*)" -> "mem_heap_create_func(ulint,ulint)"
"ibuf_insert_low(ulint,ibuf_op_t,ulint,const dtuple_t*,ulint,dict_index_t*,ulint,ulint,ulint,que_thr_t*)" -> "buf_pool_watch_occurred(ulint,ulint)"
"ibuf_insert_low(ulint,ibuf_op_t,ulint,const dtuple_t*,ulint,dict_index_t*,ulint,ulint,ulint,que_thr_t*)" -> "ibuf_size_update(const ib_page_t*,mtr_t*)"
"ibuf_insert_low(ulint,ibuf_op_t,ulint,const dtuple_t*,ulint,dict_index_t*,ulint,ulint,ulint,que_thr_t*)" -> "dict_index_is_clust(const dict_index_t*)"
"ibuf_insert_low(ulint,ibuf_op_t,ulint,const dtuple_t*,ulint,dict_index_t*,ulint,ulint,ulint,que_thr_t*)" -> "ibuf_bitmap_get_map_page_func(ulint,ulint,ulint,const char*,ulint,mtr_t*)"
"ibuf_insert_low(ulint,ibuf_op_t,ulint,const dtuple_t*,ulint,dict_index_t*,ulint,ulint,ulint,que_thr_t*)" -> "ibuf_mtr_commit(mtr_t*)"
"ibuf_insert_low(ulint,ibuf_op_t,ulint,const dtuple_t*,ulint,dict_index_t*,ulint,ulint,ulint,que_thr_t*)" -> "__builtin_expect(long int,long int)"
"ibuf_insert_low(ulint,ibuf_op_t,ulint,const dtuple_t*,ulint,dict_index_t*,ulint,ulint,ulint,que_thr_t*)" -> "ut_dbg_assertion_failed(const char*,const char*,ulint)"
"ibuf_insert_low(ulint,ibuf_op_t,ulint,const dtuple_t*,ulint,dict_index_t*,ulint,ulint,ulint,que_thr_t*)" -> "btr_cur_pessimistic_insert(ulint,btr_cur_t*,ulint**,mem_heap_t**,dtuple_t*,rec_t**,big_rec_t**,ulint,que_thr_t*,mtr_t*)"
"ibuf_insert_low(ulint,ibuf_op_t,ulint,const dtuple_t*,ulint,dict_index_t*,ulint,ulint,ulint,que_thr_t*)" -> "ibuf_contract(ulint)"
"ibuf_insert_low(ulint,ibuf_op_t,ulint,const dtuple_t*,ulint,dict_index_t*,ulint,ulint,ulint,que_thr_t*)" -> "ibuf_get_merge_page_nos_func(ulint,const rec_t*,ulint*,ib_int64_t*,ulint*,ulint*)"
"ibuf_insert_low(ulint,ibuf_op_t,ulint,const dtuple_t*,ulint,dict_index_t*,ulint,ulint,ulint,que_thr_t*)" -> "pfs_mutex_exit_func(ib_mutex_t*)"
"ibuf_insert_low(ulint,ibuf_op_t,ulint,const dtuple_t*,ulint,dict_index_t*,ulint,ulint,ulint,que_thr_t*)" -> "buf_block_get_page_no(const buf_block_t*)"
"ibuf_insert_low(ulint,ibuf_op_t,ulint,const dtuple_t*,ulint,dict_index_t*,ulint,ulint,ulint,que_thr_t*)" -> "lock_rec_expl_exist_on_page(ulint,ulint)"
"ibuf_insert_low(ulint,ibuf_op_t,ulint,const dtuple_t*,ulint,dict_index_t*,ulint,ulint,ulint,que_thr_t*)" -> "buf_read_ibuf_merge_pages(bool,const ulint*,const ib_int64_t*,const ulint*,ulint)"
"ibuf_insert_low(ulint,ibuf_op_t,ulint,const dtuple_t*,ulint,dict_index_t*,ulint,ulint,ulint,que_thr_t*)" -> "page_update_max_trx_id(buf_block_t*,page_zip_des_t*,trx_id_t,mtr_t*)"
"ibuf_insert_low(ulint,ibuf_op_t,ulint,const dtuple_t*,ulint,dict_index_t*,ulint,ulint,ulint,que_thr_t*)" -> "buf_page_peek(ulint,ulint)"
"ibuf_insert_low(ulint,ibuf_op_t,ulint,const dtuple_t*,ulint,dict_index_t*,ulint,ulint,ulint,que_thr_t*)" -> "btr_cur_optimistic_insert(ulint,btr_cur_t*,ulint**,mem_heap_t**,dtuple_t*,rec_t**,big_rec_t**,ulint,que_thr_t*,mtr_t*)"
"ibuf_insert_low(ulint,ibuf_op_t,ulint,const dtuple_t*,ulint,dict_index_t*,ulint,ulint,ulint,que_thr_t*)" -> "ibuf_index_page_calc_free_from_bits(ulint,ulint)"
"ibuf_insert_low(ulint,ibuf_op_t,ulint,const dtuple_t*,ulint,dict_index_t*,ulint,ulint,ulint,que_thr_t*)" -> "ibuf_entry_build(ibuf_op_t,dict_index_t*,const dtuple_t*,ulint,ulint,ulint,mem_heap_t*)"
"ibuf_insert_low(ulint,ibuf_op_t,ulint,const dtuple_t*,ulint,dict_index_t*,ulint,ulint,ulint,que_thr_t*)" -> "ibuf_bitmap_page_set_bits(ib_page_t*,ulint,ulint,ulint,ulint,mtr_t*)"
"ibuf_insert_low(ulint,ibuf_op_t,ulint,const dtuple_t*,ulint,dict_index_t*,ulint,ulint,ulint,que_thr_t*)" -> "ibuf_get_entry_counter_func(ulint,ulint,const rec_t*,ulint)"
"ibuf_insert_low(ulint,ibuf_op_t,ulint,const dtuple_t*,ulint,dict_index_t*,ulint,ulint,ulint,que_thr_t*)" -> "mem_heap_free_func(mem_heap_t*,const char*,ulint)"
"ibuf_insert_low(ulint,ibuf_op_t,ulint,const dtuple_t*,ulint,dict_index_t*,ulint,ulint,ulint,que_thr_t*)" -> "ibuf_bitmap_page_get_bits_low(const ib_page_t*,ulint,ulint,ulint)"
"ibuf_insert_low(ulint,ibuf_op_t,ulint,const dtuple_t*,ulint,dict_index_t*,ulint,ulint,ulint,que_thr_t*)" -> "thr_get_trx(que_thr_t*)"
"ibuf_insert_low(ulint,ibuf_op_t,ulint,const dtuple_t*,ulint,dict_index_t*,ulint,ulint,ulint,que_thr_t*)" -> "ibuf_contract_after_insert(ulint)"
"ibuf_get_volume_buffered(const btr_pcur_t*,ulint,ulint,lint*,mtr_t*)" -> "ibuf_rec_get_space_func(const rec_t*)"
"ibuf_get_volume_buffered(const btr_pcur_t*,ulint,ulint,lint*,mtr_t*)" -> "buf_page_get_gen(ulint,ulint,ulint,ulint,buf_block_t*,ulint,const char*,ulint,mtr_t*)"
"ibuf_get_volume_buffered(const btr_pcur_t*,ulint,ulint,lint*,mtr_t*)" -> "memset(void*,int,size_t)"
"ibuf_get_volume_buffered(const btr_pcur_t*,ulint,ulint,lint*,mtr_t*)" -> "__builtin_expect(long int,long int)"
"ibuf_get_volume_buffered(const btr_pcur_t*,ulint,ulint,lint*,mtr_t*)" -> "ibuf_get_volume_buffered_count_func(const rec_t*,ulint*,ulint,lint*)"
"ibuf_get_volume_buffered(const btr_pcur_t*,ulint,ulint,lint*,mtr_t*)" -> "page_get_page_no(const ib_page_t*)"
"ibuf_get_volume_buffered(const btr_pcur_t*,ulint,ulint,lint*,mtr_t*)" -> "page_rec_get_next_const(const rec_t*)"
"ibuf_get_volume_buffered(const btr_pcur_t*,ulint,ulint,lint*,mtr_t*)" -> "ibuf_rec_get_page_no_func(const rec_t*)"
"ibuf_get_volume_buffered(const btr_pcur_t*,ulint,ulint,lint*,mtr_t*)" -> "btr_page_get_next(const ib_page_t*,mtr_t*)"
"ibuf_get_volume_buffered(const btr_pcur_t*,ulint,ulint,lint*,mtr_t*)" -> "ut_dbg_assertion_failed(const char*,const char*,ulint)"
"ibuf_get_volume_buffered(const btr_pcur_t*,ulint,ulint,lint*,mtr_t*)" -> "page_rec_is_supremum(const rec_t*)"
"ibuf_get_volume_buffered(const btr_pcur_t*,ulint,ulint,lint*,mtr_t*)" -> "page_rec_get_prev_const(const rec_t*)"
"ibuf_get_volume_buffered(const btr_pcur_t*,ulint,ulint,lint*,mtr_t*)" -> "page_get_supremum_offset(const ib_page_t*)"
"ibuf_get_volume_buffered(const btr_pcur_t*,ulint,ulint,lint*,mtr_t*)" -> "page_rec_is_infimum(const rec_t*)"
"ibuf_get_volume_buffered(const btr_pcur_t*,ulint,ulint,lint*,mtr_t*)" -> "btr_page_get_prev(const ib_page_t*,mtr_t*)"
"ibuf_get_volume_buffered(const btr_pcur_t*,ulint,ulint,lint*,mtr_t*)" -> "page_align(const void*)"
"ibuf_get_volume_buffered(const btr_pcur_t*,ulint,ulint,lint*,mtr_t*)" -> "page_get_infimum_offset(const ib_page_t*)"
"ibuf_get_volume_buffered(const btr_pcur_t*,ulint,ulint,lint*,mtr_t*)" -> "abort()"
"ibuf_rec_get_space_func(const rec_t*)" -> "abort()"
"ibuf_rec_get_space_func(const rec_t*)" -> "mach_read_from_4(const unsigned char*)"
"ibuf_rec_get_space_func(const rec_t*)" -> "rec_get_nth_field_offs_old(const rec_t*,ulint,ulint*)"
"ibuf_rec_get_space_func(const rec_t*)" -> "__builtin_expect(long int,long int)"
"ibuf_rec_get_space_func(const rec_t*)" -> "ut_dbg_assertion_failed(const char*,const char*,ulint)"
"ibuf_get_volume_buffered_count_func(const rec_t*,ulint*,ulint,lint*)" -> "abort()"
"ibuf_get_volume_buffered_count_func(const rec_t*,ulint*,ulint,lint*)" -> "rec_get_nth_field_offs_old(const rec_t*,ulint,ulint*)"
"ibuf_get_volume_buffered_count_func(const rec_t*,ulint*,ulint,lint*)" -> "ibuf_dummy_index_free(dict_index_t*)"
"ibuf_get_volume_buffered_count_func(const rec_t*,ulint*,ulint,lint*)" -> "page_dir_calc_reserved_space(ulint)"
"ibuf_get_volume_buffered_count_func(const rec_t*,ulint*,ulint,lint*)" -> "mem_heap_create_func(ulint,ulint)"
"ibuf_get_volume_buffered_count_func(const rec_t*,ulint*,ulint,lint*)" -> "ibuf_build_entry_from_ibuf_rec_func(const rec_t*,mem_heap_t*,dict_index_t**)"
"ibuf_get_volume_buffered_count_func(const rec_t*,ulint*,ulint,lint*)" -> "ibuf_rec_get_size(const rec_t*,const unsigned char*,ulint,ulint)"
"ibuf_get_volume_buffered_count_func(const rec_t*,ulint*,ulint,lint*)" -> "__builtin_expect(long int,long int)"
"ibuf_get_volume_buffered_count_func(const rec_t*,ulint*,ulint,lint*)" -> "rec_get_n_fields_old(const rec_t*)"
"ibuf_get_volume_buffered_count_func(const rec_t*,ulint*,ulint,lint*)" -> "ut_dbg_assertion_failed(const char*,const char*,ulint)"
"ibuf_get_volume_buffered_count_func(const rec_t*,ulint*,ulint,lint*)" -> "mem_heap_free_func(mem_heap_t*,const char*,ulint)"
"ibuf_get_volume_buffered_count_func(const rec_t*,ulint*,ulint,lint*)" -> "rec_get_converted_size(dict_index_t*,const dtuple_t*,ulint)"
"ibuf_get_volume_buffered_count_func(const rec_t*,ulint*,ulint,lint*)" -> "rec_get_converted_extra_size(ulint,ulint,ulint)"
"ibuf_get_volume_buffered_count_func(const rec_t*,ulint*,ulint,lint*)" -> "ibuf_get_volume_buffered_hash(const rec_t*,const unsigned char*,const unsigned char*,ulint,ulint*,ulint)"
"ibuf_get_volume_buffered_count_func(const rec_t*,ulint*,ulint,lint*)" -> "rec_get_deleted_flag(const rec_t*,ulint)"
"ibuf_dummy_index_free(dict_index_t*)" -> "dict_mem_index_free(dict_index_t*)"
"ibuf_dummy_index_free(dict_index_t*)" -> "dict_mem_table_free(dict_table_t*)"
"dict_mem_index_free(dict_index_t*)" -> "mem_heap_free_func(mem_heap_t*,const char*,ulint)"
"dict_mem_index_free(dict_index_t*)" -> "pfs_os_fast_mutex_free(os_fast_mutex_t*)"
"ibuf_build_entry_from_ibuf_rec_func(const rec_t*,mem_heap_t*,dict_index_t**)" -> "dfield_set_data(dfield_t*,const void*,ulint)"
"ibuf_build_entry_from_ibuf_rec_func(const rec_t*,mem_heap_t*,dict_index_t**)" -> "dtype_new_read_for_order_and_null_size(dtype_t*,const unsigned char*)"
"ibuf_build_entry_from_ibuf_rec_func(const rec_t*,mem_heap_t*,dict_index_t**)" -> "rec_get_n_fields_old(const rec_t*)"
"ibuf_build_entry_from_ibuf_rec_func(const rec_t*,mem_heap_t*,dict_index_t**)" -> "ibuf_dummy_index_create(ulint,ulint)"
"ibuf_build_entry_from_ibuf_rec_func(const rec_t*,mem_heap_t*,dict_index_t**)" -> "ut_dbg_assertion_failed(const char*,const char*,ulint)"
"ibuf_build_entry_from_ibuf_rec_func(const rec_t*,mem_heap_t*,dict_index_t**)" -> "ibuf_dummy_index_add_col(dict_index_t*,const dtype_t*,ulint)"
"ibuf_build_entry_from_ibuf_rec_func(const rec_t*,mem_heap_t*,dict_index_t**)" -> "__builtin_expect(long int,long int)"
"ibuf_build_entry_from_ibuf_rec_func(const rec_t*,mem_heap_t*,dict_index_t**)" -> "ibuf_rec_get_info_func(const rec_t*,ibuf_op_t*,ulint*,ulint*,ulint*)"
"ibuf_build_entry_from_ibuf_rec_func(const rec_t*,mem_heap_t*,dict_index_t**)" -> "dtuple_create(mem_heap_t*,ulint)"
"ibuf_build_entry_from_ibuf_rec_func(const rec_t*,mem_heap_t*,dict_index_t**)" -> "rec_get_nth_field_offs_old(const rec_t*,ulint,ulint*)"
"ibuf_build_entry_from_ibuf_rec_func(const rec_t*,mem_heap_t*,dict_index_t**)" -> "abort()"
"dtype_new_read_for_order_and_null_size(dtype_t*,const unsigned char*)" -> "mach_read_from_2(const unsigned char*)"
"dtype_new_read_for_order_and_null_size(dtype_t*,const unsigned char*)" -> "dtype_form_prtype(ulint,ulint)"
"dtype_new_read_for_order_and_null_size(dtype_t*,const unsigned char*)" -> "dtype_is_string_type(ulint)"
"dtype_new_read_for_order_and_null_size(dtype_t*,const unsigned char*)" -> "ut_dbg_assertion_failed(const char*,const char*,ulint)"
"dtype_new_read_for_order_and_null_size(dtype_t*,const unsigned char*)" -> "dtype_set_mblen(dtype_t*)"
"dtype_new_read_for_order_and_null_size(dtype_t*,const unsigned char*)" -> "__builtin_expect(long int,long int)"
"dtype_new_read_for_order_and_null_size(dtype_t*,const unsigned char*)" -> "abort()"
"dtype_form_prtype(ulint,ulint)" -> "abort()"
"dtype_form_prtype(ulint,ulint)" -> "__builtin_expect(long int,long int)"
"dtype_form_prtype(ulint,ulint)" -> "ut_dbg_assertion_failed(const char*,const char*,ulint)"
"ibuf_dummy_index_create(ulint,ulint)" -> "dict_mem_index_create(const char*,const char*,ulint,ulint,ulint)"
"ibuf_dummy_index_create(ulint,ulint)" -> "dict_mem_table_create(const char*,ulint,ulint,ulint,ulint)"
"dict_mem_index_create(const char*,const char*,ulint,ulint,ulint)" -> "pfs_os_fast_mutex_init(PSI_mutex_key,os_fast_mutex_t*)"
"dict_mem_index_create(const char*,const char*,ulint,ulint,ulint)" -> "mem_heap_zalloc(mem_heap_t*,ulint)"
"dict_mem_index_create(const char*,const char*,ulint,ulint,ulint)" -> "dict_mem_fill_index_struct(dict_index_t*,mem_heap_t*,const char*,const char*,ulint,ulint,ulint)"
"dict_mem_index_create(const char*,const char*,ulint,ulint,ulint)" -> "mem_heap_create_func(ulint,ulint)"
"dict_mem_fill_index_struct(dict_index_t*,mem_heap_t*,const char*,const char*,ulint,ulint,ulint)" -> "mem_heap_alloc(mem_heap_t*,ulint)"
"dict_mem_fill_index_struct(dict_index_t*,mem_heap_t*,const char*,const char*,ulint,ulint,ulint)" -> "mem_heap_strdup(mem_heap_t*,const char*)"
"mem_heap_strdup(mem_heap_t*,const char*)" -> "strlen(const char*)"
"mem_heap_strdup(mem_heap_t*,const char*)" -> "mem_heap_dup(mem_heap_t*,const void*,ulint)"
"dict_mem_table_create(const char*,ulint,ulint,ulint,ulint)" -> "pfs_mutex_create_func(mysql_pfs_key_t,ib_mutex_t*,const char*,ulint)"
"dict_mem_table_create(const char*,ulint,ulint,ulint,ulint)" -> "dict_tf_is_valid(ulint)"
"dict_mem_table_create(const char*,ulint,ulint,ulint,ulint)" -> "ut_malloc_low(ulint,ulint)"
"dict_mem_table_create(const char*,ulint,ulint,ulint,ulint)" -> "strlen(const char*)"
"dict_mem_table_create(const char*,ulint,ulint,ulint,ulint)" -> "__builtin_expect(long int,long int)"
"dict_mem_table_create(const char*,ulint,ulint,ulint,ulint)" -> "dict_table_has_fts_index(dict_table_t*)"
"dict_mem_table_create(const char*,ulint,ulint,ulint,ulint)" -> "ut_dbg_assertion_failed(const char*,const char*,ulint)"
"dict_mem_table_create(const char*,ulint,ulint,ulint,ulint)" -> "mem_heap_zalloc(mem_heap_t*,ulint)"
"dict_mem_table_create(const char*,ulint,ulint,ulint,ulint)" -> "mem_heap_alloc(mem_heap_t*,ulint)"
"dict_mem_table_create(const char*,ulint,ulint,ulint,ulint)" -> "fts_create(dict_table_t*)"
"dict_mem_table_create(const char*,ulint,ulint,ulint,ulint)" -> "lock_get_size()"
"dict_mem_table_create(const char*,ulint,ulint,ulint,ulint)" -> "abort()"
"dict_mem_table_create(const char*,ulint,ulint,ulint,ulint)" -> "dict_table_stats_latch_create(dict_table_t*,bool)"
"dict_mem_table_create(const char*,ulint,ulint,ulint,ulint)" -> "fts_cache_create(dict_table_t*)"
"dict_mem_table_create(const char*,ulint,ulint,ulint,ulint)" -> "mem_heap_create_func(ulint,ulint)"
"dict_mem_table_create(const char*,ulint,ulint,ulint,ulint)" -> "_Alloc>::set() [with _Key = dict_foreign_t*,_Compare = dict_foreign_compare,_Alloc = std::allocator<dict_foreign_t*>]"
"dict_mem_table_create(const char*,ulint,ulint,ulint,ulint)" -> "memcpy(void*,const void*,size_t)"
"fts_create(dict_table_t*)" -> "mem_heap_alloc(mem_heap_t*,ulint)"
"fts_create(dict_table_t*)" -> "memset(void*,int,size_t)"
"fts_create(dict_table_t*)" -> "__builtin_expect(long int,long int)"
"fts_create(dict_table_t*)" -> "ut_dbg_assertion_failed(const char*,const char*,ulint)"
"fts_create(dict_table_t*)" -> "ib_vector_create(ib_alloc_t*,ulint,ulint)"
"fts_create(dict_table_t*)" -> "dict_table_get_all_fts_indexes(dict_table_t*,ib_vector_t*)"
"fts_create(dict_table_t*)" -> "pfs_mutex_create_func(mysql_pfs_key_t,ib_mutex_t*,const char*,ulint)"
"fts_create(dict_table_t*)" -> "abort()"
"fts_create(dict_table_t*)" -> "ib_heap_allocator_create(mem_heap_t*)"
"fts_create(dict_table_t*)" -> "mem_heap_create_func(ulint,ulint)"
"dict_table_get_all_fts_indexes(dict_table_t*,ib_vector_t*)" -> "ib_vector_size(const ib_vector_t*)"
"dict_table_get_all_fts_indexes(dict_table_t*,ib_vector_t*)" -> "ib_vector_push(ib_vector_t*,const void*)"
"dict_table_get_all_fts_indexes(dict_table_t*,ib_vector_t*)" -> "__builtin_expect(long int,long int)"
"dict_table_get_all_fts_indexes(dict_table_t*,ib_vector_t*)" -> "abort()"
"dict_table_get_all_fts_indexes(dict_table_t*,ib_vector_t*)" -> "ut_dbg_assertion_failed(const char*,const char*,ulint)"
"fts_cache_create(dict_table_t*)" -> "pfs_rw_lock_create_func(mysql_pfs_key_t,rw_lock_t*,const char*,ulint)"
"fts_cache_create(dict_table_t*)" -> "pfs_mutex_create_func(mysql_pfs_key_t,ib_mutex_t*,const char*,ulint)"
"fts_cache_create(dict_table_t*)" -> "ib_vector_create(ib_alloc_t*,ulint,ulint)"
"fts_cache_create(dict_table_t*)" -> "fts_cache_init(fts_cache_t*)"
"fts_cache_create(dict_table_t*)" -> "mem_heap_zalloc(mem_heap_t*,ulint)"
"fts_cache_create(dict_table_t*)" -> "ib_heap_allocator_create(mem_heap_t*)"
"fts_cache_create(dict_table_t*)" -> "mem_heap_create_func(ulint,ulint)"
"pfs_rw_lock_create_func(mysql_pfs_key_t,rw_lock_t*,const char*,ulint)" -> "rw_lock_create_func(rw_lock_t*,const char*,ulint)"
"rw_lock_create_func(rw_lock_t*,const char*,ulint)" -> "os_event_create()"
"rw_lock_create_func(rw_lock_t*,const char*,ulint)" -> "memset(void*,int,size_t)"
"rw_lock_create_func(rw_lock_t*,const char*,ulint)" -> "ut_list_prepend(List&,Type&,size_t) [with List = ut_list_base<rw_lock_t>,Type = rw_lock_t,size_t = long unsigned int]"
"rw_lock_create_func(rw_lock_t*,const char*,ulint)" -> "pfs_mutex_exit_func(ib_mutex_t*)"
"rw_lock_create_func(rw_lock_t*,const char*,ulint)" -> "pfs_mutex_enter_func(ib_mutex_t*,const char*,ulint)"
"ut_list_prepend(List&,Type&,size_t) [with List = ut_list_base<rw_lock_t>,Type = rw_lock_t,size_t = long unsigned int]" -> "ut_elem_get_node(Type&,size_t) [with Type = rw_lock_t,size_t = long unsigned int]"
"fts_cache_init(fts_cache_t*)" -> "ib_vector_size(const ib_vector_t*)"
"fts_cache_init(fts_cache_t*)" -> "mem_heap_create_func(ulint,ulint)"
"fts_cache_init(fts_cache_t*)" -> "pfs_mutex_exit_func(ib_mutex_t*)"
"fts_cache_init(fts_cache_t*)" -> "__builtin_expect(long int,long int)"
"fts_cache_init(fts_cache_t*)" -> "ib_vector_create(ib_alloc_t*,ulint,ulint)"
"fts_cache_init(fts_cache_t*)" -> "ib_vector_get(ib_vector_t*,ulint)"
"fts_cache_init(fts_cache_t*)" -> "ut_dbg_assertion_failed(const char*,const char*,ulint)"
"fts_cache_init(fts_cache_t*)" -> "fts_index_cache_init(ib_alloc_t*,fts_index_cache_t*)"
"fts_cache_init(fts_cache_t*)" -> "pfs_mutex_enter_func(ib_mutex_t*,const char*,ulint)"
"fts_cache_init(fts_cache_t*)" -> "abort()"
"fts_index_cache_init(ib_alloc_t*,fts_index_cache_t*)" -> "rbt_create_arg_cmp(size_t,ib_rbt_arg_compare,void*)"
"fts_index_cache_init(ib_alloc_t*,fts_index_cache_t*)" -> "ib_vector_create(ib_alloc_t*,ulint,ulint)"
"fts_index_cache_init(ib_alloc_t*,fts_index_cache_t*)" -> "__builtin_expect(long int,long int)"
"fts_index_cache_init(ib_alloc_t*,fts_index_cache_t*)" -> "ut_dbg_assertion_failed(const char*,const char*,ulint)"
"fts_index_cache_init(ib_alloc_t*,fts_index_cache_t*)" -> "abort()"
"rbt_create_arg_cmp(size_t,ib_rbt_arg_compare,void*)" -> "abort()"
"rbt_create_arg_cmp(size_t,ib_rbt_arg_compare,void*)" -> "rbt_create(size_t,ib_rbt_compare)"
"rbt_create_arg_cmp(size_t,ib_rbt_arg_compare,void*)" -> "__builtin_expect(long int,long int)"
"rbt_create_arg_cmp(size_t,ib_rbt_arg_compare,void*)" -> "ut_dbg_assertion_failed(const char*,const char*,ulint)"
"rbt_create(size_t,ib_rbt_compare)" -> "ut_malloc_low(ulint,ulint)"
"rbt_create(size_t,ib_rbt_compare)" -> "memset(void*,int,size_t)"
"_Alloc>::set() [with _Key = dict_foreign_t*,_Compare = dict_foreign_compare,_Alloc = std::allocator<dict_foreign_t*>]" -> "_Alloc>::_Rb_tree() [with _Key = dict_foreign_t*,_Val = dict_foreign_t*,_KeyOfValue = std::_Identity<dict_foreign_t*>,_Compare = dict_foreign_compare,_Alloc = std::allocator<dict_foreign_t*>]"
"_Alloc>::_Rb_tree() [with _Key = dict_foreign_t*,_Val = dict_foreign_t*,_KeyOfValue = std::_Identity<dict_foreign_t*>,_Compare = dict_foreign_compare,_Alloc = std::allocator<dict_foreign_t*>]" -> "_Is_pod_comparator>::_Rb_tree_impl() [with _Key_compare = dict_foreign_compare,bool _Is_pod_comparator = true,_Key = dict_foreign_t*,_Val = dict_foreign_t*,_KeyOfValue = std::_Identity<dict_foreign_t*>,_Compare = dict_foreign_compare,_Alloc = std::allocator<dict_foreign_t*>]"
"_Is_pod_comparator>::_Rb_tree_impl() [with _Key_compare = dict_foreign_compare,bool _Is_pod_comparator = true,_Key = dict_foreign_t*,_Val = dict_foreign_t*,_KeyOfValue = std::_Identity<dict_foreign_t*>,_Compare = dict_foreign_compare,_Alloc = std::allocator<dict_foreign_t*>]" -> "_Is_pod_comparator>::_M_initialize() [with _Key_compare = dict_foreign_compare,bool _Is_pod_comparator = true,_Key = dict_foreign_t*,_Val = dict_foreign_t*,_KeyOfValue = std::_Identity<dict_foreign_t*>,_Compare = dict_foreign_compare,_Alloc = std::allocator<dict_foreign_t*>]"
"_Is_pod_comparator>::_Rb_tree_impl() [with _Key_compare = dict_foreign_compare,bool _Is_pod_comparator = true,_Key = dict_foreign_t*,_Val = dict_foreign_t*,_KeyOfValue = std::_Identity<dict_foreign_t*>,_Compare = dict_foreign_compare,_Alloc = std::allocator<dict_foreign_t*>]" -> "std::allocator<_Tp>::allocator() [with _Tp = std::_Rb_tree_node<dict_foreign_t*>]"
"std::allocator<_Tp>::allocator() [with _Tp = std::_Rb_tree_node<dict_foreign_t*>]" -> "__gnu_cxx::new_allocator<_Tp>::new_allocator() [with _Tp = std::_Rb_tree_node<dict_foreign_t*>]"
"ibuf_dummy_index_add_col(dict_index_t*,const dtype_t*,ulint)" -> "dtype_get_mtype(const dtype_t*)"
"ibuf_dummy_index_add_col(dict_index_t*,const dtype_t*,ulint)" -> "dict_mem_table_add_col(dict_table_t*,mem_heap_t*,const char*,ulint,ulint,ulint)"
"ibuf_dummy_index_add_col(dict_index_t*,const dtype_t*,ulint)" -> "dict_index_add_col(dict_index_t*,const dict_table_t*,dict_col_t*,ulint)"
"ibuf_dummy_index_add_col(dict_index_t*,const dtype_t*,ulint)" -> "dtype_get_prtype(const dtype_t*)"
"ibuf_dummy_index_add_col(dict_index_t*,const dtype_t*,ulint)" -> "dtype_get_len(const dtype_t*)"
"dict_index_add_col(dict_index_t*,const dict_table_t*,dict_col_t*,ulint)" -> "dict_table_get_col_name(const dict_table_t*,ulint)"
"dict_index_add_col(dict_index_t*,const dict_table_t*,dict_col_t*,ulint)" -> "dict_mem_index_add_field(dict_index_t*,const char*,ulint)"
"dict_index_add_col(dict_index_t*,const dict_table_t*,dict_col_t*,ulint)" -> "dict_col_get_fixed_size(const dict_col_t*,ulint)"
"dict_index_add_col(dict_index_t*,const dict_table_t*,dict_col_t*,ulint)" -> "dict_table_is_comp(const dict_table_t*)"
"dict_index_add_col(dict_index_t*,const dict_table_t*,dict_col_t*,ulint)" -> "dict_col_get_no(const dict_col_t*)"
"ibuf_rec_get_info_func(const rec_t*,ibuf_op_t*,ulint*,ulint*,ulint*)" -> "ut_dbg_assertion_failed(const char*,const char*,ulint)"
"ibuf_rec_get_info_func(const rec_t*,ibuf_op_t*,ulint*,ulint*,ulint*)" -> "abort()"
"ibuf_rec_get_info_func(const rec_t*,ibuf_op_t*,ulint*,ulint*,ulint*)" -> "mach_read_from_2(const unsigned char*)"
"ibuf_rec_get_info_func(const rec_t*,ibuf_op_t*,ulint*,ulint*,ulint*)" -> "rec_get_n_fields_old(const rec_t*)"
"ibuf_rec_get_info_func(const rec_t*,ibuf_op_t*,ulint*,ulint*,ulint*)" -> "rec_get_nth_field_offs_old(const rec_t*,ulint,ulint*)"
"ibuf_rec_get_info_func(const rec_t*,ibuf_op_t*,ulint*,ulint*,ulint*)" -> "__builtin_expect(long int,long int)"
"ibuf_rec_get_size(const rec_t*,const unsigned char*,ulint,ulint)" -> "dtype_new_read_for_order_and_null_size(dtype_t*,const unsigned char*)"
"ibuf_rec_get_size(const rec_t*,const unsigned char*,ulint,ulint)" -> "dtype_get_sql_null_size(const dtype_t*,ulint)"
"ibuf_rec_get_size(const rec_t*,const unsigned char*,ulint,ulint)" -> "rec_get_nth_field_offs_old(const rec_t*,ulint,ulint*)"
"ibuf_get_volume_buffered_hash(const rec_t*,const unsigned char*,const unsigned char*,ulint,ulint*,ulint)" -> "ut_fold_binary(const unsigned char*,ulint)"
"ibuf_get_volume_buffered_hash(const rec_t*,const unsigned char*,const unsigned char*,ulint,ulint*,ulint)" -> "ibuf_rec_get_size(const rec_t*,const unsigned char*,ulint,ulint)"
"ibuf_get_volume_buffered_hash(const rec_t*,const unsigned char*,const unsigned char*,ulint,ulint*,ulint)" -> "rec_get_n_fields_old(const rec_t*)"
"page_rec_get_next_const(const rec_t*)" -> "page_rec_get_next_low(const rec_t*,ulint)"
"page_rec_get_next_const(const rec_t*)" -> "page_rec_is_comp(const rec_t*)"
"ibuf_rec_get_page_no_func(const rec_t*)" -> "rec_get_nth_field_offs_old(const rec_t*,ulint,ulint*)"
"ibuf_rec_get_page_no_func(const rec_t*)" -> "mach_read_from_4(const unsigned char*)"
"ibuf_rec_get_page_no_func(const rec_t*)" -> "__builtin_expect(long int,long int)"
"ibuf_rec_get_page_no_func(const rec_t*)" -> "abort()"
"ibuf_rec_get_page_no_func(const rec_t*)" -> "ut_dbg_assertion_failed(const char*,const char*,ulint)"
"ibuf_mtr_start(mtr_t*)" -> "mtr_start(mtr_t*)"
"ibuf_tree_root_get(mtr_t*)" -> "buf_page_get_gen(ulint,ulint,ulint,ulint,buf_block_t*,ulint,const char*,ulint,mtr_t*)"
"ibuf_tree_root_get(mtr_t*)" -> "dict_index_get_lock(dict_index_t*)"
"ibuf_tree_root_get(mtr_t*)" -> "mtr_x_lock_func(rw_lock_t*,const char*,ulint,mtr_t*)"
"btr_pcur_open_low(dict_index_t*,ulint,const dtuple_t*,ulint,ulint,btr_pcur_t*,const char*,ulint,mtr_t*)" -> "btr_cur_search_to_nth_level(dict_index_t*,ulint,const dtuple_t*,ulint,ulint,btr_cur_t*,ulint,const char*,ulint,mtr_t*)"
"btr_pcur_open_low(dict_index_t*,ulint,const dtuple_t*,ulint,ulint,btr_pcur_t*,const char*,ulint,mtr_t*)" -> "btr_pcur_init(btr_pcur_t*)"
"ibuf_add_free_page()" -> "fsp_flags_get_zip_size(ulint)"
"ibuf_add_free_page()" -> "mtr_start(mtr_t*)"
"ibuf_add_free_page()" -> "pfs_mutex_exit_func(ib_mutex_t*)"
"ibuf_add_free_page()" -> "mlog_write_ulint(unsigned char*,ulint,unsigned char,mtr_t*)"
"ibuf_add_free_page()" -> "ibuf_tree_root_get(mtr_t*)"
"ibuf_add_free_page()" -> "buf_block_get_page_no(const buf_block_t*)"
"ibuf_add_free_page()" -> "ibuf_bitmap_page_set_bits(ib_page_t*,ulint,ulint,ulint,ulint,mtr_t*)"
"ibuf_add_free_page()" -> "flst_add_last(flst_base_node_t*,flst_node_t*,mtr_t*)"
"ibuf_add_free_page()" -> "fil_space_get_latch(ulint,ulint*)"
"ibuf_add_free_page()" -> "ibuf_bitmap_get_map_page_func(ulint,ulint,ulint,const char*,ulint,mtr_t*)"
"ibuf_add_free_page()" -> "ibuf_header_page_get(mtr_t*)"
"ibuf_add_free_page()" -> "ibuf_mtr_commit(mtr_t*)"
"ibuf_add_free_page()" -> "fseg_alloc_free_page_general(fseg_header_t*,ulint,unsigned char,ulint,mtr_t*,mtr_t*)"
"ibuf_add_free_page()" -> "ibuf_enter(mtr_t*)"
"ibuf_add_free_page()" -> "mtr_x_lock_func(rw_lock_t*,const char*,ulint,mtr_t*)"
"ibuf_add_free_page()" -> "mtr_commit(mtr_t*)"
"ibuf_add_free_page()" -> "pfs_mutex_enter_func(ib_mutex_t*,const char*,ulint)"
"ibuf_bitmap_page_set_bits(ib_page_t*,ulint,ulint,ulint,ulint,mtr_t*)" -> "mach_read_from_1(const unsigned char*)"
"ibuf_bitmap_page_set_bits(ib_page_t*,ulint,ulint,ulint,ulint,mtr_t*)" -> "mlog_write_ulint(unsigned char*,ulint,unsigned char,mtr_t*)"
"ibuf_bitmap_page_set_bits(ib_page_t*,ulint,ulint,ulint,ulint,mtr_t*)" -> "ut_bit_set_nth(ulint,ulint,ulint)"
"ibuf_bitmap_get_map_page_func(ulint,ulint,ulint,const char*,ulint,mtr_t*)" -> "ibuf_bitmap_page_no_calc(ulint,ulint)"
"ibuf_bitmap_get_map_page_func(ulint,ulint,ulint,const char*,ulint,mtr_t*)" -> "buf_page_get_gen(ulint,ulint,ulint,ulint,buf_block_t*,ulint,const char*,ulint,mtr_t*)"
"ibuf_header_page_get(mtr_t*)" -> "buf_page_get_gen(ulint,ulint,ulint,ulint,buf_block_t*,ulint,const char*,ulint,mtr_t*)"
"ibuf_mtr_commit(mtr_t*)" -> "mtr_commit(mtr_t*)"
"fseg_alloc_free_page_general(fseg_header_t*,ulint,unsigned char,ulint,mtr_t*,mtr_t*)" -> "fil_space_get_latch(ulint,ulint*)"
"fseg_alloc_free_page_general(fseg_header_t*,ulint,unsigned char,ulint,mtr_t*,mtr_t*)" -> "page_get_space_id(const ib_page_t*)"
"fseg_alloc_free_page_general(fseg_header_t*,ulint,unsigned char,ulint,mtr_t*,mtr_t*)" -> "page_align(const void*)"
"fseg_alloc_free_page_general(fseg_header_t*,ulint,unsigned char,ulint,mtr_t*,mtr_t*)" -> "fseg_alloc_free_page_low(ulint,ulint,fseg_inode_t*,ulint,unsigned char,mtr_t*,mtr_t*)"
"fseg_alloc_free_page_general(fseg_header_t*,ulint,unsigned char,ulint,mtr_t*,mtr_t*)" -> "rw_lock_get_x_lock_count(const rw_lock_t*)"
"fseg_alloc_free_page_general(fseg_header_t*,ulint,unsigned char,ulint,mtr_t*,mtr_t*)" -> "fseg_inode_get(fseg_header_t*,ulint,ulint,mtr_t*)"
"fseg_alloc_free_page_general(fseg_header_t*,ulint,unsigned char,ulint,mtr_t*,mtr_t*)" -> "fsp_reserve_free_extents(ulint*,ulint,ulint,ulint,mtr_t*)"
"fseg_alloc_free_page_general(fseg_header_t*,ulint,unsigned char,ulint,mtr_t*,mtr_t*)" -> "fsp_flags_get_zip_size(ulint)"
"fseg_alloc_free_page_general(fseg_header_t*,ulint,unsigned char,ulint,mtr_t*,mtr_t*)" -> "fil_space_release_free_extents(ulint,ulint)"
"fseg_alloc_free_page_general(fseg_header_t*,ulint,unsigned char,ulint,mtr_t*,mtr_t*)" -> "mtr_x_lock_func(rw_lock_t*,const char*,ulint,mtr_t*)"
"fseg_alloc_free_page_general(fseg_header_t*,ulint,unsigned char,ulint,mtr_t*,mtr_t*)" -> "ibuf_free_excess_pages()"
"fseg_alloc_free_page_low(ulint,ulint,fseg_inode_t*,ulint,unsigned char,mtr_t*,mtr_t*)" -> "xdes_mtr_get_bit(const xdes_t*,ulint,ulint,mtr_t*)"
"fseg_alloc_free_page_low(ulint,ulint,fseg_inode_t*,ulint,unsigned char,mtr_t*,mtr_t*)" -> "mach_read_from_4(const unsigned char*)"
"fseg_alloc_free_page_low(ulint,ulint,fseg_inode_t*,ulint,unsigned char,mtr_t*,mtr_t*)" -> "fsp_page_create(ulint,ulint,ulint,mtr_t*,mtr_t*)"
"fseg_alloc_free_page_low(ulint,ulint,fseg_inode_t*,ulint,unsigned char,mtr_t*,mtr_t*)" -> "xdes_get_descriptor(ulint,ulint,ulint,mtr_t*)"
"fseg_alloc_free_page_low(ulint,ulint,fseg_inode_t*,ulint,unsigned char,mtr_t*,mtr_t*)" -> "fil_space_get_size(ulint)"
"fseg_alloc_free_page_low(ulint,ulint,fseg_inode_t*,ulint,unsigned char,mtr_t*,mtr_t*)" -> "fseg_n_reserved_pages_low(fseg_inode_t*,ulint*,mtr_t*)"
"fseg_alloc_free_page_low(ulint,ulint,fseg_inode_t*,ulint,unsigned char,mtr_t*,mtr_t*)" -> "fsp_alloc_free_extent(ulint,ulint,ulint,mtr_t*)"
"fseg_alloc_free_page_low(ulint,ulint,fseg_inode_t*,ulint,unsigned char,mtr_t*,mtr_t*)" -> "buf_block_get_page_no(const buf_block_t*)"
"fseg_alloc_free_page_low(ulint,ulint,fseg_inode_t*,ulint,unsigned char,mtr_t*,mtr_t*)" -> "xdes_get_offset(const xdes_t*)"
"fseg_alloc_free_page_low(ulint,ulint,fseg_inode_t*,ulint,unsigned char,mtr_t*,mtr_t*)" -> "fseg_mark_page_used(fseg_inode_t*,ulint,xdes_t*,mtr_t*)"
"fseg_alloc_free_page_low(ulint,ulint,fseg_inode_t*,ulint,unsigned char,mtr_t*,mtr_t*)" -> "xdes_set_state(xdes_t*,ulint,mtr_t*)"
"fseg_alloc_free_page_low(ulint,ulint,fseg_inode_t*,ulint,unsigned char,mtr_t*,mtr_t*)" -> "fseg_alloc_free_extent(fseg_inode_t*,ulint,ulint,mtr_t*)"
"fseg_alloc_free_page_low(ulint,ulint,fseg_inode_t*,ulint,unsigned char,mtr_t*,mtr_t*)" -> "xdes_lst_get_descriptor(ulint,ulint,fil_addr_t,mtr_t*)"
"fseg_alloc_free_page_low(ulint,ulint,fseg_inode_t*,ulint,unsigned char,mtr_t*,mtr_t*)" -> "fsp_get_space_header(ulint,ulint,mtr_t*)"
"fseg_alloc_free_page_low(ulint,ulint,fseg_inode_t*,ulint,unsigned char,mtr_t*,mtr_t*)" -> "fseg_set_nth_frag_page_no(fseg_inode_t*,ulint,ulint,mtr_t*)"
"fseg_alloc_free_page_low(ulint,ulint,fseg_inode_t*,ulint,unsigned char,mtr_t*,mtr_t*)" -> "flst_get_len(const flst_base_node_t*,mtr_t*)"
"fseg_alloc_free_page_low(ulint,ulint,fseg_inode_t*,ulint,unsigned char,mtr_t*,mtr_t*)" -> "fseg_find_free_frag_page_slot(fseg_inode_t*,mtr_t*)"
"fseg_alloc_free_page_low(ulint,ulint,fseg_inode_t*,ulint,unsigned char,mtr_t*,mtr_t*)" -> "mlog_write_ull(unsigned char*,ib_uint64_t,mtr_t*)"
"fseg_alloc_free_page_low(ulint,ulint,fseg_inode_t*,ulint,unsigned char,mtr_t*,mtr_t*)" -> "mach_read_from_8(const unsigned char*)"
"fseg_alloc_free_page_low(ulint,ulint,fseg_inode_t*,ulint,unsigned char,mtr_t*,mtr_t*)" -> "xdes_is_full(const xdes_t*,mtr_t*)"
"fseg_alloc_free_page_low(ulint,ulint,fseg_inode_t*,ulint,unsigned char,mtr_t*,mtr_t*)" -> "fseg_fill_free_list(fseg_inode_t*,ulint,ulint,ulint,mtr_t*)"
"fseg_alloc_free_page_low(ulint,ulint,fseg_inode_t*,ulint,unsigned char,mtr_t*,mtr_t*)" -> "fprintf(FILE*,const char*,...)"
"fseg_alloc_free_page_low(ulint,ulint,fseg_inode_t*,ulint,unsigned char,mtr_t*,mtr_t*)" -> "xdes_get_descriptor_with_space_hdr(fsp_header_t*,ulint,ulint,mtr_t*)"
"fseg_alloc_free_page_low(ulint,ulint,fseg_inode_t*,ulint,unsigned char,mtr_t*,mtr_t*)" -> "fsp_alloc_free_page(ulint,ulint,ulint,mtr_t*,mtr_t*)"
"fseg_alloc_free_page_low(ulint,ulint,fseg_inode_t*,ulint,unsigned char,mtr_t*,mtr_t*)" -> "xdes_get_state(const xdes_t*,mtr_t*)"
"fseg_alloc_free_page_low(ulint,ulint,fseg_inode_t*,ulint,unsigned char,mtr_t*,mtr_t*)" -> "flst_get_first(const flst_base_node_t*,mtr_t*)"
"fseg_alloc_free_page_low(ulint,ulint,fseg_inode_t*,ulint,unsigned char,mtr_t*,mtr_t*)" -> "ut_dbg_assertion_failed(const char*,const char*,ulint)"
"fseg_alloc_free_page_low(ulint,ulint,fseg_inode_t*,ulint,unsigned char,mtr_t*,mtr_t*)" -> "fsp_flags_get_zip_size(ulint)"
"fseg_alloc_free_page_low(ulint,ulint,fseg_inode_t*,ulint,unsigned char,mtr_t*,mtr_t*)" -> "abort()"
"fseg_alloc_free_page_low(ulint,ulint,fseg_inode_t*,ulint,unsigned char,mtr_t*,mtr_t*)" -> "fsp_try_extend_data_file_with_pages(ulint,ulint,fsp_header_t*,mtr_t*)"
"fseg_alloc_free_page_low(ulint,ulint,fseg_inode_t*,ulint,unsigned char,mtr_t*,mtr_t*)" -> "flst_add_last(flst_base_node_t*,flst_node_t*,mtr_t*)"
"fseg_alloc_free_page_low(ulint,ulint,fseg_inode_t*,ulint,unsigned char,mtr_t*,mtr_t*)" -> "__builtin_expect(long int,long int)"
"fseg_alloc_free_page_low(ulint,ulint,fseg_inode_t*,ulint,unsigned char,mtr_t*,mtr_t*)" -> "xdes_find_bit(xdes_t*,ulint,ulint,ulint,mtr_t*)"
"fsp_page_create(ulint,ulint,ulint,mtr_t*,mtr_t*)" -> "pfs_rw_lock_x_lock_func(rw_lock_t*,ulint,const char*,ulint)"
"fsp_page_create(ulint,ulint,ulint,mtr_t*,mtr_t*)" -> "buf_block_buf_fix_inc_func(buf_block_t*)"
"fsp_page_create(ulint,ulint,ulint,mtr_t*,mtr_t*)" -> "pfs_mutex_enter_func(ib_mutex_t*,const char*,ulint)"
"fsp_page_create(ulint,ulint,ulint,mtr_t*,mtr_t*)" -> "rw_lock_get_x_lock_count(const rw_lock_t*)"
"fsp_page_create(ulint,ulint,ulint,mtr_t*,mtr_t*)" -> "fsp_init_file_page(buf_block_t*,mtr_t*)"
"fsp_page_create(ulint,ulint,ulint,mtr_t*,mtr_t*)" -> "mtr_memo_push(mtr_t*,void*,ulint)"
"fsp_page_create(ulint,ulint,ulint,mtr_t*,mtr_t*)" -> "buf_page_create(ulint,ulint,ulint,mtr_t*)"
"fsp_page_create(ulint,ulint,ulint,mtr_t*,mtr_t*)" -> "pfs_mutex_exit_func(ib_mutex_t*)"
"fsp_init_file_page(buf_block_t*,mtr_t*)" -> "fsp_init_file_page_low(buf_block_t*)"
"fsp_init_file_page(buf_block_t*,mtr_t*)" -> "mlog_write_initial_log_record(const unsigned char*,unsigned char,mtr_t*)"
"fsp_init_file_page_low(buf_block_t*)" -> "buf_block_get_space(const buf_block_t*)"
"fsp_init_file_page_low(buf_block_t*)" -> "mach_write_to_4(unsigned char*,ulint)"
"fsp_init_file_page_low(buf_block_t*)" -> "page_zip_get_size(const page_zip_des_t*)"
"fsp_init_file_page_low(buf_block_t*)" -> "memset(void*,int,size_t)"
"fsp_init_file_page_low(buf_block_t*)" -> "memcpy(void*,const void*,size_t)"
"fsp_init_file_page_low(buf_block_t*)" -> "buf_block_get_page_no(const buf_block_t*)"
"buf_page_create(ulint,ulint,ulint,mtr_t*)" -> "buf_LRU_add_block(buf_page_t*,ulint)"
"buf_page_create(ulint,ulint,ulint,mtr_t*)" -> "buf_page_get_gen(ulint,ulint,ulint,ulint,buf_block_t*,ulint,const char*,ulint,mtr_t*)"
"buf_page_create(ulint,ulint,ulint,mtr_t*)" -> "pfs_mutex_enter_func(ib_mutex_t*,const char*,ulint)"
"buf_page_create(ulint,ulint,ulint,mtr_t*)" -> "hash_get_lock(hash_table_t*,ulint)"
"buf_page_create(ulint,ulint,ulint,mtr_t*)" -> "buf_page_set_io_fix(buf_page_t*,buf_io_fix)"
"buf_page_create(ulint,ulint,ulint,mtr_t*)" -> "pfs_mutex_exit_func(ib_mutex_t*)"
"buf_page_create(ulint,ulint,ulint,mtr_t*)" -> "buf_block_buf_fix_inc_func(buf_block_t*)"
"buf_page_create(ulint,ulint,ulint,mtr_t*)" -> "buf_page_in_file(const buf_page_t*)"
"buf_page_create(ulint,ulint,ulint,mtr_t*)" -> "buf_buddy_alloc(buf_pool_t*,ulint,ulint*)"
"buf_page_create(ulint,ulint,ulint,mtr_t*)" -> "pfs_rw_lock_x_unlock_func(rw_lock_t*)"
"buf_page_create(ulint,ulint,ulint,mtr_t*)" -> "buf_page_set_accessed(buf_page_t*)"
"buf_page_create(ulint,ulint,ulint,mtr_t*)" -> "memset(void*,int,size_t)"
"buf_page_create(ulint,ulint,ulint,mtr_t*)" -> "buf_page_address_fold(ulint,ulint)"
"buf_page_create(ulint,ulint,ulint,mtr_t*)" -> "pfs_rw_lock_x_lock_func(rw_lock_t*,ulint,const char*,ulint)"
"buf_page_create(ulint,ulint,ulint,mtr_t*)" -> "buf_LRU_get_free_block(buf_pool_t*)"
"buf_page_create(ulint,ulint,ulint,mtr_t*)" -> "buf_pool_get(ulint,ulint)"
"buf_page_create(ulint,ulint,ulint,mtr_t*)" -> "buf_unzip_LRU_add_block(buf_block_t*,ulint)"
"buf_page_create(ulint,ulint,ulint,mtr_t*)" -> "buf_block_free(buf_block_t*)"
"buf_page_create(ulint,ulint,ulint,mtr_t*)" -> "mtr_memo_push(mtr_t*,void*,ulint)"
"buf_page_create(ulint,ulint,ulint,mtr_t*)" -> "buf_pool_watch_is_sentinel(buf_pool_t*,const buf_page_t*)"
"buf_page_create(ulint,ulint,ulint,mtr_t*)" -> "buf_page_hash_get_low(buf_pool_t*,ulint,ulint,ulint)"
"buf_page_create(ulint,ulint,ulint,mtr_t*)" -> "mach_write_to_2(unsigned char*,ulint)"
"buf_page_create(ulint,ulint,ulint,mtr_t*)" -> "buf_page_init(buf_pool_t*,ulint,ulint,ulint,ulint,buf_block_t*)"
"buf_page_create(ulint,ulint,ulint,mtr_t*)" -> "ibuf_merge_or_delete_for_page(buf_block_t*,ulint,ulint,ulint,ulint)"
"buf_LRU_add_block(buf_page_t*,ulint)" -> "buf_LRU_add_block_low(buf_page_t*,ulint)"
"buf_buddy_alloc(buf_pool_t*,ulint,ulint*)" -> "buf_buddy_get_slot(ulint)"
"buf_buddy_alloc(buf_pool_t*,ulint,ulint*)" -> "buf_buddy_alloc_low(buf_pool_t*,ulint,ulint*)"
"buf_buddy_alloc_low(buf_pool_t*,ulint,ulint*)" -> "pfs_mutex_exit_func(ib_mutex_t*)"
"buf_buddy_alloc_low(buf_pool_t*,ulint,ulint*)" -> "pfs_mutex_enter_func(ib_mutex_t*,const char*,ulint)"
"buf_buddy_alloc_low(buf_pool_t*,ulint,ulint*)" -> "buf_buddy_block_register(buf_block_t*)"
"buf_buddy_alloc_low(buf_pool_t*,ulint,ulint*)" -> "buf_buddy_alloc_zip(buf_pool_t*,ulint)"
"buf_buddy_alloc_low(buf_pool_t*,ulint,ulint*)" -> "buf_LRU_get_free_only(buf_pool_t*)"
"buf_buddy_alloc_low(buf_pool_t*,ulint,ulint*)" -> "buf_LRU_get_free_block(buf_pool_t*)"
"buf_buddy_alloc_low(buf_pool_t*,ulint,ulint*)" -> "buf_buddy_alloc_from(buf_pool_t*,void*,ulint,ulint)"
"buf_buddy_block_register(buf_block_t*)" -> "__builtin_expect(long int,long int)"
"buf_buddy_block_register(buf_block_t*)" -> "ut_align_offset(const void*,ulint)"
"buf_buddy_block_register(buf_block_t*)" -> "ut_dbg_assertion_failed(const char*,const char*,ulint)"
"buf_buddy_block_register(buf_block_t*)" -> "hash_calc_hash(ulint,hash_table_t*)"
"buf_buddy_block_register(buf_block_t*)" -> "buf_block_set_state(buf_block_t*,buf_page_state)"
"buf_buddy_block_register(buf_block_t*)" -> "buf_pool_from_block(const buf_block_t*)"
"buf_buddy_block_register(buf_block_t*)" -> "hash_get_nth_cell(hash_table_t*,ulint)"
"buf_buddy_block_register(buf_block_t*)" -> "abort()"
"buf_buddy_alloc_zip(buf_pool_t*,ulint)" -> "abort()"
"buf_buddy_alloc_zip(buf_pool_t*,ulint)" -> "buf_buddy_remove_from_free(buf_pool_t*,buf_buddy_free_t*,ulint)"
"buf_buddy_alloc_zip(buf_pool_t*,ulint)" -> "buf_buddy_get_slot(ulint)"
"buf_buddy_alloc_zip(buf_pool_t*,ulint)" -> "__builtin_expect(long int,long int)"
"buf_buddy_alloc_zip(buf_pool_t*,ulint)" -> "ut_dbg_assertion_failed(const char*,const char*,ulint)"
"buf_buddy_alloc_zip(buf_pool_t*,ulint)" -> "buf_buddy_add_to_free(buf_pool_t*,buf_buddy_free_t*,ulint)"
"buf_buddy_alloc_zip(buf_pool_t*,ulint)" -> "buf_buddy_alloc_zip(buf_pool_t*,ulint)"
"buf_LRU_get_free_only(buf_pool_t*)" -> "pfs_mutex_enter_func(ib_mutex_t*,const char*,ulint)"
"buf_LRU_get_free_only(buf_pool_t*)" -> "buf_page_in_file(const buf_page_t*)"
"buf_LRU_get_free_only(buf_pool_t*)" -> "buf_block_set_state(buf_block_t*,buf_page_state)"
"buf_LRU_get_free_only(buf_pool_t*)" -> "ut_dbg_assertion_failed(const char*,const char*,ulint)"
"buf_LRU_get_free_only(buf_pool_t*)" -> "__builtin_expect(long int,long int)"
"buf_LRU_get_free_only(buf_pool_t*)" -> "abort()"
"buf_LRU_get_free_only(buf_pool_t*)" -> "pfs_mutex_exit_func(ib_mutex_t*)"
"buf_LRU_get_free_only(buf_pool_t*)" -> "ut_list_remove(List&,Type&,size_t) [with List = ut_list_base<buf_page_t>,Type = buf_page_t,size_t = long unsigned int]"
"buf_buddy_alloc_from(buf_pool_t*,void*,ulint,ulint)" -> "buf_buddy_add_to_free(buf_pool_t*,buf_buddy_free_t*,ulint)"
"buf_buddy_alloc_from(buf_pool_t*,void*,ulint,ulint)" -> "memset(void*,int,size_t)"
"buf_page_init(buf_pool_t*,ulint,ulint,ulint,ulint,buf_block_t*)" -> "ut_dbg_assertion_failed(const char*,const char*,ulint)"
"buf_page_init(buf_pool_t*,ulint,ulint,ulint,ulint,buf_block_t*)" -> "buf_pool_watch_is_sentinel(buf_pool_t*,const buf_page_t*)"
"buf_page_init(buf_pool_t*,ulint,ulint,ulint,ulint,buf_block_t*)" -> "abort()"
"buf_page_init(buf_pool_t*,ulint,ulint,ulint,ulint,buf_block_t*)" -> "hash_get_nth_cell(hash_table_t*,ulint)"
"buf_page_init(buf_pool_t*,ulint,ulint,ulint,ulint,buf_block_t*)" -> "__sync_add_and_fetch_4(volatile void*,unsigned int)"
"buf_page_init(buf_pool_t*,ulint,ulint,ulint,ulint,buf_block_t*)" -> "buf_block_get_state(const buf_block_t*)"
"buf_page_init(buf_pool_t*,ulint,ulint,ulint,ulint,buf_block_t*)" -> "fprintf(FILE*,const char*,...)"
"buf_page_init(buf_pool_t*,ulint,ulint,ulint,ulint,buf_block_t*)" -> "buf_pool_watch_remove(buf_pool_t*,ulint,buf_page_t*)"
"buf_page_init(buf_pool_t*,ulint,ulint,ulint,ulint,buf_block_t*)" -> "buf_block_init_low(buf_block_t*)"
"buf_page_init(buf_pool_t*,ulint,ulint,ulint,ulint,buf_block_t*)" -> "buf_page_hash_get_low(buf_pool_t*,ulint,ulint,ulint)"
"buf_page_init(buf_pool_t*,ulint,ulint,ulint,ulint,buf_block_t*)" -> "buf_page_init_low(buf_page_t*)"
"buf_page_init(buf_pool_t*,ulint,ulint,ulint,ulint,buf_block_t*)" -> "__builtin_expect(long int,long int)"
"buf_page_init(buf_pool_t*,ulint,ulint,ulint,ulint,buf_block_t*)" -> "buf_block_set_file_page(buf_block_t*,ulint,ulint)"
"buf_page_init(buf_pool_t*,ulint,ulint,ulint,ulint,buf_block_t*)" -> "lock_rec_hash(ulint,ulint)"
"buf_page_init(buf_pool_t*,ulint,ulint,ulint,ulint,buf_block_t*)" -> "page_zip_set_size(page_zip_des_t*,ulint)"
"buf_page_init(buf_pool_t*,ulint,ulint,ulint,ulint,buf_block_t*)" -> "hash_calc_hash(ulint,hash_table_t*)"
"buf_pool_watch_remove(buf_pool_t*,ulint,buf_page_t*)" -> "ut_dbg_assertion_failed(const char*,const char*,ulint)"
"buf_pool_watch_remove(buf_pool_t*,ulint,buf_page_t*)" -> "__builtin_expect(long int,long int)"
"buf_pool_watch_remove(buf_pool_t*,ulint,buf_page_t*)" -> "hash_get_nth_cell(hash_table_t*,ulint)"
"buf_pool_watch_remove(buf_pool_t*,ulint,buf_page_t*)" -> "hash_calc_hash(ulint,hash_table_t*)"
"buf_pool_watch_remove(buf_pool_t*,ulint,buf_page_t*)" -> "abort()"
"buf_block_set_file_page(buf_block_t*,ulint,ulint)" -> "buf_block_set_state(buf_block_t*,buf_page_state)"
"ibuf_merge_or_delete_for_page(buf_block_t*,ulint,ulint,ulint,ulint)" -> "btr_pcur_store_position(btr_pcur_t*,mtr_t*)"
"ibuf_merge_or_delete_for_page(buf_block_t*,ulint,ulint,ulint,ulint)" -> "btr_pcur_is_after_last_on_page(const btr_pcur_t*)"
"ibuf_merge_or_delete_for_page(buf_block_t*,ulint,ulint,ulint,ulint)" -> "page_align(const void*)"
"ibuf_merge_or_delete_for_page(buf_block_t*,ulint,ulint,ulint,ulint)" -> "ibuf_mtr_commit(mtr_t*)"
"ibuf_merge_or_delete_for_page(buf_block_t*,ulint,ulint,ulint,ulint)" -> "ibuf_insert_to_index_page(const dtuple_t*,buf_block_t*,dict_index_t*,mtr_t*)"
"ibuf_merge_or_delete_for_page(buf_block_t*,ulint,ulint,ulint,ulint)" -> "ibuf_bitmap_page_set_bits(ib_page_t*,ulint,ulint,ulint,ulint,mtr_t*)"
"ibuf_merge_or_delete_for_page(buf_block_t*,ulint,ulint,ulint,ulint)" -> "btr_cur_set_deleted_flag_for_ibuf(rec_t*,page_zip_des_t*,ulint,mtr_t*)"
"ibuf_merge_or_delete_for_page(buf_block_t*,ulint,ulint,ulint,ulint)" -> "ut_dbg_assertion_failed(const char*,const char*,ulint)"
"ibuf_merge_or_delete_for_page(buf_block_t*,ulint,ulint,ulint,ulint)" -> "ibuf_fixed_addr_page(ulint,ulint,ulint)"
"ibuf_merge_or_delete_for_page(buf_block_t*,ulint,ulint,ulint,ulint)" -> "ibuf_bitmap_get_map_page_func(ulint,ulint,ulint,const char*,ulint,mtr_t*)"
"ibuf_merge_or_delete_for_page(buf_block_t*,ulint,ulint,ulint,ulint)" -> "__builtin_fwrite(const void*,size_t,size_t,FILE*)"
"ibuf_merge_or_delete_for_page(buf_block_t*,ulint,ulint,ulint,ulint)" -> "mem_heap_create_func(ulint,ulint)"
"ibuf_merge_or_delete_for_page(buf_block_t*,ulint,ulint,ulint,ulint)" -> "fprintf(FILE*,const char*,...)"
"ibuf_merge_or_delete_for_page(buf_block_t*,ulint,ulint,ulint,ulint)" -> "fil_decr_pending_ops(ulint)"
"ibuf_merge_or_delete_for_page(buf_block_t*,ulint,ulint,ulint,ulint)" -> "ibuf_rec_get_page_no_func(const rec_t*)"
"ibuf_merge_or_delete_for_page(buf_block_t*,ulint,ulint,ulint,ulint)" -> "ibuf_mtr_start(mtr_t*)"
"ibuf_merge_or_delete_for_page(buf_block_t*,ulint,ulint,ulint,ulint)" -> "abort()"
"ibuf_merge_or_delete_for_page(buf_block_t*,ulint,ulint,ulint,ulint)" -> "ibuf_index_page_calc_free(ulint,const buf_block_t*)"
"ibuf_merge_or_delete_for_page(buf_block_t*,ulint,ulint,ulint,ulint)" -> "buf_page_print(const unsigned char*,ulint,ulint)"
"ibuf_merge_or_delete_for_page(buf_block_t*,ulint,ulint,ulint,ulint)" -> "ibuf_delete(const dtuple_t*,buf_block_t*,dict_index_t*,mtr_t*)"
"ibuf_merge_or_delete_for_page(buf_block_t*,ulint,ulint,ulint,ulint)" -> "ibuf_restore_pos(ulint,ulint,const dtuple_t*,ulint,btr_pcur_t*,mtr_t*)"
"ibuf_merge_or_delete_for_page(buf_block_t*,ulint,ulint,ulint,ulint)" -> "btr_pcur_is_on_user_rec(const btr_pcur_t*)"
"ibuf_merge_or_delete_for_page(buf_block_t*,ulint,ulint,ulint,ulint)" -> "ibuf_build_entry_from_ibuf_rec_func(const rec_t*,mem_heap_t*,dict_index_t**)"
"ibuf_merge_or_delete_for_page(buf_block_t*,ulint,ulint,ulint,ulint)" -> "rw_lock_x_lock_move_ownership(rw_lock_t*)"
"ibuf_merge_or_delete_for_page(buf_block_t*,ulint,ulint,ulint,ulint)" -> "ut_print_timestamp(FILE*)"
"ibuf_merge_or_delete_for_page(buf_block_t*,ulint,ulint,ulint,ulint)" -> "rec_print_old(FILE*,const rec_t*)"
"ibuf_merge_or_delete_for_page(buf_block_t*,ulint,ulint,ulint,ulint)" -> "fil_page_get_type(const unsigned char*)"
"ibuf_merge_or_delete_for_page(buf_block_t*,ulint,ulint,ulint,ulint)" -> "fil_inc_pending_ops(ulint)"
"ibuf_merge_or_delete_for_page(buf_block_t*,ulint,ulint,ulint,ulint)" -> "ibuf_btr_pcur_commit_specify_mtr(btr_pcur_t*,mtr_t*)"
"ibuf_merge_or_delete_for_page(buf_block_t*,ulint,ulint,ulint,ulint)" -> "mem_heap_free_func(mem_heap_t*,const char*,ulint)"
"ibuf_merge_or_delete_for_page(buf_block_t*,ulint,ulint,ulint,ulint)" -> "ibuf_rec_get_op_type_func(const rec_t*)"
"ibuf_merge_or_delete_for_page(buf_block_t*,ulint,ulint,ulint,ulint)" -> "ibuf_bitmap_page_get_bits_low(const ib_page_t*,ulint,ulint,ulint)"
"ibuf_merge_or_delete_for_page(buf_block_t*,ulint,ulint,ulint,ulint)" -> "ibuf_search_tuple_build(ulint,ulint,mem_heap_t*)"
"ibuf_merge_or_delete_for_page(buf_block_t*,ulint,ulint,ulint,ulint)" -> "btr_pcur_open_on_user_rec_func(dict_index_t*,const dtuple_t*,ulint,ulint,btr_pcur_t*,const char*,ulint,mtr_t*)"
"ibuf_merge_or_delete_for_page(buf_block_t*,ulint,ulint,ulint,ulint)" -> "rec_get_deleted_flag(const rec_t*,ulint)"
"ibuf_merge_or_delete_for_page(buf_block_t*,ulint,ulint,ulint,ulint)" -> "buf_page_get_known_nowait(ulint,buf_block_t*,ulint,const char*,ulint,mtr_t*)"
"ibuf_merge_or_delete_for_page(buf_block_t*,ulint,ulint,ulint,ulint)" -> "btr_pcur_close(btr_pcur_t*)"
"ibuf_merge_or_delete_for_page(buf_block_t*,ulint,ulint,ulint,ulint)" -> "ibuf_delete_rec(ulint,ulint,btr_pcur_t*,const dtuple_t*,mtr_t*)"
"ibuf_merge_or_delete_for_page(buf_block_t*,ulint,ulint,ulint,ulint)" -> "memset(void*,int,size_t)"
"ibuf_merge_or_delete_for_page(buf_block_t*,ulint,ulint,ulint,ulint)" -> "__builtin_expect(long int,long int)"
"ibuf_merge_or_delete_for_page(buf_block_t*,ulint,ulint,ulint,ulint)" -> "page_get_max_trx_id(const ib_page_t*)"
"ibuf_merge_or_delete_for_page(buf_block_t*,ulint,ulint,ulint,ulint)" -> "ibuf_dummy_index_free(dict_index_t*)"
"ibuf_merge_or_delete_for_page(buf_block_t*,ulint,ulint,ulint,ulint)" -> "ibuf_rec_get_space_func(const rec_t*)"
"ibuf_merge_or_delete_for_page(buf_block_t*,ulint,ulint,ulint,ulint)" -> "fsp_descr_page(ulint,ulint)"
"ibuf_merge_or_delete_for_page(buf_block_t*,ulint,ulint,ulint,ulint)" -> "ibuf_add_ops(ulint*,const ulint*)"
"ibuf_merge_or_delete_for_page(buf_block_t*,ulint,ulint,ulint,ulint)" -> "page_update_max_trx_id(buf_block_t*,page_zip_des_t*,trx_id_t,mtr_t*)"
"ibuf_merge_or_delete_for_page(buf_block_t*,ulint,ulint,ulint,ulint)" -> "page_is_leaf(const ib_page_t*)"
"ibuf_merge_or_delete_for_page(buf_block_t*,ulint,ulint,ulint,ulint)" -> "trx_sys_hdr_page(ulint,ulint)"
"ibuf_merge_or_delete_for_page(buf_block_t*,ulint,ulint,ulint,ulint)" -> "ibuf_set_del_mark(const dtuple_t*,buf_block_t*,const dict_index_t*,mtr_t*)"
"ibuf_merge_or_delete_for_page(buf_block_t*,ulint,ulint,ulint,ulint)" -> "page_header_reset_last_insert(ib_page_t*,page_zip_des_t*,mtr_t*)"
"ibuf_merge_or_delete_for_page(buf_block_t*,ulint,ulint,ulint,ulint)" -> "__sync_add_and_fetch_8(volatile void*,long unsigned int)"
"ibuf_insert_to_index_page(const dtuple_t*,buf_block_t*,dict_index_t*,mtr_t*)" -> "row_upd_rec_in_place(rec_t*,dict_index_t*,const ulint*,const upd_t*,page_zip_des_t*)"
"ibuf_insert_to_index_page(const dtuple_t*,buf_block_t*,dict_index_t*,mtr_t*)" -> "page_rec_get_next(rec_t*)"
"ibuf_insert_to_index_page(const dtuple_t*,buf_block_t*,dict_index_t*,mtr_t*)" -> "page_cur_delete_rec(page_cur_t*,const dict_index_t*,const ulint*,mtr_t*)"
"ibuf_insert_to_index_page(const dtuple_t*,buf_block_t*,dict_index_t*,mtr_t*)" -> "lock_rec_store_on_page_infimum(const buf_block_t*,const rec_t*)"
"ibuf_insert_to_index_page(const dtuple_t*,buf_block_t*,dict_index_t*,mtr_t*)" -> "dtuple_print(FILE*,const dtuple_t*)"
"ibuf_insert_to_index_page(const dtuple_t*,buf_block_t*,dict_index_t*,mtr_t*)" -> "lock_rec_restore_from_page_infimum(const buf_block_t*,const rec_t*,const buf_block_t*)"
"ibuf_insert_to_index_page(const dtuple_t*,buf_block_t*,dict_index_t*,mtr_t*)" -> "rec_get_offsets_func(const rec_t*,const dict_index_t*,ulint*,ulint,mem_heap_t**)"
"ibuf_insert_to_index_page(const dtuple_t*,buf_block_t*,dict_index_t*,mtr_t*)" -> "row_upd_build_sec_rec_difference_binary(const rec_t*,dict_index_t*,const ulint*,const dtuple_t*,mem_heap_t*)"
"ibuf_insert_to_index_page(const dtuple_t*,buf_block_t*,dict_index_t*,mtr_t*)" -> "__builtin_fwrite(const void*,size_t,size_t,FILE*)"
"ibuf_insert_to_index_page(const dtuple_t*,buf_block_t*,dict_index_t*,mtr_t*)" -> "page_get_infimum_offset(const ib_page_t*)"
"ibuf_insert_to_index_page(const dtuple_t*,buf_block_t*,dict_index_t*,mtr_t*)" -> "buf_page_print(const unsigned char*,ulint,ulint)"
"ibuf_insert_to_index_page(const dtuple_t*,buf_block_t*,dict_index_t*,mtr_t*)" -> "btr_cur_set_deleted_flag_for_ibuf(rec_t*,page_zip_des_t*,ulint,mtr_t*)"
"ibuf_insert_to_index_page(const dtuple_t*,buf_block_t*,dict_index_t*,mtr_t*)" -> "ibuf_insert_to_index_page_low(const dtuple_t*,buf_block_t*,dict_index_t*,ulint**,mem_heap_t*,mtr_t*,page_cur_t*)"
"ibuf_insert_to_index_page(const dtuple_t*,buf_block_t*,dict_index_t*,mtr_t*)" -> "page_rec_is_supremum(const rec_t*)"
"ibuf_insert_to_index_page(const dtuple_t*,buf_block_t*,dict_index_t*,mtr_t*)" -> "page_cur_search(const buf_block_t*,const dict_index_t*,const dtuple_t*,ulint,page_cur_t*)"
"ibuf_insert_to_index_page(const dtuple_t*,buf_block_t*,dict_index_t*,mtr_t*)" -> "dict_table_is_comp(const dict_table_t*)"
"ibuf_insert_to_index_page(const dtuple_t*,buf_block_t*,dict_index_t*,mtr_t*)" -> "rec_offs_size(const ulint*)"
"ibuf_insert_to_index_page(const dtuple_t*,buf_block_t*,dict_index_t*,mtr_t*)" -> "dtuple_get_n_fields(const dtuple_t*)"
"ibuf_insert_to_index_page(const dtuple_t*,buf_block_t*,dict_index_t*,mtr_t*)" -> "__builtin_expect(long int,long int)"
"ibuf_insert_to_index_page(const dtuple_t*,buf_block_t*,dict_index_t*,mtr_t*)" -> "btr_cur_update_alloc_zip_func(page_zip_des_t*,page_cur_t*,dict_index_t*,ulint,bool,mtr_t*)"
"ibuf_insert_to_index_page(const dtuple_t*,buf_block_t*,dict_index_t*,mtr_t*)" -> "rec_get_n_fields(const rec_t*,const dict_index_t*)"
"ibuf_insert_to_index_page(const dtuple_t*,buf_block_t*,dict_index_t*,mtr_t*)" -> "row_upd_changes_field_size_or_external(dict_index_t*,const ulint*,const upd_t*)"
"ibuf_insert_to_index_page(const dtuple_t*,buf_block_t*,dict_index_t*,mtr_t*)" -> "page_is_comp(const ib_page_t*)"
"ibuf_insert_to_index_page(const dtuple_t*,buf_block_t*,dict_index_t*,mtr_t*)" -> "mem_heap_free_func(mem_heap_t*,const char*,ulint)"
"ibuf_insert_to_index_page(const dtuple_t*,buf_block_t*,dict_index_t*,mtr_t*)" -> "mem_heap_create_func(ulint,ulint)"
"ibuf_insert_to_index_page(const dtuple_t*,buf_block_t*,dict_index_t*,mtr_t*)" -> "rec_get_info_bits(const rec_t*,ulint)"
"ibuf_insert_to_index_page(const dtuple_t*,buf_block_t*,dict_index_t*,mtr_t*)" -> "btr_cur_update_in_place_log(ulint,const rec_t*,dict_index_t*,const upd_t*,trx_id_t,roll_ptr_t,mtr_t*)"
"ibuf_insert_to_index_page(const dtuple_t*,buf_block_t*,dict_index_t*,mtr_t*)" -> "page_cur_move_to_prev(page_cur_t*)"
"row_upd_rec_in_place(rec_t*,dict_index_t*,const ulint*,const upd_t*,page_zip_des_t*)" -> "rec_set_info_bits_old(rec_t*,ulint)"
"row_upd_rec_in_place(rec_t*,dict_index_t*,const ulint*,const upd_t*,page_zip_des_t*)" -> "dfield_get_len(const dfield_t*)"
"row_upd_rec_in_place(rec_t*,dict_index_t*,const ulint*,const upd_t*,page_zip_des_t*)" -> "rec_set_info_bits_new(rec_t*,ulint)"
"row_upd_rec_in_place(rec_t*,dict_index_t*,const ulint*,const upd_t*,page_zip_des_t*)" -> "rec_set_nth_field(rec_t*,const ulint*,ulint,const void*,ulint)"
"row_upd_rec_in_place(rec_t*,dict_index_t*,const ulint*,const upd_t*,page_zip_des_t*)" -> "rec_offs_comp(const ulint*)"
"row_upd_rec_in_place(rec_t*,dict_index_t*,const ulint*,const upd_t*,page_zip_des_t*)" -> "upd_get_n_fields(const upd_t*)"
"row_upd_rec_in_place(rec_t*,dict_index_t*,const ulint*,const upd_t*,page_zip_des_t*)" -> "page_zip_write_rec(page_zip_des_t*,const unsigned char*,dict_index_t*,const ulint*,ulint)"
"rec_set_nth_field(rec_t*,const ulint*,ulint,const void*,ulint)" -> "rec_get_nth_field_offs(const ulint*,ulint,ulint*)"
"rec_set_nth_field(rec_t*,const ulint*,ulint,const void*,ulint)" -> "__builtin_expect(long int,long int)"
"rec_set_nth_field(rec_t*,const ulint*,ulint,const void*,ulint)" -> "rec_set_nth_field_sql_null(rec_t*,ulint)"
"rec_set_nth_field(rec_t*,const ulint*,ulint,const void*,ulint)" -> "ut_memcpy(void*,const void*,ulint)"
"rec_set_nth_field(rec_t*,const ulint*,ulint,const void*,ulint)" -> "rec_set_nth_field_null_bit(rec_t*,ulint,ulint)"
"rec_set_nth_field(rec_t*,const ulint*,ulint,const void*,ulint)" -> "abort()"
"rec_set_nth_field(rec_t*,const ulint*,ulint,const void*,ulint)" -> "rec_offs_comp(const ulint*)"
"rec_set_nth_field(rec_t*,const ulint*,ulint,const void*,ulint)" -> "rec_offs_nth_sql_null(const ulint*,ulint)"
"rec_set_nth_field(rec_t*,const ulint*,ulint,const void*,ulint)" -> "ut_dbg_assertion_failed(const char*,const char*,ulint)"
"rec_set_nth_field_sql_null(rec_t*,ulint)" -> "data_write_sql_null(unsigned char*,ulint)"
"rec_set_nth_field_sql_null(rec_t*,ulint)" -> "rec_set_nth_field_null_bit(rec_t*,ulint,ulint)"
"rec_set_nth_field_sql_null(rec_t*,ulint)" -> "rec_get_field_start_offs(const rec_t*,ulint)"
"rec_set_nth_field_sql_null(rec_t*,ulint)" -> "rec_get_nth_field_size(const rec_t*,ulint)"
"rec_set_nth_field_null_bit(rec_t*,ulint,ulint)" -> "rec_1_get_field_end_info(const rec_t*,ulint)"
"rec_set_nth_field_null_bit(rec_t*,ulint,ulint)" -> "rec_1_set_field_end_info(rec_t*,ulint,ulint)"
"rec_set_nth_field_null_bit(rec_t*,ulint,ulint)" -> "rec_get_1byte_offs_flag(const rec_t*)"
"rec_set_nth_field_null_bit(rec_t*,ulint,ulint)" -> "rec_2_get_field_end_info(const rec_t*,ulint)"
"rec_set_nth_field_null_bit(rec_t*,ulint,ulint)" -> "rec_2_set_field_end_info(rec_t*,ulint,ulint)"
"page_cur_delete_rec(page_cur_t*,const dict_index_t*,const ulint*,mtr_t*)" -> "recv_recovery_is_on()"
"page_cur_delete_rec(page_cur_t*,const dict_index_t*,const ulint*,mtr_t*)" -> "page_dir_find_owner_slot(const rec_t*)"
"page_cur_delete_rec(page_cur_t*,const dict_index_t*,const ulint*,mtr_t*)" -> "page_cur_move_to_next(page_cur_t*)"
"page_cur_delete_rec(page_cur_t*,const dict_index_t*,const ulint*,mtr_t*)" -> "buf_block_modify_clock_inc(buf_block_t*)"
"page_cur_delete_rec(page_cur_t*,const dict_index_t*,const ulint*,mtr_t*)" -> "page_align(const void*)"
"page_cur_delete_rec(page_cur_t*,const dict_index_t*,const ulint*,mtr_t*)" -> "page_mem_free(ib_page_t*,page_zip_des_t*,rec_t*,const dict_index_t*,const ulint*)"
"page_cur_delete_rec(page_cur_t*,const dict_index_t*,const ulint*,mtr_t*)" -> "page_dir_balance_slot(ib_page_t*,page_zip_des_t*,ulint)"
"page_cur_delete_rec(page_cur_t*,const dict_index_t*,const ulint*,mtr_t*)" -> "page_rec_set_next(rec_t*,const rec_t*)"
"page_cur_delete_rec(page_cur_t*,const dict_index_t*,const ulint*,mtr_t*)" -> "page_rec_get_next(rec_t*)"
"page_cur_delete_rec(page_cur_t*,const dict_index_t*,const ulint*,mtr_t*)" -> "page_header_set_ptr(ib_page_t*,page_zip_des_t*,ulint,const unsigned char*)"
"page_cur_delete_rec(page_cur_t*,const dict_index_t*,const ulint*,mtr_t*)" -> "page_dir_slot_set_rec(page_dir_slot_t*,rec_t*)"
"page_cur_delete_rec(page_cur_t*,const dict_index_t*,const ulint*,mtr_t*)" -> "page_cur_delete_rec_write_log(rec_t*,const dict_index_t*,mtr_t*)"
"page_cur_delete_rec(page_cur_t*,const dict_index_t*,const ulint*,mtr_t*)" -> "page_dir_slot_get_rec(const page_dir_slot_t*)"
"page_cur_delete_rec(page_cur_t*,const dict_index_t*,const ulint*,mtr_t*)" -> "page_dir_slot_set_n_owned(page_dir_slot_t*,page_zip_des_t*,ulint)"
"page_cur_delete_rec(page_cur_t*,const dict_index_t*,const ulint*,mtr_t*)" -> "page_create_empty(buf_block_t*,dict_index_t*,mtr_t*)"
"page_cur_delete_rec(page_cur_t*,const dict_index_t*,const ulint*,mtr_t*)" -> "page_dir_slot_get_n_owned(const page_dir_slot_t*)"
"page_cur_delete_rec(page_cur_t*,const dict_index_t*,const ulint*,mtr_t*)" -> "page_get_n_recs(const ib_page_t*)"
"page_mem_free(ib_page_t*,page_zip_des_t*,rec_t*,const dict_index_t*,const ulint*)" -> "page_header_get_offs(const ib_page_t*,ulint)"
"page_mem_free(ib_page_t*,page_zip_des_t*,rec_t*,const dict_index_t*,const ulint*)" -> "rec_offs_size(const ulint*)"
"page_mem_free(ib_page_t*,page_zip_des_t*,rec_t*,const dict_index_t*,const ulint*)" -> "page_header_set_ptr(ib_page_t*,page_zip_des_t*,ulint,const unsigned char*)"
"page_mem_free(ib_page_t*,page_zip_des_t*,rec_t*,const dict_index_t*,const ulint*)" -> "page_header_set_field(ib_page_t*,page_zip_des_t*,ulint,ulint)"
"page_mem_free(ib_page_t*,page_zip_des_t*,rec_t*,const dict_index_t*,const ulint*)" -> "page_get_n_recs(const ib_page_t*)"
"page_mem_free(ib_page_t*,page_zip_des_t*,rec_t*,const dict_index_t*,const ulint*)" -> "page_header_get_field(const ib_page_t*,ulint)"
"page_mem_free(ib_page_t*,page_zip_des_t*,rec_t*,const dict_index_t*,const ulint*)" -> "page_rec_set_next(rec_t*,const rec_t*)"
"page_mem_free(ib_page_t*,page_zip_des_t*,rec_t*,const dict_index_t*,const ulint*)" -> "page_zip_dir_delete(page_zip_des_t*,unsigned char*,const dict_index_t*,const ulint*,const unsigned char*)"
"page_zip_dir_delete(page_zip_des_t*,unsigned char*,const dict_index_t*,const ulint*,const unsigned char*)" -> "ut_dbg_assertion_failed(const char*,const char*,ulint)"
"page_zip_dir_delete(page_zip_des_t*,unsigned char*,const dict_index_t*,const ulint*,const unsigned char*)" -> "rec_offs_n_extern(const ulint*)"
"page_zip_dir_delete(page_zip_des_t*,unsigned char*,const dict_index_t*,const ulint*,const unsigned char*)" -> "__builtin_expect(long int,long int)"
"page_zip_dir_delete(page_zip_des_t*,unsigned char*,const dict_index_t*,const ulint*,const unsigned char*)" -> "page_zip_get_size(const page_zip_des_t*)"
"page_zip_dir_delete(page_zip_des_t*,unsigned char*,const dict_index_t*,const ulint*,const unsigned char*)" -> "page_zip_clear_rec(page_zip_des_t*,unsigned char*,const dict_index_t*,const ulint*)"
"page_zip_dir_delete(page_zip_des_t*,unsigned char*,const dict_index_t*,const ulint*,const unsigned char*)" -> "page_header_set_field(ib_page_t*,page_zip_des_t*,ulint,ulint)"
"page_zip_dir_delete(page_zip_des_t*,unsigned char*,const dict_index_t*,const ulint*,const unsigned char*)" -> "page_zip_dir_find(page_zip_des_t*,ulint)"
"page_zip_dir_delete(page_zip_des_t*,unsigned char*,const dict_index_t*,const ulint*,const unsigned char*)" -> "dict_index_is_clust(const dict_index_t*)"
"page_zip_dir_delete(page_zip_des_t*,unsigned char*,const dict_index_t*,const ulint*,const unsigned char*)" -> "page_align(const void*)"
"page_zip_dir_delete(page_zip_des_t*,unsigned char*,const dict_index_t*,const ulint*,const unsigned char*)" -> "page_zip_get_n_prev_extern(const page_zip_des_t*,const rec_t*,const dict_index_t*)"
"page_zip_dir_delete(page_zip_des_t*,unsigned char*,const dict_index_t*,const ulint*,const unsigned char*)" -> "page_dir_get_n_heap(const ib_page_t*)"
"page_zip_dir_delete(page_zip_des_t*,unsigned char*,const dict_index_t*,const ulint*,const unsigned char*)" -> "memmove(void*,const void*,size_t)"
"page_zip_dir_delete(page_zip_des_t*,unsigned char*,const dict_index_t*,const ulint*,const unsigned char*)" -> "page_get_n_recs(const ib_page_t*)"
"page_zip_dir_delete(page_zip_des_t*,unsigned char*,const dict_index_t*,const ulint*,const unsigned char*)" -> "abort()"
"page_zip_dir_delete(page_zip_des_t*,unsigned char*,const dict_index_t*,const ulint*,const unsigned char*)" -> "page_offset(const void*)"
"page_zip_dir_delete(page_zip_des_t*,unsigned char*,const dict_index_t*,const ulint*,const unsigned char*)" -> "page_zip_dir_find_free(page_zip_des_t*,ulint)"
"page_zip_dir_delete(page_zip_des_t*,unsigned char*,const dict_index_t*,const ulint*,const unsigned char*)" -> "memset(void*,int,size_t)"
"page_zip_dir_delete(page_zip_des_t*,unsigned char*,const dict_index_t*,const ulint*,const unsigned char*)" -> "mach_write_to_2(unsigned char*,ulint)"
"page_zip_dir_delete(page_zip_des_t*,unsigned char*,const dict_index_t*,const ulint*,const unsigned char*)" -> "page_is_leaf(const ib_page_t*)"
"page_zip_clear_rec(page_zip_des_t*,unsigned char*,const dict_index_t*,const ulint*)" -> "rec_get_heap_no_new(const rec_t*)"
"page_zip_clear_rec(page_zip_des_t*,unsigned char*,const dict_index_t*,const ulint*)" -> "rec_offs_n_fields(const ulint*)"
"page_zip_clear_rec(page_zip_des_t*,unsigned char*,const dict_index_t*,const ulint*)" -> "page_is_leaf(const ib_page_t*)"
"page_zip_clear_rec(page_zip_des_t*,unsigned char*,const dict_index_t*,const ulint*)" -> "rec_offs_any_extern(const ulint*)"
"page_zip_clear_rec(page_zip_des_t*,unsigned char*,const dict_index_t*,const ulint*)" -> "memset(void*,int,size_t)"
"page_zip_clear_rec(page_zip_des_t*,unsigned char*,const dict_index_t*,const ulint*)" -> "rec_offs_nth_extern(const ulint*,ulint)"
"page_zip_clear_rec(page_zip_des_t*,unsigned char*,const dict_index_t*,const ulint*)" -> "page_align(const void*)"
"page_zip_clear_rec(page_zip_des_t*,unsigned char*,const dict_index_t*,const ulint*)" -> "dict_col_get_clust_pos(const dict_col_t*,const dict_index_t*)"
"page_zip_clear_rec(page_zip_des_t*,unsigned char*,const dict_index_t*,const ulint*)" -> "rec_get_nth_field_offs(const ulint*,ulint,ulint*)"
"page_zip_clear_rec(page_zip_des_t*,unsigned char*,const dict_index_t*,const ulint*)" -> "page_zip_dir_elems(const page_zip_des_t*)"
"page_zip_clear_rec(page_zip_des_t*,unsigned char*,const dict_index_t*,const ulint*)" -> "dict_index_is_clust(const dict_index_t*)"
"page_zip_clear_rec(page_zip_des_t*,unsigned char*,const dict_index_t*,const ulint*)" -> "page_zip_dir_start_offs(const page_zip_des_t*,ulint)"
"page_dir_balance_slot(ib_page_t*,page_zip_des_t*,ulint)" -> "page_dir_get_n_slots(const ib_page_t*)"
"page_dir_balance_slot(ib_page_t*,page_zip_des_t*,ulint)" -> "rec_set_n_owned_old(rec_t*,ulint)"
"page_dir_balance_slot(ib_page_t*,page_zip_des_t*,ulint)" -> "page_dir_slot_get_n_owned(const page_dir_slot_t*)"
"page_dir_balance_slot(ib_page_t*,page_zip_des_t*,ulint)" -> "rec_get_next_ptr(rec_t*,ulint)"
"page_dir_balance_slot(ib_page_t*,page_zip_des_t*,ulint)" -> "page_is_comp(const ib_page_t*)"
"page_dir_balance_slot(ib_page_t*,page_zip_des_t*,ulint)" -> "__builtin_expect(long int,long int)"
"page_dir_balance_slot(ib_page_t*,page_zip_des_t*,ulint)" -> "page_dir_slot_set_n_owned(page_dir_slot_t*,page_zip_des_t*,ulint)"
"page_dir_balance_slot(ib_page_t*,page_zip_des_t*,ulint)" -> "page_dir_slot_get_rec(const page_dir_slot_t*)"
"page_dir_balance_slot(ib_page_t*,page_zip_des_t*,ulint)" -> "page_dir_slot_set_rec(page_dir_slot_t*,rec_t*)"
"page_dir_balance_slot(ib_page_t*,page_zip_des_t*,ulint)" -> "page_dir_delete_slot(ib_page_t*,page_zip_des_t*,ulint)"
"page_dir_balance_slot(ib_page_t*,page_zip_des_t*,ulint)" -> "rec_set_n_owned_new(rec_t*,page_zip_des_t*,ulint)"
"page_dir_delete_slot(ib_page_t*,page_zip_des_t*,ulint)" -> "page_dir_get_n_slots(const ib_page_t*)"
"page_dir_delete_slot(ib_page_t*,page_zip_des_t*,ulint)" -> "page_dir_slot_set_rec(page_dir_slot_t*,rec_t*)"
"page_dir_delete_slot(ib_page_t*,page_zip_des_t*,ulint)" -> "mach_write_to_2(unsigned char*,ulint)"
"page_dir_delete_slot(ib_page_t*,page_zip_des_t*,ulint)" -> "page_dir_slot_set_n_owned(page_dir_slot_t*,page_zip_des_t*,ulint)"
"page_dir_delete_slot(ib_page_t*,page_zip_des_t*,ulint)" -> "page_dir_slot_get_n_owned(const page_dir_slot_t*)"
"page_dir_delete_slot(ib_page_t*,page_zip_des_t*,ulint)" -> "page_header_set_field(ib_page_t*,page_zip_des_t*,ulint,ulint)"
"page_dir_delete_slot(ib_page_t*,page_zip_des_t*,ulint)" -> "page_dir_slot_get_rec(const page_dir_slot_t*)"
"page_cur_delete_rec_write_log(rec_t*,const dict_index_t*,mtr_t*)" -> "page_offset(const void*)"
"page_cur_delete_rec_write_log(rec_t*,const dict_index_t*,mtr_t*)" -> "mach_write_to_2(unsigned char*,ulint)"
"page_cur_delete_rec_write_log(rec_t*,const dict_index_t*,mtr_t*)" -> "page_rec_is_comp(const rec_t*)"
"page_cur_delete_rec_write_log(rec_t*,const dict_index_t*,mtr_t*)" -> "mlog_close(mtr_t*,unsigned char*)"
"page_cur_delete_rec_write_log(rec_t*,const dict_index_t*,mtr_t*)" -> "mlog_open_and_write_index(mtr_t*,const unsigned char*,const dict_index_t*,unsigned char,ulint)"
"page_create_empty(buf_block_t*,dict_index_t*,mtr_t*)" -> "page_is_leaf(const ib_page_t*)"
"page_create_empty(buf_block_t*,dict_index_t*,mtr_t*)" -> "page_header_get_field(const ib_page_t*,ulint)"
"page_create_empty(buf_block_t*,dict_index_t*,mtr_t*)" -> "dict_index_is_sec_or_ibuf(const dict_index_t*)"
"page_create_empty(buf_block_t*,dict_index_t*,mtr_t*)" -> "page_create_zip(buf_block_t*,dict_index_t*,ulint,trx_id_t,mtr_t*)"
"page_create_empty(buf_block_t*,dict_index_t*,mtr_t*)" -> "page_get_max_trx_id(const ib_page_t*)"
"page_create_empty(buf_block_t*,dict_index_t*,mtr_t*)" -> "page_create(buf_block_t*,mtr_t*,ulint)"
"page_create_empty(buf_block_t*,dict_index_t*,mtr_t*)" -> "page_is_comp(const ib_page_t*)"
"page_create_empty(buf_block_t*,dict_index_t*,mtr_t*)" -> "page_update_max_trx_id(buf_block_t*,page_zip_des_t*,trx_id_t,mtr_t*)"
"page_create_zip(buf_block_t*,dict_index_t*,ulint,trx_id_t,mtr_t*)" -> "ut_dbg_assertion_failed(const char*,const char*,ulint)"
"page_create_zip(buf_block_t*,dict_index_t*,ulint,trx_id_t,mtr_t*)" -> "mach_write_to_2(unsigned char*,ulint)"
"page_create_zip(buf_block_t*,dict_index_t*,ulint,trx_id_t,mtr_t*)" -> "page_create_low(buf_block_t*,ulint)"
"page_create_zip(buf_block_t*,dict_index_t*,ulint,trx_id_t,mtr_t*)" -> "abort()"
"page_create_zip(buf_block_t*,dict_index_t*,ulint,trx_id_t,mtr_t*)" -> "mach_write_to_8(void*,ib_uint64_t)"
"page_create_zip(buf_block_t*,dict_index_t*,ulint,trx_id_t,mtr_t*)" -> "page_zip_compress(page_zip_des_t*,const ib_page_t*,dict_index_t*,ulint,mtr_t*)"
"page_update_max_trx_id(buf_block_t*,page_zip_des_t*,trx_id_t,mtr_t*)" -> "page_get_max_trx_id(const ib_page_t*)"
"page_update_max_trx_id(buf_block_t*,page_zip_des_t*,trx_id_t,mtr_t*)" -> "page_set_max_trx_id(buf_block_t*,page_zip_des_t*,trx_id_t,mtr_t*)"
"lock_rec_store_on_page_infimum(const buf_block_t*,const rec_t*)" -> "lock_rec_move(const buf_block_t*,const buf_block_t*,ulint,ulint)"
"lock_rec_store_on_page_infimum(const buf_block_t*,const rec_t*)" -> "pfs_mutex_exit_func(ib_mutex_t*)"
"lock_rec_store_on_page_infimum(const buf_block_t*,const rec_t*)" -> "page_rec_get_heap_no(const rec_t*)"
"lock_rec_store_on_page_infimum(const buf_block_t*,const rec_t*)" -> "pfs_mutex_enter_func(ib_mutex_t*,const char*,ulint)"
"lock_rec_move(const buf_block_t*,const buf_block_t*,ulint,ulint)" -> "lock_rec_get_first(const buf_block_t*,ulint)"
"lock_rec_move(const buf_block_t*,const buf_block_t*,ulint,ulint)" -> "lock_reset_lock_and_trx_wait(ib_lock_t*)"
"lock_rec_move(const buf_block_t*,const buf_block_t*,ulint,ulint)" -> "lock_rec_reset_nth_bit(ib_lock_t*,ulint)"
"lock_rec_move(const buf_block_t*,const buf_block_t*,ulint,ulint)" -> "lock_rec_add_to_queue(ulint,const buf_block_t*,ulint,dict_index_t*,trx_t*,ulint)"
"lock_rec_move(const buf_block_t*,const buf_block_t*,ulint,ulint)" -> "__builtin_expect(long int,long int)"
"lock_rec_move(const buf_block_t*,const buf_block_t*,ulint,ulint)" -> "lock_rec_get_next(ulint,ib_lock_t*)"
"lock_rec_get_first(const buf_block_t*,ulint)" -> "lock_rec_get_next_on_page(ib_lock_t*)"
"lock_rec_get_first(const buf_block_t*,ulint)" -> "lock_rec_get_nth_bit(const ib_lock_t*,ulint)"
"lock_rec_get_first(const buf_block_t*,ulint)" -> "lock_rec_get_first_on_page(const buf_block_t*)"
"lock_rec_get_next(ulint,ib_lock_t*)" -> "lock_rec_get_nth_bit(const ib_lock_t*,ulint)"
"lock_rec_get_next(ulint,ib_lock_t*)" -> "lock_rec_get_next_on_page(ib_lock_t*)"
"page_rec_get_heap_no(const rec_t*)" -> "rec_get_heap_no_old(const rec_t*)"
"page_rec_get_heap_no(const rec_t*)" -> "page_rec_is_comp(const rec_t*)"
"page_rec_get_heap_no(const rec_t*)" -> "rec_get_heap_no_new(const rec_t*)"
"dtuple_print(FILE*,const dtuple_t*)" -> "dtuple_get_n_fields(const dtuple_t*)"
"dtuple_print(FILE*,const dtuple_t*)" -> "_IO_putc(int,_IO_FILE*)"
"dtuple_print(FILE*,const dtuple_t*)" -> "dfield_print_raw(FILE*,const dfield_t*)"
"dtuple_print(FILE*,const dtuple_t*)" -> "fprintf(FILE*,const char*,...)"
"dfield_print_raw(FILE*,const dfield_t*)" -> "dfield_is_ext(const dfield_t*)"
"dfield_print_raw(FILE*,const dfield_t*)" -> "ut_min(ulint,ulint)"
"dfield_print_raw(FILE*,const dfield_t*)" -> "dfield_get_len(const dfield_t*)"
"dfield_print_raw(FILE*,const dfield_t*)" -> "ut_print_buf(FILE*,const void*,ulint)"
"dfield_print_raw(FILE*,const dfield_t*)" -> "dfield_is_null(const dfield_t*)"
"dfield_print_raw(FILE*,const dfield_t*)" -> "fprintf(FILE*,const char*,...)"
"dfield_print_raw(FILE*,const dfield_t*)" -> "__builtin_fwrite(const void*,size_t,size_t,FILE*)"
"lock_rec_restore_from_page_infimum(const buf_block_t*,const rec_t*,const buf_block_t*)" -> "pfs_mutex_enter_func(ib_mutex_t*,const char*,ulint)"
"lock_rec_restore_from_page_infimum(const buf_block_t*,const rec_t*,const buf_block_t*)" -> "pfs_mutex_exit_func(ib_mutex_t*)"
"lock_rec_restore_from_page_infimum(const buf_block_t*,const rec_t*,const buf_block_t*)" -> "page_rec_get_heap_no(const rec_t*)"
"lock_rec_restore_from_page_infimum(const buf_block_t*,const rec_t*,const buf_block_t*)" -> "lock_rec_move(const buf_block_t*,const buf_block_t*,ulint,ulint)"
"row_upd_build_sec_rec_difference_binary(const rec_t*,dict_index_t*,const ulint*,const dtuple_t*,mem_heap_t*)" -> "upd_create(ulint,mem_heap_t*)"
"row_upd_build_sec_rec_difference_binary(const rec_t*,dict_index_t*,const ulint*,const dtuple_t*,mem_heap_t*)" -> "upd_field_set_field_no(upd_field_t*,ulint,dict_index_t*,trx_t*)"
"row_upd_build_sec_rec_difference_binary(const rec_t*,dict_index_t*,const ulint*,const dtuple_t*,mem_heap_t*)" -> "ut_dbg_assertion_failed(const char*,const char*,ulint)"
"row_upd_build_sec_rec_difference_binary(const rec_t*,dict_index_t*,const ulint*,const dtuple_t*,mem_heap_t*)" -> "__builtin_expect(long int,long int)"
"row_upd_build_sec_rec_difference_binary(const rec_t*,dict_index_t*,const ulint*,const dtuple_t*,mem_heap_t*)" -> "abort()"
"row_upd_build_sec_rec_difference_binary(const rec_t*,dict_index_t*,const ulint*,const dtuple_t*,mem_heap_t*)" -> "dict_index_is_clust(const dict_index_t*)"
"row_upd_build_sec_rec_difference_binary(const rec_t*,dict_index_t*,const ulint*,const dtuple_t*,mem_heap_t*)" -> "dfield_copy(dfield_t*,const dfield_t*)"
"row_upd_build_sec_rec_difference_binary(const rec_t*,dict_index_t*,const ulint*,const dtuple_t*,mem_heap_t*)" -> "dtuple_get_n_fields(const dtuple_t*)"
"row_upd_build_sec_rec_difference_binary(const rec_t*,dict_index_t*,const ulint*,const dtuple_t*,mem_heap_t*)" -> "rec_get_nth_field_offs(const ulint*,ulint,ulint*)"
"row_upd_build_sec_rec_difference_binary(const rec_t*,dict_index_t*,const ulint*,const dtuple_t*,mem_heap_t*)" -> "dfield_data_is_binary_equal(const dfield_t*,ulint,const unsigned char*)"
"dfield_data_is_binary_equal(const dfield_t*,ulint,const unsigned char*)" -> "memcmp(const void*,const void*,size_t)"
"dfield_data_is_binary_equal(const dfield_t*,ulint,const unsigned char*)" -> "dfield_get_len(const dfield_t*)"
"btr_cur_set_deleted_flag_for_ibuf(rec_t*,page_zip_des_t*,ulint,mtr_t*)" -> "btr_cur_del_mark_set_sec_rec_log(rec_t*,ulint,mtr_t*)"
"btr_cur_set_deleted_flag_for_ibuf(rec_t*,page_zip_des_t*,ulint,mtr_t*)" -> "btr_rec_set_deleted_flag(rec_t*,page_zip_des_t*,ulint)"
"btr_cur_del_mark_set_sec_rec_log(rec_t*,ulint,mtr_t*)" -> "mach_write_to_2(unsigned char*,ulint)"
"btr_cur_del_mark_set_sec_rec_log(rec_t*,ulint,mtr_t*)" -> "page_offset(const void*)"
"btr_cur_del_mark_set_sec_rec_log(rec_t*,ulint,mtr_t*)" -> "mlog_write_initial_log_record_fast(const unsigned char*,unsigned char,unsigned char*,mtr_t*)"
"btr_cur_del_mark_set_sec_rec_log(rec_t*,ulint,mtr_t*)" -> "mlog_open(mtr_t*,ulint)"
"btr_cur_del_mark_set_sec_rec_log(rec_t*,ulint,mtr_t*)" -> "mach_write_to_1(unsigned char*,ulint)"
"btr_cur_del_mark_set_sec_rec_log(rec_t*,ulint,mtr_t*)" -> "mlog_close(mtr_t*,unsigned char*)"
"btr_rec_set_deleted_flag(rec_t*,page_zip_des_t*,ulint)" -> "page_rec_is_comp(const rec_t*)"
"btr_rec_set_deleted_flag(rec_t*,page_zip_des_t*,ulint)" -> "rec_set_deleted_flag_new(rec_t*,page_zip_des_t*,ulint)"
"btr_rec_set_deleted_flag(rec_t*,page_zip_des_t*,ulint)" -> "rec_set_deleted_flag_old(rec_t*,ulint)"
"rec_set_deleted_flag_new(rec_t*,page_zip_des_t*,ulint)" -> "rec_set_info_bits_new(rec_t*,ulint)"
"rec_set_deleted_flag_new(rec_t*,page_zip_des_t*,ulint)" -> "page_zip_rec_set_deleted(page_zip_des_t*,const unsigned char*,ulint)"
"rec_set_deleted_flag_new(rec_t*,page_zip_des_t*,ulint)" -> "rec_get_info_bits(const rec_t*,ulint)"
"page_zip_rec_set_deleted(page_zip_des_t*,const unsigned char*,ulint)" -> "abort()"
"page_zip_rec_set_deleted(page_zip_des_t*,const unsigned char*,ulint)" -> "ut_dbg_assertion_failed(const char*,const char*,ulint)"
"page_zip_rec_set_deleted(page_zip_des_t*,const unsigned char*,ulint)" -> "page_zip_dir_find(page_zip_des_t*,ulint)"
"page_zip_rec_set_deleted(page_zip_des_t*,const unsigned char*,ulint)" -> "page_offset(const void*)"
"page_zip_rec_set_deleted(page_zip_des_t*,const unsigned char*,ulint)" -> "__builtin_expect(long int,long int)"
"rec_set_deleted_flag_old(rec_t*,ulint)" -> "rec_get_info_bits(const rec_t*,ulint)"
"rec_set_deleted_flag_old(rec_t*,ulint)" -> "rec_set_info_bits_old(rec_t*,ulint)"
"ibuf_insert_to_index_page_low(const dtuple_t*,buf_block_t*,dict_index_t*,ulint**,mem_heap_t*,mtr_t*,page_cur_t*)" -> "page_get_page_no(const ib_page_t*)"
"ibuf_insert_to_index_page_low(const dtuple_t*,buf_block_t*,dict_index_t*,ulint**,mem_heap_t*,mtr_t*,page_cur_t*)" -> "btr_page_reorganize(page_cur_t*,dict_index_t*,mtr_t*)"
"ibuf_insert_to_index_page_low(const dtuple_t*,buf_block_t*,dict_index_t*,ulint**,mem_heap_t*,mtr_t*,page_cur_t*)" -> "ibuf_bitmap_get_map_page_func(ulint,ulint,ulint,const char*,ulint,mtr_t*)"
"ibuf_insert_to_index_page_low(const dtuple_t*,buf_block_t*,dict_index_t*,ulint**,mem_heap_t*,mtr_t*,page_cur_t*)" -> "page_get_max_insert_size(const ib_page_t*,ulint)"
"ibuf_insert_to_index_page_low(const dtuple_t*,buf_block_t*,dict_index_t*,ulint**,mem_heap_t*,mtr_t*,page_cur_t*)" -> "fprintf(FILE*,const char*,...)"
"ibuf_insert_to_index_page_low(const dtuple_t*,buf_block_t*,dict_index_t*,ulint**,mem_heap_t*,mtr_t*,page_cur_t*)" -> "dtuple_print(FILE*,const dtuple_t*)"
"ibuf_insert_to_index_page_low(const dtuple_t*,buf_block_t*,dict_index_t*,ulint**,mem_heap_t*,mtr_t*,page_cur_t*)" -> "rec_get_converted_size(dict_index_t*,const dtuple_t*,ulint)"
"ibuf_insert_to_index_page_low(const dtuple_t*,buf_block_t*,dict_index_t*,ulint**,mem_heap_t*,mtr_t*,page_cur_t*)" -> "ibuf_bitmap_page_get_bits_low(const ib_page_t*,ulint,ulint,ulint)"
"ibuf_insert_to_index_page_low(const dtuple_t*,buf_block_t*,dict_index_t*,ulint**,mem_heap_t*,mtr_t*,page_cur_t*)" -> "buf_block_get_zip_size(const buf_block_t*)"
"ibuf_insert_to_index_page_low(const dtuple_t*,buf_block_t*,dict_index_t*,ulint**,mem_heap_t*,mtr_t*,page_cur_t*)" -> "__builtin_fwrite(const void*,size_t,size_t,FILE*)"
"ibuf_insert_to_index_page_low(const dtuple_t*,buf_block_t*,dict_index_t*,ulint**,mem_heap_t*,mtr_t*,page_cur_t*)" -> "page_get_space_id(const ib_page_t*)"
"ibuf_insert_to_index_page_low(const dtuple_t*,buf_block_t*,dict_index_t*,ulint**,mem_heap_t*,mtr_t*,page_cur_t*)" -> "ut_print_timestamp(FILE*)"
"ibuf_insert_to_index_page_low(const dtuple_t*,buf_block_t*,dict_index_t*,ulint**,mem_heap_t*,mtr_t*,page_cur_t*)" -> "page_cur_tuple_insert(page_cur_t*,const dtuple_t*,dict_index_t*,ulint**,mem_heap_t**,ulint,mtr_t*)"
"btr_page_reorganize(page_cur_t*,dict_index_t*,mtr_t*)" -> "btr_page_reorganize_low(bool,ulint,page_cur_t*,dict_index_t*,mtr_t*)"
"btr_page_reorganize_low(bool,ulint,page_cur_t*,dict_index_t*,mtr_t*)" -> "mlog_open_and_write_index(mtr_t*,const unsigned char*,const dict_index_t*,unsigned char,ulint)"
"btr_page_reorganize_low(bool,ulint,page_cur_t*,dict_index_t*,mtr_t*)" -> "btr_search_drop_page_hash_index(buf_block_t*)"
"btr_page_reorganize_low(bool,ulint,page_cur_t*,dict_index_t*,mtr_t*)" -> "dict_table_is_comp(const dict_table_t*)"
"btr_page_reorganize_low(bool,ulint,page_cur_t*,dict_index_t*,mtr_t*)" -> "buf_frame_copy(unsigned char*,const buf_frame_t*)"
"btr_page_reorganize_low(bool,ulint,page_cur_t*,dict_index_t*,mtr_t*)" -> "page_copy_rec_list_end_no_locks(buf_block_t*,buf_block_t*,rec_t*,dict_index_t*,mtr_t*)"
"btr_page_reorganize_low(bool,ulint,page_cur_t*,dict_index_t*,mtr_t*)" -> "mach_write_to_1(unsigned char*,ulint)"
"btr_page_reorganize_low(bool,ulint,page_cur_t*,dict_index_t*,mtr_t*)" -> "abort()"
"btr_page_reorganize_low(bool,ulint,page_cur_t*,dict_index_t*,mtr_t*)" -> "page_is_leaf(const ib_page_t*)"
"btr_page_reorganize_low(bool,ulint,page_cur_t*,dict_index_t*,mtr_t*)" -> "memcpy(void*,const void*,size_t)"
"btr_page_reorganize_low(bool,ulint,page_cur_t*,dict_index_t*,mtr_t*)" -> "dict_index_is_sec_or_ibuf(const dict_index_t*)"
"btr_page_reorganize_low(bool,ulint,page_cur_t*,dict_index_t*,mtr_t*)" -> "page_zip_compress(page_zip_des_t*,const ib_page_t*,dict_index_t*,ulint,mtr_t*)"
"btr_page_reorganize_low(bool,ulint,page_cur_t*,dict_index_t*,mtr_t*)" -> "btr_corruption_report(const buf_block_t*,const dict_index_t*)"
"btr_page_reorganize_low(bool,ulint,page_cur_t*,dict_index_t*,mtr_t*)" -> "page_rec_get_n_recs_before(const rec_t*)"
"btr_page_reorganize_low(bool,ulint,page_cur_t*,dict_index_t*,mtr_t*)" -> "ut_dbg_assertion_failed(const char*,const char*,ulint)"
"btr_page_reorganize_low(bool,ulint,page_cur_t*,dict_index_t*,mtr_t*)" -> "page_rec_get_nth(ib_page_t*,ulint)"
"btr_page_reorganize_low(bool,ulint,page_cur_t*,dict_index_t*,mtr_t*)" -> "fprintf(FILE*,const char*,...)"
"btr_page_reorganize_low(bool,ulint,page_cur_t*,dict_index_t*,mtr_t*)" -> "page_get_max_insert_size_after_reorganize(const ib_page_t*,ulint)"
"btr_page_reorganize_low(bool,ulint,page_cur_t*,dict_index_t*,mtr_t*)" -> "buf_pool_from_bpage(const buf_page_t*)"
"btr_page_reorganize_low(bool,ulint,page_cur_t*,dict_index_t*,mtr_t*)" -> "page_get_max_trx_id(const ib_page_t*)"
"btr_page_reorganize_low(bool,ulint,page_cur_t*,dict_index_t*,mtr_t*)" -> "lock_move_reorganize_page(const buf_block_t*,const buf_block_t*)"
"btr_page_reorganize_low(bool,ulint,page_cur_t*,dict_index_t*,mtr_t*)" -> "buf_block_alloc(buf_pool_t*)"
"btr_page_reorganize_low(bool,ulint,page_cur_t*,dict_index_t*,mtr_t*)" -> "mtr_set_log_mode(mtr_t*,ulint)"
"btr_page_reorganize_low(bool,ulint,page_cur_t*,dict_index_t*,mtr_t*)" -> "page_get_data_size(const ib_page_t*)"
"btr_page_reorganize_low(bool,ulint,page_cur_t*,dict_index_t*,mtr_t*)" -> "page_is_comp(const ib_page_t*)"
"btr_page_reorganize_low(bool,ulint,page_cur_t*,dict_index_t*,mtr_t*)" -> "buf_page_print(const unsigned char*,ulint,ulint)"
"btr_page_reorganize_low(bool,ulint,page_cur_t*,dict_index_t*,mtr_t*)" -> "page_get_infimum_offset(const ib_page_t*)"
"btr_page_reorganize_low(bool,ulint,page_cur_t*,dict_index_t*,mtr_t*)" -> "page_create(buf_block_t*,mtr_t*,ulint)"
"btr_page_reorganize_low(bool,ulint,page_cur_t*,dict_index_t*,mtr_t*)" -> "page_set_max_trx_id(buf_block_t*,page_zip_des_t*,trx_id_t,mtr_t*)"
"btr_page_reorganize_low(bool,ulint,page_cur_t*,dict_index_t*,mtr_t*)" -> "mlog_close(mtr_t*,unsigned char*)"
"btr_page_reorganize_low(bool,ulint,page_cur_t*,dict_index_t*,mtr_t*)" -> "buf_block_free(buf_block_t*)"
"page_rec_get_nth(ib_page_t*,ulint)" -> "page_rec_get_nth_const(const ib_page_t*,ulint)"
"page_rec_get_nth_const(const ib_page_t*,ulint)" -> "page_is_comp(const ib_page_t*)"
"page_rec_get_nth_const(const ib_page_t*,ulint)" -> "page_dir_slot_get_n_owned(const page_dir_slot_t*)"
"page_rec_get_nth_const(const ib_page_t*,ulint)" -> "page_dir_slot_get_rec(const page_dir_slot_t*)"
"page_rec_get_nth_const(const ib_page_t*,ulint)" -> "page_rec_get_next_low(const rec_t*,ulint)"
"page_rec_get_nth_const(const ib_page_t*,ulint)" -> "page_get_infimum_offset(const ib_page_t*)"
"page_get_max_insert_size_after_reorganize(const ib_page_t*,ulint)" -> "page_is_comp(const ib_page_t*)"
"page_get_max_insert_size_after_reorganize(const ib_page_t*,ulint)" -> "page_get_data_size(const ib_page_t*)"
"page_get_max_insert_size_after_reorganize(const ib_page_t*,ulint)" -> "page_get_free_space_of_empty(ulint)"
"page_get_max_insert_size_after_reorganize(const ib_page_t*,ulint)" -> "page_get_n_recs(const ib_page_t*)"
"page_get_max_insert_size_after_reorganize(const ib_page_t*,ulint)" -> "page_dir_calc_reserved_space(ulint)"
"page_get_data_size(const ib_page_t*)" -> "page_is_comp(const ib_page_t*)"
"page_get_data_size(const ib_page_t*)" -> "page_header_get_field(const ib_page_t*,ulint)"
"ibuf_bitmap_page_get_bits_low(const ib_page_t*,ulint,ulint,ulint)" -> "mach_read_from_1(const unsigned char*)"
"ibuf_bitmap_page_get_bits_low(const ib_page_t*,ulint,ulint,ulint)" -> "ut_bit_get_nth(ulint,ulint)"
"page_cur_tuple_insert(page_cur_t*,const dtuple_t*,dict_index_t*,ulint**,mem_heap_t**,ulint,mtr_t*)" -> "mem_heap_alloc(mem_heap_t*,ulint)"
"page_cur_tuple_insert(page_cur_t*,const dtuple_t*,dict_index_t*,ulint**,mem_heap_t**,ulint,mtr_t*)" -> "rec_get_offsets_func(const rec_t*,const dict_index_t*,ulint*,ulint,mem_heap_t**)"
"page_cur_tuple_insert(page_cur_t*,const dtuple_t*,dict_index_t*,ulint**,mem_heap_t**,ulint,mtr_t*)" -> "page_cur_insert_rec_low(rec_t*,dict_index_t*,const rec_t*,ulint*,mtr_t*)"
"page_cur_tuple_insert(page_cur_t*,const dtuple_t*,dict_index_t*,ulint**,mem_heap_t**,ulint,mtr_t*)" -> "rec_get_converted_size(dict_index_t*,const dtuple_t*,ulint)"
"page_cur_tuple_insert(page_cur_t*,const dtuple_t*,dict_index_t*,ulint**,mem_heap_t**,ulint,mtr_t*)" -> "rec_convert_dtuple_to_rec(unsigned char*,const dict_index_t*,const dtuple_t*,ulint)"
"page_cur_tuple_insert(page_cur_t*,const dtuple_t*,dict_index_t*,ulint**,mem_heap_t**,ulint,mtr_t*)" -> "page_cur_insert_rec_zip(page_cur_t*,dict_index_t*,const rec_t*,ulint*,mtr_t*)"
"page_cur_tuple_insert(page_cur_t*,const dtuple_t*,dict_index_t*,ulint**,mem_heap_t**,ulint,mtr_t*)" -> "dtuple_get_n_fields(const dtuple_t*)"
"page_cur_tuple_insert(page_cur_t*,const dtuple_t*,dict_index_t*,ulint**,mem_heap_t**,ulint,mtr_t*)" -> "mem_heap_create_func(ulint,ulint)"
"page_cur_search(const buf_block_t*,const dict_index_t*,const dtuple_t*,ulint,page_cur_t*)" -> "page_cur_search_with_match(const buf_block_t*,const dict_index_t*,const dtuple_t*,ulint,ulint*,ulint*,ulint*,ulint*,page_cur_t*)"
"page_cur_search_with_match(const buf_block_t*,const dict_index_t*,const dtuple_t*,ulint,ulint*,ulint*,ulint*,ulint*,page_cur_t*)" -> "ut_pair_min(ulint*,ulint*,ulint,ulint,ulint,ulint)"
"page_cur_search_with_match(const buf_block_t*,const dict_index_t*,const dtuple_t*,ulint,ulint*,ulint*,ulint*,ulint*,page_cur_t*)" -> "page_dir_slot_get_rec(const page_dir_slot_t*)"
"page_cur_search_with_match(const buf_block_t*,const dict_index_t*,const dtuple_t*,ulint,ulint*,ulint*,ulint*,ulint*,page_cur_t*)" -> "rec_get_offsets_func(const rec_t*,const dict_index_t*,ulint*,ulint,mem_heap_t**)"
"page_cur_search_with_match(const buf_block_t*,const dict_index_t*,const dtuple_t*,ulint,ulint*,ulint*,ulint*,ulint*,page_cur_t*)" -> "__builtin_expect(long int,long int)"
"page_cur_search_with_match(const buf_block_t*,const dict_index_t*,const dtuple_t*,ulint,ulint*,ulint*,ulint*,ulint*,page_cur_t*)" -> "dtuple_get_n_fields_cmp(const dtuple_t*)"
"page_cur_search_with_match(const buf_block_t*,const dict_index_t*,const dtuple_t*,ulint,ulint*,ulint*,ulint*,ulint*,page_cur_t*)" -> "page_check_dir(const ib_page_t*)"
"page_cur_search_with_match(const buf_block_t*,const dict_index_t*,const dtuple_t*,ulint,ulint*,ulint*,ulint*,ulint*,page_cur_t*)" -> "page_cur_position(const rec_t*,const buf_block_t*,page_cur_t*)"
"page_cur_search_with_match(const buf_block_t*,const dict_index_t*,const dtuple_t*,ulint,ulint*,ulint*,ulint*,ulint*,page_cur_t*)" -> "page_cur_try_search_shortcut(const buf_block_t*,const dict_index_t*,const dtuple_t*,ulint*,ulint*,ulint*,ulint*,page_cur_t*)"
"page_cur_search_with_match(const buf_block_t*,const dict_index_t*,const dtuple_t*,ulint,ulint*,ulint*,ulint*,ulint*,page_cur_t*)" -> "mem_heap_free_func(mem_heap_t*,const char*,ulint)"
"page_cur_search_with_match(const buf_block_t*,const dict_index_t*,const dtuple_t*,ulint,ulint*,ulint*,ulint*,ulint*,page_cur_t*)" -> "page_header_get_field(const ib_page_t*,ulint)"
"page_cur_search_with_match(const buf_block_t*,const dict_index_t*,const dtuple_t*,ulint,ulint*,ulint*,ulint*,ulint*,page_cur_t*)" -> "page_rec_get_next_const(const rec_t*)"
"page_cur_search_with_match(const buf_block_t*,const dict_index_t*,const dtuple_t*,ulint,ulint*,ulint*,ulint*,ulint*,page_cur_t*)" -> "cmp_dtuple_rec_with_match_low(const dtuple_t*,const rec_t*,const ulint*,ulint,ulint*,ulint*)"
"page_cur_search_with_match(const buf_block_t*,const dict_index_t*,const dtuple_t*,ulint,ulint*,ulint*,ulint*,ulint*,page_cur_t*)" -> "page_is_leaf(const ib_page_t*)"
"page_cur_search_with_match(const buf_block_t*,const dict_index_t*,const dtuple_t*,ulint,ulint*,ulint*,ulint*,ulint*,page_cur_t*)" -> "page_dir_get_n_slots(const ib_page_t*)"
"page_cur_search_with_match(const buf_block_t*,const dict_index_t*,const dtuple_t*,ulint,ulint*,ulint*,ulint*,ulint*,page_cur_t*)" -> "page_header_get_offs(const ib_page_t*,ulint)"
"page_cur_search_with_match(const buf_block_t*,const dict_index_t*,const dtuple_t*,ulint,ulint*,ulint*,ulint*,ulint*,page_cur_t*)" -> "rec_offs_set_n_alloc(ulint*,ulint)"
"ut_pair_min(ulint*,ulint*,ulint,ulint,ulint,ulint)" -> "ut_min(ulint,ulint)"
"page_check_dir(const ib_page_t*)" -> "buf_page_print(const unsigned char*,ulint,ulint)"
"page_check_dir(const ib_page_t*)" -> "mach_read_from_2(const unsigned char*)"
"page_check_dir(const ib_page_t*)" -> "page_rec_is_supremum_low(ulint)"
"page_check_dir(const ib_page_t*)" -> "__builtin_expect(long int,long int)"
"page_check_dir(const ib_page_t*)" -> "__builtin_fwrite(const void*,size_t,size_t,FILE*)"
"page_check_dir(const ib_page_t*)" -> "page_rec_is_infimum_low(ulint)"
"page_check_dir(const ib_page_t*)" -> "page_dir_get_n_slots(const ib_page_t*)"
"page_cur_try_search_shortcut(const buf_block_t*,const dict_index_t*,const dtuple_t*,ulint*,ulint*,ulint*,ulint*,page_cur_t*)" -> "page_header_get_offs(const ib_page_t*,ulint)"
"page_cur_try_search_shortcut(const buf_block_t*,const dict_index_t*,const dtuple_t*,ulint*,ulint*,ulint*,ulint*,page_cur_t*)" -> "rec_offs_set_n_alloc(ulint*,ulint)"
"page_cur_try_search_shortcut(const buf_block_t*,const dict_index_t*,const dtuple_t*,ulint*,ulint*,ulint*,ulint*,page_cur_t*)" -> "mem_heap_free_func(mem_heap_t*,const char*,ulint)"
"page_cur_try_search_shortcut(const buf_block_t*,const dict_index_t*,const dtuple_t*,ulint*,ulint*,ulint*,ulint*,page_cur_t*)" -> "page_rec_get_next_const(const rec_t*)"
"page_cur_try_search_shortcut(const buf_block_t*,const dict_index_t*,const dtuple_t*,ulint*,ulint*,ulint*,ulint*,page_cur_t*)" -> "__builtin_expect(long int,long int)"
"page_cur_try_search_shortcut(const buf_block_t*,const dict_index_t*,const dtuple_t*,ulint*,ulint*,ulint*,ulint*,page_cur_t*)" -> "rec_get_offsets_func(const rec_t*,const dict_index_t*,ulint*,ulint,mem_heap_t**)"
"page_cur_try_search_shortcut(const buf_block_t*,const dict_index_t*,const dtuple_t*,ulint*,ulint*,ulint*,ulint*,page_cur_t*)" -> "page_cur_position(const rec_t*,const buf_block_t*,page_cur_t*)"
"page_cur_try_search_shortcut(const buf_block_t*,const dict_index_t*,const dtuple_t*,ulint*,ulint*,ulint*,ulint*,page_cur_t*)" -> "dtuple_get_n_fields(const dtuple_t*)"
"page_cur_try_search_shortcut(const buf_block_t*,const dict_index_t*,const dtuple_t*,ulint*,ulint*,ulint*,ulint*,page_cur_t*)" -> "page_cmp_dtuple_rec_with_match(const dtuple_t*,const rec_t*,const ulint*,ulint*,ulint*)"
"page_cur_try_search_shortcut(const buf_block_t*,const dict_index_t*,const dtuple_t*,ulint*,ulint*,ulint*,ulint*,page_cur_t*)" -> "page_rec_is_supremum(const rec_t*)"
"page_cur_try_search_shortcut(const buf_block_t*,const dict_index_t*,const dtuple_t*,ulint*,ulint*,ulint*,ulint*,page_cur_t*)" -> "ut_pair_min(ulint*,ulint*,ulint,ulint,ulint,ulint)"
"btr_cur_update_alloc_zip_func(page_zip_des_t*,page_cur_t*,dict_index_t*,ulint,bool,mtr_t*)" -> "dict_index_is_clust(const dict_index_t*)"
"btr_cur_update_alloc_zip_func(page_zip_des_t*,page_cur_t*,dict_index_t*,ulint,bool,mtr_t*)" -> "page_has_garbage(const ib_page_t*)"
"btr_cur_update_alloc_zip_func(page_zip_des_t*,page_cur_t*,dict_index_t*,ulint,bool,mtr_t*)" -> "btr_page_reorganize(page_cur_t*,dict_index_t*,mtr_t*)"
"btr_cur_update_alloc_zip_func(page_zip_des_t*,page_cur_t*,dict_index_t*,ulint,bool,mtr_t*)" -> "dict_index_zip_pad_optimal_page_size(dict_index_t*)"
"btr_cur_update_alloc_zip_func(page_zip_des_t*,page_cur_t*,dict_index_t*,ulint,bool,mtr_t*)" -> "page_is_leaf(const ib_page_t*)"
"btr_cur_update_alloc_zip_func(page_zip_des_t*,page_cur_t*,dict_index_t*,ulint,bool,mtr_t*)" -> "page_align(const void*)"
"btr_cur_update_alloc_zip_func(page_zip_des_t*,page_cur_t*,dict_index_t*,ulint,bool,mtr_t*)" -> "page_zip_available(const page_zip_des_t*,ulint,ulint,ulint)"
"btr_cur_update_alloc_zip_func(page_zip_des_t*,page_cur_t*,dict_index_t*,ulint,bool,mtr_t*)" -> "page_get_data_size(const ib_page_t*)"
"btr_cur_update_alloc_zip_func(page_zip_des_t*,page_cur_t*,dict_index_t*,ulint,bool,mtr_t*)" -> "ibuf_reset_free_bits(buf_block_t*)"
"dict_index_zip_pad_optimal_page_size(dict_index_t*)" -> "__sync_add_and_fetch_8(volatile void*,long unsigned int)"
"dict_index_zip_pad_optimal_page_size(dict_index_t*)" -> "ut_max(ulint,ulint)"
"page_zip_available(const page_zip_des_t*,ulint,ulint,ulint)" -> "page_zip_get_trailer_len(const page_zip_des_t*,ulint)"
"page_zip_available(const page_zip_des_t*,ulint,ulint,ulint)" -> "page_zip_get_size(const page_zip_des_t*)"
"ibuf_reset_free_bits(buf_block_t*)" -> "ibuf_set_free_bits_func(buf_block_t*,ulint)"
"ibuf_set_free_bits_func(buf_block_t*,ulint)" -> "page_is_leaf(const ib_page_t*)"
"ibuf_set_free_bits_func(buf_block_t*,ulint)" -> "buf_block_get_space(const buf_block_t*)"
"ibuf_set_free_bits_func(buf_block_t*,ulint)" -> "mtr_commit(mtr_t*)"
"ibuf_set_free_bits_func(buf_block_t*,ulint)" -> "ibuf_bitmap_page_set_bits(ib_page_t*,ulint,ulint,ulint,ulint,mtr_t*)"
"ibuf_set_free_bits_func(buf_block_t*,ulint)" -> "buf_block_get_page_no(const buf_block_t*)"
"ibuf_set_free_bits_func(buf_block_t*,ulint)" -> "ibuf_bitmap_get_map_page_func(ulint,ulint,ulint,const char*,ulint,mtr_t*)"
"ibuf_set_free_bits_func(buf_block_t*,ulint)" -> "buf_block_get_zip_size(const buf_block_t*)"
"ibuf_set_free_bits_func(buf_block_t*,ulint)" -> "mtr_start(mtr_t*)"
"rec_get_n_fields(const rec_t*,const dict_index_t*)" -> "rec_get_status(const rec_t*)"
"rec_get_n_fields(const rec_t*,const dict_index_t*)" -> "rec_get_n_fields_old(const rec_t*)"
"rec_get_n_fields(const rec_t*,const dict_index_t*)" -> "ut_dbg_assertion_failed(const char*,const char*,ulint)"
"rec_get_n_fields(const rec_t*,const dict_index_t*)" -> "abort()"
"rec_get_n_fields(const rec_t*,const dict_index_t*)" -> "dict_table_is_comp(const dict_table_t*)"
"rec_get_n_fields(const rec_t*,const dict_index_t*)" -> "dict_index_get_n_fields(const dict_index_t*)"
"rec_get_n_fields(const rec_t*,const dict_index_t*)" -> "dict_index_get_n_unique_in_tree(const dict_index_t*)"
"row_upd_changes_field_size_or_external(dict_index_t*,const ulint*,const upd_t*)" -> "dfield_is_ext(const dfield_t*)"
"row_upd_changes_field_size_or_external(dict_index_t*,const ulint*,const upd_t*)" -> "rec_offs_nth_size(const ulint*,ulint)"
"row_upd_changes_field_size_or_external(dict_index_t*,const ulint*,const upd_t*)" -> "rec_offs_comp(const ulint*)"
"row_upd_changes_field_size_or_external(dict_index_t*,const ulint*,const upd_t*)" -> "rec_offs_nth_extern(const ulint*,ulint)"
"row_upd_changes_field_size_or_external(dict_index_t*,const ulint*,const upd_t*)" -> "dict_col_get_sql_null_size(const dict_col_t*,ulint)"
"row_upd_changes_field_size_or_external(dict_index_t*,const ulint*,const upd_t*)" -> "upd_get_n_fields(const upd_t*)"
"row_upd_changes_field_size_or_external(dict_index_t*,const ulint*,const upd_t*)" -> "dfield_is_null(const dfield_t*)"
"row_upd_changes_field_size_or_external(dict_index_t*,const ulint*,const upd_t*)" -> "rec_offs_nth_sql_null(const ulint*,ulint)"
"row_upd_changes_field_size_or_external(dict_index_t*,const ulint*,const upd_t*)" -> "dfield_get_len(const dfield_t*)"
"row_upd_changes_field_size_or_external(dict_index_t*,const ulint*,const upd_t*)" -> "dict_index_get_nth_col(const dict_index_t*,ulint)"
"dict_col_get_sql_null_size(const dict_col_t*,ulint)" -> "dict_col_get_fixed_size(const dict_col_t*,ulint)"
"btr_cur_update_in_place_log(ulint,const rec_t*,dict_index_t*,const upd_t*,trx_id_t,roll_ptr_t,mtr_t*)" -> "row_upd_index_write_log(const upd_t*,unsigned char*,mtr_t*)"
"btr_cur_update_in_place_log(ulint,const rec_t*,dict_index_t*,const upd_t*,trx_id_t,roll_ptr_t,mtr_t*)" -> "page_is_comp(const ib_page_t*)"
"btr_cur_update_in_place_log(ulint,const rec_t*,dict_index_t*,const upd_t*,trx_id_t,roll_ptr_t,mtr_t*)" -> "trx_write_roll_ptr(unsigned char*,roll_ptr_t)"
"btr_cur_update_in_place_log(ulint,const rec_t*,dict_index_t*,const upd_t*,trx_id_t,roll_ptr_t,mtr_t*)" -> "page_offset(const void*)"
"btr_cur_update_in_place_log(ulint,const rec_t*,dict_index_t*,const upd_t*,trx_id_t,roll_ptr_t,mtr_t*)" -> "row_upd_write_sys_vals_to_log(dict_index_t*,trx_id_t,roll_ptr_t,unsigned char*,mtr_t*)"
"btr_cur_update_in_place_log(ulint,const rec_t*,dict_index_t*,const upd_t*,trx_id_t,roll_ptr_t,mtr_t*)" -> "mach_write_compressed(unsigned char*,ulint)"
"btr_cur_update_in_place_log(ulint,const rec_t*,dict_index_t*,const upd_t*,trx_id_t,roll_ptr_t,mtr_t*)" -> "mlog_open_and_write_index(mtr_t*,const unsigned char*,const dict_index_t*,unsigned char,ulint)"
"btr_cur_update_in_place_log(ulint,const rec_t*,dict_index_t*,const upd_t*,trx_id_t,roll_ptr_t,mtr_t*)" -> "mach_ull_write_compressed(unsigned char*,ib_uint64_t)"
"btr_cur_update_in_place_log(ulint,const rec_t*,dict_index_t*,const upd_t*,trx_id_t,roll_ptr_t,mtr_t*)" -> "dict_index_is_clust(const dict_index_t*)"
"btr_cur_update_in_place_log(ulint,const rec_t*,dict_index_t*,const upd_t*,trx_id_t,roll_ptr_t,mtr_t*)" -> "mach_write_to_1(unsigned char*,ulint)"
"btr_cur_update_in_place_log(ulint,const rec_t*,dict_index_t*,const upd_t*,trx_id_t,roll_ptr_t,mtr_t*)" -> "page_align(const void*)"
"btr_cur_update_in_place_log(ulint,const rec_t*,dict_index_t*,const upd_t*,trx_id_t,roll_ptr_t,mtr_t*)" -> "mach_write_to_2(unsigned char*,ulint)"
"row_upd_index_write_log(const upd_t*,unsigned char*,mtr_t*)" -> "dfield_get_len(const dfield_t*)"
"row_upd_index_write_log(const upd_t*,unsigned char*,mtr_t*)" -> "memcpy(void*,const void*,size_t)"
"row_upd_index_write_log(const upd_t*,unsigned char*,mtr_t*)" -> "mlog_catenate_string(mtr_t*,const unsigned char*,ulint)"
"row_upd_index_write_log(const upd_t*,unsigned char*,mtr_t*)" -> "mach_write_compressed(unsigned char*,ulint)"
"row_upd_index_write_log(const upd_t*,unsigned char*,mtr_t*)" -> "mach_write_to_1(unsigned char*,ulint)"
"row_upd_index_write_log(const upd_t*,unsigned char*,mtr_t*)" -> "mlog_close(mtr_t*,unsigned char*)"
"row_upd_index_write_log(const upd_t*,unsigned char*,mtr_t*)" -> "mlog_open(mtr_t*,ulint)"
"row_upd_index_write_log(const upd_t*,unsigned char*,mtr_t*)" -> "upd_get_n_fields(const upd_t*)"
"trx_write_roll_ptr(unsigned char*,roll_ptr_t)" -> "mach_write_to_7(unsigned char*,ib_uint64_t)"
"mach_write_to_7(unsigned char*,ib_uint64_t)" -> "mach_write_to_3(unsigned char*,ulint)"
"mach_write_to_7(unsigned char*,ib_uint64_t)" -> "mach_write_to_4(unsigned char*,ulint)"
"row_upd_write_sys_vals_to_log(dict_index_t*,trx_id_t,roll_ptr_t,unsigned char*,mtr_t*)" -> "dict_index_get_sys_col_pos(const dict_index_t*,ulint)"
"row_upd_write_sys_vals_to_log(dict_index_t*,trx_id_t,roll_ptr_t,unsigned char*,mtr_t*)" -> "trx_write_roll_ptr(unsigned char*,roll_ptr_t)"
"row_upd_write_sys_vals_to_log(dict_index_t*,trx_id_t,roll_ptr_t,unsigned char*,mtr_t*)" -> "mach_ull_write_compressed(unsigned char*,ib_uint64_t)"
"row_upd_write_sys_vals_to_log(dict_index_t*,trx_id_t,roll_ptr_t,unsigned char*,mtr_t*)" -> "mach_write_compressed(unsigned char*,ulint)"
"fil_decr_pending_ops(ulint)" -> "fprintf(FILE*,const char*,...)"
"fil_decr_pending_ops(ulint)" -> "pfs_mutex_enter_func(ib_mutex_t*,const char*,ulint)"
"fil_decr_pending_ops(ulint)" -> "pfs_mutex_exit_func(ib_mutex_t*)"
"fil_decr_pending_ops(ulint)" -> "fil_space_get_by_id(ulint)"
"ibuf_index_page_calc_free(ulint,const buf_block_t*)" -> "ibuf_index_page_calc_free_bits(ulint,ulint)"
"ibuf_index_page_calc_free(ulint,const buf_block_t*)" -> "ibuf_index_page_calc_free_zip(ulint,const buf_block_t*)"
"ibuf_index_page_calc_free(ulint,const buf_block_t*)" -> "page_get_max_insert_size_after_reorganize(const ib_page_t*,ulint)"
"ibuf_index_page_calc_free_zip(ulint,const buf_block_t*)" -> "page_zip_max_ins_size(const page_zip_des_t*,ulint)"
"ibuf_index_page_calc_free_zip(ulint,const buf_block_t*)" -> "ibuf_index_page_calc_free_bits(ulint,ulint)"
"ibuf_index_page_calc_free_zip(ulint,const buf_block_t*)" -> "page_get_max_insert_size(const ib_page_t*,ulint)"
"page_zip_max_ins_size(const page_zip_des_t*,ulint)" -> "page_zip_get_size(const page_zip_des_t*)"
"page_zip_max_ins_size(const page_zip_des_t*,ulint)" -> "page_zip_get_trailer_len(const page_zip_des_t*,ulint)"
"ibuf_delete(const dtuple_t*,buf_block_t*,dict_index_t*,mtr_t*)" -> "rec_offs_set_n_alloc(ulint*,ulint)"
"ibuf_delete(const dtuple_t*,buf_block_t*,dict_index_t*,mtr_t*)" -> "dtuple_print(FILE*,const dtuple_t*)"
"ibuf_delete(const dtuple_t*,buf_block_t*,dict_index_t*,mtr_t*)" -> "ibuf_update_free_bits_low(const buf_block_t*,ulint,mtr_t*)"
"ibuf_delete(const dtuple_t*,buf_block_t*,dict_index_t*,mtr_t*)" -> "ut_print_timestamp(FILE*)"
"ibuf_delete(const dtuple_t*,buf_block_t*,dict_index_t*,mtr_t*)" -> "mem_heap_free_func(mem_heap_t*,const char*,ulint)"
"ibuf_delete(const dtuple_t*,buf_block_t*,dict_index_t*,mtr_t*)" -> "rec_get_offsets_func(const rec_t*,const dict_index_t*,ulint*,ulint,mem_heap_t**)"
"ibuf_delete(const dtuple_t*,buf_block_t*,dict_index_t*,mtr_t*)" -> "fprintf(FILE*,const char*,...)"
"ibuf_delete(const dtuple_t*,buf_block_t*,dict_index_t*,mtr_t*)" -> "rec_get_info_bits(const rec_t*,ulint)"
"ibuf_delete(const dtuple_t*,buf_block_t*,dict_index_t*,mtr_t*)" -> "__builtin_fwrite(const void*,size_t,size_t,FILE*)"
"ibuf_delete(const dtuple_t*,buf_block_t*,dict_index_t*,mtr_t*)" -> "dtuple_get_n_fields(const dtuple_t*)"
"ibuf_delete(const dtuple_t*,buf_block_t*,dict_index_t*,mtr_t*)" -> "lock_update_delete(const buf_block_t*,const rec_t*)"
"ibuf_delete(const dtuple_t*,buf_block_t*,dict_index_t*,mtr_t*)" -> "buf_block_get_page_no(const buf_block_t*)"
"ibuf_delete(const dtuple_t*,buf_block_t*,dict_index_t*,mtr_t*)" -> "page_get_n_recs(const ib_page_t*)"
"ibuf_delete(const dtuple_t*,buf_block_t*,dict_index_t*,mtr_t*)" -> "buf_block_get_space(const buf_block_t*)"
"ibuf_delete(const dtuple_t*,buf_block_t*,dict_index_t*,mtr_t*)" -> "btr_page_get_index_id(const ib_page_t*)"
"ibuf_delete(const dtuple_t*,buf_block_t*,dict_index_t*,mtr_t*)" -> "ibuf_update_free_bits_zip(buf_block_t*,mtr_t*)"
"ibuf_delete(const dtuple_t*,buf_block_t*,dict_index_t*,mtr_t*)" -> "page_cur_search(const buf_block_t*,const dict_index_t*,const dtuple_t*,ulint,page_cur_t*)"
"ibuf_delete(const dtuple_t*,buf_block_t*,dict_index_t*,mtr_t*)" -> "page_get_max_insert_size_after_reorganize(const ib_page_t*,ulint)"
"ibuf_delete(const dtuple_t*,buf_block_t*,dict_index_t*,mtr_t*)" -> "page_is_comp(const ib_page_t*)"
"ibuf_delete(const dtuple_t*,buf_block_t*,dict_index_t*,mtr_t*)" -> "page_cur_delete_rec(page_cur_t*,const dict_index_t*,const ulint*,mtr_t*)"
"ibuf_delete(const dtuple_t*,buf_block_t*,dict_index_t*,mtr_t*)" -> "__builtin_expect(long int,long int)"
"ibuf_delete(const dtuple_t*,buf_block_t*,dict_index_t*,mtr_t*)" -> "rec_print_new(FILE*,const rec_t*,const ulint*)"
"ibuf_update_free_bits_low(const buf_block_t*,ulint,mtr_t*)" -> "__builtin_expect(long int,long int)"
"ibuf_update_free_bits_low(const buf_block_t*,ulint,mtr_t*)" -> "ibuf_set_free_bits_low(ulint,const buf_block_t*,ulint,mtr_t*)"
"ibuf_update_free_bits_low(const buf_block_t*,ulint,mtr_t*)" -> "ibuf_index_page_calc_free_bits(ulint,ulint)"
"ibuf_update_free_bits_low(const buf_block_t*,ulint,mtr_t*)" -> "ibuf_index_page_calc_free(ulint,const buf_block_t*)"
"ibuf_update_free_bits_low(const buf_block_t*,ulint,mtr_t*)" -> "ut_dbg_assertion_failed(const char*,const char*,ulint)"
"ibuf_update_free_bits_low(const buf_block_t*,ulint,mtr_t*)" -> "abort()"
"ibuf_set_free_bits_low(ulint,const buf_block_t*,ulint,mtr_t*)" -> "buf_block_get_page_no(const buf_block_t*)"
"ibuf_set_free_bits_low(ulint,const buf_block_t*,ulint,mtr_t*)" -> "ibuf_bitmap_page_set_bits(ib_page_t*,ulint,ulint,ulint,ulint,mtr_t*)"
"ibuf_set_free_bits_low(ulint,const buf_block_t*,ulint,mtr_t*)" -> "ibuf_bitmap_get_map_page_func(ulint,ulint,ulint,const char*,ulint,mtr_t*)"
"ibuf_set_free_bits_low(ulint,const buf_block_t*,ulint,mtr_t*)" -> "buf_block_get_space(const buf_block_t*)"
"ibuf_set_free_bits_low(ulint,const buf_block_t*,ulint,mtr_t*)" -> "page_is_leaf(const ib_page_t*)"
"lock_update_delete(const buf_block_t*,const rec_t*)" -> "pfs_mutex_exit_func(ib_mutex_t*)"
"lock_update_delete(const buf_block_t*,const rec_t*)" -> "rec_get_heap_no_old(const rec_t*)"
"lock_update_delete(const buf_block_t*,const rec_t*)" -> "page_is_comp(const ib_page_t*)"
"lock_update_delete(const buf_block_t*,const rec_t*)" -> "rec_get_heap_no_new(const rec_t*)"
"lock_update_delete(const buf_block_t*,const rec_t*)" -> "lock_rec_inherit_to_gap(const buf_block_t*,const buf_block_t*,ulint,ulint)"
"lock_update_delete(const buf_block_t*,const rec_t*)" -> "rec_get_next_offs(const rec_t*,ulint)"
"lock_update_delete(const buf_block_t*,const rec_t*)" -> "pfs_mutex_enter_func(ib_mutex_t*,const char*,ulint)"
"lock_update_delete(const buf_block_t*,const rec_t*)" -> "lock_rec_reset_and_release_wait(const buf_block_t*,ulint)"
"lock_rec_inherit_to_gap(const buf_block_t*,const buf_block_t*,ulint,ulint)" -> "lock_rec_get_insert_intention(const ib_lock_t*)"
"lock_rec_inherit_to_gap(const buf_block_t*,const buf_block_t*,ulint,ulint)" -> "lock_rec_get_next(ulint,ib_lock_t*)"
"lock_rec_inherit_to_gap(const buf_block_t*,const buf_block_t*,ulint,ulint)" -> "lock_rec_add_to_queue(ulint,const buf_block_t*,ulint,dict_index_t*,trx_t*,ulint)"
"lock_rec_inherit_to_gap(const buf_block_t*,const buf_block_t*,ulint,ulint)" -> "lock_rec_get_first(const buf_block_t*,ulint)"
"lock_rec_inherit_to_gap(const buf_block_t*,const buf_block_t*,ulint,ulint)" -> "lock_get_mode(const ib_lock_t*)"
"lock_rec_reset_and_release_wait(const buf_block_t*,ulint)" -> "lock_rec_get_first(const buf_block_t*,ulint)"
"lock_rec_reset_and_release_wait(const buf_block_t*,ulint)" -> "lock_rec_get_next(ulint,ib_lock_t*)"
"lock_rec_reset_and_release_wait(const buf_block_t*,ulint)" -> "lock_get_wait(const ib_lock_t*)"
"lock_rec_reset_and_release_wait(const buf_block_t*,ulint)" -> "lock_rec_reset_nth_bit(ib_lock_t*,ulint)"
"lock_rec_reset_and_release_wait(const buf_block_t*,ulint)" -> "lock_rec_cancel(ib_lock_t*)"
"lock_rec_cancel(ib_lock_t*)" -> "pfs_mutex_exit_func(ib_mutex_t*)"
"lock_rec_cancel(ib_lock_t*)" -> "pfs_mutex_enter_func(ib_mutex_t*,const char*,ulint)"
"lock_rec_cancel(ib_lock_t*)" -> "lock_rec_find_set_bit(const ib_lock_t*)"
"lock_rec_cancel(ib_lock_t*)" -> "lock_wait_release_thread_if_suspended(que_thr_t*)"
"lock_rec_cancel(ib_lock_t*)" -> "lock_reset_lock_and_trx_wait(ib_lock_t*)"
"lock_rec_cancel(ib_lock_t*)" -> "lock_rec_reset_nth_bit(ib_lock_t*,ulint)"
"lock_rec_cancel(ib_lock_t*)" -> "que_thr_end_lock_wait(trx_t*)"
"ibuf_update_free_bits_zip(buf_block_t*,mtr_t*)" -> "ut_dbg_assertion_failed(const char*,const char*,ulint)"
"ibuf_update_free_bits_zip(buf_block_t*,mtr_t*)" -> "abort()"
"ibuf_update_free_bits_zip(buf_block_t*,mtr_t*)" -> "page_is_leaf(const ib_page_t*)"
"ibuf_update_free_bits_zip(buf_block_t*,mtr_t*)" -> "buf_block_get_page_no(const buf_block_t*)"
"ibuf_update_free_bits_zip(buf_block_t*,mtr_t*)" -> "buf_page_make_young(buf_page_t*)"
"ibuf_update_free_bits_zip(buf_block_t*,mtr_t*)" -> "__builtin_expect(long int,long int)"
"ibuf_update_free_bits_zip(buf_block_t*,mtr_t*)" -> "buf_block_get_zip_size(const buf_block_t*)"
"ibuf_update_free_bits_zip(buf_block_t*,mtr_t*)" -> "buf_block_get_space(const buf_block_t*)"
"ibuf_update_free_bits_zip(buf_block_t*,mtr_t*)" -> "ibuf_bitmap_page_set_bits(ib_page_t*,ulint,ulint,ulint,ulint,mtr_t*)"
"ibuf_update_free_bits_zip(buf_block_t*,mtr_t*)" -> "ibuf_index_page_calc_free_zip(ulint,const buf_block_t*)"
"ibuf_update_free_bits_zip(buf_block_t*,mtr_t*)" -> "ibuf_bitmap_get_map_page_func(ulint,ulint,ulint,const char*,ulint,mtr_t*)"
"rec_print_new(FILE*,const rec_t*,const ulint*)" -> "rec_print_old(FILE*,const rec_t*)"
"rec_print_new(FILE*,const rec_t*,const ulint*)" -> "rec_validate(const rec_t*,const ulint*)"
"rec_print_new(FILE*,const rec_t*,const ulint*)" -> "fprintf(FILE*,const char*,...)"
"rec_print_new(FILE*,const rec_t*,const ulint*)" -> "rec_offs_n_fields(const ulint*)"
"rec_print_new(FILE*,const rec_t*,const ulint*)" -> "rec_print_comp(FILE*,const rec_t*,const ulint*)"
"rec_print_new(FILE*,const rec_t*,const ulint*)" -> "rec_offs_comp(const ulint*)"
"rec_print_new(FILE*,const rec_t*,const ulint*)" -> "rec_get_info_bits(const rec_t*,ulint)"
"rec_validate(const rec_t*,const ulint*)" -> "__builtin_expect(long int,long int)"
"rec_validate(const rec_t*,const ulint*)" -> "rec_offs_n_fields(const ulint*)"
"rec_validate(const rec_t*,const ulint*)" -> "rec_get_nth_field_offs(const ulint*,ulint,ulint*)"
"rec_validate(const rec_t*,const ulint*)" -> "abort()"
"rec_validate(const rec_t*,const ulint*)" -> "rec_offs_comp(const ulint*)"
"rec_validate(const rec_t*,const ulint*)" -> "fprintf(FILE*,const char*,...)"
"rec_validate(const rec_t*,const ulint*)" -> "rec_get_n_fields_old(const rec_t*)"
"rec_validate(const rec_t*,const ulint*)" -> "rec_validate_old(const rec_t*)"
"rec_validate(const rec_t*,const ulint*)" -> "rec_get_nth_field_size(const rec_t*,ulint)"
"rec_validate(const rec_t*,const ulint*)" -> "ut_dbg_assertion_failed(const char*,const char*,ulint)"
"rec_validate(const rec_t*,const ulint*)" -> "rec_offs_data_size(const ulint*)"
"rec_print_comp(FILE*,const rec_t*,const ulint*)" -> "__builtin_fwrite(const void*,size_t,size_t,FILE*)"
"rec_print_comp(FILE*,const rec_t*,const ulint*)" -> "rec_offs_n_fields(const ulint*)"
"rec_print_comp(FILE*,const rec_t*,const ulint*)" -> "rec_get_nth_field_offs(const ulint*,ulint,ulint*)"
"rec_print_comp(FILE*,const rec_t*,const ulint*)" -> "ut_print_buf(FILE*,const void*,ulint)"
"rec_print_comp(FILE*,const rec_t*,const ulint*)" -> "fprintf(FILE*,const char*,...)"
"rec_print_comp(FILE*,const rec_t*,const ulint*)" -> "_IO_putc(int,_IO_FILE*)"
"rec_print_comp(FILE*,const rec_t*,const ulint*)" -> "rec_offs_nth_extern(const ulint*,ulint)"
"ibuf_restore_pos(ulint,ulint,const dtuple_t*,ulint,btr_pcur_t*,mtr_t*)" -> "btr_pcur_restore_position_func(ulint,btr_pcur_t*,const char*,ulint,mtr_t*)"
"ibuf_restore_pos(ulint,ulint,const dtuple_t*,ulint,btr_pcur_t*,mtr_t*)" -> "rec_print_old(FILE*,const rec_t*)"
"ibuf_restore_pos(ulint,ulint,const dtuple_t*,ulint,btr_pcur_t*,mtr_t*)" -> "ibuf_btr_pcur_commit_specify_mtr(btr_pcur_t*,mtr_t*)"
"ibuf_restore_pos(ulint,ulint,const dtuple_t*,ulint,btr_pcur_t*,mtr_t*)" -> "page_rec_get_next(rec_t*)"
"ibuf_restore_pos(ulint,ulint,const dtuple_t*,ulint,btr_pcur_t*,mtr_t*)" -> "dtuple_print(FILE*,const dtuple_t*)"
"ibuf_restore_pos(ulint,ulint,const dtuple_t*,ulint,btr_pcur_t*,mtr_t*)" -> "fil_space_get_flags(ulint)"
"ibuf_restore_pos(ulint,ulint,const dtuple_t*,ulint,btr_pcur_t*,mtr_t*)" -> "fflush(FILE*)"
"ibuf_restore_pos(ulint,ulint,const dtuple_t*,ulint,btr_pcur_t*,mtr_t*)" -> "fprintf(FILE*,const char*,...)"
"ibuf_btr_pcur_commit_specify_mtr(btr_pcur_t*,mtr_t*)" -> "btr_pcur_commit_specify_mtr(btr_pcur_t*,mtr_t*)"
"btr_pcur_commit_specify_mtr(btr_pcur_t*,mtr_t*)" -> "mtr_commit(mtr_t*)"
"rw_lock_x_lock_move_ownership(rw_lock_t*)" -> "rw_lock_set_writer_id_and_recursion_flag(rw_lock_t*,ulint)"
"fil_inc_pending_ops(ulint)" -> "pfs_mutex_exit_func(ib_mutex_t*)"
"fil_inc_pending_ops(ulint)" -> "fprintf(FILE*,const char*,...)"
"fil_inc_pending_ops(ulint)" -> "fil_space_get_by_id(ulint)"
"fil_inc_pending_ops(ulint)" -> "pfs_mutex_enter_func(ib_mutex_t*,const char*,ulint)"
"ibuf_rec_get_op_type_func(const rec_t*)" -> "ibuf_rec_get_info_func(const rec_t*,ibuf_op_t*,ulint*,ulint*,ulint*)"
"ibuf_rec_get_op_type_func(const rec_t*)" -> "rec_get_nth_field_offs_old(const rec_t*,ulint,ulint*)"
"ibuf_search_tuple_build(ulint,ulint,mem_heap_t*)" -> "dtuple_set_types_binary(dtuple_t*,ulint)"
"ibuf_search_tuple_build(ulint,ulint,mem_heap_t*)" -> "dtuple_create(mem_heap_t*,ulint)"
"ibuf_search_tuple_build(ulint,ulint,mem_heap_t*)" -> "dfield_set_data(dfield_t*,const void*,ulint)"
"ibuf_search_tuple_build(ulint,ulint,mem_heap_t*)" -> "mach_write_to_1(unsigned char*,ulint)"
"ibuf_search_tuple_build(ulint,ulint,mem_heap_t*)" -> "mach_write_to_4(unsigned char*,ulint)"
"ibuf_search_tuple_build(ulint,ulint,mem_heap_t*)" -> "mem_heap_alloc(mem_heap_t*,ulint)"
"btr_pcur_open_on_user_rec_func(dict_index_t*,const dtuple_t*,ulint,ulint,btr_pcur_t*,const char*,ulint,mtr_t*)" -> "btr_pcur_open_low(dict_index_t*,ulint,const dtuple_t*,ulint,ulint,btr_pcur_t*,const char*,ulint,mtr_t*)"
"btr_pcur_open_on_user_rec_func(dict_index_t*,const dtuple_t*,ulint,ulint,btr_pcur_t*,const char*,ulint,mtr_t*)" -> "abort()"
"btr_pcur_open_on_user_rec_func(dict_index_t*,const dtuple_t*,ulint,ulint,btr_pcur_t*,const char*,ulint,mtr_t*)" -> "btr_pcur_move_to_next_user_rec(btr_pcur_t*,mtr_t*)"
"btr_pcur_open_on_user_rec_func(dict_index_t*,const dtuple_t*,ulint,ulint,btr_pcur_t*,const char*,ulint,mtr_t*)" -> "ut_dbg_assertion_failed(const char*,const char*,ulint)"
"btr_pcur_open_on_user_rec_func(dict_index_t*,const dtuple_t*,ulint,ulint,btr_pcur_t*,const char*,ulint,mtr_t*)" -> "btr_pcur_is_after_last_on_page(const btr_pcur_t*)"
"ibuf_delete_rec(ulint,ulint,btr_pcur_t*,const dtuple_t*,mtr_t*)" -> "ibuf_btr_pcur_commit_specify_mtr(btr_pcur_t*,mtr_t*)"
"ibuf_delete_rec(ulint,ulint,btr_pcur_t*,const dtuple_t*,mtr_t*)" -> "ut_dbg_assertion_failed(const char*,const char*,ulint)"
"ibuf_delete_rec(ulint,ulint,btr_pcur_t*,const dtuple_t*,mtr_t*)" -> "btr_cur_optimistic_delete_func(btr_cur_t*,mtr_t*)"
"ibuf_delete_rec(ulint,ulint,btr_pcur_t*,const dtuple_t*,mtr_t*)" -> "abort()"
"ibuf_delete_rec(ulint,ulint,btr_pcur_t*,const dtuple_t*,mtr_t*)" -> "pfs_mutex_exit_func(ib_mutex_t*)"
"ibuf_delete_rec(ulint,ulint,btr_pcur_t*,const dtuple_t*,mtr_t*)" -> "btr_cur_set_deleted_flag_for_ibuf(rec_t*,page_zip_des_t*,ulint,mtr_t*)"
"ibuf_delete_rec(ulint,ulint,btr_pcur_t*,const dtuple_t*,mtr_t*)" -> "btr_pcur_store_position(btr_pcur_t*,mtr_t*)"
"ibuf_delete_rec(ulint,ulint,btr_pcur_t*,const dtuple_t*,mtr_t*)" -> "btr_pcur_close(btr_pcur_t*)"
"ibuf_delete_rec(ulint,ulint,btr_pcur_t*,const dtuple_t*,mtr_t*)" -> "ibuf_tree_root_get(mtr_t*)"
"ibuf_delete_rec(ulint,ulint,btr_pcur_t*,const dtuple_t*,mtr_t*)" -> "btr_cur_pessimistic_delete(dberr_t*,ulint,btr_cur_t*,ulint,trx_rb_ctx,mtr_t*)"
"ibuf_delete_rec(ulint,ulint,btr_pcur_t*,const dtuple_t*,mtr_t*)" -> "ibuf_mtr_start(mtr_t*)"
"ibuf_delete_rec(ulint,ulint,btr_pcur_t*,const dtuple_t*,mtr_t*)" -> "__builtin_expect(long int,long int)"
"ibuf_delete_rec(ulint,ulint,btr_pcur_t*,const dtuple_t*,mtr_t*)" -> "ibuf_size_update(const ib_page_t*,mtr_t*)"
"ibuf_delete_rec(ulint,ulint,btr_pcur_t*,const dtuple_t*,mtr_t*)" -> "ibuf_restore_pos(ulint,ulint,const dtuple_t*,ulint,btr_pcur_t*,mtr_t*)"
"ibuf_delete_rec(ulint,ulint,btr_pcur_t*,const dtuple_t*,mtr_t*)" -> "page_is_empty(const ib_page_t*)"
"ibuf_delete_rec(ulint,ulint,btr_pcur_t*,const dtuple_t*,mtr_t*)" -> "pfs_mutex_enter_func(ib_mutex_t*,const char*,ulint)"
"btr_cur_optimistic_delete_func(btr_cur_t*,mtr_t*)" -> "page_is_leaf(const ib_page_t*)"
"btr_cur_optimistic_delete_func(btr_cur_t*,mtr_t*)" -> "rec_get_offsets_func(const rec_t*,const dict_index_t*,ulint*,ulint,mem_heap_t**)"
"btr_cur_optimistic_delete_func(btr_cur_t*,mtr_t*)" -> "page_cur_delete_rec(page_cur_t*,const dict_index_t*,const ulint*,mtr_t*)"
"btr_cur_optimistic_delete_func(btr_cur_t*,mtr_t*)" -> "rec_offs_size(const ulint*)"
"btr_cur_optimistic_delete_func(btr_cur_t*,mtr_t*)" -> "lock_update_delete(const buf_block_t*,const rec_t*)"
"btr_cur_optimistic_delete_func(btr_cur_t*,mtr_t*)" -> "dict_index_is_ibuf(const dict_index_t*)"
"btr_cur_optimistic_delete_func(btr_cur_t*,mtr_t*)" -> "ibuf_update_free_bits_low(const buf_block_t*,ulint,mtr_t*)"
"btr_cur_optimistic_delete_func(btr_cur_t*,mtr_t*)" -> "page_get_max_insert_size_after_reorganize(const ib_page_t*,ulint)"
"btr_cur_optimistic_delete_func(btr_cur_t*,mtr_t*)" -> "dict_index_is_clust(const dict_index_t*)"
"btr_cur_optimistic_delete_func(btr_cur_t*,mtr_t*)" -> "mem_heap_free_func(mem_heap_t*,const char*,ulint)"
"btr_cur_optimistic_delete_func(btr_cur_t*,mtr_t*)" -> "__builtin_expect(long int,long int)"
"btr_cur_optimistic_delete_func(btr_cur_t*,mtr_t*)" -> "btr_cur_can_delete_without_compress(btr_cur_t*,ulint,mtr_t*)"
"btr_cur_optimistic_delete_func(btr_cur_t*,mtr_t*)" -> "rec_offs_any_extern(const ulint*)"
"btr_cur_optimistic_delete_func(btr_cur_t*,mtr_t*)" -> "btr_search_update_hash_on_delete(btr_cur_t*)"
"btr_cur_optimistic_delete_func(btr_cur_t*,mtr_t*)" -> "rec_offs_set_n_alloc(ulint*,ulint)"
"btr_cur_can_delete_without_compress(btr_cur_t*,ulint,mtr_t*)" -> "page_get_n_recs(const ib_page_t*)"
"btr_cur_can_delete_without_compress(btr_cur_t*,ulint,mtr_t*)" -> "btr_page_get_next(const ib_page_t*,mtr_t*)"
"btr_cur_can_delete_without_compress(btr_cur_t*,ulint,mtr_t*)" -> "dict_index_get_page(const dict_index_t*)"
"btr_cur_can_delete_without_compress(btr_cur_t*,ulint,mtr_t*)" -> "btr_cur_get_page(btr_cur_t*)"
"btr_cur_can_delete_without_compress(btr_cur_t*,ulint,mtr_t*)" -> "page_get_page_no(const ib_page_t*)"
"btr_cur_can_delete_without_compress(btr_cur_t*,ulint,mtr_t*)" -> "page_get_data_size(const ib_page_t*)"
"btr_cur_can_delete_without_compress(btr_cur_t*,ulint,mtr_t*)" -> "btr_page_get_prev(const ib_page_t*,mtr_t*)"
"btr_cur_get_page(btr_cur_t*)" -> "page_align(const void*)"
"btr_search_update_hash_on_delete(btr_cur_t*)" -> "rec_offs_set_n_alloc(ulint*,ulint)"
"btr_search_update_hash_on_delete(btr_cur_t*)" -> "ut_dbg_assertion_failed(const char*,const char*,ulint)"
"btr_search_update_hash_on_delete(btr_cur_t*)" -> "abort()"
"btr_search_update_hash_on_delete(btr_cur_t*)" -> "pfs_rw_lock_x_lock_func(rw_lock_t*,ulint,const char*,ulint)"
"btr_search_update_hash_on_delete(btr_cur_t*)" -> "__builtin_expect(long int,long int)"
"btr_search_update_hash_on_delete(btr_cur_t*)" -> "pfs_rw_lock_x_unlock_func(rw_lock_t*)"
"btr_search_update_hash_on_delete(btr_cur_t*)" -> "ha_search_and_delete_if_found(hash_table_t*,ulint,const rec_t*)"
"btr_search_update_hash_on_delete(btr_cur_t*)" -> "dict_index_is_ibuf(const dict_index_t*)"
"btr_search_update_hash_on_delete(btr_cur_t*)" -> "rec_get_offsets_func(const rec_t*,const dict_index_t*,ulint*,ulint,mem_heap_t**)"
"btr_search_update_hash_on_delete(btr_cur_t*)" -> "mem_heap_free_func(mem_heap_t*,const char*,ulint)"
"btr_search_update_hash_on_delete(btr_cur_t*)" -> "rec_fold(const rec_t*,const ulint*,ulint,ulint,index_id_t)"
"ha_search_and_delete_if_found(hash_table_t*,ulint,const rec_t*)" -> "ha_delete_hash_node(hash_table_t*,ha_node_t*)"
"ha_search_and_delete_if_found(hash_table_t*,ulint,const rec_t*)" -> "ha_search_with_data(hash_table_t*,ulint,const rec_t*)"
"ha_search_with_data(hash_table_t*,ulint,const rec_t*)" -> "ha_chain_get_next(ha_node_t*)"
"ha_search_with_data(hash_table_t*,ulint,const rec_t*)" -> "ha_chain_get_first(hash_table_t*,ulint)"
"btr_cur_pessimistic_delete(dberr_t*,ulint,btr_cur_t*,ulint,trx_rb_ctx,mtr_t*)" -> "fil_space_release_free_extents(ulint,ulint)"
"btr_cur_pessimistic_delete(dberr_t*,ulint,btr_cur_t*,ulint,trx_rb_ctx,mtr_t*)" -> "btr_page_get_level_low(const ib_page_t*)"
"btr_cur_pessimistic_delete(dberr_t*,ulint,btr_cur_t*,ulint,trx_rb_ctx,mtr_t*)" -> "dict_index_get_page(const dict_index_t*)"
"btr_cur_pessimistic_delete(dberr_t*,ulint,btr_cur_t*,ulint,trx_rb_ctx,mtr_t*)" -> "fsp_reserve_free_extents(ulint*,ulint,ulint,ulint,mtr_t*)"
"btr_cur_pessimistic_delete(dberr_t*,ulint,btr_cur_t*,ulint,trx_rb_ctx,mtr_t*)" -> "btr_cur_compress_if_useful(btr_cur_t*,ulint,mtr_t*)"
"btr_cur_pessimistic_delete(dberr_t*,ulint,btr_cur_t*,ulint,trx_rb_ctx,mtr_t*)" -> "btr_rec_free_externally_stored_fields(dict_index_t*,rec_t*,const ulint*,page_zip_des_t*,trx_rb_ctx,mtr_t*)"
"btr_cur_pessimistic_delete(dberr_t*,ulint,btr_cur_t*,ulint,trx_rb_ctx,mtr_t*)" -> "btr_insert_on_non_leaf_level_func(ulint,dict_index_t*,ulint,dtuple_t*,const char*,ulint,mtr_t*)"
"btr_cur_pessimistic_delete(dberr_t*,ulint,btr_cur_t*,ulint,trx_rb_ctx,mtr_t*)" -> "mem_heap_create_func(ulint,ulint)"
"btr_cur_pessimistic_delete(dberr_t*,ulint,btr_cur_t*,ulint,trx_rb_ctx,mtr_t*)" -> "mem_heap_free_func(mem_heap_t*,const char*,ulint)"
"btr_cur_pessimistic_delete(dberr_t*,ulint,btr_cur_t*,ulint,trx_rb_ctx,mtr_t*)" -> "page_rec_get_next(rec_t*)"
"btr_cur_pessimistic_delete(dberr_t*,ulint,btr_cur_t*,ulint,trx_rb_ctx,mtr_t*)" -> "btr_node_ptr_delete(dict_index_t*,buf_block_t*,mtr_t*)"
"btr_cur_pessimistic_delete(dberr_t*,ulint,btr_cur_t*,ulint,trx_rb_ctx,mtr_t*)" -> "btr_discard_page(btr_cur_t*,mtr_t*)"
"btr_cur_pessimistic_delete(dberr_t*,ulint,btr_cur_t*,ulint,trx_rb_ctx,mtr_t*)" -> "__builtin_expect(long int,long int)"
"btr_cur_pessimistic_delete(dberr_t*,ulint,btr_cur_t*,ulint,trx_rb_ctx,mtr_t*)" -> "dict_index_build_node_ptr(const dict_index_t*,const rec_t*,ulint,mem_heap_t*,ulint)"
"btr_cur_pessimistic_delete(dberr_t*,ulint,btr_cur_t*,ulint,trx_rb_ctx,mtr_t*)" -> "btr_set_min_rec_mark(rec_t*,mtr_t*)"
"btr_cur_pessimistic_delete(dberr_t*,ulint,btr_cur_t*,ulint,trx_rb_ctx,mtr_t*)" -> "lock_update_delete(const buf_block_t*,const rec_t*)"
"btr_cur_pessimistic_delete(dberr_t*,ulint,btr_cur_t*,ulint,trx_rb_ctx,mtr_t*)" -> "page_get_n_recs(const ib_page_t*)"
"btr_cur_pessimistic_delete(dberr_t*,ulint,btr_cur_t*,ulint,trx_rb_ctx,mtr_t*)" -> "rec_offs_any_extern(const ulint*)"
"btr_cur_pessimistic_delete(dberr_t*,ulint,btr_cur_t*,ulint,trx_rb_ctx,mtr_t*)" -> "rec_get_offsets_func(const rec_t*,const dict_index_t*,ulint*,ulint,mem_heap_t**)"
"btr_cur_pessimistic_delete(dberr_t*,ulint,btr_cur_t*,ulint,trx_rb_ctx,mtr_t*)" -> "btr_search_update_hash_on_delete(btr_cur_t*)"
"btr_cur_pessimistic_delete(dberr_t*,ulint,btr_cur_t*,ulint,trx_rb_ctx,mtr_t*)" -> "btr_page_get_prev(const ib_page_t*,mtr_t*)"
"btr_cur_pessimistic_delete(dberr_t*,ulint,btr_cur_t*,ulint,trx_rb_ctx,mtr_t*)" -> "page_cur_delete_rec(page_cur_t*,const dict_index_t*,const ulint*,mtr_t*)"
"btr_cur_pessimistic_delete(dberr_t*,ulint,btr_cur_t*,ulint,trx_rb_ctx,mtr_t*)" -> "page_get_infimum_offset(const ib_page_t*)"
"btr_cur_pessimistic_delete(dberr_t*,ulint,btr_cur_t*,ulint,trx_rb_ctx,mtr_t*)" -> "buf_block_get_page_no(const buf_block_t*)"
"fil_space_release_free_extents(ulint,ulint)" -> "pfs_mutex_enter_func(ib_mutex_t*,const char*,ulint)"
"fil_space_release_free_extents(ulint,ulint)" -> "fil_space_get_by_id(ulint)"
"fil_space_release_free_extents(ulint,ulint)" -> "ut_dbg_assertion_failed(const char*,const char*,ulint)"
"fil_space_release_free_extents(ulint,ulint)" -> "__builtin_expect(long int,long int)"
"fil_space_release_free_extents(ulint,ulint)" -> "pfs_mutex_exit_func(ib_mutex_t*)"
"fil_space_release_free_extents(ulint,ulint)" -> "abort()"
"fsp_reserve_free_extents(ulint*,ulint,ulint,ulint,mtr_t*)" -> "fsp_get_space_header(ulint,ulint,mtr_t*)"
"fsp_reserve_free_extents(ulint*,ulint,ulint,ulint,mtr_t*)" -> "mtr_read_ulint(const unsigned char*,ulint,mtr_t*)"
"fsp_reserve_free_extents(ulint*,ulint,ulint,ulint,mtr_t*)" -> "mtr_x_lock_func(rw_lock_t*,const char*,ulint,mtr_t*)"
"fsp_reserve_free_extents(ulint*,ulint,ulint,ulint,mtr_t*)" -> "fsp_reserve_free_pages(ulint,fsp_header_t*,ulint,mtr_t*)"
"fsp_reserve_free_extents(ulint*,ulint,ulint,ulint,mtr_t*)" -> "abort()"
"fsp_reserve_free_extents(ulint*,ulint,ulint,ulint,mtr_t*)" -> "fsp_try_extend_data_file(ulint*,ulint,fsp_header_t*,mtr_t*)"
"fsp_reserve_free_extents(ulint*,ulint,ulint,ulint,mtr_t*)" -> "flst_get_len(const flst_base_node_t*,mtr_t*)"
"fsp_reserve_free_extents(ulint*,ulint,ulint,ulint,mtr_t*)" -> "__builtin_expect(long int,long int)"
"fsp_reserve_free_extents(ulint*,ulint,ulint,ulint,mtr_t*)" -> "fil_space_get_latch(ulint,ulint*)"
"fsp_reserve_free_extents(ulint*,ulint,ulint,ulint,mtr_t*)" -> "fil_space_reserve_free_extents(ulint,ulint,ulint)"
"fsp_reserve_free_extents(ulint*,ulint,ulint,ulint,mtr_t*)" -> "fsp_flags_get_zip_size(ulint)"
"fsp_reserve_free_extents(ulint*,ulint,ulint,ulint,mtr_t*)" -> "ut_dbg_assertion_failed(const char*,const char*,ulint)"
"fsp_reserve_free_pages(ulint,fsp_header_t*,ulint,mtr_t*)" -> "xdes_get_descriptor_with_space_hdr(fsp_header_t*,ulint,ulint,mtr_t*)"
"fsp_reserve_free_pages(ulint,fsp_header_t*,ulint,mtr_t*)" -> "ut_dbg_assertion_failed(const char*,const char*,ulint)"
"fsp_reserve_free_pages(ulint,fsp_header_t*,ulint,mtr_t*)" -> "__builtin_expect(long int,long int)"
"fsp_reserve_free_pages(ulint,fsp_header_t*,ulint,mtr_t*)" -> "fsp_try_extend_data_file_with_pages(ulint,ulint,fsp_header_t*,mtr_t*)"
"fsp_reserve_free_pages(ulint,fsp_header_t*,ulint,mtr_t*)" -> "xdes_get_n_used(const xdes_t*,mtr_t*)"
"fsp_reserve_free_pages(ulint,fsp_header_t*,ulint,mtr_t*)" -> "abort()"
"fsp_try_extend_data_file_with_pages(ulint,ulint,fsp_header_t*,mtr_t*)" -> "mlog_write_ulint(unsigned char*,ulint,unsigned char,mtr_t*)"
"fsp_try_extend_data_file_with_pages(ulint,ulint,fsp_header_t*,mtr_t*)" -> "ut_dbg_assertion_failed(const char*,const char*,ulint)"
"fsp_try_extend_data_file_with_pages(ulint,ulint,fsp_header_t*,mtr_t*)" -> "abort()"
"fsp_try_extend_data_file_with_pages(ulint,ulint,fsp_header_t*,mtr_t*)" -> "__builtin_expect(long int,long int)"
"fsp_try_extend_data_file_with_pages(ulint,ulint,fsp_header_t*,mtr_t*)" -> "mtr_read_ulint(const unsigned char*,ulint,mtr_t*)"
"fsp_try_extend_data_file_with_pages(ulint,ulint,fsp_header_t*,mtr_t*)" -> "fil_extend_space_to_desired_size(ulint*,ulint,ulint)"
"fil_extend_space_to_desired_size(ulint*,ulint,ulint)" -> "pfs_mutex_exit_func(ib_mutex_t*)"
"fil_extend_space_to_desired_size(ulint*,ulint,ulint)" -> "fil_flush(ulint)"
"fil_extend_space_to_desired_size(ulint*,ulint,ulint)" -> "fsp_flags_get_zip_size(ulint)"
"fil_extend_space_to_desired_size(ulint*,ulint,ulint)" -> "fil_node_prepare_for_io(fil_node_t*,fil_system_t*,fil_space_t*)"
"fil_extend_space_to_desired_size(ulint*,ulint,ulint)" -> "os_file_get_size(os_file_t)"
"fil_extend_space_to_desired_size(ulint*,ulint,ulint)" -> "abort()"
"fil_extend_space_to_desired_size(ulint*,ulint,ulint)" -> "fil_mutex_enter_and_prepare_for_io(ulint)"
"fil_extend_space_to_desired_size(ulint*,ulint,ulint)" -> "pfs_mutex_enter_func(ib_mutex_t*,const char*,ulint)"
"fil_extend_space_to_desired_size(ulint*,ulint,ulint)" -> "fil_space_get_by_id(ulint)"
"fil_extend_space_to_desired_size(ulint*,ulint,ulint)" -> "mem_alloc_func(ulint,ulint*)"
"fil_extend_space_to_desired_size(ulint*,ulint,ulint)" -> "ut_align(const void*,ulint)"
"fil_extend_space_to_desired_size(ulint*,ulint,ulint)" -> "fil_node_complete_io(fil_node_t*,fil_system_t*,ulint)"
"fil_extend_space_to_desired_size(ulint*,ulint,ulint)" -> "ut_min(ulint,ulint)"
"fil_extend_space_to_desired_size(ulint*,ulint,ulint)" -> "ut_dbg_assertion_failed(const char*,const char*,ulint)"
"fil_extend_space_to_desired_size(ulint*,ulint,ulint)" -> "memset(void*,int,size_t)"
"fil_extend_space_to_desired_size(ulint*,ulint,ulint)" -> "mem_free_func(void*,const char*,ulint)"
"fil_extend_space_to_desired_size(ulint*,ulint,ulint)" -> "pfs_os_aio_func(ulint,ulint,const char*,os_file_t,void*,os_offset_t,ulint,fil_node_t*,void*,const char*,ulint)"
"fil_extend_space_to_desired_size(ulint*,ulint,ulint)" -> "__builtin_expect(long int,long int)"
"fil_extend_space_to_desired_size(ulint*,ulint,ulint)" -> "os_thread_sleep(ulint)"
"pfs_os_aio_func(ulint,ulint,const char*,os_file_t,void*,os_offset_t,ulint,fil_node_t*,void*,const char*,ulint)" -> "os_aio_func(ulint,ulint,const char*,os_file_t,void*,os_offset_t,ulint,fil_node_t*,void*)"
"pfs_os_aio_func(ulint,ulint,const char*,os_file_t,void*,os_offset_t,ulint,fil_node_t*,void*,const char*,ulint)" -> "__builtin_expect(long int,long int)"
"os_aio_func(ulint,ulint,const char*,os_file_t,void*,os_offset_t,ulint,fil_node_t*,void*)" -> "os_file_read_func(os_file_t,void*,os_offset_t,ulint)"
"os_aio_func(ulint,ulint,const char*,os_file_t,void*,os_offset_t,ulint,fil_node_t*,void*)" -> "os_file_write_func(const char*,os_file_t,const void*,os_offset_t,ulint)"
"os_aio_func(ulint,ulint,const char*,os_file_t,void*,os_offset_t,ulint,fil_node_t*,void*)" -> "abort()"
"os_aio_func(ulint,ulint,const char*,os_file_t,void*,os_offset_t,ulint,fil_node_t*,void*)" -> "ut_dbg_assertion_failed(const char*,const char*,ulint)"
"os_aio_func(ulint,ulint,const char*,os_file_t,void*,os_offset_t,ulint,fil_node_t*,void*)" -> "__builtin_expect(long int,long int)"
"os_aio_func(ulint,ulint,const char*,os_file_t,void*,os_offset_t,ulint,fil_node_t*,void*)" -> "os_aio_get_segment_no_from_slot(os_aio_array_t*,os_aio_slot_t*)"
"os_aio_func(ulint,ulint,const char*,os_file_t,void*,os_offset_t,ulint,fil_node_t*,void*)" -> "os_aio_simulated_wake_handler_thread(ulint)"
"os_aio_func(ulint,ulint,const char*,os_file_t,void*,os_offset_t,ulint,fil_node_t*,void*)" -> "os_aio_array_reserve_slot(ulint,os_aio_array_t*,fil_node_t*,void*,os_file_t,const char*,void*,os_offset_t,ulint)"
"os_file_write_func(const char*,os_file_t,const void*,os_offset_t,ulint)" -> "__builtin_fwrite(const void*,size_t,size_t,FILE*)"
"os_file_write_func(const char*,os_file_t,const void*,os_offset_t,ulint)" -> "fprintf(FILE*,const char*,...)"
"os_file_write_func(const char*,os_file_t,const void*,os_offset_t,ulint)" -> "os_file_pwrite(os_file_t,const void*,ulint,os_offset_t)"
"os_file_write_func(const char*,os_file_t,const void*,os_offset_t,ulint)" -> "strerror(int)"
"os_file_write_func(const char*,os_file_t,const void*,os_offset_t,ulint)" -> "__errno_location()"
"os_file_write_func(const char*,os_file_t,const void*,os_offset_t,ulint)" -> "ut_print_timestamp(FILE*)"
"os_file_pwrite(os_file_t,const void*,ulint,os_offset_t)" -> "__sync_sub_and_fetch_8(volatile void*,long unsigned int)"
"os_file_pwrite(os_file_t,const void*,ulint,os_offset_t)" -> "__sync_add_and_fetch_8(volatile void*,long unsigned int)"
"os_file_pwrite(os_file_t,const void*,ulint,os_offset_t)" -> "pwrite(int,const void*,size_t,__off64_t)"
"os_aio_get_segment_no_from_slot(os_aio_array_t*,os_aio_slot_t*)" -> "__builtin_expect(long int,long int)"
"os_aio_get_segment_no_from_slot(os_aio_array_t*,os_aio_slot_t*)" -> "ut_dbg_assertion_failed(const char*,const char*,ulint)"
"os_aio_get_segment_no_from_slot(os_aio_array_t*,os_aio_slot_t*)" -> "abort()"
"os_aio_array_reserve_slot(ulint,os_aio_array_t*,fil_node_t*,void*,os_file_t,const char*,void*,os_offset_t,ulint)" -> "__builtin_expect(long int,long int)"
"os_aio_array_reserve_slot(ulint,os_aio_array_t*,fil_node_t*,void*,os_file_t,const char*,void*,os_offset_t,ulint)" -> "os_mutex_exit(os_ib_mutex_t)"
"os_aio_array_reserve_slot(ulint,os_aio_array_t*,fil_node_t*,void*,os_file_t,const char*,void*,os_offset_t,ulint)" -> "os_mutex_enter(os_ib_mutex_t)"
"os_aio_array_reserve_slot(ulint,os_aio_array_t*,fil_node_t*,void*,os_file_t,const char*,void*,os_offset_t,ulint)" -> "os_event_wait_low(os_event_t,ib_int64_t)"
"os_aio_array_reserve_slot(ulint,os_aio_array_t*,fil_node_t*,void*,os_file_t,const char*,void*,os_offset_t,ulint)" -> "os_event_reset(os_event_t)"
"os_aio_array_reserve_slot(ulint,os_aio_array_t*,fil_node_t*,void*,os_file_t,const char*,void*,os_offset_t,ulint)" -> "abort()"
"os_aio_array_reserve_slot(ulint,os_aio_array_t*,fil_node_t*,void*,os_file_t,const char*,void*,os_offset_t,ulint)" -> "ut_time()"
"os_aio_array_reserve_slot(ulint,os_aio_array_t*,fil_node_t*,void*,os_file_t,const char*,void*,os_offset_t,ulint)" -> "ut_dbg_assertion_failed(const char*,const char*,ulint)"
"os_aio_array_reserve_slot(ulint,os_aio_array_t*,fil_node_t*,void*,os_file_t,const char*,void*,os_offset_t,ulint)" -> "os_aio_simulated_wake_handler_threads()"
"os_aio_array_reserve_slot(ulint,os_aio_array_t*,fil_node_t*,void*,os_file_t,const char*,void*,os_offset_t,ulint)" -> "os_aio_array_get_nth_slot(os_aio_array_t*,ulint)"
"fsp_try_extend_data_file(ulint*,ulint,fsp_header_t*,mtr_t*)" -> "fsp_try_extend_data_file_with_pages(ulint,ulint,fsp_header_t*,mtr_t*)"
"fsp_try_extend_data_file(ulint*,ulint,fsp_header_t*,mtr_t*)" -> "fsp_flags_get_zip_size(ulint)"
"fsp_try_extend_data_file(ulint*,ulint,fsp_header_t*,mtr_t*)" -> "fil_extend_space_to_desired_size(ulint*,ulint,ulint)"
"fsp_try_extend_data_file(ulint*,ulint,fsp_header_t*,mtr_t*)" -> "fprintf(FILE*,const char*,...)"
"fsp_try_extend_data_file(ulint*,ulint,fsp_header_t*,mtr_t*)" -> "mlog_write_ulint(unsigned char*,ulint,unsigned char,mtr_t*)"
"fsp_try_extend_data_file(ulint*,ulint,fsp_header_t*,mtr_t*)" -> "mach_read_from_4(const unsigned char*)"
"fsp_try_extend_data_file(ulint*,ulint,fsp_header_t*,mtr_t*)" -> "__builtin_fwrite(const void*,size_t,size_t,FILE*)"
"fsp_try_extend_data_file(ulint*,ulint,fsp_header_t*,mtr_t*)" -> "mtr_read_ulint(const unsigned char*,ulint,mtr_t*)"
"fil_space_reserve_free_extents(ulint,ulint,ulint)" -> "pfs_mutex_enter_func(ib_mutex_t*,const char*,ulint)"
"fil_space_reserve_free_extents(ulint,ulint,ulint)" -> "__builtin_expect(long int,long int)"
"fil_space_reserve_free_extents(ulint,ulint,ulint)" -> "ut_dbg_assertion_failed(const char*,const char*,ulint)"
"fil_space_reserve_free_extents(ulint,ulint,ulint)" -> "abort()"
"fil_space_reserve_free_extents(ulint,ulint,ulint)" -> "fil_space_get_by_id(ulint)"
"fil_space_reserve_free_extents(ulint,ulint,ulint)" -> "pfs_mutex_exit_func(ib_mutex_t*)"
"btr_cur_compress_if_useful(btr_cur_t*,ulint,mtr_t*)" -> "btr_cur_compress_recommendation(btr_cur_t*,mtr_t*)"
"btr_cur_compress_if_useful(btr_cur_t*,ulint,mtr_t*)" -> "btr_compress(btr_cur_t*,ulint,mtr_t*)"
"btr_cur_compress_recommendation(btr_cur_t*,mtr_t*)" -> "page_get_page_no(const ib_page_t*)"
"btr_cur_compress_recommendation(btr_cur_t*,mtr_t*)" -> "btr_page_get_prev(const ib_page_t*,mtr_t*)"
"btr_cur_compress_recommendation(btr_cur_t*,mtr_t*)" -> "btr_page_get_next(const ib_page_t*,mtr_t*)"
"btr_cur_compress_recommendation(btr_cur_t*,mtr_t*)" -> "btr_cur_get_page(btr_cur_t*)"
"btr_cur_compress_recommendation(btr_cur_t*,mtr_t*)" -> "page_get_data_size(const ib_page_t*)"
"btr_cur_compress_recommendation(btr_cur_t*,mtr_t*)" -> "dict_index_get_page(const dict_index_t*)"
"btr_compress(btr_cur_t*,ulint,mtr_t*)" -> "btr_node_ptr_set_child_page_no(rec_t*,page_zip_des_t*,const ulint*,ulint,mtr_t*)"
"btr_compress(btr_cur_t*,ulint,mtr_t*)" -> "btr_page_free(dict_index_t*,buf_block_t*,mtr_t*)"
"btr_compress(btr_cur_t*,ulint,mtr_t*)" -> "btr_cur_get_page_zip(btr_cur_t*)"
"btr_compress(btr_cur_t*,ulint,mtr_t*)" -> "btr_cur_position(dict_index_t*,rec_t*,buf_block_t*,btr_cur_t*)"
"btr_compress(btr_cur_t*,ulint,mtr_t*)" -> "page_rec_get_n_recs_before(const rec_t*)"
"btr_compress(btr_cur_t*,ulint,mtr_t*)" -> "btr_lift_page_up(dict_index_t*,buf_block_t*,mtr_t*)"
"btr_compress(btr_cur_t*,ulint,mtr_t*)" -> "page_get_supremum_offset(const ib_page_t*)"
"btr_compress(btr_cur_t*,ulint,mtr_t*)" -> "page_get_infimum_offset(const ib_page_t*)"
"btr_compress(btr_cur_t*,ulint,mtr_t*)" -> "btr_search_drop_page_hash_index(buf_block_t*)"
"btr_compress(btr_cur_t*,ulint,mtr_t*)" -> "btr_node_ptr_delete(dict_index_t*,buf_block_t*,mtr_t*)"
"btr_compress(btr_cur_t*,ulint,mtr_t*)" -> "btr_cur_compress_if_useful(btr_cur_t*,ulint,mtr_t*)"
"btr_compress(btr_cur_t*,ulint,mtr_t*)" -> "__builtin_expect(long int,long int)"
"btr_compress(btr_cur_t*,ulint,mtr_t*)" -> "btr_page_get_next(const ib_page_t*,mtr_t*)"
"btr_compress(btr_cur_t*,ulint,mtr_t*)" -> "dict_index_is_clust(const dict_index_t*)"
"btr_compress(btr_cur_t*,ulint,mtr_t*)" -> "page_is_leaf(const ib_page_t*)"
"btr_compress(btr_cur_t*,ulint,mtr_t*)" -> "btr_page_get_father_block(ulint*,mem_heap_t*,dict_index_t*,buf_block_t*,mtr_t*,btr_cur_t*)"
"btr_compress(btr_cur_t*,ulint,mtr_t*)" -> "buf_block_get_page_no(const buf_block_t*)"
"btr_compress(btr_cur_t*,ulint,mtr_t*)" -> "page_copy_rec_list_start(buf_block_t*,buf_block_t*,rec_t*,dict_index_t*,mtr_t*)"
"btr_compress(btr_cur_t*,ulint,mtr_t*)" -> "btr_corruption_report(const buf_block_t*,const dict_index_t*)"
"btr_compress(btr_cur_t*,ulint,mtr_t*)" -> "btr_page_get_father(dict_index_t*,buf_block_t*,mtr_t*,btr_cur_t*)"
"btr_compress(btr_cur_t*,ulint,mtr_t*)" -> "dict_index_get_space(const dict_index_t*)"
"btr_compress(btr_cur_t*,ulint,mtr_t*)" -> "ibuf_reset_free_bits(buf_block_t*)"
"btr_compress(btr_cur_t*,ulint,mtr_t*)" -> "page_is_comp(const ib_page_t*)"
"btr_compress(btr_cur_t*,ulint,mtr_t*)" -> "lock_update_merge_left(const buf_block_t*,const rec_t*,const buf_block_t*)"
"btr_compress(btr_cur_t*,ulint,mtr_t*)" -> "dict_table_zip_size(const dict_table_t*)"
"btr_compress(btr_cur_t*,ulint,mtr_t*)" -> "page_rec_get_nth(ib_page_t*,ulint)"
"btr_compress(btr_cur_t*,ulint,mtr_t*)" -> "btr_level_list_remove_func(ulint,ulint,ib_page_t*,mtr_t*)"
"btr_compress(btr_cur_t*,ulint,mtr_t*)" -> "dict_table_is_comp(const dict_table_t*)"
"btr_compress(btr_cur_t*,ulint,mtr_t*)" -> "ut_dbg_assertion_failed(const char*,const char*,ulint)"
"btr_compress(btr_cur_t*,ulint,mtr_t*)" -> "abort()"
"btr_compress(btr_cur_t*,ulint,mtr_t*)" -> "page_copy_rec_list_end(buf_block_t*,buf_block_t*,rec_t*,dict_index_t*,mtr_t*)"
"btr_compress(btr_cur_t*,ulint,mtr_t*)" -> "btr_page_get_prev(const ib_page_t*,mtr_t*)"
"btr_compress(btr_cur_t*,ulint,mtr_t*)" -> "ibuf_update_free_bits_if_full(buf_block_t*,ulint,ulint)"
"btr_compress(btr_cur_t*,ulint,mtr_t*)" -> "mem_heap_create_func(ulint,ulint)"
"btr_compress(btr_cur_t*,ulint,mtr_t*)" -> "btr_can_merge_with_page(btr_cur_t*,ulint,buf_block_t**,mtr_t*)"
"btr_compress(btr_cur_t*,ulint,mtr_t*)" -> "lock_update_merge_right(const buf_block_t*,const rec_t*,const buf_block_t*)"
"btr_compress(btr_cur_t*,ulint,mtr_t*)" -> "memset(void*,int,size_t)"
"btr_compress(btr_cur_t*,ulint,mtr_t*)" -> "btr_cur_get_page(btr_cur_t*)"
"btr_compress(btr_cur_t*,ulint,mtr_t*)" -> "memcmp(const void*,const void*,size_t)"
"btr_compress(btr_cur_t*,ulint,mtr_t*)" -> "btr_cur_pessimistic_delete(dberr_t*,ulint,btr_cur_t*,ulint,trx_rb_ctx,mtr_t*)"
"btr_compress(btr_cur_t*,ulint,mtr_t*)" -> "mem_heap_free_func(mem_heap_t*,const char*,ulint)"
"btr_node_ptr_set_child_page_no(rec_t*,page_zip_des_t*,const ulint*,ulint,mtr_t*)" -> "rec_offs_n_fields(const ulint*)"
"btr_node_ptr_set_child_page_no(rec_t*,page_zip_des_t*,const ulint*,ulint,mtr_t*)" -> "rec_offs_data_size(const ulint*)"
"btr_node_ptr_set_child_page_no(rec_t*,page_zip_des_t*,const ulint*,ulint,mtr_t*)" -> "page_zip_write_node_ptr(page_zip_des_t*,unsigned char*,ulint,ulint,mtr_t*)"
"btr_node_ptr_set_child_page_no(rec_t*,page_zip_des_t*,const ulint*,ulint,mtr_t*)" -> "rec_get_nth_field_offs(const ulint*,ulint,ulint*)"
"btr_node_ptr_set_child_page_no(rec_t*,page_zip_des_t*,const ulint*,ulint,mtr_t*)" -> "mlog_write_ulint(unsigned char*,ulint,unsigned char,mtr_t*)"
"page_zip_write_node_ptr(page_zip_des_t*,unsigned char*,ulint,ulint,mtr_t*)" -> "page_zip_dir_start_offs(const page_zip_des_t*,ulint)"
"page_zip_write_node_ptr(page_zip_des_t*,unsigned char*,ulint,ulint,mtr_t*)" -> "rec_get_heap_no_new(const rec_t*)"
"page_zip_write_node_ptr(page_zip_des_t*,unsigned char*,ulint,ulint,mtr_t*)" -> "memcpy(void*,const void*,size_t)"
"page_zip_write_node_ptr(page_zip_des_t*,unsigned char*,ulint,ulint,mtr_t*)" -> "page_zip_dir_elems(const page_zip_des_t*)"
"page_zip_write_node_ptr(page_zip_des_t*,unsigned char*,ulint,ulint,mtr_t*)" -> "mlog_open(mtr_t*,ulint)"
"page_zip_write_node_ptr(page_zip_des_t*,unsigned char*,ulint,ulint,mtr_t*)" -> "__builtin_expect(long int,long int)"
"page_zip_write_node_ptr(page_zip_des_t*,unsigned char*,ulint,ulint,mtr_t*)" -> "mach_write_to_2(unsigned char*,ulint)"
"page_zip_write_node_ptr(page_zip_des_t*,unsigned char*,ulint,ulint,mtr_t*)" -> "mlog_close(mtr_t*,unsigned char*)"
"page_zip_write_node_ptr(page_zip_des_t*,unsigned char*,ulint,ulint,mtr_t*)" -> "mach_write_to_4(unsigned char*,ulint)"
"page_zip_write_node_ptr(page_zip_des_t*,unsigned char*,ulint,ulint,mtr_t*)" -> "page_offset(const void*)"
"page_zip_write_node_ptr(page_zip_des_t*,unsigned char*,ulint,ulint,mtr_t*)" -> "mlog_write_initial_log_record_fast(const unsigned char*,unsigned char,unsigned char*,mtr_t*)"
"btr_page_free(dict_index_t*,buf_block_t*,mtr_t*)" -> "btr_page_free_low(dict_index_t*,buf_block_t*,ulint,mtr_t*)"
"btr_page_free(dict_index_t*,buf_block_t*,mtr_t*)" -> "btr_page_get_level_low(const ib_page_t*)"
"btr_page_free_low(dict_index_t*,buf_block_t*,ulint,mtr_t*)" -> "buf_block_modify_clock_inc(buf_block_t*)"
"btr_page_free_low(dict_index_t*,buf_block_t*,ulint,mtr_t*)" -> "btr_page_free_for_ibuf(dict_index_t*,buf_block_t*,mtr_t*)"
"btr_page_free_low(dict_index_t*,buf_block_t*,ulint,mtr_t*)" -> "buf_block_get_page_no(const buf_block_t*)"
"btr_page_free_low(dict_index_t*,buf_block_t*,ulint,mtr_t*)" -> "dict_index_is_ibuf(const dict_index_t*)"
"btr_page_free_low(dict_index_t*,buf_block_t*,ulint,mtr_t*)" -> "fseg_free_page(fseg_header_t*,ulint,ulint,mtr_t*)"
"btr_page_free_low(dict_index_t*,buf_block_t*,ulint,mtr_t*)" -> "btr_root_get(const dict_index_t*,mtr_t*)"
"btr_page_free_low(dict_index_t*,buf_block_t*,ulint,mtr_t*)" -> "buf_block_get_space(const buf_block_t*)"
"btr_page_free_for_ibuf(dict_index_t*,buf_block_t*,mtr_t*)" -> "btr_root_get(const dict_index_t*,mtr_t*)"
"btr_page_free_for_ibuf(dict_index_t*,buf_block_t*,mtr_t*)" -> "flst_add_first(flst_base_node_t*,flst_node_t*,mtr_t*)"
"btr_root_get(const dict_index_t*,mtr_t*)" -> "btr_root_block_get(const dict_index_t*,ulint,mtr_t*)"
"btr_root_block_get(const dict_index_t*,ulint,mtr_t*)" -> "dict_table_zip_size(const dict_table_t*)"
"btr_root_block_get(const dict_index_t*,ulint,mtr_t*)" -> "btr_corruption_report(const buf_block_t*,const dict_index_t*)"
"btr_root_block_get(const dict_index_t*,ulint,mtr_t*)" -> "abort()"
"btr_root_block_get(const dict_index_t*,ulint,mtr_t*)" -> "btr_block_get_func(ulint,ulint,ulint,ulint,const char*,ulint,mtr_t*)"
"btr_root_block_get(const dict_index_t*,ulint,mtr_t*)" -> "dict_table_is_comp(const dict_table_t*)"
"btr_root_block_get(const dict_index_t*,ulint,mtr_t*)" -> "page_is_comp(const ib_page_t*)"
"btr_root_block_get(const dict_index_t*,ulint,mtr_t*)" -> "btr_root_fseg_validate(const fseg_header_t*,ulint)"
"btr_root_block_get(const dict_index_t*,ulint,mtr_t*)" -> "__builtin_expect(long int,long int)"
"btr_root_block_get(const dict_index_t*,ulint,mtr_t*)" -> "ut_dbg_assertion_failed(const char*,const char*,ulint)"
"btr_root_block_get(const dict_index_t*,ulint,mtr_t*)" -> "dict_index_get_space(const dict_index_t*)"
"btr_root_block_get(const dict_index_t*,ulint,mtr_t*)" -> "dict_index_get_page(const dict_index_t*)"
"btr_root_block_get(const dict_index_t*,ulint,mtr_t*)" -> "dict_index_is_ibuf(const dict_index_t*)"
"btr_root_fseg_validate(const fseg_header_t*,ulint)" -> "ut_dbg_assertion_failed(const char*,const char*,ulint)"
"btr_root_fseg_validate(const fseg_header_t*,ulint)" -> "__builtin_expect(long int,long int)"
"btr_root_fseg_validate(const fseg_header_t*,ulint)" -> "mach_read_from_2(const unsigned char*)"
"btr_root_fseg_validate(const fseg_header_t*,ulint)" -> "abort()"
"btr_root_fseg_validate(const fseg_header_t*,ulint)" -> "mach_read_from_4(const unsigned char*)"
"fseg_free_page(fseg_header_t*,ulint,ulint,mtr_t*)" -> "mtr_x_lock_func(rw_lock_t*,const char*,ulint,mtr_t*)"
"fseg_free_page(fseg_header_t*,ulint,ulint,mtr_t*)" -> "fseg_free_page_low(fseg_inode_t*,ulint,ulint,ulint,mtr_t*)"
"fseg_free_page(fseg_header_t*,ulint,ulint,mtr_t*)" -> "fsp_flags_get_zip_size(ulint)"
"fseg_free_page(fseg_header_t*,ulint,ulint,mtr_t*)" -> "fil_space_get_latch(ulint,ulint*)"
"fseg_free_page(fseg_header_t*,ulint,ulint,mtr_t*)" -> "fseg_inode_get(fseg_header_t*,ulint,ulint,mtr_t*)"
"fseg_inode_get(fseg_header_t*,ulint,ulint,mtr_t*)" -> "__builtin_expect(long int,long int)"
"fseg_inode_get(fseg_header_t*,ulint,ulint,mtr_t*)" -> "ut_dbg_assertion_failed(const char*,const char*,ulint)"
"fseg_inode_get(fseg_header_t*,ulint,ulint,mtr_t*)" -> "fseg_inode_try_get(fseg_header_t*,ulint,ulint,mtr_t*)"
"fseg_inode_get(fseg_header_t*,ulint,ulint,mtr_t*)" -> "abort()"
"btr_lift_page_up(dict_index_t*,buf_block_t*,mtr_t*)" -> "mem_heap_create_func(ulint,ulint)"
"btr_lift_page_up(dict_index_t*,buf_block_t*,mtr_t*)" -> "ibuf_reset_free_bits(buf_block_t*)"
"btr_lift_page_up(dict_index_t*,buf_block_t*,mtr_t*)" -> "page_copy_rec_list_end(buf_block_t*,buf_block_t*,rec_t*,dict_index_t*,mtr_t*)"
"btr_lift_page_up(dict_index_t*,buf_block_t*,mtr_t*)" -> "buf_block_get_page_no(const buf_block_t*)"
"btr_lift_page_up(dict_index_t*,buf_block_t*,mtr_t*)" -> "btr_page_empty(buf_block_t*,page_zip_des_t*,dict_index_t*,ulint,mtr_t*)"
"btr_lift_page_up(dict_index_t*,buf_block_t*,mtr_t*)" -> "lock_update_copy_and_discard(const buf_block_t*,const buf_block_t*)"
"btr_lift_page_up(dict_index_t*,buf_block_t*,mtr_t*)" -> "page_get_infimum_offset(const ib_page_t*)"
"btr_lift_page_up(dict_index_t*,buf_block_t*,mtr_t*)" -> "btr_page_free(dict_index_t*,buf_block_t*,mtr_t*)"
"btr_lift_page_up(dict_index_t*,buf_block_t*,mtr_t*)" -> "btr_search_move_or_delete_hash_entries(buf_block_t*,buf_block_t*,dict_index_t*)"
"btr_lift_page_up(dict_index_t*,buf_block_t*,mtr_t*)" -> "btr_page_get_father_block(ulint*,mem_heap_t*,dict_index_t*,buf_block_t*,mtr_t*,btr_cur_t*)"
"btr_lift_page_up(dict_index_t*,buf_block_t*,mtr_t*)" -> "btr_page_set_level(ib_page_t*,page_zip_des_t*,ulint,mtr_t*)"
"btr_lift_page_up(dict_index_t*,buf_block_t*,mtr_t*)" -> "dict_index_get_page(const dict_index_t*)"
"btr_lift_page_up(dict_index_t*,buf_block_t*,mtr_t*)" -> "btr_page_get_level_low(const ib_page_t*)"
"btr_lift_page_up(dict_index_t*,buf_block_t*,mtr_t*)" -> "dict_index_is_clust(const dict_index_t*)"
"btr_lift_page_up(dict_index_t*,buf_block_t*,mtr_t*)" -> "ut_dbg_assertion_failed(const char*,const char*,ulint)"
"btr_lift_page_up(dict_index_t*,buf_block_t*,mtr_t*)" -> "abort()"
"btr_lift_page_up(dict_index_t*,buf_block_t*,mtr_t*)" -> "mem_heap_free_func(mem_heap_t*,const char*,ulint)"
"btr_lift_page_up(dict_index_t*,buf_block_t*,mtr_t*)" -> "__builtin_expect(long int,long int)"
"btr_lift_page_up(dict_index_t*,buf_block_t*,mtr_t*)" -> "lock_move_rec_list_end(const buf_block_t*,const buf_block_t*,const rec_t*)"
"btr_lift_page_up(dict_index_t*,buf_block_t*,mtr_t*)" -> "btr_search_drop_page_hash_index(buf_block_t*)"
"btr_lift_page_up(dict_index_t*,buf_block_t*,mtr_t*)" -> "page_zip_copy_recs(page_zip_des_t*,ib_page_t*,const page_zip_des_t*,const ib_page_t*,dict_index_t*,mtr_t*)"
"page_copy_rec_list_end(buf_block_t*,buf_block_t*,rec_t*,dict_index_t*,mtr_t*)" -> "page_zip_compress(page_zip_des_t*,const ib_page_t*,dict_index_t*,ulint,mtr_t*)"
"page_copy_rec_list_end(buf_block_t*,buf_block_t*,rec_t*,dict_index_t*,mtr_t*)" -> "page_zip_decompress(page_zip_des_t*,ib_page_t*,ulint)"
"page_copy_rec_list_end(buf_block_t*,buf_block_t*,rec_t*,dict_index_t*,mtr_t*)" -> "lock_move_rec_list_end(const buf_block_t*,const buf_block_t*,const rec_t*)"
"page_copy_rec_list_end(buf_block_t*,buf_block_t*,rec_t*,dict_index_t*,mtr_t*)" -> "page_align(const void*)"
"page_copy_rec_list_end(buf_block_t*,buf_block_t*,rec_t*,dict_index_t*,mtr_t*)" -> "mtr_set_log_mode(mtr_t*,ulint)"
"page_copy_rec_list_end(buf_block_t*,buf_block_t*,rec_t*,dict_index_t*,mtr_t*)" -> "btr_search_move_or_delete_hash_entries(buf_block_t*,buf_block_t*,dict_index_t*)"
"page_copy_rec_list_end(buf_block_t*,buf_block_t*,rec_t*,dict_index_t*,mtr_t*)" -> "page_copy_rec_list_end_no_locks(buf_block_t*,buf_block_t*,rec_t*,dict_index_t*,mtr_t*)"
"page_copy_rec_list_end(buf_block_t*,buf_block_t*,rec_t*,dict_index_t*,mtr_t*)" -> "page_dir_get_n_heap(const ib_page_t*)"
"page_copy_rec_list_end(buf_block_t*,buf_block_t*,rec_t*,dict_index_t*,mtr_t*)" -> "page_get_max_trx_id(const ib_page_t*)"
"page_copy_rec_list_end(buf_block_t*,buf_block_t*,rec_t*,dict_index_t*,mtr_t*)" -> "dict_index_is_sec_or_ibuf(const dict_index_t*)"
"page_copy_rec_list_end(buf_block_t*,buf_block_t*,rec_t*,dict_index_t*,mtr_t*)" -> "page_copy_rec_list_end_to_created_page(ib_page_t*,rec_t*,dict_index_t*,mtr_t*)"
"page_copy_rec_list_end(buf_block_t*,buf_block_t*,rec_t*,dict_index_t*,mtr_t*)" -> "page_is_leaf(const ib_page_t*)"
"page_copy_rec_list_end(buf_block_t*,buf_block_t*,rec_t*,dict_index_t*,mtr_t*)" -> "page_get_infimum_offset(const ib_page_t*)"
"page_copy_rec_list_end(buf_block_t*,buf_block_t*,rec_t*,dict_index_t*,mtr_t*)" -> "ut_dbg_assertion_failed(const char*,const char*,ulint)"
"page_copy_rec_list_end(buf_block_t*,buf_block_t*,rec_t*,dict_index_t*,mtr_t*)" -> "abort()"
"page_copy_rec_list_end(buf_block_t*,buf_block_t*,rec_t*,dict_index_t*,mtr_t*)" -> "rec_get_next_ptr(rec_t*,ulint)"
"page_copy_rec_list_end(buf_block_t*,buf_block_t*,rec_t*,dict_index_t*,mtr_t*)" -> "__builtin_expect(long int,long int)"
"page_copy_rec_list_end(buf_block_t*,buf_block_t*,rec_t*,dict_index_t*,mtr_t*)" -> "page_zip_reorganize(buf_block_t*,dict_index_t*,mtr_t*)"
"page_copy_rec_list_end(buf_block_t*,buf_block_t*,rec_t*,dict_index_t*,mtr_t*)" -> "page_rec_get_next(rec_t*)"
"page_copy_rec_list_end(buf_block_t*,buf_block_t*,rec_t*,dict_index_t*,mtr_t*)" -> "page_rec_get_n_recs_before(const rec_t*)"
"page_copy_rec_list_end(buf_block_t*,buf_block_t*,rec_t*,dict_index_t*,mtr_t*)" -> "page_update_max_trx_id(buf_block_t*,page_zip_des_t*,trx_id_t,mtr_t*)"
"lock_move_rec_list_end(const buf_block_t*,const buf_block_t*,const rec_t*)" -> "lock_rec_add_to_queue(ulint,const buf_block_t*,ulint,dict_index_t*,trx_t*,ulint)"
"lock_move_rec_list_end(const buf_block_t*,const buf_block_t*,const rec_t*)" -> "rec_get_heap_no_old(const rec_t*)"
"lock_move_rec_list_end(const buf_block_t*,const buf_block_t*,const rec_t*)" -> "lock_rec_get_next_on_page(ib_lock_t*)"
"lock_move_rec_list_end(const buf_block_t*,const buf_block_t*,const rec_t*)" -> "page_cur_is_after_last(const page_cur_t*)"
"lock_move_rec_list_end(const buf_block_t*,const buf_block_t*,const rec_t*)" -> "page_cur_set_before_first(const buf_block_t*,page_cur_t*)"
"lock_move_rec_list_end(const buf_block_t*,const buf_block_t*,const rec_t*)" -> "lock_reset_lock_and_trx_wait(ib_lock_t*)"
"lock_move_rec_list_end(const buf_block_t*,const buf_block_t*,const rec_t*)" -> "__builtin_expect(long int,long int)"
"lock_move_rec_list_end(const buf_block_t*,const buf_block_t*,const rec_t*)" -> "pfs_mutex_enter_func(ib_mutex_t*,const char*,ulint)"
"lock_move_rec_list_end(const buf_block_t*,const buf_block_t*,const rec_t*)" -> "rec_get_heap_no_new(const rec_t*)"
"lock_move_rec_list_end(const buf_block_t*,const buf_block_t*,const rec_t*)" -> "page_rec_is_comp(const rec_t*)"
"lock_move_rec_list_end(const buf_block_t*,const buf_block_t*,const rec_t*)" -> "lock_rec_reset_nth_bit(ib_lock_t*,ulint)"
"lock_move_rec_list_end(const buf_block_t*,const buf_block_t*,const rec_t*)" -> "lock_rec_get_first_on_page(const buf_block_t*)"
"lock_move_rec_list_end(const buf_block_t*,const buf_block_t*,const rec_t*)" -> "page_cur_move_to_next(page_cur_t*)"
"lock_move_rec_list_end(const buf_block_t*,const buf_block_t*,const rec_t*)" -> "lock_rec_get_nth_bit(const ib_lock_t*,ulint)"
"lock_move_rec_list_end(const buf_block_t*,const buf_block_t*,const rec_t*)" -> "pfs_mutex_exit_func(ib_mutex_t*)"
"lock_move_rec_list_end(const buf_block_t*,const buf_block_t*,const rec_t*)" -> "page_cur_is_before_first(const page_cur_t*)"
"lock_move_rec_list_end(const buf_block_t*,const buf_block_t*,const rec_t*)" -> "page_cur_position(const rec_t*,const buf_block_t*,page_cur_t*)"
"btr_search_move_or_delete_hash_entries(buf_block_t*,buf_block_t*,dict_index_t*)" -> "pfs_rw_lock_s_unlock_func(rw_lock_t*)"
"btr_search_move_or_delete_hash_entries(buf_block_t*,buf_block_t*,dict_index_t*)" -> "pfs_rw_lock_s_lock_func(rw_lock_t*,ulint,const char*,ulint)"
"btr_search_move_or_delete_hash_entries(buf_block_t*,buf_block_t*,dict_index_t*)" -> "btr_search_build_page_hash_index(dict_index_t*,buf_block_t*,ulint,ulint,ulint)"
"btr_search_move_or_delete_hash_entries(buf_block_t*,buf_block_t*,dict_index_t*)" -> "btr_search_drop_page_hash_index(buf_block_t*)"
"btr_search_move_or_delete_hash_entries(buf_block_t*,buf_block_t*,dict_index_t*)" -> "dict_index_is_ibuf(const dict_index_t*)"
"btr_search_move_or_delete_hash_entries(buf_block_t*,buf_block_t*,dict_index_t*)" -> "abort()"
"btr_search_move_or_delete_hash_entries(buf_block_t*,buf_block_t*,dict_index_t*)" -> "__builtin_expect(long int,long int)"
"btr_search_move_or_delete_hash_entries(buf_block_t*,buf_block_t*,dict_index_t*)" -> "ut_dbg_assertion_failed(const char*,const char*,ulint)"
"btr_search_build_page_hash_index(dict_index_t*,buf_block_t*,ulint,ulint,ulint)" -> "pfs_rw_lock_s_unlock_func(rw_lock_t*)"
"btr_search_build_page_hash_index(dict_index_t*,buf_block_t*,ulint,ulint,ulint)" -> "rec_fold(const rec_t*,const ulint*,ulint,ulint,index_id_t)"
"btr_search_build_page_hash_index(dict_index_t*,buf_block_t*,ulint,ulint,ulint)" -> "btr_page_get_index_id(const ib_page_t*)"
"btr_search_build_page_hash_index(dict_index_t*,buf_block_t*,ulint,ulint,ulint)" -> "ut_dbg_assertion_failed(const char*,const char*,ulint)"
"btr_search_build_page_hash_index(dict_index_t*,buf_block_t*,ulint,ulint,ulint)" -> "pfs_rw_lock_s_lock_func(rw_lock_t*,ulint,const char*,ulint)"
"btr_search_build_page_hash_index(dict_index_t*,buf_block_t*,ulint,ulint,ulint)" -> "page_get_n_recs(const ib_page_t*)"
"btr_search_build_page_hash_index(dict_index_t*,buf_block_t*,ulint,ulint,ulint)" -> "page_rec_get_next(rec_t*)"
"btr_search_build_page_hash_index(dict_index_t*,buf_block_t*,ulint,ulint,ulint)" -> "mem_alloc_func(ulint,ulint*)"
"btr_search_build_page_hash_index(dict_index_t*,buf_block_t*,ulint,ulint,ulint)" -> "btr_search_drop_page_hash_index(buf_block_t*)"
"btr_search_build_page_hash_index(dict_index_t*,buf_block_t*,ulint,ulint,ulint)" -> "rec_offs_set_n_alloc(ulint*,ulint)"
"btr_search_build_page_hash_index(dict_index_t*,buf_block_t*,ulint,ulint,ulint)" -> "pfs_rw_lock_x_unlock_func(rw_lock_t*)"
"btr_search_build_page_hash_index(dict_index_t*,buf_block_t*,ulint,ulint,ulint)" -> "dict_index_get_n_unique_in_tree(const dict_index_t*)"
"btr_search_build_page_hash_index(dict_index_t*,buf_block_t*,ulint,ulint,ulint)" -> "page_get_infimum_offset(const ib_page_t*)"
"btr_search_build_page_hash_index(dict_index_t*,buf_block_t*,ulint,ulint,ulint)" -> "abort()"
"btr_search_build_page_hash_index(dict_index_t*,buf_block_t*,ulint,ulint,ulint)" -> "pfs_rw_lock_x_lock_func(rw_lock_t*,ulint,const char*,ulint)"
"btr_search_build_page_hash_index(dict_index_t*,buf_block_t*,ulint,ulint,ulint)" -> "mem_free_func(void*,const char*,ulint)"
"btr_search_build_page_hash_index(dict_index_t*,buf_block_t*,ulint,ulint,ulint)" -> "mem_heap_free_func(mem_heap_t*,const char*,ulint)"
"btr_search_build_page_hash_index(dict_index_t*,buf_block_t*,ulint,ulint,ulint)" -> "page_rec_is_supremum(const rec_t*)"
"btr_search_build_page_hash_index(dict_index_t*,buf_block_t*,ulint,ulint,ulint)" -> "__builtin_expect(long int,long int)"
"btr_search_build_page_hash_index(dict_index_t*,buf_block_t*,ulint,ulint,ulint)" -> "ha_insert_for_fold_func(hash_table_t*,ulint,const rec_t*)"
"btr_search_build_page_hash_index(dict_index_t*,buf_block_t*,ulint,ulint,ulint)" -> "rec_offs_n_fields(const ulint*)"
"btr_search_build_page_hash_index(dict_index_t*,buf_block_t*,ulint,ulint,ulint)" -> "dict_index_is_ibuf(const dict_index_t*)"
"btr_search_build_page_hash_index(dict_index_t*,buf_block_t*,ulint,ulint,ulint)" -> "btr_search_check_free_space_in_heap()"
"btr_search_build_page_hash_index(dict_index_t*,buf_block_t*,ulint,ulint,ulint)" -> "rec_get_offsets_func(const rec_t*,const dict_index_t*,ulint*,ulint,mem_heap_t**)"
"ha_insert_for_fold_func(hash_table_t*,ulint,const rec_t*)" -> "hash_get_heap(hash_table_t*,ulint)"
"ha_insert_for_fold_func(hash_table_t*,ulint,const rec_t*)" -> "hash_get_nth_cell(hash_table_t*,ulint)"
"ha_insert_for_fold_func(hash_table_t*,ulint,const rec_t*)" -> "mem_heap_alloc(mem_heap_t*,ulint)"
"ha_insert_for_fold_func(hash_table_t*,ulint,const rec_t*)" -> "ha_node_set_data_func(ha_node_t*,const rec_t*)"
"ha_insert_for_fold_func(hash_table_t*,ulint,const rec_t*)" -> "hash_calc_hash(ulint,hash_table_t*)"
"btr_search_check_free_space_in_heap()" -> "pfs_rw_lock_x_unlock_func(rw_lock_t*)"
"btr_search_check_free_space_in_heap()" -> "buf_block_alloc(buf_pool_t*)"
"btr_search_check_free_space_in_heap()" -> "pfs_rw_lock_x_lock_func(rw_lock_t*,ulint,const char*,ulint)"
"btr_search_check_free_space_in_heap()" -> "buf_block_free(buf_block_t*)"
"page_copy_rec_list_end_to_created_page(ib_page_t*,rec_t*,dict_index_t*,mtr_t*)" -> "page_dir_slot_set_n_owned(page_dir_slot_t*,page_zip_des_t*,ulint)"
"page_copy_rec_list_end_to_created_page(ib_page_t*,rec_t*,dict_index_t*,mtr_t*)" -> "page_get_supremum_offset(const ib_page_t*)"
"page_copy_rec_list_end_to_created_page(ib_page_t*,rec_t*,dict_index_t*,mtr_t*)" -> "rec_set_next_offs_old(rec_t*,ulint)"
"page_copy_rec_list_end_to_created_page(ib_page_t*,rec_t*,dict_index_t*,mtr_t*)" -> "rec_set_heap_no_old(rec_t*,ulint)"
"page_copy_rec_list_end_to_created_page(ib_page_t*,rec_t*,dict_index_t*,mtr_t*)" -> "abort()"
"page_copy_rec_list_end_to_created_page(ib_page_t*,rec_t*,dict_index_t*,mtr_t*)" -> "page_offset(const void*)"
"page_copy_rec_list_end_to_created_page(ib_page_t*,rec_t*,dict_index_t*,mtr_t*)" -> "rec_get_offsets_func(const rec_t*,const dict_index_t*,ulint*,ulint,mem_heap_t**)"
"page_copy_rec_list_end_to_created_page(ib_page_t*,rec_t*,dict_index_t*,mtr_t*)" -> "page_cur_insert_rec_write_log(rec_t*,ulint,rec_t*,dict_index_t*,mtr_t*)"
"page_copy_rec_list_end_to_created_page(ib_page_t*,rec_t*,dict_index_t*,mtr_t*)" -> "page_get_infimum_offset(const ib_page_t*)"
"page_copy_rec_list_end_to_created_page(ib_page_t*,rec_t*,dict_index_t*,mtr_t*)" -> "page_dir_slot_set_rec(page_dir_slot_t*,rec_t*)"
"page_copy_rec_list_end_to_created_page(ib_page_t*,rec_t*,dict_index_t*,mtr_t*)" -> "mach_write_to_4(unsigned char*,ulint)"
"page_copy_rec_list_end_to_created_page(ib_page_t*,rec_t*,dict_index_t*,mtr_t*)" -> "ut_dbg_assertion_failed(const char*,const char*,ulint)"
"page_copy_rec_list_end_to_created_page(ib_page_t*,rec_t*,dict_index_t*,mtr_t*)" -> "page_copy_rec_list_to_created_page_write_log(ib_page_t*,dict_index_t*,mtr_t*)"
"page_copy_rec_list_end_to_created_page(ib_page_t*,rec_t*,dict_index_t*,mtr_t*)" -> "page_rec_get_next(rec_t*)"
"page_copy_rec_list_end_to_created_page(ib_page_t*,rec_t*,dict_index_t*,mtr_t*)" -> "mtr_set_log_mode(mtr_t*,ulint)"
"page_copy_rec_list_end_to_created_page(ib_page_t*,rec_t*,dict_index_t*,mtr_t*)" -> "page_rec_is_supremum(const rec_t*)"
"page_copy_rec_list_end_to_created_page(ib_page_t*,rec_t*,dict_index_t*,mtr_t*)" -> "rec_copy(void*,const rec_t*,const ulint*)"
"page_copy_rec_list_end_to_created_page(ib_page_t*,rec_t*,dict_index_t*,mtr_t*)" -> "page_dir_set_n_heap(ib_page_t*,page_zip_des_t*,ulint)"
"page_copy_rec_list_end_to_created_page(ib_page_t*,rec_t*,dict_index_t*,mtr_t*)" -> "page_is_comp(const ib_page_t*)"
"page_copy_rec_list_end_to_created_page(ib_page_t*,rec_t*,dict_index_t*,mtr_t*)" -> "dyn_array_get_data_size(const dyn_array_t*)"
"page_copy_rec_list_end_to_created_page(ib_page_t*,rec_t*,dict_index_t*,mtr_t*)" -> "mem_heap_free_func(mem_heap_t*,const char*,ulint)"
"page_copy_rec_list_end_to_created_page(ib_page_t*,rec_t*,dict_index_t*,mtr_t*)" -> "rec_set_n_owned_old(rec_t*,ulint)"
"page_copy_rec_list_end_to_created_page(ib_page_t*,rec_t*,dict_index_t*,mtr_t*)" -> "page_dir_set_n_slots(ib_page_t*,page_zip_des_t*,ulint)"
"page_copy_rec_list_end_to_created_page(ib_page_t*,rec_t*,dict_index_t*,mtr_t*)" -> "rec_set_n_owned_new(rec_t*,page_zip_des_t*,ulint)"
"page_copy_rec_list_end_to_created_page(ib_page_t*,rec_t*,dict_index_t*,mtr_t*)" -> "rec_offs_size(const ulint*)"
"page_copy_rec_list_end_to_created_page(ib_page_t*,rec_t*,dict_index_t*,mtr_t*)" -> "page_header_set_field(ib_page_t*,page_zip_des_t*,ulint,ulint)"
"page_copy_rec_list_end_to_created_page(ib_page_t*,rec_t*,dict_index_t*,mtr_t*)" -> "rec_set_next_offs_new(rec_t*,ulint)"
"page_copy_rec_list_end_to_created_page(ib_page_t*,rec_t*,dict_index_t*,mtr_t*)" -> "page_rec_is_infimum(const rec_t*)"
"page_copy_rec_list_end_to_created_page(ib_page_t*,rec_t*,dict_index_t*,mtr_t*)" -> "rec_set_heap_no_new(rec_t*,ulint)"
"page_copy_rec_list_end_to_created_page(ib_page_t*,rec_t*,dict_index_t*,mtr_t*)" -> "page_header_set_ptr(ib_page_t*,page_zip_des_t*,ulint,const unsigned char*)"
"page_copy_rec_list_end_to_created_page(ib_page_t*,rec_t*,dict_index_t*,mtr_t*)" -> "rec_offs_set_n_alloc(ulint*,ulint)"
"page_copy_rec_list_end_to_created_page(ib_page_t*,rec_t*,dict_index_t*,mtr_t*)" -> "__builtin_expect(long int,long int)"
"page_copy_rec_list_to_created_page_write_log(ib_page_t*,dict_index_t*,mtr_t*)" -> "page_is_comp(const ib_page_t*)"
"page_copy_rec_list_to_created_page_write_log(ib_page_t*,dict_index_t*,mtr_t*)" -> "mlog_close(mtr_t*,unsigned char*)"
"page_copy_rec_list_to_created_page_write_log(ib_page_t*,dict_index_t*,mtr_t*)" -> "__builtin_expect(long int,long int)"
"page_copy_rec_list_to_created_page_write_log(ib_page_t*,dict_index_t*,mtr_t*)" -> "mlog_open_and_write_index(mtr_t*,const unsigned char*,const dict_index_t*,unsigned char,ulint)"
"btr_page_empty(buf_block_t*,page_zip_des_t*,dict_index_t*,ulint,mtr_t*)" -> "page_create(buf_block_t*,mtr_t*,ulint)"
"btr_page_empty(buf_block_t*,page_zip_des_t*,dict_index_t*,ulint,mtr_t*)" -> "dict_table_is_comp(const dict_table_t*)"
"btr_page_empty(buf_block_t*,page_zip_des_t*,dict_index_t*,ulint,mtr_t*)" -> "page_create_zip(buf_block_t*,dict_index_t*,ulint,trx_id_t,mtr_t*)"
"btr_page_empty(buf_block_t*,page_zip_des_t*,dict_index_t*,ulint,mtr_t*)" -> "btr_search_drop_page_hash_index(buf_block_t*)"
"btr_page_empty(buf_block_t*,page_zip_des_t*,dict_index_t*,ulint,mtr_t*)" -> "btr_page_set_level(ib_page_t*,page_zip_des_t*,ulint,mtr_t*)"
"btr_page_set_level(ib_page_t*,page_zip_des_t*,ulint,mtr_t*)" -> "page_zip_write_header(page_zip_des_t*,const unsigned char*,ulint,mtr_t*)"
"btr_page_set_level(ib_page_t*,page_zip_des_t*,ulint,mtr_t*)" -> "mlog_write_ulint(unsigned char*,ulint,unsigned char,mtr_t*)"
"btr_page_set_level(ib_page_t*,page_zip_des_t*,ulint,mtr_t*)" -> "mach_write_to_2(unsigned char*,ulint)"
"lock_update_copy_and_discard(const buf_block_t*,const buf_block_t*)" -> "pfs_mutex_enter_func(ib_mutex_t*,const char*,ulint)"
"lock_update_copy_and_discard(const buf_block_t*,const buf_block_t*)" -> "pfs_mutex_exit_func(ib_mutex_t*)"
"lock_update_copy_and_discard(const buf_block_t*,const buf_block_t*)" -> "lock_rec_free_all_from_discard_page(const buf_block_t*)"
"lock_update_copy_and_discard(const buf_block_t*,const buf_block_t*)" -> "lock_rec_move(const buf_block_t*,const buf_block_t*,ulint,ulint)"
"lock_rec_free_all_from_discard_page(const buf_block_t*)" -> "buf_block_get_space(const buf_block_t*)"
"lock_rec_free_all_from_discard_page(const buf_block_t*)" -> "lock_rec_discard(ib_lock_t*)"
"lock_rec_free_all_from_discard_page(const buf_block_t*)" -> "buf_block_get_page_no(const buf_block_t*)"
"lock_rec_free_all_from_discard_page(const buf_block_t*)" -> "lock_rec_get_first_on_page_addr(ulint,ulint)"
"lock_rec_free_all_from_discard_page(const buf_block_t*)" -> "lock_rec_get_next_on_page(ib_lock_t*)"
"lock_rec_discard(ib_lock_t*)" -> "hash_calc_hash(ulint,hash_table_t*)"
"lock_rec_discard(ib_lock_t*)" -> "ut_dbg_assertion_failed(const char*,const char*,ulint)"
"lock_rec_discard(ib_lock_t*)" -> "abort()"
"lock_rec_discard(ib_lock_t*)" -> "hash_get_nth_cell(hash_table_t*,ulint)"
"lock_rec_discard(ib_lock_t*)" -> "__builtin_expect(long int,long int)"
"lock_rec_discard(ib_lock_t*)" -> "ut_list_remove(List&,Type&,size_t) [with List = ut_list_base<ib_lock_t>,Type = ib_lock_t,size_t = long unsigned int]"
"lock_rec_discard(ib_lock_t*)" -> "lock_rec_fold(ulint,ulint)"
"btr_page_get_father_block(ulint*,mem_heap_t*,dict_index_t*,buf_block_t*,mtr_t*,btr_cur_t*)" -> "btr_page_get_father_node_ptr_func(ulint*,mem_heap_t*,btr_cur_t*,const char*,ulint,mtr_t*)"
"btr_page_get_father_block(ulint*,mem_heap_t*,dict_index_t*,buf_block_t*,mtr_t*,btr_cur_t*)" -> "btr_cur_position(dict_index_t*,rec_t*,buf_block_t*,btr_cur_t*)"
"btr_page_get_father_block(ulint*,mem_heap_t*,dict_index_t*,buf_block_t*,mtr_t*,btr_cur_t*)" -> "page_rec_get_next(rec_t*)"
"btr_page_get_father_block(ulint*,mem_heap_t*,dict_index_t*,buf_block_t*,mtr_t*,btr_cur_t*)" -> "page_get_infimum_offset(const ib_page_t*)"
"btr_page_get_father_node_ptr_func(ulint*,mem_heap_t*,btr_cur_t*,const char*,ulint,mtr_t*)" -> "dict_index_build_node_ptr(const dict_index_t*,const rec_t*,ulint,mem_heap_t*,ulint)"
"btr_page_get_father_node_ptr_func(ulint*,mem_heap_t*,btr_cur_t*,const char*,ulint,mtr_t*)" -> "btr_cur_search_to_nth_level(dict_index_t*,ulint,const dtuple_t*,ulint,ulint,btr_cur_t*,ulint,const char*,ulint,mtr_t*)"
"btr_page_get_father_node_ptr_func(ulint*,mem_heap_t*,btr_cur_t*,const char*,ulint,mtr_t*)" -> "page_align(const void*)"
"btr_page_get_father_node_ptr_func(ulint*,mem_heap_t*,btr_cur_t*,const char*,ulint,mtr_t*)" -> "page_rec_get_next(rec_t*)"
"btr_page_get_father_node_ptr_func(ulint*,mem_heap_t*,btr_cur_t*,const char*,ulint,mtr_t*)" -> "page_get_infimum_offset(const ib_page_t*)"
"btr_page_get_father_node_ptr_func(ulint*,mem_heap_t*,btr_cur_t*,const char*,ulint,mtr_t*)" -> "buf_block_get_page_no(const buf_block_t*)"
"btr_page_get_father_node_ptr_func(ulint*,mem_heap_t*,btr_cur_t*,const char*,ulint,mtr_t*)" -> "fprintf(FILE*,const char*,...)"
"btr_page_get_father_node_ptr_func(ulint*,mem_heap_t*,btr_cur_t*,const char*,ulint,mtr_t*)" -> "btr_cur_get_page(btr_cur_t*)"
"btr_page_get_father_node_ptr_func(ulint*,mem_heap_t*,btr_cur_t*,const char*,ulint,mtr_t*)" -> "buf_page_print(const unsigned char*,ulint,ulint)"
"btr_page_get_father_node_ptr_func(ulint*,mem_heap_t*,btr_cur_t*,const char*,ulint,mtr_t*)" -> "__builtin_fwrite(const void*,size_t,size_t,FILE*)"
"btr_page_get_father_node_ptr_func(ulint*,mem_heap_t*,btr_cur_t*,const char*,ulint,mtr_t*)" -> "__builtin_expect(long int,long int)"
"btr_page_get_father_node_ptr_func(ulint*,mem_heap_t*,btr_cur_t*,const char*,ulint,mtr_t*)" -> "btr_node_ptr_get_child_page_no(const rec_t*,const ulint*)"
"btr_page_get_father_node_ptr_func(ulint*,mem_heap_t*,btr_cur_t*,const char*,ulint,mtr_t*)" -> "page_rec_print(const rec_t*,const ulint*)"
"btr_page_get_father_node_ptr_func(ulint*,mem_heap_t*,btr_cur_t*,const char*,ulint,mtr_t*)" -> "abort()"
"btr_page_get_father_node_ptr_func(ulint*,mem_heap_t*,btr_cur_t*,const char*,ulint,mtr_t*)" -> "page_rec_is_user_rec(const rec_t*)"
"btr_page_get_father_node_ptr_func(ulint*,mem_heap_t*,btr_cur_t*,const char*,ulint,mtr_t*)" -> "ut_print_name(FILE*,const trx_t*,ulint,const char*)"
"btr_page_get_father_node_ptr_func(ulint*,mem_heap_t*,btr_cur_t*,const char*,ulint,mtr_t*)" -> "btr_page_get_level_low(const ib_page_t*)"
"btr_page_get_father_node_ptr_func(ulint*,mem_heap_t*,btr_cur_t*,const char*,ulint,mtr_t*)" -> "rec_get_offsets_func(const rec_t*,const dict_index_t*,ulint*,ulint,mem_heap_t**)"
"btr_page_get_father_node_ptr_func(ulint*,mem_heap_t*,btr_cur_t*,const char*,ulint,mtr_t*)" -> "ut_dbg_assertion_failed(const char*,const char*,ulint)"
"dict_index_build_node_ptr(const dict_index_t*,const rec_t*,ulint,mem_heap_t*,ulint)" -> "mach_write_to_4(unsigned char*,ulint)"
"dict_index_build_node_ptr(const dict_index_t*,const rec_t*,ulint,mem_heap_t*,ulint)" -> "__builtin_expect(long int,long int)"
"dict_index_build_node_ptr(const dict_index_t*,const rec_t*,ulint,mem_heap_t*,ulint)" -> "abort()"
"dict_index_build_node_ptr(const dict_index_t*,const rec_t*,ulint,mem_heap_t*,ulint)" -> "dtuple_create(mem_heap_t*,ulint)"
"dict_index_build_node_ptr(const dict_index_t*,const rec_t*,ulint,mem_heap_t*,ulint)" -> "dict_index_get_n_unique_in_tree(const dict_index_t*)"
"dict_index_build_node_ptr(const dict_index_t*,const rec_t*,ulint,mem_heap_t*,ulint)" -> "dict_index_is_univ(const dict_index_t*)"
"dict_index_build_node_ptr(const dict_index_t*,const rec_t*,ulint,mem_heap_t*,ulint)" -> "dtuple_set_n_fields_cmp(dtuple_t*,ulint)"
"dict_index_build_node_ptr(const dict_index_t*,const rec_t*,ulint,mem_heap_t*,ulint)" -> "dict_index_copy_types(dtuple_t*,const dict_index_t*,ulint)"
"dict_index_build_node_ptr(const dict_index_t*,const rec_t*,ulint,mem_heap_t*,ulint)" -> "dict_table_is_comp(const dict_table_t*)"
"dict_index_build_node_ptr(const dict_index_t*,const rec_t*,ulint,mem_heap_t*,ulint)" -> "rec_copy_prefix_to_dtuple(dtuple_t*,const rec_t*,const dict_index_t*,ulint,mem_heap_t*)"
"dict_index_build_node_ptr(const dict_index_t*,const rec_t*,ulint,mem_heap_t*,ulint)" -> "ut_dbg_assertion_failed(const char*,const char*,ulint)"
"dict_index_build_node_ptr(const dict_index_t*,const rec_t*,ulint,mem_heap_t*,ulint)" -> "dtuple_get_info_bits(const dtuple_t*)"
"dict_index_build_node_ptr(const dict_index_t*,const rec_t*,ulint,mem_heap_t*,ulint)" -> "dtype_set(dtype_t*,ulint,ulint,ulint)"
"dict_index_build_node_ptr(const dict_index_t*,const rec_t*,ulint,mem_heap_t*,ulint)" -> "rec_get_n_fields_old(const rec_t*)"
"dict_index_build_node_ptr(const dict_index_t*,const rec_t*,ulint,mem_heap_t*,ulint)" -> "dtuple_set_info_bits(dtuple_t*,ulint)"
"dict_index_build_node_ptr(const dict_index_t*,const rec_t*,ulint,mem_heap_t*,ulint)" -> "dfield_set_data(dfield_t*,const void*,ulint)"
"dict_index_build_node_ptr(const dict_index_t*,const rec_t*,ulint,mem_heap_t*,ulint)" -> "mem_heap_alloc(mem_heap_t*,ulint)"
"page_rec_print(const rec_t*,const ulint*)" -> "rec_validate(const rec_t*,const ulint*)"
"page_rec_print(const rec_t*,const ulint*)" -> "rec_get_n_owned_old(const rec_t*)"
"page_rec_print(const rec_t*,const ulint*)" -> "rec_get_heap_no_old(const rec_t*)"
"page_rec_print(const rec_t*,const ulint*)" -> "fprintf(FILE*,const char*,...)"
"page_rec_print(const rec_t*,const ulint*)" -> "page_rec_is_comp(const rec_t*)"
"page_rec_print(const rec_t*,const ulint*)" -> "ut_dbg_assertion_failed(const char*,const char*,ulint)"
"page_rec_print(const rec_t*,const ulint*)" -> "page_rec_check(const rec_t*)"
"page_rec_print(const rec_t*,const ulint*)" -> "rec_get_next_offs(const rec_t*,ulint)"
"page_rec_print(const rec_t*,const ulint*)" -> "rec_print_new(FILE*,const rec_t*,const ulint*)"
"page_rec_print(const rec_t*,const ulint*)" -> "abort()"
"page_rec_print(const rec_t*,const ulint*)" -> "rec_get_n_owned_new(const rec_t*)"
"page_rec_print(const rec_t*,const ulint*)" -> "__builtin_expect(long int,long int)"
"page_rec_print(const rec_t*,const ulint*)" -> "rec_offs_comp(const ulint*)"
"page_rec_print(const rec_t*,const ulint*)" -> "rec_get_heap_no_new(const rec_t*)"
"page_rec_check(const rec_t*)" -> "page_header_get_field(const ib_page_t*,ulint)"
"page_rec_check(const rec_t*)" -> "page_align(const void*)"
"page_rec_check(const rec_t*)" -> "page_offset(const void*)"
"page_rec_check(const rec_t*)" -> "ut_dbg_assertion_failed(const char*,const char*,ulint)"
"page_rec_check(const rec_t*)" -> "abort()"
"page_rec_check(const rec_t*)" -> "__builtin_expect(long int,long int)"
"page_rec_is_user_rec(const rec_t*)" -> "page_rec_is_user_rec_low(ulint)"
"page_rec_is_user_rec(const rec_t*)" -> "page_offset(const void*)"
"page_zip_copy_recs(page_zip_des_t*,ib_page_t*,const page_zip_des_t*,const ib_page_t*,dict_index_t*,mtr_t*)" -> "page_zip_compress_write_log(const page_zip_des_t*,const ib_page_t*,dict_index_t*,mtr_t*)"
"page_zip_copy_recs(page_zip_des_t*,ib_page_t*,const page_zip_des_t*,const ib_page_t*,dict_index_t*,mtr_t*)" -> "page_zip_get_size(const page_zip_des_t*)"
"page_zip_copy_recs(page_zip_des_t*,ib_page_t*,const page_zip_des_t*,const ib_page_t*,dict_index_t*,mtr_t*)" -> "__builtin_expect(long int,long int)"
"page_zip_copy_recs(page_zip_des_t*,ib_page_t*,const page_zip_des_t*,const ib_page_t*,dict_index_t*,mtr_t*)" -> "abort()"
"page_zip_copy_recs(page_zip_des_t*,ib_page_t*,const page_zip_des_t*,const ib_page_t*,dict_index_t*,mtr_t*)" -> "page_get_max_trx_id(const ib_page_t*)"
"page_zip_copy_recs(page_zip_des_t*,ib_page_t*,const page_zip_des_t*,const ib_page_t*,dict_index_t*,mtr_t*)" -> "mach_read_from_4(const unsigned char*)"
"page_zip_copy_recs(page_zip_des_t*,ib_page_t*,const page_zip_des_t*,const ib_page_t*,dict_index_t*,mtr_t*)" -> "ut_dbg_assertion_failed(const char*,const char*,ulint)"
"page_zip_copy_recs(page_zip_des_t*,ib_page_t*,const page_zip_des_t*,const ib_page_t*,dict_index_t*,mtr_t*)" -> "memcpy(void*,const void*,size_t)"
"page_zip_copy_recs(page_zip_des_t*,ib_page_t*,const page_zip_des_t*,const ib_page_t*,dict_index_t*,mtr_t*)" -> "page_is_leaf(const ib_page_t*)"
"page_zip_copy_recs(page_zip_des_t*,ib_page_t*,const page_zip_des_t*,const ib_page_t*,dict_index_t*,mtr_t*)" -> "dict_index_is_clust(const dict_index_t*)"
"page_zip_copy_recs(page_zip_des_t*,ib_page_t*,const page_zip_des_t*,const ib_page_t*,dict_index_t*,mtr_t*)" -> "rec_get_next_offs(const rec_t*,ulint)"
"btr_node_ptr_delete(dict_index_t*,buf_block_t*,mtr_t*)" -> "ut_dbg_assertion_failed(const char*,const char*,ulint)"
"btr_node_ptr_delete(dict_index_t*,buf_block_t*,mtr_t*)" -> "btr_cur_pessimistic_delete(dberr_t*,ulint,btr_cur_t*,ulint,trx_rb_ctx,mtr_t*)"
"btr_node_ptr_delete(dict_index_t*,buf_block_t*,mtr_t*)" -> "__builtin_expect(long int,long int)"
"btr_node_ptr_delete(dict_index_t*,buf_block_t*,mtr_t*)" -> "btr_cur_compress_if_useful(btr_cur_t*,ulint,mtr_t*)"
"btr_node_ptr_delete(dict_index_t*,buf_block_t*,mtr_t*)" -> "abort()"
"btr_node_ptr_delete(dict_index_t*,buf_block_t*,mtr_t*)" -> "btr_page_get_father(dict_index_t*,buf_block_t*,mtr_t*,btr_cur_t*)"
"btr_page_get_father(dict_index_t*,buf_block_t*,mtr_t*,btr_cur_t*)" -> "mem_heap_create_func(ulint,ulint)"
"btr_page_get_father(dict_index_t*,buf_block_t*,mtr_t*,btr_cur_t*)" -> "page_get_infimum_offset(const ib_page_t*)"
"btr_page_get_father(dict_index_t*,buf_block_t*,mtr_t*,btr_cur_t*)" -> "btr_page_get_father_node_ptr_func(ulint*,mem_heap_t*,btr_cur_t*,const char*,ulint,mtr_t*)"
"btr_page_get_father(dict_index_t*,buf_block_t*,mtr_t*,btr_cur_t*)" -> "btr_cur_position(dict_index_t*,rec_t*,buf_block_t*,btr_cur_t*)"
"btr_page_get_father(dict_index_t*,buf_block_t*,mtr_t*,btr_cur_t*)" -> "mem_heap_free_func(mem_heap_t*,const char*,ulint)"
"btr_page_get_father(dict_index_t*,buf_block_t*,mtr_t*,btr_cur_t*)" -> "page_rec_get_next(rec_t*)"
"page_copy_rec_list_start(buf_block_t*,buf_block_t*,rec_t*,dict_index_t*,mtr_t*)" -> "rec_get_offsets_func(const rec_t*,const dict_index_t*,ulint*,ulint,mem_heap_t**)"
"page_copy_rec_list_start(buf_block_t*,buf_block_t*,rec_t*,dict_index_t*,mtr_t*)" -> "abort()"
"page_copy_rec_list_start(buf_block_t*,buf_block_t*,rec_t*,dict_index_t*,mtr_t*)" -> "page_rec_is_infimum(const rec_t*)"
"page_copy_rec_list_start(buf_block_t*,buf_block_t*,rec_t*,dict_index_t*,mtr_t*)" -> "rec_offs_set_n_alloc(ulint*,ulint)"
"page_copy_rec_list_start(buf_block_t*,buf_block_t*,rec_t*,dict_index_t*,mtr_t*)" -> "page_zip_reorganize(buf_block_t*,dict_index_t*,mtr_t*)"
"page_copy_rec_list_start(buf_block_t*,buf_block_t*,rec_t*,dict_index_t*,mtr_t*)" -> "page_rec_get_prev(rec_t*)"
"page_copy_rec_list_start(buf_block_t*,buf_block_t*,rec_t*,dict_index_t*,mtr_t*)" -> "btr_search_move_or_delete_hash_entries(buf_block_t*,buf_block_t*,dict_index_t*)"
"page_copy_rec_list_start(buf_block_t*,buf_block_t*,rec_t*,dict_index_t*,mtr_t*)" -> "ut_dbg_assertion_failed(const char*,const char*,ulint)"
"page_copy_rec_list_start(buf_block_t*,buf_block_t*,rec_t*,dict_index_t*,mtr_t*)" -> "page_is_leaf(const ib_page_t*)"
"page_copy_rec_list_start(buf_block_t*,buf_block_t*,rec_t*,dict_index_t*,mtr_t*)" -> "page_cur_set_before_first(const buf_block_t*,page_cur_t*)"
"page_copy_rec_list_start(buf_block_t*,buf_block_t*,rec_t*,dict_index_t*,mtr_t*)" -> "mtr_set_log_mode(mtr_t*,ulint)"
"page_copy_rec_list_start(buf_block_t*,buf_block_t*,rec_t*,dict_index_t*,mtr_t*)" -> "page_rec_get_nth(ib_page_t*,ulint)"
"page_copy_rec_list_start(buf_block_t*,buf_block_t*,rec_t*,dict_index_t*,mtr_t*)" -> "page_get_max_trx_id(const ib_page_t*)"
"page_copy_rec_list_start(buf_block_t*,buf_block_t*,rec_t*,dict_index_t*,mtr_t*)" -> "mem_heap_free_func(mem_heap_t*,const char*,ulint)"
"page_copy_rec_list_start(buf_block_t*,buf_block_t*,rec_t*,dict_index_t*,mtr_t*)" -> "page_cur_insert_rec_low(rec_t*,dict_index_t*,const rec_t*,ulint*,mtr_t*)"
"page_copy_rec_list_start(buf_block_t*,buf_block_t*,rec_t*,dict_index_t*,mtr_t*)" -> "dict_index_is_sec_or_ibuf(const dict_index_t*)"
"page_copy_rec_list_start(buf_block_t*,buf_block_t*,rec_t*,dict_index_t*,mtr_t*)" -> "page_zip_compress(page_zip_des_t*,const ib_page_t*,dict_index_t*,ulint,mtr_t*)"
"page_copy_rec_list_start(buf_block_t*,buf_block_t*,rec_t*,dict_index_t*,mtr_t*)" -> "page_zip_decompress(page_zip_des_t*,ib_page_t*,ulint)"
"page_copy_rec_list_start(buf_block_t*,buf_block_t*,rec_t*,dict_index_t*,mtr_t*)" -> "page_rec_get_n_recs_before(const rec_t*)"
"page_copy_rec_list_start(buf_block_t*,buf_block_t*,rec_t*,dict_index_t*,mtr_t*)" -> "page_align(const void*)"
"page_copy_rec_list_start(buf_block_t*,buf_block_t*,rec_t*,dict_index_t*,mtr_t*)" -> "__builtin_expect(long int,long int)"
"page_copy_rec_list_start(buf_block_t*,buf_block_t*,rec_t*,dict_index_t*,mtr_t*)" -> "page_cur_move_to_next(page_cur_t*)"
"page_copy_rec_list_start(buf_block_t*,buf_block_t*,rec_t*,dict_index_t*,mtr_t*)" -> "page_get_supremum_offset(const ib_page_t*)"
"page_copy_rec_list_start(buf_block_t*,buf_block_t*,rec_t*,dict_index_t*,mtr_t*)" -> "page_update_max_trx_id(buf_block_t*,page_zip_des_t*,trx_id_t,mtr_t*)"
"page_copy_rec_list_start(buf_block_t*,buf_block_t*,rec_t*,dict_index_t*,mtr_t*)" -> "lock_move_rec_list_start(const buf_block_t*,const buf_block_t*,const rec_t*,const rec_t*)"
"lock_move_rec_list_start(const buf_block_t*,const buf_block_t*,const rec_t*,const rec_t*)" -> "page_cur_move_to_next(page_cur_t*)"
"lock_move_rec_list_start(const buf_block_t*,const buf_block_t*,const rec_t*,const rec_t*)" -> "lock_rec_get_nth_bit(const ib_lock_t*,ulint)"
"lock_move_rec_list_start(const buf_block_t*,const buf_block_t*,const rec_t*,const rec_t*)" -> "pfs_mutex_enter_func(ib_mutex_t*,const char*,ulint)"
"lock_move_rec_list_start(const buf_block_t*,const buf_block_t*,const rec_t*,const rec_t*)" -> "rec_get_heap_no_new(const rec_t*)"
"lock_move_rec_list_start(const buf_block_t*,const buf_block_t*,const rec_t*,const rec_t*)" -> "page_cur_set_before_first(const buf_block_t*,page_cur_t*)"
"lock_move_rec_list_start(const buf_block_t*,const buf_block_t*,const rec_t*,const rec_t*)" -> "__builtin_expect(long int,long int)"
"lock_move_rec_list_start(const buf_block_t*,const buf_block_t*,const rec_t*,const rec_t*)" -> "page_cur_position(const rec_t*,const buf_block_t*,page_cur_t*)"
"lock_move_rec_list_start(const buf_block_t*,const buf_block_t*,const rec_t*,const rec_t*)" -> "page_rec_is_comp(const rec_t*)"
"lock_move_rec_list_start(const buf_block_t*,const buf_block_t*,const rec_t*,const rec_t*)" -> "pfs_mutex_exit_func(ib_mutex_t*)"
"lock_move_rec_list_start(const buf_block_t*,const buf_block_t*,const rec_t*,const rec_t*)" -> "lock_rec_add_to_queue(ulint,const buf_block_t*,ulint,dict_index_t*,trx_t*,ulint)"
"lock_move_rec_list_start(const buf_block_t*,const buf_block_t*,const rec_t*,const rec_t*)" -> "lock_rec_reset_nth_bit(ib_lock_t*,ulint)"
"lock_move_rec_list_start(const buf_block_t*,const buf_block_t*,const rec_t*,const rec_t*)" -> "lock_reset_lock_and_trx_wait(ib_lock_t*)"
"lock_move_rec_list_start(const buf_block_t*,const buf_block_t*,const rec_t*,const rec_t*)" -> "lock_rec_get_next_on_page(ib_lock_t*)"
"lock_move_rec_list_start(const buf_block_t*,const buf_block_t*,const rec_t*,const rec_t*)" -> "rec_get_heap_no_old(const rec_t*)"
"lock_move_rec_list_start(const buf_block_t*,const buf_block_t*,const rec_t*,const rec_t*)" -> "lock_rec_get_first_on_page(const buf_block_t*)"
"lock_update_merge_left(const buf_block_t*,const rec_t*,const buf_block_t*)" -> "page_rec_get_next_const(const rec_t*)"
"lock_update_merge_left(const buf_block_t*,const rec_t*,const buf_block_t*)" -> "page_rec_is_supremum(const rec_t*)"
"lock_update_merge_left(const buf_block_t*,const rec_t*,const buf_block_t*)" -> "lock_rec_reset_and_release_wait(const buf_block_t*,ulint)"
"lock_update_merge_left(const buf_block_t*,const rec_t*,const buf_block_t*)" -> "lock_rec_inherit_to_gap(const buf_block_t*,const buf_block_t*,ulint,ulint)"
"lock_update_merge_left(const buf_block_t*,const rec_t*,const buf_block_t*)" -> "pfs_mutex_enter_func(ib_mutex_t*,const char*,ulint)"
"lock_update_merge_left(const buf_block_t*,const rec_t*,const buf_block_t*)" -> "lock_rec_move(const buf_block_t*,const buf_block_t*,ulint,ulint)"
"lock_update_merge_left(const buf_block_t*,const rec_t*,const buf_block_t*)" -> "pfs_mutex_exit_func(ib_mutex_t*)"
"lock_update_merge_left(const buf_block_t*,const rec_t*,const buf_block_t*)" -> "lock_rec_free_all_from_discard_page(const buf_block_t*)"
"lock_update_merge_left(const buf_block_t*,const rec_t*,const buf_block_t*)" -> "page_rec_get_heap_no(const rec_t*)"
"btr_level_list_remove_func(ulint,ulint,ib_page_t*,mtr_t*)" -> "__builtin_expect(long int,long int)"
"btr_level_list_remove_func(ulint,ulint,ib_page_t*,mtr_t*)" -> "btr_page_set_next(ib_page_t*,page_zip_des_t*,ulint,mtr_t*)"
"btr_level_list_remove_func(ulint,ulint,ib_page_t*,mtr_t*)" -> "page_is_comp(const ib_page_t*)"
"btr_level_list_remove_func(ulint,ulint,ib_page_t*,mtr_t*)" -> "ut_dbg_assertion_failed(const char*,const char*,ulint)"
"btr_level_list_remove_func(ulint,ulint,ib_page_t*,mtr_t*)" -> "btr_page_set_prev(ib_page_t*,page_zip_des_t*,ulint,mtr_t*)"
"btr_level_list_remove_func(ulint,ulint,ib_page_t*,mtr_t*)" -> "btr_page_get_next(const ib_page_t*,mtr_t*)"
"btr_level_list_remove_func(ulint,ulint,ib_page_t*,mtr_t*)" -> "btr_page_get_prev(const ib_page_t*,mtr_t*)"
"btr_level_list_remove_func(ulint,ulint,ib_page_t*,mtr_t*)" -> "abort()"
"btr_level_list_remove_func(ulint,ulint,ib_page_t*,mtr_t*)" -> "page_get_page_no(const ib_page_t*)"
"btr_level_list_remove_func(ulint,ulint,ib_page_t*,mtr_t*)" -> "btr_block_get_func(ulint,ulint,ulint,ulint,const char*,ulint,mtr_t*)"
"btr_page_set_next(ib_page_t*,page_zip_des_t*,ulint,mtr_t*)" -> "mach_write_to_4(unsigned char*,ulint)"
"btr_page_set_next(ib_page_t*,page_zip_des_t*,ulint,mtr_t*)" -> "mlog_write_ulint(unsigned char*,ulint,unsigned char,mtr_t*)"
"btr_page_set_next(ib_page_t*,page_zip_des_t*,ulint,mtr_t*)" -> "page_zip_write_header(page_zip_des_t*,const unsigned char*,ulint,mtr_t*)"
"btr_page_set_prev(ib_page_t*,page_zip_des_t*,ulint,mtr_t*)" -> "mach_write_to_4(unsigned char*,ulint)"
"btr_page_set_prev(ib_page_t*,page_zip_des_t*,ulint,mtr_t*)" -> "mlog_write_ulint(unsigned char*,ulint,unsigned char,mtr_t*)"
"btr_page_set_prev(ib_page_t*,page_zip_des_t*,ulint,mtr_t*)" -> "page_zip_write_header(page_zip_des_t*,const unsigned char*,ulint,mtr_t*)"
"ibuf_update_free_bits_if_full(buf_block_t*,ulint,ulint)" -> "ibuf_index_page_calc_free_bits(ulint,ulint)"
"ibuf_update_free_bits_if_full(buf_block_t*,ulint,ulint)" -> "ibuf_set_free_bits_func(buf_block_t*,ulint)"
"ibuf_update_free_bits_if_full(buf_block_t*,ulint,ulint)" -> "ibuf_index_page_calc_free(ulint,const buf_block_t*)"
"ibuf_update_free_bits_if_full(buf_block_t*,ulint,ulint)" -> "buf_page_make_young(buf_page_t*)"
"btr_can_merge_with_page(btr_cur_t*,ulint,buf_block_t**,mtr_t*)" -> "dict_index_zip_pad_optimal_page_size(dict_index_t*)"
"btr_can_merge_with_page(btr_cur_t*,ulint,buf_block_t**,mtr_t*)" -> "page_get_max_insert_size(const ib_page_t*,ulint)"
"btr_can_merge_with_page(btr_cur_t*,ulint,buf_block_t**,mtr_t*)" -> "page_get_max_insert_size_after_reorganize(const ib_page_t*,ulint)"
"btr_can_merge_with_page(btr_cur_t*,ulint,buf_block_t**,mtr_t*)" -> "btr_block_get_func(ulint,ulint,ulint,ulint,const char*,ulint,mtr_t*)"
"btr_can_merge_with_page(btr_cur_t*,ulint,buf_block_t**,mtr_t*)" -> "page_get_data_size(const ib_page_t*)"
"btr_can_merge_with_page(btr_cur_t*,ulint,buf_block_t**,mtr_t*)" -> "btr_page_reorganize_block(bool,ulint,buf_block_t*,dict_index_t*,mtr_t*)"
"btr_can_merge_with_page(btr_cur_t*,ulint,buf_block_t**,mtr_t*)" -> "page_is_leaf(const ib_page_t*)"
"btr_can_merge_with_page(btr_cur_t*,ulint,buf_block_t**,mtr_t*)" -> "dict_index_get_space(const dict_index_t*)"
"btr_can_merge_with_page(btr_cur_t*,ulint,buf_block_t**,mtr_t*)" -> "btr_cur_get_page(btr_cur_t*)"
"btr_can_merge_with_page(btr_cur_t*,ulint,buf_block_t**,mtr_t*)" -> "page_get_n_recs(const ib_page_t*)"
"btr_can_merge_with_page(btr_cur_t*,ulint,buf_block_t**,mtr_t*)" -> "dict_table_zip_size(const dict_table_t*)"
"btr_page_reorganize_block(bool,ulint,buf_block_t*,dict_index_t*,mtr_t*)" -> "page_cur_set_before_first(const buf_block_t*,page_cur_t*)"
"btr_page_reorganize_block(bool,ulint,buf_block_t*,dict_index_t*,mtr_t*)" -> "btr_page_reorganize_low(bool,ulint,page_cur_t*,dict_index_t*,mtr_t*)"
"lock_update_merge_right(const buf_block_t*,const rec_t*,const buf_block_t*)" -> "pfs_mutex_enter_func(ib_mutex_t*,const char*,ulint)"
"lock_update_merge_right(const buf_block_t*,const rec_t*,const buf_block_t*)" -> "page_rec_get_heap_no(const rec_t*)"
"lock_update_merge_right(const buf_block_t*,const rec_t*,const buf_block_t*)" -> "lock_rec_inherit_to_gap(const buf_block_t*,const buf_block_t*,ulint,ulint)"
"lock_update_merge_right(const buf_block_t*,const rec_t*,const buf_block_t*)" -> "lock_rec_reset_and_release_wait(const buf_block_t*,ulint)"
"lock_update_merge_right(const buf_block_t*,const rec_t*,const buf_block_t*)" -> "pfs_mutex_exit_func(ib_mutex_t*)"
"lock_update_merge_right(const buf_block_t*,const rec_t*,const buf_block_t*)" -> "lock_rec_free_all_from_discard_page(const buf_block_t*)"
"btr_rec_free_externally_stored_fields(dict_index_t*,rec_t*,const ulint*,page_zip_des_t*,trx_rb_ctx,mtr_t*)" -> "btr_rec_get_field_ref_offs(const ulint*,ulint)"
"btr_rec_free_externally_stored_fields(dict_index_t*,rec_t*,const ulint*,page_zip_des_t*,trx_rb_ctx,mtr_t*)" -> "rec_offs_n_fields(const ulint*)"
"btr_rec_free_externally_stored_fields(dict_index_t*,rec_t*,const ulint*,page_zip_des_t*,trx_rb_ctx,mtr_t*)" -> "rec_offs_nth_extern(const ulint*,ulint)"
"btr_rec_free_externally_stored_fields(dict_index_t*,rec_t*,const ulint*,page_zip_des_t*,trx_rb_ctx,mtr_t*)" -> "btr_free_externally_stored_field(dict_index_t*,unsigned char*,const rec_t*,const ulint*,page_zip_des_t*,ulint,trx_rb_ctx,mtr_t*)"
"btr_rec_get_field_ref_offs(const ulint*,ulint)" -> "rec_offs_nth_extern(const ulint*,ulint)"
"btr_rec_get_field_ref_offs(const ulint*,ulint)" -> "abort()"
"btr_rec_get_field_ref_offs(const ulint*,ulint)" -> "__builtin_expect(long int,long int)"
"btr_rec_get_field_ref_offs(const ulint*,ulint)" -> "ut_dbg_assertion_failed(const char*,const char*,ulint)"
"btr_rec_get_field_ref_offs(const ulint*,ulint)" -> "rec_get_nth_field_offs(const ulint*,ulint,ulint*)"
"btr_free_externally_stored_field(dict_index_t*,unsigned char*,const rec_t*,const ulint*,page_zip_des_t*,ulint,trx_rb_ctx,mtr_t*)" -> "btr_page_free_low(dict_index_t*,buf_block_t*,ulint,mtr_t*)"
"btr_free_externally_stored_field(dict_index_t*,unsigned char*,const rec_t*,const ulint*,page_zip_des_t*,ulint,trx_rb_ctx,mtr_t*)" -> "mlog_write_ulint(unsigned char*,ulint,unsigned char,mtr_t*)"
"btr_free_externally_stored_field(dict_index_t*,unsigned char*,const rec_t*,const ulint*,page_zip_des_t*,ulint,trx_rb_ctx,mtr_t*)" -> "btr_blob_free(buf_block_t*,ulint,mtr_t*)"
"btr_free_externally_stored_field(dict_index_t*,unsigned char*,const rec_t*,const ulint*,page_zip_des_t*,ulint,trx_rb_ctx,mtr_t*)" -> "buf_page_get_gen(ulint,ulint,ulint,ulint,buf_block_t*,ulint,const char*,ulint,mtr_t*)"
"btr_free_externally_stored_field(dict_index_t*,unsigned char*,const rec_t*,const ulint*,page_zip_des_t*,ulint,trx_rb_ctx,mtr_t*)" -> "ut_dbg_assertion_failed(const char*,const char*,ulint)"
"btr_free_externally_stored_field(dict_index_t*,unsigned char*,const rec_t*,const ulint*,page_zip_des_t*,ulint,trx_rb_ctx,mtr_t*)" -> "dict_table_zip_size(const dict_table_t*)"
"btr_free_externally_stored_field(dict_index_t*,unsigned char*,const rec_t*,const ulint*,page_zip_des_t*,ulint,trx_rb_ctx,mtr_t*)" -> "mtr_start(mtr_t*)"
"btr_free_externally_stored_field(dict_index_t*,unsigned char*,const rec_t*,const ulint*,page_zip_des_t*,ulint,trx_rb_ctx,mtr_t*)" -> "btr_check_blob_fil_page_type(ulint,ulint,const ib_page_t*,ulint)"
"btr_free_externally_stored_field(dict_index_t*,unsigned char*,const rec_t*,const ulint*,page_zip_des_t*,ulint,trx_rb_ctx,mtr_t*)" -> "page_zip_write_blob_ptr(page_zip_des_t*,const unsigned char*,dict_index_t*,const ulint*,ulint,mtr_t*)"
"btr_free_externally_stored_field(dict_index_t*,unsigned char*,const rec_t*,const ulint*,page_zip_des_t*,ulint,trx_rb_ctx,mtr_t*)" -> "row_log_table_blob_free(dict_index_t*,ulint)"
"btr_free_externally_stored_field(dict_index_t*,unsigned char*,const rec_t*,const ulint*,page_zip_des_t*,ulint,trx_rb_ctx,mtr_t*)" -> "mach_read_from_1(const unsigned char*)"
"btr_free_externally_stored_field(dict_index_t*,unsigned char*,const rec_t*,const ulint*,page_zip_des_t*,ulint,trx_rb_ctx,mtr_t*)" -> "fil_page_get_type(const unsigned char*)"
"btr_free_externally_stored_field(dict_index_t*,unsigned char*,const rec_t*,const ulint*,page_zip_des_t*,ulint,trx_rb_ctx,mtr_t*)" -> "fil_space_get_zip_size(ulint)"
"btr_free_externally_stored_field(dict_index_t*,unsigned char*,const rec_t*,const ulint*,page_zip_des_t*,ulint,trx_rb_ctx,mtr_t*)" -> "page_align(const void*)"
"btr_free_externally_stored_field(dict_index_t*,unsigned char*,const rec_t*,const ulint*,page_zip_des_t*,ulint,trx_rb_ctx,mtr_t*)" -> "dict_index_is_online_ddl(const dict_index_t*)"
"btr_free_externally_stored_field(dict_index_t*,unsigned char*,const rec_t*,const ulint*,page_zip_des_t*,ulint,trx_rb_ctx,mtr_t*)" -> "memcmp(const void*,const void*,size_t)"
"btr_free_externally_stored_field(dict_index_t*,unsigned char*,const rec_t*,const ulint*,page_zip_des_t*,ulint,trx_rb_ctx,mtr_t*)" -> "mtr_commit(mtr_t*)"
"btr_free_externally_stored_field(dict_index_t*,unsigned char*,const rec_t*,const ulint*,page_zip_des_t*,ulint,trx_rb_ctx,mtr_t*)" -> "page_get_page_no(const ib_page_t*)"
"btr_free_externally_stored_field(dict_index_t*,unsigned char*,const rec_t*,const ulint*,page_zip_des_t*,ulint,trx_rb_ctx,mtr_t*)" -> "page_get_space_id(const ib_page_t*)"
"btr_free_externally_stored_field(dict_index_t*,unsigned char*,const rec_t*,const ulint*,page_zip_des_t*,ulint,trx_rb_ctx,mtr_t*)" -> "dict_index_get_space(const dict_index_t*)"
"btr_free_externally_stored_field(dict_index_t*,unsigned char*,const rec_t*,const ulint*,page_zip_des_t*,ulint,trx_rb_ctx,mtr_t*)" -> "__builtin_expect(long int,long int)"
"btr_free_externally_stored_field(dict_index_t*,unsigned char*,const rec_t*,const ulint*,page_zip_des_t*,ulint,trx_rb_ctx,mtr_t*)" -> "mach_write_to_4(unsigned char*,ulint)"
"btr_free_externally_stored_field(dict_index_t*,unsigned char*,const rec_t*,const ulint*,page_zip_des_t*,ulint,trx_rb_ctx,mtr_t*)" -> "abort()"
"btr_free_externally_stored_field(dict_index_t*,unsigned char*,const rec_t*,const ulint*,page_zip_des_t*,ulint,trx_rb_ctx,mtr_t*)" -> "mach_read_from_4(const unsigned char*)"
"btr_blob_free(buf_block_t*,ulint,mtr_t*)" -> "buf_LRU_free_page(buf_page_t*,bool)"
"btr_blob_free(buf_block_t*,ulint,mtr_t*)" -> "mtr_commit(mtr_t*)"
"btr_blob_free(buf_block_t*,ulint,mtr_t*)" -> "buf_block_get_page_no(const buf_block_t*)"
"btr_blob_free(buf_block_t*,ulint,mtr_t*)" -> "buf_pool_from_block(const buf_block_t*)"
"btr_blob_free(buf_block_t*,ulint,mtr_t*)" -> "buf_block_get_space(const buf_block_t*)"
"btr_blob_free(buf_block_t*,ulint,mtr_t*)" -> "buf_block_get_state(const buf_block_t*)"
"btr_blob_free(buf_block_t*,ulint,mtr_t*)" -> "pfs_mutex_exit_func(ib_mutex_t*)"
"btr_blob_free(buf_block_t*,ulint,mtr_t*)" -> "pfs_mutex_enter_func(ib_mutex_t*,const char*,ulint)"
"buf_LRU_free_page(buf_page_t*,bool)" -> "btr_search_drop_page_hash_index(buf_block_t*)"
"buf_LRU_free_page(buf_page_t*,bool)" -> "buf_LRU_add_block_low(buf_page_t*,ulint)"
"buf_LRU_free_page(buf_page_t*,bool)" -> "pfs_rw_lock_x_lock_func(rw_lock_t*,ulint,const char*,ulint)"
"buf_LRU_free_page(buf_page_t*,bool)" -> "pfs_rw_lock_x_unlock_func(rw_lock_t*)"
"buf_LRU_free_page(buf_page_t*,bool)" -> "buf_pool_from_bpage(const buf_page_t*)"
"buf_LRU_free_page(buf_page_t*,bool)" -> "ut_dbg_assertion_failed(const char*,const char*,ulint)"
"buf_LRU_free_page(buf_page_t*,bool)" -> "ut_list_insert(List&,Type&,Type&,size_t) [with List = ut_list_base<buf_page_t>,Type = buf_page_t,size_t = long unsigned int]"
"buf_LRU_free_page(buf_page_t*,bool)" -> "buf_page_hash_get_low(buf_pool_t*,ulint,ulint,ulint)"
"buf_LRU_free_page(buf_page_t*,bool)" -> "mach_write_to_4(unsigned char*,ulint)"
"buf_LRU_free_page(buf_page_t*,bool)" -> "buf_LRU_block_remove_hashed(buf_page_t*,bool)"
"buf_LRU_free_page(buf_page_t*,bool)" -> "buf_page_can_relocate(const buf_page_t*)"
"buf_LRU_free_page(buf_page_t*,bool)" -> "buf_LRU_old_init(buf_pool_t*)"
"buf_LRU_free_page(buf_page_t*,bool)" -> "page_zip_calc_checksum(const void*,ulint,srv_checksum_algorithm_t)"
"buf_LRU_free_page(buf_page_t*,bool)" -> "buf_page_get_mutex(const buf_page_t*)"
"buf_LRU_free_page(buf_page_t*,bool)" -> "buf_page_alloc_descriptor()"
"buf_LRU_free_page(buf_page_t*,bool)" -> "buf_page_is_old(const buf_page_t*)"
"buf_LRU_free_page(buf_page_t*,bool)" -> "hash_calc_hash(ulint,hash_table_t*)"
"buf_LRU_free_page(buf_page_t*,bool)" -> "buf_page_unset_sticky(buf_page_t*)"
"buf_LRU_free_page(buf_page_t*,bool)" -> "buf_page_get_state(const buf_page_t*)"
"buf_LRU_free_page(buf_page_t*,bool)" -> "page_zip_set_size(page_zip_des_t*,ulint)"
"buf_LRU_free_page(buf_page_t*,bool)" -> "incr_LRU_size_in_bytes(buf_page_t*,buf_pool_t*)"
"buf_LRU_free_page(buf_page_t*,bool)" -> "hash_get_nth_cell(hash_table_t*,ulint)"
"buf_LRU_free_page(buf_page_t*,bool)" -> "buf_flush_relocate_on_flush_list(buf_page_t*,buf_page_t*)"
"buf_LRU_free_page(buf_page_t*,bool)" -> "buf_LRU_block_free_hashed_page(buf_block_t*)"
"buf_LRU_free_page(buf_page_t*,bool)" -> "buf_page_address_fold(ulint,ulint)"
"buf_LRU_free_page(buf_page_t*,bool)" -> "hash_get_lock(hash_table_t*,ulint)"
"buf_LRU_free_page(buf_page_t*,bool)" -> "pfs_mutex_exit_func(ib_mutex_t*)"
"buf_LRU_free_page(buf_page_t*,bool)" -> "memcpy(void*,const void*,size_t)"
"buf_LRU_free_page(buf_page_t*,bool)" -> "page_zip_get_size(const page_zip_des_t*)"
"buf_LRU_free_page(buf_page_t*,bool)" -> "__builtin_expect(long int,long int)"
"buf_LRU_free_page(buf_page_t*,bool)" -> "pfs_mutex_enter_func(ib_mutex_t*,const char*,ulint)"
"buf_LRU_free_page(buf_page_t*,bool)" -> "buf_LRU_old_adjust_len(buf_pool_t*)"
"buf_LRU_free_page(buf_page_t*,bool)" -> "abort()"
"buf_LRU_free_page(buf_page_t*,bool)" -> "buf_page_set_sticky(buf_page_t*)"
"buf_page_alloc_descriptor()" -> "ut_malloc_low(ulint,ulint)"
"buf_flush_relocate_on_flush_list(buf_page_t*,buf_page_t*)" -> "buf_flush_update_hp(buf_pool_t*,buf_page_t*)"
"buf_flush_relocate_on_flush_list(buf_page_t*,buf_page_t*)" -> "buf_flush_delete_from_flush_rbt(buf_page_t*)"
"buf_flush_relocate_on_flush_list(buf_page_t*,buf_page_t*)" -> "buf_flush_insert_in_flush_rbt(buf_page_t*)"
"buf_flush_relocate_on_flush_list(buf_page_t*,buf_page_t*)" -> "abort()"
"buf_flush_relocate_on_flush_list(buf_page_t*,buf_page_t*)" -> "__builtin_expect(long int,long int)"
"buf_flush_relocate_on_flush_list(buf_page_t*,buf_page_t*)" -> "ut_list_insert(List&,Type&,Type&,size_t) [with List = ut_list_base<buf_page_t>,Type = buf_page_t,size_t = long unsigned int]"
"buf_flush_relocate_on_flush_list(buf_page_t*,buf_page_t*)" -> "ut_dbg_assertion_failed(const char*,const char*,ulint)"
"buf_flush_relocate_on_flush_list(buf_page_t*,buf_page_t*)" -> "pfs_mutex_exit_func(ib_mutex_t*)"
"buf_flush_relocate_on_flush_list(buf_page_t*,buf_page_t*)" -> "ut_list_prepend(List&,Type&,size_t) [with List = ut_list_base<buf_page_t>,Type = buf_page_t,size_t = long unsigned int]"
"buf_flush_relocate_on_flush_list(buf_page_t*,buf_page_t*)" -> "pfs_mutex_enter_func(ib_mutex_t*,const char*,ulint)"
"buf_flush_relocate_on_flush_list(buf_page_t*,buf_page_t*)" -> "buf_pool_from_bpage(const buf_page_t*)"
"buf_flush_relocate_on_flush_list(buf_page_t*,buf_page_t*)" -> "ut_list_remove(List&,Type&,size_t) [with List = ut_list_base<buf_page_t>,Type = buf_page_t,size_t = long unsigned int]"
"buf_flush_update_hp(buf_pool_t*,buf_page_t*)" -> "buf_flush_set_hp(buf_pool_t*,const buf_page_t*)"
"buf_flush_update_hp(buf_pool_t*,buf_page_t*)" -> "buf_flush_is_hp(buf_pool_t*,const buf_page_t*)"
"buf_flush_delete_from_flush_rbt(buf_page_t*)" -> "rbt_delete(ib_rbt_t*,const void*)"
"buf_flush_delete_from_flush_rbt(buf_page_t*)" -> "buf_pool_from_bpage(const buf_page_t*)"
"rbt_delete(ib_rbt_t*,const void*)" -> "rbt_lookup(const ib_rbt_t*,const void*)"
"rbt_delete(ib_rbt_t*,const void*)" -> "ut_free(void*)"
"rbt_delete(ib_rbt_t*,const void*)" -> "rbt_remove_node_and_rebalance(ib_rbt_t*,ib_rbt_node_t*)"
"btr_check_blob_fil_page_type(ulint,ulint,const ib_page_t*,ulint)" -> "fil_space_get_flags(ulint)"
"btr_check_blob_fil_page_type(ulint,ulint,const ib_page_t*,ulint)" -> "fil_page_get_type(const unsigned char*)"
"btr_check_blob_fil_page_type(ulint,ulint,const ib_page_t*,ulint)" -> "ut_print_timestamp(FILE*)"
"btr_check_blob_fil_page_type(ulint,ulint,const ib_page_t*,ulint)" -> "__builtin_expect(long int,long int)"
"btr_check_blob_fil_page_type(ulint,ulint,const ib_page_t*,ulint)" -> "page_get_space_id(const ib_page_t*)"
"btr_check_blob_fil_page_type(ulint,ulint,const ib_page_t*,ulint)" -> "page_get_page_no(const ib_page_t*)"
"btr_check_blob_fil_page_type(ulint,ulint,const ib_page_t*,ulint)" -> "abort()"
"btr_check_blob_fil_page_type(ulint,ulint,const ib_page_t*,ulint)" -> "fprintf(FILE*,const char*,...)"
"btr_check_blob_fil_page_type(ulint,ulint,const ib_page_t*,ulint)" -> "ut_dbg_assertion_failed(const char*,const char*,ulint)"
"btr_check_blob_fil_page_type(ulint,ulint,const ib_page_t*,ulint)" -> "dict_tf_get_format(ulint)"
"page_zip_write_blob_ptr(page_zip_des_t*,const unsigned char*,dict_index_t*,const ulint*,ulint,mtr_t*)" -> "rec_get_n_extern_new(const rec_t*,const dict_index_t*,ulint)"
"page_zip_write_blob_ptr(page_zip_des_t*,const unsigned char*,dict_index_t*,const ulint*,ulint,mtr_t*)" -> "memcpy(void*,const void*,size_t)"
"page_zip_write_blob_ptr(page_zip_des_t*,const unsigned char*,dict_index_t*,const ulint*,ulint,mtr_t*)" -> "page_dir_get_n_heap(const ib_page_t*)"
"page_zip_write_blob_ptr(page_zip_des_t*,const unsigned char*,dict_index_t*,const ulint*,ulint,mtr_t*)" -> "page_offset(const void*)"
"page_zip_write_blob_ptr(page_zip_des_t*,const unsigned char*,dict_index_t*,const ulint*,ulint,mtr_t*)" -> "page_align(const void*)"
"page_zip_write_blob_ptr(page_zip_des_t*,const unsigned char*,dict_index_t*,const ulint*,ulint,mtr_t*)" -> "mlog_open(mtr_t*,ulint)"
"page_zip_write_blob_ptr(page_zip_des_t*,const unsigned char*,dict_index_t*,const ulint*,ulint,mtr_t*)" -> "page_zip_get_n_prev_extern(const page_zip_des_t*,const rec_t*,const dict_index_t*)"
"page_zip_write_blob_ptr(page_zip_des_t*,const unsigned char*,dict_index_t*,const ulint*,ulint,mtr_t*)" -> "rec_get_nth_field_offs(const ulint*,ulint,ulint*)"
"page_zip_write_blob_ptr(page_zip_des_t*,const unsigned char*,dict_index_t*,const ulint*,ulint,mtr_t*)" -> "abort()"
"page_zip_write_blob_ptr(page_zip_des_t*,const unsigned char*,dict_index_t*,const ulint*,ulint,mtr_t*)" -> "mach_write_to_2(unsigned char*,ulint)"
"page_zip_write_blob_ptr(page_zip_des_t*,const unsigned char*,dict_index_t*,const ulint*,ulint,mtr_t*)" -> "mlog_write_initial_log_record_fast(const unsigned char*,unsigned char,unsigned char*,mtr_t*)"
"page_zip_write_blob_ptr(page_zip_des_t*,const unsigned char*,dict_index_t*,const ulint*,ulint,mtr_t*)" -> "__builtin_expect(long int,long int)"
"page_zip_write_blob_ptr(page_zip_des_t*,const unsigned char*,dict_index_t*,const ulint*,ulint,mtr_t*)" -> "ut_dbg_assertion_failed(const char*,const char*,ulint)"
"page_zip_write_blob_ptr(page_zip_des_t*,const unsigned char*,dict_index_t*,const ulint*,ulint,mtr_t*)" -> "page_zip_get_size(const page_zip_des_t*)"
"page_zip_write_blob_ptr(page_zip_des_t*,const unsigned char*,dict_index_t*,const ulint*,ulint,mtr_t*)" -> "mlog_close(mtr_t*,unsigned char*)"
"row_log_table_blob_free(dict_index_t*,ulint)" -> "row_log_table_blob_t::blob_free()"
"row_log_table_blob_free(dict_index_t*,ulint)" -> "_Alloc>::map() [with _Key = long unsigned int,_Tp = row_log_table_blob_t,_Compare = std::less<long unsigned int>,_Alloc = std::allocator<std::pair<const long unsigned int,row_log_table_blob_t> >]"
"row_log_table_blob_free(dict_index_t*,ulint)" -> "row_log_table_blob_t::row_log_table_blob_t()"
"row_log_table_blob_free(dict_index_t*,ulint)" -> "std::_Rb_tree_iterator<_Tp>::operator->() const [with _Tp = std::pair<const long unsigned int,row_log_table_blob_t>,std::_Rb_tree_iterator<_Tp>::pointer = std::pair<const long unsigned int,row_log_table_blob_t>*]"
"row_log_table_blob_free(dict_index_t*,ulint)" -> "_Alloc>::insert(const value_type&) [with _Key = long unsigned int,_Tp = row_log_table_blob_t,_Compare = std::less<long unsigned int>,_Alloc = std::allocator<std::pair<const long unsigned int,row_log_table_blob_t> >,typename std::_Rb_tree<_Key,std::pair<const _Key,_Tp>,std::_Select1st<std::pair<const _Key,_Tp> >,_Compare,typename _Alloc::rebind<std::map<_Key,_Tp,_Compare,_Alloc>::value_type>::other>::iterator = std::_Rb_tree_iterator<std::pair<const long unsigned int,row_log_table_blob_t> >,std::map<_Key,_Tp,_Compare,_Alloc>::value_type = std::pair<const long unsigned int,row_log_table_blob_t>]"
"row_log_table_blob_free(dict_index_t*,ulint)" -> "_T2>::pair(const _T1&,const _T2&) [with _T1 = const long unsigned int,_T2 = row_log_table_blob_t]"
"_Alloc>::map() [with _Key = long unsigned int,_Tp = row_log_table_blob_t,_Compare = std::less<long unsigned int>,_Alloc = std::allocator<std::pair<const long unsigned int,row_log_table_blob_t> >]" -> "_Alloc>::_Rb_tree() [with _Key = long unsigned int,_Val = std::pair<const long unsigned int,row_log_table_blob_t>,_KeyOfValue = std::_Select1st<std::pair<const long unsigned int,row_log_table_blob_t> >,_Compare = std::less<long unsigned int>,_Alloc = std::allocator<std::pair<const long unsigned int,row_log_table_blob_t> >]"
"_Alloc>::_Rb_tree() [with _Key = long unsigned int,_Val = std::pair<const long unsigned int,row_log_table_blob_t>,_KeyOfValue = std::_Select1st<std::pair<const long unsigned int,row_log_table_blob_t> >,_Compare = std::less<long unsigned int>,_Alloc = std::allocator<std::pair<const long unsigned int,row_log_table_blob_t> >]" -> "_Is_pod_comparator>::_Rb_tree_impl() [with _Key_compare = std::less<long unsigned int>,bool _Is_pod_comparator = false,_Key = long unsigned int,_Val = std::pair<const long unsigned int,row_log_table_blob_t>,_KeyOfValue = std::_Select1st<std::pair<const long unsigned int,row_log_table_blob_t> >,_Compare = std::less<long unsigned int>,_Alloc = std::allocator<std::pair<const long unsigned int,row_log_table_blob_t> >]"
"_Is_pod_comparator>::_Rb_tree_impl() [with _Key_compare = std::less<long unsigned int>,bool _Is_pod_comparator = false,_Key = long unsigned int,_Val = std::pair<const long unsigned int,row_log_table_blob_t>,_KeyOfValue = std::_Select1st<std::pair<const long unsigned int,row_log_table_blob_t> >,_Compare = std::less<long unsigned int>,_Alloc = std::allocator<std::pair<const long unsigned int,row_log_table_blob_t> >]" -> "std::allocator<_Tp>::allocator() [with _Tp = std::_Rb_tree_node<std::pair<const long unsigned int,row_log_table_blob_t> >]"
"_Is_pod_comparator>::_Rb_tree_impl() [with _Key_compare = std::less<long unsigned int>,bool _Is_pod_comparator = false,_Key = long unsigned int,_Val = std::pair<const long unsigned int,row_log_table_blob_t>,_KeyOfValue = std::_Select1st<std::pair<const long unsigned int,row_log_table_blob_t> >,_Compare = std::less<long unsigned int>,_Alloc = std::allocator<std::pair<const long unsigned int,row_log_table_blob_t> >]" -> "_Is_pod_comparator>::_M_initialize() [with _Key_compare = std::less<long unsigned int>,bool _Is_pod_comparator = false,_Key = long unsigned int,_Val = std::pair<const long unsigned int,row_log_table_blob_t>,_KeyOfValue = std::_Select1st<std::pair<const long unsigned int,row_log_table_blob_t> >,_Compare = std::less<long unsigned int>,_Alloc = std::allocator<std::pair<const long unsigned int,row_log_table_blob_t> >]"
"std::allocator<_Tp>::allocator() [with _Tp = std::_Rb_tree_node<std::pair<const long unsigned int,row_log_table_blob_t> >]" -> "__gnu_cxx::new_allocator<_Tp>::new_allocator() [with _Tp = std::_Rb_tree_node<std::pair<const long unsigned int,row_log_table_blob_t> >]"
"std::_Rb_tree_iterator<_Tp>::operator->() const [with _Tp = std::pair<const long unsigned int,row_log_table_blob_t>,std::_Rb_tree_iterator<_Tp>::pointer = std::pair<const long unsigned int,row_log_table_blob_t>*]" -> "std::__addressof(_Tp&) [with _Tp = std::pair<const long unsigned int,row_log_table_blob_t>]"
"_Alloc>::insert(const value_type&) [with _Key = long unsigned int,_Tp = row_log_table_blob_t,_Compare = std::less<long unsigned int>,_Alloc = std::allocator<std::pair<const long unsigned int,row_log_table_blob_t> >,typename std::_Rb_tree<_Key,std::pair<const _Key,_Tp>,std::_Select1st<std::pair<const _Key,_Tp> >,_Compare,typename _Alloc::rebind<std::map<_Key,_Tp,_Compare,_Alloc>::value_type>::other>::iterator = std::_Rb_tree_iterator<std::pair<const long unsigned int,row_log_table_blob_t> >,std::map<_Key,_Tp,_Compare,_Alloc>::value_type = std::pair<const long unsigned int,row_log_table_blob_t>]" -> "_Alloc>::_M_insert_unique(const _Val&) [with _Key = long unsigned int,_Val = std::pair<const long unsigned int,row_log_table_blob_t>,_KeyOfValue = std::_Select1st<std::pair<const long unsigned int,row_log_table_blob_t> >,_Compare = std::less<long unsigned int>,_Alloc = std::allocator<std::pair<const long unsigned int,row_log_table_blob_t> >]"
"_Alloc>::_M_insert_unique(const _Val&) [with _Key = long unsigned int,_Val = std::pair<const long unsigned int,row_log_table_blob_t>,_KeyOfValue = std::_Select1st<std::pair<const long unsigned int,row_log_table_blob_t> >,_Compare = std::less<long unsigned int>,_Alloc = std::allocator<std::pair<const long unsigned int,row_log_table_blob_t> >]" -> "_Alloc>::_S_key(std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::_Const_Link_type) [with _Key = long unsigned int,_Val = std::pair<const long unsigned int,row_log_table_blob_t>,_KeyOfValue = std::_Select1st<std::pair<const long unsigned int,row_log_table_blob_t> >,_Compare = std::less<long unsigned int>,_Alloc = std::allocator<std::pair<const long unsigned int,row_log_table_blob_t> >,std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::_Const_Link_type = const std::_Rb_tree_node<std::pair<const long unsigned int,row_log_table_blob_t> >*]"
"_Alloc>::_M_insert_unique(const _Val&) [with _Key = long unsigned int,_Val = std::pair<const long unsigned int,row_log_table_blob_t>,_KeyOfValue = std::_Select1st<std::pair<const long unsigned int,row_log_table_blob_t> >,_Compare = std::less<long unsigned int>,_Alloc = std::allocator<std::pair<const long unsigned int,row_log_table_blob_t> >]" -> "_T2>::pair(const _T1&,const _T2&) [with _T1 = std::_Rb_tree_iterator<std::pair<const long unsigned int,row_log_table_blob_t> >,_T2 = bool]"
"_Alloc>::_M_insert_unique(const _Val&) [with _Key = long unsigned int,_Val = std::pair<const long unsigned int,row_log_table_blob_t>,_KeyOfValue = std::_Select1st<std::pair<const long unsigned int,row_log_table_blob_t> >,_Compare = std::less<long unsigned int>,_Alloc = std::allocator<std::pair<const long unsigned int,row_log_table_blob_t> >]" -> "_Alloc>::_M_end() [with _Key = long unsigned int,_Val = std::pair<const long unsigned int,row_log_table_blob_t>,_KeyOfValue = std::_Select1st<std::pair<const long unsigned int,row_log_table_blob_t> >,_Compare = std::less<long unsigned int>,_Alloc = std::allocator<std::pair<const long unsigned int,row_log_table_blob_t> >,std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::_Link_type = std::_Rb_tree_node<std::pair<const long unsigned int,row_log_table_blob_t> >*]"
"_Alloc>::_M_insert_unique(const _Val&) [with _Key = long unsigned int,_Val = std::pair<const long unsigned int,row_log_table_blob_t>,_KeyOfValue = std::_Select1st<std::pair<const long unsigned int,row_log_table_blob_t> >,_Compare = std::less<long unsigned int>,_Alloc = std::allocator<std::pair<const long unsigned int,row_log_table_blob_t> >]" -> "_Alloc>::_M_begin() [with _Key = long unsigned int,_Val = std::pair<const long unsigned int,row_log_table_blob_t>,_KeyOfValue = std::_Select1st<std::pair<const long unsigned int,row_log_table_blob_t> >,_Compare = std::less<long unsigned int>,_Alloc = std::allocator<std::pair<const long unsigned int,row_log_table_blob_t> >,std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::_Link_type = std::_Rb_tree_node<std::pair<const long unsigned int,row_log_table_blob_t> >*]"
"_Alloc>::_M_insert_unique(const _Val&) [with _Key = long unsigned int,_Val = std::pair<const long unsigned int,row_log_table_blob_t>,_KeyOfValue = std::_Select1st<std::pair<const long unsigned int,row_log_table_blob_t> >,_Compare = std::less<long unsigned int>,_Alloc = std::allocator<std::pair<const long unsigned int,row_log_table_blob_t> >]" -> "_Alloc>::begin() [with _Key = long unsigned int,_Val = std::pair<const long unsigned int,row_log_table_blob_t>,_KeyOfValue = std::_Select1st<std::pair<const long unsigned int,row_log_table_blob_t> >,_Compare = std::less<long unsigned int>,_Alloc = std::allocator<std::pair<const long unsigned int,row_log_table_blob_t> >,std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::iterator = std::_Rb_tree_iterator<std::pair<const long unsigned int,row_log_table_blob_t> >]"
"_Alloc>::_M_insert_unique(const _Val&) [with _Key = long unsigned int,_Val = std::pair<const long unsigned int,row_log_table_blob_t>,_KeyOfValue = std::_Select1st<std::pair<const long unsigned int,row_log_table_blob_t> >,_Compare = std::less<long unsigned int>,_Alloc = std::allocator<std::pair<const long unsigned int,row_log_table_blob_t> >]" -> "_Alloc>::_S_key(std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::_Const_Base_ptr) [with _Key = long unsigned int,_Val = std::pair<const long unsigned int,row_log_table_blob_t>,_KeyOfValue = std::_Select1st<std::pair<const long unsigned int,row_log_table_blob_t> >,_Compare = std::less<long unsigned int>,_Alloc = std::allocator<std::pair<const long unsigned int,row_log_table_blob_t> >,std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::_Const_Base_ptr = const std::_Rb_tree_node_base*]"
"_Alloc>::_M_insert_unique(const _Val&) [with _Key = long unsigned int,_Val = std::pair<const long unsigned int,row_log_table_blob_t>,_KeyOfValue = std::_Select1st<std::pair<const long unsigned int,row_log_table_blob_t> >,_Compare = std::less<long unsigned int>,_Alloc = std::allocator<std::pair<const long unsigned int,row_log_table_blob_t> >]" -> "std::_Select1st<_Pair>::operator()(const _Pair&) const [with _Pair = std::pair<const long unsigned int,row_log_table_blob_t>,typename _Pair::first_type = const long unsigned int]"
"_Alloc>::_M_insert_unique(const _Val&) [with _Key = long unsigned int,_Val = std::pair<const long unsigned int,row_log_table_blob_t>,_KeyOfValue = std::_Select1st<std::pair<const long unsigned int,row_log_table_blob_t> >,_Compare = std::less<long unsigned int>,_Alloc = std::allocator<std::pair<const long unsigned int,row_log_table_blob_t> >]" -> "std::_Rb_tree_iterator<_Tp>::operator==(const _Self&) const [with _Tp = std::pair<const long unsigned int,row_log_table_blob_t>,std::_Rb_tree_iterator<_Tp>::_Self = std::_Rb_tree_iterator<std::pair<const long unsigned int,row_log_table_blob_t> >]"
"_Alloc>::_M_insert_unique(const _Val&) [with _Key = long unsigned int,_Val = std::pair<const long unsigned int,row_log_table_blob_t>,_KeyOfValue = std::_Select1st<std::pair<const long unsigned int,row_log_table_blob_t> >,_Compare = std::less<long unsigned int>,_Alloc = std::allocator<std::pair<const long unsigned int,row_log_table_blob_t> >]" -> "std::_Rb_tree_iterator<_Tp>::_Rb_tree_iterator(std::_Rb_tree_iterator<_Tp>::_Link_type) [with _Tp = std::pair<const long unsigned int,row_log_table_blob_t>,std::_Rb_tree_iterator<_Tp>::_Link_type = std::_Rb_tree_node<std::pair<const long unsigned int,row_log_table_blob_t> >*]"
"_Alloc>::_M_insert_unique(const _Val&) [with _Key = long unsigned int,_Val = std::pair<const long unsigned int,row_log_table_blob_t>,_KeyOfValue = std::_Select1st<std::pair<const long unsigned int,row_log_table_blob_t> >,_Compare = std::less<long unsigned int>,_Alloc = std::allocator<std::pair<const long unsigned int,row_log_table_blob_t> >]" -> "std::_Rb_tree_iterator<_Tp>::operator--() [with _Tp = std::pair<const long unsigned int,row_log_table_blob_t>,std::_Rb_tree_iterator<_Tp>::_Self = std::_Rb_tree_iterator<std::pair<const long unsigned int,row_log_table_blob_t> >]"
"_Alloc>::_M_insert_unique(const _Val&) [with _Key = long unsigned int,_Val = std::pair<const long unsigned int,row_log_table_blob_t>,_KeyOfValue = std::_Select1st<std::pair<const long unsigned int,row_log_table_blob_t> >,_Compare = std::less<long unsigned int>,_Alloc = std::allocator<std::pair<const long unsigned int,row_log_table_blob_t> >]" -> "_Alloc>::_M_insert_(std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::_Const_Base_ptr,std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::_Const_Base_ptr,const _Val&) [with _Key = long unsigned int,_Val = std::pair<const long unsigned int,row_log_table_blob_t>,_KeyOfValue = std::_Select1st<std::pair<const long unsigned int,row_log_table_blob_t> >,_Compare = std::less<long unsigned int>,_Alloc = std::allocator<std::pair<const long unsigned int,row_log_table_blob_t> >,std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::iterator = std::_Rb_tree_iterator<std::pair<const long unsigned int,row_log_table_blob_t> >,std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::_Const_Base_ptr = const std::_Rb_tree_node_base*]"
"_Alloc>::_M_insert_unique(const _Val&) [with _Key = long unsigned int,_Val = std::pair<const long unsigned int,row_log_table_blob_t>,_KeyOfValue = std::_Select1st<std::pair<const long unsigned int,row_log_table_blob_t> >,_Compare = std::less<long unsigned int>,_Alloc = std::allocator<std::pair<const long unsigned int,row_log_table_blob_t> >]" -> "std::less<_Tp>::operator()(const _Tp&,const _Tp&) const [with _Tp = long unsigned int]"
"_Alloc>::_M_insert_unique(const _Val&) [with _Key = long unsigned int,_Val = std::pair<const long unsigned int,row_log_table_blob_t>,_KeyOfValue = std::_Select1st<std::pair<const long unsigned int,row_log_table_blob_t> >,_Compare = std::less<long unsigned int>,_Alloc = std::allocator<std::pair<const long unsigned int,row_log_table_blob_t> >]" -> "_Alloc>::_S_right(std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::_Base_ptr) [with _Key = long unsigned int,_Val = std::pair<const long unsigned int,row_log_table_blob_t>,_KeyOfValue = std::_Select1st<std::pair<const long unsigned int,row_log_table_blob_t> >,_Compare = std::less<long unsigned int>,_Alloc = std::allocator<std::pair<const long unsigned int,row_log_table_blob_t> >,std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::_Link_type = std::_Rb_tree_node<std::pair<const long unsigned int,row_log_table_blob_t> >*,std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::_Base_ptr = std::_Rb_tree_node_base*]"
"_Alloc>::_M_insert_unique(const _Val&) [with _Key = long unsigned int,_Val = std::pair<const long unsigned int,row_log_table_blob_t>,_KeyOfValue = std::_Select1st<std::pair<const long unsigned int,row_log_table_blob_t> >,_Compare = std::less<long unsigned int>,_Alloc = std::allocator<std::pair<const long unsigned int,row_log_table_blob_t> >]" -> "_Alloc>::_S_left(std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::_Base_ptr) [with _Key = long unsigned int,_Val = std::pair<const long unsigned int,row_log_table_blob_t>,_KeyOfValue = std::_Select1st<std::pair<const long unsigned int,row_log_table_blob_t> >,_Compare = std::less<long unsigned int>,_Alloc = std::allocator<std::pair<const long unsigned int,row_log_table_blob_t> >,std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::_Link_type = std::_Rb_tree_node<std::pair<const long unsigned int,row_log_table_blob_t> >*,std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::_Base_ptr = std::_Rb_tree_node_base*]"
"_Alloc>::_S_key(std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::_Const_Link_type) [with _Key = long unsigned int,_Val = std::pair<const long unsigned int,row_log_table_blob_t>,_KeyOfValue = std::_Select1st<std::pair<const long unsigned int,row_log_table_blob_t> >,_Compare = std::less<long unsigned int>,_Alloc = std::allocator<std::pair<const long unsigned int,row_log_table_blob_t> >,std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::_Const_Link_type = const std::_Rb_tree_node<std::pair<const long unsigned int,row_log_table_blob_t> >*]" -> "_Alloc>::_S_value(std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::_Const_Link_type) [with _Key = long unsigned int,_Val = std::pair<const long unsigned int,row_log_table_blob_t>,_KeyOfValue = std::_Select1st<std::pair<const long unsigned int,row_log_table_blob_t> >,_Compare = std::less<long unsigned int>,_Alloc = std::allocator<std::pair<const long unsigned int,row_log_table_blob_t> >,std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::const_reference = const std::pair<const long unsigned int,row_log_table_blob_t>&,std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::value_type = std::pair<const long unsigned int,row_log_table_blob_t>,std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::_Const_Link_type = const std::_Rb_tree_node<std::pair<const long unsigned int,row_log_table_blob_t> >*]"
"_Alloc>::_S_key(std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::_Const_Link_type) [with _Key = long unsigned int,_Val = std::pair<const long unsigned int,row_log_table_blob_t>,_KeyOfValue = std::_Select1st<std::pair<const long unsigned int,row_log_table_blob_t> >,_Compare = std::less<long unsigned int>,_Alloc = std::allocator<std::pair<const long unsigned int,row_log_table_blob_t> >,std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::_Const_Link_type = const std::_Rb_tree_node<std::pair<const long unsigned int,row_log_table_blob_t> >*]" -> "std::_Select1st<_Pair>::operator()(const _Pair&) const [with _Pair = std::pair<const long unsigned int,row_log_table_blob_t>,typename _Pair::first_type = const long unsigned int]"
"_Alloc>::begin() [with _Key = long unsigned int,_Val = std::pair<const long unsigned int,row_log_table_blob_t>,_KeyOfValue = std::_Select1st<std::pair<const long unsigned int,row_log_table_blob_t> >,_Compare = std::less<long unsigned int>,_Alloc = std::allocator<std::pair<const long unsigned int,row_log_table_blob_t> >,std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::iterator = std::_Rb_tree_iterator<std::pair<const long unsigned int,row_log_table_blob_t> >]" -> "std::_Rb_tree_iterator<_Tp>::_Rb_tree_iterator(std::_Rb_tree_iterator<_Tp>::_Link_type) [with _Tp = std::pair<const long unsigned int,row_log_table_blob_t>,std::_Rb_tree_iterator<_Tp>::_Link_type = std::_Rb_tree_node<std::pair<const long unsigned int,row_log_table_blob_t> >*]"
"_Alloc>::_S_key(std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::_Const_Base_ptr) [with _Key = long unsigned int,_Val = std::pair<const long unsigned int,row_log_table_blob_t>,_KeyOfValue = std::_Select1st<std::pair<const long unsigned int,row_log_table_blob_t> >,_Compare = std::less<long unsigned int>,_Alloc = std::allocator<std::pair<const long unsigned int,row_log_table_blob_t> >,std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::_Const_Base_ptr = const std::_Rb_tree_node_base*]" -> "std::_Select1st<_Pair>::operator()(const _Pair&) const [with _Pair = std::pair<const long unsigned int,row_log_table_blob_t>,typename _Pair::first_type = const long unsigned int]"
"_Alloc>::_S_key(std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::_Const_Base_ptr) [with _Key = long unsigned int,_Val = std::pair<const long unsigned int,row_log_table_blob_t>,_KeyOfValue = std::_Select1st<std::pair<const long unsigned int,row_log_table_blob_t> >,_Compare = std::less<long unsigned int>,_Alloc = std::allocator<std::pair<const long unsigned int,row_log_table_blob_t> >,std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::_Const_Base_ptr = const std::_Rb_tree_node_base*]" -> "_Alloc>::_S_value(std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::_Const_Base_ptr) [with _Key = long unsigned int,_Val = std::pair<const long unsigned int,row_log_table_blob_t>,_KeyOfValue = std::_Select1st<std::pair<const long unsigned int,row_log_table_blob_t> >,_Compare = std::less<long unsigned int>,_Alloc = std::allocator<std::pair<const long unsigned int,row_log_table_blob_t> >,std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::const_reference = const std::pair<const long unsigned int,row_log_table_blob_t>&,std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::value_type = std::pair<const long unsigned int,row_log_table_blob_t>,std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::_Const_Base_ptr = const std::_Rb_tree_node_base*]"
"std::_Rb_tree_iterator<_Tp>::operator--() [with _Tp = std::pair<const long unsigned int,row_log_table_blob_t>,std::_Rb_tree_iterator<_Tp>::_Self = std::_Rb_tree_iterator<std::pair<const long unsigned int,row_log_table_blob_t> >]" -> "std::_Rb_tree_decrement(std::_Rb_tree_node_base*)"
"_Alloc>::_M_insert_(std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::_Const_Base_ptr,std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::_Const_Base_ptr,const _Val&) [with _Key = long unsigned int,_Val = std::pair<const long unsigned int,row_log_table_blob_t>,_KeyOfValue = std::_Select1st<std::pair<const long unsigned int,row_log_table_blob_t> >,_Compare = std::less<long unsigned int>,_Alloc = std::allocator<std::pair<const long unsigned int,row_log_table_blob_t> >,std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::iterator = std::_Rb_tree_iterator<std::pair<const long unsigned int,row_log_table_blob_t> >,std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::_Const_Base_ptr = const std::_Rb_tree_node_base*]" -> "_Alloc>::_M_create_node(const value_type&) [with _Key = long unsigned int,_Val = std::pair<const long unsigned int,row_log_table_blob_t>,_KeyOfValue = std::_Select1st<std::pair<const long unsigned int,row_log_table_blob_t> >,_Compare = std::less<long unsigned int>,_Alloc = std::allocator<std::pair<const long unsigned int,row_log_table_blob_t> >,std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::_Link_type = std::_Rb_tree_node<std::pair<const long unsigned int,row_log_table_blob_t> >*,std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::value_type = std::pair<const long unsigned int,row_log_table_blob_t>]"
"_Alloc>::_M_insert_(std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::_Const_Base_ptr,std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::_Const_Base_ptr,const _Val&) [with _Key = long unsigned int,_Val = std::pair<const long unsigned int,row_log_table_blob_t>,_KeyOfValue = std::_Select1st<std::pair<const long unsigned int,row_log_table_blob_t> >,_Compare = std::less<long unsigned int>,_Alloc = std::allocator<std::pair<const long unsigned int,row_log_table_blob_t> >,std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::iterator = std::_Rb_tree_iterator<std::pair<const long unsigned int,row_log_table_blob_t> >,std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::_Const_Base_ptr = const std::_Rb_tree_node_base*]" -> "std::_Rb_tree_insert_and_rebalance(bool,std::_Rb_tree_node_base*,std::_Rb_tree_node_base*,std::_Rb_tree_node_base&)"
"_Alloc>::_M_insert_(std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::_Const_Base_ptr,std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::_Const_Base_ptr,const _Val&) [with _Key = long unsigned int,_Val = std::pair<const long unsigned int,row_log_table_blob_t>,_KeyOfValue = std::_Select1st<std::pair<const long unsigned int,row_log_table_blob_t> >,_Compare = std::less<long unsigned int>,_Alloc = std::allocator<std::pair<const long unsigned int,row_log_table_blob_t> >,std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::iterator = std::_Rb_tree_iterator<std::pair<const long unsigned int,row_log_table_blob_t> >,std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::_Const_Base_ptr = const std::_Rb_tree_node_base*]" -> "_Alloc>::_S_key(std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::_Const_Base_ptr) [with _Key = long unsigned int,_Val = std::pair<const long unsigned int,row_log_table_blob_t>,_KeyOfValue = std::_Select1st<std::pair<const long unsigned int,row_log_table_blob_t> >,_Compare = std::less<long unsigned int>,_Alloc = std::allocator<std::pair<const long unsigned int,row_log_table_blob_t> >,std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::_Const_Base_ptr = const std::_Rb_tree_node_base*]"
"_Alloc>::_M_insert_(std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::_Const_Base_ptr,std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::_Const_Base_ptr,const _Val&) [with _Key = long unsigned int,_Val = std::pair<const long unsigned int,row_log_table_blob_t>,_KeyOfValue = std::_Select1st<std::pair<const long unsigned int,row_log_table_blob_t> >,_Compare = std::less<long unsigned int>,_Alloc = std::allocator<std::pair<const long unsigned int,row_log_table_blob_t> >,std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::iterator = std::_Rb_tree_iterator<std::pair<const long unsigned int,row_log_table_blob_t> >,std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::_Const_Base_ptr = const std::_Rb_tree_node_base*]" -> "std::less<_Tp>::operator()(const _Tp&,const _Tp&) const [with _Tp = long unsigned int]"
"_Alloc>::_M_insert_(std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::_Const_Base_ptr,std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::_Const_Base_ptr,const _Val&) [with _Key = long unsigned int,_Val = std::pair<const long unsigned int,row_log_table_blob_t>,_KeyOfValue = std::_Select1st<std::pair<const long unsigned int,row_log_table_blob_t> >,_Compare = std::less<long unsigned int>,_Alloc = std::allocator<std::pair<const long unsigned int,row_log_table_blob_t> >,std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::iterator = std::_Rb_tree_iterator<std::pair<const long unsigned int,row_log_table_blob_t> >,std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::_Const_Base_ptr = const std::_Rb_tree_node_base*]" -> "std::_Rb_tree_iterator<_Tp>::_Rb_tree_iterator(std::_Rb_tree_iterator<_Tp>::_Link_type) [with _Tp = std::pair<const long unsigned int,row_log_table_blob_t>,std::_Rb_tree_iterator<_Tp>::_Link_type = std::_Rb_tree_node<std::pair<const long unsigned int,row_log_table_blob_t> >*]"
"_Alloc>::_M_insert_(std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::_Const_Base_ptr,std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::_Const_Base_ptr,const _Val&) [with _Key = long unsigned int,_Val = std::pair<const long unsigned int,row_log_table_blob_t>,_KeyOfValue = std::_Select1st<std::pair<const long unsigned int,row_log_table_blob_t> >,_Compare = std::less<long unsigned int>,_Alloc = std::allocator<std::pair<const long unsigned int,row_log_table_blob_t> >,std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::iterator = std::_Rb_tree_iterator<std::pair<const long unsigned int,row_log_table_blob_t> >,std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::_Const_Base_ptr = const std::_Rb_tree_node_base*]" -> "_Alloc>::_M_end() [with _Key = long unsigned int,_Val = std::pair<const long unsigned int,row_log_table_blob_t>,_KeyOfValue = std::_Select1st<std::pair<const long unsigned int,row_log_table_blob_t> >,_Compare = std::less<long unsigned int>,_Alloc = std::allocator<std::pair<const long unsigned int,row_log_table_blob_t> >,std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::_Link_type = std::_Rb_tree_node<std::pair<const long unsigned int,row_log_table_blob_t> >*]"
"_Alloc>::_M_insert_(std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::_Const_Base_ptr,std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::_Const_Base_ptr,const _Val&) [with _Key = long unsigned int,_Val = std::pair<const long unsigned int,row_log_table_blob_t>,_KeyOfValue = std::_Select1st<std::pair<const long unsigned int,row_log_table_blob_t> >,_Compare = std::less<long unsigned int>,_Alloc = std::allocator<std::pair<const long unsigned int,row_log_table_blob_t> >,std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::iterator = std::_Rb_tree_iterator<std::pair<const long unsigned int,row_log_table_blob_t> >,std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::_Const_Base_ptr = const std::_Rb_tree_node_base*]" -> "std::_Select1st<_Pair>::operator()(const _Pair&) const [with _Pair = std::pair<const long unsigned int,row_log_table_blob_t>,typename _Pair::first_type = const long unsigned int]"
"_Alloc>::_M_create_node(const value_type&) [with _Key = long unsigned int,_Val = std::pair<const long unsigned int,row_log_table_blob_t>,_KeyOfValue = std::_Select1st<std::pair<const long unsigned int,row_log_table_blob_t> >,_Compare = std::less<long unsigned int>,_Alloc = std::allocator<std::pair<const long unsigned int,row_log_table_blob_t> >,std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::_Link_type = std::_Rb_tree_node<std::pair<const long unsigned int,row_log_table_blob_t> >*,std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::value_type = std::pair<const long unsigned int,row_log_table_blob_t>]" -> "__cxa_end_catch()"
"_Alloc>::_M_create_node(const value_type&) [with _Key = long unsigned int,_Val = std::pair<const long unsigned int,row_log_table_blob_t>,_KeyOfValue = std::_Select1st<std::pair<const long unsigned int,row_log_table_blob_t> >,_Compare = std::less<long unsigned int>,_Alloc = std::allocator<std::pair<const long unsigned int,row_log_table_blob_t> >,std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::_Link_type = std::_Rb_tree_node<std::pair<const long unsigned int,row_log_table_blob_t> >*,std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::value_type = std::pair<const long unsigned int,row_log_table_blob_t>]" -> "_Alloc>::_M_put_node(std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::_Link_type) [with _Key = long unsigned int,_Val = std::pair<const long unsigned int,row_log_table_blob_t>,_KeyOfValue = std::_Select1st<std::pair<const long unsigned int,row_log_table_blob_t> >,_Compare = std::less<long unsigned int>,_Alloc = std::allocator<std::pair<const long unsigned int,row_log_table_blob_t> >,std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::_Link_type = std::_Rb_tree_node<std::pair<const long unsigned int,row_log_table_blob_t> >*]"
"_Alloc>::_M_create_node(const value_type&) [with _Key = long unsigned int,_Val = std::pair<const long unsigned int,row_log_table_blob_t>,_KeyOfValue = std::_Select1st<std::pair<const long unsigned int,row_log_table_blob_t> >,_Compare = std::less<long unsigned int>,_Alloc = std::allocator<std::pair<const long unsigned int,row_log_table_blob_t> >,std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::_Link_type = std::_Rb_tree_node<std::pair<const long unsigned int,row_log_table_blob_t> >*,std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::value_type = std::pair<const long unsigned int,row_log_table_blob_t>]" -> "__cxa_rethrow()"
"_Alloc>::_M_create_node(const value_type&) [with _Key = long unsigned int,_Val = std::pair<const long unsigned int,row_log_table_blob_t>,_KeyOfValue = std::_Select1st<std::pair<const long unsigned int,row_log_table_blob_t> >,_Compare = std::less<long unsigned int>,_Alloc = std::allocator<std::pair<const long unsigned int,row_log_table_blob_t> >,std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::_Link_type = std::_Rb_tree_node<std::pair<const long unsigned int,row_log_table_blob_t> >*,std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::value_type = std::pair<const long unsigned int,row_log_table_blob_t>]" -> "_Alloc>::_M_get_node() [with _Key = long unsigned int,_Val = std::pair<const long unsigned int,row_log_table_blob_t>,_KeyOfValue = std::_Select1st<std::pair<const long unsigned int,row_log_table_blob_t> >,_Compare = std::less<long unsigned int>,_Alloc = std::allocator<std::pair<const long unsigned int,row_log_table_blob_t> >,std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::_Link_type = std::_Rb_tree_node<std::pair<const long unsigned int,row_log_table_blob_t> >*]"
"_Alloc>::_M_create_node(const value_type&) [with _Key = long unsigned int,_Val = std::pair<const long unsigned int,row_log_table_blob_t>,_KeyOfValue = std::_Select1st<std::pair<const long unsigned int,row_log_table_blob_t> >,_Compare = std::less<long unsigned int>,_Alloc = std::allocator<std::pair<const long unsigned int,row_log_table_blob_t> >,std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::_Link_type = std::_Rb_tree_node<std::pair<const long unsigned int,row_log_table_blob_t> >*,std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::value_type = std::pair<const long unsigned int,row_log_table_blob_t>]" -> "_Alloc>::get_allocator() const [with _Key = long unsigned int,_Val = std::pair<const long unsigned int,row_log_table_blob_t>,_KeyOfValue = std::_Select1st<std::pair<const long unsigned int,row_log_table_blob_t> >,_Compare = std::less<long unsigned int>,_Alloc = std::allocator<std::pair<const long unsigned int,row_log_table_blob_t> >,std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::allocator_type = std::allocator<std::pair<const long unsigned int,row_log_table_blob_t> >]"
"_Alloc>::_M_create_node(const value_type&) [with _Key = long unsigned int,_Val = std::pair<const long unsigned int,row_log_table_blob_t>,_KeyOfValue = std::_Select1st<std::pair<const long unsigned int,row_log_table_blob_t> >,_Compare = std::less<long unsigned int>,_Alloc = std::allocator<std::pair<const long unsigned int,row_log_table_blob_t> >,std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::_Link_type = std::_Rb_tree_node<std::pair<const long unsigned int,row_log_table_blob_t> >*,std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::value_type = std::pair<const long unsigned int,row_log_table_blob_t>]" -> "std::__addressof(_Tp&) [with _Tp = std::pair<const long unsigned int,row_log_table_blob_t>]"
"_Alloc>::_M_create_node(const value_type&) [with _Key = long unsigned int,_Val = std::pair<const long unsigned int,row_log_table_blob_t>,_KeyOfValue = std::_Select1st<std::pair<const long unsigned int,row_log_table_blob_t> >,_Compare = std::less<long unsigned int>,_Alloc = std::allocator<std::pair<const long unsigned int,row_log_table_blob_t> >,std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::_Link_type = std::_Rb_tree_node<std::pair<const long unsigned int,row_log_table_blob_t> >*,std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::value_type = std::pair<const long unsigned int,row_log_table_blob_t>]" -> "__cxa_begin_catch(void*)"
"_Alloc>::_M_create_node(const value_type&) [with _Key = long unsigned int,_Val = std::pair<const long unsigned int,row_log_table_blob_t>,_KeyOfValue = std::_Select1st<std::pair<const long unsigned int,row_log_table_blob_t> >,_Compare = std::less<long unsigned int>,_Alloc = std::allocator<std::pair<const long unsigned int,row_log_table_blob_t> >,std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::_Link_type = std::_Rb_tree_node<std::pair<const long unsigned int,row_log_table_blob_t> >*,std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::value_type = std::pair<const long unsigned int,row_log_table_blob_t>]" -> "__gnu_cxx::new_allocator<_Tp>::construct(__gnu_cxx::new_allocator<_Tp>::pointer,const _Tp&) [with _Tp = std::pair<const long unsigned int,row_log_table_blob_t>,__gnu_cxx::new_allocator<_Tp>::pointer = std::pair<const long unsigned int,row_log_table_blob_t>*]"
"_Alloc>::_M_create_node(const value_type&) [with _Key = long unsigned int,_Val = std::pair<const long unsigned int,row_log_table_blob_t>,_KeyOfValue = std::_Select1st<std::pair<const long unsigned int,row_log_table_blob_t> >,_Compare = std::less<long unsigned int>,_Alloc = std::allocator<std::pair<const long unsigned int,row_log_table_blob_t> >,std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::_Link_type = std::_Rb_tree_node<std::pair<const long unsigned int,row_log_table_blob_t> >*,std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::value_type = std::pair<const long unsigned int,row_log_table_blob_t>]" -> "__builtin_eh_pointer(int)"
"_Alloc>::_M_put_node(std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::_Link_type) [with _Key = long unsigned int,_Val = std::pair<const long unsigned int,row_log_table_blob_t>,_KeyOfValue = std::_Select1st<std::pair<const long unsigned int,row_log_table_blob_t> >,_Compare = std::less<long unsigned int>,_Alloc = std::allocator<std::pair<const long unsigned int,row_log_table_blob_t> >,std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::_Link_type = std::_Rb_tree_node<std::pair<const long unsigned int,row_log_table_blob_t> >*]" -> "__gnu_cxx::new_allocator<_Tp>::deallocate(__gnu_cxx::new_allocator<_Tp>::pointer,__gnu_cxx::new_allocator<_Tp>::size_type) [with _Tp = std::_Rb_tree_node<std::pair<const long unsigned int,row_log_table_blob_t> >,__gnu_cxx::new_allocator<_Tp>::pointer = std::_Rb_tree_node<std::pair<const long unsigned int,row_log_table_blob_t> >*,__gnu_cxx::new_allocator<_Tp>::size_type = long unsigned int]"
"_Alloc>::_M_get_node() [with _Key = long unsigned int,_Val = std::pair<const long unsigned int,row_log_table_blob_t>,_KeyOfValue = std::_Select1st<std::pair<const long unsigned int,row_log_table_blob_t> >,_Compare = std::less<long unsigned int>,_Alloc = std::allocator<std::pair<const long unsigned int,row_log_table_blob_t> >,std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::_Link_type = std::_Rb_tree_node<std::pair<const long unsigned int,row_log_table_blob_t> >*]" -> "__gnu_cxx::new_allocator<_Tp>::allocate(__gnu_cxx::new_allocator<_Tp>::size_type,const void*) [with _Tp = std::_Rb_tree_node<std::pair<const long unsigned int,row_log_table_blob_t> >,__gnu_cxx::new_allocator<_Tp>::pointer = std::_Rb_tree_node<std::pair<const long unsigned int,row_log_table_blob_t> >*,__gnu_cxx::new_allocator<_Tp>::size_type = long unsigned int]"
"__gnu_cxx::new_allocator<_Tp>::allocate(__gnu_cxx::new_allocator<_Tp>::size_type,const void*) [with _Tp = std::_Rb_tree_node<std::pair<const long unsigned int,row_log_table_blob_t> >,__gnu_cxx::new_allocator<_Tp>::pointer = std::_Rb_tree_node<std::pair<const long unsigned int,row_log_table_blob_t> >*,__gnu_cxx::new_allocator<_Tp>::size_type = long unsigned int]" -> "__gnu_cxx::new_allocator<_Tp>::max_size() const [with _Tp = std::_Rb_tree_node<std::pair<const long unsigned int,row_log_table_blob_t> >,__gnu_cxx::new_allocator<_Tp>::size_type = long unsigned int]"
"__gnu_cxx::new_allocator<_Tp>::allocate(__gnu_cxx::new_allocator<_Tp>::size_type,const void*) [with _Tp = std::_Rb_tree_node<std::pair<const long unsigned int,row_log_table_blob_t> >,__gnu_cxx::new_allocator<_Tp>::pointer = std::_Rb_tree_node<std::pair<const long unsigned int,row_log_table_blob_t> >*,__gnu_cxx::new_allocator<_Tp>::size_type = long unsigned int]" -> "std::__throw_bad_alloc()"
"_Alloc>::get_allocator() const [with _Key = long unsigned int,_Val = std::pair<const long unsigned int,row_log_table_blob_t>,_KeyOfValue = std::_Select1st<std::pair<const long unsigned int,row_log_table_blob_t> >,_Compare = std::less<long unsigned int>,_Alloc = std::allocator<std::pair<const long unsigned int,row_log_table_blob_t> >,std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::allocator_type = std::allocator<std::pair<const long unsigned int,row_log_table_blob_t> >]" -> "std::allocator<_Tp>::allocator(const std::allocator<_Tp1>&) [with _Tp1 = std::_Rb_tree_node<std::pair<const long unsigned int,row_log_table_blob_t> >,_Tp = std::pair<const long unsigned int,row_log_table_blob_t>]"
"_Alloc>::get_allocator() const [with _Key = long unsigned int,_Val = std::pair<const long unsigned int,row_log_table_blob_t>,_KeyOfValue = std::_Select1st<std::pair<const long unsigned int,row_log_table_blob_t> >,_Compare = std::less<long unsigned int>,_Alloc = std::allocator<std::pair<const long unsigned int,row_log_table_blob_t> >,std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::allocator_type = std::allocator<std::pair<const long unsigned int,row_log_table_blob_t> >]" -> "_Alloc>::_M_get_Node_allocator() const [with _Key = long unsigned int,_Val = std::pair<const long unsigned int,row_log_table_blob_t>,_KeyOfValue = std::_Select1st<std::pair<const long unsigned int,row_log_table_blob_t> >,_Compare = std::less<long unsigned int>,_Alloc = std::allocator<std::pair<const long unsigned int,row_log_table_blob_t> >,std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::_Node_allocator = std::allocator<std::_Rb_tree_node<std::pair<const long unsigned int,row_log_table_blob_t> > >]"
"std::allocator<_Tp>::allocator(const std::allocator<_Tp1>&) [with _Tp1 = std::_Rb_tree_node<std::pair<const long unsigned int,row_log_table_blob_t> >,_Tp = std::pair<const long unsigned int,row_log_table_blob_t>]" -> "__gnu_cxx::new_allocator<_Tp>::new_allocator() [with _Tp = std::pair<const long unsigned int,row_log_table_blob_t>]"
"btr_insert_on_non_leaf_level_func(ulint,dict_index_t*,ulint,dtuple_t*,const char*,ulint,mtr_t*)" -> "btr_cur_search_to_nth_level(dict_index_t*,ulint,const dtuple_t*,ulint,ulint,btr_cur_t*,ulint,const char*,ulint,mtr_t*)"
"btr_insert_on_non_leaf_level_func(ulint,dict_index_t*,ulint,dtuple_t*,const char*,ulint,mtr_t*)" -> "btr_cur_optimistic_insert(ulint,btr_cur_t*,ulint**,mem_heap_t**,dtuple_t*,rec_t**,big_rec_t**,ulint,que_thr_t*,mtr_t*)"
"btr_insert_on_non_leaf_level_func(ulint,dict_index_t*,ulint,dtuple_t*,const char*,ulint,mtr_t*)" -> "btr_cur_pessimistic_insert(ulint,btr_cur_t*,ulint**,mem_heap_t**,dtuple_t*,rec_t**,big_rec_t**,ulint,que_thr_t*,mtr_t*)"
"btr_insert_on_non_leaf_level_func(ulint,dict_index_t*,ulint,dtuple_t*,const char*,ulint,mtr_t*)" -> "ut_dbg_assertion_failed(const char*,const char*,ulint)"
"btr_insert_on_non_leaf_level_func(ulint,dict_index_t*,ulint,dtuple_t*,const char*,ulint,mtr_t*)" -> "__builtin_expect(long int,long int)"
"btr_insert_on_non_leaf_level_func(ulint,dict_index_t*,ulint,dtuple_t*,const char*,ulint,mtr_t*)" -> "abort()"
"btr_insert_on_non_leaf_level_func(ulint,dict_index_t*,ulint,dtuple_t*,const char*,ulint,mtr_t*)" -> "mem_heap_free_func(mem_heap_t*,const char*,ulint)"
"btr_cur_optimistic_insert(ulint,btr_cur_t*,ulint**,mem_heap_t**,dtuple_t*,rec_t**,big_rec_t**,ulint,que_thr_t*,mtr_t*)" -> "ibuf_update_free_bits_zip(buf_block_t*,mtr_t*)"
"btr_cur_optimistic_insert(ulint,btr_cur_t*,ulint**,mem_heap_t**,dtuple_t*,rec_t**,big_rec_t**,ulint,que_thr_t*,mtr_t*)" -> "page_zip_rec_needs_ext(ulint,ulint,ulint,ulint)"
"btr_cur_optimistic_insert(ulint,btr_cur_t*,ulint**,mem_heap_t**,dtuple_t*,rec_t**,big_rec_t**,ulint,que_thr_t*,mtr_t*)" -> "dict_index_get_space_reserve()"
"btr_cur_optimistic_insert(ulint,btr_cur_t*,ulint**,mem_heap_t**,dtuple_t*,rec_t**,big_rec_t**,ulint,que_thr_t*,mtr_t*)" -> "lock_update_insert(const buf_block_t*,const rec_t*)"
"btr_cur_optimistic_insert(ulint,btr_cur_t*,ulint**,mem_heap_t**,dtuple_t*,rec_t**,big_rec_t**,ulint,que_thr_t*,mtr_t*)" -> "btr_cur_ins_lock_and_undo(ulint,btr_cur_t*,dtuple_t*,que_thr_t*,mtr_t*,ulint*)"
"btr_cur_optimistic_insert(ulint,btr_cur_t*,ulint**,mem_heap_t**,dtuple_t*,rec_t**,big_rec_t**,ulint,que_thr_t*,mtr_t*)" -> "dtuple_convert_back_big_rec(dict_index_t*,dtuple_t*,big_rec_t*)"
"btr_cur_optimistic_insert(ulint,btr_cur_t*,ulint**,mem_heap_t**,dtuple_t*,rec_t**,big_rec_t**,ulint,que_thr_t*,mtr_t*)" -> "page_get_n_recs(const ib_page_t*)"
"btr_cur_optimistic_insert(ulint,btr_cur_t*,ulint**,mem_heap_t**,dtuple_t*,rec_t**,big_rec_t**,ulint,que_thr_t*,mtr_t*)" -> "dict_index_name_print(FILE*,const trx_t*,const dict_index_t*)"
"btr_cur_optimistic_insert(ulint,btr_cur_t*,ulint**,mem_heap_t**,dtuple_t*,rec_t**,big_rec_t**,ulint,que_thr_t*,mtr_t*)" -> "thr_get_trx(que_thr_t*)"
"btr_cur_optimistic_insert(ulint,btr_cur_t*,ulint**,mem_heap_t**,dtuple_t*,rec_t**,big_rec_t**,ulint,que_thr_t*,mtr_t*)" -> "page_cur_tuple_insert(page_cur_t*,const dtuple_t*,dict_index_t*,ulint**,mem_heap_t**,ulint,mtr_t*)"
"btr_cur_optimistic_insert(ulint,btr_cur_t*,ulint**,mem_heap_t**,dtuple_t*,rec_t**,big_rec_t**,ulint,que_thr_t*,mtr_t*)" -> "page_has_garbage(const ib_page_t*)"
"btr_cur_optimistic_insert(ulint,btr_cur_t*,ulint**,mem_heap_t**,dtuple_t*,rec_t**,big_rec_t**,ulint,que_thr_t*,mtr_t*)" -> "ut_dbg_assertion_failed(const char*,const char*,ulint)"
"btr_cur_optimistic_insert(ulint,btr_cur_t*,ulint**,mem_heap_t**,dtuple_t*,rec_t**,big_rec_t**,ulint,que_thr_t*,mtr_t*)" -> "dtuple_convert_big_rec(dict_index_t*,dtuple_t*,ulint*)"
"btr_cur_optimistic_insert(ulint,btr_cur_t*,ulint**,mem_heap_t**,dtuple_t*,rec_t**,big_rec_t**,ulint,que_thr_t*,mtr_t*)" -> "dict_index_get_n_unique_in_tree(const dict_index_t*)"
"btr_cur_optimistic_insert(ulint,btr_cur_t*,ulint**,mem_heap_t**,dtuple_t*,rec_t**,big_rec_t**,ulint,que_thr_t*,mtr_t*)" -> "buf_block_get_zip_size(const buf_block_t*)"
"btr_cur_optimistic_insert(ulint,btr_cur_t*,ulint**,mem_heap_t**,dtuple_t*,rec_t**,big_rec_t**,ulint,que_thr_t*,mtr_t*)" -> "btr_page_get_split_rec_to_left(btr_cur_t*,rec_t**)"
"btr_cur_optimistic_insert(ulint,btr_cur_t*,ulint**,mem_heap_t**,dtuple_t*,rec_t**,big_rec_t**,ulint,que_thr_t*,mtr_t*)" -> "btr_page_get_split_rec_to_right(btr_cur_t*,rec_t**)"
"btr_cur_optimistic_insert(ulint,btr_cur_t*,ulint**,mem_heap_t**,dtuple_t*,rec_t**,big_rec_t**,ulint,que_thr_t*,mtr_t*)" -> "__builtin_expect(long int,long int)"
"btr_cur_optimistic_insert(ulint,btr_cur_t*,ulint**,mem_heap_t**,dtuple_t*,rec_t**,big_rec_t**,ulint,que_thr_t*,mtr_t*)" -> "rec_get_converted_size(dict_index_t*,const dtuple_t*,ulint)"
"btr_cur_optimistic_insert(ulint,btr_cur_t*,ulint**,mem_heap_t**,dtuple_t*,rec_t**,big_rec_t**,ulint,que_thr_t*,mtr_t*)" -> "dict_index_zip_pad_optimal_page_size(dict_index_t*)"
"btr_cur_optimistic_insert(ulint,btr_cur_t*,ulint**,mem_heap_t**,dtuple_t*,rec_t**,big_rec_t**,ulint,que_thr_t*,mtr_t*)" -> "page_get_data_size(const ib_page_t*)"
"btr_cur_optimistic_insert(ulint,btr_cur_t*,ulint**,mem_heap_t**,dtuple_t*,rec_t**,big_rec_t**,ulint,que_thr_t*,mtr_t*)" -> "ibuf_update_free_bits_if_full(buf_block_t*,ulint,ulint)"
"btr_cur_optimistic_insert(ulint,btr_cur_t*,ulint**,mem_heap_t**,dtuple_t*,rec_t**,big_rec_t**,ulint,que_thr_t*,mtr_t*)" -> "rec_get_converted_size_comp_prefix(const dict_index_t*,const dfield_t*,ulint,ulint*)"
"btr_cur_optimistic_insert(ulint,btr_cur_t*,ulint**,mem_heap_t**,dtuple_t*,rec_t**,big_rec_t**,ulint,que_thr_t*,mtr_t*)" -> "dict_index_is_clust(const dict_index_t*)"
"btr_cur_optimistic_insert(ulint,btr_cur_t*,ulint**,mem_heap_t**,dtuple_t*,rec_t**,big_rec_t**,ulint,que_thr_t*,mtr_t*)" -> "dtuple_get_n_fields(const dtuple_t*)"
"btr_cur_optimistic_insert(ulint,btr_cur_t*,ulint**,mem_heap_t**,dtuple_t*,rec_t**,big_rec_t**,ulint,que_thr_t*,mtr_t*)" -> "page_is_leaf(const ib_page_t*)"
"btr_cur_optimistic_insert(ulint,btr_cur_t*,ulint**,mem_heap_t**,dtuple_t*,rec_t**,big_rec_t**,ulint,que_thr_t*,mtr_t*)" -> "page_get_max_insert_size_after_reorganize(const ib_page_t*,ulint)"
"btr_cur_optimistic_insert(ulint,btr_cur_t*,ulint**,mem_heap_t**,dtuple_t*,rec_t**,big_rec_t**,ulint,que_thr_t*,mtr_t*)" -> "abort()"
"btr_cur_optimistic_insert(ulint,btr_cur_t*,ulint**,mem_heap_t**,dtuple_t*,rec_t**,big_rec_t**,ulint,que_thr_t*,mtr_t*)" -> "page_zip_empty_size(ulint,ulint)"
"btr_cur_optimistic_insert(ulint,btr_cur_t*,ulint**,mem_heap_t**,dtuple_t*,rec_t**,big_rec_t**,ulint,que_thr_t*,mtr_t*)" -> "fprintf(FILE*,const char*,...)"
"btr_cur_optimistic_insert(ulint,btr_cur_t*,ulint**,mem_heap_t**,dtuple_t*,rec_t**,big_rec_t**,ulint,que_thr_t*,mtr_t*)" -> "btr_search_update_hash_on_insert(btr_cur_t*)"
"btr_cur_optimistic_insert(ulint,btr_cur_t*,ulint**,mem_heap_t**,dtuple_t*,rec_t**,big_rec_t**,ulint,que_thr_t*,mtr_t*)" -> "dtuple_print(FILE*,const dtuple_t*)"
"btr_cur_optimistic_insert(ulint,btr_cur_t*,ulint**,mem_heap_t**,dtuple_t*,rec_t**,big_rec_t**,ulint,que_thr_t*,mtr_t*)" -> "page_is_comp(const ib_page_t*)"
"btr_cur_optimistic_insert(ulint,btr_cur_t*,ulint**,mem_heap_t**,dtuple_t*,rec_t**,big_rec_t**,ulint,que_thr_t*,mtr_t*)" -> "btr_search_update_hash_node_on_insert(btr_cur_t*)"
"btr_cur_optimistic_insert(ulint,btr_cur_t*,ulint**,mem_heap_t**,dtuple_t*,rec_t**,big_rec_t**,ulint,que_thr_t*,mtr_t*)" -> "page_get_max_insert_size(const ib_page_t*,ulint)"
"btr_cur_optimistic_insert(ulint,btr_cur_t*,ulint**,mem_heap_t**,dtuple_t*,rec_t**,big_rec_t**,ulint,que_thr_t*,mtr_t*)" -> "ibuf_reset_free_bits(buf_block_t*)"
"btr_cur_optimistic_insert(ulint,btr_cur_t*,ulint**,mem_heap_t**,dtuple_t*,rec_t**,big_rec_t**,ulint,que_thr_t*,mtr_t*)" -> "__builtin_fwrite(const void*,size_t,size_t,FILE*)"
"btr_cur_optimistic_insert(ulint,btr_cur_t*,ulint**,mem_heap_t**,dtuple_t*,rec_t**,big_rec_t**,ulint,que_thr_t*,mtr_t*)" -> "btr_page_reorganize(page_cur_t*,dict_index_t*,mtr_t*)"
"page_zip_rec_needs_ext(ulint,ulint,ulint,ulint)" -> "page_get_free_space_of_empty(ulint)"
"page_zip_rec_needs_ext(ulint,ulint,ulint,ulint)" -> "page_zip_empty_size(ulint,ulint)"
"page_zip_empty_size(ulint,ulint)" -> "compressBound(uLong)"
"lock_update_insert(const buf_block_t*,const rec_t*)" -> "rec_get_heap_no_new(const rec_t*)"
"lock_update_insert(const buf_block_t*,const rec_t*)" -> "lock_rec_inherit_to_gap_if_gap_lock(const buf_block_t*,ulint,ulint)"
"lock_update_insert(const buf_block_t*,const rec_t*)" -> "page_rec_is_comp(const rec_t*)"
"lock_update_insert(const buf_block_t*,const rec_t*)" -> "rec_get_heap_no_old(const rec_t*)"
"lock_update_insert(const buf_block_t*,const rec_t*)" -> "page_rec_get_next_low(const rec_t*,ulint)"
"lock_rec_inherit_to_gap_if_gap_lock(const buf_block_t*,ulint,ulint)" -> "lock_rec_get_insert_intention(const ib_lock_t*)"
"lock_rec_inherit_to_gap_if_gap_lock(const buf_block_t*,ulint,ulint)" -> "pfs_mutex_enter_func(ib_mutex_t*,const char*,ulint)"
"lock_rec_inherit_to_gap_if_gap_lock(const buf_block_t*,ulint,ulint)" -> "lock_rec_get_rec_not_gap(const ib_lock_t*)"
"lock_rec_inherit_to_gap_if_gap_lock(const buf_block_t*,ulint,ulint)" -> "lock_rec_get_next(ulint,ib_lock_t*)"
"lock_rec_inherit_to_gap_if_gap_lock(const buf_block_t*,ulint,ulint)" -> "lock_rec_add_to_queue(ulint,const buf_block_t*,ulint,dict_index_t*,trx_t*,ulint)"
"lock_rec_inherit_to_gap_if_gap_lock(const buf_block_t*,ulint,ulint)" -> "lock_rec_get_first(const buf_block_t*,ulint)"
"lock_rec_inherit_to_gap_if_gap_lock(const buf_block_t*,ulint,ulint)" -> "lock_get_mode(const ib_lock_t*)"
"lock_rec_inherit_to_gap_if_gap_lock(const buf_block_t*,ulint,ulint)" -> "pfs_mutex_exit_func(ib_mutex_t*)"
"btr_cur_ins_lock_and_undo(ulint,btr_cur_t*,dtuple_t*,que_thr_t*,mtr_t*,ulint*)" -> "lock_rec_insert_check_and_lock(ulint,const rec_t*,buf_block_t*,dict_index_t*,que_thr_t*,mtr_t*,ulint*)"
"btr_cur_ins_lock_and_undo(ulint,btr_cur_t*,dtuple_t*,que_thr_t*,mtr_t*,ulint*)" -> "dict_index_is_clust(const dict_index_t*)"
"btr_cur_ins_lock_and_undo(ulint,btr_cur_t*,dtuple_t*,que_thr_t*,mtr_t*,ulint*)" -> "dict_index_is_ibuf(const dict_index_t*)"
"btr_cur_ins_lock_and_undo(ulint,btr_cur_t*,dtuple_t*,que_thr_t*,mtr_t*,ulint*)" -> "trx_undo_report_row_operation(ulint,ulint,que_thr_t*,dict_index_t*,const dtuple_t*,const upd_t*,ulint,const rec_t*,const ulint*,roll_ptr_t*)"
"btr_cur_ins_lock_and_undo(ulint,btr_cur_t*,dtuple_t*,que_thr_t*,mtr_t*,ulint*)" -> "row_upd_index_entry_sys_field(dtuple_t*,dict_index_t*,ulint,ib_uint64_t)"
"lock_rec_insert_check_and_lock(ulint,const rec_t*,buf_block_t*,dict_index_t*,que_thr_t*,mtr_t*,ulint*)" -> "lock_rec_enqueue_waiting(ulint,const buf_block_t*,ulint,dict_index_t*,que_thr_t*)"
"lock_rec_insert_check_and_lock(ulint,const rec_t*,buf_block_t*,dict_index_t*,que_thr_t*,mtr_t*,ulint*)" -> "thr_get_trx(que_thr_t*)"
"lock_rec_insert_check_and_lock(ulint,const rec_t*,buf_block_t*,dict_index_t*,que_thr_t*,mtr_t*,ulint*)" -> "__builtin_expect(long int,long int)"
"lock_rec_insert_check_and_lock(ulint,const rec_t*,buf_block_t*,dict_index_t*,que_thr_t*,mtr_t*,ulint*)" -> "page_update_max_trx_id(buf_block_t*,page_zip_des_t*,trx_id_t,mtr_t*)"
"lock_rec_insert_check_and_lock(ulint,const rec_t*,buf_block_t*,dict_index_t*,que_thr_t*,mtr_t*,ulint*)" -> "lock_rec_other_has_conflicting(lock_mode,const buf_block_t*,ulint,const trx_t*)"
"lock_rec_insert_check_and_lock(ulint,const rec_t*,buf_block_t*,dict_index_t*,que_thr_t*,mtr_t*,ulint*)" -> "page_rec_get_next_const(const rec_t*)"
"lock_rec_insert_check_and_lock(ulint,const rec_t*,buf_block_t*,dict_index_t*,que_thr_t*,mtr_t*,ulint*)" -> "page_rec_get_heap_no(const rec_t*)"
"lock_rec_insert_check_and_lock(ulint,const rec_t*,buf_block_t*,dict_index_t*,que_thr_t*,mtr_t*,ulint*)" -> "dict_index_is_clust(const dict_index_t*)"
"lock_rec_insert_check_and_lock(ulint,const rec_t*,buf_block_t*,dict_index_t*,que_thr_t*,mtr_t*,ulint*)" -> "lock_rec_get_first(const buf_block_t*,ulint)"
"lock_rec_insert_check_and_lock(ulint,const rec_t*,buf_block_t*,dict_index_t*,que_thr_t*,mtr_t*,ulint*)" -> "pfs_mutex_exit_func(ib_mutex_t*)"
"lock_rec_insert_check_and_lock(ulint,const rec_t*,buf_block_t*,dict_index_t*,que_thr_t*,mtr_t*,ulint*)" -> "pfs_mutex_enter_func(ib_mutex_t*,const char*,ulint)"
"lock_rec_enqueue_waiting(ulint,const buf_block_t*,ulint,dict_index_t*,que_thr_t*)" -> "pfs_mutex_enter_func(ib_mutex_t*,const char*,ulint)"
"lock_rec_enqueue_waiting(ulint,const buf_block_t*,ulint,dict_index_t*,que_thr_t*)" -> "trx_get_dict_operation(const trx_t*)"
"lock_rec_enqueue_waiting(ulint,const buf_block_t*,ulint,dict_index_t*,que_thr_t*)" -> "dict_index_name_print(FILE*,const trx_t*,const dict_index_t*)"
"lock_rec_enqueue_waiting(ulint,const buf_block_t*,ulint,dict_index_t*,que_thr_t*)" -> "thr_get_trx(que_thr_t*)"
"lock_rec_enqueue_waiting(ulint,const buf_block_t*,ulint,dict_index_t*,que_thr_t*)" -> "pfs_mutex_exit_func(ib_mutex_t*)"
"lock_rec_enqueue_waiting(ulint,const buf_block_t*,ulint,dict_index_t*,que_thr_t*)" -> "lock_deadlock_check_and_resolve(const ib_lock_t*,const trx_t*)"
"lock_rec_enqueue_waiting(ulint,const buf_block_t*,ulint,dict_index_t*,que_thr_t*)" -> "__builtin_expect(long int,long int)"
"lock_rec_enqueue_waiting(ulint,const buf_block_t*,ulint,dict_index_t*,que_thr_t*)" -> "lock_reset_lock_and_trx_wait(ib_lock_t*)"
"lock_rec_enqueue_waiting(ulint,const buf_block_t*,ulint,dict_index_t*,que_thr_t*)" -> "lock_rec_reset_nth_bit(ib_lock_t*,ulint)"
"lock_rec_enqueue_waiting(ulint,const buf_block_t*,ulint,dict_index_t*,que_thr_t*)" -> "que_thr_stop(que_thr_t*)"
"lock_rec_enqueue_waiting(ulint,const buf_block_t*,ulint,dict_index_t*,que_thr_t*)" -> "ut_print_timestamp(FILE*)"
"lock_rec_enqueue_waiting(ulint,const buf_block_t*,ulint,dict_index_t*,que_thr_t*)" -> "abort()"
"lock_rec_enqueue_waiting(ulint,const buf_block_t*,ulint,dict_index_t*,que_thr_t*)" -> "__builtin_fwrite(const void*,size_t,size_t,FILE*)"
"lock_rec_enqueue_waiting(ulint,const buf_block_t*,ulint,dict_index_t*,que_thr_t*)" -> "ut_time()"
"lock_rec_enqueue_waiting(ulint,const buf_block_t*,ulint,dict_index_t*,que_thr_t*)" -> "ut_dbg_assertion_failed(const char*,const char*,ulint)"
"lock_rec_enqueue_waiting(ulint,const buf_block_t*,ulint,dict_index_t*,que_thr_t*)" -> "lock_rec_create(ulint,const buf_block_t*,ulint,dict_index_t*,trx_t*,ulint)"
"lock_deadlock_check_and_resolve(const ib_lock_t*,const trx_t*)" -> "lock_deadlock_search(lock_deadlock_ctx_t*)"
"lock_deadlock_check_and_resolve(const ib_lock_t*,const trx_t*)" -> "lock_deadlock_fputs(const char*)"
"lock_deadlock_check_and_resolve(const ib_lock_t*,const trx_t*)" -> "lock_deadlock_trx_rollback(lock_deadlock_ctx_t*)"
"lock_deadlock_check_and_resolve(const ib_lock_t*,const trx_t*)" -> "__builtin_expect(long int,long int)"
"lock_deadlock_check_and_resolve(const ib_lock_t*,const trx_t*)" -> "abort()"
"lock_deadlock_check_and_resolve(const ib_lock_t*,const trx_t*)" -> "lock_deadlock_joining_trx_print(const trx_t*,const ib_lock_t*)"
"lock_deadlock_check_and_resolve(const ib_lock_t*,const trx_t*)" -> "ut_dbg_assertion_failed(const char*,const char*,ulint)"
"lock_deadlock_search(lock_deadlock_ctx_t*)" -> "lock_deadlock_pop(lock_deadlock_ctx_t*)"
"lock_deadlock_search(lock_deadlock_ctx_t*)" -> "lock_get_first_lock(const lock_deadlock_ctx_t*,ulint*)"
"lock_deadlock_search(lock_deadlock_ctx_t*)" -> "lock_deadlock_select_victim(const lock_deadlock_ctx_t*)"
"lock_deadlock_search(lock_deadlock_ctx_t*)" -> "ut_dbg_assertion_failed(const char*,const char*,ulint)"
"lock_deadlock_search(lock_deadlock_ctx_t*)" -> "lock_deadlock_notify(const lock_deadlock_ctx_t*,const ib_lock_t*)"
"lock_deadlock_search(lock_deadlock_ctx_t*)" -> "abort()"
"lock_deadlock_search(lock_deadlock_ctx_t*)" -> "lock_get_next_lock(const lock_deadlock_ctx_t*,const ib_lock_t*,ulint)"
"lock_deadlock_search(lock_deadlock_ctx_t*)" -> "__builtin_expect(long int,long int)"
"lock_deadlock_search(lock_deadlock_ctx_t*)" -> "lock_deadlock_push(lock_deadlock_ctx_t*,const ib_lock_t*,ulint)"
"lock_deadlock_search(lock_deadlock_ctx_t*)" -> "lock_has_to_wait(const ib_lock_t*,const ib_lock_t*)"
"lock_get_first_lock(const lock_deadlock_ctx_t*,ulint*)" -> "lock_rec_find_set_bit(const ib_lock_t*)"
"lock_get_first_lock(const lock_deadlock_ctx_t*,ulint*)" -> "lock_rec_get_nth_bit(const ib_lock_t*,ulint)"
"lock_get_first_lock(const lock_deadlock_ctx_t*,ulint*)" -> "lock_rec_get_next_const(ulint,const ib_lock_t*)"
"lock_get_first_lock(const lock_deadlock_ctx_t*,ulint*)" -> "lock_rec_get_first_on_page_addr(ulint,ulint)"
"lock_get_first_lock(const lock_deadlock_ctx_t*,ulint*)" -> "abort()"
"lock_get_first_lock(const lock_deadlock_ctx_t*,ulint*)" -> "ut_dbg_assertion_failed(const char*,const char*,ulint)"
"lock_get_first_lock(const lock_deadlock_ctx_t*,ulint*)" -> "__builtin_expect(long int,long int)"
"lock_get_first_lock(const lock_deadlock_ctx_t*,ulint*)" -> "lock_get_type_low(const ib_lock_t*)"
"lock_rec_get_next_const(ulint,const ib_lock_t*)" -> "lock_rec_get_next(ulint,ib_lock_t*)"
"lock_deadlock_select_victim(const lock_deadlock_ctx_t*)" -> "trx_weight_ge(const trx_t*,const trx_t*)"
"trx_weight_ge(const trx_t*,const trx_t*)" -> "thd_has_edited_nontrans_tables(THD*)"
"thd_has_edited_nontrans_tables(THD*)" -> "thd_non_transactional_update(const THD*)"
"thd_non_transactional_update(const THD*)" -> "THD_TRANS::has_modified_non_trans_table() const"
"lock_deadlock_notify(const lock_deadlock_ctx_t*,const ib_lock_t*)" -> "lock_deadlock_lock_print(const ib_lock_t*)"
"lock_deadlock_notify(const lock_deadlock_ctx_t*,const ib_lock_t*)" -> "lock_deadlock_start_print()"
"lock_deadlock_notify(const lock_deadlock_ctx_t*,const ib_lock_t*)" -> "lock_deadlock_fputs(const char*)"
"lock_deadlock_notify(const lock_deadlock_ctx_t*,const ib_lock_t*)" -> "lock_deadlock_trx_print(const trx_t*,ulint)"
"lock_deadlock_lock_print(const ib_lock_t*)" -> "lock_get_type_low(const ib_lock_t*)"
"lock_deadlock_lock_print(const ib_lock_t*)" -> "lock_table_print(FILE*,const ib_lock_t*)"
"lock_deadlock_lock_print(const ib_lock_t*)" -> "lock_rec_print(FILE*,const ib_lock_t*)"
"lock_table_print(FILE*,const ib_lock_t*)" -> "putc(int,FILE*)"
"lock_table_print(FILE*,const ib_lock_t*)" -> "ut_dbg_assertion_failed(const char*,const char*,ulint)"
"lock_table_print(FILE*,const ib_lock_t*)" -> "lock_get_type_low(const ib_lock_t*)"
"lock_table_print(FILE*,const ib_lock_t*)" -> "abort()"
"lock_table_print(FILE*,const ib_lock_t*)" -> "lock_get_mode(const ib_lock_t*)"
"lock_table_print(FILE*,const ib_lock_t*)" -> "__builtin_expect(long int,long int)"
"lock_table_print(FILE*,const ib_lock_t*)" -> "__builtin_fwrite(const void*,size_t,size_t,FILE*)"
"lock_table_print(FILE*,const ib_lock_t*)" -> "fprintf(FILE*,const char*,...)"
"lock_table_print(FILE*,const ib_lock_t*)" -> "lock_get_wait(const ib_lock_t*)"
"lock_table_print(FILE*,const ib_lock_t*)" -> "ut_print_name(FILE*,const trx_t*,ulint,const char*)"
"lock_rec_print(FILE*,const ib_lock_t*)" -> "buf_page_try_get_func(ulint,ulint,const char*,ulint,mtr_t*)"
"lock_rec_print(FILE*,const ib_lock_t*)" -> "lock_rec_get_nth_bit(const ib_lock_t*,ulint)"
"lock_rec_print(FILE*,const ib_lock_t*)" -> "lock_rec_get_n_bits(const ib_lock_t*)"
"lock_rec_print(FILE*,const ib_lock_t*)" -> "mem_heap_free_func(mem_heap_t*,const char*,ulint)"
"lock_rec_print(FILE*,const ib_lock_t*)" -> "lock_rec_get_rec_not_gap(const ib_lock_t*)"
"lock_rec_print(FILE*,const ib_lock_t*)" -> "putc(int,FILE*)"
"lock_rec_print(FILE*,const ib_lock_t*)" -> "rec_print_new(FILE*,const rec_t*,const ulint*)"
"lock_rec_print(FILE*,const ib_lock_t*)" -> "__builtin_fwrite(const void*,size_t,size_t,FILE*)"
"lock_rec_print(FILE*,const ib_lock_t*)" -> "lock_rec_get_insert_intention(const ib_lock_t*)"
"lock_rec_print(FILE*,const ib_lock_t*)" -> "__builtin_expect(long int,long int)"
"lock_rec_print(FILE*,const ib_lock_t*)" -> "mtr_commit(mtr_t*)"
"lock_rec_print(FILE*,const ib_lock_t*)" -> "lock_rec_get_gap(const ib_lock_t*)"
"lock_rec_print(FILE*,const ib_lock_t*)" -> "lock_get_mode(const ib_lock_t*)"
"lock_rec_print(FILE*,const ib_lock_t*)" -> "rec_get_offsets_func(const rec_t*,const dict_index_t*,ulint*,ulint,mem_heap_t**)"
"lock_rec_print(FILE*,const ib_lock_t*)" -> "abort()"
"lock_rec_print(FILE*,const ib_lock_t*)" -> "dict_index_name_print(FILE*,const trx_t*,const dict_index_t*)"
"lock_rec_print(FILE*,const ib_lock_t*)" -> "lock_get_wait(const ib_lock_t*)"
"lock_rec_print(FILE*,const ib_lock_t*)" -> "ut_dbg_assertion_failed(const char*,const char*,ulint)"
"lock_rec_print(FILE*,const ib_lock_t*)" -> "rec_offs_set_n_alloc(ulint*,ulint)"
"lock_rec_print(FILE*,const ib_lock_t*)" -> "lock_get_type_low(const ib_lock_t*)"
"lock_rec_print(FILE*,const ib_lock_t*)" -> "fprintf(FILE*,const char*,...)"
"lock_rec_print(FILE*,const ib_lock_t*)" -> "mtr_start(mtr_t*)"
"lock_rec_print(FILE*,const ib_lock_t*)" -> "page_find_rec_with_heap_no(const ib_page_t*,ulint)"
"buf_page_try_get_func(ulint,ulint,const char*,ulint,mtr_t*)" -> "pfs_mutex_enter_func(ib_mutex_t*,const char*,ulint)"
"buf_page_try_get_func(ulint,ulint,const char*,ulint,mtr_t*)" -> "pfs_rw_lock_x_lock_func_nowait(rw_lock_t*,const char*,ulint)"
"buf_page_try_get_func(ulint,ulint,const char*,ulint,mtr_t*)" -> "pfs_rw_lock_s_lock_low(rw_lock_t*,ulint,const char*,ulint)"
"buf_page_try_get_func(ulint,ulint,const char*,ulint,mtr_t*)" -> "buf_block_buf_fix_dec(buf_block_t*)"
"buf_page_try_get_func(ulint,ulint,const char*,ulint,mtr_t*)" -> "mtr_memo_push(mtr_t*,void*,ulint)"
"buf_page_try_get_func(ulint,ulint,const char*,ulint,mtr_t*)" -> "buf_pool_get(ulint,ulint)"
"buf_page_try_get_func(ulint,ulint,const char*,ulint,mtr_t*)" -> "pfs_rw_lock_s_unlock_func(rw_lock_t*)"
"buf_page_try_get_func(ulint,ulint,const char*,ulint,mtr_t*)" -> "pfs_mutex_exit_func(ib_mutex_t*)"
"buf_page_try_get_func(ulint,ulint,const char*,ulint,mtr_t*)" -> "buf_block_buf_fix_inc_func(buf_block_t*)"
"buf_page_try_get_func(ulint,ulint,const char*,ulint,mtr_t*)" -> "buf_block_hash_get_locked(buf_pool_t*,ulint,ulint,rw_lock_t**,ulint)"
"buf_page_try_get_func(ulint,ulint,const char*,ulint,mtr_t*)" -> "buf_block_get_state(const buf_block_t*)"
"buf_block_hash_get_locked(buf_pool_t*,ulint,ulint,rw_lock_t**,ulint)" -> "pfs_rw_lock_s_unlock_func(rw_lock_t*)"
"buf_block_hash_get_locked(buf_pool_t*,ulint,ulint,rw_lock_t**,ulint)" -> "buf_page_get_block(buf_page_t*)"
"buf_block_hash_get_locked(buf_pool_t*,ulint,ulint,rw_lock_t**,ulint)" -> "pfs_rw_lock_x_unlock_func(rw_lock_t*)"
"buf_block_hash_get_locked(buf_pool_t*,ulint,ulint,rw_lock_t**,ulint)" -> "buf_page_hash_get_locked(buf_pool_t*,ulint,ulint,rw_lock_t**,ulint)"
"buf_page_get_block(buf_page_t*)" -> "buf_page_get_state(const buf_page_t*)"
"page_find_rec_with_heap_no(const ib_page_t*,ulint)" -> "rec_get_heap_no_old(const rec_t*)"
"page_find_rec_with_heap_no(const ib_page_t*,ulint)" -> "rec_get_heap_no_new(const rec_t*)"
"page_find_rec_with_heap_no(const ib_page_t*,ulint)" -> "page_is_comp(const ib_page_t*)"
"page_find_rec_with_heap_no(const ib_page_t*,ulint)" -> "rec_get_next_offs(const rec_t*,ulint)"
"lock_deadlock_start_print()" -> "__builtin_fwrite(const void*,size_t,size_t,FILE*)"
"lock_deadlock_start_print()" -> "ut_print_timestamp(FILE*)"
"lock_deadlock_start_print()" -> "rewind(FILE*)"
"lock_deadlock_fputs(const char*)" -> "fputs(const char*,FILE*)"
"lock_deadlock_trx_print(const trx_t*,ulint)" -> "trx_print_low(FILE*,const trx_t*,ulint,ulint,ulint,ulint)"
"lock_deadlock_trx_print(const trx_t*,ulint)" -> "lock_number_of_rows_locked(const trx_lock_t*)"
"lock_deadlock_trx_print(const trx_t*,ulint)" -> "mem_heap_get_size(mem_heap_t*)"
"lock_deadlock_trx_print(const trx_t*,ulint)" -> "pfs_mutex_enter_func(ib_mutex_t*,const char*,ulint)"
"lock_deadlock_trx_print(const trx_t*,ulint)" -> "pfs_mutex_exit_func(ib_mutex_t*)"
"lock_get_next_lock(const lock_deadlock_ctx_t*,const ib_lock_t*,ulint)" -> "lock_rec_get_next_const(ulint,const ib_lock_t*)"
"lock_get_next_lock(const lock_deadlock_ctx_t*,const ib_lock_t*,ulint)" -> "lock_get_type_low(const ib_lock_t*)"
"lock_deadlock_trx_rollback(lock_deadlock_ctx_t*)" -> "pfs_mutex_enter_func(ib_mutex_t*,const char*,ulint)"
"lock_deadlock_trx_rollback(lock_deadlock_ctx_t*)" -> "pfs_mutex_exit_func(ib_mutex_t*)"
"lock_deadlock_trx_rollback(lock_deadlock_ctx_t*)" -> "lock_cancel_waiting_and_release(ib_lock_t*)"
"lock_deadlock_trx_rollback(lock_deadlock_ctx_t*)" -> "lock_deadlock_fputs(const char*)"
"lock_cancel_waiting_and_release(ib_lock_t*)" -> "lock_get_type_low(const ib_lock_t*)"
"lock_cancel_waiting_and_release(ib_lock_t*)" -> "que_thr_end_lock_wait(trx_t*)"
"lock_cancel_waiting_and_release(ib_lock_t*)" -> "lock_reset_lock_and_trx_wait(ib_lock_t*)"
"lock_cancel_waiting_and_release(ib_lock_t*)" -> "lock_wait_release_thread_if_suspended(que_thr_t*)"
"lock_cancel_waiting_and_release(ib_lock_t*)" -> "lock_table_dequeue(ib_lock_t*)"
"lock_cancel_waiting_and_release(ib_lock_t*)" -> "lock_release_autoinc_locks(trx_t*)"
"lock_cancel_waiting_and_release(ib_lock_t*)" -> "lock_rec_dequeue_from_page(ib_lock_t*)"
"lock_release_autoinc_locks(trx_t*)" -> "__builtin_expect(long int,long int)"
"lock_release_autoinc_locks(trx_t*)" -> "ib_vector_is_empty(const ib_vector_t*)"
"lock_release_autoinc_locks(trx_t*)" -> "abort()"
"lock_release_autoinc_locks(trx_t*)" -> "ut_dbg_assertion_failed(const char*,const char*,ulint)"
"lock_release_autoinc_locks(trx_t*)" -> "lock_release_autoinc_last_lock(ib_vector_t*)"
"lock_release_autoinc_last_lock(ib_vector_t*)" -> "lock_trx_table_locks_remove(const ib_lock_t*)"
"lock_release_autoinc_last_lock(ib_vector_t*)" -> "ib_vector_get(ib_vector_t*,ulint)"
"lock_release_autoinc_last_lock(ib_vector_t*)" -> "lock_get_mode(const ib_lock_t*)"
"lock_release_autoinc_last_lock(ib_vector_t*)" -> "__builtin_expect(long int,long int)"
"lock_release_autoinc_last_lock(ib_vector_t*)" -> "abort()"
"lock_release_autoinc_last_lock(ib_vector_t*)" -> "ib_vector_is_empty(const ib_vector_t*)"
"lock_release_autoinc_last_lock(ib_vector_t*)" -> "ib_vector_size(const ib_vector_t*)"
"lock_release_autoinc_last_lock(ib_vector_t*)" -> "ut_dbg_assertion_failed(const char*,const char*,ulint)"
"lock_release_autoinc_last_lock(ib_vector_t*)" -> "lock_table_dequeue(ib_lock_t*)"
"lock_release_autoinc_last_lock(ib_vector_t*)" -> "lock_get_type(const ib_lock_t*)"
"lock_trx_table_locks_remove(const ib_lock_t*)" -> "lock_get_type_low(const ib_lock_t*)"
"lock_trx_table_locks_remove(const ib_lock_t*)" -> "pfs_mutex_enter_func(ib_mutex_t*,const char*,ulint)"
"lock_trx_table_locks_remove(const ib_lock_t*)" -> "abort()"
"lock_trx_table_locks_remove(const ib_lock_t*)" -> "ib_vector_set(ib_vector_t*,ulint,void*)"
"lock_trx_table_locks_remove(const ib_lock_t*)" -> "ut_dbg_assertion_failed(const char*,const char*,ulint)"
"lock_trx_table_locks_remove(const ib_lock_t*)" -> "__builtin_expect(long int,long int)"
"lock_trx_table_locks_remove(const ib_lock_t*)" -> "pfs_mutex_exit_func(ib_mutex_t*)"
"lock_trx_table_locks_remove(const ib_lock_t*)" -> "ib_vector_size(const ib_vector_t*)"
"lock_trx_table_locks_remove(const ib_lock_t*)" -> "ib_vector_get(ib_vector_t*,ulint)"
"lock_get_type(const ib_lock_t*)" -> "lock_get_type_low(const ib_lock_t*)"
"lock_deadlock_joining_trx_print(const trx_t*,const ib_lock_t*)" -> "lock_deadlock_start_print()"
"lock_deadlock_joining_trx_print(const trx_t*,const ib_lock_t*)" -> "lock_deadlock_trx_print(const trx_t*,ulint)"
"lock_deadlock_joining_trx_print(const trx_t*,const ib_lock_t*)" -> "lock_deadlock_lock_print(const ib_lock_t*)"
"lock_deadlock_joining_trx_print(const trx_t*,const ib_lock_t*)" -> "lock_deadlock_fputs(const char*)"
"que_thr_stop(que_thr_t*)" -> "thr_get_trx(que_thr_t*)"
"lock_rec_other_has_conflicting(lock_mode,const buf_block_t*,ulint,const trx_t*)" -> "lock_rec_get_first(const buf_block_t*,ulint)"
"lock_rec_other_has_conflicting(lock_mode,const buf_block_t*,ulint,const trx_t*)" -> "lock_rec_has_to_wait(const trx_t*,ulint,const ib_lock_t*,ulint)"
"lock_rec_other_has_conflicting(lock_mode,const buf_block_t*,ulint,const trx_t*)" -> "lock_rec_get_next_const(ulint,const ib_lock_t*)"
"trx_undo_report_row_operation(ulint,ulint,que_thr_t*,dict_index_t*,const dtuple_t*,const upd_t*,ulint,const rec_t*,const ulint*,roll_ptr_t*)" -> "pfs_mutex_enter_func(ib_mutex_t*,const char*,ulint)"
"trx_undo_report_row_operation(ulint,ulint,que_thr_t*,dict_index_t*,const dtuple_t*,const upd_t*,ulint,const rec_t*,const ulint*,roll_ptr_t*)" -> "trx_undo_assign_undo(trx_t*,ulint)"
"trx_undo_report_row_operation(ulint,ulint,que_thr_t*,dict_index_t*,const dtuple_t*,const upd_t*,ulint,const rec_t*,const ulint*,roll_ptr_t*)" -> "trx_undo_build_roll_ptr(ulint,ulint,ulint,ulint)"
"trx_undo_report_row_operation(ulint,ulint,que_thr_t*,dict_index_t*,const dtuple_t*,const upd_t*,ulint,const rec_t*,const ulint*,roll_ptr_t*)" -> "ut_dbg_assertion_failed(const char*,const char*,ulint)"
"trx_undo_report_row_operation(ulint,ulint,que_thr_t*,dict_index_t*,const dtuple_t*,const upd_t*,ulint,const rec_t*,const ulint*,roll_ptr_t*)" -> "trx_undo_page_report_modify(ib_page_t*,trx_t*,dict_index_t*,const rec_t*,const ulint*,const upd_t*,ulint,mtr_t*)"
"trx_undo_report_row_operation(ulint,ulint,que_thr_t*,dict_index_t*,const dtuple_t*,const upd_t*,ulint,const rec_t*,const ulint*,roll_ptr_t*)" -> "buf_page_get_gen(ulint,ulint,ulint,ulint,buf_block_t*,ulint,const char*,ulint,mtr_t*)"
"trx_undo_report_row_operation(ulint,ulint,que_thr_t*,dict_index_t*,const dtuple_t*,const upd_t*,ulint,const rec_t*,const ulint*,roll_ptr_t*)" -> "pfs_mutex_exit_func(ib_mutex_t*)"
"trx_undo_report_row_operation(ulint,ulint,que_thr_t*,dict_index_t*,const dtuple_t*,const upd_t*,ulint,const rec_t*,const ulint*,roll_ptr_t*)" -> "mtr_commit(mtr_t*)"
"trx_undo_report_row_operation(ulint,ulint,que_thr_t*,dict_index_t*,const dtuple_t*,const upd_t*,ulint,const rec_t*,const ulint*,roll_ptr_t*)" -> "thr_get_trx(que_thr_t*)"
"trx_undo_report_row_operation(ulint,ulint,que_thr_t*,dict_index_t*,const dtuple_t*,const upd_t*,ulint,const rec_t*,const ulint*,roll_ptr_t*)" -> "abort()"
"trx_undo_report_row_operation(ulint,ulint,que_thr_t*,dict_index_t*,const dtuple_t*,const upd_t*,ulint,const rec_t*,const ulint*,roll_ptr_t*)" -> "trx_undo_free_last_page_func(trx_undo_t*,mtr_t*)"
"trx_undo_report_row_operation(ulint,ulint,que_thr_t*,dict_index_t*,const dtuple_t*,const upd_t*,ulint,const rec_t*,const ulint*,roll_ptr_t*)" -> "trx_undo_add_page(trx_t*,trx_undo_t*,mtr_t*)"
"trx_undo_report_row_operation(ulint,ulint,que_thr_t*,dict_index_t*,const dtuple_t*,const upd_t*,ulint,const rec_t*,const ulint*,roll_ptr_t*)" -> "trx_undo_erase_page_end(ib_page_t*,mtr_t*)"
"trx_undo_report_row_operation(ulint,ulint,que_thr_t*,dict_index_t*,const dtuple_t*,const upd_t*,ulint,const rec_t*,const ulint*,roll_ptr_t*)" -> "trx_assign_rseg(trx_t*)"
"trx_undo_report_row_operation(ulint,ulint,que_thr_t*,dict_index_t*,const dtuple_t*,const upd_t*,ulint,const rec_t*,const ulint*,roll_ptr_t*)" -> "trx_undo_page_report_insert(ib_page_t*,trx_t*,dict_index_t*,const dtuple_t*,mtr_t*)"
"trx_undo_report_row_operation(ulint,ulint,que_thr_t*,dict_index_t*,const dtuple_t*,const upd_t*,ulint,const rec_t*,const ulint*,roll_ptr_t*)" -> "mtr_start(mtr_t*)"
"trx_undo_report_row_operation(ulint,ulint,que_thr_t*,dict_index_t*,const dtuple_t*,const upd_t*,ulint,const rec_t*,const ulint*,roll_ptr_t*)" -> "__builtin_expect(long int,long int)"
"trx_undo_report_row_operation(ulint,ulint,que_thr_t*,dict_index_t*,const dtuple_t*,const upd_t*,ulint,const rec_t*,const ulint*,roll_ptr_t*)" -> "dict_index_is_clust(const dict_index_t*)"
"trx_undo_assign_undo(trx_t*,ulint)" -> "mtr_commit(mtr_t*)"
"trx_undo_assign_undo(trx_t*,ulint)" -> "pfs_mutex_exit_func(ib_mutex_t*)"
"trx_undo_assign_undo(trx_t*,ulint)" -> "trx_undo_create(trx_t*,trx_rseg_t*,ulint,trx_id_t,const XID*,trx_undo_t**,mtr_t*)"
"trx_undo_assign_undo(trx_t*,ulint)" -> "pfs_mutex_enter_func(ib_mutex_t*,const char*,ulint)"
"trx_undo_assign_undo(trx_t*,ulint)" -> "mtr_start(mtr_t*)"
"trx_undo_assign_undo(trx_t*,ulint)" -> "ut_list_prepend(List&,Type&,size_t) [with List = ut_list_base<trx_undo_t>,Type = trx_undo_t,size_t = long unsigned int]"
"trx_undo_assign_undo(trx_t*,ulint)" -> "trx_undo_reuse_cached(trx_t*,trx_rseg_t*,ulint,trx_id_t,const XID*,mtr_t*)"
"trx_undo_assign_undo(trx_t*,ulint)" -> "trx_get_dict_operation(const trx_t*)"
"trx_undo_assign_undo(trx_t*,ulint)" -> "trx_undo_mark_as_dict_operation(trx_t*,trx_undo_t*,mtr_t*)"
"trx_undo_create(trx_t*,trx_rseg_t*,ulint,trx_id_t,const XID*,trx_undo_t**,mtr_t*)" -> "page_get_page_no(const ib_page_t*)"
"trx_undo_create(trx_t*,trx_rseg_t*,ulint,trx_id_t,const XID*,trx_undo_t**,mtr_t*)" -> "trx_undo_header_create(ib_page_t*,trx_id_t,mtr_t*)"
"trx_undo_create(trx_t*,trx_rseg_t*,ulint,trx_id_t,const XID*,trx_undo_t**,mtr_t*)" -> "trx_undo_mem_create(trx_rseg_t*,ulint,ulint,trx_id_t,const XID*,ulint,ulint)"
"trx_undo_create(trx_t*,trx_rseg_t*,ulint,trx_id_t,const XID*,trx_undo_t**,mtr_t*)" -> "trx_undo_seg_create(trx_rseg_t*,trx_rsegf_t*,ulint,ulint*,ib_page_t**,mtr_t*)"
"trx_undo_create(trx_t*,trx_rseg_t*,ulint,trx_id_t,const XID*,trx_undo_t**,mtr_t*)" -> "trx_undo_header_add_space_for_xid(ib_page_t*,trx_ulogf_t*,mtr_t*)"
"trx_undo_create(trx_t*,trx_rseg_t*,ulint,trx_id_t,const XID*,trx_undo_t**,mtr_t*)" -> "trx_rsegf_get(ulint,ulint,ulint,mtr_t*)"
"trx_undo_header_create(ib_page_t*,trx_id_t,mtr_t*)" -> "trx_undo_header_create_log(const ib_page_t*,trx_id_t,mtr_t*)"
"trx_undo_header_create(ib_page_t*,trx_id_t,mtr_t*)" -> "mach_write_to_8(void*,ib_uint64_t)"
"trx_undo_header_create(ib_page_t*,trx_id_t,mtr_t*)" -> "mach_write_to_2(unsigned char*,ulint)"
"trx_undo_header_create(ib_page_t*,trx_id_t,mtr_t*)" -> "ut_dbg_assertion_failed(const char*,const char*,ulint)"
"trx_undo_header_create(ib_page_t*,trx_id_t,mtr_t*)" -> "abort()"
"trx_undo_header_create(ib_page_t*,trx_id_t,mtr_t*)" -> "mach_read_from_2(const unsigned char*)"
"trx_undo_header_create(ib_page_t*,trx_id_t,mtr_t*)" -> "__builtin_expect(long int,long int)"
"trx_undo_header_create(ib_page_t*,trx_id_t,mtr_t*)" -> "mach_write_to_1(unsigned char*,ulint)"
"trx_undo_header_create_log(const ib_page_t*,trx_id_t,mtr_t*)" -> "mlog_write_initial_log_record(const unsigned char*,unsigned char,mtr_t*)"
"trx_undo_header_create_log(const ib_page_t*,trx_id_t,mtr_t*)" -> "mlog_catenate_ull_compressed(mtr_t*,ib_uint64_t)"
"mlog_catenate_ull_compressed(mtr_t*,ib_uint64_t)" -> "mlog_open(mtr_t*,ulint)"
"mlog_catenate_ull_compressed(mtr_t*,ib_uint64_t)" -> "mach_ull_write_compressed(unsigned char*,ib_uint64_t)"
"mlog_catenate_ull_compressed(mtr_t*,ib_uint64_t)" -> "mlog_close(mtr_t*,unsigned char*)"
"trx_undo_mem_create(trx_rseg_t*,ulint,ulint,trx_id_t,const XID*,ulint,ulint)" -> "abort()"
"trx_undo_mem_create(trx_rseg_t*,ulint,ulint,trx_id_t,const XID*,ulint,ulint)" -> "mem_alloc_func(ulint,ulint*)"
"trx_undo_mem_create(trx_rseg_t*,ulint,ulint,trx_id_t,const XID*,ulint,ulint)" -> "ut_dbg_assertion_failed(const char*,const char*,ulint)"
"trx_undo_mem_create(trx_rseg_t*,ulint,ulint,trx_id_t,const XID*,ulint,ulint)" -> "fprintf(FILE*,const char*,...)"
"trx_undo_seg_create(trx_rseg_t*,trx_rsegf_t*,ulint,ulint*,ib_page_t**,mtr_t*)" -> "page_align(const void*)"
"trx_undo_seg_create(trx_rseg_t*,trx_rsegf_t*,ulint,ulint*,ib_page_t**,mtr_t*)" -> "fil_space_release_free_extents(ulint,ulint)"
"trx_undo_seg_create(trx_rseg_t*,trx_rsegf_t*,ulint,ulint*,ib_page_t**,mtr_t*)" -> "flst_init(flst_base_node_t*,mtr_t*)"
"trx_undo_seg_create(trx_rseg_t*,trx_rsegf_t*,ulint,ulint*,ib_page_t**,mtr_t*)" -> "trx_rsegf_undo_find_free(trx_rsegf_t*,mtr_t*)"
"trx_undo_seg_create(trx_rseg_t*,trx_rsegf_t*,ulint,ulint*,ib_page_t**,mtr_t*)" -> "__builtin_fwrite(const void*,size_t,size_t,FILE*)"
"trx_undo_seg_create(trx_rseg_t*,trx_rsegf_t*,ulint,ulint*,ib_page_t**,mtr_t*)" -> "page_get_page_no(const ib_page_t*)"
"trx_undo_seg_create(trx_rseg_t*,trx_rsegf_t*,ulint,ulint*,ib_page_t**,mtr_t*)" -> "fseg_create_general(ulint,ulint,ulint,ulint,mtr_t*)"
"trx_undo_seg_create(trx_rseg_t*,trx_rsegf_t*,ulint,ulint*,ib_page_t**,mtr_t*)" -> "mlog_write_ulint(unsigned char*,ulint,unsigned char,mtr_t*)"
"trx_undo_seg_create(trx_rseg_t*,trx_rsegf_t*,ulint,ulint*,ib_page_t**,mtr_t*)" -> "page_get_space_id(const ib_page_t*)"
"trx_undo_seg_create(trx_rseg_t*,trx_rsegf_t*,ulint,ulint*,ib_page_t**,mtr_t*)" -> "ut_print_timestamp(FILE*)"
"trx_undo_seg_create(trx_rseg_t*,trx_rsegf_t*,ulint,ulint*,ib_page_t**,mtr_t*)" -> "fsp_reserve_free_extents(ulint*,ulint,ulint,ulint,mtr_t*)"
"trx_undo_seg_create(trx_rseg_t*,trx_rsegf_t*,ulint,ulint*,ib_page_t**,mtr_t*)" -> "trx_rsegf_set_nth_undo(trx_rsegf_t*,ulint,ulint,mtr_t*)"
"trx_undo_seg_create(trx_rseg_t*,trx_rsegf_t*,ulint,ulint*,ib_page_t**,mtr_t*)" -> "flst_add_last(flst_base_node_t*,flst_node_t*,mtr_t*)"
"trx_undo_seg_create(trx_rseg_t*,trx_rsegf_t*,ulint,ulint*,ib_page_t**,mtr_t*)" -> "trx_undo_page_init(ib_page_t*,ulint,mtr_t*)"
"flst_init(flst_base_node_t*,mtr_t*)" -> "flst_write_addr(fil_faddr_t*,fil_addr_t,mtr_t*)"
"flst_init(flst_base_node_t*,mtr_t*)" -> "mlog_write_ulint(unsigned char*,ulint,unsigned char,mtr_t*)"
"trx_rsegf_undo_find_free(trx_rsegf_t*,mtr_t*)" -> "trx_rsegf_get_nth_undo(trx_rsegf_t*,ulint,mtr_t*)"
"trx_rsegf_get_nth_undo(trx_rsegf_t*,ulint,mtr_t*)" -> "mtr_read_ulint(const unsigned char*,ulint,mtr_t*)"
"trx_rsegf_get_nth_undo(trx_rsegf_t*,ulint,mtr_t*)" -> "fprintf(FILE*,const char*,...)"
"trx_rsegf_get_nth_undo(trx_rsegf_t*,ulint,mtr_t*)" -> "abort()"
"trx_rsegf_get_nth_undo(trx_rsegf_t*,ulint,mtr_t*)" -> "ut_dbg_assertion_failed(const char*,const char*,ulint)"
"fseg_create_general(ulint,ulint,ulint,ulint,mtr_t*)" -> "mlog_write_ulint(unsigned char*,ulint,unsigned char,mtr_t*)"
"fseg_create_general(ulint,ulint,ulint,ulint,mtr_t*)" -> "mach_read_from_8(const unsigned char*)"
"fseg_create_general(ulint,ulint,ulint,ulint,mtr_t*)" -> "fil_space_release_free_extents(ulint,ulint)"
"fseg_create_general(ulint,ulint,ulint,ulint,mtr_t*)" -> "fsp_flags_get_zip_size(ulint)"
"fseg_create_general(ulint,ulint,ulint,ulint,mtr_t*)" -> "fsp_get_space_header(ulint,ulint,mtr_t*)"
"fseg_create_general(ulint,ulint,ulint,ulint,mtr_t*)" -> "ibuf_free_excess_pages()"
"fseg_create_general(ulint,ulint,ulint,ulint,mtr_t*)" -> "fseg_alloc_free_page_low(ulint,ulint,fseg_inode_t*,ulint,unsigned char,mtr_t*,mtr_t*)"
"fseg_create_general(ulint,ulint,ulint,ulint,mtr_t*)" -> "fsp_free_seg_inode(ulint,ulint,fseg_inode_t*,mtr_t*)"
"fseg_create_general(ulint,ulint,ulint,ulint,mtr_t*)" -> "rw_lock_get_x_lock_count(const rw_lock_t*)"
"fseg_create_general(ulint,ulint,ulint,ulint,mtr_t*)" -> "fsp_reserve_free_extents(ulint*,ulint,ulint,ulint,mtr_t*)"
"fseg_create_general(ulint,ulint,ulint,ulint,mtr_t*)" -> "flst_init(flst_base_node_t*,mtr_t*)"
"fseg_create_general(ulint,ulint,ulint,ulint,mtr_t*)" -> "fil_space_get_latch(ulint,ulint*)"
"fseg_create_general(ulint,ulint,ulint,ulint,mtr_t*)" -> "buf_page_get_gen(ulint,ulint,ulint,ulint,buf_block_t*,ulint,const char*,ulint,mtr_t*)"
"fseg_create_general(ulint,ulint,ulint,ulint,mtr_t*)" -> "fseg_set_nth_frag_page_no(fseg_inode_t*,ulint,ulint,mtr_t*)"
"fseg_create_general(ulint,ulint,ulint,ulint,mtr_t*)" -> "mtr_x_lock_func(rw_lock_t*,const char*,ulint,mtr_t*)"
"fseg_create_general(ulint,ulint,ulint,ulint,mtr_t*)" -> "page_offset(const void*)"
"fseg_create_general(ulint,ulint,ulint,ulint,mtr_t*)" -> "fsp_alloc_seg_inode(fsp_header_t*,mtr_t*)"
"fseg_create_general(ulint,ulint,ulint,ulint,mtr_t*)" -> "page_align(const void*)"
"fseg_create_general(ulint,ulint,ulint,ulint,mtr_t*)" -> "page_get_page_no(const ib_page_t*)"
"fseg_create_general(ulint,ulint,ulint,ulint,mtr_t*)" -> "mlog_write_ull(unsigned char*,ib_uint64_t,mtr_t*)"
"ibuf_free_excess_pages()" -> "pfs_mutex_exit_func(ib_mutex_t*)"
"ibuf_free_excess_pages()" -> "pfs_mutex_enter_func(ib_mutex_t*,const char*,ulint)"
"ibuf_free_excess_pages()" -> "ibuf_data_too_much_free()"
"ibuf_free_excess_pages()" -> "ibuf_remove_free_page()"
"ibuf_remove_free_page()" -> "ibuf_header_page_get(mtr_t*)"
"ibuf_remove_free_page()" -> "flst_remove(flst_base_node_t*,flst_node_t*,mtr_t*)"
"ibuf_remove_free_page()" -> "flst_get_last(const flst_base_node_t*,mtr_t*)"
"ibuf_remove_free_page()" -> "ibuf_bitmap_get_map_page_func(ulint,ulint,ulint,const char*,ulint,mtr_t*)"
"ibuf_remove_free_page()" -> "ibuf_data_too_much_free()"
"ibuf_remove_free_page()" -> "ibuf_enter(mtr_t*)"
"ibuf_remove_free_page()" -> "fil_space_get_latch(ulint,ulint*)"
"ibuf_remove_free_page()" -> "ibuf_tree_root_get(mtr_t*)"
"ibuf_remove_free_page()" -> "ibuf_exit(mtr_t*)"
"ibuf_remove_free_page()" -> "mtr_x_lock_func(rw_lock_t*,const char*,ulint,mtr_t*)"
"ibuf_remove_free_page()" -> "mtr_start(mtr_t*)"
"ibuf_remove_free_page()" -> "pfs_mutex_enter_func(ib_mutex_t*,const char*,ulint)"
"ibuf_remove_free_page()" -> "ibuf_mtr_start(mtr_t*)"
"ibuf_remove_free_page()" -> "fsp_flags_get_zip_size(ulint)"
"ibuf_remove_free_page()" -> "buf_page_get_gen(ulint,ulint,ulint,ulint,buf_block_t*,ulint,const char*,ulint,mtr_t*)"
"ibuf_remove_free_page()" -> "ibuf_bitmap_page_set_bits(ib_page_t*,ulint,ulint,ulint,ulint,mtr_t*)"
"ibuf_remove_free_page()" -> "fseg_free_page(fseg_header_t*,ulint,ulint,mtr_t*)"
"ibuf_remove_free_page()" -> "pfs_mutex_exit_func(ib_mutex_t*)"
"ibuf_remove_free_page()" -> "ibuf_mtr_commit(mtr_t*)"
"fsp_alloc_seg_inode(fsp_header_t*,mtr_t*)" -> "page_get_space_id(const ib_page_t*)"
"fsp_alloc_seg_inode(fsp_header_t*,mtr_t*)" -> "ut_dbg_assertion_failed(const char*,const char*,ulint)"
"fsp_alloc_seg_inode(fsp_header_t*,mtr_t*)" -> "abort()"
"fsp_alloc_seg_inode(fsp_header_t*,mtr_t*)" -> "flst_get_first(const flst_base_node_t*,mtr_t*)"
"fsp_alloc_seg_inode(fsp_header_t*,mtr_t*)" -> "fsp_alloc_seg_inode_page(fsp_header_t*,mtr_t*)"
"fsp_alloc_seg_inode(fsp_header_t*,mtr_t*)" -> "page_align(const void*)"
"fsp_alloc_seg_inode(fsp_header_t*,mtr_t*)" -> "buf_page_get_gen(ulint,ulint,ulint,ulint,buf_block_t*,ulint,const char*,ulint,mtr_t*)"
"fsp_alloc_seg_inode(fsp_header_t*,mtr_t*)" -> "flst_add_last(flst_base_node_t*,flst_node_t*,mtr_t*)"
"fsp_alloc_seg_inode(fsp_header_t*,mtr_t*)" -> "flst_remove(flst_base_node_t*,flst_node_t*,mtr_t*)"
"fsp_alloc_seg_inode(fsp_header_t*,mtr_t*)" -> "fsp_seg_inode_page_get_nth_inode(ib_page_t*,ulint,ulint,mtr_t*)"
"fsp_alloc_seg_inode(fsp_header_t*,mtr_t*)" -> "mach_read_from_4(const unsigned char*)"
"fsp_alloc_seg_inode(fsp_header_t*,mtr_t*)" -> "fsp_seg_inode_page_find_free(ib_page_t*,ulint,ulint,mtr_t*)"
"fsp_alloc_seg_inode(fsp_header_t*,mtr_t*)" -> "flst_get_len(const flst_base_node_t*,mtr_t*)"
"fsp_alloc_seg_inode(fsp_header_t*,mtr_t*)" -> "__builtin_expect(long int,long int)"
"fsp_alloc_seg_inode(fsp_header_t*,mtr_t*)" -> "fsp_flags_get_zip_size(ulint)"
"fsp_alloc_seg_inode_page(fsp_header_t*,mtr_t*)" -> "mlog_write_ull(unsigned char*,ib_uint64_t,mtr_t*)"
"fsp_alloc_seg_inode_page(fsp_header_t*,mtr_t*)" -> "page_get_space_id(const ib_page_t*)"
"fsp_alloc_seg_inode_page(fsp_header_t*,mtr_t*)" -> "flst_add_last(flst_base_node_t*,flst_node_t*,mtr_t*)"
"fsp_alloc_seg_inode_page(fsp_header_t*,mtr_t*)" -> "page_align(const void*)"
"fsp_alloc_seg_inode_page(fsp_header_t*,mtr_t*)" -> "fsp_flags_get_zip_size(ulint)"
"fsp_alloc_seg_inode_page(fsp_header_t*,mtr_t*)" -> "fsp_alloc_free_page(ulint,ulint,ulint,mtr_t*,mtr_t*)"
"fsp_alloc_seg_inode_page(fsp_header_t*,mtr_t*)" -> "mlog_write_ulint(unsigned char*,ulint,unsigned char,mtr_t*)"
"fsp_alloc_seg_inode_page(fsp_header_t*,mtr_t*)" -> "mach_read_from_4(const unsigned char*)"
"fsp_alloc_seg_inode_page(fsp_header_t*,mtr_t*)" -> "fsp_seg_inode_page_get_nth_inode(ib_page_t*,ulint,ulint,mtr_t*)"
"fsp_alloc_free_page(ulint,ulint,ulint,mtr_t*,mtr_t*)" -> "fsp_get_space_header(ulint,ulint,mtr_t*)"
"fsp_alloc_free_page(ulint,ulint,ulint,mtr_t*,mtr_t*)" -> "fil_addr_is_null(fil_addr_t)"
"fsp_alloc_free_page(ulint,ulint,ulint,mtr_t*,mtr_t*)" -> "ut_dbg_assertion_failed(const char*,const char*,ulint)"
"fsp_alloc_free_page(ulint,ulint,ulint,mtr_t*,mtr_t*)" -> "fsp_alloc_from_free_frag(fsp_header_t*,xdes_t*,ulint,mtr_t*)"
"fsp_alloc_free_page(ulint,ulint,ulint,mtr_t*,mtr_t*)" -> "xdes_set_state(xdes_t*,ulint,mtr_t*)"
"fsp_alloc_free_page(ulint,ulint,ulint,mtr_t*,mtr_t*)" -> "abort()"
"fsp_alloc_free_page(ulint,ulint,ulint,mtr_t*,mtr_t*)" -> "fprintf(FILE*,const char*,...)"
"fsp_alloc_free_page(ulint,ulint,ulint,mtr_t*,mtr_t*)" -> "fsp_alloc_free_extent(ulint,ulint,ulint,mtr_t*)"
"fsp_alloc_free_page(ulint,ulint,ulint,mtr_t*,mtr_t*)" -> "fsp_try_extend_data_file_with_pages(ulint,ulint,fsp_header_t*,mtr_t*)"
"fsp_alloc_free_page(ulint,ulint,ulint,mtr_t*,mtr_t*)" -> "xdes_find_bit(xdes_t*,ulint,ulint,ulint,mtr_t*)"
"fsp_alloc_free_page(ulint,ulint,ulint,mtr_t*,mtr_t*)" -> "xdes_lst_get_descriptor(ulint,ulint,fil_addr_t,mtr_t*)"
"fsp_alloc_free_page(ulint,ulint,ulint,mtr_t*,mtr_t*)" -> "mtr_read_ulint(const unsigned char*,ulint,mtr_t*)"
"fsp_alloc_free_page(ulint,ulint,ulint,mtr_t*,mtr_t*)" -> "xdes_get_offset(const xdes_t*)"
"fsp_alloc_free_page(ulint,ulint,ulint,mtr_t*,mtr_t*)" -> "xdes_get_descriptor_with_space_hdr(fsp_header_t*,ulint,ulint,mtr_t*)"
"fsp_alloc_free_page(ulint,ulint,ulint,mtr_t*,mtr_t*)" -> "flst_add_last(flst_base_node_t*,flst_node_t*,mtr_t*)"
"fsp_alloc_free_page(ulint,ulint,ulint,mtr_t*,mtr_t*)" -> "_IO_putc(int,_IO_FILE*)"
"fsp_alloc_free_page(ulint,ulint,ulint,mtr_t*,mtr_t*)" -> "fsp_page_create(ulint,ulint,ulint,mtr_t*,mtr_t*)"
"fsp_alloc_free_page(ulint,ulint,ulint,mtr_t*,mtr_t*)" -> "ut_print_buf(FILE*,const void*,ulint)"
"fsp_alloc_free_page(ulint,ulint,ulint,mtr_t*,mtr_t*)" -> "xdes_get_state(const xdes_t*,mtr_t*)"
"fsp_alloc_free_page(ulint,ulint,ulint,mtr_t*,mtr_t*)" -> "flst_get_first(const flst_base_node_t*,mtr_t*)"
"fsp_alloc_free_page(ulint,ulint,ulint,mtr_t*,mtr_t*)" -> "__builtin_expect(long int,long int)"
"fsp_alloc_from_free_frag(fsp_header_t*,xdes_t*,ulint,mtr_t*)" -> "abort()"
"fsp_alloc_from_free_frag(fsp_header_t*,xdes_t*,ulint,mtr_t*)" -> "__builtin_expect(long int,long int)"
"fsp_alloc_from_free_frag(fsp_header_t*,xdes_t*,ulint,mtr_t*)" -> "flst_remove(flst_base_node_t*,flst_node_t*,mtr_t*)"
"fsp_alloc_from_free_frag(fsp_header_t*,xdes_t*,ulint,mtr_t*)" -> "mtr_read_ulint(const unsigned char*,ulint,mtr_t*)"
"fsp_alloc_from_free_frag(fsp_header_t*,xdes_t*,ulint,mtr_t*)" -> "flst_add_last(flst_base_node_t*,flst_node_t*,mtr_t*)"
"fsp_alloc_from_free_frag(fsp_header_t*,xdes_t*,ulint,mtr_t*)" -> "xdes_set_state(xdes_t*,ulint,mtr_t*)"
"fsp_alloc_from_free_frag(fsp_header_t*,xdes_t*,ulint,mtr_t*)" -> "ut_dbg_assertion_failed(const char*,const char*,ulint)"
"fsp_alloc_from_free_frag(fsp_header_t*,xdes_t*,ulint,mtr_t*)" -> "xdes_set_bit(xdes_t*,ulint,ulint,ulint,mtr_t*)"
"fsp_alloc_from_free_frag(fsp_header_t*,xdes_t*,ulint,mtr_t*)" -> "mlog_write_ulint(unsigned char*,ulint,unsigned char,mtr_t*)"
"fsp_alloc_from_free_frag(fsp_header_t*,xdes_t*,ulint,mtr_t*)" -> "xdes_mtr_get_bit(const xdes_t*,ulint,ulint,mtr_t*)"
"fsp_alloc_from_free_frag(fsp_header_t*,xdes_t*,ulint,mtr_t*)" -> "xdes_is_full(const xdes_t*,mtr_t*)"
"fsp_alloc_free_extent(ulint,ulint,ulint,mtr_t*)" -> "xdes_get_state(const xdes_t*,mtr_t*)"
"fsp_alloc_free_extent(ulint,ulint,ulint,mtr_t*)" -> "fsp_get_space_header(ulint,ulint,mtr_t*)"
"fsp_alloc_free_extent(ulint,ulint,ulint,mtr_t*)" -> "fsp_fill_free_list(ulint,ulint,fsp_header_t*,mtr_t*)"
"fsp_alloc_free_extent(ulint,ulint,ulint,mtr_t*)" -> "fil_addr_is_null(fil_addr_t)"
"fsp_alloc_free_extent(ulint,ulint,ulint,mtr_t*)" -> "flst_remove(flst_base_node_t*,flst_node_t*,mtr_t*)"
"fsp_alloc_free_extent(ulint,ulint,ulint,mtr_t*)" -> "xdes_get_descriptor_with_space_hdr(fsp_header_t*,ulint,ulint,mtr_t*)"
"fsp_alloc_free_extent(ulint,ulint,ulint,mtr_t*)" -> "xdes_lst_get_descriptor(ulint,ulint,fil_addr_t,mtr_t*)"
"fsp_alloc_free_extent(ulint,ulint,ulint,mtr_t*)" -> "flst_get_first(const flst_base_node_t*,mtr_t*)"
"fsp_fill_free_list(ulint,ulint,fsp_header_t*,mtr_t*)" -> "xdes_set_state(xdes_t*,ulint,mtr_t*)"
"fsp_fill_free_list(ulint,ulint,fsp_header_t*,mtr_t*)" -> "xdes_set_bit(xdes_t*,ulint,ulint,ulint,mtr_t*)"
"fsp_fill_free_list(ulint,ulint,fsp_header_t*,mtr_t*)" -> "mtr_start(mtr_t*)"
"fsp_fill_free_list(ulint,ulint,fsp_header_t*,mtr_t*)" -> "ibuf_bitmap_page_init(buf_block_t*,mtr_t*)"
"fsp_fill_free_list(ulint,ulint,fsp_header_t*,mtr_t*)" -> "xdes_get_descriptor_with_space_hdr(fsp_header_t*,ulint,ulint,mtr_t*)"
"fsp_fill_free_list(ulint,ulint,fsp_header_t*,mtr_t*)" -> "abort()"
"fsp_fill_free_list(ulint,ulint,fsp_header_t*,mtr_t*)" -> "xdes_init(xdes_t*,mtr_t*)"
"fsp_fill_free_list(ulint,ulint,fsp_header_t*,mtr_t*)" -> "ut_dbg_assertion_failed(const char*,const char*,ulint)"
"fsp_fill_free_list(ulint,ulint,fsp_header_t*,mtr_t*)" -> "fsp_init_file_page(buf_block_t*,mtr_t*)"
"fsp_fill_free_list(ulint,ulint,fsp_header_t*,mtr_t*)" -> "__builtin_expect(long int,long int)"
"fsp_fill_free_list(ulint,ulint,fsp_header_t*,mtr_t*)" -> "fsp_try_extend_data_file(ulint*,ulint,fsp_header_t*,mtr_t*)"
"fsp_fill_free_list(ulint,ulint,fsp_header_t*,mtr_t*)" -> "fsp_flags_get_zip_size(ulint)"
"fsp_fill_free_list(ulint,ulint,fsp_header_t*,mtr_t*)" -> "mlog_write_ulint(unsigned char*,ulint,unsigned char,mtr_t*)"
"fsp_fill_free_list(ulint,ulint,fsp_header_t*,mtr_t*)" -> "buf_page_get_gen(ulint,ulint,ulint,ulint,buf_block_t*,ulint,const char*,ulint,mtr_t*)"
"fsp_fill_free_list(ulint,ulint,fsp_header_t*,mtr_t*)" -> "mtr_commit(mtr_t*)"
"fsp_fill_free_list(ulint,ulint,fsp_header_t*,mtr_t*)" -> "mtr_read_ulint(const unsigned char*,ulint,mtr_t*)"
"fsp_fill_free_list(ulint,ulint,fsp_header_t*,mtr_t*)" -> "buf_page_create(ulint,ulint,ulint,mtr_t*)"
"fsp_fill_free_list(ulint,ulint,fsp_header_t*,mtr_t*)" -> "flst_add_last(flst_base_node_t*,flst_node_t*,mtr_t*)"
"fsp_fill_free_list(ulint,ulint,fsp_header_t*,mtr_t*)" -> "mach_read_from_4(const unsigned char*)"
"ibuf_bitmap_page_init(buf_block_t*,mtr_t*)" -> "memset(void*,int,size_t)"
"ibuf_bitmap_page_init(buf_block_t*,mtr_t*)" -> "mlog_write_initial_log_record(const unsigned char*,unsigned char,mtr_t*)"
"ibuf_bitmap_page_init(buf_block_t*,mtr_t*)" -> "buf_block_get_zip_size(const buf_block_t*)"
"ibuf_bitmap_page_init(buf_block_t*,mtr_t*)" -> "ut_dbg_assertion_failed(const char*,const char*,ulint)"
"ibuf_bitmap_page_init(buf_block_t*,mtr_t*)" -> "__builtin_expect(long int,long int)"
"ibuf_bitmap_page_init(buf_block_t*,mtr_t*)" -> "abort()"
"ibuf_bitmap_page_init(buf_block_t*,mtr_t*)" -> "fil_page_set_type(unsigned char*,ulint)"
"xdes_find_bit(xdes_t*,ulint,ulint,ulint,mtr_t*)" -> "xdes_mtr_get_bit(const xdes_t*,ulint,ulint,mtr_t*)"
"trx_undo_page_init(ib_page_t*,ulint,mtr_t*)" -> "mach_write_to_2(unsigned char*,ulint)"
"trx_undo_page_init(ib_page_t*,ulint,mtr_t*)" -> "trx_undo_page_init_log(ib_page_t*,ulint,mtr_t*)"
"trx_undo_page_init(ib_page_t*,ulint,mtr_t*)" -> "fil_page_set_type(unsigned char*,ulint)"
"trx_undo_page_init_log(ib_page_t*,ulint,mtr_t*)" -> "mlog_write_initial_log_record(const unsigned char*,unsigned char,mtr_t*)"
"trx_undo_page_init_log(ib_page_t*,ulint,mtr_t*)" -> "mlog_catenate_ulint_compressed(mtr_t*,ulint)"
"mlog_catenate_ulint_compressed(mtr_t*,ulint)" -> "mach_write_compressed(unsigned char*,ulint)"
"mlog_catenate_ulint_compressed(mtr_t*,ulint)" -> "mlog_close(mtr_t*,unsigned char*)"
"mlog_catenate_ulint_compressed(mtr_t*,ulint)" -> "mlog_open(mtr_t*,ulint)"
"trx_undo_header_add_space_for_xid(ib_page_t*,trx_ulogf_t*,mtr_t*)" -> "mlog_write_ulint(unsigned char*,ulint,unsigned char,mtr_t*)"
"trx_undo_header_add_space_for_xid(ib_page_t*,trx_ulogf_t*,mtr_t*)" -> "mach_read_from_2(const unsigned char*)"
"trx_undo_header_add_space_for_xid(ib_page_t*,trx_ulogf_t*,mtr_t*)" -> "abort()"
"trx_undo_header_add_space_for_xid(ib_page_t*,trx_ulogf_t*,mtr_t*)" -> "ut_dbg_assertion_failed(const char*,const char*,ulint)"
"trx_undo_header_add_space_for_xid(ib_page_t*,trx_ulogf_t*,mtr_t*)" -> "__builtin_expect(long int,long int)"
"trx_undo_reuse_cached(trx_t*,trx_rseg_t*,ulint,trx_id_t,const XID*,mtr_t*)" -> "trx_undo_insert_header_reuse(ib_page_t*,trx_id_t,mtr_t*)"
"trx_undo_reuse_cached(trx_t*,trx_rseg_t*,ulint,trx_id_t,const XID*,mtr_t*)" -> "__builtin_expect(long int,long int)"
"trx_undo_reuse_cached(trx_t*,trx_rseg_t*,ulint,trx_id_t,const XID*,mtr_t*)" -> "mach_read_from_2(const unsigned char*)"
"trx_undo_reuse_cached(trx_t*,trx_rseg_t*,ulint,trx_id_t,const XID*,mtr_t*)" -> "trx_undo_header_add_space_for_xid(ib_page_t*,trx_ulogf_t*,mtr_t*)"
"trx_undo_reuse_cached(trx_t*,trx_rseg_t*,ulint,trx_id_t,const XID*,mtr_t*)" -> "mem_analyze_corruption(void*)"
"trx_undo_reuse_cached(trx_t*,trx_rseg_t*,ulint,trx_id_t,const XID*,mtr_t*)" -> "trx_undo_page_get(ulint,ulint,ulint,mtr_t*)"
"trx_undo_reuse_cached(trx_t*,trx_rseg_t*,ulint,trx_id_t,const XID*,mtr_t*)" -> "trx_undo_mem_init_for_reuse(trx_undo_t*,trx_id_t,const XID*,ulint)"
"trx_undo_reuse_cached(trx_t*,trx_rseg_t*,ulint,trx_id_t,const XID*,mtr_t*)" -> "trx_undo_header_create(ib_page_t*,trx_id_t,mtr_t*)"
"trx_undo_reuse_cached(trx_t*,trx_rseg_t*,ulint,trx_id_t,const XID*,mtr_t*)" -> "ut_list_remove(List&,Type&,size_t) [with List = ut_list_base<trx_undo_t>,Type = trx_undo_t,size_t = long unsigned int]"
"trx_undo_reuse_cached(trx_t*,trx_rseg_t*,ulint,trx_id_t,const XID*,mtr_t*)" -> "abort()"
"trx_undo_reuse_cached(trx_t*,trx_rseg_t*,ulint,trx_id_t,const XID*,mtr_t*)" -> "fprintf(FILE*,const char*,...)"
"trx_undo_reuse_cached(trx_t*,trx_rseg_t*,ulint,trx_id_t,const XID*,mtr_t*)" -> "ut_dbg_assertion_failed(const char*,const char*,ulint)"
"trx_undo_insert_header_reuse(ib_page_t*,trx_id_t,mtr_t*)" -> "trx_undo_insert_header_reuse_log(const ib_page_t*,trx_id_t,mtr_t*)"
"trx_undo_insert_header_reuse(ib_page_t*,trx_id_t,mtr_t*)" -> "mach_write_to_8(void*,ib_uint64_t)"
"trx_undo_insert_header_reuse(ib_page_t*,trx_id_t,mtr_t*)" -> "abort()"
"trx_undo_insert_header_reuse(ib_page_t*,trx_id_t,mtr_t*)" -> "mach_write_to_1(unsigned char*,ulint)"
"trx_undo_insert_header_reuse(ib_page_t*,trx_id_t,mtr_t*)" -> "mach_write_to_2(unsigned char*,ulint)"
"trx_undo_insert_header_reuse(ib_page_t*,trx_id_t,mtr_t*)" -> "mach_read_from_2(const unsigned char*)"
"trx_undo_insert_header_reuse(ib_page_t*,trx_id_t,mtr_t*)" -> "ut_dbg_assertion_failed(const char*,const char*,ulint)"
"trx_undo_insert_header_reuse(ib_page_t*,trx_id_t,mtr_t*)" -> "__builtin_expect(long int,long int)"
"trx_undo_insert_header_reuse_log(const ib_page_t*,trx_id_t,mtr_t*)" -> "mlog_write_initial_log_record(const unsigned char*,unsigned char,mtr_t*)"
"trx_undo_insert_header_reuse_log(const ib_page_t*,trx_id_t,mtr_t*)" -> "mlog_catenate_ull_compressed(mtr_t*,ib_uint64_t)"
"trx_undo_mem_init_for_reuse(trx_undo_t*,trx_id_t,const XID*,ulint)" -> "fprintf(FILE*,const char*,...)"
"trx_undo_mem_init_for_reuse(trx_undo_t*,trx_id_t,const XID*,ulint)" -> "ut_dbg_assertion_failed(const char*,const char*,ulint)"
"trx_undo_mem_init_for_reuse(trx_undo_t*,trx_id_t,const XID*,ulint)" -> "abort()"
"trx_undo_mem_init_for_reuse(trx_undo_t*,trx_id_t,const XID*,ulint)" -> "__builtin_expect(long int,long int)"
"trx_undo_mem_init_for_reuse(trx_undo_t*,trx_id_t,const XID*,ulint)" -> "mem_analyze_corruption(void*)"
"trx_undo_mark_as_dict_operation(trx_t*,trx_undo_t*,mtr_t*)" -> "mlog_write_ull(unsigned char*,ib_uint64_t,mtr_t*)"
"trx_undo_mark_as_dict_operation(trx_t*,trx_undo_t*,mtr_t*)" -> "ut_dbg_assertion_failed(const char*,const char*,ulint)"
"trx_undo_mark_as_dict_operation(trx_t*,trx_undo_t*,mtr_t*)" -> "trx_get_dict_operation(const trx_t*)"
"trx_undo_mark_as_dict_operation(trx_t*,trx_undo_t*,mtr_t*)" -> "abort()"
"trx_undo_mark_as_dict_operation(trx_t*,trx_undo_t*,mtr_t*)" -> "mlog_write_ulint(unsigned char*,ulint,unsigned char,mtr_t*)"
"trx_undo_mark_as_dict_operation(trx_t*,trx_undo_t*,mtr_t*)" -> "trx_undo_page_get(ulint,ulint,ulint,mtr_t*)"
"trx_undo_page_report_modify(ib_page_t*,trx_t*,dict_index_t*,const rec_t*,const ulint*,const upd_t*,ulint,mtr_t*)" -> "trx_read_roll_ptr(const unsigned char*)"
"trx_undo_page_report_modify(ib_page_t*,trx_t*,dict_index_t*,const rec_t*,const ulint*,const upd_t*,ulint,mtr_t*)" -> "abort()"
"trx_undo_page_report_modify(ib_page_t*,trx_t*,dict_index_t*,const rec_t*,const ulint*,const upd_t*,ulint,mtr_t*)" -> "mach_write_compressed(unsigned char*,ulint)"
"trx_undo_page_report_modify(ib_page_t*,trx_t*,dict_index_t*,const rec_t*,const ulint*,const upd_t*,ulint,mtr_t*)" -> "dict_index_get_nth_col_pos(const dict_index_t*,ulint)"
"trx_undo_page_report_modify(ib_page_t*,trx_t*,dict_index_t*,const rec_t*,const ulint*,const upd_t*,ulint,mtr_t*)" -> "dict_table_get_n_cols(const dict_table_t*)"
"trx_undo_page_report_modify(ib_page_t*,trx_t*,dict_index_t*,const rec_t*,const ulint*,const upd_t*,ulint,mtr_t*)" -> "mach_write_to_2(unsigned char*,ulint)"
"trx_undo_page_report_modify(ib_page_t*,trx_t*,dict_index_t*,const rec_t*,const ulint*,const upd_t*,ulint,mtr_t*)" -> "rec_get_nth_field_offs(const ulint*,ulint,ulint*)"
"trx_undo_page_report_modify(ib_page_t*,trx_t*,dict_index_t*,const rec_t*,const ulint*,const upd_t*,ulint,mtr_t*)" -> "upd_get_n_fields(const upd_t*)"
"trx_undo_page_report_modify(ib_page_t*,trx_t*,dict_index_t*,const rec_t*,const ulint*,const upd_t*,ulint,mtr_t*)" -> "rec_get_deleted_flag(const rec_t*,ulint)"
"trx_undo_page_report_modify(ib_page_t*,trx_t*,dict_index_t*,const rec_t*,const ulint*,const upd_t*,ulint,mtr_t*)" -> "mach_read_from_2(const unsigned char*)"
"trx_undo_page_report_modify(ib_page_t*,trx_t*,dict_index_t*,const rec_t*,const ulint*,const upd_t*,ulint,mtr_t*)" -> "dict_index_get_n_unique(const dict_index_t*)"
"trx_undo_page_report_modify(ib_page_t*,trx_t*,dict_index_t*,const rec_t*,const ulint*,const upd_t*,ulint,mtr_t*)" -> "trx_read_trx_id(const unsigned char*)"
"trx_undo_page_report_modify(ib_page_t*,trx_t*,dict_index_t*,const rec_t*,const ulint*,const upd_t*,ulint,mtr_t*)" -> "trx_undo_left(const ib_page_t*,const unsigned char*)"
"trx_undo_page_report_modify(ib_page_t*,trx_t*,dict_index_t*,const rec_t*,const ulint*,const upd_t*,ulint,mtr_t*)" -> "dict_index_get_sys_col_pos(const dict_index_t*,ulint)"
"trx_undo_page_report_modify(ib_page_t*,trx_t*,dict_index_t*,const rec_t*,const ulint*,const upd_t*,ulint,mtr_t*)" -> "trx_undof_page_add_undo_rec_log(ib_page_t*,ulint,ulint,mtr_t*)"
"trx_undo_page_report_modify(ib_page_t*,trx_t*,dict_index_t*,const rec_t*,const ulint*,const upd_t*,ulint,mtr_t*)" -> "ut_dbg_assertion_failed(const char*,const char*,ulint)"
"trx_undo_page_report_modify(ib_page_t*,trx_t*,dict_index_t*,const rec_t*,const ulint*,const upd_t*,ulint,mtr_t*)" -> "trx_undo_page_report_modify_ext(unsigned char*,unsigned char*,ulint,ulint,const unsigned char**,ulint*)"
"trx_undo_page_report_modify(ib_page_t*,trx_t*,dict_index_t*,const rec_t*,const ulint*,const upd_t*,ulint,mtr_t*)" -> "__builtin_expect(long int,long int)"
"trx_undo_page_report_modify(ib_page_t*,trx_t*,dict_index_t*,const rec_t*,const ulint*,const upd_t*,ulint,mtr_t*)" -> "dict_max_field_len_store_undo(dict_table_t*,const dict_col_t*)"
"trx_undo_page_report_modify(ib_page_t*,trx_t*,dict_index_t*,const rec_t*,const ulint*,const upd_t*,ulint,mtr_t*)" -> "dict_index_is_clust(const dict_index_t*)"
"trx_undo_page_report_modify(ib_page_t*,trx_t*,dict_index_t*,const rec_t*,const ulint*,const upd_t*,ulint,mtr_t*)" -> "ut_memcpy(void*,const void*,ulint)"
"trx_undo_page_report_modify(ib_page_t*,trx_t*,dict_index_t*,const rec_t*,const ulint*,const upd_t*,ulint,mtr_t*)" -> "dict_table_zip_size(const dict_table_t*)"
"trx_undo_page_report_modify(ib_page_t*,trx_t*,dict_index_t*,const rec_t*,const ulint*,const upd_t*,ulint,mtr_t*)" -> "mach_ull_write_compressed(unsigned char*,ib_uint64_t)"
"trx_undo_page_report_modify(ib_page_t*,trx_t*,dict_index_t*,const rec_t*,const ulint*,const upd_t*,ulint,mtr_t*)" -> "rec_get_info_bits(const rec_t*,ulint)"
"trx_undo_page_report_modify(ib_page_t*,trx_t*,dict_index_t*,const rec_t*,const ulint*,const upd_t*,ulint,mtr_t*)" -> "dict_table_is_comp(const dict_table_t*)"
"trx_undo_page_report_modify(ib_page_t*,trx_t*,dict_index_t*,const rec_t*,const ulint*,const upd_t*,ulint,mtr_t*)" -> "dict_index_get_nth_col(const dict_index_t*,ulint)"
"trx_undo_page_report_modify(ib_page_t*,trx_t*,dict_index_t*,const rec_t*,const ulint*,const upd_t*,ulint,mtr_t*)" -> "mach_ull_write_much_compressed(unsigned char*,ib_uint64_t)"
"trx_undo_page_report_modify(ib_page_t*,trx_t*,dict_index_t*,const rec_t*,const ulint*,const upd_t*,ulint,mtr_t*)" -> "rec_offs_nth_extern(const ulint*,ulint)"
"trx_read_roll_ptr(const unsigned char*)" -> "mach_read_from_7(const unsigned char*)"
"mach_read_from_7(const unsigned char*)" -> "mach_read_from_3(const unsigned char*)"
"mach_read_from_7(const unsigned char*)" -> "ut_ull_create(ulint,ulint)"
"mach_read_from_7(const unsigned char*)" -> "mach_read_from_4(const unsigned char*)"
"trx_undof_page_add_undo_rec_log(ib_page_t*,ulint,ulint,mtr_t*)" -> "memcpy(void*,const void*,size_t)"
"trx_undof_page_add_undo_rec_log(ib_page_t*,ulint,ulint,mtr_t*)" -> "mlog_write_initial_log_record_fast(const unsigned char*,unsigned char,unsigned char*,mtr_t*)"
"trx_undof_page_add_undo_rec_log(ib_page_t*,ulint,ulint,mtr_t*)" -> "mlog_open(mtr_t*,ulint)"
"trx_undof_page_add_undo_rec_log(ib_page_t*,ulint,ulint,mtr_t*)" -> "mlog_close(mtr_t*,unsigned char*)"
"trx_undof_page_add_undo_rec_log(ib_page_t*,ulint,ulint,mtr_t*)" -> "mach_write_to_2(unsigned char*,ulint)"
"trx_undof_page_add_undo_rec_log(ib_page_t*,ulint,ulint,mtr_t*)" -> "mlog_catenate_string(mtr_t*,const unsigned char*,ulint)"
"trx_undo_page_report_modify_ext(unsigned char*,unsigned char*,ulint,ulint,const unsigned char**,ulint*)" -> "abort()"
"trx_undo_page_report_modify_ext(unsigned char*,unsigned char*,ulint,ulint,const unsigned char**,ulint*)" -> "trx_undo_page_fetch_ext(unsigned char*,ulint,ulint,const unsigned char*,ulint*)"
"trx_undo_page_report_modify_ext(unsigned char*,unsigned char*,ulint,ulint,const unsigned char**,ulint*)" -> "ut_dbg_assertion_failed(const char*,const char*,ulint)"
"trx_undo_page_report_modify_ext(unsigned char*,unsigned char*,ulint,ulint,const unsigned char**,ulint*)" -> "__builtin_expect(long int,long int)"
"trx_undo_page_report_modify_ext(unsigned char*,unsigned char*,ulint,ulint,const unsigned char**,ulint*)" -> "mach_write_compressed(unsigned char*,ulint)"
"trx_undo_page_fetch_ext(unsigned char*,ulint,ulint,const unsigned char*,ulint*)" -> "ut_dbg_assertion_failed(const char*,const char*,ulint)"
"trx_undo_page_fetch_ext(unsigned char*,ulint,ulint,const unsigned char*,ulint*)" -> "abort()"
"trx_undo_page_fetch_ext(unsigned char*,ulint,ulint,const unsigned char*,ulint*)" -> "memcpy(void*,const void*,size_t)"
"trx_undo_page_fetch_ext(unsigned char*,ulint,ulint,const unsigned char*,ulint*)" -> "btr_copy_externally_stored_field_prefix(unsigned char*,ulint,ulint,const unsigned char*,ulint)"
"trx_undo_page_fetch_ext(unsigned char*,ulint,ulint,const unsigned char*,ulint*)" -> "__builtin_expect(long int,long int)"
"btr_copy_externally_stored_field_prefix(unsigned char*,ulint,ulint,const unsigned char*,ulint)" -> "memcmp(const void*,const void*,size_t)"
"btr_copy_externally_stored_field_prefix(unsigned char*,ulint,ulint,const unsigned char*,ulint)" -> "mach_read_from_4(const unsigned char*)"
"btr_copy_externally_stored_field_prefix(unsigned char*,ulint,ulint,const unsigned char*,ulint)" -> "abort()"
"btr_copy_externally_stored_field_prefix(unsigned char*,ulint,ulint,const unsigned char*,ulint)" -> "ut_dbg_assertion_failed(const char*,const char*,ulint)"
"btr_copy_externally_stored_field_prefix(unsigned char*,ulint,ulint,const unsigned char*,ulint)" -> "__builtin_expect(long int,long int)"
"btr_copy_externally_stored_field_prefix(unsigned char*,ulint,ulint,const unsigned char*,ulint)" -> "btr_copy_externally_stored_field_prefix_low(unsigned char*,ulint,ulint,ulint,ulint,ulint)"
"btr_copy_externally_stored_field_prefix(unsigned char*,ulint,ulint,const unsigned char*,ulint)" -> "memcpy(void*,const void*,size_t)"
"btr_copy_externally_stored_field_prefix_low(unsigned char*,ulint,ulint,ulint,ulint,ulint)" -> "btr_copy_zblob_prefix(unsigned char*,ulint,ulint,ulint,ulint,ulint)"
"btr_copy_externally_stored_field_prefix_low(unsigned char*,ulint,ulint,ulint,ulint,ulint)" -> "__builtin_expect(long int,long int)"
"btr_copy_externally_stored_field_prefix_low(unsigned char*,ulint,ulint,ulint,ulint,ulint)" -> "btr_copy_blob_prefix(unsigned char*,ulint,ulint,ulint,ulint)"
"btr_copy_zblob_prefix(unsigned char*,ulint,ulint,ulint,ulint,ulint)" -> "ut_dbg_assertion_failed(const char*,const char*,ulint)"
"btr_copy_zblob_prefix(unsigned char*,ulint,ulint,ulint,ulint,ulint)" -> "fil_page_get_type(const unsigned char*)"
"btr_copy_zblob_prefix(unsigned char*,ulint,ulint,ulint,ulint,ulint)" -> "inflateInit_(z_streamp,const char*,int)"
"btr_copy_zblob_prefix(unsigned char*,ulint,ulint,ulint,ulint,ulint)" -> "mem_heap_create_func(ulint,ulint)"
"btr_copy_zblob_prefix(unsigned char*,ulint,ulint,ulint,ulint,ulint)" -> "abort()"
"btr_copy_zblob_prefix(unsigned char*,ulint,ulint,ulint,ulint,ulint)" -> "inflateEnd(z_streamp)"
"btr_copy_zblob_prefix(unsigned char*,ulint,ulint,ulint,ulint,ulint)" -> "buf_page_get_zip(ulint,ulint,ulint)"
"btr_copy_zblob_prefix(unsigned char*,ulint,ulint,ulint,ulint,ulint)" -> "inflate(z_streamp,int)"
"btr_copy_zblob_prefix(unsigned char*,ulint,ulint,ulint,ulint,ulint)" -> "mem_heap_free_func(mem_heap_t*,const char*,ulint)"
"btr_copy_zblob_prefix(unsigned char*,ulint,ulint,ulint,ulint,ulint)" -> "fprintf(FILE*,const char*,...)"
"btr_copy_zblob_prefix(unsigned char*,ulint,ulint,ulint,ulint,ulint)" -> "page_zip_set_alloc(void*,mem_heap_t*)"
"btr_copy_zblob_prefix(unsigned char*,ulint,ulint,ulint,ulint,ulint)" -> "__builtin_expect(long int,long int)"
"btr_copy_zblob_prefix(unsigned char*,ulint,ulint,ulint,ulint,ulint)" -> "buf_page_release_zip(buf_page_t*)"
"btr_copy_zblob_prefix(unsigned char*,ulint,ulint,ulint,ulint,ulint)" -> "mach_read_from_4(const unsigned char*)"
"btr_copy_zblob_prefix(unsigned char*,ulint,ulint,ulint,ulint,ulint)" -> "ut_print_timestamp(FILE*)"
"buf_page_get_zip(ulint,ulint,ulint)" -> "buf_page_set_accessed(buf_page_t*)"
"buf_page_get_zip(ulint,ulint,ulint)" -> "__sync_add_and_fetch_4(volatile void*,unsigned int)"
"buf_page_get_zip(ulint,ulint,ulint)" -> "pfs_mutex_exit_func(ib_mutex_t*)"
"buf_page_get_zip(ulint,ulint,ulint)" -> "buf_pool_get(ulint,ulint)"
"buf_page_get_zip(ulint,ulint,ulint)" -> "buf_page_get_io_fix(const buf_page_t*)"
"buf_page_get_zip(ulint,ulint,ulint)" -> "buf_page_make_young_if_needed(buf_page_t*)"
"buf_page_get_zip(ulint,ulint,ulint)" -> "pfs_rw_lock_s_unlock_func(rw_lock_t*)"
"buf_page_get_zip(ulint,ulint,ulint)" -> "buf_block_buf_fix_inc_func(buf_block_t*)"
"buf_page_get_zip(ulint,ulint,ulint)" -> "ut_dbg_assertion_failed(const char*,const char*,ulint)"
"buf_page_get_zip(ulint,ulint,ulint)" -> "pfs_mutex_enter_func(ib_mutex_t*,const char*,ulint)"
"buf_page_get_zip(ulint,ulint,ulint)" -> "buf_page_hash_get_locked(buf_pool_t*,ulint,ulint,rw_lock_t**,ulint)"
"buf_page_get_zip(ulint,ulint,ulint)" -> "buf_page_get_state(const buf_page_t*)"
"buf_page_get_zip(ulint,ulint,ulint)" -> "buf_read_page(ulint,ulint,ulint)"
"buf_page_get_zip(ulint,ulint,ulint)" -> "buf_block_try_discard_uncompressed(ulint,ulint)"
"buf_page_get_zip(ulint,ulint,ulint)" -> "os_thread_sleep(ulint)"
"buf_page_get_zip(ulint,ulint,ulint)" -> "abort()"
"buf_read_page(ulint,ulint,ulint)" -> "buf_read_page_low(dberr_t*,bool,ulint,ulint,ulint,ulint,ib_int64_t,ulint)"
"buf_read_page(ulint,ulint,ulint)" -> "fprintf(FILE*,const char*,...)"
"buf_read_page(ulint,ulint,ulint)" -> "ut_print_timestamp(FILE*)"
"buf_read_page(ulint,ulint,ulint)" -> "Indexer>::add(Type) [with Type = long unsigned int,int N = 1,Indexer = single_indexer_t]"
"buf_read_page(ulint,ulint,ulint)" -> "fil_space_get_version(ulint)"
"buf_block_try_discard_uncompressed(ulint,ulint)" -> "buf_page_hash_get_locked(buf_pool_t*,ulint,ulint,rw_lock_t**,ulint)"
"buf_block_try_discard_uncompressed(ulint,ulint)" -> "pfs_mutex_exit_func(ib_mutex_t*)"
"buf_block_try_discard_uncompressed(ulint,ulint)" -> "buf_pool_get(ulint,ulint)"
"buf_block_try_discard_uncompressed(ulint,ulint)" -> "pfs_mutex_enter_func(ib_mutex_t*,const char*,ulint)"
"buf_block_try_discard_uncompressed(ulint,ulint)" -> "buf_LRU_free_page(buf_page_t*,bool)"
"buf_page_release_zip(buf_page_t*)" -> "buf_block_unfix(buf_block_t*)"
"buf_page_release_zip(buf_page_t*)" -> "ut_dbg_assertion_failed(const char*,const char*,ulint)"
"buf_page_release_zip(buf_page_t*)" -> "abort()"
"buf_page_release_zip(buf_page_t*)" -> "buf_page_get_state(const buf_page_t*)"
"btr_copy_blob_prefix(unsigned char*,ulint,ulint,ulint,ulint)" -> "mtr_commit(mtr_t*)"
"btr_copy_blob_prefix(unsigned char*,ulint,ulint,ulint,ulint)" -> "btr_blob_get_next_page_no(const unsigned char*)"
"btr_copy_blob_prefix(unsigned char*,ulint,ulint,ulint,ulint)" -> "btr_blob_get_part_len(const unsigned char*)"
"btr_copy_blob_prefix(unsigned char*,ulint,ulint,ulint,ulint)" -> "buf_page_get_gen(ulint,ulint,ulint,ulint,buf_block_t*,ulint,const char*,ulint,mtr_t*)"
"btr_copy_blob_prefix(unsigned char*,ulint,ulint,ulint,ulint)" -> "mtr_start(mtr_t*)"
"btr_copy_blob_prefix(unsigned char*,ulint,ulint,ulint,ulint)" -> "btr_check_blob_fil_page_type(ulint,ulint,const ib_page_t*,ulint)"
"btr_copy_blob_prefix(unsigned char*,ulint,ulint,ulint,ulint)" -> "ut_min(ulint,ulint)"
"btr_copy_blob_prefix(unsigned char*,ulint,ulint,ulint,ulint)" -> "memcpy(void*,const void*,size_t)"
"btr_blob_get_next_page_no(const unsigned char*)" -> "mach_read_from_4(const unsigned char*)"
"btr_blob_get_part_len(const unsigned char*)" -> "mach_read_from_4(const unsigned char*)"
"dict_max_field_len_store_undo(dict_table_t*,const dict_col_t*)" -> "dict_table_get_format(const dict_table_t*)"
"dict_table_get_format(const dict_table_t*)" -> "dict_tf_get_format(ulint)"
"mach_ull_write_much_compressed(unsigned char*,ib_uint64_t)" -> "mach_write_compressed(unsigned char*,ulint)"
"trx_undo_free_last_page_func(trx_undo_t*,mtr_t*)" -> "trx_undo_free_page(trx_rseg_t*,ulint,ulint,ulint,ulint,mtr_t*)"
"trx_undo_free_page(trx_rseg_t*,ulint,ulint,ulint,ulint,mtr_t*)" -> "trx_rsegf_get(ulint,ulint,ulint,mtr_t*)"
"trx_undo_free_page(trx_rseg_t*,ulint,ulint,ulint,ulint,mtr_t*)" -> "ut_dbg_assertion_failed(const char*,const char*,ulint)"
"trx_undo_free_page(trx_rseg_t*,ulint,ulint,ulint,ulint,mtr_t*)" -> "__builtin_expect(long int,long int)"
"trx_undo_free_page(trx_rseg_t*,ulint,ulint,ulint,ulint,mtr_t*)" -> "flst_get_last(const flst_base_node_t*,mtr_t*)"
"trx_undo_free_page(trx_rseg_t*,ulint,ulint,ulint,ulint,mtr_t*)" -> "mtr_read_ulint(const unsigned char*,ulint,mtr_t*)"
"trx_undo_free_page(trx_rseg_t*,ulint,ulint,ulint,ulint,mtr_t*)" -> "fseg_free_page(fseg_header_t*,ulint,ulint,mtr_t*)"
"trx_undo_free_page(trx_rseg_t*,ulint,ulint,ulint,ulint,mtr_t*)" -> "mlog_write_ulint(unsigned char*,ulint,unsigned char,mtr_t*)"
"trx_undo_free_page(trx_rseg_t*,ulint,ulint,ulint,ulint,mtr_t*)" -> "trx_undo_page_get(ulint,ulint,ulint,mtr_t*)"
"trx_undo_free_page(trx_rseg_t*,ulint,ulint,ulint,ulint,mtr_t*)" -> "abort()"
"trx_undo_free_page(trx_rseg_t*,ulint,ulint,ulint,ulint,mtr_t*)" -> "flst_remove(flst_base_node_t*,flst_node_t*,mtr_t*)"
"trx_undo_add_page(trx_t*,trx_undo_t*,mtr_t*)" -> "fseg_alloc_free_page_general(fseg_header_t*,ulint,unsigned char,ulint,mtr_t*,mtr_t*)"
"trx_undo_add_page(trx_t*,trx_undo_t*,mtr_t*)" -> "trx_undo_page_init(ib_page_t*,ulint,mtr_t*)"
"trx_undo_add_page(trx_t*,trx_undo_t*,mtr_t*)" -> "fsp_reserve_free_extents(ulint*,ulint,ulint,ulint,mtr_t*)"
"trx_undo_add_page(trx_t*,trx_undo_t*,mtr_t*)" -> "flst_add_last(flst_base_node_t*,flst_node_t*,mtr_t*)"
"trx_undo_add_page(trx_t*,trx_undo_t*,mtr_t*)" -> "trx_undo_page_get(ulint,ulint,ulint,mtr_t*)"
"trx_undo_add_page(trx_t*,trx_undo_t*,mtr_t*)" -> "fil_space_release_free_extents(ulint,ulint)"
"trx_undo_add_page(trx_t*,trx_undo_t*,mtr_t*)" -> "buf_block_get_page_no(const buf_block_t*)"
"trx_undo_erase_page_end(ib_page_t*,mtr_t*)" -> "mlog_write_initial_log_record(const unsigned char*,unsigned char,mtr_t*)"
"trx_undo_erase_page_end(ib_page_t*,mtr_t*)" -> "mach_read_from_2(const unsigned char*)"
"trx_undo_erase_page_end(ib_page_t*,mtr_t*)" -> "memset(void*,int,size_t)"
"trx_assign_rseg(trx_t*)" -> "trx_assign_rseg_low(ulong,ulint)"
"trx_assign_rseg(trx_t*)" -> "abort()"
"trx_assign_rseg(trx_t*)" -> "ut_dbg_assertion_failed(const char*,const char*,ulint)"
"trx_assign_rseg(trx_t*)" -> "__builtin_expect(long int,long int)"
"trx_assign_rseg_low(ulong,ulint)" -> "__builtin_expect(long int,long int)"
"trx_assign_rseg_low(ulong,ulint)" -> "abort()"
"trx_assign_rseg_low(ulong,ulint)" -> "ut_dbg_assertion_failed(const char*,const char*,ulint)"
"trx_undo_page_report_insert(ib_page_t*,trx_t*,dict_index_t*,const dtuple_t*,mtr_t*)" -> "mach_read_from_2(const unsigned char*)"
"trx_undo_page_report_insert(ib_page_t*,trx_t*,dict_index_t*,const dtuple_t*,mtr_t*)" -> "dict_index_get_n_unique(const dict_index_t*)"
"trx_undo_page_report_insert(ib_page_t*,trx_t*,dict_index_t*,const dtuple_t*,mtr_t*)" -> "mach_ull_write_much_compressed(unsigned char*,ib_uint64_t)"
"trx_undo_page_report_insert(ib_page_t*,trx_t*,dict_index_t*,const dtuple_t*,mtr_t*)" -> "trx_undo_left(const ib_page_t*,const unsigned char*)"
"trx_undo_page_report_insert(ib_page_t*,trx_t*,dict_index_t*,const dtuple_t*,mtr_t*)" -> "mach_write_compressed(unsigned char*,ulint)"
"trx_undo_page_report_insert(ib_page_t*,trx_t*,dict_index_t*,const dtuple_t*,mtr_t*)" -> "trx_undo_page_set_next_prev_and_add(ib_page_t*,unsigned char*,mtr_t*)"
"trx_undo_page_report_insert(ib_page_t*,trx_t*,dict_index_t*,const dtuple_t*,mtr_t*)" -> "ut_memcpy(void*,const void*,ulint)"
"trx_undo_page_report_insert(ib_page_t*,trx_t*,dict_index_t*,const dtuple_t*,mtr_t*)" -> "dfield_get_len(const dfield_t*)"
"trx_undo_page_set_next_prev_and_add(ib_page_t*,unsigned char*,mtr_t*)" -> "trx_undof_page_add_undo_rec_log(ib_page_t*,ulint,ulint,mtr_t*)"
"trx_undo_page_set_next_prev_and_add(ib_page_t*,unsigned char*,mtr_t*)" -> "__builtin_expect(long int,long int)"
"trx_undo_page_set_next_prev_and_add(ib_page_t*,unsigned char*,mtr_t*)" -> "mach_write_to_2(unsigned char*,ulint)"
"trx_undo_page_set_next_prev_and_add(ib_page_t*,unsigned char*,mtr_t*)" -> "trx_undo_left(const ib_page_t*,const unsigned char*)"
"trx_undo_page_set_next_prev_and_add(ib_page_t*,unsigned char*,mtr_t*)" -> "mach_read_from_2(const unsigned char*)"
"row_upd_index_entry_sys_field(dtuple_t*,dict_index_t*,ulint,ib_uint64_t)" -> "trx_write_trx_id(unsigned char*,trx_id_t)"
"row_upd_index_entry_sys_field(dtuple_t*,dict_index_t*,ulint,ib_uint64_t)" -> "dict_index_get_sys_col_pos(const dict_index_t*,ulint)"
"row_upd_index_entry_sys_field(dtuple_t*,dict_index_t*,ulint,ib_uint64_t)" -> "trx_write_roll_ptr(unsigned char*,roll_ptr_t)"
"trx_write_trx_id(unsigned char*,trx_id_t)" -> "mach_write_to_6(unsigned char*,ib_uint64_t)"
"mach_write_to_6(unsigned char*,ib_uint64_t)" -> "mach_write_to_2(unsigned char*,ulint)"
"mach_write_to_6(unsigned char*,ib_uint64_t)" -> "mach_write_to_4(unsigned char*,ulint)"
"dtuple_convert_back_big_rec(dict_index_t*,dtuple_t*,big_rec_t*)" -> "dfield_get_len(const dfield_t*)"
"dtuple_convert_back_big_rec(dict_index_t*,dtuple_t*,big_rec_t*)" -> "mem_heap_free_func(mem_heap_t*,const char*,ulint)"
"dtuple_convert_back_big_rec(dict_index_t*,dtuple_t*,big_rec_t*)" -> "dfield_set_data(dfield_t*,const void*,ulint)"
"dtuple_convert_big_rec(dict_index_t*,dtuple_t*,ulint*)" -> "abort()"
"dtuple_convert_big_rec(dict_index_t*,dtuple_t*,ulint*)" -> "__builtin_expect(long int,long int)"
"dtuple_convert_big_rec(dict_index_t*,dtuple_t*,ulint*)" -> "dict_table_zip_size(const dict_table_t*)"
"dtuple_convert_big_rec(dict_index_t*,dtuple_t*,ulint*)" -> "_IO_putc(int,_IO_FILE*)"
"dtuple_convert_big_rec(dict_index_t*,dtuple_t*,ulint*)" -> "__builtin_fwrite(const void*,size_t,size_t,FILE*)"
"dtuple_convert_big_rec(dict_index_t*,dtuple_t*,ulint*)" -> "rec_get_converted_size(dict_index_t*,const dtuple_t*,ulint)"
"dtuple_convert_big_rec(dict_index_t*,dtuple_t*,ulint*)" -> "page_zip_rec_needs_ext(ulint,ulint,ulint,ulint)"
"dtuple_convert_big_rec(dict_index_t*,dtuple_t*,ulint*)" -> "memset(void*,int,size_t)"
"dtuple_convert_big_rec(dict_index_t*,dtuple_t*,ulint*)" -> "dfield_get_len(const dfield_t*)"
"dtuple_convert_big_rec(dict_index_t*,dtuple_t*,ulint*)" -> "dfield_set_data(dfield_t*,const void*,ulint)"
"dtuple_convert_big_rec(dict_index_t*,dtuple_t*,ulint*)" -> "mem_heap_create_func(ulint,ulint)"
"dtuple_convert_big_rec(dict_index_t*,dtuple_t*,ulint*)" -> "dict_index_get_n_unique_in_tree(const dict_index_t*)"
"dtuple_convert_big_rec(dict_index_t*,dtuple_t*,ulint*)" -> "dfield_is_null(const dfield_t*)"
"dtuple_convert_big_rec(dict_index_t*,dtuple_t*,ulint*)" -> "dfield_set_ext(dfield_t*)"
"dtuple_convert_big_rec(dict_index_t*,dtuple_t*,ulint*)" -> "mem_heap_alloc(mem_heap_t*,ulint)"
"dtuple_convert_big_rec(dict_index_t*,dtuple_t*,ulint*)" -> "dtuple_print(FILE*,const dtuple_t*)"
"dtuple_convert_big_rec(dict_index_t*,dtuple_t*,ulint*)" -> "fprintf(FILE*,const char*,...)"
"dtuple_convert_big_rec(dict_index_t*,dtuple_t*,ulint*)" -> "dfield_is_ext(const dfield_t*)"
"dtuple_convert_big_rec(dict_index_t*,dtuple_t*,ulint*)" -> "ut_dbg_assertion_failed(const char*,const char*,ulint)"
"dtuple_convert_big_rec(dict_index_t*,dtuple_t*,ulint*)" -> "dict_table_is_comp(const dict_table_t*)"
"dtuple_convert_big_rec(dict_index_t*,dtuple_t*,ulint*)" -> "dict_table_get_format(const dict_table_t*)"
"dtuple_convert_big_rec(dict_index_t*,dtuple_t*,ulint*)" -> "dict_index_is_clust(const dict_index_t*)"
"dtuple_convert_big_rec(dict_index_t*,dtuple_t*,ulint*)" -> "memcpy(void*,const void*,size_t)"
"dtuple_convert_big_rec(dict_index_t*,dtuple_t*,ulint*)" -> "mem_heap_free_func(mem_heap_t*,const char*,ulint)"
"dtuple_convert_big_rec(dict_index_t*,dtuple_t*,ulint*)" -> "dtuple_get_n_fields(const dtuple_t*)"
"dtuple_convert_big_rec(dict_index_t*,dtuple_t*,ulint*)" -> "dtuple_check_typed_no_assert(const dtuple_t*)"
"dtuple_convert_big_rec(dict_index_t*,dtuple_t*,ulint*)" -> "dict_index_get_n_fields(const dict_index_t*)"
"dtuple_check_typed_no_assert(const dtuple_t*)" -> "fprintf(FILE*,const char*,...)"
"dtuple_check_typed_no_assert(const dtuple_t*)" -> "dfield_check_typed_no_assert(const dfield_t*)"
"dtuple_check_typed_no_assert(const dtuple_t*)" -> "_IO_putc(int,_IO_FILE*)"
"dtuple_check_typed_no_assert(const dtuple_t*)" -> "__builtin_fwrite(const void*,size_t,size_t,FILE*)"
"dtuple_check_typed_no_assert(const dtuple_t*)" -> "dtuple_get_n_fields(const dtuple_t*)"
"dtuple_check_typed_no_assert(const dtuple_t*)" -> "dtuple_print(FILE*,const dtuple_t*)"
"dfield_check_typed_no_assert(const dfield_t*)" -> "dfield_get_len(const dfield_t*)"
"dfield_check_typed_no_assert(const dfield_t*)" -> "fprintf(FILE*,const char*,...)"
"btr_page_get_split_rec_to_left(btr_cur_t*,rec_t**)" -> "page_get_infimum_offset(const ib_page_t*)"
"btr_page_get_split_rec_to_left(btr_cur_t*,rec_t**)" -> "btr_cur_get_page(btr_cur_t*)"
"btr_page_get_split_rec_to_left(btr_cur_t*,rec_t**)" -> "page_rec_get_next(rec_t*)"
"btr_page_get_split_rec_to_left(btr_cur_t*,rec_t**)" -> "page_header_get_offs(const ib_page_t*,ulint)"
"btr_page_get_split_rec_to_right(btr_cur_t*,rec_t**)" -> "page_header_get_offs(const ib_page_t*,ulint)"
"btr_page_get_split_rec_to_right(btr_cur_t*,rec_t**)" -> "page_rec_is_supremum(const rec_t*)"
"btr_page_get_split_rec_to_right(btr_cur_t*,rec_t**)" -> "btr_cur_get_page(btr_cur_t*)"
"btr_page_get_split_rec_to_right(btr_cur_t*,rec_t**)" -> "page_rec_get_next(rec_t*)"
"rec_get_converted_size_comp_prefix(const dict_index_t*,const dfield_t*,ulint,ulint*)" -> "rec_get_converted_size_comp_prefix_low(const dict_index_t*,const dfield_t*,ulint,ulint*,bool)"
"btr_search_update_hash_on_insert(btr_cur_t*)" -> "page_rec_is_supremum(const rec_t*)"
"btr_search_update_hash_on_insert(btr_cur_t*)" -> "abort()"
"btr_search_update_hash_on_insert(btr_cur_t*)" -> "rec_fold(const rec_t*,const ulint*,ulint,ulint,index_id_t)"
"btr_search_update_hash_on_insert(btr_cur_t*)" -> "page_rec_is_infimum(const rec_t*)"
"btr_search_update_hash_on_insert(btr_cur_t*)" -> "ha_insert_for_fold_func(hash_table_t*,ulint,const rec_t*)"
"btr_search_update_hash_on_insert(btr_cur_t*)" -> "btr_search_check_free_space_in_heap()"
"btr_search_update_hash_on_insert(btr_cur_t*)" -> "__builtin_expect(long int,long int)"
"btr_search_update_hash_on_insert(btr_cur_t*)" -> "pfs_rw_lock_x_lock_func(rw_lock_t*,ulint,const char*,ulint)"
"btr_search_update_hash_on_insert(btr_cur_t*)" -> "page_rec_get_next_const(const rec_t*)"
"btr_search_update_hash_on_insert(btr_cur_t*)" -> "rec_offs_set_n_alloc(ulint*,ulint)"
"btr_search_update_hash_on_insert(btr_cur_t*)" -> "dict_index_is_ibuf(const dict_index_t*)"
"btr_search_update_hash_on_insert(btr_cur_t*)" -> "mem_heap_free_func(mem_heap_t*,const char*,ulint)"
"btr_search_update_hash_on_insert(btr_cur_t*)" -> "rec_get_offsets_func(const rec_t*,const dict_index_t*,ulint*,ulint,mem_heap_t**)"
"btr_search_update_hash_on_insert(btr_cur_t*)" -> "ut_dbg_assertion_failed(const char*,const char*,ulint)"
"btr_search_update_hash_on_insert(btr_cur_t*)" -> "pfs_rw_lock_x_unlock_func(rw_lock_t*)"
"btr_search_update_hash_node_on_insert(btr_cur_t*)" -> "ut_dbg_assertion_failed(const char*,const char*,ulint)"
"btr_search_update_hash_node_on_insert(btr_cur_t*)" -> "dict_index_is_ibuf(const dict_index_t*)"
"btr_search_update_hash_node_on_insert(btr_cur_t*)" -> "pfs_rw_lock_x_unlock_func(rw_lock_t*)"
"btr_search_update_hash_node_on_insert(btr_cur_t*)" -> "btr_search_update_hash_on_insert(btr_cur_t*)"
"btr_search_update_hash_node_on_insert(btr_cur_t*)" -> "__builtin_expect(long int,long int)"
"btr_search_update_hash_node_on_insert(btr_cur_t*)" -> "abort()"
"btr_search_update_hash_node_on_insert(btr_cur_t*)" -> "page_rec_get_next(rec_t*)"
"btr_search_update_hash_node_on_insert(btr_cur_t*)" -> "pfs_rw_lock_x_lock_func(rw_lock_t*,ulint,const char*,ulint)"
"btr_search_update_hash_node_on_insert(btr_cur_t*)" -> "ha_search_and_update_if_found_func(hash_table_t*,ulint,const rec_t*,const rec_t*)"
"ha_search_and_update_if_found_func(hash_table_t*,ulint,const rec_t*,const rec_t*)" -> "ha_search_with_data(hash_table_t*,ulint,const rec_t*)"
"btr_cur_pessimistic_insert(ulint,btr_cur_t*,ulint**,mem_heap_t**,dtuple_t*,rec_t**,big_rec_t**,ulint,que_thr_t*,mtr_t*)" -> "btr_cur_ins_lock_and_undo(ulint,btr_cur_t*,dtuple_t*,que_thr_t*,mtr_t*,ulint*)"
"btr_cur_pessimistic_insert(ulint,btr_cur_t*,ulint**,mem_heap_t**,dtuple_t*,rec_t**,big_rec_t**,ulint,que_thr_t*,mtr_t*)" -> "btr_root_raise_and_insert(ulint,btr_cur_t*,ulint**,mem_heap_t**,const dtuple_t*,ulint,mtr_t*)"
"btr_cur_pessimistic_insert(ulint,btr_cur_t*,ulint**,mem_heap_t**,dtuple_t*,rec_t**,big_rec_t**,ulint,que_thr_t*,mtr_t*)" -> "dict_table_zip_size(const dict_table_t*)"
"btr_cur_pessimistic_insert(ulint,btr_cur_t*,ulint**,mem_heap_t**,dtuple_t*,rec_t**,big_rec_t**,ulint,que_thr_t*,mtr_t*)" -> "page_update_max_trx_id(buf_block_t*,page_zip_des_t*,trx_id_t,mtr_t*)"
"btr_cur_pessimistic_insert(ulint,btr_cur_t*,ulint**,mem_heap_t**,dtuple_t*,rec_t**,big_rec_t**,ulint,que_thr_t*,mtr_t*)" -> "btr_cur_get_page_zip(btr_cur_t*)"
"btr_cur_pessimistic_insert(ulint,btr_cur_t*,ulint**,mem_heap_t**,dtuple_t*,rec_t**,big_rec_t**,ulint,que_thr_t*,mtr_t*)" -> "lock_update_insert(const buf_block_t*,const rec_t*)"
"btr_cur_pessimistic_insert(ulint,btr_cur_t*,ulint**,mem_heap_t**,dtuple_t*,rec_t**,big_rec_t**,ulint,que_thr_t*,mtr_t*)" -> "thr_get_trx(que_thr_t*)"
"btr_cur_pessimistic_insert(ulint,btr_cur_t*,ulint**,mem_heap_t**,dtuple_t*,rec_t**,big_rec_t**,ulint,que_thr_t*,mtr_t*)" -> "dict_table_is_comp(const dict_table_t*)"
"btr_cur_pessimistic_insert(ulint,btr_cur_t*,ulint**,mem_heap_t**,dtuple_t*,rec_t**,big_rec_t**,ulint,que_thr_t*,mtr_t*)" -> "dtuple_convert_big_rec(dict_index_t*,dtuple_t*,ulint*)"
"btr_cur_pessimistic_insert(ulint,btr_cur_t*,ulint**,mem_heap_t**,dtuple_t*,rec_t**,big_rec_t**,ulint,que_thr_t*,mtr_t*)" -> "dict_index_get_page(const dict_index_t*)"
"btr_cur_pessimistic_insert(ulint,btr_cur_t*,ulint**,mem_heap_t**,dtuple_t*,rec_t**,big_rec_t**,ulint,que_thr_t*,mtr_t*)" -> "buf_block_get_page_no(const buf_block_t*)"
"btr_cur_pessimistic_insert(ulint,btr_cur_t*,ulint**,mem_heap_t**,dtuple_t*,rec_t**,big_rec_t**,ulint,que_thr_t*,mtr_t*)" -> "dtuple_get_n_fields(const dtuple_t*)"
"btr_cur_pessimistic_insert(ulint,btr_cur_t*,ulint**,mem_heap_t**,dtuple_t*,rec_t**,big_rec_t**,ulint,que_thr_t*,mtr_t*)" -> "btr_page_get_prev(const ib_page_t*,mtr_t*)"
"btr_cur_pessimistic_insert(ulint,btr_cur_t*,ulint**,mem_heap_t**,dtuple_t*,rec_t**,big_rec_t**,ulint,que_thr_t*,mtr_t*)" -> "fsp_reserve_free_extents(ulint*,ulint,ulint,ulint,mtr_t*)"
"btr_cur_pessimistic_insert(ulint,btr_cur_t*,ulint**,mem_heap_t**,dtuple_t*,rec_t**,big_rec_t**,ulint,que_thr_t*,mtr_t*)" -> "rec_get_converted_size(dict_index_t*,const dtuple_t*,ulint)"
"btr_cur_pessimistic_insert(ulint,btr_cur_t*,ulint**,mem_heap_t**,dtuple_t*,rec_t**,big_rec_t**,ulint,que_thr_t*,mtr_t*)" -> "__builtin_expect(long int,long int)"
"btr_cur_pessimistic_insert(ulint,btr_cur_t*,ulint**,mem_heap_t**,dtuple_t*,rec_t**,big_rec_t**,ulint,que_thr_t*,mtr_t*)" -> "dtuple_convert_back_big_rec(dict_index_t*,dtuple_t*,big_rec_t*)"
"btr_cur_pessimistic_insert(ulint,btr_cur_t*,ulint**,mem_heap_t**,dtuple_t*,rec_t**,big_rec_t**,ulint,que_thr_t*,mtr_t*)" -> "btr_search_update_hash_on_insert(btr_cur_t*)"
"btr_cur_pessimistic_insert(ulint,btr_cur_t*,ulint**,mem_heap_t**,dtuple_t*,rec_t**,big_rec_t**,ulint,que_thr_t*,mtr_t*)" -> "dict_index_is_clust(const dict_index_t*)"
"btr_cur_pessimistic_insert(ulint,btr_cur_t*,ulint**,mem_heap_t**,dtuple_t*,rec_t**,big_rec_t**,ulint,que_thr_t*,mtr_t*)" -> "page_zip_rec_needs_ext(ulint,ulint,ulint,ulint)"
"btr_cur_pessimistic_insert(ulint,btr_cur_t*,ulint**,mem_heap_t**,dtuple_t*,rec_t**,big_rec_t**,ulint,que_thr_t*,mtr_t*)" -> "btr_page_split_and_insert(ulint,btr_cur_t*,ulint**,mem_heap_t**,const dtuple_t*,ulint,mtr_t*)"
"btr_cur_pessimistic_insert(ulint,btr_cur_t*,ulint**,mem_heap_t**,dtuple_t*,rec_t**,big_rec_t**,ulint,que_thr_t*,mtr_t*)" -> "fil_space_release_free_extents(ulint,ulint)"
"btr_cur_pessimistic_insert(ulint,btr_cur_t*,ulint**,mem_heap_t**,dtuple_t*,rec_t**,big_rec_t**,ulint,que_thr_t*,mtr_t*)" -> "page_rec_is_infimum(const rec_t*)"
"btr_root_raise_and_insert(ulint,btr_cur_t*,ulint**,mem_heap_t**,const dtuple_t*,ulint,mtr_t*)" -> "dict_index_get_space(const dict_index_t*)"
"btr_root_raise_and_insert(ulint,btr_cur_t*,ulint**,mem_heap_t**,const dtuple_t*,ulint,mtr_t*)" -> "page_cur_tuple_insert(page_cur_t*,const dtuple_t*,dict_index_t*,ulint**,mem_heap_t**,ulint,mtr_t*)"
"btr_root_raise_and_insert(ulint,btr_cur_t*,ulint**,mem_heap_t**,const dtuple_t*,ulint,mtr_t*)" -> "page_cur_set_before_first(const buf_block_t*,page_cur_t*)"
"btr_root_raise_and_insert(ulint,btr_cur_t*,ulint**,mem_heap_t**,const dtuple_t*,ulint,mtr_t*)" -> "abort()"
"btr_root_raise_and_insert(ulint,btr_cur_t*,ulint**,mem_heap_t**,const dtuple_t*,ulint,mtr_t*)" -> "dict_index_get_page(const dict_index_t*)"
"btr_root_raise_and_insert(ulint,btr_cur_t*,ulint**,mem_heap_t**,const dtuple_t*,ulint,mtr_t*)" -> "dict_index_is_ibuf(const dict_index_t*)"
"btr_root_raise_and_insert(ulint,btr_cur_t*,ulint**,mem_heap_t**,const dtuple_t*,ulint,mtr_t*)" -> "page_cur_search(const buf_block_t*,const dict_index_t*,const dtuple_t*,ulint,page_cur_t*)"
"btr_root_raise_and_insert(ulint,btr_cur_t*,ulint**,mem_heap_t**,const dtuple_t*,ulint,mtr_t*)" -> "btr_root_fseg_validate(const fseg_header_t*,ulint)"
"btr_root_raise_and_insert(ulint,btr_cur_t*,ulint**,mem_heap_t**,const dtuple_t*,ulint,mtr_t*)" -> "buf_block_get_page_no(const buf_block_t*)"
"btr_root_raise_and_insert(ulint,btr_cur_t*,ulint**,mem_heap_t**,const dtuple_t*,ulint,mtr_t*)" -> "__builtin_expect(long int,long int)"
"btr_root_raise_and_insert(ulint,btr_cur_t*,ulint**,mem_heap_t**,const dtuple_t*,ulint,mtr_t*)" -> "ut_dbg_assertion_failed(const char*,const char*,ulint)"
"btr_root_raise_and_insert(ulint,btr_cur_t*,ulint**,mem_heap_t**,const dtuple_t*,ulint,mtr_t*)" -> "btr_page_get_level_low(const ib_page_t*)"
"btr_root_raise_and_insert(ulint,btr_cur_t*,ulint**,mem_heap_t**,const dtuple_t*,ulint,mtr_t*)" -> "btr_page_set_prev(ib_page_t*,page_zip_des_t*,ulint,mtr_t*)"
"btr_root_raise_and_insert(ulint,btr_cur_t*,ulint**,mem_heap_t**,const dtuple_t*,ulint,mtr_t*)" -> "page_copy_rec_list_end(buf_block_t*,buf_block_t*,rec_t*,dict_index_t*,mtr_t*)"
"btr_root_raise_and_insert(ulint,btr_cur_t*,ulint**,mem_heap_t**,const dtuple_t*,ulint,mtr_t*)" -> "btr_page_split_and_insert(ulint,btr_cur_t*,ulint**,mem_heap_t**,const dtuple_t*,ulint,mtr_t*)"
"btr_root_raise_and_insert(ulint,btr_cur_t*,ulint**,mem_heap_t**,const dtuple_t*,ulint,mtr_t*)" -> "btr_cur_get_page(btr_cur_t*)"
"btr_root_raise_and_insert(ulint,btr_cur_t*,ulint**,mem_heap_t**,const dtuple_t*,ulint,mtr_t*)" -> "dtuple_set_info_bits(dtuple_t*,ulint)"
"btr_root_raise_and_insert(ulint,btr_cur_t*,ulint**,mem_heap_t**,const dtuple_t*,ulint,mtr_t*)" -> "page_get_infimum_offset(const ib_page_t*)"
"btr_root_raise_and_insert(ulint,btr_cur_t*,ulint**,mem_heap_t**,const dtuple_t*,ulint,mtr_t*)" -> "btr_page_set_next(ib_page_t*,page_zip_des_t*,ulint,mtr_t*)"
"btr_root_raise_and_insert(ulint,btr_cur_t*,ulint**,mem_heap_t**,const dtuple_t*,ulint,mtr_t*)" -> "page_zip_copy_recs(page_zip_des_t*,ib_page_t*,const page_zip_des_t*,const ib_page_t*,dict_index_t*,mtr_t*)"
"btr_root_raise_and_insert(ulint,btr_cur_t*,ulint**,mem_heap_t**,const dtuple_t*,ulint,mtr_t*)" -> "page_get_page_no(const ib_page_t*)"
"btr_root_raise_and_insert(ulint,btr_cur_t*,ulint**,mem_heap_t**,const dtuple_t*,ulint,mtr_t*)" -> "btr_page_alloc(dict_index_t*,ulint,unsigned char,ulint,mtr_t*,mtr_t*)"
"btr_root_raise_and_insert(ulint,btr_cur_t*,ulint**,mem_heap_t**,const dtuple_t*,ulint,mtr_t*)" -> "page_rec_get_next(rec_t*)"
"btr_root_raise_and_insert(ulint,btr_cur_t*,ulint**,mem_heap_t**,const dtuple_t*,ulint,mtr_t*)" -> "dict_index_is_clust(const dict_index_t*)"
"btr_root_raise_and_insert(ulint,btr_cur_t*,ulint**,mem_heap_t**,const dtuple_t*,ulint,mtr_t*)" -> "btr_page_empty(buf_block_t*,page_zip_des_t*,dict_index_t*,ulint,mtr_t*)"
"btr_root_raise_and_insert(ulint,btr_cur_t*,ulint**,mem_heap_t**,const dtuple_t*,ulint,mtr_t*)" -> "btr_search_move_or_delete_hash_entries(buf_block_t*,buf_block_t*,dict_index_t*)"
"btr_root_raise_and_insert(ulint,btr_cur_t*,ulint**,mem_heap_t**,const dtuple_t*,ulint,mtr_t*)" -> "mem_heap_create_func(ulint,ulint)"
"btr_root_raise_and_insert(ulint,btr_cur_t*,ulint**,mem_heap_t**,const dtuple_t*,ulint,mtr_t*)" -> "ibuf_reset_free_bits(buf_block_t*)"
"btr_root_raise_and_insert(ulint,btr_cur_t*,ulint**,mem_heap_t**,const dtuple_t*,ulint,mtr_t*)" -> "btr_page_create(buf_block_t*,page_zip_des_t*,dict_index_t*,ulint,mtr_t*)"
"btr_root_raise_and_insert(ulint,btr_cur_t*,ulint**,mem_heap_t**,const dtuple_t*,ulint,mtr_t*)" -> "lock_update_root_raise(const buf_block_t*,const buf_block_t*)"
"btr_root_raise_and_insert(ulint,btr_cur_t*,ulint**,mem_heap_t**,const dtuple_t*,ulint,mtr_t*)" -> "page_zip_get_size(const page_zip_des_t*)"
"btr_root_raise_and_insert(ulint,btr_cur_t*,ulint**,mem_heap_t**,const dtuple_t*,ulint,mtr_t*)" -> "dtuple_get_info_bits(const dtuple_t*)"
"btr_root_raise_and_insert(ulint,btr_cur_t*,ulint**,mem_heap_t**,const dtuple_t*,ulint,mtr_t*)" -> "lock_move_rec_list_end(const buf_block_t*,const buf_block_t*,const rec_t*)"
"btr_root_raise_and_insert(ulint,btr_cur_t*,ulint**,mem_heap_t**,const dtuple_t*,ulint,mtr_t*)" -> "dict_index_build_node_ptr(const dict_index_t*,const rec_t*,ulint,mem_heap_t*,ulint)"
"btr_page_split_and_insert(ulint,btr_cur_t*,ulint**,mem_heap_t**,const dtuple_t*,ulint,mtr_t*)" -> "btr_page_insert_fits(btr_cur_t*,const rec_t*,ulint**,const dtuple_t*,ulint,mem_heap_t**)"
"btr_page_split_and_insert(ulint,btr_cur_t*,ulint**,mem_heap_t**,const dtuple_t*,ulint,mtr_t*)" -> "btr_insert_into_right_sibling(ulint,btr_cur_t*,ulint**,mem_heap_t*,const dtuple_t*,ulint,mtr_t*)"
"btr_page_split_and_insert(ulint,btr_cur_t*,ulint**,mem_heap_t**,const dtuple_t*,ulint,mtr_t*)" -> "buf_block_get_zip_size(const buf_block_t*)"
"btr_page_split_and_insert(ulint,btr_cur_t*,ulint**,mem_heap_t**,const dtuple_t*,ulint,mtr_t*)" -> "btr_page_tuple_smaller(btr_cur_t*,const dtuple_t*,ulint**,ulint,mem_heap_t**)"
"btr_page_split_and_insert(ulint,btr_cur_t*,ulint**,mem_heap_t**,const dtuple_t*,ulint,mtr_t*)" -> "page_is_leaf(const ib_page_t*)"
"btr_page_split_and_insert(ulint,btr_cur_t*,ulint**,mem_heap_t**,const dtuple_t*,ulint,mtr_t*)" -> "mem_heap_create_func(ulint,ulint)"
"btr_page_split_and_insert(ulint,btr_cur_t*,ulint**,mem_heap_t**,const dtuple_t*,ulint,mtr_t*)" -> "page_get_n_recs(const ib_page_t*)"
"btr_page_split_and_insert(ulint,btr_cur_t*,ulint**,mem_heap_t**,const dtuple_t*,ulint,mtr_t*)" -> "ibuf_reset_free_bits(buf_block_t*)"
"btr_page_split_and_insert(ulint,btr_cur_t*,ulint**,mem_heap_t**,const dtuple_t*,ulint,mtr_t*)" -> "dict_index_is_online_ddl(const dict_index_t*)"
"btr_page_split_and_insert(ulint,btr_cur_t*,ulint**,mem_heap_t**,const dtuple_t*,ulint,mtr_t*)" -> "btr_attach_half_pages(ulint,dict_index_t*,buf_block_t*,const rec_t*,buf_block_t*,ulint,mtr_t*)"
"btr_page_split_and_insert(ulint,btr_cur_t*,ulint**,mem_heap_t**,const dtuple_t*,ulint,mtr_t*)" -> "btr_page_get_level_low(const ib_page_t*)"
"btr_page_split_and_insert(ulint,btr_cur_t*,ulint**,mem_heap_t**,const dtuple_t*,ulint,mtr_t*)" -> "page_move_rec_list_end(buf_block_t*,buf_block_t*,rec_t*,dict_index_t*,mtr_t*)"
"btr_page_split_and_insert(ulint,btr_cur_t*,ulint**,mem_heap_t**,const dtuple_t*,ulint,mtr_t*)" -> "mem_alloc_func(ulint,ulint*)"
"btr_page_split_and_insert(ulint,btr_cur_t*,ulint**,mem_heap_t**,const dtuple_t*,ulint,mtr_t*)" -> "btr_page_get_split_rec_to_right(btr_cur_t*,rec_t**)"
"btr_page_split_and_insert(ulint,btr_cur_t*,ulint**,mem_heap_t**,const dtuple_t*,ulint,mtr_t*)" -> "dict_index_is_clust(const dict_index_t*)"
"btr_page_split_and_insert(ulint,btr_cur_t*,ulint**,mem_heap_t**,const dtuple_t*,ulint,mtr_t*)" -> "rec_get_converted_size(dict_index_t*,const dtuple_t*,ulint)"
"btr_page_split_and_insert(ulint,btr_cur_t*,ulint**,mem_heap_t**,const dtuple_t*,ulint,mtr_t*)" -> "abort()"
"btr_page_split_and_insert(ulint,btr_cur_t*,ulint**,mem_heap_t**,const dtuple_t*,ulint,mtr_t*)" -> "page_cur_search(const buf_block_t*,const dict_index_t*,const dtuple_t*,ulint,page_cur_t*)"
"btr_page_split_and_insert(ulint,btr_cur_t*,ulint**,mem_heap_t**,const dtuple_t*,ulint,mtr_t*)" -> "btr_page_alloc(dict_index_t*,ulint,unsigned char,ulint,mtr_t*,mtr_t*)"
"btr_page_split_and_insert(ulint,btr_cur_t*,ulint**,mem_heap_t**,const dtuple_t*,ulint,mtr_t*)" -> "page_delete_rec_list_start(rec_t*,buf_block_t*,dict_index_t*,mtr_t*)"
"btr_page_split_and_insert(ulint,btr_cur_t*,ulint**,mem_heap_t**,const dtuple_t*,ulint,mtr_t*)" -> "page_rec_get_next(rec_t*)"
"btr_page_split_and_insert(ulint,btr_cur_t*,ulint**,mem_heap_t**,const dtuple_t*,ulint,mtr_t*)" -> "btr_page_create(buf_block_t*,page_zip_des_t*,dict_index_t*,ulint,mtr_t*)"
"btr_page_split_and_insert(ulint,btr_cur_t*,ulint**,mem_heap_t**,const dtuple_t*,ulint,mtr_t*)" -> "page_delete_rec_list_end(rec_t*,buf_block_t*,dict_index_t*,ulint,ulint,mtr_t*)"
"btr_page_split_and_insert(ulint,btr_cur_t*,ulint**,mem_heap_t**,const dtuple_t*,ulint,mtr_t*)" -> "buf_block_get_page_no(const buf_block_t*)"
"btr_page_split_and_insert(ulint,btr_cur_t*,ulint**,mem_heap_t**,const dtuple_t*,ulint,mtr_t*)" -> "btr_search_move_or_delete_hash_entries(buf_block_t*,buf_block_t*,dict_index_t*)"
"btr_page_split_and_insert(ulint,btr_cur_t*,ulint**,mem_heap_t**,const dtuple_t*,ulint,mtr_t*)" -> "__builtin_expect(long int,long int)"
"btr_page_split_and_insert(ulint,btr_cur_t*,ulint**,mem_heap_t**,const dtuple_t*,ulint,mtr_t*)" -> "cmp_dtuple_rec(const dtuple_t*,const rec_t*,const ulint*)"
"btr_page_split_and_insert(ulint,btr_cur_t*,ulint**,mem_heap_t**,const dtuple_t*,ulint,mtr_t*)" -> "page_move_rec_list_start(buf_block_t*,buf_block_t*,rec_t*,dict_index_t*,mtr_t*)"
"btr_page_split_and_insert(ulint,btr_cur_t*,ulint**,mem_heap_t**,const dtuple_t*,ulint,mtr_t*)" -> "lock_update_split_right(const buf_block_t*,const buf_block_t*)"
"btr_page_split_and_insert(ulint,btr_cur_t*,ulint**,mem_heap_t**,const dtuple_t*,ulint,mtr_t*)" -> "mem_heap_empty(mem_heap_t*)"
"btr_page_split_and_insert(ulint,btr_cur_t*,ulint**,mem_heap_t**,const dtuple_t*,ulint,mtr_t*)" -> "lock_move_rec_list_end(const buf_block_t*,const buf_block_t*,const rec_t*)"
"btr_page_split_and_insert(ulint,btr_cur_t*,ulint**,mem_heap_t**,const dtuple_t*,ulint,mtr_t*)" -> "rec_get_offsets_func(const rec_t*,const dict_index_t*,ulint*,ulint,mem_heap_t**)"
"btr_page_split_and_insert(ulint,btr_cur_t*,ulint**,mem_heap_t**,const dtuple_t*,ulint,mtr_t*)" -> "btr_page_get_split_rec_to_left(btr_cur_t*,rec_t**)"
"btr_page_split_and_insert(ulint,btr_cur_t*,ulint**,mem_heap_t**,const dtuple_t*,ulint,mtr_t*)" -> "dict_index_get_lock(dict_index_t*)"
"btr_page_split_and_insert(ulint,btr_cur_t*,ulint**,mem_heap_t**,const dtuple_t*,ulint,mtr_t*)" -> "btr_page_get_split_rec(btr_cur_t*,const dtuple_t*,ulint)"
"btr_page_split_and_insert(ulint,btr_cur_t*,ulint**,mem_heap_t**,const dtuple_t*,ulint,mtr_t*)" -> "page_cur_tuple_insert(page_cur_t*,const dtuple_t*,dict_index_t*,ulint**,mem_heap_t**,ulint,mtr_t*)"
"btr_page_split_and_insert(ulint,btr_cur_t*,ulint**,mem_heap_t**,const dtuple_t*,ulint,mtr_t*)" -> "dict_index_get_n_unique_in_tree(const dict_index_t*)"
"btr_page_split_and_insert(ulint,btr_cur_t*,ulint**,mem_heap_t**,const dtuple_t*,ulint,mtr_t*)" -> "lock_update_split_left(const buf_block_t*,const buf_block_t*)"
"btr_page_split_and_insert(ulint,btr_cur_t*,ulint**,mem_heap_t**,const dtuple_t*,ulint,mtr_t*)" -> "page_get_infimum_offset(const ib_page_t*)"
"btr_page_split_and_insert(ulint,btr_cur_t*,ulint**,mem_heap_t**,const dtuple_t*,ulint,mtr_t*)" -> "page_zip_copy_recs(page_zip_des_t*,ib_page_t*,const page_zip_des_t*,const ib_page_t*,dict_index_t*,mtr_t*)"
"btr_page_split_and_insert(ulint,btr_cur_t*,ulint**,mem_heap_t**,const dtuple_t*,ulint,mtr_t*)" -> "ibuf_update_free_bits_for_two_pages_low(ulint,buf_block_t*,buf_block_t*,mtr_t*)"
"btr_page_split_and_insert(ulint,btr_cur_t*,ulint**,mem_heap_t**,const dtuple_t*,ulint,mtr_t*)" -> "page_get_middle_rec(ib_page_t*)"
"btr_page_split_and_insert(ulint,btr_cur_t*,ulint**,mem_heap_t**,const dtuple_t*,ulint,mtr_t*)" -> "lock_move_rec_list_start(const buf_block_t*,const buf_block_t*,const rec_t*,const rec_t*)"
"btr_page_split_and_insert(ulint,btr_cur_t*,ulint**,mem_heap_t**,const dtuple_t*,ulint,mtr_t*)" -> "rec_convert_dtuple_to_rec(unsigned char*,const dict_index_t*,const dtuple_t*,ulint)"
"btr_page_split_and_insert(ulint,btr_cur_t*,ulint**,mem_heap_t**,const dtuple_t*,ulint,mtr_t*)" -> "mem_free_func(void*,const char*,ulint)"
"btr_page_split_and_insert(ulint,btr_cur_t*,ulint**,mem_heap_t**,const dtuple_t*,ulint,mtr_t*)" -> "mtr_memo_release(mtr_t*,void*,ulint)"
"btr_page_split_and_insert(ulint,btr_cur_t*,ulint**,mem_heap_t**,const dtuple_t*,ulint,mtr_t*)" -> "ut_dbg_assertion_failed(const char*,const char*,ulint)"
"btr_page_split_and_insert(ulint,btr_cur_t*,ulint**,mem_heap_t**,const dtuple_t*,ulint,mtr_t*)" -> "btr_page_reorganize(page_cur_t*,dict_index_t*,mtr_t*)"
"btr_page_insert_fits(btr_cur_t*,const rec_t*,ulint**,const dtuple_t*,ulint,mem_heap_t**)" -> "page_get_n_recs(const ib_page_t*)"
"btr_page_insert_fits(btr_cur_t*,const rec_t*,ulint**,const dtuple_t*,ulint,mem_heap_t**)" -> "btr_cur_get_page(btr_cur_t*)"
"btr_page_insert_fits(btr_cur_t*,const rec_t*,ulint**,const dtuple_t*,ulint,mem_heap_t**)" -> "page_get_free_space_of_empty(ulint)"
"btr_page_insert_fits(btr_cur_t*,const rec_t*,ulint**,const dtuple_t*,ulint,mem_heap_t**)" -> "page_dir_calc_reserved_space(ulint)"
"btr_page_insert_fits(btr_cur_t*,const rec_t*,ulint**,const dtuple_t*,ulint,mem_heap_t**)" -> "page_rec_get_next(rec_t*)"
"btr_page_insert_fits(btr_cur_t*,const rec_t*,ulint**,const dtuple_t*,ulint,mem_heap_t**)" -> "page_rec_get_next_const(const rec_t*)"
"btr_page_insert_fits(btr_cur_t*,const rec_t*,ulint**,const dtuple_t*,ulint,mem_heap_t**)" -> "page_get_data_size(const ib_page_t*)"
"btr_page_insert_fits(btr_cur_t*,const rec_t*,ulint**,const dtuple_t*,ulint,mem_heap_t**)" -> "page_get_infimum_offset(const ib_page_t*)"
"btr_page_insert_fits(btr_cur_t*,const rec_t*,ulint**,const dtuple_t*,ulint,mem_heap_t**)" -> "cmp_dtuple_rec(const dtuple_t*,const rec_t*,const ulint*)"
"btr_page_insert_fits(btr_cur_t*,const rec_t*,ulint**,const dtuple_t*,ulint,mem_heap_t**)" -> "page_get_supremum_offset(const ib_page_t*)"
"btr_page_insert_fits(btr_cur_t*,const rec_t*,ulint**,const dtuple_t*,ulint,mem_heap_t**)" -> "rec_get_converted_size(dict_index_t*,const dtuple_t*,ulint)"
"btr_page_insert_fits(btr_cur_t*,const rec_t*,ulint**,const dtuple_t*,ulint,mem_heap_t**)" -> "rec_offs_size(const ulint*)"
"btr_page_insert_fits(btr_cur_t*,const rec_t*,ulint**,const dtuple_t*,ulint,mem_heap_t**)" -> "page_is_comp(const ib_page_t*)"
"btr_page_insert_fits(btr_cur_t*,const rec_t*,ulint**,const dtuple_t*,ulint,mem_heap_t**)" -> "rec_get_offsets_func(const rec_t*,const dict_index_t*,ulint*,ulint,mem_heap_t**)"
"btr_insert_into_right_sibling(ulint,btr_cur_t*,ulint**,mem_heap_t*,const dtuple_t*,ulint,mtr_t*)" -> "__builtin_expect(long int,long int)"
"btr_insert_into_right_sibling(ulint,btr_cur_t*,ulint**,mem_heap_t*,const dtuple_t*,ulint,mtr_t*)" -> "page_rec_get_next(rec_t*)"
"btr_insert_into_right_sibling(ulint,btr_cur_t*,ulint**,mem_heap_t*,const dtuple_t*,ulint,mtr_t*)" -> "btr_insert_on_non_leaf_level_func(ulint,dict_index_t*,ulint,dtuple_t*,const char*,ulint,mtr_t*)"
"btr_insert_into_right_sibling(ulint,btr_cur_t*,ulint**,mem_heap_t*,const dtuple_t*,ulint,mtr_t*)" -> "btr_page_get_father(dict_index_t*,buf_block_t*,mtr_t*,btr_cur_t*)"
"btr_insert_into_right_sibling(ulint,btr_cur_t*,ulint**,mem_heap_t*,const dtuple_t*,ulint,mtr_t*)" -> "ut_dbg_assertion_failed(const char*,const char*,ulint)"
"btr_insert_into_right_sibling(ulint,btr_cur_t*,ulint**,mem_heap_t*,const dtuple_t*,ulint,mtr_t*)" -> "btr_page_get_level_low(const ib_page_t*)"
"btr_insert_into_right_sibling(ulint,btr_cur_t*,ulint**,mem_heap_t*,const dtuple_t*,ulint,mtr_t*)" -> "dict_index_build_node_ptr(const dict_index_t*,const rec_t*,ulint,mem_heap_t*,ulint)"
"btr_insert_into_right_sibling(ulint,btr_cur_t*,ulint**,mem_heap_t*,const dtuple_t*,ulint,mtr_t*)" -> "page_is_leaf(const ib_page_t*)"
"btr_insert_into_right_sibling(ulint,btr_cur_t*,ulint**,mem_heap_t*,const dtuple_t*,ulint,mtr_t*)" -> "page_cur_search(const buf_block_t*,const dict_index_t*,const dtuple_t*,ulint,page_cur_t*)"
"btr_insert_into_right_sibling(ulint,btr_cur_t*,ulint**,mem_heap_t*,const dtuple_t*,ulint,mtr_t*)" -> "ibuf_update_free_bits_zip(buf_block_t*,mtr_t*)"
"btr_insert_into_right_sibling(ulint,btr_cur_t*,ulint**,mem_heap_t*,const dtuple_t*,ulint,mtr_t*)" -> "lock_update_split_left(const buf_block_t*,const buf_block_t*)"
"btr_insert_into_right_sibling(ulint,btr_cur_t*,ulint**,mem_heap_t*,const dtuple_t*,ulint,mtr_t*)" -> "page_cur_tuple_insert(page_cur_t*,const dtuple_t*,dict_index_t*,ulint**,mem_heap_t**,ulint,mtr_t*)"
"btr_insert_into_right_sibling(ulint,btr_cur_t*,ulint**,mem_heap_t*,const dtuple_t*,ulint,mtr_t*)" -> "btr_block_get_func(ulint,ulint,ulint,ulint,const char*,ulint,mtr_t*)"
"btr_insert_into_right_sibling(ulint,btr_cur_t*,ulint**,mem_heap_t*,const dtuple_t*,ulint,mtr_t*)" -> "buf_block_get_page_no(const buf_block_t*)"
"btr_insert_into_right_sibling(ulint,btr_cur_t*,ulint**,mem_heap_t*,const dtuple_t*,ulint,mtr_t*)" -> "abort()"
"btr_insert_into_right_sibling(ulint,btr_cur_t*,ulint**,mem_heap_t*,const dtuple_t*,ulint,mtr_t*)" -> "ibuf_update_free_bits_if_full(buf_block_t*,ulint,ulint)"
"btr_insert_into_right_sibling(ulint,btr_cur_t*,ulint**,mem_heap_t*,const dtuple_t*,ulint,mtr_t*)" -> "btr_page_get_next(const ib_page_t*,mtr_t*)"
"btr_insert_into_right_sibling(ulint,btr_cur_t*,ulint**,mem_heap_t*,const dtuple_t*,ulint,mtr_t*)" -> "dict_index_is_clust(const dict_index_t*)"
"btr_insert_into_right_sibling(ulint,btr_cur_t*,ulint**,mem_heap_t*,const dtuple_t*,ulint,mtr_t*)" -> "page_rec_is_supremum(const rec_t*)"
"btr_insert_into_right_sibling(ulint,btr_cur_t*,ulint**,mem_heap_t*,const dtuple_t*,ulint,mtr_t*)" -> "buf_block_get_zip_size(const buf_block_t*)"
"btr_insert_into_right_sibling(ulint,btr_cur_t*,ulint**,mem_heap_t*,const dtuple_t*,ulint,mtr_t*)" -> "rec_offs_size(const ulint*)"
"btr_insert_into_right_sibling(ulint,btr_cur_t*,ulint**,mem_heap_t*,const dtuple_t*,ulint,mtr_t*)" -> "btr_cur_compress_if_useful(btr_cur_t*,ulint,mtr_t*)"
"btr_insert_into_right_sibling(ulint,btr_cur_t*,ulint**,mem_heap_t*,const dtuple_t*,ulint,mtr_t*)" -> "btr_cur_pessimistic_delete(dberr_t*,ulint,btr_cur_t*,ulint,trx_rb_ctx,mtr_t*)"
"btr_insert_into_right_sibling(ulint,btr_cur_t*,ulint**,mem_heap_t*,const dtuple_t*,ulint,mtr_t*)" -> "buf_block_get_space(const buf_block_t*)"
"btr_insert_into_right_sibling(ulint,btr_cur_t*,ulint**,mem_heap_t*,const dtuple_t*,ulint,mtr_t*)" -> "page_get_max_insert_size_after_reorganize(const ib_page_t*,ulint)"
"btr_insert_into_right_sibling(ulint,btr_cur_t*,ulint**,mem_heap_t*,const dtuple_t*,ulint,mtr_t*)" -> "ibuf_reset_free_bits(buf_block_t*)"
"lock_update_split_left(const buf_block_t*,const buf_block_t*)" -> "pfs_mutex_exit_func(ib_mutex_t*)"
"lock_update_split_left(const buf_block_t*,const buf_block_t*)" -> "lock_rec_inherit_to_gap(const buf_block_t*,const buf_block_t*,ulint,ulint)"
"lock_update_split_left(const buf_block_t*,const buf_block_t*)" -> "pfs_mutex_enter_func(ib_mutex_t*,const char*,ulint)"
"lock_update_split_left(const buf_block_t*,const buf_block_t*)" -> "lock_get_min_heap_no(const buf_block_t*)"
"lock_get_min_heap_no(const buf_block_t*)" -> "rec_get_heap_no_new(const rec_t*)"
"lock_get_min_heap_no(const buf_block_t*)" -> "page_is_comp(const ib_page_t*)"
"lock_get_min_heap_no(const buf_block_t*)" -> "rec_get_next_offs(const rec_t*,ulint)"
"lock_get_min_heap_no(const buf_block_t*)" -> "rec_get_heap_no_old(const rec_t*)"
"btr_page_tuple_smaller(btr_cur_t*,const dtuple_t*,ulint**,ulint,mem_heap_t**)" -> "cmp_dtuple_rec(const dtuple_t*,const rec_t*,const ulint*)"
"btr_page_tuple_smaller(btr_cur_t*,const dtuple_t*,ulint**,ulint,mem_heap_t**)" -> "page_cur_set_before_first(const buf_block_t*,page_cur_t*)"
"btr_page_tuple_smaller(btr_cur_t*,const dtuple_t*,ulint**,ulint,mem_heap_t**)" -> "page_cur_move_to_next(page_cur_t*)"
"btr_page_tuple_smaller(btr_cur_t*,const dtuple_t*,ulint**,ulint,mem_heap_t**)" -> "rec_get_offsets_func(const rec_t*,const dict_index_t*,ulint*,ulint,mem_heap_t**)"
"btr_attach_half_pages(ulint,dict_index_t*,buf_block_t*,const rec_t*,buf_block_t*,ulint,mtr_t*)" -> "btr_page_get_level_low(const ib_page_t*)"
"btr_attach_half_pages(ulint,dict_index_t*,buf_block_t*,const rec_t*,buf_block_t*,ulint,mtr_t*)" -> "ut_dbg_assertion_failed(const char*,const char*,ulint)"
"btr_attach_half_pages(ulint,dict_index_t*,buf_block_t*,const rec_t*,buf_block_t*,ulint,mtr_t*)" -> "btr_page_get_father_block(ulint*,mem_heap_t*,dict_index_t*,buf_block_t*,mtr_t*,btr_cur_t*)"
"btr_attach_half_pages(ulint,dict_index_t*,buf_block_t*,const rec_t*,buf_block_t*,ulint,mtr_t*)" -> "buf_block_get_zip_size(const buf_block_t*)"
"btr_attach_half_pages(ulint,dict_index_t*,buf_block_t*,const rec_t*,buf_block_t*,ulint,mtr_t*)" -> "mem_heap_empty(mem_heap_t*)"
"btr_attach_half_pages(ulint,dict_index_t*,buf_block_t*,const rec_t*,buf_block_t*,ulint,mtr_t*)" -> "dict_index_build_node_ptr(const dict_index_t*,const rec_t*,ulint,mem_heap_t*,ulint)"
"btr_attach_half_pages(ulint,dict_index_t*,buf_block_t*,const rec_t*,buf_block_t*,ulint,mtr_t*)" -> "abort()"
"btr_attach_half_pages(ulint,dict_index_t*,buf_block_t*,const rec_t*,buf_block_t*,ulint,mtr_t*)" -> "btr_page_set_next(ib_page_t*,page_zip_des_t*,ulint,mtr_t*)"
"btr_attach_half_pages(ulint,dict_index_t*,buf_block_t*,const rec_t*,buf_block_t*,ulint,mtr_t*)" -> "__builtin_expect(long int,long int)"
"btr_attach_half_pages(ulint,dict_index_t*,buf_block_t*,const rec_t*,buf_block_t*,ulint,mtr_t*)" -> "btr_page_set_prev(ib_page_t*,page_zip_des_t*,ulint,mtr_t*)"
"btr_attach_half_pages(ulint,dict_index_t*,buf_block_t*,const rec_t*,buf_block_t*,ulint,mtr_t*)" -> "btr_block_get_func(ulint,ulint,ulint,ulint,const char*,ulint,mtr_t*)"
"btr_attach_half_pages(ulint,dict_index_t*,buf_block_t*,const rec_t*,buf_block_t*,ulint,mtr_t*)" -> "btr_insert_on_non_leaf_level_func(ulint,dict_index_t*,ulint,dtuple_t*,const char*,ulint,mtr_t*)"
"btr_attach_half_pages(ulint,dict_index_t*,buf_block_t*,const rec_t*,buf_block_t*,ulint,mtr_t*)" -> "btr_page_get_prev(const ib_page_t*,mtr_t*)"
"btr_attach_half_pages(ulint,dict_index_t*,buf_block_t*,const rec_t*,buf_block_t*,ulint,mtr_t*)" -> "btr_cur_get_page_zip(btr_cur_t*)"
"btr_attach_half_pages(ulint,dict_index_t*,buf_block_t*,const rec_t*,buf_block_t*,ulint,mtr_t*)" -> "btr_page_get_next(const ib_page_t*,mtr_t*)"
"btr_attach_half_pages(ulint,dict_index_t*,buf_block_t*,const rec_t*,buf_block_t*,ulint,mtr_t*)" -> "btr_node_ptr_set_child_page_no(rec_t*,page_zip_des_t*,const ulint*,ulint,mtr_t*)"
"btr_attach_half_pages(ulint,dict_index_t*,buf_block_t*,const rec_t*,buf_block_t*,ulint,mtr_t*)" -> "page_get_page_no(const ib_page_t*)"
"btr_attach_half_pages(ulint,dict_index_t*,buf_block_t*,const rec_t*,buf_block_t*,ulint,mtr_t*)" -> "buf_block_get_space(const buf_block_t*)"
"btr_attach_half_pages(ulint,dict_index_t*,buf_block_t*,const rec_t*,buf_block_t*,ulint,mtr_t*)" -> "mem_heap_free_func(mem_heap_t*,const char*,ulint)"
"btr_attach_half_pages(ulint,dict_index_t*,buf_block_t*,const rec_t*,buf_block_t*,ulint,mtr_t*)" -> "buf_block_get_page_no(const buf_block_t*)"
"btr_attach_half_pages(ulint,dict_index_t*,buf_block_t*,const rec_t*,buf_block_t*,ulint,mtr_t*)" -> "mem_heap_create_func(ulint,ulint)"
"btr_attach_half_pages(ulint,dict_index_t*,buf_block_t*,const rec_t*,buf_block_t*,ulint,mtr_t*)" -> "page_is_comp(const ib_page_t*)"
"page_move_rec_list_end(buf_block_t*,buf_block_t*,rec_t*,dict_index_t*,mtr_t*)" -> "page_copy_rec_list_end(buf_block_t*,buf_block_t*,rec_t*,dict_index_t*,mtr_t*)"
"page_move_rec_list_end(buf_block_t*,buf_block_t*,rec_t*,dict_index_t*,mtr_t*)" -> "__builtin_expect(long int,long int)"
"page_move_rec_list_end(buf_block_t*,buf_block_t*,rec_t*,dict_index_t*,mtr_t*)" -> "page_get_data_size(const ib_page_t*)"
"page_move_rec_list_end(buf_block_t*,buf_block_t*,rec_t*,dict_index_t*,mtr_t*)" -> "page_get_n_recs(const ib_page_t*)"
"page_move_rec_list_end(buf_block_t*,buf_block_t*,rec_t*,dict_index_t*,mtr_t*)" -> "page_delete_rec_list_end(rec_t*,buf_block_t*,dict_index_t*,ulint,ulint,mtr_t*)"
"page_delete_rec_list_end(rec_t*,buf_block_t*,dict_index_t*,ulint,ulint,mtr_t*)" -> "recv_recovery_is_on()"
"page_delete_rec_list_end(rec_t*,buf_block_t*,dict_index_t*,ulint,ulint,mtr_t*)" -> "rec_get_next_ptr(rec_t*,ulint)"
"page_delete_rec_list_end(rec_t*,buf_block_t*,dict_index_t*,ulint,ulint,mtr_t*)" -> "page_header_get_field(const ib_page_t*,ulint)"
"page_delete_rec_list_end(rec_t*,buf_block_t*,dict_index_t*,ulint,ulint,mtr_t*)" -> "page_header_get_offs(const ib_page_t*,ulint)"
"page_delete_rec_list_end(rec_t*,buf_block_t*,dict_index_t*,ulint,ulint,mtr_t*)" -> "rec_get_n_owned_new(const rec_t*)"
"page_delete_rec_list_end(rec_t*,buf_block_t*,dict_index_t*,ulint,ulint,mtr_t*)" -> "page_dir_set_n_slots(ib_page_t*,page_zip_des_t*,ulint)"
"page_delete_rec_list_end(rec_t*,buf_block_t*,dict_index_t*,ulint,ulint,mtr_t*)" -> "rec_offs_size(const ulint*)"
"page_delete_rec_list_end(rec_t*,buf_block_t*,dict_index_t*,ulint,ulint,mtr_t*)" -> "page_rec_get_next_low(const rec_t*,ulint)"
"page_delete_rec_list_end(rec_t*,buf_block_t*,dict_index_t*,ulint,ulint,mtr_t*)" -> "page_dir_slot_set_n_owned(page_dir_slot_t*,page_zip_des_t*,ulint)"
"page_delete_rec_list_end(rec_t*,buf_block_t*,dict_index_t*,ulint,ulint,mtr_t*)" -> "page_dir_slot_set_rec(page_dir_slot_t*,rec_t*)"
"page_delete_rec_list_end(rec_t*,buf_block_t*,dict_index_t*,ulint,ulint,mtr_t*)" -> "page_is_comp(const ib_page_t*)"
"page_delete_rec_list_end(rec_t*,buf_block_t*,dict_index_t*,ulint,ulint,mtr_t*)" -> "page_rec_is_supremum(const rec_t*)"
"page_delete_rec_list_end(rec_t*,buf_block_t*,dict_index_t*,ulint,ulint,mtr_t*)" -> "page_rec_get_next(rec_t*)"
"page_delete_rec_list_end(rec_t*,buf_block_t*,dict_index_t*,ulint,ulint,mtr_t*)" -> "__builtin_expect(long int,long int)"
"page_delete_rec_list_end(rec_t*,buf_block_t*,dict_index_t*,ulint,ulint,mtr_t*)" -> "page_rec_get_prev(rec_t*)"
"page_delete_rec_list_end(rec_t*,buf_block_t*,dict_index_t*,ulint,ulint,mtr_t*)" -> "buf_block_modify_clock_inc(buf_block_t*)"
"page_delete_rec_list_end(rec_t*,buf_block_t*,dict_index_t*,ulint,ulint,mtr_t*)" -> "page_align(const void*)"
"page_delete_rec_list_end(rec_t*,buf_block_t*,dict_index_t*,ulint,ulint,mtr_t*)" -> "page_cur_delete_rec(page_cur_t*,const dict_index_t*,const ulint*,mtr_t*)"
"page_delete_rec_list_end(rec_t*,buf_block_t*,dict_index_t*,ulint,ulint,mtr_t*)" -> "page_cur_position(const rec_t*,const buf_block_t*,page_cur_t*)"
"page_delete_rec_list_end(rec_t*,buf_block_t*,dict_index_t*,ulint,ulint,mtr_t*)" -> "ut_dbg_assertion_failed(const char*,const char*,ulint)"
"page_delete_rec_list_end(rec_t*,buf_block_t*,dict_index_t*,ulint,ulint,mtr_t*)" -> "mtr_set_log_mode(mtr_t*,ulint)"
"page_delete_rec_list_end(rec_t*,buf_block_t*,dict_index_t*,ulint,ulint,mtr_t*)" -> "page_header_set_field(ib_page_t*,page_zip_des_t*,ulint,ulint)"
"page_delete_rec_list_end(rec_t*,buf_block_t*,dict_index_t*,ulint,ulint,mtr_t*)" -> "page_rec_set_next(rec_t*,const rec_t*)"
"page_delete_rec_list_end(rec_t*,buf_block_t*,dict_index_t*,ulint,ulint,mtr_t*)" -> "page_delete_rec_list_write_log(rec_t*,dict_index_t*,unsigned char,mtr_t*)"
"page_delete_rec_list_end(rec_t*,buf_block_t*,dict_index_t*,ulint,ulint,mtr_t*)" -> "rec_get_offsets_func(const rec_t*,const dict_index_t*,ulint*,ulint,mem_heap_t**)"
"page_delete_rec_list_end(rec_t*,buf_block_t*,dict_index_t*,ulint,ulint,mtr_t*)" -> "abort()"
"page_delete_rec_list_end(rec_t*,buf_block_t*,dict_index_t*,ulint,ulint,mtr_t*)" -> "rec_get_n_owned_old(const rec_t*)"
"page_delete_rec_list_end(rec_t*,buf_block_t*,dict_index_t*,ulint,ulint,mtr_t*)" -> "page_rec_is_infimum(const rec_t*)"
"page_delete_rec_list_end(rec_t*,buf_block_t*,dict_index_t*,ulint,ulint,mtr_t*)" -> "page_get_supremum_offset(const ib_page_t*)"
"page_delete_rec_list_end(rec_t*,buf_block_t*,dict_index_t*,ulint,ulint,mtr_t*)" -> "page_offset(const void*)"
"page_delete_rec_list_end(rec_t*,buf_block_t*,dict_index_t*,ulint,ulint,mtr_t*)" -> "page_header_set_ptr(ib_page_t*,page_zip_des_t*,ulint,const unsigned char*)"
"page_delete_rec_list_end(rec_t*,buf_block_t*,dict_index_t*,ulint,ulint,mtr_t*)" -> "mem_heap_free_func(mem_heap_t*,const char*,ulint)"
"page_delete_rec_list_end(rec_t*,buf_block_t*,dict_index_t*,ulint,ulint,mtr_t*)" -> "page_create_empty(buf_block_t*,dict_index_t*,mtr_t*)"
"page_delete_rec_list_end(rec_t*,buf_block_t*,dict_index_t*,ulint,ulint,mtr_t*)" -> "rec_offs_set_n_alloc(ulint*,ulint)"
"page_delete_rec_list_end(rec_t*,buf_block_t*,dict_index_t*,ulint,ulint,mtr_t*)" -> "page_get_n_recs(const ib_page_t*)"
"page_delete_rec_list_end(rec_t*,buf_block_t*,dict_index_t*,ulint,ulint,mtr_t*)" -> "page_dir_find_owner_slot(const rec_t*)"
"page_delete_rec_list_write_log(rec_t*,dict_index_t*,unsigned char,mtr_t*)" -> "mach_write_to_2(unsigned char*,ulint)"
"page_delete_rec_list_write_log(rec_t*,dict_index_t*,unsigned char,mtr_t*)" -> "mlog_open_and_write_index(mtr_t*,const unsigned char*,const dict_index_t*,unsigned char,ulint)"
"page_delete_rec_list_write_log(rec_t*,dict_index_t*,unsigned char,mtr_t*)" -> "page_offset(const void*)"
"page_delete_rec_list_write_log(rec_t*,dict_index_t*,unsigned char,mtr_t*)" -> "mlog_close(mtr_t*,unsigned char*)"
"btr_page_alloc(dict_index_t*,ulint,unsigned char,ulint,mtr_t*,mtr_t*)" -> "dict_index_is_ibuf(const dict_index_t*)"
"btr_page_alloc(dict_index_t*,ulint,unsigned char,ulint,mtr_t*,mtr_t*)" -> "btr_page_alloc_for_ibuf(dict_index_t*,mtr_t*)"
"btr_page_alloc(dict_index_t*,ulint,unsigned char,ulint,mtr_t*,mtr_t*)" -> "btr_page_alloc_low(dict_index_t*,ulint,unsigned char,ulint,mtr_t*,mtr_t*)"
"btr_page_alloc_for_ibuf(dict_index_t*,mtr_t*)" -> "btr_root_get(const dict_index_t*,mtr_t*)"
"btr_page_alloc_for_ibuf(dict_index_t*,mtr_t*)" -> "flst_get_first(const flst_base_node_t*,mtr_t*)"
"btr_page_alloc_for_ibuf(dict_index_t*,mtr_t*)" -> "buf_page_get_gen(ulint,ulint,ulint,ulint,buf_block_t*,ulint,const char*,ulint,mtr_t*)"
"btr_page_alloc_for_ibuf(dict_index_t*,mtr_t*)" -> "abort()"
"btr_page_alloc_for_ibuf(dict_index_t*,mtr_t*)" -> "__builtin_expect(long int,long int)"
"btr_page_alloc_for_ibuf(dict_index_t*,mtr_t*)" -> "dict_table_zip_size(const dict_table_t*)"
"btr_page_alloc_for_ibuf(dict_index_t*,mtr_t*)" -> "ut_dbg_assertion_failed(const char*,const char*,ulint)"
"btr_page_alloc_for_ibuf(dict_index_t*,mtr_t*)" -> "flst_remove(flst_base_node_t*,flst_node_t*,mtr_t*)"
"btr_page_alloc_for_ibuf(dict_index_t*,mtr_t*)" -> "dict_index_get_space(const dict_index_t*)"
"btr_page_alloc_low(dict_index_t*,ulint,unsigned char,ulint,mtr_t*,mtr_t*)" -> "btr_root_get(const dict_index_t*,mtr_t*)"
"btr_page_alloc_low(dict_index_t*,ulint,unsigned char,ulint,mtr_t*,mtr_t*)" -> "fseg_alloc_free_page_general(fseg_header_t*,ulint,unsigned char,ulint,mtr_t*,mtr_t*)"
"page_delete_rec_list_start(rec_t*,buf_block_t*,dict_index_t*,mtr_t*)" -> "mem_heap_free_func(mem_heap_t*,const char*,ulint)"
"page_delete_rec_list_start(rec_t*,buf_block_t*,dict_index_t*,mtr_t*)" -> "page_create_empty(buf_block_t*,dict_index_t*,mtr_t*)"
"page_delete_rec_list_start(rec_t*,buf_block_t*,dict_index_t*,mtr_t*)" -> "page_rec_is_infimum(const rec_t*)"
"page_delete_rec_list_start(rec_t*,buf_block_t*,dict_index_t*,mtr_t*)" -> "page_rec_is_comp(const rec_t*)"
"page_delete_rec_list_start(rec_t*,buf_block_t*,dict_index_t*,mtr_t*)" -> "page_delete_rec_list_write_log(rec_t*,dict_index_t*,unsigned char,mtr_t*)"
"page_delete_rec_list_start(rec_t*,buf_block_t*,dict_index_t*,mtr_t*)" -> "page_cur_delete_rec(page_cur_t*,const dict_index_t*,const ulint*,mtr_t*)"
"page_delete_rec_list_start(rec_t*,buf_block_t*,dict_index_t*,mtr_t*)" -> "page_cur_set_before_first(const buf_block_t*,page_cur_t*)"
"page_delete_rec_list_start(rec_t*,buf_block_t*,dict_index_t*,mtr_t*)" -> "page_rec_is_supremum(const rec_t*)"
"page_delete_rec_list_start(rec_t*,buf_block_t*,dict_index_t*,mtr_t*)" -> "__builtin_expect(long int,long int)"
"page_delete_rec_list_start(rec_t*,buf_block_t*,dict_index_t*,mtr_t*)" -> "page_cur_move_to_next(page_cur_t*)"
"page_delete_rec_list_start(rec_t*,buf_block_t*,dict_index_t*,mtr_t*)" -> "mtr_set_log_mode(mtr_t*,ulint)"
"page_delete_rec_list_start(rec_t*,buf_block_t*,dict_index_t*,mtr_t*)" -> "rec_get_offsets_func(const rec_t*,const dict_index_t*,ulint*,ulint,mem_heap_t**)"
"page_delete_rec_list_start(rec_t*,buf_block_t*,dict_index_t*,mtr_t*)" -> "rec_offs_set_n_alloc(ulint*,ulint)"
"btr_page_create(buf_block_t*,page_zip_des_t*,dict_index_t*,ulint,mtr_t*)" -> "btr_page_set_index_id(ib_page_t*,page_zip_des_t*,index_id_t,mtr_t*)"
"btr_page_create(buf_block_t*,page_zip_des_t*,dict_index_t*,ulint,mtr_t*)" -> "page_create(buf_block_t*,mtr_t*,ulint)"
"btr_page_create(buf_block_t*,page_zip_des_t*,dict_index_t*,ulint,mtr_t*)" -> "btr_page_set_level(ib_page_t*,page_zip_des_t*,ulint,mtr_t*)"
"btr_page_create(buf_block_t*,page_zip_des_t*,dict_index_t*,ulint,mtr_t*)" -> "dict_table_is_comp(const dict_table_t*)"
"btr_page_create(buf_block_t*,page_zip_des_t*,dict_index_t*,ulint,mtr_t*)" -> "page_create_zip(buf_block_t*,dict_index_t*,ulint,trx_id_t,mtr_t*)"
"btr_page_set_index_id(ib_page_t*,page_zip_des_t*,index_id_t,mtr_t*)" -> "mach_write_to_8(void*,ib_uint64_t)"
"btr_page_set_index_id(ib_page_t*,page_zip_des_t*,index_id_t,mtr_t*)" -> "mlog_write_ull(unsigned char*,ib_uint64_t,mtr_t*)"
"btr_page_set_index_id(ib_page_t*,page_zip_des_t*,index_id_t,mtr_t*)" -> "page_zip_write_header(page_zip_des_t*,const unsigned char*,ulint,mtr_t*)"
"page_move_rec_list_start(buf_block_t*,buf_block_t*,rec_t*,dict_index_t*,mtr_t*)" -> "page_delete_rec_list_start(rec_t*,buf_block_t*,dict_index_t*,mtr_t*)"
"page_move_rec_list_start(buf_block_t*,buf_block_t*,rec_t*,dict_index_t*,mtr_t*)" -> "__builtin_expect(long int,long int)"
"page_move_rec_list_start(buf_block_t*,buf_block_t*,rec_t*,dict_index_t*,mtr_t*)" -> "page_copy_rec_list_start(buf_block_t*,buf_block_t*,rec_t*,dict_index_t*,mtr_t*)"
"lock_update_split_right(const buf_block_t*,const buf_block_t*)" -> "pfs_mutex_enter_func(ib_mutex_t*,const char*,ulint)"
"lock_update_split_right(const buf_block_t*,const buf_block_t*)" -> "lock_get_min_heap_no(const buf_block_t*)"
"lock_update_split_right(const buf_block_t*,const buf_block_t*)" -> "pfs_mutex_exit_func(ib_mutex_t*)"
"lock_update_split_right(const buf_block_t*,const buf_block_t*)" -> "lock_rec_inherit_to_gap(const buf_block_t*,const buf_block_t*,ulint,ulint)"
"lock_update_split_right(const buf_block_t*,const buf_block_t*)" -> "lock_rec_move(const buf_block_t*,const buf_block_t*,ulint,ulint)"
"btr_page_get_split_rec(btr_cur_t*,const dtuple_t*,ulint)" -> "page_get_data_size(const ib_page_t*)"
"btr_page_get_split_rec(btr_cur_t*,const dtuple_t*,ulint)" -> "rec_offs_size(const ulint*)"
"btr_page_get_split_rec(btr_cur_t*,const dtuple_t*,ulint)" -> "page_get_n_recs(const ib_page_t*)"
"btr_page_get_split_rec(btr_cur_t*,const dtuple_t*,ulint)" -> "page_zip_empty_size(ulint,ulint)"
"btr_page_get_split_rec(btr_cur_t*,const dtuple_t*,ulint)" -> "rec_get_offsets_func(const rec_t*,const dict_index_t*,ulint*,ulint,mem_heap_t**)"
"btr_page_get_split_rec(btr_cur_t*,const dtuple_t*,ulint)" -> "page_zip_get_size(const page_zip_des_t*)"
"btr_page_get_split_rec(btr_cur_t*,const dtuple_t*,ulint)" -> "btr_cur_get_page_zip(btr_cur_t*)"
"btr_page_get_split_rec(btr_cur_t*,const dtuple_t*,ulint)" -> "page_get_free_space_of_empty(ulint)"
"btr_page_get_split_rec(btr_cur_t*,const dtuple_t*,ulint)" -> "btr_cur_get_page(btr_cur_t*)"
"btr_page_get_split_rec(btr_cur_t*,const dtuple_t*,ulint)" -> "page_dir_calc_reserved_space(ulint)"
"btr_page_get_split_rec(btr_cur_t*,const dtuple_t*,ulint)" -> "page_is_comp(const ib_page_t*)"
"btr_page_get_split_rec(btr_cur_t*,const dtuple_t*,ulint)" -> "rec_get_converted_size(dict_index_t*,const dtuple_t*,ulint)"
"btr_page_get_split_rec(btr_cur_t*,const dtuple_t*,ulint)" -> "mem_heap_free_func(mem_heap_t*,const char*,ulint)"
"btr_page_get_split_rec(btr_cur_t*,const dtuple_t*,ulint)" -> "page_get_infimum_offset(const ib_page_t*)"
"btr_page_get_split_rec(btr_cur_t*,const dtuple_t*,ulint)" -> "page_rec_is_supremum(const rec_t*)"
"btr_page_get_split_rec(btr_cur_t*,const dtuple_t*,ulint)" -> "page_rec_get_next(rec_t*)"
"ibuf_update_free_bits_for_two_pages_low(ulint,buf_block_t*,buf_block_t*,mtr_t*)" -> "ibuf_index_page_calc_free(ulint,const buf_block_t*)"
"ibuf_update_free_bits_for_two_pages_low(ulint,buf_block_t*,buf_block_t*,mtr_t*)" -> "ibuf_set_free_bits_low(ulint,const buf_block_t*,ulint,mtr_t*)"
"ibuf_update_free_bits_for_two_pages_low(ulint,buf_block_t*,buf_block_t*,mtr_t*)" -> "pfs_mutex_enter_func(ib_mutex_t*,const char*,ulint)"
"ibuf_update_free_bits_for_two_pages_low(ulint,buf_block_t*,buf_block_t*,mtr_t*)" -> "pfs_mutex_exit_func(ib_mutex_t*)"
"page_get_middle_rec(ib_page_t*)" -> "page_get_n_recs(const ib_page_t*)"
"page_get_middle_rec(ib_page_t*)" -> "page_rec_get_nth(ib_page_t*,ulint)"
"lock_update_root_raise(const buf_block_t*,const buf_block_t*)" -> "pfs_mutex_enter_func(ib_mutex_t*,const char*,ulint)"
"lock_update_root_raise(const buf_block_t*,const buf_block_t*)" -> "pfs_mutex_exit_func(ib_mutex_t*)"
"lock_update_root_raise(const buf_block_t*,const buf_block_t*)" -> "lock_rec_move(const buf_block_t*,const buf_block_t*,ulint,ulint)"
"btr_discard_page(btr_cur_t*,mtr_t*)" -> "btr_node_ptr_delete(dict_index_t*,buf_block_t*,mtr_t*)"
"btr_discard_page(btr_cur_t*,mtr_t*)" -> "page_rec_get_next(rec_t*)"
"btr_discard_page(btr_cur_t*,mtr_t*)" -> "btr_page_get_prev(const ib_page_t*,mtr_t*)"
"btr_discard_page(btr_cur_t*,mtr_t*)" -> "page_is_leaf(const ib_page_t*)"
"btr_discard_page(btr_cur_t*,mtr_t*)" -> "btr_discard_only_page_on_level(dict_index_t*,buf_block_t*,mtr_t*)"
"btr_discard_page(btr_cur_t*,mtr_t*)" -> "dict_index_get_space(const dict_index_t*)"
"btr_discard_page(btr_cur_t*,mtr_t*)" -> "page_is_comp(const ib_page_t*)"
"btr_discard_page(btr_cur_t*,mtr_t*)" -> "btr_page_free(dict_index_t*,buf_block_t*,mtr_t*)"
"btr_discard_page(btr_cur_t*,mtr_t*)" -> "abort()"
"btr_discard_page(btr_cur_t*,mtr_t*)" -> "btr_level_list_remove_func(ulint,ulint,ib_page_t*,mtr_t*)"
"btr_discard_page(btr_cur_t*,mtr_t*)" -> "btr_block_get_func(ulint,ulint,ulint,ulint,const char*,ulint,mtr_t*)"
"btr_discard_page(btr_cur_t*,mtr_t*)" -> "lock_get_min_heap_no(const buf_block_t*)"
"btr_discard_page(btr_cur_t*,mtr_t*)" -> "btr_set_min_rec_mark(rec_t*,mtr_t*)"
"btr_discard_page(btr_cur_t*,mtr_t*)" -> "btr_page_get_next(const ib_page_t*,mtr_t*)"
"btr_discard_page(btr_cur_t*,mtr_t*)" -> "lock_update_discard(const buf_block_t*,ulint,const buf_block_t*)"
"btr_discard_page(btr_cur_t*,mtr_t*)" -> "btr_search_drop_page_hash_index(buf_block_t*)"
"btr_discard_page(btr_cur_t*,mtr_t*)" -> "ut_dbg_assertion_failed(const char*,const char*,ulint)"
"btr_discard_page(btr_cur_t*,mtr_t*)" -> "__builtin_expect(long int,long int)"
"btr_discard_page(btr_cur_t*,mtr_t*)" -> "dict_table_zip_size(const dict_table_t*)"
"btr_discard_page(btr_cur_t*,mtr_t*)" -> "page_get_infimum_offset(const ib_page_t*)"
"btr_discard_page(btr_cur_t*,mtr_t*)" -> "buf_block_get_page_no(const buf_block_t*)"
"btr_discard_only_page_on_level(dict_index_t*,buf_block_t*,mtr_t*)" -> "dict_index_get_page(const dict_index_t*)"
"btr_discard_only_page_on_level(dict_index_t*,buf_block_t*,mtr_t*)" -> "lock_update_discard(const buf_block_t*,ulint,const buf_block_t*)"
"btr_discard_only_page_on_level(dict_index_t*,buf_block_t*,mtr_t*)" -> "buf_block_get_page_no(const buf_block_t*)"
"btr_discard_only_page_on_level(dict_index_t*,buf_block_t*,mtr_t*)" -> "dict_index_get_space(const dict_index_t*)"
"btr_discard_only_page_on_level(dict_index_t*,buf_block_t*,mtr_t*)" -> "__builtin_expect(long int,long int)"
"btr_discard_only_page_on_level(dict_index_t*,buf_block_t*,mtr_t*)" -> "btr_page_get_next(const ib_page_t*,mtr_t*)"
"btr_discard_only_page_on_level(dict_index_t*,buf_block_t*,mtr_t*)" -> "btr_page_get_father(dict_index_t*,buf_block_t*,mtr_t*,btr_cur_t*)"
"btr_discard_only_page_on_level(dict_index_t*,buf_block_t*,mtr_t*)" -> "dict_index_is_clust(const dict_index_t*)"
"btr_discard_only_page_on_level(dict_index_t*,buf_block_t*,mtr_t*)" -> "ut_dbg_assertion_failed(const char*,const char*,ulint)"
"btr_discard_only_page_on_level(dict_index_t*,buf_block_t*,mtr_t*)" -> "btr_page_get_level_low(const ib_page_t*)"
"btr_discard_only_page_on_level(dict_index_t*,buf_block_t*,mtr_t*)" -> "page_get_n_recs(const ib_page_t*)"
"btr_discard_only_page_on_level(dict_index_t*,buf_block_t*,mtr_t*)" -> "btr_page_free(dict_index_t*,buf_block_t*,mtr_t*)"
"btr_discard_only_page_on_level(dict_index_t*,buf_block_t*,mtr_t*)" -> "btr_page_get_prev(const ib_page_t*,mtr_t*)"
"btr_discard_only_page_on_level(dict_index_t*,buf_block_t*,mtr_t*)" -> "btr_search_drop_page_hash_index(buf_block_t*)"
"btr_discard_only_page_on_level(dict_index_t*,buf_block_t*,mtr_t*)" -> "ibuf_reset_free_bits(buf_block_t*)"
"btr_discard_only_page_on_level(dict_index_t*,buf_block_t*,mtr_t*)" -> "dict_index_is_ibuf(const dict_index_t*)"
"btr_discard_only_page_on_level(dict_index_t*,buf_block_t*,mtr_t*)" -> "page_get_max_trx_id(const ib_page_t*)"
"btr_discard_only_page_on_level(dict_index_t*,buf_block_t*,mtr_t*)" -> "btr_page_empty(buf_block_t*,page_zip_des_t*,dict_index_t*,ulint,mtr_t*)"
"btr_discard_only_page_on_level(dict_index_t*,buf_block_t*,mtr_t*)" -> "abort()"
"btr_discard_only_page_on_level(dict_index_t*,buf_block_t*,mtr_t*)" -> "btr_root_fseg_validate(const fseg_header_t*,ulint)"
"btr_discard_only_page_on_level(dict_index_t*,buf_block_t*,mtr_t*)" -> "page_set_max_trx_id(buf_block_t*,page_zip_des_t*,trx_id_t,mtr_t*)"
"lock_update_discard(const buf_block_t*,ulint,const buf_block_t*)" -> "lock_rec_inherit_to_gap(const buf_block_t*,const buf_block_t*,ulint,ulint)"
"lock_update_discard(const buf_block_t*,ulint,const buf_block_t*)" -> "pfs_mutex_exit_func(ib_mutex_t*)"
"lock_update_discard(const buf_block_t*,ulint,const buf_block_t*)" -> "lock_rec_reset_and_release_wait(const buf_block_t*,ulint)"
"lock_update_discard(const buf_block_t*,ulint,const buf_block_t*)" -> "page_is_comp(const ib_page_t*)"
"lock_update_discard(const buf_block_t*,ulint,const buf_block_t*)" -> "pfs_mutex_enter_func(ib_mutex_t*,const char*,ulint)"
"lock_update_discard(const buf_block_t*,ulint,const buf_block_t*)" -> "rec_get_heap_no_old(const rec_t*)"
"lock_update_discard(const buf_block_t*,ulint,const buf_block_t*)" -> "rec_get_heap_no_new(const rec_t*)"
"lock_update_discard(const buf_block_t*,ulint,const buf_block_t*)" -> "lock_rec_get_first_on_page(const buf_block_t*)"
"lock_update_discard(const buf_block_t*,ulint,const buf_block_t*)" -> "rec_get_next_offs(const rec_t*,ulint)"
"lock_update_discard(const buf_block_t*,ulint,const buf_block_t*)" -> "lock_rec_free_all_from_discard_page(const buf_block_t*)"
"btr_set_min_rec_mark(rec_t*,mtr_t*)" -> "rec_set_info_bits_new(rec_t*,ulint)"
"btr_set_min_rec_mark(rec_t*,mtr_t*)" -> "rec_set_info_bits_old(rec_t*,ulint)"
"btr_set_min_rec_mark(rec_t*,mtr_t*)" -> "btr_set_min_rec_mark_log(rec_t*,unsigned char,mtr_t*)"
"btr_set_min_rec_mark(rec_t*,mtr_t*)" -> "page_rec_is_comp(const rec_t*)"
"btr_set_min_rec_mark(rec_t*,mtr_t*)" -> "rec_get_info_bits(const rec_t*,ulint)"
"btr_set_min_rec_mark_log(rec_t*,unsigned char,mtr_t*)" -> "mlog_catenate_ulint(mtr_t*,ulint,ulint)"
"btr_set_min_rec_mark_log(rec_t*,unsigned char,mtr_t*)" -> "mlog_write_initial_log_record(const unsigned char*,unsigned char,mtr_t*)"
"btr_set_min_rec_mark_log(rec_t*,unsigned char,mtr_t*)" -> "page_offset(const void*)"
"ibuf_size_update(const ib_page_t*,mtr_t*)" -> "flst_get_len(const flst_base_node_t*,mtr_t*)"
"ibuf_size_update(const ib_page_t*,mtr_t*)" -> "btr_page_get_level_low(const ib_page_t*)"
"ibuf_add_ops(ulint*,const ulint*)" -> "__sync_add_and_fetch_8(volatile void*,long unsigned int)"
"ibuf_set_del_mark(const dtuple_t*,buf_block_t*,const dict_index_t*,mtr_t*)" -> "ut_print_timestamp(FILE*)"
"ibuf_set_del_mark(const dtuple_t*,buf_block_t*,const dict_index_t*,mtr_t*)" -> "page_cur_search(const buf_block_t*,const dict_index_t*,const dtuple_t*,ulint,page_cur_t*)"
"ibuf_set_del_mark(const dtuple_t*,buf_block_t*,const dict_index_t*,mtr_t*)" -> "dtuple_get_n_fields(const dtuple_t*)"
"ibuf_set_del_mark(const dtuple_t*,buf_block_t*,const dict_index_t*,mtr_t*)" -> "buf_block_get_space(const buf_block_t*)"
"ibuf_set_del_mark(const dtuple_t*,buf_block_t*,const dict_index_t*,mtr_t*)" -> "rec_get_deleted_flag(const rec_t*,ulint)"
"ibuf_set_del_mark(const dtuple_t*,buf_block_t*,const dict_index_t*,mtr_t*)" -> "fprintf(FILE*,const char*,...)"
"ibuf_set_del_mark(const dtuple_t*,buf_block_t*,const dict_index_t*,mtr_t*)" -> "btr_cur_set_deleted_flag_for_ibuf(rec_t*,page_zip_des_t*,ulint,mtr_t*)"
"ibuf_set_del_mark(const dtuple_t*,buf_block_t*,const dict_index_t*,mtr_t*)" -> "__builtin_fwrite(const void*,size_t,size_t,FILE*)"
"ibuf_set_del_mark(const dtuple_t*,buf_block_t*,const dict_index_t*,mtr_t*)" -> "dtuple_print(FILE*,const dtuple_t*)"
"ibuf_set_del_mark(const dtuple_t*,buf_block_t*,const dict_index_t*,mtr_t*)" -> "rec_print(FILE*,const rec_t*,const dict_index_t*)"
"ibuf_set_del_mark(const dtuple_t*,buf_block_t*,const dict_index_t*,mtr_t*)" -> "buf_block_get_page_no(const buf_block_t*)"
"ibuf_set_del_mark(const dtuple_t*,buf_block_t*,const dict_index_t*,mtr_t*)" -> "__builtin_expect(long int,long int)"
"ibuf_set_del_mark(const dtuple_t*,buf_block_t*,const dict_index_t*,mtr_t*)" -> "page_get_n_recs(const ib_page_t*)"
"ibuf_set_del_mark(const dtuple_t*,buf_block_t*,const dict_index_t*,mtr_t*)" -> "dict_table_is_comp(const dict_table_t*)"
"ibuf_set_del_mark(const dtuple_t*,buf_block_t*,const dict_index_t*,mtr_t*)" -> "page_align(const void*)"
"ibuf_set_del_mark(const dtuple_t*,buf_block_t*,const dict_index_t*,mtr_t*)" -> "btr_page_get_index_id(const ib_page_t*)"
"rec_print(FILE*,const rec_t*,const dict_index_t*)" -> "rec_offs_set_n_alloc(ulint*,ulint)"
"rec_print(FILE*,const rec_t*,const dict_index_t*)" -> "dict_table_is_comp(const dict_table_t*)"
"rec_print(FILE*,const rec_t*,const dict_index_t*)" -> "__builtin_expect(long int,long int)"
"rec_print(FILE*,const rec_t*,const dict_index_t*)" -> "rec_print_new(FILE*,const rec_t*,const ulint*)"
"rec_print(FILE*,const rec_t*,const dict_index_t*)" -> "mem_heap_free_func(mem_heap_t*,const char*,ulint)"
"rec_print(FILE*,const rec_t*,const dict_index_t*)" -> "rec_print_old(FILE*,const rec_t*)"
"rec_print(FILE*,const rec_t*,const dict_index_t*)" -> "rec_get_offsets_func(const rec_t*,const dict_index_t*,ulint*,ulint,mem_heap_t**)"
"page_header_reset_last_insert(ib_page_t*,page_zip_des_t*,mtr_t*)" -> "mlog_write_ulint(unsigned char*,ulint,unsigned char,mtr_t*)"
"page_header_reset_last_insert(ib_page_t*,page_zip_des_t*,mtr_t*)" -> "mach_write_to_2(unsigned char*,ulint)"
"page_header_reset_last_insert(ib_page_t*,page_zip_des_t*,mtr_t*)" -> "page_zip_write_header(page_zip_des_t*,const unsigned char*,ulint,mtr_t*)"
"fil_space_get_size(ulint)" -> "pfs_mutex_enter_func(ib_mutex_t*,const char*,ulint)"
"fil_space_get_size(ulint)" -> "pfs_mutex_exit_func(ib_mutex_t*)"
"fil_space_get_size(ulint)" -> "fil_space_get_space(ulint)"
"fseg_n_reserved_pages_low(fseg_inode_t*,ulint*,mtr_t*)" -> "fseg_get_n_frag_pages(fseg_inode_t*,mtr_t*)"
"fseg_n_reserved_pages_low(fseg_inode_t*,ulint*,mtr_t*)" -> "flst_get_len(const flst_base_node_t*,mtr_t*)"
"fseg_n_reserved_pages_low(fseg_inode_t*,ulint*,mtr_t*)" -> "mtr_read_ulint(const unsigned char*,ulint,mtr_t*)"
"fseg_get_n_frag_pages(fseg_inode_t*,mtr_t*)" -> "fseg_get_nth_frag_page_no(fseg_inode_t*,ulint,mtr_t*)"
"fseg_mark_page_used(fseg_inode_t*,ulint,xdes_t*,mtr_t*)" -> "xdes_is_free(const xdes_t*,mtr_t*)"
"fseg_mark_page_used(fseg_inode_t*,ulint,xdes_t*,mtr_t*)" -> "xdes_is_full(const xdes_t*,mtr_t*)"
"fseg_mark_page_used(fseg_inode_t*,ulint,xdes_t*,mtr_t*)" -> "xdes_set_bit(xdes_t*,ulint,ulint,ulint,mtr_t*)"
"fseg_mark_page_used(fseg_inode_t*,ulint,xdes_t*,mtr_t*)" -> "flst_remove(flst_base_node_t*,flst_node_t*,mtr_t*)"
"fseg_mark_page_used(fseg_inode_t*,ulint,xdes_t*,mtr_t*)" -> "mlog_write_ulint(unsigned char*,ulint,unsigned char,mtr_t*)"
"fseg_mark_page_used(fseg_inode_t*,ulint,xdes_t*,mtr_t*)" -> "flst_add_last(flst_base_node_t*,flst_node_t*,mtr_t*)"
"fseg_mark_page_used(fseg_inode_t*,ulint,xdes_t*,mtr_t*)" -> "mtr_read_ulint(const unsigned char*,ulint,mtr_t*)"
"fseg_alloc_free_extent(fseg_inode_t*,ulint,ulint,mtr_t*)" -> "flst_get_len(const flst_base_node_t*,mtr_t*)"
"fseg_alloc_free_extent(fseg_inode_t*,ulint,ulint,mtr_t*)" -> "xdes_get_offset(const xdes_t*)"
"fseg_alloc_free_extent(fseg_inode_t*,ulint,ulint,mtr_t*)" -> "mlog_write_ull(unsigned char*,ib_uint64_t,mtr_t*)"
"fseg_alloc_free_extent(fseg_inode_t*,ulint,ulint,mtr_t*)" -> "xdes_lst_get_descriptor(ulint,ulint,fil_addr_t,mtr_t*)"
"fseg_alloc_free_extent(fseg_inode_t*,ulint,ulint,mtr_t*)" -> "flst_get_first(const flst_base_node_t*,mtr_t*)"
"fseg_alloc_free_extent(fseg_inode_t*,ulint,ulint,mtr_t*)" -> "fsp_alloc_free_extent(ulint,ulint,ulint,mtr_t*)"
"fseg_alloc_free_extent(fseg_inode_t*,ulint,ulint,mtr_t*)" -> "xdes_set_state(xdes_t*,ulint,mtr_t*)"
"fseg_alloc_free_extent(fseg_inode_t*,ulint,ulint,mtr_t*)" -> "mach_read_from_8(const unsigned char*)"
"fseg_alloc_free_extent(fseg_inode_t*,ulint,ulint,mtr_t*)" -> "fseg_fill_free_list(fseg_inode_t*,ulint,ulint,ulint,mtr_t*)"
"fseg_alloc_free_extent(fseg_inode_t*,ulint,ulint,mtr_t*)" -> "flst_add_last(flst_base_node_t*,flst_node_t*,mtr_t*)"
"fseg_fill_free_list(fseg_inode_t*,ulint,ulint,ulint,mtr_t*)" -> "mlog_write_ull(unsigned char*,ib_uint64_t,mtr_t*)"
"fseg_fill_free_list(fseg_inode_t*,ulint,ulint,ulint,mtr_t*)" -> "mach_read_from_8(const unsigned char*)"
"fseg_fill_free_list(fseg_inode_t*,ulint,ulint,ulint,mtr_t*)" -> "flst_add_last(flst_base_node_t*,flst_node_t*,mtr_t*)"
"fseg_fill_free_list(fseg_inode_t*,ulint,ulint,ulint,mtr_t*)" -> "xdes_get_state(const xdes_t*,mtr_t*)"
"fseg_fill_free_list(fseg_inode_t*,ulint,ulint,ulint,mtr_t*)" -> "fseg_n_reserved_pages_low(fseg_inode_t*,ulint*,mtr_t*)"
"fseg_fill_free_list(fseg_inode_t*,ulint,ulint,ulint,mtr_t*)" -> "fsp_alloc_free_extent(ulint,ulint,ulint,mtr_t*)"
"fseg_fill_free_list(fseg_inode_t*,ulint,ulint,ulint,mtr_t*)" -> "flst_get_len(const flst_base_node_t*,mtr_t*)"
"fseg_fill_free_list(fseg_inode_t*,ulint,ulint,ulint,mtr_t*)" -> "xdes_get_descriptor(ulint,ulint,ulint,mtr_t*)"
"fseg_fill_free_list(fseg_inode_t*,ulint,ulint,ulint,mtr_t*)" -> "xdes_set_state(xdes_t*,ulint,mtr_t*)"
"fseg_find_free_frag_page_slot(fseg_inode_t*,mtr_t*)" -> "fseg_get_nth_frag_page_no(fseg_inode_t*,ulint,mtr_t*)"
"buf_pool_watch_occurred(ulint,ulint)" -> "buf_pool_watch_is_sentinel(buf_pool_t*,const buf_page_t*)"
"buf_pool_watch_occurred(ulint,ulint)" -> "buf_pool_get(ulint,ulint)"
"buf_pool_watch_occurred(ulint,ulint)" -> "pfs_rw_lock_s_lock_func(rw_lock_t*,ulint,const char*,ulint)"
"buf_pool_watch_occurred(ulint,ulint)" -> "pfs_rw_lock_s_unlock_func(rw_lock_t*)"
"buf_pool_watch_occurred(ulint,ulint)" -> "buf_page_hash_get_low(buf_pool_t*,ulint,ulint,ulint)"
"buf_pool_watch_occurred(ulint,ulint)" -> "buf_page_address_fold(ulint,ulint)"
"buf_pool_watch_occurred(ulint,ulint)" -> "hash_get_lock(hash_table_t*,ulint)"
"ibuf_contract(ulint)" -> "ibuf_merge(table_id_t,ulint*,bool)"
"ibuf_merge(table_id_t,ulint*,bool)" -> "ibuf_get_table(table_id_t)"
"ibuf_merge(table_id_t,ulint*,bool)" -> "ibuf_merge_space(ulint,ulint*)"
"ibuf_merge(table_id_t,ulint*,bool)" -> "ibuf_merge_pages(ulint*,bool)"
"ibuf_merge(table_id_t,ulint*,bool)" -> "dict_table_close(dict_table_t*,ulint,ulint)"
"ibuf_get_table(table_id_t)" -> "rw_lock_s_lock_func(rw_lock_t*,ulint,const char*,ulint)"
"ibuf_get_table(table_id_t)" -> "dict_table_open_on_id(table_id_t,ulint,dict_table_op_t)"
"ibuf_get_table(table_id_t)" -> "pfs_rw_lock_s_unlock_func(rw_lock_t*)"
"dict_table_open_on_id(table_id_t,ulint,dict_table_op_t)" -> "pfs_mutex_enter_func(ib_mutex_t*,const char*,ulint)"
"dict_table_open_on_id(table_id_t,ulint,dict_table_op_t)" -> "dict_table_try_drop_aborted_and_mutex_exit(dict_table_t*,ulint)"
"dict_table_open_on_id(table_id_t,ulint,dict_table_op_t)" -> "dict_move_to_mru(dict_table_t*)"
"dict_table_open_on_id(table_id_t,ulint,dict_table_op_t)" -> "dict_table_open_on_id_low(table_id_t,dict_err_ignore_t)"
"dict_move_to_mru(dict_table_t*)" -> "ut_dbg_assertion_failed(const char*,const char*,ulint)"
"dict_move_to_mru(dict_table_t*)" -> "__builtin_expect(long int,long int)"
"dict_move_to_mru(dict_table_t*)" -> "abort()"
"dict_move_to_mru(dict_table_t*)" -> "ut_list_prepend(List&,Type&,size_t) [with List = ut_list_base<dict_table_t>,Type = dict_table_t,size_t = long unsigned int]"
"dict_move_to_mru(dict_table_t*)" -> "ut_list_remove(List&,Type&,size_t) [with List = ut_list_base<dict_table_t>,Type = dict_table_t,size_t = long unsigned int]"
"ut_list_prepend(List&,Type&,size_t) [with List = ut_list_base<dict_table_t>,Type = dict_table_t,size_t = long unsigned int]" -> "ut_elem_get_node(Type&,size_t) [with Type = dict_table_t,size_t = long unsigned int]"
"ut_elem_get_node(Type&,size_t) [with Type = dict_table_t,size_t = long unsigned int]" -> "__builtin_expect(long int,long int)"
"ut_elem_get_node(Type&,size_t) [with Type = dict_table_t,size_t = long unsigned int]" -> "ut_dbg_assertion_failed(const char*,const char*,ulint)"
"ut_elem_get_node(Type&,size_t) [with Type = dict_table_t,size_t = long unsigned int]" -> "abort()"
"ut_list_remove(List&,Type&,size_t) [with List = ut_list_base<dict_table_t>,Type = dict_table_t,size_t = long unsigned int]" -> "abort()"
"ut_list_remove(List&,Type&,size_t) [with List = ut_list_base<dict_table_t>,Type = dict_table_t,size_t = long unsigned int]" -> "ut_dbg_assertion_failed(const char*,const char*,ulint)"
"ut_list_remove(List&,Type&,size_t) [with List = ut_list_base<dict_table_t>,Type = dict_table_t,size_t = long unsigned int]" -> "__builtin_expect(long int,long int)"
"ut_list_remove(List&,Type&,size_t) [with List = ut_list_base<dict_table_t>,Type = dict_table_t,size_t = long unsigned int]" -> "ut_elem_get_node(Type&,size_t) [with Type = dict_table_t,size_t = long unsigned int]"
"dict_table_open_on_id_low(table_id_t,dict_err_ignore_t)" -> "hash_get_nth_cell(hash_table_t*,ulint)"
"dict_table_open_on_id_low(table_id_t,dict_err_ignore_t)" -> "dict_load_table_on_id(table_id_t,dict_err_ignore_t)"
"dict_table_open_on_id_low(table_id_t,dict_err_ignore_t)" -> "ut_fold_ull(ib_uint64_t)"
"dict_table_open_on_id_low(table_id_t,dict_err_ignore_t)" -> "hash_calc_hash(ulint,hash_table_t*)"
"dict_load_table_on_id(table_id_t,dict_err_ignore_t)" -> "mem_heap_strdupl(mem_heap_t*,const char*,ulint)"
"dict_load_table_on_id(table_id_t,dict_err_ignore_t)" -> "mem_heap_create_func(ulint,ulint)"
"dict_load_table_on_id(table_id_t,dict_err_ignore_t)" -> "rec_get_deleted_flag(const rec_t*,ulint)"
"dict_load_table_on_id(table_id_t,dict_err_ignore_t)" -> "dtuple_create(mem_heap_t*,ulint)"
"dict_load_table_on_id(table_id_t,dict_err_ignore_t)" -> "dfield_set_data(dfield_t*,const void*,ulint)"
"dict_load_table_on_id(table_id_t,dict_err_ignore_t)" -> "dict_load_table(const char*,ulint,dict_err_ignore_t)"
"dict_load_table_on_id(table_id_t,dict_err_ignore_t)" -> "rec_get_nth_field_offs_old(const rec_t*,ulint,ulint*)"
"dict_load_table_on_id(table_id_t,dict_err_ignore_t)" -> "page_rec_is_user_rec(const rec_t*)"
"dict_load_table_on_id(table_id_t,dict_err_ignore_t)" -> "btr_pcur_open_on_user_rec_func(dict_index_t*,const dtuple_t*,ulint,ulint,btr_pcur_t*,const char*,ulint,mtr_t*)"
"dict_load_table_on_id(table_id_t,dict_err_ignore_t)" -> "mem_heap_free_func(mem_heap_t*,const char*,ulint)"
"dict_load_table_on_id(table_id_t,dict_err_ignore_t)" -> "mtr_commit(mtr_t*)"
"dict_load_table_on_id(table_id_t,dict_err_ignore_t)" -> "btr_pcur_move_to_next(btr_pcur_t*,mtr_t*)"
"dict_load_table_on_id(table_id_t,dict_err_ignore_t)" -> "dict_index_copy_types(dtuple_t*,const dict_index_t*,ulint)"
"dict_load_table_on_id(table_id_t,dict_err_ignore_t)" -> "mach_read_from_8(const unsigned char*)"
"dict_load_table_on_id(table_id_t,dict_err_ignore_t)" -> "btr_pcur_close(btr_pcur_t*)"
"dict_load_table_on_id(table_id_t,dict_err_ignore_t)" -> "mach_write_to_8(void*,ib_uint64_t)"
"dict_load_table_on_id(table_id_t,dict_err_ignore_t)" -> "mtr_start(mtr_t*)"
"ibuf_merge_space(ulint,ulint*)" -> "mem_heap_create_func(ulint,ulint)"
"ibuf_merge_space(ulint,ulint*)" -> "ibuf_mtr_start(mtr_t*)"
"ibuf_merge_space(ulint,ulint*)" -> "btr_pcur_open_low(dict_index_t*,ulint,const dtuple_t*,ulint,ulint,btr_pcur_t*,const char*,ulint,mtr_t*)"
"ibuf_merge_space(ulint,ulint*)" -> "__builtin_expect(long int,long int)"
"ibuf_merge_space(ulint,ulint*)" -> "abort()"
"ibuf_merge_space(ulint,ulint*)" -> "mem_heap_free_func(mem_heap_t*,const char*,ulint)"
"ibuf_merge_space(ulint,ulint*)" -> "ibuf_search_tuple_build(ulint,ulint,mem_heap_t*)"
"ibuf_merge_space(ulint,ulint*)" -> "page_is_empty(const ib_page_t*)"
"ibuf_merge_space(ulint,ulint*)" -> "btr_pcur_close(btr_pcur_t*)"
"ibuf_merge_space(ulint,ulint*)" -> "buf_read_ibuf_merge_pages(bool,const ulint*,const ib_int64_t*,const ulint*,ulint)"
"ibuf_merge_space(ulint,ulint*)" -> "ibuf_get_merge_pages(btr_pcur_t*,ulint,ulint,ulint*,ulint*,ib_int64_t*,ulint*,mtr_t*)"
"ibuf_merge_space(ulint,ulint*)" -> "ibuf_mtr_commit(mtr_t*)"
"ibuf_merge_space(ulint,ulint*)" -> "ut_dbg_assertion_failed(const char*,const char*,ulint)"
"buf_read_ibuf_merge_pages(bool,const ulint*,const ib_int64_t*,const ulint*,ulint)" -> "ibuf_merge_or_delete_for_page(buf_block_t*,ulint,ulint,ulint,ulint)"
"buf_read_ibuf_merge_pages(bool,const ulint*,const ib_int64_t*,const ulint*,ulint)" -> "buf_pool_get(ulint,ulint)"
"buf_read_ibuf_merge_pages(bool,const ulint*,const ib_int64_t*,const ulint*,ulint)" -> "os_aio_simulated_wake_handler_threads()"
"buf_read_ibuf_merge_pages(bool,const ulint*,const ib_int64_t*,const ulint*,ulint)" -> "buf_read_page_low(dberr_t*,bool,ulint,ulint,ulint,ulint,ib_int64_t,ulint)"
"buf_read_ibuf_merge_pages(bool,const ulint*,const ib_int64_t*,const ulint*,ulint)" -> "fil_space_get_zip_size(ulint)"
"buf_read_ibuf_merge_pages(bool,const ulint*,const ib_int64_t*,const ulint*,ulint)" -> "__builtin_expect(long int,long int)"
"buf_read_ibuf_merge_pages(bool,const ulint*,const ib_int64_t*,const ulint*,ulint)" -> "os_thread_sleep(ulint)"
"ibuf_get_merge_pages(btr_pcur_t*,ulint,ulint,ulint*,ulint*,ib_int64_t*,ulint*,mtr_t*)" -> "ibuf_rec_get_space_func(const rec_t*)"
"ibuf_get_merge_pages(btr_pcur_t*,ulint,ulint,ulint*,ulint*,ib_int64_t*,ulint*,mtr_t*)" -> "ibuf_get_user_rec(btr_pcur_t*,mtr_t*)"
"ibuf_get_merge_pages(btr_pcur_t*,ulint,ulint,ulint*,ulint*,ib_int64_t*,ulint*,mtr_t*)" -> "ut_dbg_assertion_failed(const char*,const char*,ulint)"
"ibuf_get_merge_pages(btr_pcur_t*,ulint,ulint,ulint*,ulint*,ib_int64_t*,ulint*,mtr_t*)" -> "btr_pcur_move_to_next(btr_pcur_t*,mtr_t*)"
"ibuf_get_merge_pages(btr_pcur_t*,ulint,ulint,ulint*,ulint*,ib_int64_t*,ulint*,mtr_t*)" -> "fil_space_get_version(ulint)"
"ibuf_get_merge_pages(btr_pcur_t*,ulint,ulint,ulint*,ulint*,ib_int64_t*,ulint*,mtr_t*)" -> "__builtin_expect(long int,long int)"
"ibuf_get_merge_pages(btr_pcur_t*,ulint,ulint,ulint*,ulint*,ib_int64_t*,ulint*,mtr_t*)" -> "abort()"
"ibuf_get_merge_pages(btr_pcur_t*,ulint,ulint,ulint*,ulint*,ib_int64_t*,ulint*,mtr_t*)" -> "ibuf_rec_get_page_no_func(const rec_t*)"
"ibuf_get_merge_pages(btr_pcur_t*,ulint,ulint,ulint*,ulint*,ib_int64_t*,ulint*,mtr_t*)" -> "ibuf_rec_get_volume_func(const rec_t*)"
"ibuf_get_user_rec(btr_pcur_t*,mtr_t*)" -> "btr_pcur_move_to_next(btr_pcur_t*,mtr_t*)"
"ibuf_get_user_rec(btr_pcur_t*,mtr_t*)" -> "page_rec_is_user_rec(const rec_t*)"
"ibuf_rec_get_volume_func(const rec_t*)" -> "abort()"
"ibuf_rec_get_volume_func(const rec_t*)" -> "ibuf_dummy_index_free(dict_index_t*)"
"ibuf_rec_get_volume_func(const rec_t*)" -> "ibuf_rec_get_size(const rec_t*,const unsigned char*,ulint,ulint)"
"ibuf_rec_get_volume_func(const rec_t*)" -> "rec_get_n_fields_old(const rec_t*)"
"ibuf_rec_get_volume_func(const rec_t*)" -> "mem_heap_create_func(ulint,ulint)"
"ibuf_rec_get_volume_func(const rec_t*)" -> "page_dir_calc_reserved_space(ulint)"
"ibuf_rec_get_volume_func(const rec_t*)" -> "ibuf_build_entry_from_ibuf_rec_func(const rec_t*,mem_heap_t*,dict_index_t**)"
"ibuf_rec_get_volume_func(const rec_t*)" -> "rec_get_nth_field_offs_old(const rec_t*,ulint,ulint*)"
"ibuf_rec_get_volume_func(const rec_t*)" -> "rec_get_converted_size(dict_index_t*,const dtuple_t*,ulint)"
"ibuf_rec_get_volume_func(const rec_t*)" -> "ut_dbg_assertion_failed(const char*,const char*,ulint)"
"ibuf_rec_get_volume_func(const rec_t*)" -> "mem_heap_free_func(mem_heap_t*,const char*,ulint)"
"ibuf_rec_get_volume_func(const rec_t*)" -> "rec_get_converted_extra_size(ulint,ulint,ulint)"
"ibuf_rec_get_volume_func(const rec_t*)" -> "__builtin_expect(long int,long int)"
"ibuf_rec_get_volume_func(const rec_t*)" -> "ibuf_rec_get_info_func(const rec_t*,ibuf_op_t*,ulint*,ulint*,ulint*)"
"ibuf_merge_pages(ulint*,bool)" -> "ibuf_mtr_start(mtr_t*)"
"ibuf_merge_pages(ulint*,bool)" -> "buf_read_ibuf_merge_pages(bool,const ulint*,const ib_int64_t*,const ulint*,ulint)"
"ibuf_merge_pages(ulint*,bool)" -> "ibuf_mtr_commit(mtr_t*)"
"ibuf_merge_pages(ulint*,bool)" -> "page_is_empty(const ib_page_t*)"
"ibuf_merge_pages(ulint*,bool)" -> "btr_pcur_close(btr_pcur_t*)"
"ibuf_merge_pages(ulint*,bool)" -> "btr_pcur_open_at_rnd_pos_func(dict_index_t*,ulint,btr_pcur_t*,const char*,ulint,mtr_t*)"
"ibuf_merge_pages(ulint*,bool)" -> "ibuf_get_merge_page_nos_func(ulint,const rec_t*,ulint*,ib_int64_t*,ulint*,ulint*)"
"btr_pcur_open_at_rnd_pos_func(dict_index_t*,ulint,btr_pcur_t*,const char*,ulint,mtr_t*)" -> "btr_pcur_init(btr_pcur_t*)"
"btr_pcur_open_at_rnd_pos_func(dict_index_t*,ulint,btr_pcur_t*,const char*,ulint,mtr_t*)" -> "btr_cur_open_at_rnd_pos_func(dict_index_t*,ulint,btr_cur_t*,const char*,ulint,mtr_t*)"
"btr_cur_open_at_rnd_pos_func(dict_index_t*,ulint,btr_cur_t*,const char*,ulint,mtr_t*)" -> "btr_node_ptr_get_child_page_no(const rec_t*,const ulint*)"
"btr_cur_open_at_rnd_pos_func(dict_index_t*,ulint,btr_cur_t*,const char*,ulint,mtr_t*)" -> "dict_index_get_space(const dict_index_t*)"
"btr_cur_open_at_rnd_pos_func(dict_index_t*,ulint,btr_cur_t*,const char*,ulint,mtr_t*)" -> "buf_page_get_gen(ulint,ulint,ulint,ulint,buf_block_t*,ulint,const char*,ulint,mtr_t*)"
"btr_cur_open_at_rnd_pos_func(dict_index_t*,ulint,btr_cur_t*,const char*,ulint,mtr_t*)" -> "rec_get_offsets_func(const rec_t*,const dict_index_t*,ulint*,ulint,mem_heap_t**)"
"btr_cur_open_at_rnd_pos_func(dict_index_t*,ulint,btr_cur_t*,const char*,ulint,mtr_t*)" -> "btr_cur_latch_leaves(ib_page_t*,ulint,ulint,ulint,ulint,btr_cur_t*,mtr_t*)"
"btr_cur_open_at_rnd_pos_func(dict_index_t*,ulint,btr_cur_t*,const char*,ulint,mtr_t*)" -> "mem_heap_free_func(mem_heap_t*,const char*,ulint)"
"btr_cur_open_at_rnd_pos_func(dict_index_t*,ulint,btr_cur_t*,const char*,ulint,mtr_t*)" -> "dict_index_get_page(const dict_index_t*)"
"btr_cur_open_at_rnd_pos_func(dict_index_t*,ulint,btr_cur_t*,const char*,ulint,mtr_t*)" -> "mtr_x_lock_func(rw_lock_t*,const char*,ulint,mtr_t*)"
"btr_cur_open_at_rnd_pos_func(dict_index_t*,ulint,btr_cur_t*,const char*,ulint,mtr_t*)" -> "rec_offs_set_n_alloc(ulint*,ulint)"
"btr_cur_open_at_rnd_pos_func(dict_index_t*,ulint,btr_cur_t*,const char*,ulint,mtr_t*)" -> "btr_page_get_level_low(const ib_page_t*)"
"btr_cur_open_at_rnd_pos_func(dict_index_t*,ulint,btr_cur_t*,const char*,ulint,mtr_t*)" -> "page_cur_open_on_rnd_user_rec(buf_block_t*,page_cur_t*)"
"btr_cur_open_at_rnd_pos_func(dict_index_t*,ulint,btr_cur_t*,const char*,ulint,mtr_t*)" -> "dict_index_get_lock(dict_index_t*)"
"btr_cur_open_at_rnd_pos_func(dict_index_t*,ulint,btr_cur_t*,const char*,ulint,mtr_t*)" -> "__builtin_expect(long int,long int)"
"btr_cur_open_at_rnd_pos_func(dict_index_t*,ulint,btr_cur_t*,const char*,ulint,mtr_t*)" -> "dict_table_zip_size(const dict_table_t*)"
"btr_cur_open_at_rnd_pos_func(dict_index_t*,ulint,btr_cur_t*,const char*,ulint,mtr_t*)" -> "mtr_s_lock_func(rw_lock_t*,const char*,ulint,mtr_t*)"
"page_cur_open_on_rnd_user_rec(buf_block_t*,page_cur_t*)" -> "__builtin_expect(long int,long int)"
"page_cur_open_on_rnd_user_rec(buf_block_t*,page_cur_t*)" -> "page_cur_set_before_first(const buf_block_t*,page_cur_t*)"
"page_cur_open_on_rnd_user_rec(buf_block_t*,page_cur_t*)" -> "page_cur_lcg_prng()"
"page_cur_open_on_rnd_user_rec(buf_block_t*,page_cur_t*)" -> "page_get_n_recs(const ib_page_t*)"
"page_cur_open_on_rnd_user_rec(buf_block_t*,page_cur_t*)" -> "page_cur_move_to_next(page_cur_t*)"
"page_cur_lcg_prng()" -> "ut_time_us(ullint*)"
"ibuf_get_merge_page_nos_func(ulint,const rec_t*,ulint*,ib_int64_t*,ulint*,ulint*)" -> "ibuf_rec_get_space_func(const rec_t*)"
"ibuf_get_merge_page_nos_func(ulint,const rec_t*,ulint*,ib_int64_t*,ulint*,ulint*)" -> "fil_space_get_version(ulint)"
"ibuf_get_merge_page_nos_func(ulint,const rec_t*,ulint*,ib_int64_t*,ulint*,ulint*)" -> "page_rec_get_prev_const(const rec_t*)"
"ibuf_get_merge_page_nos_func(ulint,const rec_t*,ulint*,ib_int64_t*,ulint*,ulint*)" -> "page_rec_is_infimum(const rec_t*)"
"ibuf_get_merge_page_nos_func(ulint,const rec_t*,ulint*,ib_int64_t*,ulint*,ulint*)" -> "page_rec_get_next_const(const rec_t*)"
"ibuf_get_merge_page_nos_func(ulint,const rec_t*,ulint*,ib_int64_t*,ulint*,ulint*)" -> "ibuf_rec_get_page_no_func(const rec_t*)"
"ibuf_get_merge_page_nos_func(ulint,const rec_t*,ulint*,ib_int64_t*,ulint*,ulint*)" -> "__builtin_expect(long int,long int)"
"ibuf_get_merge_page_nos_func(ulint,const rec_t*,ulint*,ib_int64_t*,ulint*,ulint*)" -> "page_rec_is_supremum(const rec_t*)"
"ibuf_get_merge_page_nos_func(ulint,const rec_t*,ulint*,ib_int64_t*,ulint*,ulint*)" -> "ut_min(ulint,ulint)"
"ibuf_get_merge_page_nos_func(ulint,const rec_t*,ulint*,ib_int64_t*,ulint*,ulint*)" -> "buf_pool_get_curr_size()"
"ibuf_get_merge_page_nos_func(ulint,const rec_t*,ulint*,ib_int64_t*,ulint*,ulint*)" -> "ibuf_rec_get_volume_func(const rec_t*)"
"lock_rec_expl_exist_on_page(ulint,ulint)" -> "pfs_mutex_exit_func(ib_mutex_t*)"
"lock_rec_expl_exist_on_page(ulint,ulint)" -> "lock_rec_get_first_on_page_addr(ulint,ulint)"
"lock_rec_expl_exist_on_page(ulint,ulint)" -> "pfs_mutex_enter_func(ib_mutex_t*,const char*,ulint)"
"buf_page_peek(ulint,ulint)" -> "buf_pool_get(ulint,ulint)"
"buf_page_peek(ulint,ulint)" -> "buf_page_hash_get_locked(buf_pool_t*,ulint,ulint,rw_lock_t**,ulint)"
"ibuf_entry_build(ibuf_op_t,dict_index_t*,const dtuple_t*,ulint,ulint,ulint,mem_heap_t*)" -> "dtype_new_store_for_order_and_null_size(unsigned char*,const dtype_t*,ulint)"
"ibuf_entry_build(ibuf_op_t,dict_index_t*,const dtuple_t*,ulint,ulint,ulint,mem_heap_t*)" -> "ut_dbg_assertion_failed(const char*,const char*,ulint)"
"ibuf_entry_build(ibuf_op_t,dict_index_t*,const dtuple_t*,ulint,ulint,ulint,mem_heap_t*)" -> "mach_write_to_4(unsigned char*,ulint)"
"ibuf_entry_build(ibuf_op_t,dict_index_t*,const dtuple_t*,ulint,ulint,ulint,mem_heap_t*)" -> "mach_write_to_1(unsigned char*,ulint)"
"ibuf_entry_build(ibuf_op_t,dict_index_t*,const dtuple_t*,ulint,ulint,ulint,mem_heap_t*)" -> "mach_write_to_2(unsigned char*,ulint)"
"ibuf_entry_build(ibuf_op_t,dict_index_t*,const dtuple_t*,ulint,ulint,ulint,mem_heap_t*)" -> "dfield_copy(dfield_t*,const dfield_t*)"
"ibuf_entry_build(ibuf_op_t,dict_index_t*,const dtuple_t*,ulint,ulint,ulint,mem_heap_t*)" -> "dtuple_set_types_binary(dtuple_t*,ulint)"
"ibuf_entry_build(ibuf_op_t,dict_index_t*,const dtuple_t*,ulint,ulint,ulint,mem_heap_t*)" -> "mem_heap_alloc(mem_heap_t*,ulint)"
"ibuf_entry_build(ibuf_op_t,dict_index_t*,const dtuple_t*,ulint,ulint,ulint,mem_heap_t*)" -> "abort()"
"ibuf_entry_build(ibuf_op_t,dict_index_t*,const dtuple_t*,ulint,ulint,ulint,mem_heap_t*)" -> "dict_table_is_comp(const dict_table_t*)"
"ibuf_entry_build(ibuf_op_t,dict_index_t*,const dtuple_t*,ulint,ulint,ulint,mem_heap_t*)" -> "dtuple_create(mem_heap_t*,ulint)"
"ibuf_entry_build(ibuf_op_t,dict_index_t*,const dtuple_t*,ulint,ulint,ulint,mem_heap_t*)" -> "dfield_set_data(dfield_t*,const void*,ulint)"
"ibuf_entry_build(ibuf_op_t,dict_index_t*,const dtuple_t*,ulint,ulint,ulint,mem_heap_t*)" -> "dtuple_get_n_fields(const dtuple_t*)"
"dtype_new_store_for_order_and_null_size(unsigned char*,const dtype_t*,ulint)" -> "mach_write_to_2(unsigned char*,ulint)"
"dtype_new_store_for_order_and_null_size(unsigned char*,const dtype_t*,ulint)" -> "dtype_get_charset_coll(ulint)"
"ibuf_get_entry_counter_func(ulint,ulint,const rec_t*,ulint)" -> "page_rec_is_infimum(const rec_t*)"
"ibuf_get_entry_counter_func(ulint,ulint,const rec_t*,ulint)" -> "page_align(const void*)"
"ibuf_get_entry_counter_func(ulint,ulint,const rec_t*,ulint)" -> "page_rec_is_supremum(const rec_t*)"
"ibuf_get_entry_counter_func(ulint,ulint,const rec_t*,ulint)" -> "fil_page_get_prev(const unsigned char*)"
"ibuf_get_entry_counter_func(ulint,ulint,const rec_t*,ulint)" -> "ibuf_get_entry_counter_low_func(const rec_t*,ulint,ulint)"
"fil_page_get_prev(const unsigned char*)" -> "mach_read_from_4(const unsigned char*)"
"ibuf_get_entry_counter_low_func(const rec_t*,ulint,ulint)" -> "mach_read_from_2(const unsigned char*)"
"ibuf_get_entry_counter_low_func(const rec_t*,ulint,ulint)" -> "mach_read_from_4(const unsigned char*)"
"ibuf_get_entry_counter_low_func(const rec_t*,ulint,ulint)" -> "ut_dbg_assertion_failed(const char*,const char*,ulint)"
"ibuf_get_entry_counter_low_func(const rec_t*,ulint,ulint)" -> "abort()"
"ibuf_get_entry_counter_low_func(const rec_t*,ulint,ulint)" -> "rec_get_nth_field_offs_old(const rec_t*,ulint,ulint*)"
"ibuf_get_entry_counter_low_func(const rec_t*,ulint,ulint)" -> "__builtin_expect(long int,long int)"
"ibuf_contract_after_insert(ulint)" -> "ibuf_contract(ulint)"
"btr_search_info_update(dict_index_t*,btr_cur_t*)" -> "btr_search_info_update_slow(btr_search_t*,btr_cur_t*)"
"btr_search_info_update(dict_index_t*,btr_cur_t*)" -> "btr_search_get_info(dict_index_t*)"
"btr_search_info_update_slow(btr_search_t*,btr_cur_t*)" -> "mem_alloc_func(ulint,ulint*)"
"btr_search_info_update_slow(btr_search_t*,btr_cur_t*)" -> "pfs_rw_lock_x_lock_func(rw_lock_t*,ulint,const char*,ulint)"
"btr_search_info_update_slow(btr_search_t*,btr_cur_t*)" -> "btr_search_info_update_hash(btr_search_t*,btr_cur_t*)"
"btr_search_info_update_slow(btr_search_t*,btr_cur_t*)" -> "pfs_rw_lock_x_unlock_func(rw_lock_t*)"
"btr_search_info_update_slow(btr_search_t*,btr_cur_t*)" -> "btr_search_build_page_hash_index(dict_index_t*,buf_block_t*,ulint,ulint,ulint)"
"btr_search_info_update_slow(btr_search_t*,btr_cur_t*)" -> "btr_search_update_block_hash_info(btr_search_t*,buf_block_t*,btr_cur_t*)"
"btr_search_info_update_slow(btr_search_t*,btr_cur_t*)" -> "btr_search_check_free_space_in_heap()"
"btr_search_info_update_slow(btr_search_t*,btr_cur_t*)" -> "mem_free_func(void*,const char*,ulint)"
"btr_search_info_update_slow(btr_search_t*,btr_cur_t*)" -> "btr_search_update_hash_ref(btr_search_t*,buf_block_t*,btr_cur_t*)"
"btr_search_info_update_hash(btr_search_t*,btr_cur_t*)" -> "dict_index_is_ibuf(const dict_index_t*)"
"btr_search_info_update_hash(btr_search_t*,btr_cur_t*)" -> "dict_index_get_n_unique_in_tree(const dict_index_t*)"
"btr_search_info_update_hash(btr_search_t*,btr_cur_t*)" -> "ut_pair_cmp(ulint,ulint,ulint,ulint)"
"btr_search_update_block_hash_info(btr_search_t*,buf_block_t*,btr_cur_t*)" -> "__builtin_expect(long int,long int)"
"btr_search_update_block_hash_info(btr_search_t*,buf_block_t*,btr_cur_t*)" -> "buf_block_get_state(const buf_block_t*)"
"btr_search_update_block_hash_info(btr_search_t*,buf_block_t*,btr_cur_t*)" -> "page_get_n_recs(const ib_page_t*)"
"btr_search_update_block_hash_info(btr_search_t*,buf_block_t*,btr_cur_t*)" -> "abort()"
"btr_search_update_block_hash_info(btr_search_t*,buf_block_t*,btr_cur_t*)" -> "ut_dbg_assertion_failed(const char*,const char*,ulint)"
"btr_search_update_hash_ref(btr_search_t*,buf_block_t*,btr_cur_t*)" -> "__builtin_expect(long int,long int)"
"btr_search_update_hash_ref(btr_search_t*,buf_block_t*,btr_cur_t*)" -> "rec_offs_set_n_alloc(ulint*,ulint)"
"btr_search_update_hash_ref(btr_search_t*,buf_block_t*,btr_cur_t*)" -> "ut_dbg_assertion_failed(const char*,const char*,ulint)"
"btr_search_update_hash_ref(btr_search_t*,buf_block_t*,btr_cur_t*)" -> "abort()"
"btr_search_update_hash_ref(btr_search_t*,buf_block_t*,btr_cur_t*)" -> "page_rec_is_user_rec(const rec_t*)"
"btr_search_update_hash_ref(btr_search_t*,buf_block_t*,btr_cur_t*)" -> "ha_insert_for_fold_func(hash_table_t*,ulint,const rec_t*)"
"btr_search_update_hash_ref(btr_search_t*,buf_block_t*,btr_cur_t*)" -> "dict_index_is_ibuf(const dict_index_t*)"
"btr_search_update_hash_ref(btr_search_t*,buf_block_t*,btr_cur_t*)" -> "rec_get_offsets_func(const rec_t*,const dict_index_t*,ulint*,ulint,mem_heap_t**)"
"btr_search_update_hash_ref(btr_search_t*,buf_block_t*,btr_cur_t*)" -> "mem_heap_free_func(mem_heap_t*,const char*,ulint)"
"btr_search_update_hash_ref(btr_search_t*,buf_block_t*,btr_cur_t*)" -> "rec_fold(const rec_t*,const ulint*,ulint,ulint,index_id_t)"
"buf_pool_watch_unset(ulint,ulint)" -> "pfs_mutex_enter_func(ib_mutex_t*,const char*,ulint)"
"buf_pool_watch_unset(ulint,ulint)" -> "buf_block_unfix(buf_block_t*)"
"buf_pool_watch_unset(ulint,ulint)" -> "buf_page_address_fold(ulint,ulint)"
"buf_pool_watch_unset(ulint,ulint)" -> "pfs_rw_lock_x_lock_func(rw_lock_t*,ulint,const char*,ulint)"
"buf_pool_watch_unset(ulint,ulint)" -> "__sync_sub_and_fetch_4(volatile void*,unsigned int)"
"buf_pool_watch_unset(ulint,ulint)" -> "buf_pool_watch_remove(buf_pool_t*,ulint,buf_page_t*)"
"buf_pool_watch_unset(ulint,ulint)" -> "buf_pool_get(ulint,ulint)"
"buf_pool_watch_unset(ulint,ulint)" -> "buf_page_hash_get_low(buf_pool_t*,ulint,ulint,ulint)"
"buf_pool_watch_unset(ulint,ulint)" -> "buf_pool_watch_is_sentinel(buf_pool_t*,const buf_page_t*)"
"buf_pool_watch_unset(ulint,ulint)" -> "hash_get_lock(hash_table_t*,ulint)"
"buf_pool_watch_unset(ulint,ulint)" -> "pfs_mutex_exit_func(ib_mutex_t*)"
"buf_pool_watch_unset(ulint,ulint)" -> "pfs_rw_lock_x_unlock_func(rw_lock_t*)"
"row_purge_poss_sec(purge_node_t*,dict_index_t*,const dtuple_t*)" -> "btr_pcur_commit_specify_mtr(btr_pcur_t*,mtr_t*)"
"row_purge_poss_sec(purge_node_t*,dict_index_t*,const dtuple_t*)" -> "row_purge_reposition_pcur(ulint,purge_node_t*,mtr_t*)"
"row_purge_poss_sec(purge_node_t*,dict_index_t*,const dtuple_t*)" -> "mtr_start(mtr_t*)"
"row_purge_poss_sec(purge_node_t*,dict_index_t*,const dtuple_t*)" -> "row_vers_old_has_index_entry(ulint,const rec_t*,mtr_t*,dict_index_t*,const dtuple_t*)"
"row_purge_reposition_pcur(ulint,purge_node_t*,mtr_t*)" -> "row_search_on_row_ref(btr_pcur_t*,ulint,const dict_table_t*,const dtuple_t*,mtr_t*)"
"row_purge_reposition_pcur(ulint,purge_node_t*,mtr_t*)" -> "btr_pcur_restore_position_func(ulint,btr_pcur_t*,const char*,ulint,mtr_t*)"
"row_purge_reposition_pcur(ulint,purge_node_t*,mtr_t*)" -> "btr_pcur_store_position(btr_pcur_t*,mtr_t*)"
"row_search_on_row_ref(btr_pcur_t*,ulint,const dict_table_t*,const dtuple_t*,mtr_t*)" -> "btr_pcur_open_low(dict_index_t*,ulint,const dtuple_t*,ulint,ulint,btr_pcur_t*,const char*,ulint,mtr_t*)"
"row_search_on_row_ref(btr_pcur_t*,ulint,const dict_table_t*,const dtuple_t*,mtr_t*)" -> "__builtin_expect(long int,long int)"
"row_search_on_row_ref(btr_pcur_t*,ulint,const dict_table_t*,const dtuple_t*,mtr_t*)" -> "abort()"
"row_search_on_row_ref(btr_pcur_t*,ulint,const dict_table_t*,const dtuple_t*,mtr_t*)" -> "btr_pcur_get_low_match(const btr_pcur_t*)"
"row_search_on_row_ref(btr_pcur_t*,ulint,const dict_table_t*,const dtuple_t*,mtr_t*)" -> "dict_index_get_n_unique(const dict_index_t*)"
"row_search_on_row_ref(btr_pcur_t*,ulint,const dict_table_t*,const dtuple_t*,mtr_t*)" -> "dtuple_get_n_fields(const dtuple_t*)"
"row_search_on_row_ref(btr_pcur_t*,ulint,const dict_table_t*,const dtuple_t*,mtr_t*)" -> "page_rec_is_infimum(const rec_t*)"
"row_search_on_row_ref(btr_pcur_t*,ulint,const dict_table_t*,const dtuple_t*,mtr_t*)" -> "ut_dbg_assertion_failed(const char*,const char*,ulint)"
"row_vers_old_has_index_entry(ulint,const rec_t*,mtr_t*,dict_index_t*,const dtuple_t*)" -> "row_build(ulint,const dict_index_t*,const rec_t*,const ulint*,const dict_table_t*,const dtuple_t*,const ulint*,row_ext_t**,mem_heap_t*)"
"row_vers_old_has_index_entry(ulint,const rec_t*,mtr_t*,dict_index_t*,const dtuple_t*)" -> "page_rec_is_comp(const rec_t*)"
"row_vers_old_has_index_entry(ulint,const rec_t*,mtr_t*,dict_index_t*,const dtuple_t*)" -> "dtuple_coll_cmp(const dtuple_t*,const dtuple_t*)"
"row_vers_old_has_index_entry(ulint,const rec_t*,mtr_t*,dict_index_t*,const dtuple_t*)" -> "mem_heap_create_func(ulint,ulint)"
"row_vers_old_has_index_entry(ulint,const rec_t*,mtr_t*,dict_index_t*,const dtuple_t*)" -> "row_build_index_entry(const dtuple_t*,const row_ext_t*,dict_index_t*,mem_heap_t*)"
"row_vers_old_has_index_entry(ulint,const rec_t*,mtr_t*,dict_index_t*,const dtuple_t*)" -> "mem_heap_free_func(mem_heap_t*,const char*,ulint)"
"row_vers_old_has_index_entry(ulint,const rec_t*,mtr_t*,dict_index_t*,const dtuple_t*)" -> "trx_undo_prev_version_build(const rec_t*,mtr_t*,const rec_t*,dict_index_t*,ulint*,mem_heap_t*,rec_t**)"
"row_vers_old_has_index_entry(ulint,const rec_t*,mtr_t*,dict_index_t*,const dtuple_t*)" -> "rec_get_deleted_flag(const rec_t*,ulint)"
"row_vers_old_has_index_entry(ulint,const rec_t*,mtr_t*,dict_index_t*,const dtuple_t*)" -> "rec_get_offsets_func(const rec_t*,const dict_index_t*,ulint*,ulint,mem_heap_t**)"
"row_build(ulint,const dict_index_t*,const rec_t*,const ulint*,const dict_table_t*,const dtuple_t*,const ulint*,row_ext_t**,mem_heap_t*)" -> "mem_heap_alloc(mem_heap_t*,ulint)"
"row_build(ulint,const dict_index_t*,const rec_t*,const ulint*,const dict_table_t*,const dtuple_t*,const ulint*,row_ext_t**,mem_heap_t*)" -> "rec_offs_n_fields(const ulint*)"
"row_build(ulint,const dict_index_t*,const rec_t*,const ulint*,const dict_table_t*,const dtuple_t*,const ulint*,row_ext_t**,mem_heap_t*)" -> "dfield_set_data(dfield_t*,const void*,ulint)"
"row_build(ulint,const dict_index_t*,const rec_t*,const ulint*,const dict_table_t*,const dtuple_t*,const ulint*,row_ext_t**,mem_heap_t*)" -> "rec_offs_nth_extern(const ulint*,ulint)"
"row_build(ulint,const dict_index_t*,const rec_t*,const ulint*,const dict_table_t*,const dtuple_t*,const ulint*,row_ext_t**,mem_heap_t*)" -> "dfield_set_ext(dfield_t*)"
"row_build(ulint,const dict_index_t*,const rec_t*,const ulint*,const dict_table_t*,const dtuple_t*,const ulint*,row_ext_t**,mem_heap_t*)" -> "dict_col_copy_type(const dict_col_t*,dtype_t*)"
"row_build(ulint,const dict_index_t*,const rec_t*,const ulint*,const dict_table_t*,const dtuple_t*,const ulint*,row_ext_t**,mem_heap_t*)" -> "rec_offs_set_n_alloc(ulint*,ulint)"
"row_build(ulint,const dict_index_t*,const rec_t*,const ulint*,const dict_table_t*,const dtuple_t*,const ulint*,row_ext_t**,mem_heap_t*)" -> "dict_table_copy_types(dtuple_t*,const dict_table_t*)"
"row_build(ulint,const dict_index_t*,const rec_t*,const ulint*,const dict_table_t*,const dtuple_t*,const ulint*,row_ext_t**,mem_heap_t*)" -> "dtuple_set_info_bits(dtuple_t*,ulint)"
"row_build(ulint,const dict_index_t*,const rec_t*,const ulint*,const dict_table_t*,const dtuple_t*,const ulint*,row_ext_t**,mem_heap_t*)" -> "dict_col_get_no(const dict_col_t*)"
"row_build(ulint,const dict_index_t*,const rec_t*,const ulint*,const dict_table_t*,const dtuple_t*,const ulint*,row_ext_t**,mem_heap_t*)" -> "rec_offs_comp(const ulint*)"
"row_build(ulint,const dict_index_t*,const rec_t*,const ulint*,const dict_table_t*,const dtuple_t*,const ulint*,row_ext_t**,mem_heap_t*)" -> "rec_offs_n_extern(const ulint*)"
"row_build(ulint,const dict_index_t*,const rec_t*,const ulint*,const dict_table_t*,const dtuple_t*,const ulint*,row_ext_t**,mem_heap_t*)" -> "dict_field_get_col(const dict_field_t*)"
"row_build(ulint,const dict_index_t*,const rec_t*,const ulint*,const dict_table_t*,const dtuple_t*,const ulint*,row_ext_t**,mem_heap_t*)" -> "mem_heap_free_func(mem_heap_t*,const char*,ulint)"
"row_build(ulint,const dict_index_t*,const rec_t*,const ulint*,const dict_table_t*,const dtuple_t*,const ulint*,row_ext_t**,mem_heap_t*)" -> "dict_table_get_n_cols(const dict_table_t*)"
"row_build(ulint,const dict_index_t*,const rec_t*,const ulint*,const dict_table_t*,const dtuple_t*,const ulint*,row_ext_t**,mem_heap_t*)" -> "dtuple_create(mem_heap_t*,ulint)"
"row_build(ulint,const dict_index_t*,const rec_t*,const ulint*,const dict_table_t*,const dtuple_t*,const ulint*,row_ext_t**,mem_heap_t*)" -> "rec_get_nth_field_offs(const ulint*,ulint,ulint*)"
"row_build(ulint,const dict_index_t*,const rec_t*,const ulint*,const dict_table_t*,const dtuple_t*,const ulint*,row_ext_t**,mem_heap_t*)" -> "dtuple_copy(const dtuple_t*,mem_heap_t*)"
"row_build(ulint,const dict_index_t*,const rec_t*,const ulint*,const dict_table_t*,const dtuple_t*,const ulint*,row_ext_t**,mem_heap_t*)" -> "row_ext_create(ulint,const ulint*,ulint,const dtuple_t*,mem_heap_t*)"
"row_build(ulint,const dict_index_t*,const rec_t*,const ulint*,const dict_table_t*,const dtuple_t*,const ulint*,row_ext_t**,mem_heap_t*)" -> "rec_copy(void*,const rec_t*,const ulint*)"
"row_build(ulint,const dict_index_t*,const rec_t*,const ulint*,const dict_table_t*,const dtuple_t*,const ulint*,row_ext_t**,mem_heap_t*)" -> "rec_get_info_bits(const rec_t*,ulint)"
"row_build(ulint,const dict_index_t*,const rec_t*,const ulint*,const dict_table_t*,const dtuple_t*,const ulint*,row_ext_t**,mem_heap_t*)" -> "rec_get_offsets_func(const rec_t*,const dict_index_t*,ulint*,ulint,mem_heap_t**)"
"row_build(ulint,const dict_index_t*,const rec_t*,const ulint*,const dict_table_t*,const dtuple_t*,const ulint*,row_ext_t**,mem_heap_t*)" -> "rec_offs_size(const ulint*)"
"dict_table_copy_types(dtuple_t*,const dict_table_t*)" -> "dict_col_copy_type(const dict_col_t*,dtype_t*)"
"dict_table_copy_types(dtuple_t*,const dict_table_t*)" -> "dfield_set_null(dfield_t*)"
"dict_table_copy_types(dtuple_t*,const dict_table_t*)" -> "dtuple_get_n_fields(const dtuple_t*)"
"dtuple_copy(const dtuple_t*,mem_heap_t*)" -> "dfield_copy(dfield_t*,const dfield_t*)"
"dtuple_copy(const dtuple_t*,mem_heap_t*)" -> "dtuple_get_n_fields(const dtuple_t*)"
"dtuple_copy(const dtuple_t*,mem_heap_t*)" -> "dtuple_create(mem_heap_t*,ulint)"
"row_ext_create(ulint,const ulint*,ulint,const dtuple_t*,mem_heap_t*)" -> "mem_heap_alloc(mem_heap_t*,ulint)"
"row_ext_create(ulint,const ulint*,ulint,const dtuple_t*,mem_heap_t*)" -> "row_ext_cache_fill(row_ext_t*,ulint,ulint,const dfield_t*)"
"row_ext_create(ulint,const ulint*,ulint,const dtuple_t*,mem_heap_t*)" -> "dict_tf_get_zip_size(ulint)"
"row_ext_cache_fill(row_ext_t*,ulint,ulint,const dfield_t*)" -> "memcpy(void*,const void*,size_t)"
"row_ext_cache_fill(row_ext_t*,ulint,ulint,const dfield_t*)" -> "abort()"
"row_ext_cache_fill(row_ext_t*,ulint,ulint,const dfield_t*)" -> "btr_copy_externally_stored_field_prefix(unsigned char*,ulint,ulint,const unsigned char*,ulint)"
"row_ext_cache_fill(row_ext_t*,ulint,ulint,const dfield_t*)" -> "__builtin_expect(long int,long int)"
"row_ext_cache_fill(row_ext_t*,ulint,ulint,const dfield_t*)" -> "ut_dbg_assertion_failed(const char*,const char*,ulint)"
"row_ext_cache_fill(row_ext_t*,ulint,ulint,const dfield_t*)" -> "dfield_get_len(const dfield_t*)"
"row_ext_cache_fill(row_ext_t*,ulint,ulint,const dfield_t*)" -> "memcmp(const void*,const void*,size_t)"
"dtuple_coll_cmp(const dtuple_t*,const dtuple_t*)" -> "cmp_dfield_dfield(const dfield_t*,const dfield_t*)"
"dtuple_coll_cmp(const dtuple_t*,const dtuple_t*)" -> "dtuple_get_n_fields(const dtuple_t*)"
"cmp_dfield_dfield(const dfield_t*,const dfield_t*)" -> "cmp_data_data(ulint,ulint,const unsigned char*,ulint,const unsigned char*,ulint)"
"cmp_dfield_dfield(const dfield_t*,const dfield_t*)" -> "dfield_get_len(const dfield_t*)"
"row_build_index_entry(const dtuple_t*,const row_ext_t*,dict_index_t*,mem_heap_t*)" -> "row_build_index_entry_low(const dtuple_t*,const row_ext_t*,dict_index_t*,mem_heap_t*)"
"row_build_index_entry_low(const dtuple_t*,const row_ext_t*,dict_index_t*,mem_heap_t*)" -> "dict_index_is_univ(const dict_index_t*)"
"row_build_index_entry_low(const dtuple_t*,const row_ext_t*,dict_index_t*,mem_heap_t*)" -> "dfield_set_data(dfield_t*,const void*,ulint)"
"row_build_index_entry_low(const dtuple_t*,const row_ext_t*,dict_index_t*,mem_heap_t*)" -> "row_ext_lookup(const row_ext_t*,ulint,ulint*)"
"row_build_index_entry_low(const dtuple_t*,const row_ext_t*,dict_index_t*,mem_heap_t*)" -> "dfield_get_len(const dfield_t*)"
"row_build_index_entry_low(const dtuple_t*,const row_ext_t*,dict_index_t*,mem_heap_t*)" -> "ut_dbg_assertion_failed(const char*,const char*,ulint)"
"row_build_index_entry_low(const dtuple_t*,const row_ext_t*,dict_index_t*,mem_heap_t*)" -> "abort()"
"row_build_index_entry_low(const dtuple_t*,const row_ext_t*,dict_index_t*,mem_heap_t*)" -> "dict_index_get_n_unique_in_tree(const dict_index_t*)"
"row_build_index_entry_low(const dtuple_t*,const row_ext_t*,dict_index_t*,mem_heap_t*)" -> "dfield_set_len(dfield_t*,ulint)"
"row_build_index_entry_low(const dtuple_t*,const row_ext_t*,dict_index_t*,mem_heap_t*)" -> "dfield_is_null(const dfield_t*)"
"row_build_index_entry_low(const dtuple_t*,const row_ext_t*,dict_index_t*,mem_heap_t*)" -> "dfield_is_ext(const dfield_t*)"
"row_build_index_entry_low(const dtuple_t*,const row_ext_t*,dict_index_t*,mem_heap_t*)" -> "__builtin_expect(long int,long int)"
"row_build_index_entry_low(const dtuple_t*,const row_ext_t*,dict_index_t*,mem_heap_t*)" -> "dict_col_get_no(const dict_col_t*)"
"row_build_index_entry_low(const dtuple_t*,const row_ext_t*,dict_index_t*,mem_heap_t*)" -> "dtuple_set_n_fields_cmp(dtuple_t*,ulint)"
"row_build_index_entry_low(const dtuple_t*,const row_ext_t*,dict_index_t*,mem_heap_t*)" -> "dict_index_get_n_fields(const dict_index_t*)"
"row_build_index_entry_low(const dtuple_t*,const row_ext_t*,dict_index_t*,mem_heap_t*)" -> "dfield_copy(dfield_t*,const dfield_t*)"
"row_build_index_entry_low(const dtuple_t*,const row_ext_t*,dict_index_t*,mem_heap_t*)" -> "dict_index_is_clust(const dict_index_t*)"
"row_build_index_entry_low(const dtuple_t*,const row_ext_t*,dict_index_t*,mem_heap_t*)" -> "dtype_get_at_most_n_mbchars(ulint,ulint,ulint,ulint,const char*)"
"row_build_index_entry_low(const dtuple_t*,const row_ext_t*,dict_index_t*,mem_heap_t*)" -> "dtuple_create(mem_heap_t*,ulint)"
"row_ext_lookup(const row_ext_t*,ulint,ulint*)" -> "row_ext_lookup_ith(const row_ext_t*,ulint,ulint*)"
"dtype_get_at_most_n_mbchars(ulint,ulint,ulint,ulint,const char*)" -> "ut_dbg_assertion_failed(const char*,const char*,ulint)"
"dtype_get_at_most_n_mbchars(ulint,ulint,ulint,ulint,const char*)" -> "abort()"
"dtype_get_at_most_n_mbchars(ulint,ulint,ulint,ulint,const char*)" -> "__builtin_expect(long int,long int)"
"dtype_get_at_most_n_mbchars(ulint,ulint,ulint,ulint,const char*)" -> "innobase_get_at_most_n_mbchars(ulint,ulint,ulint,const char*)"
"dtype_get_at_most_n_mbchars(ulint,ulint,ulint,ulint,const char*)" -> "dtype_get_charset_coll(ulint)"
"innobase_get_at_most_n_mbchars(ulint,ulint,ulint,const char*)" -> "get_charset(uint,myf)"
"trx_undo_prev_version_build(const rec_t*,mtr_t*,const rec_t*,dict_index_t*,ulint*,mem_heap_t*,rec_t**)" -> "dict_index_is_clust(const dict_index_t*)"
"trx_undo_prev_version_build(const rec_t*,mtr_t*,const rec_t*,dict_index_t*,ulint*,mem_heap_t*,rec_t**)" -> "rec_get_converted_size(dict_index_t*,const dtuple_t*,ulint)"
"trx_undo_prev_version_build(const rec_t*,mtr_t*,const rec_t*,dict_index_t*,ulint*,mem_heap_t*,rec_t**)" -> "rec_copy(void*,const rec_t*,const ulint*)"
"trx_undo_prev_version_build(const rec_t*,mtr_t*,const rec_t*,dict_index_t*,ulint*,mem_heap_t*,rec_t**)" -> "row_upd_index_replace_new_col_vals(dtuple_t*,dict_index_t*,const upd_t*,mem_heap_t*)"
"trx_undo_prev_version_build(const rec_t*,mtr_t*,const rec_t*,dict_index_t*,ulint*,mem_heap_t*,rec_t**)" -> "row_upd_changes_field_size_or_external(dict_index_t*,const ulint*,const upd_t*)"
"trx_undo_prev_version_build(const rec_t*,mtr_t*,const rec_t*,dict_index_t*,ulint*,mem_heap_t*,rec_t**)" -> "trx_undo_roll_ptr_is_insert(roll_ptr_t)"
"trx_undo_prev_version_build(const rec_t*,mtr_t*,const rec_t*,dict_index_t*,ulint*,mem_heap_t*,rec_t**)" -> "btr_push_update_extern_fields(dtuple_t*,const upd_t*,mem_heap_t*)"
"trx_undo_prev_version_build(const rec_t*,mtr_t*,const rec_t*,dict_index_t*,ulint*,mem_heap_t*,rec_t**)" -> "mem_heap_alloc(mem_heap_t*,ulint)"
"trx_undo_prev_version_build(const rec_t*,mtr_t*,const rec_t*,dict_index_t*,ulint*,mem_heap_t*,rec_t**)" -> "row_upd_changes_disowned_external(const upd_t*)"
"trx_undo_prev_version_build(const rec_t*,mtr_t*,const rec_t*,dict_index_t*,ulint*,mem_heap_t*,rec_t**)" -> "__builtin_expect(long int,long int)"
"trx_undo_prev_version_build(const rec_t*,mtr_t*,const rec_t*,dict_index_t*,ulint*,mem_heap_t*,rec_t**)" -> "trx_undo_get_undo_rec(roll_ptr_t,trx_id_t,trx_undo_rec_t**,mem_heap_t*)"
"trx_undo_prev_version_build(const rec_t*,mtr_t*,const rec_t*,dict_index_t*,ulint*,mem_heap_t*,rec_t**)" -> "row_rec_to_index_entry(const rec_t*,const dict_index_t*,const ulint*,ulint*,mem_heap_t*)"
"trx_undo_prev_version_build(const rec_t*,mtr_t*,const rec_t*,dict_index_t*,ulint*,mem_heap_t*,rec_t**)" -> "abort()"
"trx_undo_prev_version_build(const rec_t*,mtr_t*,const rec_t*,dict_index_t*,ulint*,mem_heap_t*,rec_t**)" -> "read_view_sees_trx_id(const read_view_t*,trx_id_t)"
"trx_undo_prev_version_build(const rec_t*,mtr_t*,const rec_t*,dict_index_t*,ulint*,mem_heap_t*,rec_t**)" -> "row_upd_rec_in_place(rec_t*,dict_index_t*,const ulint*,const upd_t*,page_zip_des_t*)"
"trx_undo_prev_version_build(const rec_t*,mtr_t*,const rec_t*,dict_index_t*,ulint*,mem_heap_t*,rec_t**)" -> "pfs_rw_lock_s_lock_func(rw_lock_t*,ulint,const char*,ulint)"
"trx_undo_prev_version_build(const rec_t*,mtr_t*,const rec_t*,dict_index_t*,ulint*,mem_heap_t*,rec_t**)" -> "trx_undo_update_rec_get_sys_cols(unsigned char*,trx_id_t*,roll_ptr_t*,ulint*)"
"trx_undo_prev_version_build(const rec_t*,mtr_t*,const rec_t*,dict_index_t*,ulint*,mem_heap_t*,rec_t**)" -> "rec_convert_dtuple_to_rec(unsigned char*,const dict_index_t*,const dtuple_t*,ulint)"
"trx_undo_prev_version_build(const rec_t*,mtr_t*,const rec_t*,dict_index_t*,ulint*,mem_heap_t*,rec_t**)" -> "row_get_rec_roll_ptr(const rec_t*,const dict_index_t*,const ulint*)"
"trx_undo_prev_version_build(const rec_t*,mtr_t*,const rec_t*,dict_index_t*,ulint*,mem_heap_t*,rec_t**)" -> "row_get_rec_trx_id(const rec_t*,const dict_index_t*,const ulint*)"
"trx_undo_prev_version_build(const rec_t*,mtr_t*,const rec_t*,dict_index_t*,ulint*,mem_heap_t*,rec_t**)" -> "trx_undo_update_rec_get_update(unsigned char*,dict_index_t*,ulint,trx_id_t,roll_ptr_t,ulint,trx_t*,mem_heap_t*,upd_t**)"
"trx_undo_prev_version_build(const rec_t*,mtr_t*,const rec_t*,dict_index_t*,ulint*,mem_heap_t*,rec_t**)" -> "trx_undo_rec_skip_row_ref(unsigned char*,dict_index_t*)"
"trx_undo_prev_version_build(const rec_t*,mtr_t*,const rec_t*,dict_index_t*,ulint*,mem_heap_t*,rec_t**)" -> "rec_offs_size(const ulint*)"
"trx_undo_prev_version_build(const rec_t*,mtr_t*,const rec_t*,dict_index_t*,ulint*,mem_heap_t*,rec_t**)" -> "trx_undo_rec_get_pars(trx_undo_rec_t*,ulint*,ulint*,bool*,undo_no_t*,table_id_t*)"
"trx_undo_prev_version_build(const rec_t*,mtr_t*,const rec_t*,dict_index_t*,ulint*,mem_heap_t*,rec_t**)" -> "pfs_rw_lock_s_unlock_func(rw_lock_t*)"
"trx_undo_prev_version_build(const rec_t*,mtr_t*,const rec_t*,dict_index_t*,ulint*,mem_heap_t*,rec_t**)" -> "ut_dbg_assertion_failed(const char*,const char*,ulint)"
"row_upd_index_replace_new_col_vals(dtuple_t*,dict_index_t*,const upd_t*,mem_heap_t*)" -> "dtuple_set_info_bits(dtuple_t*,ulint)"
"row_upd_index_replace_new_col_vals(dtuple_t*,dict_index_t*,const upd_t*,mem_heap_t*)" -> "dict_field_get_col(const dict_field_t*)"
"row_upd_index_replace_new_col_vals(dtuple_t*,dict_index_t*,const upd_t*,mem_heap_t*)" -> "dict_index_get_n_fields(const dict_index_t*)"
"row_upd_index_replace_new_col_vals(dtuple_t*,dict_index_t*,const upd_t*,mem_heap_t*)" -> "upd_get_field_by_field_no(const upd_t*,ulint)"
"row_upd_index_replace_new_col_vals(dtuple_t*,dict_index_t*,const upd_t*,mem_heap_t*)" -> "row_upd_index_replace_new_col_val(dfield_t*,const dict_field_t*,const dict_col_t*,const upd_field_t*,mem_heap_t*,ulint)"
"row_upd_index_replace_new_col_vals(dtuple_t*,dict_index_t*,const upd_t*,mem_heap_t*)" -> "dict_col_get_clust_pos(const dict_col_t*,const dict_index_t*)"
"row_upd_index_replace_new_col_vals(dtuple_t*,dict_index_t*,const upd_t*,mem_heap_t*)" -> "dict_table_zip_size(const dict_table_t*)"
"upd_get_field_by_field_no(const upd_t*,ulint)" -> "upd_get_n_fields(const upd_t*)"
"row_upd_index_replace_new_col_val(dfield_t*,const dict_field_t*,const dict_col_t*,const upd_field_t*,mem_heap_t*,ulint)" -> "dfield_is_null(const dfield_t*)"
"row_upd_index_replace_new_col_val(dfield_t*,const dict_field_t*,const dict_col_t*,const upd_field_t*,mem_heap_t*,ulint)" -> "memcpy(void*,const void*,size_t)"
"row_upd_index_replace_new_col_val(dfield_t*,const dict_field_t*,const dict_col_t*,const upd_field_t*,mem_heap_t*,ulint)" -> "__builtin_expect(long int,long int)"
"row_upd_index_replace_new_col_val(dfield_t*,const dict_field_t*,const dict_col_t*,const upd_field_t*,mem_heap_t*,ulint)" -> "dfield_is_ext(const dfield_t*)"
"row_upd_index_replace_new_col_val(dfield_t*,const dict_field_t*,const dict_col_t*,const upd_field_t*,mem_heap_t*,ulint)" -> "dfield_get_len(const dfield_t*)"
"row_upd_index_replace_new_col_val(dfield_t*,const dict_field_t*,const dict_col_t*,const upd_field_t*,mem_heap_t*,ulint)" -> "mem_heap_alloc(mem_heap_t*,ulint)"
"row_upd_index_replace_new_col_val(dfield_t*,const dict_field_t*,const dict_col_t*,const upd_field_t*,mem_heap_t*,ulint)" -> "dfield_copy_data(dfield_t*,const dfield_t*)"
"row_upd_index_replace_new_col_val(dfield_t*,const dict_field_t*,const dict_col_t*,const upd_field_t*,mem_heap_t*,ulint)" -> "dfield_set_data(dfield_t*,const void*,ulint)"
"row_upd_index_replace_new_col_val(dfield_t*,const dict_field_t*,const dict_col_t*,const upd_field_t*,mem_heap_t*,ulint)" -> "ut_dbg_assertion_failed(const char*,const char*,ulint)"
"row_upd_index_replace_new_col_val(dfield_t*,const dict_field_t*,const dict_col_t*,const upd_field_t*,mem_heap_t*,ulint)" -> "row_upd_ext_fetch(const unsigned char*,ulint,ulint,ulint*,mem_heap_t*)"
"row_upd_index_replace_new_col_val(dfield_t*,const dict_field_t*,const dict_col_t*,const upd_field_t*,mem_heap_t*,ulint)" -> "dtype_get_at_most_n_mbchars(ulint,ulint,ulint,ulint,const char*)"
"row_upd_index_replace_new_col_val(dfield_t*,const dict_field_t*,const dict_col_t*,const upd_field_t*,mem_heap_t*,ulint)" -> "abort()"
"row_upd_index_replace_new_col_val(dfield_t*,const dict_field_t*,const dict_col_t*,const upd_field_t*,mem_heap_t*,ulint)" -> "dfield_set_ext(dfield_t*)"
"row_upd_index_replace_new_col_val(dfield_t*,const dict_field_t*,const dict_col_t*,const upd_field_t*,mem_heap_t*,ulint)" -> "dfield_dup(dfield_t*,mem_heap_t*)"
"row_upd_ext_fetch(const unsigned char*,ulint,ulint,ulint*,mem_heap_t*)" -> "mem_heap_alloc(mem_heap_t*,ulint)"
"row_upd_ext_fetch(const unsigned char*,ulint,ulint,ulint*,mem_heap_t*)" -> "btr_copy_externally_stored_field_prefix(unsigned char*,ulint,ulint,const unsigned char*,ulint)"
"row_upd_ext_fetch(const unsigned char*,ulint,ulint,ulint*,mem_heap_t*)" -> "ut_dbg_assertion_failed(const char*,const char*,ulint)"
"row_upd_ext_fetch(const unsigned char*,ulint,ulint,ulint*,mem_heap_t*)" -> "abort()"
"row_upd_ext_fetch(const unsigned char*,ulint,ulint,ulint*,mem_heap_t*)" -> "__builtin_expect(long int,long int)"
"dfield_dup(dfield_t*,mem_heap_t*)" -> "mem_heap_dup(mem_heap_t*,const void*,ulint)"
"dfield_dup(dfield_t*,mem_heap_t*)" -> "dfield_is_null(const dfield_t*)"
"btr_push_update_extern_fields(dtuple_t*,const upd_t*,mem_heap_t*)" -> "mem_heap_alloc(mem_heap_t*,ulint)"
"btr_push_update_extern_fields(dtuple_t*,const upd_t*,mem_heap_t*)" -> "dfield_set_data(dfield_t*,const void*,ulint)"
"btr_push_update_extern_fields(dtuple_t*,const upd_t*,mem_heap_t*)" -> "dfield_is_ext(const dfield_t*)"
"btr_push_update_extern_fields(dtuple_t*,const upd_t*,mem_heap_t*)" -> "abort()"
"btr_push_update_extern_fields(dtuple_t*,const upd_t*,mem_heap_t*)" -> "memcpy(void*,const void*,size_t)"
"btr_push_update_extern_fields(dtuple_t*,const upd_t*,mem_heap_t*)" -> "ut_dbg_assertion_failed(const char*,const char*,ulint)"
"btr_push_update_extern_fields(dtuple_t*,const upd_t*,mem_heap_t*)" -> "dfield_set_ext(dfield_t*)"
"btr_push_update_extern_fields(dtuple_t*,const upd_t*,mem_heap_t*)" -> "upd_get_n_fields(const upd_t*)"
"btr_push_update_extern_fields(dtuple_t*,const upd_t*,mem_heap_t*)" -> "dfield_get_len(const dfield_t*)"
"btr_push_update_extern_fields(dtuple_t*,const upd_t*,mem_heap_t*)" -> "__builtin_expect(long int,long int)"
"row_upd_changes_disowned_external(const upd_t*)" -> "dfield_get_len(const dfield_t*)"
"row_upd_changes_disowned_external(const upd_t*)" -> "upd_get_n_fields(const upd_t*)"
"row_upd_changes_disowned_external(const upd_t*)" -> "dfield_is_ext(const dfield_t*)"
"trx_undo_get_undo_rec(roll_ptr_t,trx_id_t,trx_undo_rec_t**,mem_heap_t*)" -> "pfs_rw_lock_s_unlock_func(rw_lock_t*)"
"trx_undo_get_undo_rec(roll_ptr_t,trx_id_t,trx_undo_rec_t**,mem_heap_t*)" -> "read_view_sees_trx_id(const read_view_t*,trx_id_t)"
"trx_undo_get_undo_rec(roll_ptr_t,trx_id_t,trx_undo_rec_t**,mem_heap_t*)" -> "pfs_rw_lock_s_lock_func(rw_lock_t*,ulint,const char*,ulint)"
"trx_undo_get_undo_rec(roll_ptr_t,trx_id_t,trx_undo_rec_t**,mem_heap_t*)" -> "trx_undo_get_undo_rec_low(roll_ptr_t,mem_heap_t*)"
"trx_undo_get_undo_rec_low(roll_ptr_t,mem_heap_t*)" -> "trx_undo_rec_copy(const trx_undo_rec_t*,mem_heap_t*)"
"trx_undo_get_undo_rec_low(roll_ptr_t,mem_heap_t*)" -> "trx_undo_page_get_s_latched(ulint,ulint,ulint,mtr_t*)"
"trx_undo_get_undo_rec_low(roll_ptr_t,mem_heap_t*)" -> "mtr_start(mtr_t*)"
"trx_undo_get_undo_rec_low(roll_ptr_t,mem_heap_t*)" -> "trx_rseg_get_on_id(ulint)"
"trx_undo_get_undo_rec_low(roll_ptr_t,mem_heap_t*)" -> "mtr_commit(mtr_t*)"
"trx_undo_get_undo_rec_low(roll_ptr_t,mem_heap_t*)" -> "trx_undo_decode_roll_ptr(roll_ptr_t,ulint*,ulint*,ulint*,ulint*)"
"trx_undo_rec_copy(const trx_undo_rec_t*,mem_heap_t*)" -> "mach_read_from_2(const unsigned char*)"
"trx_undo_rec_copy(const trx_undo_rec_t*,mem_heap_t*)" -> "mem_heap_dup(mem_heap_t*,const void*,ulint)"
"trx_undo_rec_copy(const trx_undo_rec_t*,mem_heap_t*)" -> "ut_align_offset(const void*,ulint)"
"trx_undo_page_get_s_latched(ulint,ulint,ulint,mtr_t*)" -> "buf_page_get_gen(ulint,ulint,ulint,ulint,buf_block_t*,ulint,const char*,ulint,mtr_t*)"
"trx_rseg_get_on_id(ulint)" -> "abort()"
"trx_rseg_get_on_id(ulint)" -> "ut_dbg_assertion_failed(const char*,const char*,ulint)"
"trx_rseg_get_on_id(ulint)" -> "__builtin_expect(long int,long int)"
"row_rec_to_index_entry(const rec_t*,const dict_index_t*,const ulint*,ulint*,mem_heap_t*)" -> "row_rec_to_index_entry_low(const rec_t*,const dict_index_t*,const ulint*,ulint*,mem_heap_t*)"
"row_rec_to_index_entry(const rec_t*,const dict_index_t*,const ulint*,ulint*,mem_heap_t*)" -> "dtuple_set_info_bits(dtuple_t*,ulint)"
"row_rec_to_index_entry(const rec_t*,const dict_index_t*,const ulint*,ulint*,mem_heap_t*)" -> "rec_offs_size(const ulint*)"
"row_rec_to_index_entry(const rec_t*,const dict_index_t*,const ulint*,ulint*,mem_heap_t*)" -> "rec_copy(void*,const rec_t*,const ulint*)"
"row_rec_to_index_entry(const rec_t*,const dict_index_t*,const ulint*,ulint*,mem_heap_t*)" -> "mem_heap_alloc(mem_heap_t*,ulint)"
"row_rec_to_index_entry(const rec_t*,const dict_index_t*,const ulint*,ulint*,mem_heap_t*)" -> "rec_get_info_bits(const rec_t*,ulint)"
"row_rec_to_index_entry(const rec_t*,const dict_index_t*,const ulint*,ulint*,mem_heap_t*)" -> "rec_offs_comp(const ulint*)"
"row_rec_to_index_entry_low(const rec_t*,const dict_index_t*,const ulint*,ulint*,mem_heap_t*)" -> "dfield_set_ext(dfield_t*)"
"row_rec_to_index_entry_low(const rec_t*,const dict_index_t*,const ulint*,ulint*,mem_heap_t*)" -> "dict_index_copy_types(dtuple_t*,const dict_index_t*,ulint)"
"row_rec_to_index_entry_low(const rec_t*,const dict_index_t*,const ulint*,ulint*,mem_heap_t*)" -> "dfield_set_data(dfield_t*,const void*,ulint)"
"row_rec_to_index_entry_low(const rec_t*,const dict_index_t*,const ulint*,ulint*,mem_heap_t*)" -> "dtuple_create(mem_heap_t*,ulint)"
"row_rec_to_index_entry_low(const rec_t*,const dict_index_t*,const ulint*,ulint*,mem_heap_t*)" -> "dict_index_get_n_unique_in_tree(const dict_index_t*)"
"row_rec_to_index_entry_low(const rec_t*,const dict_index_t*,const ulint*,ulint*,mem_heap_t*)" -> "rec_get_nth_field_offs(const ulint*,ulint,ulint*)"
"row_rec_to_index_entry_low(const rec_t*,const dict_index_t*,const ulint*,ulint*,mem_heap_t*)" -> "rec_offs_nth_extern(const ulint*,ulint)"
"row_rec_to_index_entry_low(const rec_t*,const dict_index_t*,const ulint*,ulint*,mem_heap_t*)" -> "rec_offs_n_fields(const ulint*)"
"row_rec_to_index_entry_low(const rec_t*,const dict_index_t*,const ulint*,ulint*,mem_heap_t*)" -> "dtuple_set_n_fields_cmp(dtuple_t*,ulint)"
"trx_undo_update_rec_get_sys_cols(unsigned char*,trx_id_t*,roll_ptr_t*,ulint*)" -> "mach_ull_get_compressed_size(ib_uint64_t)"
"trx_undo_update_rec_get_sys_cols(unsigned char*,trx_id_t*,roll_ptr_t*,ulint*)" -> "mach_ull_read_compressed(const unsigned char*)"
"trx_undo_update_rec_get_sys_cols(unsigned char*,trx_id_t*,roll_ptr_t*,ulint*)" -> "mach_read_from_1(const unsigned char*)"
"mach_ull_get_compressed_size(ib_uint64_t)" -> "mach_get_compressed_size(ulint)"
"mach_ull_read_compressed(const unsigned char*)" -> "mach_get_compressed_size(ulint)"
"mach_ull_read_compressed(const unsigned char*)" -> "mach_read_from_4(const unsigned char*)"
"mach_ull_read_compressed(const unsigned char*)" -> "mach_read_compressed(const unsigned char*)"
"mach_read_compressed(const unsigned char*)" -> "mach_read_from_1(const unsigned char*)"
"mach_read_compressed(const unsigned char*)" -> "mach_read_from_3(const unsigned char*)"
"mach_read_compressed(const unsigned char*)" -> "mach_read_from_4(const unsigned char*)"
"mach_read_compressed(const unsigned char*)" -> "mach_read_from_2(const unsigned char*)"
"row_get_rec_roll_ptr(const rec_t*,const dict_index_t*,const ulint*)" -> "row_get_trx_id_offset(const dict_index_t*,const ulint*)"
"row_get_rec_roll_ptr(const rec_t*,const dict_index_t*,const ulint*)" -> "trx_read_roll_ptr(const unsigned char*)"
"trx_undo_update_rec_get_update(unsigned char*,dict_index_t*,ulint,trx_id_t,roll_ptr_t,ulint,trx_t*,mem_heap_t*,upd_t**)" -> "trx_write_roll_ptr(unsigned char*,roll_ptr_t)"
"trx_undo_update_rec_get_update(unsigned char*,dict_index_t*,ulint,trx_id_t,roll_ptr_t,ulint,trx_t*,mem_heap_t*,upd_t**)" -> "ut_dbg_assertion_failed(const char*,const char*,ulint)"
"trx_undo_update_rec_get_update(unsigned char*,dict_index_t*,ulint,trx_id_t,roll_ptr_t,ulint,trx_t*,mem_heap_t*,upd_t**)" -> "upd_create(ulint,mem_heap_t*)"
"trx_undo_update_rec_get_update(unsigned char*,dict_index_t*,ulint,trx_id_t,roll_ptr_t,ulint,trx_t*,mem_heap_t*,upd_t**)" -> "dict_index_get_sys_col_pos(const dict_index_t*,ulint)"
"trx_undo_update_rec_get_update(unsigned char*,dict_index_t*,ulint,trx_id_t,roll_ptr_t,ulint,trx_t*,mem_heap_t*,upd_t**)" -> "__builtin_expect(long int,long int)"
"trx_undo_update_rec_get_update(unsigned char*,dict_index_t*,ulint,trx_id_t,roll_ptr_t,ulint,trx_t*,mem_heap_t*,upd_t**)" -> "abort()"
"trx_undo_update_rec_get_update(unsigned char*,dict_index_t*,ulint,trx_id_t,roll_ptr_t,ulint,trx_t*,mem_heap_t*,upd_t**)" -> "ut_print_name(FILE*,const trx_t*,ulint,const char*)"
"trx_undo_update_rec_get_update(unsigned char*,dict_index_t*,ulint,trx_id_t,roll_ptr_t,ulint,trx_t*,mem_heap_t*,upd_t**)" -> "dfield_set_null(dfield_t*)"
"trx_undo_update_rec_get_update(unsigned char*,dict_index_t*,ulint,trx_id_t,roll_ptr_t,ulint,trx_t*,mem_heap_t*,upd_t**)" -> "dfield_set_ext(dfield_t*)"
"trx_undo_update_rec_get_update(unsigned char*,dict_index_t*,ulint,trx_id_t,roll_ptr_t,ulint,trx_t*,mem_heap_t*,upd_t**)" -> "dict_index_name_print(FILE*,const trx_t*,const dict_index_t*)"
"trx_undo_update_rec_get_update(unsigned char*,dict_index_t*,ulint,trx_id_t,roll_ptr_t,ulint,trx_t*,mem_heap_t*,upd_t**)" -> "upd_field_set_field_no(upd_field_t*,ulint,dict_index_t*,trx_t*)"
"trx_undo_update_rec_get_update(unsigned char*,dict_index_t*,ulint,trx_id_t,roll_ptr_t,ulint,trx_t*,mem_heap_t*,upd_t**)" -> "trx_undo_rec_get_col_val(unsigned char*,unsigned char**,ulint*,ulint*)"
"trx_undo_update_rec_get_update(unsigned char*,dict_index_t*,ulint,trx_id_t,roll_ptr_t,ulint,trx_t*,mem_heap_t*,upd_t**)" -> "dict_index_is_clust(const dict_index_t*)"
"trx_undo_update_rec_get_update(unsigned char*,dict_index_t*,ulint,trx_id_t,roll_ptr_t,ulint,trx_t*,mem_heap_t*,upd_t**)" -> "trx_undo_update_rec_get_n_upd_fields(unsigned char*,ulint*)"
"trx_undo_update_rec_get_update(unsigned char*,dict_index_t*,ulint,trx_id_t,roll_ptr_t,ulint,trx_t*,mem_heap_t*,upd_t**)" -> "trx_write_trx_id(unsigned char*,trx_id_t)"
"trx_undo_update_rec_get_update(unsigned char*,dict_index_t*,ulint,trx_id_t,roll_ptr_t,ulint,trx_t*,mem_heap_t*,upd_t**)" -> "trx_undo_update_rec_get_field_no(unsigned char*,ulint*)"
"trx_undo_update_rec_get_update(unsigned char*,dict_index_t*,ulint,trx_id_t,roll_ptr_t,ulint,trx_t*,mem_heap_t*,upd_t**)" -> "dfield_set_data(dfield_t*,const void*,ulint)"
"trx_undo_update_rec_get_update(unsigned char*,dict_index_t*,ulint,trx_id_t,roll_ptr_t,ulint,trx_t*,mem_heap_t*,upd_t**)" -> "mem_heap_alloc(mem_heap_t*,ulint)"
"trx_undo_update_rec_get_update(unsigned char*,dict_index_t*,ulint,trx_id_t,roll_ptr_t,ulint,trx_t*,mem_heap_t*,upd_t**)" -> "fprintf(FILE*,const char*,...)"
"trx_undo_update_rec_get_update(unsigned char*,dict_index_t*,ulint,trx_id_t,roll_ptr_t,ulint,trx_t*,mem_heap_t*,upd_t**)" -> "dict_index_get_n_fields(const dict_index_t*)"
"trx_undo_rec_get_col_val(unsigned char*,unsigned char**,ulint*,ulint*)" -> "mach_get_compressed_size(ulint)"
"trx_undo_rec_get_col_val(unsigned char*,unsigned char**,ulint*,ulint*)" -> "mach_read_compressed(const unsigned char*)"
"trx_undo_update_rec_get_n_upd_fields(unsigned char*,ulint*)" -> "mach_read_compressed(const unsigned char*)"
"trx_undo_update_rec_get_n_upd_fields(unsigned char*,ulint*)" -> "mach_get_compressed_size(ulint)"
"trx_undo_update_rec_get_field_no(unsigned char*,ulint*)" -> "mach_get_compressed_size(ulint)"
"trx_undo_update_rec_get_field_no(unsigned char*,ulint*)" -> "mach_read_compressed(const unsigned char*)"
"trx_undo_rec_skip_row_ref(unsigned char*,dict_index_t*)" -> "__builtin_expect(long int,long int)"
"trx_undo_rec_skip_row_ref(unsigned char*,dict_index_t*)" -> "trx_undo_rec_get_col_val(unsigned char*,unsigned char**,ulint*,ulint*)"
"trx_undo_rec_skip_row_ref(unsigned char*,dict_index_t*)" -> "ut_dbg_assertion_failed(const char*,const char*,ulint)"
"trx_undo_rec_skip_row_ref(unsigned char*,dict_index_t*)" -> "dict_index_get_n_unique(const dict_index_t*)"
"trx_undo_rec_skip_row_ref(unsigned char*,dict_index_t*)" -> "abort()"
"trx_undo_rec_skip_row_ref(unsigned char*,dict_index_t*)" -> "dict_index_is_clust(const dict_index_t*)"
"trx_undo_rec_get_pars(trx_undo_rec_t*,ulint*,ulint*,bool*,undo_no_t*,table_id_t*)" -> "mach_read_from_1(const unsigned char*)"
"trx_undo_rec_get_pars(trx_undo_rec_t*,ulint*,ulint*,bool*,undo_no_t*,table_id_t*)" -> "mach_ull_get_much_compressed_size(ib_uint64_t)"
"trx_undo_rec_get_pars(trx_undo_rec_t*,ulint*,ulint*,bool*,undo_no_t*,table_id_t*)" -> "mach_ull_read_much_compressed(const unsigned char*)"
"mach_ull_get_much_compressed_size(ib_uint64_t)" -> "mach_get_compressed_size(ulint)"
"mach_ull_read_much_compressed(const unsigned char*)" -> "mach_get_compressed_size(ulint)"
"mach_ull_read_much_compressed(const unsigned char*)" -> "mach_read_compressed(const unsigned char*)"
"buf_page_optimistic_get(ulint,buf_block_t*,ib_uint64_t,const char*,ulint,mtr_t*)" -> "ibuf_inside(const mtr_t*)"
"buf_page_optimistic_get(ulint,buf_block_t*,ib_uint64_t,const char*,ulint,mtr_t*)" -> "buf_block_get_zip_size(const buf_block_t*)"
"buf_page_optimistic_get(ulint,buf_block_t*,ib_uint64_t,const char*,ulint,mtr_t*)" -> "buf_block_buf_fix_inc_func(buf_block_t*)"
"buf_page_optimistic_get(ulint,buf_block_t*,ib_uint64_t,const char*,ulint,mtr_t*)" -> "buf_page_set_accessed(buf_page_t*)"
"buf_page_optimistic_get(ulint,buf_block_t*,ib_uint64_t,const char*,ulint,mtr_t*)" -> "buf_block_get_state(const buf_block_t*)"
"buf_page_optimistic_get(ulint,buf_block_t*,ib_uint64_t,const char*,ulint,mtr_t*)" -> "buf_pool_from_block(const buf_block_t*)"
"buf_page_optimistic_get(ulint,buf_block_t*,ib_uint64_t,const char*,ulint,mtr_t*)" -> "__builtin_expect(long int,long int)"
"buf_page_optimistic_get(ulint,buf_block_t*,ib_uint64_t,const char*,ulint,mtr_t*)" -> "buf_page_is_accessed(const buf_page_t*)"
"buf_page_optimistic_get(ulint,buf_block_t*,ib_uint64_t,const char*,ulint,mtr_t*)" -> "pfs_rw_lock_s_lock_low(rw_lock_t*,ulint,const char*,ulint)"
"buf_page_optimistic_get(ulint,buf_block_t*,ib_uint64_t,const char*,ulint,mtr_t*)" -> "pfs_mutex_enter_func(ib_mutex_t*,const char*,ulint)"
"buf_page_optimistic_get(ulint,buf_block_t*,ib_uint64_t,const char*,ulint,mtr_t*)" -> "buf_block_buf_fix_dec(buf_block_t*)"
"buf_page_optimistic_get(ulint,buf_block_t*,ib_uint64_t,const char*,ulint,mtr_t*)" -> "buf_block_get_space(const buf_block_t*)"
"buf_page_optimistic_get(ulint,buf_block_t*,ib_uint64_t,const char*,ulint,mtr_t*)" -> "pfs_mutex_exit_func(ib_mutex_t*)"
"buf_page_optimistic_get(ulint,buf_block_t*,ib_uint64_t,const char*,ulint,mtr_t*)" -> "mtr_memo_push(mtr_t*,void*,ulint)"
"buf_page_optimistic_get(ulint,buf_block_t*,ib_uint64_t,const char*,ulint,mtr_t*)" -> "buf_block_get_page_no(const buf_block_t*)"
"buf_page_optimistic_get(ulint,buf_block_t*,ib_uint64_t,const char*,ulint,mtr_t*)" -> "pfs_rw_lock_s_unlock_func(rw_lock_t*)"
"buf_page_optimistic_get(ulint,buf_block_t*,ib_uint64_t,const char*,ulint,mtr_t*)" -> "pfs_rw_lock_x_unlock_func(rw_lock_t*)"
"buf_page_optimistic_get(ulint,buf_block_t*,ib_uint64_t,const char*,ulint,mtr_t*)" -> "buf_read_ahead_linear(ulint,ulint,ulint,ulint)"
"buf_page_optimistic_get(ulint,buf_block_t*,ib_uint64_t,const char*,ulint,mtr_t*)" -> "pfs_rw_lock_x_lock_func_nowait(rw_lock_t*,const char*,ulint)"
"buf_page_optimistic_get(ulint,buf_block_t*,ib_uint64_t,const char*,ulint,mtr_t*)" -> "buf_page_make_young_if_needed(buf_page_t*)"
"buf_read_ahead_linear(ulint,ulint,ulint,ulint)" -> "buf_pool_get(ulint,ulint)"
"buf_read_ahead_linear(ulint,ulint,ulint,ulint)" -> "ut_ulint_cmp(ulint,ulint)"
"buf_read_ahead_linear(ulint,ulint,ulint,ulint)" -> "buf_read_page_low(dberr_t*,bool,ulint,ulint,ulint,ulint,ib_int64_t,ulint)"
"buf_read_ahead_linear(ulint,ulint,ulint,ulint)" -> "buf_page_get_state(const buf_page_t*)"
"buf_read_ahead_linear(ulint,ulint,ulint,ulint)" -> "pfs_mutex_exit_func(ib_mutex_t*)"
"buf_read_ahead_linear(ulint,ulint,ulint,ulint)" -> "buf_page_hash_get_locked(buf_pool_t*,ulint,ulint,rw_lock_t**,ulint)"
"buf_read_ahead_linear(ulint,ulint,ulint,ulint)" -> "fil_space_get_size(ulint)"
"buf_read_ahead_linear(ulint,ulint,ulint,ulint)" -> "os_aio_simulated_put_read_threads_to_sleep()"
"buf_read_ahead_linear(ulint,ulint,ulint,ulint)" -> "fil_page_get_next(const unsigned char*)"
"buf_read_ahead_linear(ulint,ulint,ulint,ulint)" -> "os_aio_simulated_wake_handler_threads()"
"buf_read_ahead_linear(ulint,ulint,ulint,ulint)" -> "__builtin_expect(long int,long int)"
"buf_read_ahead_linear(ulint,ulint,ulint,ulint)" -> "fil_space_get_version(ulint)"
"buf_read_ahead_linear(ulint,ulint,ulint,ulint)" -> "abort()"
"buf_read_ahead_linear(ulint,ulint,ulint,ulint)" -> "buf_page_is_accessed(const buf_page_t*)"
"buf_read_ahead_linear(ulint,ulint,ulint,ulint)" -> "pfs_mutex_enter_func(ib_mutex_t*,const char*,ulint)"
"buf_read_ahead_linear(ulint,ulint,ulint,ulint)" -> "ut_min(ulint,ulint)"
"buf_read_ahead_linear(ulint,ulint,ulint,ulint)" -> "ut_dbg_assertion_failed(const char*,const char*,ulint)"
"buf_read_ahead_linear(ulint,ulint,ulint,ulint)" -> "fprintf(FILE*,const char*,...)"
"buf_read_ahead_linear(ulint,ulint,ulint,ulint)" -> "ut_print_timestamp(FILE*)"
"buf_read_ahead_linear(ulint,ulint,ulint,ulint)" -> "trx_sys_hdr_page(ulint,ulint)"
"buf_read_ahead_linear(ulint,ulint,ulint,ulint)" -> "ut_2_power_up(ulint)"
"buf_read_ahead_linear(ulint,ulint,ulint,ulint)" -> "fil_page_get_prev(const unsigned char*)"
"buf_read_ahead_linear(ulint,ulint,ulint,ulint)" -> "ibuf_bitmap_page(ulint,ulint)"
"fil_page_get_next(const unsigned char*)" -> "mach_read_from_4(const unsigned char*)"
"dict_table_get_low(const char*)" -> "ut_print_name(FILE*,const trx_t*,ulint,const char*)"
"dict_table_get_low(const char*)" -> "__builtin_fwrite(const void*,size_t,size_t,FILE*)"
"dict_table_get_low(const char*)" -> "dict_load_table(const char*,ulint,dict_err_ignore_t)"
"dict_table_get_low(const char*)" -> "dict_table_check_if_in_cache_low(const char*)"
"dict_table_check_if_in_cache_low(const char*)" -> "hash_get_nth_cell(hash_table_t*,ulint)"
"dict_table_check_if_in_cache_low(const char*)" -> "ut_fold_string(const char*)"
"dict_table_check_if_in_cache_low(const char*)" -> "strcmp(const char*,const char*)"
"dict_table_check_if_in_cache_low(const char*)" -> "hash_calc_hash(ulint,hash_table_t*)"
"ut_fold_string(const char*)" -> "ut_fold_ulint_pair(ulint,ulint)"
"dict_load_foreign(const char*,const char**,bool,bool,dict_err_ignore_t)" -> "mach_read_from_4(const unsigned char*)"
"dict_load_foreign(const char*,const char**,bool,bool,dict_err_ignore_t)" -> "dict_index_copy_types(dtuple_t*,const dict_index_t*,ulint)"
"dict_load_foreign(const char*,const char**,bool,bool,dict_err_ignore_t)" -> "dict_table_check_if_in_cache_low(const char*)"
"dict_load_foreign(const char*,const char**,bool,bool,dict_err_ignore_t)" -> "mtr_start(mtr_t*)"
"dict_load_foreign(const char*,const char**,bool,bool,dict_err_ignore_t)" -> "mem_heap_create_func(ulint,ulint)"
"dict_load_foreign(const char*,const char**,bool,bool,dict_err_ignore_t)" -> "btr_pcur_open_on_user_rec_func(dict_index_t*,const dtuple_t*,ulint,ulint,btr_pcur_t*,const char*,ulint,mtr_t*)"
"dict_load_foreign(const char*,const char**,bool,bool,dict_err_ignore_t)" -> "abort()"
"dict_load_foreign(const char*,const char**,bool,bool,dict_err_ignore_t)" -> "dfield_set_data(dfield_t*,const void*,ulint)"
"dict_load_foreign(const char*,const char**,bool,bool,dict_err_ignore_t)" -> "mem_heap_strdupl(mem_heap_t*,const char*,ulint)"
"dict_load_foreign(const char*,const char**,bool,bool,dict_err_ignore_t)" -> "dict_mem_foreign_table_name_lookup_set(dict_foreign_t*,ulint)"
"dict_load_foreign(const char*,const char**,bool,bool,dict_err_ignore_t)" -> "fprintf(FILE*,const char*,...)"
"dict_load_foreign(const char*,const char**,bool,bool,dict_err_ignore_t)" -> "dict_mem_foreign_create()"
"dict_load_foreign(const char*,const char**,bool,bool,dict_err_ignore_t)" -> "btr_pcur_close(btr_pcur_t*)"
"dict_load_foreign(const char*,const char**,bool,bool,dict_err_ignore_t)" -> "mtr_commit(mtr_t*)"
"dict_load_foreign(const char*,const char**,bool,bool,dict_err_ignore_t)" -> "dict_foreign_add_to_cache(dict_foreign_t*,const char**,bool,dict_err_ignore_t)"
"dict_load_foreign(const char*,const char**,bool,bool,dict_err_ignore_t)" -> "mem_heap_free_func(mem_heap_t*,const char*,ulint)"
"dict_load_foreign(const char*,const char**,bool,bool,dict_err_ignore_t)" -> "ut_memcmp(const void*,const void*,ulint)"
"dict_load_foreign(const char*,const char**,bool,bool,dict_err_ignore_t)" -> "dict_table_get_low(const char*)"
"dict_load_foreign(const char*,const char**,bool,bool,dict_err_ignore_t)" -> "dtuple_create(mem_heap_t*,ulint)"
"dict_load_foreign(const char*,const char**,bool,bool,dict_err_ignore_t)" -> "__builtin_expect(long int,long int)"
"dict_load_foreign(const char*,const char**,bool,bool,dict_err_ignore_t)" -> "dict_mem_referenced_table_name_lookup_set(dict_foreign_t*,ulint)"
"dict_load_foreign(const char*,const char**,bool,bool,dict_err_ignore_t)" -> "btr_pcur_is_on_user_rec(const btr_pcur_t*)"
"dict_load_foreign(const char*,const char**,bool,bool,dict_err_ignore_t)" -> "rec_get_nth_field_offs_old(const rec_t*,ulint,ulint*)"
"dict_load_foreign(const char*,const char**,bool,bool,dict_err_ignore_t)" -> "dict_load_foreign_cols(dict_foreign_t*)"
"dict_load_foreign(const char*,const char**,bool,bool,dict_err_ignore_t)" -> "ut_dbg_assertion_failed(const char*,const char*,ulint)"
"dict_load_foreign(const char*,const char**,bool,bool,dict_err_ignore_t)" -> "strlen(const char*)"
"dict_load_foreign(const char*,const char**,bool,bool,dict_err_ignore_t)" -> "rec_get_deleted_flag(const rec_t*,ulint)"
"dict_mem_foreign_table_name_lookup_set(dict_foreign_t*,ulint)" -> "strlen(const char*)"
"dict_mem_foreign_table_name_lookup_set(dict_foreign_t*,ulint)" -> "innobase_get_lower_case_table_names()"
"dict_mem_foreign_table_name_lookup_set(dict_foreign_t*,ulint)" -> "mem_heap_alloc(mem_heap_t*,ulint)"
"dict_mem_foreign_table_name_lookup_set(dict_foreign_t*,ulint)" -> "strcpy(char*,const char*)"
"dict_mem_foreign_table_name_lookup_set(dict_foreign_t*,ulint)" -> "innobase_casedn_str(char*)"
"dict_mem_foreign_create()" -> "mem_heap_zalloc(mem_heap_t*,ulint)"
"dict_mem_foreign_create()" -> "mem_heap_create_func(ulint,ulint)"
"dict_foreign_add_to_cache(dict_foreign_t*,const char**,bool,dict_err_ignore_t)" -> "mem_heap_free_func(mem_heap_t*,const char*,ulint)"
"dict_foreign_add_to_cache(dict_foreign_t*,const char**,bool,dict_err_ignore_t)" -> "_Alloc>::erase(const key_type&) [with _Key = dict_foreign_t*,_Compare = dict_foreign_compare,_Alloc = std::allocator<dict_foreign_t*>,std::set<_Key,_Compare,_Alloc>::size_type = long unsigned int,std::set<_Key,_Compare,_Alloc>::key_type = dict_foreign_t*]"
"dict_foreign_add_to_cache(dict_foreign_t*,const char**,bool,dict_err_ignore_t)" -> "dict_foreign_error_report(FILE*,dict_foreign_t*,const char*)"
"dict_foreign_add_to_cache(dict_foreign_t*,const char**,bool,dict_err_ignore_t)" -> "__builtin_expect(long int,long int)"
"dict_foreign_add_to_cache(dict_foreign_t*,const char**,bool,dict_err_ignore_t)" -> "ut_dbg_assertion_failed(const char*,const char*,ulint)"
"dict_foreign_add_to_cache(dict_foreign_t*,const char**,bool,dict_err_ignore_t)" -> "dict_table_move_from_lru_to_non_lru(dict_table_t*)"
"dict_foreign_add_to_cache(dict_foreign_t*,const char**,bool,dict_err_ignore_t)" -> "dict_foreign_find(dict_table_t*,dict_foreign_t*)"
"dict_foreign_add_to_cache(dict_foreign_t*,const char**,bool,dict_err_ignore_t)" -> "_Alloc>::insert(const value_type&) [with _Key = dict_foreign_t*,_Compare = dict_foreign_compare,_Alloc = std::allocator<dict_foreign_t*>,typename std::_Rb_tree<_Key,_Key,std::_Identity<_Key>,_Compare,typename _Alloc::rebind<_Key>::other>::const_iterator = std::_Rb_tree_const_iterator<dict_foreign_t*>,std::set<_Key,_Compare,_Alloc>::value_type = dict_foreign_t*]"
"dict_foreign_add_to_cache(dict_foreign_t*,const char**,bool,dict_err_ignore_t)" -> "dict_table_check_if_in_cache_low(const char*)"
"dict_foreign_add_to_cache(dict_foreign_t*,const char**,bool,dict_err_ignore_t)" -> "dict_foreign_find_index(const dict_table_t*,const char**,const char**,ulint,const dict_index_t*,bool,ulint)"
"dict_foreign_add_to_cache(dict_foreign_t*,const char**,bool,dict_err_ignore_t)" -> "abort()"
"_Alloc>::erase(const key_type&) [with _Key = dict_foreign_t*,_Compare = dict_foreign_compare,_Alloc = std::allocator<dict_foreign_t*>,std::set<_Key,_Compare,_Alloc>::size_type = long unsigned int,std::set<_Key,_Compare,_Alloc>::key_type = dict_foreign_t*]" -> "_Alloc>::erase(const _Key&) [with _Key = dict_foreign_t*,_Val = dict_foreign_t*,_KeyOfValue = std::_Identity<dict_foreign_t*>,_Compare = dict_foreign_compare,_Alloc = std::allocator<dict_foreign_t*>,std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::size_type = long unsigned int]"
"_Alloc>::erase(const _Key&) [with _Key = dict_foreign_t*,_Val = dict_foreign_t*,_KeyOfValue = std::_Identity<dict_foreign_t*>,_Compare = dict_foreign_compare,_Alloc = std::allocator<dict_foreign_t*>,std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::size_type = long unsigned int]" -> "_Alloc>::equal_range(const _Key&) [with _Key = dict_foreign_t*,_Val = dict_foreign_t*,_KeyOfValue = std::_Identity<dict_foreign_t*>,_Compare = dict_foreign_compare,_Alloc = std::allocator<dict_foreign_t*>]"
"_Alloc>::erase(const _Key&) [with _Key = dict_foreign_t*,_Val = dict_foreign_t*,_KeyOfValue = std::_Identity<dict_foreign_t*>,_Compare = dict_foreign_compare,_Alloc = std::allocator<dict_foreign_t*>,std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::size_type = long unsigned int]" -> "_Alloc>::erase(std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::iterator,std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::iterator) [with _Key = dict_foreign_t*,_Val = dict_foreign_t*,_KeyOfValue = std::_Identity<dict_foreign_t*>,_Compare = dict_foreign_compare,_Alloc = std::allocator<dict_foreign_t*>,std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::iterator = std::_Rb_tree_iterator<dict_foreign_t*>]"
"_Alloc>::erase(const _Key&) [with _Key = dict_foreign_t*,_Val = dict_foreign_t*,_KeyOfValue = std::_Identity<dict_foreign_t*>,_Compare = dict_foreign_compare,_Alloc = std::allocator<dict_foreign_t*>,std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::size_type = long unsigned int]" -> "_Alloc>::size() const [with _Key = dict_foreign_t*,_Val = dict_foreign_t*,_KeyOfValue = std::_Identity<dict_foreign_t*>,_Compare = dict_foreign_compare,_Alloc = std::allocator<dict_foreign_t*>,std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::size_type = long unsigned int]"
"_Alloc>::equal_range(const _Key&) [with _Key = dict_foreign_t*,_Val = dict_foreign_t*,_KeyOfValue = std::_Identity<dict_foreign_t*>,_Compare = dict_foreign_compare,_Alloc = std::allocator<dict_foreign_t*>]" -> "_Alloc>::_M_lower_bound(std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::_Link_type,std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::_Link_type,const _Key&) [with _Key = dict_foreign_t*,_Val = dict_foreign_t*,_KeyOfValue = std::_Identity<dict_foreign_t*>,_Compare = dict_foreign_compare,_Alloc = std::allocator<dict_foreign_t*>,std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::iterator = std::_Rb_tree_iterator<dict_foreign_t*>,std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::_Link_type = std::_Rb_tree_node<dict_foreign_t*>*]"
"_Alloc>::equal_range(const _Key&) [with _Key = dict_foreign_t*,_Val = dict_foreign_t*,_KeyOfValue = std::_Identity<dict_foreign_t*>,_Compare = dict_foreign_compare,_Alloc = std::allocator<dict_foreign_t*>]" -> "_Alloc>::_M_end() [with _Key = dict_foreign_t*,_Val = dict_foreign_t*,_KeyOfValue = std::_Identity<dict_foreign_t*>,_Compare = dict_foreign_compare,_Alloc = std::allocator<dict_foreign_t*>,std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::_Link_type = std::_Rb_tree_node<dict_foreign_t*>*]"
"_Alloc>::equal_range(const _Key&) [with _Key = dict_foreign_t*,_Val = dict_foreign_t*,_KeyOfValue = std::_Identity<dict_foreign_t*>,_Compare = dict_foreign_compare,_Alloc = std::allocator<dict_foreign_t*>]" -> "std::_Rb_tree_iterator<_Tp>::_Rb_tree_iterator(std::_Rb_tree_iterator<_Tp>::_Link_type) [with _Tp = dict_foreign_t*,std::_Rb_tree_iterator<_Tp>::_Link_type = std::_Rb_tree_node<dict_foreign_t*>*]"
"_Alloc>::equal_range(const _Key&) [with _Key = dict_foreign_t*,_Val = dict_foreign_t*,_KeyOfValue = std::_Identity<dict_foreign_t*>,_Compare = dict_foreign_compare,_Alloc = std::allocator<dict_foreign_t*>]" -> "_Alloc>::_M_upper_bound(std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::_Link_type,std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::_Link_type,const _Key&) [with _Key = dict_foreign_t*,_Val = dict_foreign_t*,_KeyOfValue = std::_Identity<dict_foreign_t*>,_Compare = dict_foreign_compare,_Alloc = std::allocator<dict_foreign_t*>,std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::iterator = std::_Rb_tree_iterator<dict_foreign_t*>,std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::_Link_type = std::_Rb_tree_node<dict_foreign_t*>*]"
"_Alloc>::equal_range(const _Key&) [with _Key = dict_foreign_t*,_Val = dict_foreign_t*,_KeyOfValue = std::_Identity<dict_foreign_t*>,_Compare = dict_foreign_compare,_Alloc = std::allocator<dict_foreign_t*>]" -> "_Alloc>::_M_begin() [with _Key = dict_foreign_t*,_Val = dict_foreign_t*,_KeyOfValue = std::_Identity<dict_foreign_t*>,_Compare = dict_foreign_compare,_Alloc = std::allocator<dict_foreign_t*>,std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::_Link_type = std::_Rb_tree_node<dict_foreign_t*>*]"
"_Alloc>::equal_range(const _Key&) [with _Key = dict_foreign_t*,_Val = dict_foreign_t*,_KeyOfValue = std::_Identity<dict_foreign_t*>,_Compare = dict_foreign_compare,_Alloc = std::allocator<dict_foreign_t*>]" -> "_T2>::pair(const _T1&,const _T2&) [with _T1 = std::_Rb_tree_iterator<dict_foreign_t*>,_T2 = std::_Rb_tree_iterator<dict_foreign_t*>]"
"_Alloc>::equal_range(const _Key&) [with _Key = dict_foreign_t*,_Val = dict_foreign_t*,_KeyOfValue = std::_Identity<dict_foreign_t*>,_Compare = dict_foreign_compare,_Alloc = std::allocator<dict_foreign_t*>]" -> "_Alloc>::_S_right(std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::_Base_ptr) [with _Key = dict_foreign_t*,_Val = dict_foreign_t*,_KeyOfValue = std::_Identity<dict_foreign_t*>,_Compare = dict_foreign_compare,_Alloc = std::allocator<dict_foreign_t*>,std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::_Link_type = std::_Rb_tree_node<dict_foreign_t*>*,std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::_Base_ptr = std::_Rb_tree_node_base*]"
"_Alloc>::equal_range(const _Key&) [with _Key = dict_foreign_t*,_Val = dict_foreign_t*,_KeyOfValue = std::_Identity<dict_foreign_t*>,_Compare = dict_foreign_compare,_Alloc = std::allocator<dict_foreign_t*>]" -> "_Alloc>::_S_key(std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::_Const_Link_type) [with _Key = dict_foreign_t*,_Val = dict_foreign_t*,_KeyOfValue = std::_Identity<dict_foreign_t*>,_Compare = dict_foreign_compare,_Alloc = std::allocator<dict_foreign_t*>,std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::_Const_Link_type = const std::_Rb_tree_node<dict_foreign_t*>*]"
"_Alloc>::equal_range(const _Key&) [with _Key = dict_foreign_t*,_Val = dict_foreign_t*,_KeyOfValue = std::_Identity<dict_foreign_t*>,_Compare = dict_foreign_compare,_Alloc = std::allocator<dict_foreign_t*>]" -> "dict_foreign_compare::operator()(const dict_foreign_t*,const dict_foreign_t*) const"
"_Alloc>::equal_range(const _Key&) [with _Key = dict_foreign_t*,_Val = dict_foreign_t*,_KeyOfValue = std::_Identity<dict_foreign_t*>,_Compare = dict_foreign_compare,_Alloc = std::allocator<dict_foreign_t*>]" -> "_Alloc>::_S_left(std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::_Base_ptr) [with _Key = dict_foreign_t*,_Val = dict_foreign_t*,_KeyOfValue = std::_Identity<dict_foreign_t*>,_Compare = dict_foreign_compare,_Alloc = std::allocator<dict_foreign_t*>,std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::_Link_type = std::_Rb_tree_node<dict_foreign_t*>*,std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::_Base_ptr = std::_Rb_tree_node_base*]"
"_Alloc>::_M_lower_bound(std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::_Link_type,std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::_Link_type,const _Key&) [with _Key = dict_foreign_t*,_Val = dict_foreign_t*,_KeyOfValue = std::_Identity<dict_foreign_t*>,_Compare = dict_foreign_compare,_Alloc = std::allocator<dict_foreign_t*>,std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::iterator = std::_Rb_tree_iterator<dict_foreign_t*>,std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::_Link_type = std::_Rb_tree_node<dict_foreign_t*>*]" -> "_Alloc>::_S_left(std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::_Base_ptr) [with _Key = dict_foreign_t*,_Val = dict_foreign_t*,_KeyOfValue = std::_Identity<dict_foreign_t*>,_Compare = dict_foreign_compare,_Alloc = std::allocator<dict_foreign_t*>,std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::_Link_type = std::_Rb_tree_node<dict_foreign_t*>*,std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::_Base_ptr = std::_Rb_tree_node_base*]"
"_Alloc>::_M_lower_bound(std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::_Link_type,std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::_Link_type,const _Key&) [with _Key = dict_foreign_t*,_Val = dict_foreign_t*,_KeyOfValue = std::_Identity<dict_foreign_t*>,_Compare = dict_foreign_compare,_Alloc = std::allocator<dict_foreign_t*>,std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::iterator = std::_Rb_tree_iterator<dict_foreign_t*>,std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::_Link_type = std::_Rb_tree_node<dict_foreign_t*>*]" -> "dict_foreign_compare::operator()(const dict_foreign_t*,const dict_foreign_t*) const"
"_Alloc>::_M_lower_bound(std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::_Link_type,std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::_Link_type,const _Key&) [with _Key = dict_foreign_t*,_Val = dict_foreign_t*,_KeyOfValue = std::_Identity<dict_foreign_t*>,_Compare = dict_foreign_compare,_Alloc = std::allocator<dict_foreign_t*>,std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::iterator = std::_Rb_tree_iterator<dict_foreign_t*>,std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::_Link_type = std::_Rb_tree_node<dict_foreign_t*>*]" -> "std::_Rb_tree_iterator<_Tp>::_Rb_tree_iterator(std::_Rb_tree_iterator<_Tp>::_Link_type) [with _Tp = dict_foreign_t*,std::_Rb_tree_iterator<_Tp>::_Link_type = std::_Rb_tree_node<dict_foreign_t*>*]"
"_Alloc>::_M_lower_bound(std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::_Link_type,std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::_Link_type,const _Key&) [with _Key = dict_foreign_t*,_Val = dict_foreign_t*,_KeyOfValue = std::_Identity<dict_foreign_t*>,_Compare = dict_foreign_compare,_Alloc = std::allocator<dict_foreign_t*>,std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::iterator = std::_Rb_tree_iterator<dict_foreign_t*>,std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::_Link_type = std::_Rb_tree_node<dict_foreign_t*>*]" -> "_Alloc>::_S_key(std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::_Const_Link_type) [with _Key = dict_foreign_t*,_Val = dict_foreign_t*,_KeyOfValue = std::_Identity<dict_foreign_t*>,_Compare = dict_foreign_compare,_Alloc = std::allocator<dict_foreign_t*>,std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::_Const_Link_type = const std::_Rb_tree_node<dict_foreign_t*>*]"
"_Alloc>::_M_lower_bound(std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::_Link_type,std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::_Link_type,const _Key&) [with _Key = dict_foreign_t*,_Val = dict_foreign_t*,_KeyOfValue = std::_Identity<dict_foreign_t*>,_Compare = dict_foreign_compare,_Alloc = std::allocator<dict_foreign_t*>,std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::iterator = std::_Rb_tree_iterator<dict_foreign_t*>,std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::_Link_type = std::_Rb_tree_node<dict_foreign_t*>*]" -> "_Alloc>::_S_right(std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::_Base_ptr) [with _Key = dict_foreign_t*,_Val = dict_foreign_t*,_KeyOfValue = std::_Identity<dict_foreign_t*>,_Compare = dict_foreign_compare,_Alloc = std::allocator<dict_foreign_t*>,std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::_Link_type = std::_Rb_tree_node<dict_foreign_t*>*,std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::_Base_ptr = std::_Rb_tree_node_base*]"
"dict_foreign_compare::operator()(const dict_foreign_t*,const dict_foreign_t*) const" -> "ut_strcmp(const char*,const char*)"
"ut_strcmp(const char*,const char*)" -> "strcmp(const char*,const char*)"
"_Alloc>::_S_key(std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::_Const_Link_type) [with _Key = dict_foreign_t*,_Val = dict_foreign_t*,_KeyOfValue = std::_Identity<dict_foreign_t*>,_Compare = dict_foreign_compare,_Alloc = std::allocator<dict_foreign_t*>,std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::_Const_Link_type = const std::_Rb_tree_node<dict_foreign_t*>*]" -> "_Alloc>::_S_value(std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::_Const_Link_type) [with _Key = dict_foreign_t*,_Val = dict_foreign_t*,_KeyOfValue = std::_Identity<dict_foreign_t*>,_Compare = dict_foreign_compare,_Alloc = std::allocator<dict_foreign_t*>,std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::const_reference = dict_foreign_t* const&,std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::value_type = dict_foreign_t*,std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::_Const_Link_type = const std::_Rb_tree_node<dict_foreign_t*>*]"
"_Alloc>::_S_key(std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::_Const_Link_type) [with _Key = dict_foreign_t*,_Val = dict_foreign_t*,_KeyOfValue = std::_Identity<dict_foreign_t*>,_Compare = dict_foreign_compare,_Alloc = std::allocator<dict_foreign_t*>,std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::_Const_Link_type = const std::_Rb_tree_node<dict_foreign_t*>*]" -> "std::_Identity<_Tp>::operator()(const _Tp&) const [with _Tp = dict_foreign_t*]"
"_Alloc>::_M_upper_bound(std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::_Link_type,std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::_Link_type,const _Key&) [with _Key = dict_foreign_t*,_Val = dict_foreign_t*,_KeyOfValue = std::_Identity<dict_foreign_t*>,_Compare = dict_foreign_compare,_Alloc = std::allocator<dict_foreign_t*>,std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::iterator = std::_Rb_tree_iterator<dict_foreign_t*>,std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::_Link_type = std::_Rb_tree_node<dict_foreign_t*>*]" -> "dict_foreign_compare::operator()(const dict_foreign_t*,const dict_foreign_t*) const"
"_Alloc>::_M_upper_bound(std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::_Link_type,std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::_Link_type,const _Key&) [with _Key = dict_foreign_t*,_Val = dict_foreign_t*,_KeyOfValue = std::_Identity<dict_foreign_t*>,_Compare = dict_foreign_compare,_Alloc = std::allocator<dict_foreign_t*>,std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::iterator = std::_Rb_tree_iterator<dict_foreign_t*>,std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::_Link_type = std::_Rb_tree_node<dict_foreign_t*>*]" -> "_Alloc>::_S_right(std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::_Base_ptr) [with _Key = dict_foreign_t*,_Val = dict_foreign_t*,_KeyOfValue = std::_Identity<dict_foreign_t*>,_Compare = dict_foreign_compare,_Alloc = std::allocator<dict_foreign_t*>,std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::_Link_type = std::_Rb_tree_node<dict_foreign_t*>*,std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::_Base_ptr = std::_Rb_tree_node_base*]"
"_Alloc>::_M_upper_bound(std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::_Link_type,std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::_Link_type,const _Key&) [with _Key = dict_foreign_t*,_Val = dict_foreign_t*,_KeyOfValue = std::_Identity<dict_foreign_t*>,_Compare = dict_foreign_compare,_Alloc = std::allocator<dict_foreign_t*>,std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::iterator = std::_Rb_tree_iterator<dict_foreign_t*>,std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::_Link_type = std::_Rb_tree_node<dict_foreign_t*>*]" -> "std::_Rb_tree_iterator<_Tp>::_Rb_tree_iterator(std::_Rb_tree_iterator<_Tp>::_Link_type) [with _Tp = dict_foreign_t*,std::_Rb_tree_iterator<_Tp>::_Link_type = std::_Rb_tree_node<dict_foreign_t*>*]"
"_Alloc>::_M_upper_bound(std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::_Link_type,std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::_Link_type,const _Key&) [with _Key = dict_foreign_t*,_Val = dict_foreign_t*,_KeyOfValue = std::_Identity<dict_foreign_t*>,_Compare = dict_foreign_compare,_Alloc = std::allocator<dict_foreign_t*>,std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::iterator = std::_Rb_tree_iterator<dict_foreign_t*>,std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::_Link_type = std::_Rb_tree_node<dict_foreign_t*>*]" -> "_Alloc>::_S_key(std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::_Const_Link_type) [with _Key = dict_foreign_t*,_Val = dict_foreign_t*,_KeyOfValue = std::_Identity<dict_foreign_t*>,_Compare = dict_foreign_compare,_Alloc = std::allocator<dict_foreign_t*>,std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::_Const_Link_type = const std::_Rb_tree_node<dict_foreign_t*>*]"
"_Alloc>::_M_upper_bound(std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::_Link_type,std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::_Link_type,const _Key&) [with _Key = dict_foreign_t*,_Val = dict_foreign_t*,_KeyOfValue = std::_Identity<dict_foreign_t*>,_Compare = dict_foreign_compare,_Alloc = std::allocator<dict_foreign_t*>,std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::iterator = std::_Rb_tree_iterator<dict_foreign_t*>,std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::_Link_type = std::_Rb_tree_node<dict_foreign_t*>*]" -> "_Alloc>::_S_left(std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::_Base_ptr) [with _Key = dict_foreign_t*,_Val = dict_foreign_t*,_KeyOfValue = std::_Identity<dict_foreign_t*>,_Compare = dict_foreign_compare,_Alloc = std::allocator<dict_foreign_t*>,std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::_Link_type = std::_Rb_tree_node<dict_foreign_t*>*,std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::_Base_ptr = std::_Rb_tree_node_base*]"
"_Alloc>::erase(std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::iterator,std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::iterator) [with _Key = dict_foreign_t*,_Val = dict_foreign_t*,_KeyOfValue = std::_Identity<dict_foreign_t*>,_Compare = dict_foreign_compare,_Alloc = std::allocator<dict_foreign_t*>,std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::iterator = std::_Rb_tree_iterator<dict_foreign_t*>]" -> "std::_Rb_tree_const_iterator<_Tp>::_Rb_tree_const_iterator(const iterator&) [with _Tp = dict_foreign_t*,std::_Rb_tree_const_iterator<_Tp>::iterator = std::_Rb_tree_iterator<dict_foreign_t*>]"
"_Alloc>::erase(std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::iterator,std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::iterator) [with _Key = dict_foreign_t*,_Val = dict_foreign_t*,_KeyOfValue = std::_Identity<dict_foreign_t*>,_Compare = dict_foreign_compare,_Alloc = std::allocator<dict_foreign_t*>,std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::iterator = std::_Rb_tree_iterator<dict_foreign_t*>]" -> "_Alloc>::_M_erase_aux(std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::const_iterator,std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::const_iterator) [with _Key = dict_foreign_t*,_Val = dict_foreign_t*,_KeyOfValue = std::_Identity<dict_foreign_t*>,_Compare = dict_foreign_compare,_Alloc = std::allocator<dict_foreign_t*>,std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::const_iterator = std::_Rb_tree_const_iterator<dict_foreign_t*>]"
"_Alloc>::_M_erase_aux(std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::const_iterator,std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::const_iterator) [with _Key = dict_foreign_t*,_Val = dict_foreign_t*,_KeyOfValue = std::_Identity<dict_foreign_t*>,_Compare = dict_foreign_compare,_Alloc = std::allocator<dict_foreign_t*>,std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::const_iterator = std::_Rb_tree_const_iterator<dict_foreign_t*>]" -> "_Alloc>::erase(std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::const_iterator) [with _Key = dict_foreign_t*,_Val = dict_foreign_t*,_KeyOfValue = std::_Identity<dict_foreign_t*>,_Compare = dict_foreign_compare,_Alloc = std::allocator<dict_foreign_t*>,std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::const_iterator = std::_Rb_tree_const_iterator<dict_foreign_t*>]"
"_Alloc>::_M_erase_aux(std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::const_iterator,std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::const_iterator) [with _Key = dict_foreign_t*,_Val = dict_foreign_t*,_KeyOfValue = std::_Identity<dict_foreign_t*>,_Compare = dict_foreign_compare,_Alloc = std::allocator<dict_foreign_t*>,std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::const_iterator = std::_Rb_tree_const_iterator<dict_foreign_t*>]" -> "std::_Rb_tree_const_iterator<_Tp>::operator!=(const _Self&) const [with _Tp = dict_foreign_t*,std::_Rb_tree_const_iterator<_Tp>::_Self = std::_Rb_tree_const_iterator<dict_foreign_t*>]"
"_Alloc>::_M_erase_aux(std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::const_iterator,std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::const_iterator) [with _Key = dict_foreign_t*,_Val = dict_foreign_t*,_KeyOfValue = std::_Identity<dict_foreign_t*>,_Compare = dict_foreign_compare,_Alloc = std::allocator<dict_foreign_t*>,std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::const_iterator = std::_Rb_tree_const_iterator<dict_foreign_t*>]" -> "_Alloc>::end() [with _Key = dict_foreign_t*,_Val = dict_foreign_t*,_KeyOfValue = std::_Identity<dict_foreign_t*>,_Compare = dict_foreign_compare,_Alloc = std::allocator<dict_foreign_t*>,std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::iterator = std::_Rb_tree_iterator<dict_foreign_t*>]"
"_Alloc>::_M_erase_aux(std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::const_iterator,std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::const_iterator) [with _Key = dict_foreign_t*,_Val = dict_foreign_t*,_KeyOfValue = std::_Identity<dict_foreign_t*>,_Compare = dict_foreign_compare,_Alloc = std::allocator<dict_foreign_t*>,std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::const_iterator = std::_Rb_tree_const_iterator<dict_foreign_t*>]" -> "std::_Rb_tree_const_iterator<_Tp>::operator++(int) [with _Tp = dict_foreign_t*,std::_Rb_tree_const_iterator<_Tp>::_Self = std::_Rb_tree_const_iterator<dict_foreign_t*>]"
"_Alloc>::_M_erase_aux(std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::const_iterator,std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::const_iterator) [with _Key = dict_foreign_t*,_Val = dict_foreign_t*,_KeyOfValue = std::_Identity<dict_foreign_t*>,_Compare = dict_foreign_compare,_Alloc = std::allocator<dict_foreign_t*>,std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::const_iterator = std::_Rb_tree_const_iterator<dict_foreign_t*>]" -> "std::_Rb_tree_const_iterator<_Tp>::operator==(const _Self&) const [with _Tp = dict_foreign_t*,std::_Rb_tree_const_iterator<_Tp>::_Self = std::_Rb_tree_const_iterator<dict_foreign_t*>]"
"_Alloc>::_M_erase_aux(std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::const_iterator,std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::const_iterator) [with _Key = dict_foreign_t*,_Val = dict_foreign_t*,_KeyOfValue = std::_Identity<dict_foreign_t*>,_Compare = dict_foreign_compare,_Alloc = std::allocator<dict_foreign_t*>,std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::const_iterator = std::_Rb_tree_const_iterator<dict_foreign_t*>]" -> "std::_Rb_tree_const_iterator<_Tp>::_Rb_tree_const_iterator(const iterator&) [with _Tp = dict_foreign_t*,std::_Rb_tree_const_iterator<_Tp>::iterator = std::_Rb_tree_iterator<dict_foreign_t*>]"
"_Alloc>::_M_erase_aux(std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::const_iterator,std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::const_iterator) [with _Key = dict_foreign_t*,_Val = dict_foreign_t*,_KeyOfValue = std::_Identity<dict_foreign_t*>,_Compare = dict_foreign_compare,_Alloc = std::allocator<dict_foreign_t*>,std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::const_iterator = std::_Rb_tree_const_iterator<dict_foreign_t*>]" -> "_Alloc>::begin() [with _Key = dict_foreign_t*,_Val = dict_foreign_t*,_KeyOfValue = std::_Identity<dict_foreign_t*>,_Compare = dict_foreign_compare,_Alloc = std::allocator<dict_foreign_t*>,std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::iterator = std::_Rb_tree_iterator<dict_foreign_t*>]"
"_Alloc>::_M_erase_aux(std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::const_iterator,std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::const_iterator) [with _Key = dict_foreign_t*,_Val = dict_foreign_t*,_KeyOfValue = std::_Identity<dict_foreign_t*>,_Compare = dict_foreign_compare,_Alloc = std::allocator<dict_foreign_t*>,std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::const_iterator = std::_Rb_tree_const_iterator<dict_foreign_t*>]" -> "_Alloc>::clear() [with _Key = dict_foreign_t*,_Val = dict_foreign_t*,_KeyOfValue = std::_Identity<dict_foreign_t*>,_Compare = dict_foreign_compare,_Alloc = std::allocator<dict_foreign_t*>]"
"_Alloc>::erase(std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::const_iterator) [with _Key = dict_foreign_t*,_Val = dict_foreign_t*,_KeyOfValue = std::_Identity<dict_foreign_t*>,_Compare = dict_foreign_compare,_Alloc = std::allocator<dict_foreign_t*>,std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::const_iterator = std::_Rb_tree_const_iterator<dict_foreign_t*>]" -> "_Alloc>::_M_erase_aux(std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::const_iterator) [with _Key = dict_foreign_t*,_Val = dict_foreign_t*,_KeyOfValue = std::_Identity<dict_foreign_t*>,_Compare = dict_foreign_compare,_Alloc = std::allocator<dict_foreign_t*>,std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::const_iterator = std::_Rb_tree_const_iterator<dict_foreign_t*>]"
"_Alloc>::_M_erase_aux(std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::const_iterator) [with _Key = dict_foreign_t*,_Val = dict_foreign_t*,_KeyOfValue = std::_Identity<dict_foreign_t*>,_Compare = dict_foreign_compare,_Alloc = std::allocator<dict_foreign_t*>,std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::const_iterator = std::_Rb_tree_const_iterator<dict_foreign_t*>]" -> "std::_Rb_tree_rebalance_for_erase(std::_Rb_tree_node_base*,std::_Rb_tree_node_base&)"
"_Alloc>::_M_erase_aux(std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::const_iterator) [with _Key = dict_foreign_t*,_Val = dict_foreign_t*,_KeyOfValue = std::_Identity<dict_foreign_t*>,_Compare = dict_foreign_compare,_Alloc = std::allocator<dict_foreign_t*>,std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::const_iterator = std::_Rb_tree_const_iterator<dict_foreign_t*>]" -> "_Alloc>::_M_destroy_node(std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::_Link_type) [with _Key = dict_foreign_t*,_Val = dict_foreign_t*,_KeyOfValue = std::_Identity<dict_foreign_t*>,_Compare = dict_foreign_compare,_Alloc = std::allocator<dict_foreign_t*>,std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::_Link_type = std::_Rb_tree_node<dict_foreign_t*>*]"
"_Alloc>::_M_destroy_node(std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::_Link_type) [with _Key = dict_foreign_t*,_Val = dict_foreign_t*,_KeyOfValue = std::_Identity<dict_foreign_t*>,_Compare = dict_foreign_compare,_Alloc = std::allocator<dict_foreign_t*>,std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::_Link_type = std::_Rb_tree_node<dict_foreign_t*>*]" -> "std::__addressof(_Tp&) [with _Tp = dict_foreign_t*]"
"_Alloc>::_M_destroy_node(std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::_Link_type) [with _Key = dict_foreign_t*,_Val = dict_foreign_t*,_KeyOfValue = std::_Identity<dict_foreign_t*>,_Compare = dict_foreign_compare,_Alloc = std::allocator<dict_foreign_t*>,std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::_Link_type = std::_Rb_tree_node<dict_foreign_t*>*]" -> "__gnu_cxx::new_allocator<_Tp>::destroy(__gnu_cxx::new_allocator<_Tp>::pointer) [with _Tp = dict_foreign_t*,__gnu_cxx::new_allocator<_Tp>::pointer = dict_foreign_t**]"
"_Alloc>::_M_destroy_node(std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::_Link_type) [with _Key = dict_foreign_t*,_Val = dict_foreign_t*,_KeyOfValue = std::_Identity<dict_foreign_t*>,_Compare = dict_foreign_compare,_Alloc = std::allocator<dict_foreign_t*>,std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::_Link_type = std::_Rb_tree_node<dict_foreign_t*>*]" -> "_Alloc>::_M_put_node(std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::_Link_type) [with _Key = dict_foreign_t*,_Val = dict_foreign_t*,_KeyOfValue = std::_Identity<dict_foreign_t*>,_Compare = dict_foreign_compare,_Alloc = std::allocator<dict_foreign_t*>,std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::_Link_type = std::_Rb_tree_node<dict_foreign_t*>*]"
"_Alloc>::_M_destroy_node(std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::_Link_type) [with _Key = dict_foreign_t*,_Val = dict_foreign_t*,_KeyOfValue = std::_Identity<dict_foreign_t*>,_Compare = dict_foreign_compare,_Alloc = std::allocator<dict_foreign_t*>,std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::_Link_type = std::_Rb_tree_node<dict_foreign_t*>*]" -> "_Alloc>::get_allocator() const [with _Key = dict_foreign_t*,_Val = dict_foreign_t*,_KeyOfValue = std::_Identity<dict_foreign_t*>,_Compare = dict_foreign_compare,_Alloc = std::allocator<dict_foreign_t*>,std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::allocator_type = std::allocator<dict_foreign_t*>]"
"_Alloc>::_M_put_node(std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::_Link_type) [with _Key = dict_foreign_t*,_Val = dict_foreign_t*,_KeyOfValue = std::_Identity<dict_foreign_t*>,_Compare = dict_foreign_compare,_Alloc = std::allocator<dict_foreign_t*>,std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::_Link_type = std::_Rb_tree_node<dict_foreign_t*>*]" -> "__gnu_cxx::new_allocator<_Tp>::deallocate(__gnu_cxx::new_allocator<_Tp>::pointer,__gnu_cxx::new_allocator<_Tp>::size_type) [with _Tp = std::_Rb_tree_node<dict_foreign_t*>,__gnu_cxx::new_allocator<_Tp>::pointer = std::_Rb_tree_node<dict_foreign_t*>*,__gnu_cxx::new_allocator<_Tp>::size_type = long unsigned int]"
"_Alloc>::get_allocator() const [with _Key = dict_foreign_t*,_Val = dict_foreign_t*,_KeyOfValue = std::_Identity<dict_foreign_t*>,_Compare = dict_foreign_compare,_Alloc = std::allocator<dict_foreign_t*>,std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::allocator_type = std::allocator<dict_foreign_t*>]" -> "std::allocator<_Tp>::allocator(const std::allocator<_Tp1>&) [with _Tp1 = std::_Rb_tree_node<dict_foreign_t*>,_Tp = dict_foreign_t*]"
"_Alloc>::get_allocator() const [with _Key = dict_foreign_t*,_Val = dict_foreign_t*,_KeyOfValue = std::_Identity<dict_foreign_t*>,_Compare = dict_foreign_compare,_Alloc = std::allocator<dict_foreign_t*>,std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::allocator_type = std::allocator<dict_foreign_t*>]" -> "_Alloc>::_M_get_Node_allocator() const [with _Key = dict_foreign_t*,_Val = dict_foreign_t*,_KeyOfValue = std::_Identity<dict_foreign_t*>,_Compare = dict_foreign_compare,_Alloc = std::allocator<dict_foreign_t*>,std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::_Node_allocator = std::allocator<std::_Rb_tree_node<dict_foreign_t*> >]"
"std::allocator<_Tp>::allocator(const std::allocator<_Tp1>&) [with _Tp1 = std::_Rb_tree_node<dict_foreign_t*>,_Tp = dict_foreign_t*]" -> "__gnu_cxx::new_allocator<_Tp>::new_allocator() [with _Tp = dict_foreign_t*]"
"_Alloc>::end() [with _Key = dict_foreign_t*,_Val = dict_foreign_t*,_KeyOfValue = std::_Identity<dict_foreign_t*>,_Compare = dict_foreign_compare,_Alloc = std::allocator<dict_foreign_t*>,std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::iterator = std::_Rb_tree_iterator<dict_foreign_t*>]" -> "std::_Rb_tree_iterator<_Tp>::_Rb_tree_iterator(std::_Rb_tree_iterator<_Tp>::_Link_type) [with _Tp = dict_foreign_t*,std::_Rb_tree_iterator<_Tp>::_Link_type = std::_Rb_tree_node<dict_foreign_t*>*]"
"std::_Rb_tree_const_iterator<_Tp>::operator++(int) [with _Tp = dict_foreign_t*,std::_Rb_tree_const_iterator<_Tp>::_Self = std::_Rb_tree_const_iterator<dict_foreign_t*>]" -> "std::_Rb_tree_increment(const std::_Rb_tree_node_base*)"
"_Alloc>::begin() [with _Key = dict_foreign_t*,_Val = dict_foreign_t*,_KeyOfValue = std::_Identity<dict_foreign_t*>,_Compare = dict_foreign_compare,_Alloc = std::allocator<dict_foreign_t*>,std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::iterator = std::_Rb_tree_iterator<dict_foreign_t*>]" -> "std::_Rb_tree_iterator<_Tp>::_Rb_tree_iterator(std::_Rb_tree_iterator<_Tp>::_Link_type) [with _Tp = dict_foreign_t*,std::_Rb_tree_iterator<_Tp>::_Link_type = std::_Rb_tree_node<dict_foreign_t*>*]"
"_Alloc>::clear() [with _Key = dict_foreign_t*,_Val = dict_foreign_t*,_KeyOfValue = std::_Identity<dict_foreign_t*>,_Compare = dict_foreign_compare,_Alloc = std::allocator<dict_foreign_t*>]" -> "_Alloc>::_M_erase(std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::_Link_type) [with _Key = dict_foreign_t*,_Val = dict_foreign_t*,_KeyOfValue = std::_Identity<dict_foreign_t*>,_Compare = dict_foreign_compare,_Alloc = std::allocator<dict_foreign_t*>,std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::_Link_type = std::_Rb_tree_node<dict_foreign_t*>*]"
"_Alloc>::clear() [with _Key = dict_foreign_t*,_Val = dict_foreign_t*,_KeyOfValue = std::_Identity<dict_foreign_t*>,_Compare = dict_foreign_compare,_Alloc = std::allocator<dict_foreign_t*>]" -> "_Alloc>::_M_leftmost() [with _Key = dict_foreign_t*,_Val = dict_foreign_t*,_KeyOfValue = std::_Identity<dict_foreign_t*>,_Compare = dict_foreign_compare,_Alloc = std::allocator<dict_foreign_t*>,std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::_Base_ptr = std::_Rb_tree_node_base*]"
"_Alloc>::clear() [with _Key = dict_foreign_t*,_Val = dict_foreign_t*,_KeyOfValue = std::_Identity<dict_foreign_t*>,_Compare = dict_foreign_compare,_Alloc = std::allocator<dict_foreign_t*>]" -> "_Alloc>::_M_rightmost() [with _Key = dict_foreign_t*,_Val = dict_foreign_t*,_KeyOfValue = std::_Identity<dict_foreign_t*>,_Compare = dict_foreign_compare,_Alloc = std::allocator<dict_foreign_t*>,std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::_Base_ptr = std::_Rb_tree_node_base*]"
"_Alloc>::clear() [with _Key = dict_foreign_t*,_Val = dict_foreign_t*,_KeyOfValue = std::_Identity<dict_foreign_t*>,_Compare = dict_foreign_compare,_Alloc = std::allocator<dict_foreign_t*>]" -> "_Alloc>::_M_root() [with _Key = dict_foreign_t*,_Val = dict_foreign_t*,_KeyOfValue = std::_Identity<dict_foreign_t*>,_Compare = dict_foreign_compare,_Alloc = std::allocator<dict_foreign_t*>,std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::_Base_ptr = std::_Rb_tree_node_base*]"
"_Alloc>::clear() [with _Key = dict_foreign_t*,_Val = dict_foreign_t*,_KeyOfValue = std::_Identity<dict_foreign_t*>,_Compare = dict_foreign_compare,_Alloc = std::allocator<dict_foreign_t*>]" -> "_Alloc>::_M_begin() [with _Key = dict_foreign_t*,_Val = dict_foreign_t*,_KeyOfValue = std::_Identity<dict_foreign_t*>,_Compare = dict_foreign_compare,_Alloc = std::allocator<dict_foreign_t*>,std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::_Link_type = std::_Rb_tree_node<dict_foreign_t*>*]"
"_Alloc>::clear() [with _Key = dict_foreign_t*,_Val = dict_foreign_t*,_KeyOfValue = std::_Identity<dict_foreign_t*>,_Compare = dict_foreign_compare,_Alloc = std::allocator<dict_foreign_t*>]" -> "_Alloc>::_M_end() [with _Key = dict_foreign_t*,_Val = dict_foreign_t*,_KeyOfValue = std::_Identity<dict_foreign_t*>,_Compare = dict_foreign_compare,_Alloc = std::allocator<dict_foreign_t*>,std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::_Link_type = std::_Rb_tree_node<dict_foreign_t*>*]"
"_Alloc>::_M_erase(std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::_Link_type) [with _Key = dict_foreign_t*,_Val = dict_foreign_t*,_KeyOfValue = std::_Identity<dict_foreign_t*>,_Compare = dict_foreign_compare,_Alloc = std::allocator<dict_foreign_t*>,std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::_Link_type = std::_Rb_tree_node<dict_foreign_t*>*]" -> "_Alloc>::_M_destroy_node(std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::_Link_type) [with _Key = dict_foreign_t*,_Val = dict_foreign_t*,_KeyOfValue = std::_Identity<dict_foreign_t*>,_Compare = dict_foreign_compare,_Alloc = std::allocator<dict_foreign_t*>,std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::_Link_type = std::_Rb_tree_node<dict_foreign_t*>*]"
"_Alloc>::_M_erase(std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::_Link_type) [with _Key = dict_foreign_t*,_Val = dict_foreign_t*,_KeyOfValue = std::_Identity<dict_foreign_t*>,_Compare = dict_foreign_compare,_Alloc = std::allocator<dict_foreign_t*>,std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::_Link_type = std::_Rb_tree_node<dict_foreign_t*>*]" -> "_Alloc>::_S_left(std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::_Base_ptr) [with _Key = dict_foreign_t*,_Val = dict_foreign_t*,_KeyOfValue = std::_Identity<dict_foreign_t*>,_Compare = dict_foreign_compare,_Alloc = std::allocator<dict_foreign_t*>,std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::_Link_type = std::_Rb_tree_node<dict_foreign_t*>*,std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::_Base_ptr = std::_Rb_tree_node_base*]"
"_Alloc>::_M_erase(std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::_Link_type) [with _Key = dict_foreign_t*,_Val = dict_foreign_t*,_KeyOfValue = std::_Identity<dict_foreign_t*>,_Compare = dict_foreign_compare,_Alloc = std::allocator<dict_foreign_t*>,std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::_Link_type = std::_Rb_tree_node<dict_foreign_t*>*]" -> "_Alloc>::_M_erase(std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::_Link_type) [with _Key = dict_foreign_t*,_Val = dict_foreign_t*,_KeyOfValue = std::_Identity<dict_foreign_t*>,_Compare = dict_foreign_compare,_Alloc = std::allocator<dict_foreign_t*>,std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::_Link_type = std::_Rb_tree_node<dict_foreign_t*>*]"
"_Alloc>::_M_erase(std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::_Link_type) [with _Key = dict_foreign_t*,_Val = dict_foreign_t*,_KeyOfValue = std::_Identity<dict_foreign_t*>,_Compare = dict_foreign_compare,_Alloc = std::allocator<dict_foreign_t*>,std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::_Link_type = std::_Rb_tree_node<dict_foreign_t*>*]" -> "_Alloc>::_S_right(std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::_Base_ptr) [with _Key = dict_foreign_t*,_Val = dict_foreign_t*,_KeyOfValue = std::_Identity<dict_foreign_t*>,_Compare = dict_foreign_compare,_Alloc = std::allocator<dict_foreign_t*>,std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::_Link_type = std::_Rb_tree_node<dict_foreign_t*>*,std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::_Base_ptr = std::_Rb_tree_node_base*]"
"dict_foreign_error_report(FILE*,dict_foreign_t*,const char*)" -> "pfs_mutex_enter_func(ib_mutex_t*,const char*,ulint)"
"dict_foreign_error_report(FILE*,dict_foreign_t*,const char*)" -> "dict_foreign_error_report_low(FILE*,const char*)"
"dict_foreign_error_report(FILE*,dict_foreign_t*,const char*)" -> "fputs(const char*,FILE*)"
"dict_foreign_error_report(FILE*,dict_foreign_t*,const char*)" -> "_IO_putc(int,_IO_FILE*)"
"dict_foreign_error_report(FILE*,dict_foreign_t*,const char*)" -> "pfs_mutex_exit_func(ib_mutex_t*)"
"dict_foreign_error_report(FILE*,dict_foreign_t*,const char*)" -> "dict_print_info_on_foreign_key_in_create_format(FILE*,trx_t*,dict_foreign_t*,ulint)"
"dict_foreign_error_report(FILE*,dict_foreign_t*,const char*)" -> "__builtin_fwrite(const void*,size_t,size_t,FILE*)"
"dict_foreign_error_report(FILE*,dict_foreign_t*,const char*)" -> "ut_print_name(FILE*,const trx_t*,ulint,const char*)"
"dict_foreign_error_report_low(FILE*,const char*)" -> "rewind(FILE*)"
"dict_foreign_error_report_low(FILE*,const char*)" -> "ut_print_timestamp(FILE*)"
"dict_foreign_error_report_low(FILE*,const char*)" -> "fprintf(FILE*,const char*,...)"
"dict_print_info_on_foreign_key_in_create_format(FILE*,trx_t*,dict_foreign_t*,ulint)" -> "__builtin_fwrite(const void*,size_t,size_t,FILE*)"
"dict_print_info_on_foreign_key_in_create_format(FILE*,trx_t*,dict_foreign_t*,ulint)" -> "dict_remove_db_name(const char*)"
"dict_print_info_on_foreign_key_in_create_format(FILE*,trx_t*,dict_foreign_t*,ulint)" -> "dict_get_db_name_len(const char*)"
"dict_print_info_on_foreign_key_in_create_format(FILE*,trx_t*,dict_foreign_t*,ulint)" -> "ut_print_name(FILE*,const trx_t*,ulint,const char*)"
"dict_print_info_on_foreign_key_in_create_format(FILE*,trx_t*,dict_foreign_t*,ulint)" -> "dict_tables_have_same_db(const char*,const char*)"
"dict_print_info_on_foreign_key_in_create_format(FILE*,trx_t*,dict_foreign_t*,ulint)" -> "strchr(char*,int)"
"dict_print_info_on_foreign_key_in_create_format(FILE*,trx_t*,dict_foreign_t*,ulint)" -> "_IO_putc(int,_IO_FILE*)"
"dict_remove_db_name(const char*)" -> "abort()"
"dict_remove_db_name(const char*)" -> "__builtin_expect(long int,long int)"
"dict_remove_db_name(const char*)" -> "ut_dbg_assertion_failed(const char*,const char*,ulint)"
"dict_remove_db_name(const char*)" -> "strchr(const char*,int)"
"dict_get_db_name_len(const char*)" -> "__builtin_expect(long int,long int)"
"dict_get_db_name_len(const char*)" -> "strchr(const char*,int)"
"dict_get_db_name_len(const char*)" -> "ut_dbg_assertion_failed(const char*,const char*,ulint)"
"dict_get_db_name_len(const char*)" -> "abort()"
"dict_tables_have_same_db(const char*,const char*)" -> "ut_dbg_assertion_failed(const char*,const char*,ulint)"
"dict_tables_have_same_db(const char*,const char*)" -> "abort()"
"dict_tables_have_same_db(const char*,const char*)" -> "__builtin_expect(long int,long int)"
"dict_table_move_from_lru_to_non_lru(dict_table_t*)" -> "__builtin_expect(long int,long int)"
"dict_table_move_from_lru_to_non_lru(dict_table_t*)" -> "ut_dbg_assertion_failed(const char*,const char*,ulint)"
"dict_table_move_from_lru_to_non_lru(dict_table_t*)" -> "abort()"
"dict_table_move_from_lru_to_non_lru(dict_table_t*)" -> "ut_list_append(List&,Type&,size_t) [with List = ut_list_base<dict_table_t>,Type = dict_table_t,size_t = long unsigned int]"
"dict_table_move_from_lru_to_non_lru(dict_table_t*)" -> "ut_list_remove(List&,Type&,size_t) [with List = ut_list_base<dict_table_t>,Type = dict_table_t,size_t = long unsigned int]"
"ut_list_append(List&,Type&,size_t) [with List = ut_list_base<dict_table_t>,Type = dict_table_t,size_t = long unsigned int]" -> "ut_elem_get_node(Type&,size_t) [with Type = dict_table_t,size_t = long unsigned int]"
"dict_foreign_find(dict_table_t*,dict_foreign_t*)" -> "std::_Rb_tree_const_iterator<_Tp>::operator*() const [with _Tp = dict_foreign_t*,std::_Rb_tree_const_iterator<_Tp>::reference = dict_foreign_t* const&]"
"dict_foreign_find(dict_table_t*,dict_foreign_t*)" -> "std::_Rb_tree_const_iterator<_Tp>::operator!=(const _Self&) const [with _Tp = dict_foreign_t*,std::_Rb_tree_const_iterator<_Tp>::_Self = std::_Rb_tree_const_iterator<dict_foreign_t*>]"
"dict_foreign_find(dict_table_t*,dict_foreign_t*)" -> "_Alloc>::find(const key_type&) [with _Key = dict_foreign_t*,_Compare = dict_foreign_compare,_Alloc = std::allocator<dict_foreign_t*>,std::set<_Key,_Compare,_Alloc>::iterator = std::_Rb_tree_const_iterator<dict_foreign_t*>,std::set<_Key,_Compare,_Alloc>::key_type = dict_foreign_t*]"
"dict_foreign_find(dict_table_t*,dict_foreign_t*)" -> "_Alloc>::end() const [with _Key = dict_foreign_t*,_Compare = dict_foreign_compare,_Alloc = std::allocator<dict_foreign_t*>,std::set<_Key,_Compare,_Alloc>::iterator = std::_Rb_tree_const_iterator<dict_foreign_t*>]"
"_Alloc>::find(const key_type&) [with _Key = dict_foreign_t*,_Compare = dict_foreign_compare,_Alloc = std::allocator<dict_foreign_t*>,std::set<_Key,_Compare,_Alloc>::iterator = std::_Rb_tree_const_iterator<dict_foreign_t*>,std::set<_Key,_Compare,_Alloc>::key_type = dict_foreign_t*]" -> "std::_Rb_tree_const_iterator<_Tp>::_Rb_tree_const_iterator(const iterator&) [with _Tp = dict_foreign_t*,std::_Rb_tree_const_iterator<_Tp>::iterator = std::_Rb_tree_iterator<dict_foreign_t*>]"
"_Alloc>::find(const key_type&) [with _Key = dict_foreign_t*,_Compare = dict_foreign_compare,_Alloc = std::allocator<dict_foreign_t*>,std::set<_Key,_Compare,_Alloc>::iterator = std::_Rb_tree_const_iterator<dict_foreign_t*>,std::set<_Key,_Compare,_Alloc>::key_type = dict_foreign_t*]" -> "_Alloc>::find(const _Key&) [with _Key = dict_foreign_t*,_Val = dict_foreign_t*,_KeyOfValue = std::_Identity<dict_foreign_t*>,_Compare = dict_foreign_compare,_Alloc = std::allocator<dict_foreign_t*>,std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::iterator = std::_Rb_tree_iterator<dict_foreign_t*>]"
"_Alloc>::find(const _Key&) [with _Key = dict_foreign_t*,_Val = dict_foreign_t*,_KeyOfValue = std::_Identity<dict_foreign_t*>,_Compare = dict_foreign_compare,_Alloc = std::allocator<dict_foreign_t*>,std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::iterator = std::_Rb_tree_iterator<dict_foreign_t*>]" -> "_Alloc>::_M_begin() [with _Key = dict_foreign_t*,_Val = dict_foreign_t*,_KeyOfValue = std::_Identity<dict_foreign_t*>,_Compare = dict_foreign_compare,_Alloc = std::allocator<dict_foreign_t*>,std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::_Link_type = std::_Rb_tree_node<dict_foreign_t*>*]"
"_Alloc>::find(const _Key&) [with _Key = dict_foreign_t*,_Val = dict_foreign_t*,_KeyOfValue = std::_Identity<dict_foreign_t*>,_Compare = dict_foreign_compare,_Alloc = std::allocator<dict_foreign_t*>,std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::iterator = std::_Rb_tree_iterator<dict_foreign_t*>]" -> "std::_Rb_tree_iterator<_Tp>::operator==(const _Self&) const [with _Tp = dict_foreign_t*,std::_Rb_tree_iterator<_Tp>::_Self = std::_Rb_tree_iterator<dict_foreign_t*>]"
"_Alloc>::find(const _Key&) [with _Key = dict_foreign_t*,_Val = dict_foreign_t*,_KeyOfValue = std::_Identity<dict_foreign_t*>,_Compare = dict_foreign_compare,_Alloc = std::allocator<dict_foreign_t*>,std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::iterator = std::_Rb_tree_iterator<dict_foreign_t*>]" -> "dict_foreign_compare::operator()(const dict_foreign_t*,const dict_foreign_t*) const"
"_Alloc>::find(const _Key&) [with _Key = dict_foreign_t*,_Val = dict_foreign_t*,_KeyOfValue = std::_Identity<dict_foreign_t*>,_Compare = dict_foreign_compare,_Alloc = std::allocator<dict_foreign_t*>,std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::iterator = std::_Rb_tree_iterator<dict_foreign_t*>]" -> "_Alloc>::_S_key(std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::_Const_Base_ptr) [with _Key = dict_foreign_t*,_Val = dict_foreign_t*,_KeyOfValue = std::_Identity<dict_foreign_t*>,_Compare = dict_foreign_compare,_Alloc = std::allocator<dict_foreign_t*>,std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::_Const_Base_ptr = const std::_Rb_tree_node_base*]"
"_Alloc>::find(const _Key&) [with _Key = dict_foreign_t*,_Val = dict_foreign_t*,_KeyOfValue = std::_Identity<dict_foreign_t*>,_Compare = dict_foreign_compare,_Alloc = std::allocator<dict_foreign_t*>,std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::iterator = std::_Rb_tree_iterator<dict_foreign_t*>]" -> "_Alloc>::end() [with _Key = dict_foreign_t*,_Val = dict_foreign_t*,_KeyOfValue = std::_Identity<dict_foreign_t*>,_Compare = dict_foreign_compare,_Alloc = std::allocator<dict_foreign_t*>,std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::iterator = std::_Rb_tree_iterator<dict_foreign_t*>]"
"_Alloc>::find(const _Key&) [with _Key = dict_foreign_t*,_Val = dict_foreign_t*,_KeyOfValue = std::_Identity<dict_foreign_t*>,_Compare = dict_foreign_compare,_Alloc = std::allocator<dict_foreign_t*>,std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::iterator = std::_Rb_tree_iterator<dict_foreign_t*>]" -> "_Alloc>::_M_end() [with _Key = dict_foreign_t*,_Val = dict_foreign_t*,_KeyOfValue = std::_Identity<dict_foreign_t*>,_Compare = dict_foreign_compare,_Alloc = std::allocator<dict_foreign_t*>,std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::_Link_type = std::_Rb_tree_node<dict_foreign_t*>*]"
"_Alloc>::find(const _Key&) [with _Key = dict_foreign_t*,_Val = dict_foreign_t*,_KeyOfValue = std::_Identity<dict_foreign_t*>,_Compare = dict_foreign_compare,_Alloc = std::allocator<dict_foreign_t*>,std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::iterator = std::_Rb_tree_iterator<dict_foreign_t*>]" -> "_Alloc>::_M_lower_bound(std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::_Link_type,std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::_Link_type,const _Key&) [with _Key = dict_foreign_t*,_Val = dict_foreign_t*,_KeyOfValue = std::_Identity<dict_foreign_t*>,_Compare = dict_foreign_compare,_Alloc = std::allocator<dict_foreign_t*>,std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::iterator = std::_Rb_tree_iterator<dict_foreign_t*>,std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::_Link_type = std::_Rb_tree_node<dict_foreign_t*>*]"
"_Alloc>::_S_key(std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::_Const_Base_ptr) [with _Key = dict_foreign_t*,_Val = dict_foreign_t*,_KeyOfValue = std::_Identity<dict_foreign_t*>,_Compare = dict_foreign_compare,_Alloc = std::allocator<dict_foreign_t*>,std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::_Const_Base_ptr = const std::_Rb_tree_node_base*]" -> "std::_Identity<_Tp>::operator()(const _Tp&) const [with _Tp = dict_foreign_t*]"
"_Alloc>::_S_key(std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::_Const_Base_ptr) [with _Key = dict_foreign_t*,_Val = dict_foreign_t*,_KeyOfValue = std::_Identity<dict_foreign_t*>,_Compare = dict_foreign_compare,_Alloc = std::allocator<dict_foreign_t*>,std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::_Const_Base_ptr = const std::_Rb_tree_node_base*]" -> "_Alloc>::_S_value(std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::_Const_Base_ptr) [with _Key = dict_foreign_t*,_Val = dict_foreign_t*,_KeyOfValue = std::_Identity<dict_foreign_t*>,_Compare = dict_foreign_compare,_Alloc = std::allocator<dict_foreign_t*>,std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::const_reference = dict_foreign_t* const&,std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::value_type = dict_foreign_t*,std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::_Const_Base_ptr = const std::_Rb_tree_node_base*]"
"_Alloc>::end() const [with _Key = dict_foreign_t*,_Compare = dict_foreign_compare,_Alloc = std::allocator<dict_foreign_t*>,std::set<_Key,_Compare,_Alloc>::iterator = std::_Rb_tree_const_iterator<dict_foreign_t*>]" -> "_Alloc>::end() const [with _Key = dict_foreign_t*,_Val = dict_foreign_t*,_KeyOfValue = std::_Identity<dict_foreign_t*>,_Compare = dict_foreign_compare,_Alloc = std::allocator<dict_foreign_t*>,std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::const_iterator = std::_Rb_tree_const_iterator<dict_foreign_t*>]"
"_Alloc>::end() const [with _Key = dict_foreign_t*,_Val = dict_foreign_t*,_KeyOfValue = std::_Identity<dict_foreign_t*>,_Compare = dict_foreign_compare,_Alloc = std::allocator<dict_foreign_t*>,std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::const_iterator = std::_Rb_tree_const_iterator<dict_foreign_t*>]" -> "std::_Rb_tree_const_iterator<_Tp>::_Rb_tree_const_iterator(std::_Rb_tree_const_iterator<_Tp>::_Link_type) [with _Tp = dict_foreign_t*,std::_Rb_tree_const_iterator<_Tp>::_Link_type = const std::_Rb_tree_node<dict_foreign_t*>*]"
"_Alloc>::insert(const value_type&) [with _Key = dict_foreign_t*,_Compare = dict_foreign_compare,_Alloc = std::allocator<dict_foreign_t*>,typename std::_Rb_tree<_Key,_Key,std::_Identity<_Key>,_Compare,typename _Alloc::rebind<_Key>::other>::const_iterator = std::_Rb_tree_const_iterator<dict_foreign_t*>,std::set<_Key,_Compare,_Alloc>::value_type = dict_foreign_t*]" -> "_T2>::pair(const _T1&,const _T2&) [with _T1 = std::_Rb_tree_const_iterator<dict_foreign_t*>,_T2 = bool]"
"_Alloc>::insert(const value_type&) [with _Key = dict_foreign_t*,_Compare = dict_foreign_compare,_Alloc = std::allocator<dict_foreign_t*>,typename std::_Rb_tree<_Key,_Key,std::_Identity<_Key>,_Compare,typename _Alloc::rebind<_Key>::other>::const_iterator = std::_Rb_tree_const_iterator<dict_foreign_t*>,std::set<_Key,_Compare,_Alloc>::value_type = dict_foreign_t*]" -> "std::_Rb_tree_const_iterator<_Tp>::_Rb_tree_const_iterator(const iterator&) [with _Tp = dict_foreign_t*,std::_Rb_tree_const_iterator<_Tp>::iterator = std::_Rb_tree_iterator<dict_foreign_t*>]"
"_Alloc>::insert(const value_type&) [with _Key = dict_foreign_t*,_Compare = dict_foreign_compare,_Alloc = std::allocator<dict_foreign_t*>,typename std::_Rb_tree<_Key,_Key,std::_Identity<_Key>,_Compare,typename _Alloc::rebind<_Key>::other>::const_iterator = std::_Rb_tree_const_iterator<dict_foreign_t*>,std::set<_Key,_Compare,_Alloc>::value_type = dict_foreign_t*]" -> "_Alloc>::_M_insert_unique(const _Val&) [with _Key = dict_foreign_t*,_Val = dict_foreign_t*,_KeyOfValue = std::_Identity<dict_foreign_t*>,_Compare = dict_foreign_compare,_Alloc = std::allocator<dict_foreign_t*>]"
"_Alloc>::_M_insert_unique(const _Val&) [with _Key = dict_foreign_t*,_Val = dict_foreign_t*,_KeyOfValue = std::_Identity<dict_foreign_t*>,_Compare = dict_foreign_compare,_Alloc = std::allocator<dict_foreign_t*>]" -> "_Alloc>::_M_insert_(std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::_Const_Base_ptr,std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::_Const_Base_ptr,const _Val&) [with _Key = dict_foreign_t*,_Val = dict_foreign_t*,_KeyOfValue = std::_Identity<dict_foreign_t*>,_Compare = dict_foreign_compare,_Alloc = std::allocator<dict_foreign_t*>,std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::iterator = std::_Rb_tree_iterator<dict_foreign_t*>,std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::_Const_Base_ptr = const std::_Rb_tree_node_base*]"
"_Alloc>::_M_insert_unique(const _Val&) [with _Key = dict_foreign_t*,_Val = dict_foreign_t*,_KeyOfValue = std::_Identity<dict_foreign_t*>,_Compare = dict_foreign_compare,_Alloc = std::allocator<dict_foreign_t*>]" -> "_Alloc>::_S_right(std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::_Base_ptr) [with _Key = dict_foreign_t*,_Val = dict_foreign_t*,_KeyOfValue = std::_Identity<dict_foreign_t*>,_Compare = dict_foreign_compare,_Alloc = std::allocator<dict_foreign_t*>,std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::_Link_type = std::_Rb_tree_node<dict_foreign_t*>*,std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::_Base_ptr = std::_Rb_tree_node_base*]"
"_Alloc>::_M_insert_unique(const _Val&) [with _Key = dict_foreign_t*,_Val = dict_foreign_t*,_KeyOfValue = std::_Identity<dict_foreign_t*>,_Compare = dict_foreign_compare,_Alloc = std::allocator<dict_foreign_t*>]" -> "_Alloc>::_M_end() [with _Key = dict_foreign_t*,_Val = dict_foreign_t*,_KeyOfValue = std::_Identity<dict_foreign_t*>,_Compare = dict_foreign_compare,_Alloc = std::allocator<dict_foreign_t*>,std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::_Link_type = std::_Rb_tree_node<dict_foreign_t*>*]"
"_Alloc>::_M_insert_unique(const _Val&) [with _Key = dict_foreign_t*,_Val = dict_foreign_t*,_KeyOfValue = std::_Identity<dict_foreign_t*>,_Compare = dict_foreign_compare,_Alloc = std::allocator<dict_foreign_t*>]" -> "_Alloc>::_S_key(std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::_Const_Base_ptr) [with _Key = dict_foreign_t*,_Val = dict_foreign_t*,_KeyOfValue = std::_Identity<dict_foreign_t*>,_Compare = dict_foreign_compare,_Alloc = std::allocator<dict_foreign_t*>,std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::_Const_Base_ptr = const std::_Rb_tree_node_base*]"
"_Alloc>::_M_insert_unique(const _Val&) [with _Key = dict_foreign_t*,_Val = dict_foreign_t*,_KeyOfValue = std::_Identity<dict_foreign_t*>,_Compare = dict_foreign_compare,_Alloc = std::allocator<dict_foreign_t*>]" -> "std::_Rb_tree_iterator<_Tp>::operator--() [with _Tp = dict_foreign_t*,std::_Rb_tree_iterator<_Tp>::_Self = std::_Rb_tree_iterator<dict_foreign_t*>]"
"_Alloc>::_M_insert_unique(const _Val&) [with _Key = dict_foreign_t*,_Val = dict_foreign_t*,_KeyOfValue = std::_Identity<dict_foreign_t*>,_Compare = dict_foreign_compare,_Alloc = std::allocator<dict_foreign_t*>]" -> "std::_Rb_tree_iterator<_Tp>::operator==(const _Self&) const [with _Tp = dict_foreign_t*,std::_Rb_tree_iterator<_Tp>::_Self = std::_Rb_tree_iterator<dict_foreign_t*>]"
"_Alloc>::_M_insert_unique(const _Val&) [with _Key = dict_foreign_t*,_Val = dict_foreign_t*,_KeyOfValue = std::_Identity<dict_foreign_t*>,_Compare = dict_foreign_compare,_Alloc = std::allocator<dict_foreign_t*>]" -> "dict_foreign_compare::operator()(const dict_foreign_t*,const dict_foreign_t*) const"
"_Alloc>::_M_insert_unique(const _Val&) [with _Key = dict_foreign_t*,_Val = dict_foreign_t*,_KeyOfValue = std::_Identity<dict_foreign_t*>,_Compare = dict_foreign_compare,_Alloc = std::allocator<dict_foreign_t*>]" -> "_Alloc>::begin() [with _Key = dict_foreign_t*,_Val = dict_foreign_t*,_KeyOfValue = std::_Identity<dict_foreign_t*>,_Compare = dict_foreign_compare,_Alloc = std::allocator<dict_foreign_t*>,std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::iterator = std::_Rb_tree_iterator<dict_foreign_t*>]"
"_Alloc>::_M_insert_unique(const _Val&) [with _Key = dict_foreign_t*,_Val = dict_foreign_t*,_KeyOfValue = std::_Identity<dict_foreign_t*>,_Compare = dict_foreign_compare,_Alloc = std::allocator<dict_foreign_t*>]" -> "_Alloc>::_S_left(std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::_Base_ptr) [with _Key = dict_foreign_t*,_Val = dict_foreign_t*,_KeyOfValue = std::_Identity<dict_foreign_t*>,_Compare = dict_foreign_compare,_Alloc = std::allocator<dict_foreign_t*>,std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::_Link_type = std::_Rb_tree_node<dict_foreign_t*>*,std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::_Base_ptr = std::_Rb_tree_node_base*]"
"_Alloc>::_M_insert_unique(const _Val&) [with _Key = dict_foreign_t*,_Val = dict_foreign_t*,_KeyOfValue = std::_Identity<dict_foreign_t*>,_Compare = dict_foreign_compare,_Alloc = std::allocator<dict_foreign_t*>]" -> "_T2>::pair(const _T1&,const _T2&) [with _T1 = std::_Rb_tree_iterator<dict_foreign_t*>,_T2 = bool]"
"_Alloc>::_M_insert_unique(const _Val&) [with _Key = dict_foreign_t*,_Val = dict_foreign_t*,_KeyOfValue = std::_Identity<dict_foreign_t*>,_Compare = dict_foreign_compare,_Alloc = std::allocator<dict_foreign_t*>]" -> "_Alloc>::_S_key(std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::_Const_Link_type) [with _Key = dict_foreign_t*,_Val = dict_foreign_t*,_KeyOfValue = std::_Identity<dict_foreign_t*>,_Compare = dict_foreign_compare,_Alloc = std::allocator<dict_foreign_t*>,std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::_Const_Link_type = const std::_Rb_tree_node<dict_foreign_t*>*]"
"_Alloc>::_M_insert_unique(const _Val&) [with _Key = dict_foreign_t*,_Val = dict_foreign_t*,_KeyOfValue = std::_Identity<dict_foreign_t*>,_Compare = dict_foreign_compare,_Alloc = std::allocator<dict_foreign_t*>]" -> "std::_Identity<_Tp>::operator()(const _Tp&) const [with _Tp = dict_foreign_t*]"
"_Alloc>::_M_insert_unique(const _Val&) [with _Key = dict_foreign_t*,_Val = dict_foreign_t*,_KeyOfValue = std::_Identity<dict_foreign_t*>,_Compare = dict_foreign_compare,_Alloc = std::allocator<dict_foreign_t*>]" -> "std::_Rb_tree_iterator<_Tp>::_Rb_tree_iterator(std::_Rb_tree_iterator<_Tp>::_Link_type) [with _Tp = dict_foreign_t*,std::_Rb_tree_iterator<_Tp>::_Link_type = std::_Rb_tree_node<dict_foreign_t*>*]"
"_Alloc>::_M_insert_unique(const _Val&) [with _Key = dict_foreign_t*,_Val = dict_foreign_t*,_KeyOfValue = std::_Identity<dict_foreign_t*>,_Compare = dict_foreign_compare,_Alloc = std::allocator<dict_foreign_t*>]" -> "_Alloc>::_M_begin() [with _Key = dict_foreign_t*,_Val = dict_foreign_t*,_KeyOfValue = std::_Identity<dict_foreign_t*>,_Compare = dict_foreign_compare,_Alloc = std::allocator<dict_foreign_t*>,std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::_Link_type = std::_Rb_tree_node<dict_foreign_t*>*]"
"_Alloc>::_M_insert_(std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::_Const_Base_ptr,std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::_Const_Base_ptr,const _Val&) [with _Key = dict_foreign_t*,_Val = dict_foreign_t*,_KeyOfValue = std::_Identity<dict_foreign_t*>,_Compare = dict_foreign_compare,_Alloc = std::allocator<dict_foreign_t*>,std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::iterator = std::_Rb_tree_iterator<dict_foreign_t*>,std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::_Const_Base_ptr = const std::_Rb_tree_node_base*]" -> "std::_Rb_tree_insert_and_rebalance(bool,std::_Rb_tree_node_base*,std::_Rb_tree_node_base*,std::_Rb_tree_node_base&)"
"_Alloc>::_M_insert_(std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::_Const_Base_ptr,std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::_Const_Base_ptr,const _Val&) [with _Key = dict_foreign_t*,_Val = dict_foreign_t*,_KeyOfValue = std::_Identity<dict_foreign_t*>,_Compare = dict_foreign_compare,_Alloc = std::allocator<dict_foreign_t*>,std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::iterator = std::_Rb_tree_iterator<dict_foreign_t*>,std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::_Const_Base_ptr = const std::_Rb_tree_node_base*]" -> "std::_Identity<_Tp>::operator()(const _Tp&) const [with _Tp = dict_foreign_t*]"
"_Alloc>::_M_insert_(std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::_Const_Base_ptr,std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::_Const_Base_ptr,const _Val&) [with _Key = dict_foreign_t*,_Val = dict_foreign_t*,_KeyOfValue = std::_Identity<dict_foreign_t*>,_Compare = dict_foreign_compare,_Alloc = std::allocator<dict_foreign_t*>,std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::iterator = std::_Rb_tree_iterator<dict_foreign_t*>,std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::_Const_Base_ptr = const std::_Rb_tree_node_base*]" -> "_Alloc>::_M_end() [with _Key = dict_foreign_t*,_Val = dict_foreign_t*,_KeyOfValue = std::_Identity<dict_foreign_t*>,_Compare = dict_foreign_compare,_Alloc = std::allocator<dict_foreign_t*>,std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::_Link_type = std::_Rb_tree_node<dict_foreign_t*>*]"
"_Alloc>::_M_insert_(std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::_Const_Base_ptr,std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::_Const_Base_ptr,const _Val&) [with _Key = dict_foreign_t*,_Val = dict_foreign_t*,_KeyOfValue = std::_Identity<dict_foreign_t*>,_Compare = dict_foreign_compare,_Alloc = std::allocator<dict_foreign_t*>,std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::iterator = std::_Rb_tree_iterator<dict_foreign_t*>,std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::_Const_Base_ptr = const std::_Rb_tree_node_base*]" -> "std::_Rb_tree_iterator<_Tp>::_Rb_tree_iterator(std::_Rb_tree_iterator<_Tp>::_Link_type) [with _Tp = dict_foreign_t*,std::_Rb_tree_iterator<_Tp>::_Link_type = std::_Rb_tree_node<dict_foreign_t*>*]"
"_Alloc>::_M_insert_(std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::_Const_Base_ptr,std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::_Const_Base_ptr,const _Val&) [with _Key = dict_foreign_t*,_Val = dict_foreign_t*,_KeyOfValue = std::_Identity<dict_foreign_t*>,_Compare = dict_foreign_compare,_Alloc = std::allocator<dict_foreign_t*>,std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::iterator = std::_Rb_tree_iterator<dict_foreign_t*>,std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::_Const_Base_ptr = const std::_Rb_tree_node_base*]" -> "_Alloc>::_M_create_node(const value_type&) [with _Key = dict_foreign_t*,_Val = dict_foreign_t*,_KeyOfValue = std::_Identity<dict_foreign_t*>,_Compare = dict_foreign_compare,_Alloc = std::allocator<dict_foreign_t*>,std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::_Link_type = std::_Rb_tree_node<dict_foreign_t*>*,std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::value_type = dict_foreign_t*]"
"_Alloc>::_M_insert_(std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::_Const_Base_ptr,std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::_Const_Base_ptr,const _Val&) [with _Key = dict_foreign_t*,_Val = dict_foreign_t*,_KeyOfValue = std::_Identity<dict_foreign_t*>,_Compare = dict_foreign_compare,_Alloc = std::allocator<dict_foreign_t*>,std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::iterator = std::_Rb_tree_iterator<dict_foreign_t*>,std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::_Const_Base_ptr = const std::_Rb_tree_node_base*]" -> "_Alloc>::_S_key(std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::_Const_Base_ptr) [with _Key = dict_foreign_t*,_Val = dict_foreign_t*,_KeyOfValue = std::_Identity<dict_foreign_t*>,_Compare = dict_foreign_compare,_Alloc = std::allocator<dict_foreign_t*>,std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::_Const_Base_ptr = const std::_Rb_tree_node_base*]"
"_Alloc>::_M_insert_(std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::_Const_Base_ptr,std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::_Const_Base_ptr,const _Val&) [with _Key = dict_foreign_t*,_Val = dict_foreign_t*,_KeyOfValue = std::_Identity<dict_foreign_t*>,_Compare = dict_foreign_compare,_Alloc = std::allocator<dict_foreign_t*>,std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::iterator = std::_Rb_tree_iterator<dict_foreign_t*>,std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::_Const_Base_ptr = const std::_Rb_tree_node_base*]" -> "dict_foreign_compare::operator()(const dict_foreign_t*,const dict_foreign_t*) const"
"_Alloc>::_M_create_node(const value_type&) [with _Key = dict_foreign_t*,_Val = dict_foreign_t*,_KeyOfValue = std::_Identity<dict_foreign_t*>,_Compare = dict_foreign_compare,_Alloc = std::allocator<dict_foreign_t*>,std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::_Link_type = std::_Rb_tree_node<dict_foreign_t*>*,std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::value_type = dict_foreign_t*]" -> "__cxa_begin_catch(void*)"
"_Alloc>::_M_create_node(const value_type&) [with _Key = dict_foreign_t*,_Val = dict_foreign_t*,_KeyOfValue = std::_Identity<dict_foreign_t*>,_Compare = dict_foreign_compare,_Alloc = std::allocator<dict_foreign_t*>,std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::_Link_type = std::_Rb_tree_node<dict_foreign_t*>*,std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::value_type = dict_foreign_t*]" -> "std::__addressof(_Tp&) [with _Tp = dict_foreign_t*]"
"_Alloc>::_M_create_node(const value_type&) [with _Key = dict_foreign_t*,_Val = dict_foreign_t*,_KeyOfValue = std::_Identity<dict_foreign_t*>,_Compare = dict_foreign_compare,_Alloc = std::allocator<dict_foreign_t*>,std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::_Link_type = std::_Rb_tree_node<dict_foreign_t*>*,std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::value_type = dict_foreign_t*]" -> "_Alloc>::_M_get_node() [with _Key = dict_foreign_t*,_Val = dict_foreign_t*,_KeyOfValue = std::_Identity<dict_foreign_t*>,_Compare = dict_foreign_compare,_Alloc = std::allocator<dict_foreign_t*>,std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::_Link_type = std::_Rb_tree_node<dict_foreign_t*>*]"
"_Alloc>::_M_create_node(const value_type&) [with _Key = dict_foreign_t*,_Val = dict_foreign_t*,_KeyOfValue = std::_Identity<dict_foreign_t*>,_Compare = dict_foreign_compare,_Alloc = std::allocator<dict_foreign_t*>,std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::_Link_type = std::_Rb_tree_node<dict_foreign_t*>*,std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::value_type = dict_foreign_t*]" -> "__gnu_cxx::new_allocator<_Tp>::construct(__gnu_cxx::new_allocator<_Tp>::pointer,const _Tp&) [with _Tp = dict_foreign_t*,__gnu_cxx::new_allocator<_Tp>::pointer = dict_foreign_t**]"
"_Alloc>::_M_create_node(const value_type&) [with _Key = dict_foreign_t*,_Val = dict_foreign_t*,_KeyOfValue = std::_Identity<dict_foreign_t*>,_Compare = dict_foreign_compare,_Alloc = std::allocator<dict_foreign_t*>,std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::_Link_type = std::_Rb_tree_node<dict_foreign_t*>*,std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::value_type = dict_foreign_t*]" -> "_Alloc>::get_allocator() const [with _Key = dict_foreign_t*,_Val = dict_foreign_t*,_KeyOfValue = std::_Identity<dict_foreign_t*>,_Compare = dict_foreign_compare,_Alloc = std::allocator<dict_foreign_t*>,std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::allocator_type = std::allocator<dict_foreign_t*>]"
"_Alloc>::_M_create_node(const value_type&) [with _Key = dict_foreign_t*,_Val = dict_foreign_t*,_KeyOfValue = std::_Identity<dict_foreign_t*>,_Compare = dict_foreign_compare,_Alloc = std::allocator<dict_foreign_t*>,std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::_Link_type = std::_Rb_tree_node<dict_foreign_t*>*,std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::value_type = dict_foreign_t*]" -> "_Alloc>::_M_put_node(std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::_Link_type) [with _Key = dict_foreign_t*,_Val = dict_foreign_t*,_KeyOfValue = std::_Identity<dict_foreign_t*>,_Compare = dict_foreign_compare,_Alloc = std::allocator<dict_foreign_t*>,std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::_Link_type = std::_Rb_tree_node<dict_foreign_t*>*]"
"_Alloc>::_M_create_node(const value_type&) [with _Key = dict_foreign_t*,_Val = dict_foreign_t*,_KeyOfValue = std::_Identity<dict_foreign_t*>,_Compare = dict_foreign_compare,_Alloc = std::allocator<dict_foreign_t*>,std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::_Link_type = std::_Rb_tree_node<dict_foreign_t*>*,std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::value_type = dict_foreign_t*]" -> "__builtin_eh_pointer(int)"
"_Alloc>::_M_create_node(const value_type&) [with _Key = dict_foreign_t*,_Val = dict_foreign_t*,_KeyOfValue = std::_Identity<dict_foreign_t*>,_Compare = dict_foreign_compare,_Alloc = std::allocator<dict_foreign_t*>,std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::_Link_type = std::_Rb_tree_node<dict_foreign_t*>*,std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::value_type = dict_foreign_t*]" -> "__cxa_end_catch()"
"_Alloc>::_M_create_node(const value_type&) [with _Key = dict_foreign_t*,_Val = dict_foreign_t*,_KeyOfValue = std::_Identity<dict_foreign_t*>,_Compare = dict_foreign_compare,_Alloc = std::allocator<dict_foreign_t*>,std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::_Link_type = std::_Rb_tree_node<dict_foreign_t*>*,std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::value_type = dict_foreign_t*]" -> "__cxa_rethrow()"
"_Alloc>::_M_get_node() [with _Key = dict_foreign_t*,_Val = dict_foreign_t*,_KeyOfValue = std::_Identity<dict_foreign_t*>,_Compare = dict_foreign_compare,_Alloc = std::allocator<dict_foreign_t*>,std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::_Link_type = std::_Rb_tree_node<dict_foreign_t*>*]" -> "__gnu_cxx::new_allocator<_Tp>::allocate(__gnu_cxx::new_allocator<_Tp>::size_type,const void*) [with _Tp = std::_Rb_tree_node<dict_foreign_t*>,__gnu_cxx::new_allocator<_Tp>::pointer = std::_Rb_tree_node<dict_foreign_t*>*,__gnu_cxx::new_allocator<_Tp>::size_type = long unsigned int]"
"__gnu_cxx::new_allocator<_Tp>::allocate(__gnu_cxx::new_allocator<_Tp>::size_type,const void*) [with _Tp = std::_Rb_tree_node<dict_foreign_t*>,__gnu_cxx::new_allocator<_Tp>::pointer = std::_Rb_tree_node<dict_foreign_t*>*,__gnu_cxx::new_allocator<_Tp>::size_type = long unsigned int]" -> "std::__throw_bad_alloc()"
"__gnu_cxx::new_allocator<_Tp>::allocate(__gnu_cxx::new_allocator<_Tp>::size_type,const void*) [with _Tp = std::_Rb_tree_node<dict_foreign_t*>,__gnu_cxx::new_allocator<_Tp>::pointer = std::_Rb_tree_node<dict_foreign_t*>*,__gnu_cxx::new_allocator<_Tp>::size_type = long unsigned int]" -> "__gnu_cxx::new_allocator<_Tp>::max_size() const [with _Tp = std::_Rb_tree_node<dict_foreign_t*>,__gnu_cxx::new_allocator<_Tp>::size_type = long unsigned int]"
"std::_Rb_tree_iterator<_Tp>::operator--() [with _Tp = dict_foreign_t*,std::_Rb_tree_iterator<_Tp>::_Self = std::_Rb_tree_iterator<dict_foreign_t*>]" -> "std::_Rb_tree_decrement(std::_Rb_tree_node_base*)"
"dict_foreign_find_index(const dict_table_t*,const char**,const char**,ulint,const dict_index_t*,bool,ulint)" -> "dict_foreign_qualify_index(const dict_table_t*,const char**,const char**,ulint,const dict_index_t*,const dict_index_t*,bool,ulint)"
"dict_foreign_qualify_index(const dict_table_t*,const char**,const char**,ulint,const dict_index_t*,const dict_index_t*,bool,ulint)" -> "cmp_cols_are_equal(const dict_col_t*,const dict_col_t*,ulint)"
"dict_foreign_qualify_index(const dict_table_t*,const char**,const char**,ulint,const dict_index_t*,const dict_index_t*,bool,ulint)" -> "dict_index_get_nth_col(const dict_index_t*,ulint)"
"dict_foreign_qualify_index(const dict_table_t*,const char**,const char**,ulint,const dict_index_t*,const dict_index_t*,bool,ulint)" -> "dict_table_get_col_name(const dict_table_t*,ulint)"
"dict_foreign_qualify_index(const dict_table_t*,const char**,const char**,ulint,const dict_index_t*,const dict_index_t*,bool,ulint)" -> "dict_index_get_n_fields(const dict_index_t*)"
"dict_foreign_qualify_index(const dict_table_t*,const char**,const char**,ulint,const dict_index_t*,const dict_index_t*,bool,ulint)" -> "dict_col_get_no(const dict_col_t*)"
"dict_foreign_qualify_index(const dict_table_t*,const char**,const char**,ulint,const dict_index_t*,const dict_index_t*,bool,ulint)" -> "innobase_strcasecmp(const char*,const char*)"
"cmp_cols_are_equal(const dict_col_t*,const dict_col_t*,ulint)" -> "dtype_is_non_binary_string_type(ulint,ulint)"
"cmp_cols_are_equal(const dict_col_t*,const dict_col_t*,ulint)" -> "dtype_get_charset_coll(ulint)"
"cmp_cols_are_equal(const dict_col_t*,const dict_col_t*,ulint)" -> "dtype_is_binary_string_type(ulint,ulint)"
"dtype_is_non_binary_string_type(ulint,ulint)" -> "dtype_is_binary_string_type(ulint,ulint)"
"dtype_is_non_binary_string_type(ulint,ulint)" -> "dtype_is_string_type(ulint)"
"dict_mem_referenced_table_name_lookup_set(dict_foreign_t*,ulint)" -> "mem_heap_alloc(mem_heap_t*,ulint)"
"dict_mem_referenced_table_name_lookup_set(dict_foreign_t*,ulint)" -> "innobase_get_lower_case_table_names()"
"dict_mem_referenced_table_name_lookup_set(dict_foreign_t*,ulint)" -> "strlen(const char*)"
"dict_mem_referenced_table_name_lookup_set(dict_foreign_t*,ulint)" -> "strcpy(char*,const char*)"
"dict_mem_referenced_table_name_lookup_set(dict_foreign_t*,ulint)" -> "innobase_casedn_str(char*)"
"dict_load_foreign_cols(dict_foreign_t*)" -> "btr_pcur_close(btr_pcur_t*)"
"dict_load_foreign_cols(dict_foreign_t*)" -> "dfield_set_data(dfield_t*,const void*,ulint)"
"dict_load_foreign_cols(dict_foreign_t*)" -> "rec_get_deleted_flag(const rec_t*,ulint)"
"dict_load_foreign_cols(dict_foreign_t*)" -> "rec_get_nth_field_offs_old(const rec_t*,ulint,ulint*)"
"dict_load_foreign_cols(dict_foreign_t*)" -> "mem_heap_strdupl(mem_heap_t*,const char*,ulint)"
"dict_load_foreign_cols(dict_foreign_t*)" -> "abort()"
"dict_load_foreign_cols(dict_foreign_t*)" -> "mach_read_from_4(const unsigned char*)"
"dict_load_foreign_cols(dict_foreign_t*)" -> "mtr_commit(mtr_t*)"
"dict_load_foreign_cols(dict_foreign_t*)" -> "dtuple_create(mem_heap_t*,ulint)"
"dict_load_foreign_cols(dict_foreign_t*)" -> "dict_index_copy_types(dtuple_t*,const dict_index_t*,ulint)"
"dict_load_foreign_cols(dict_foreign_t*)" -> "ib_logf(ib_log_level_t,const char*,...)"
"dict_load_foreign_cols(dict_foreign_t*)" -> "ut_dbg_assertion_failed(const char*,const char*,ulint)"
"dict_load_foreign_cols(dict_foreign_t*)" -> "btr_pcur_move_to_next_user_rec(btr_pcur_t*,mtr_t*)"
"dict_load_foreign_cols(dict_foreign_t*)" -> "btr_pcur_open_on_user_rec_func(dict_index_t*,const dtuple_t*,ulint,ulint,btr_pcur_t*,const char*,ulint,mtr_t*)"
"dict_load_foreign_cols(dict_foreign_t*)" -> "__builtin_expect(long int,long int)"
"dict_load_foreign_cols(dict_foreign_t*)" -> "strlen(const char*)"
"dict_load_foreign_cols(dict_foreign_t*)" -> "btr_pcur_is_on_user_rec(const btr_pcur_t*)"
"dict_load_foreign_cols(dict_foreign_t*)" -> "dict_table_get_low(const char*)"
"dict_load_foreign_cols(dict_foreign_t*)" -> "mtr_start(mtr_t*)"
"dict_load_foreign_cols(dict_foreign_t*)" -> "mem_heap_alloc(mem_heap_t*,ulint)"
"dict_load_foreign_cols(dict_foreign_t*)" -> "ut_memcmp(const void*,const void*,ulint)"
"fil_space_for_table_exists_in_mem(ulint,const char*,ulint,ulint,bool,mem_heap_t*,table_id_t)" -> "pfs_mutex_exit_func(ib_mutex_t*)"
"fil_space_for_table_exists_in_mem(ulint,const char*,ulint,ulint,bool,mem_heap_t*,table_id_t)" -> "fil_space_get_by_id(ulint)"
"fil_space_for_table_exists_in_mem(ulint,const char*,ulint,ulint,bool,mem_heap_t*,table_id_t)" -> "row_is_mysql_tmp_table_name(const char*)"
"fil_space_for_table_exists_in_mem(ulint,const char*,ulint,ulint,bool,mem_heap_t*,table_id_t)" -> "fil_rename_tablespace(const char*,ulint,const char*,const char*)"
"fil_space_for_table_exists_in_mem(ulint,const char*,ulint,ulint,bool,mem_heap_t*,table_id_t)" -> "fil_report_missing_tablespace(const char*,ulint)"
"fil_space_for_table_exists_in_mem(ulint,const char*,ulint,ulint,bool,mem_heap_t*,table_id_t)" -> "fprintf(FILE*,const char*,...)"
"fil_space_for_table_exists_in_mem(ulint,const char*,ulint,ulint,bool,mem_heap_t*,table_id_t)" -> "ut_print_timestamp(FILE*)"
"fil_space_for_table_exists_in_mem(ulint,const char*,ulint,ulint,bool,mem_heap_t*,table_id_t)" -> "__builtin_fwrite(const void*,size_t,size_t,FILE*)"
"fil_space_for_table_exists_in_mem(ulint,const char*,ulint,ulint,bool,mem_heap_t*,table_id_t)" -> "pfs_mutex_enter_func(ib_mutex_t*,const char*,ulint)"
"fil_space_for_table_exists_in_mem(ulint,const char*,ulint,ulint,bool,mem_heap_t*,table_id_t)" -> "dict_mem_create_temporary_tablename(mem_heap_t*,const char*,table_id_t)"
"fil_space_for_table_exists_in_mem(ulint,const char*,ulint,ulint,bool,mem_heap_t*,table_id_t)" -> "fil_space_get_by_name(const char*)"
"fil_space_for_table_exists_in_mem(ulint,const char*,ulint,ulint,bool,mem_heap_t*,table_id_t)" -> "strcmp(const char*,const char*)"
"fil_space_for_table_exists_in_mem(ulint,const char*,ulint,ulint,bool,mem_heap_t*,table_id_t)" -> "ut_print_filename(FILE*,const char*)"
"row_is_mysql_tmp_table_name(const char*)" -> "strstr(const char*,const char*)"
"fil_rename_tablespace(const char*,ulint,const char*,const char*)" -> "ut_print_filename(FILE*,const char*)"
"fil_rename_tablespace(const char*,ulint,const char*,const char*)" -> "os_thread_sleep(ulint)"
"fil_rename_tablespace(const char*,ulint,const char*,const char*)" -> "mem_strdup(const char*)"
"fil_rename_tablespace(const char*,ulint,const char*,const char*)" -> "fprintf(FILE*,const char*,...)"
"fil_rename_tablespace(const char*,ulint,const char*,const char*)" -> "ib_logf(ib_log_level_t,const char*,...)"
"fil_rename_tablespace(const char*,ulint,const char*,const char*)" -> "fil_op_write_log(ulint,ulint,ulint,ulint,const char*,const char*,mtr_t*)"
"fil_rename_tablespace(const char*,ulint,const char*,const char*)" -> "pfs_mutex_exit_func(ib_mutex_t*)"
"fil_rename_tablespace(const char*,ulint,const char*,const char*)" -> "abort()"
"fil_rename_tablespace(const char*,ulint,const char*,const char*)" -> "fil_space_get_by_id(ulint)"
"fil_rename_tablespace(const char*,ulint,const char*,const char*)" -> "mtr_start(mtr_t*)"
"fil_rename_tablespace(const char*,ulint,const char*,const char*)" -> "pfs_mutex_enter_func(ib_mutex_t*,const char*,ulint)"
"fil_rename_tablespace(const char*,ulint,const char*,const char*)" -> "ut_print_timestamp(FILE*)"
"fil_rename_tablespace(const char*,ulint,const char*,const char*)" -> "mem_free_func(void*,const char*,ulint)"
"fil_rename_tablespace(const char*,ulint,const char*,const char*)" -> "__builtin_fwrite(const void*,size_t,size_t,FILE*)"
"fil_rename_tablespace(const char*,ulint,const char*,const char*)" -> "__builtin_expect(long int,long int)"
"fil_rename_tablespace(const char*,ulint,const char*,const char*)" -> "fil_rename_tablespace_in_mem(fil_space_t*,fil_node_t*,const char*,const char*)"
"fil_rename_tablespace(const char*,ulint,const char*,const char*)" -> "fil_node_close_file(fil_node_t*,fil_system_t*)"
"fil_rename_tablespace(const char*,ulint,const char*,const char*)" -> "fil_make_ibd_name(const char*,bool)"
"fil_rename_tablespace(const char*,ulint,const char*,const char*)" -> "fil_flush(ulint)"
"fil_rename_tablespace(const char*,ulint,const char*,const char*)" -> "strcmp(const char*,const char*)"
"fil_rename_tablespace(const char*,ulint,const char*,const char*)" -> "mtr_commit(mtr_t*)"
"fil_rename_tablespace(const char*,ulint,const char*,const char*)" -> "pfs_os_file_rename_func(mysql_pfs_key_t,const char*,const char*,const char*,ulint)"
"fil_rename_tablespace(const char*,ulint,const char*,const char*)" -> "ut_dbg_assertion_failed(const char*,const char*,ulint)"
"mem_strdup(const char*)" -> "strlen(const char*)"
"mem_strdup(const char*)" -> "memcpy(void*,const void*,size_t)"
"mem_strdup(const char*)" -> "mem_alloc_func(ulint,ulint*)"
"fil_op_write_log(ulint,ulint,ulint,ulint,const char*,const char*,mtr_t*)" -> "mlog_write_initial_log_record_for_file_op(ulint,ulint,ulint,unsigned char*,mtr_t*)"
"fil_op_write_log(ulint,ulint,ulint,ulint,const char*,const char*,mtr_t*)" -> "mach_write_to_4(unsigned char*,ulint)"
"fil_op_write_log(ulint,ulint,ulint,ulint,const char*,const char*,mtr_t*)" -> "mach_write_to_2(unsigned char*,ulint)"
"fil_op_write_log(ulint,ulint,ulint,ulint,const char*,const char*,mtr_t*)" -> "strlen(const char*)"
"fil_op_write_log(ulint,ulint,ulint,ulint,const char*,const char*,mtr_t*)" -> "mlog_close(mtr_t*,unsigned char*)"
"fil_op_write_log(ulint,ulint,ulint,ulint,const char*,const char*,mtr_t*)" -> "mlog_open(mtr_t*,ulint)"
"fil_op_write_log(ulint,ulint,ulint,ulint,const char*,const char*,mtr_t*)" -> "mlog_catenate_string(mtr_t*,const unsigned char*,ulint)"
"fil_op_write_log(ulint,ulint,ulint,ulint,const char*,const char*,mtr_t*)" -> "__builtin_expect(long int,long int)"
"fil_op_write_log(ulint,ulint,ulint,ulint,const char*,const char*,mtr_t*)" -> "ut_dbg_assertion_failed(const char*,const char*,ulint)"
"fil_op_write_log(ulint,ulint,ulint,ulint,const char*,const char*,mtr_t*)" -> "abort()"
"mlog_write_initial_log_record_for_file_op(ulint,ulint,ulint,unsigned char*,mtr_t*)" -> "mach_write_compressed(unsigned char*,ulint)"
"mlog_write_initial_log_record_for_file_op(ulint,ulint,ulint,unsigned char*,mtr_t*)" -> "mach_write_to_1(unsigned char*,ulint)"
"fil_rename_tablespace_in_mem(fil_space_t*,fil_node_t*,const char*,const char*)" -> "ut_fold_string(const char*)"
"fil_rename_tablespace_in_mem(fil_space_t*,fil_node_t*,const char*,const char*)" -> "__builtin_expect(long int,long int)"
"fil_rename_tablespace_in_mem(fil_space_t*,fil_node_t*,const char*,const char*)" -> "hash_calc_hash(ulint,hash_table_t*)"
"fil_rename_tablespace_in_mem(fil_space_t*,fil_node_t*,const char*,const char*)" -> "ut_print_filename(FILE*,const char*)"
"fil_rename_tablespace_in_mem(fil_space_t*,fil_node_t*,const char*,const char*)" -> "hash_get_nth_cell(hash_table_t*,ulint)"
"fil_rename_tablespace_in_mem(fil_space_t*,fil_node_t*,const char*,const char*)" -> "ut_dbg_assertion_failed(const char*,const char*,ulint)"
"fil_rename_tablespace_in_mem(fil_space_t*,fil_node_t*,const char*,const char*)" -> "mem_free_func(void*,const char*,ulint)"
"fil_rename_tablespace_in_mem(fil_space_t*,fil_node_t*,const char*,const char*)" -> "__builtin_fwrite(const void*,size_t,size_t,FILE*)"
"fil_rename_tablespace_in_mem(fil_space_t*,fil_node_t*,const char*,const char*)" -> "mem_strdup(const char*)"
"fil_rename_tablespace_in_mem(fil_space_t*,fil_node_t*,const char*,const char*)" -> "fil_space_get_by_name(const char*)"
"fil_rename_tablespace_in_mem(fil_space_t*,fil_node_t*,const char*,const char*)" -> "abort()"
"fil_space_get_by_name(const char*)" -> "hash_get_nth_cell(hash_table_t*,ulint)"
"fil_space_get_by_name(const char*)" -> "ut_fold_string(const char*)"
"fil_space_get_by_name(const char*)" -> "strcmp(const char*,const char*)"
"fil_space_get_by_name(const char*)" -> "hash_calc_hash(ulint,hash_table_t*)"
"fil_make_ibd_name(const char*,bool)" -> "strlen(const char*)"
"fil_make_ibd_name(const char*,bool)" -> "mem_alloc_func(ulint,ulint*)"
"fil_make_ibd_name(const char*,bool)" -> "snprintf(char*,size_t,const char*,...)"
"fil_make_ibd_name(const char*,bool)" -> "srv_normalize_path_for_win(char*)"
"fil_make_ibd_name(const char*,bool)" -> "memcpy(void*,const void*,size_t)"
"pfs_os_file_rename_func(mysql_pfs_key_t,const char*,const char*,const char*,ulint)" -> "os_file_rename_func(const char*,const char*)"
"pfs_os_file_rename_func(mysql_pfs_key_t,const char*,const char*,const char*,ulint)" -> "__builtin_expect(long int,long int)"
"os_file_rename_func(const char*,const char*)" -> "os_file_handle_error_no_exit(const char*,const char*,ulint)"
"os_file_rename_func(const char*,const char*)" -> "rename(const char*,const char*)"
"fil_report_missing_tablespace(const char*,ulint)" -> "ib_logf(ib_log_level_t,const char*,...)"
"fil_report_missing_tablespace(const char*,ulint)" -> "innobase_format_name(char*,ulint,const char*,ulint)"
"innobase_format_name(char*,ulint,const char*,ulint)" -> "strlen(const char*)"
"innobase_format_name(char*,ulint,const char*,ulint)" -> "innobase_convert_name(char*,ulint,const char*,ulint,THD*,ulint)"
"innobase_convert_name(char*,ulint,const char*,ulint,THD*,ulint)" -> "memcpy(void*,const void*,size_t)"
"innobase_convert_name(char*,ulint,const char*,ulint,THD*,ulint)" -> "__builtin_expect(long int,long int)"
"innobase_convert_name(char*,ulint,const char*,ulint,THD*,ulint)" -> "innobase_convert_identifier(char*,ulint,const char*,ulint,THD*,ulint)"
"innobase_convert_name(char*,ulint,const char*,ulint,THD*,ulint)" -> "memchr(const void*,int,size_t)"
"innobase_convert_identifier(char*,ulint,const char*,ulint,THD*,ulint)" -> "memcpy(void*,const void*,size_t)"
"innobase_convert_identifier(char*,ulint,const char*,ulint,THD*,ulint)" -> "abort()"
"innobase_convert_identifier(char*,ulint,const char*,ulint,THD*,ulint)" -> "get_quote_char_for_identifier(THD*,const char*,uint)"
"innobase_convert_identifier(char*,ulint,const char*,ulint,THD*,ulint)" -> "ut_dbg_assertion_failed(const char*,const char*,ulint)"
"innobase_convert_identifier(char*,ulint,const char*,ulint,THD*,ulint)" -> "explain_filename(THD*,const char*,char*,uint,enum_explain_filename_mode)"
"innobase_convert_identifier(char*,ulint,const char*,ulint,THD*,ulint)" -> "__builtin_expect(long int,long int)"
"explain_filename(THD*,const char*,char*,uint,enum_explain_filename_mode)" -> "strlen(const char*)"
"explain_filename(THD*,const char*,char*,uint,enum_explain_filename_mode)" -> "strnmov(char*,const char*,size_t)"
"explain_filename(THD*,const char*,char*,uint,enum_explain_filename_mode)" -> "strchr(const char*,int)"
"explain_filename(THD*,const char*,char*,uint,enum_explain_filename_mode)" -> "add_identifier(THD*,char*,const char*,const char*,uint)"
"add_identifier(THD*,char*,const char*,const char*,uint)" -> "strnmov(char*,const char*,size_t)"
"add_identifier(THD*,char*,const char*,const char*,uint)" -> "strconvert(CHARSET_INFO*,const char*,CHARSET_INFO*,char*,uint,uint*)"
"add_identifier(THD*,char*,const char*,const char*,uint)" -> "get_quote_char_for_identifier(THD*,const char*,uint)"
"dict_mem_create_temporary_tablename(mem_heap_t*,const char*,table_id_t)" -> "memcpy(void*,const void*,size_t)"
"dict_mem_create_temporary_tablename(mem_heap_t*,const char*,table_id_t)" -> "__sync_add_and_fetch_4(volatile void*,unsigned int)"
"dict_mem_create_temporary_tablename(mem_heap_t*,const char*,table_id_t)" -> "strchr(const char*,int)"
"dict_mem_create_temporary_tablename(mem_heap_t*,const char*,table_id_t)" -> "snprintf(char*,size_t,const char*,...)"
"dict_mem_create_temporary_tablename(mem_heap_t*,const char*,table_id_t)" -> "mem_heap_alloc(mem_heap_t*,ulint)"
"fil_open_single_table_tablespace(bool,bool,ulint,ulint,const char*,const char*)" -> "fil_make_ibd_name(const char*,bool)"
"fil_open_single_table_tablespace(bool,bool,ulint,ulint,const char*,const char*)" -> "fil_space_create(const char*,ulint,ulint,ulint)"
"fil_open_single_table_tablespace(bool,bool,ulint,ulint,const char*,const char*)" -> "strcmp(const char*,const char*)"
"fil_open_single_table_tablespace(bool,bool,ulint,ulint,const char*,const char*)" -> "mem_free_func(void*,const char*,ulint)"
"fil_open_single_table_tablespace(bool,bool,ulint,ulint,const char*,const char*)" -> "fil_open_linked_file(const char*,char**,os_file_t*)"
"fil_open_single_table_tablespace(bool,bool,ulint,ulint,const char*,const char*)" -> "ut_dbg_assertion_failed(const char*,const char*,ulint)"
"fil_open_single_table_tablespace(bool,bool,ulint,ulint,const char*,const char*)" -> "memset(void*,int,size_t)"
"fil_open_single_table_tablespace(bool,bool,ulint,ulint,const char*,const char*)" -> "fil_delete_link_file(const char*)"
"fil_open_single_table_tablespace(bool,bool,ulint,ulint,const char*,const char*)" -> "__builtin_expect(long int,long int)"
"fil_open_single_table_tablespace(bool,bool,ulint,ulint,const char*,const char*)" -> "fil_read_first_page(os_file_t,ulint,ulint*,ulint*,lsn_t*,lsn_t*)"
"fil_open_single_table_tablespace(bool,bool,ulint,ulint,const char*,const char*)" -> "mem_strdup(const char*)"
"fil_open_single_table_tablespace(bool,bool,ulint,ulint,const char*,const char*)" -> "fsp_flags_is_valid(ulint)"
"fil_open_single_table_tablespace(bool,bool,ulint,ulint,const char*,const char*)" -> "fil_node_create(const char*,ulint,ulint,ulint)"
"fil_open_single_table_tablespace(bool,bool,ulint,ulint,const char*,const char*)" -> "os_file_get_last_error(bool)"
"fil_open_single_table_tablespace(bool,bool,ulint,ulint,const char*,const char*)" -> "ib_logf(ib_log_level_t,const char*,...)"
"fil_open_single_table_tablespace(bool,bool,ulint,ulint,const char*,const char*)" -> "fil_report_bad_tablespace(const char*,const char*,ulint,ulint,ulint,ulint)"
"fil_open_single_table_tablespace(bool,bool,ulint,ulint,const char*,const char*)" -> "dict_insert_tablespace_and_filepath(ulint,const char*,const char*,ulint)"
"fil_open_single_table_tablespace(bool,bool,ulint,ulint,const char*,const char*)" -> "fil_create_link_file(const char*,const char*)"
"fil_open_single_table_tablespace(bool,bool,ulint,ulint,const char*,const char*)" -> "pfs_os_file_close_func(os_file_t,const char*,ulint)"
"fil_open_single_table_tablespace(bool,bool,ulint,ulint,const char*,const char*)" -> "abort()"
"fil_open_single_table_tablespace(bool,bool,ulint,ulint,const char*,const char*)" -> "pfs_os_file_create_simple_no_error_handling_func(mysql_pfs_key_t,const char*,ulint,ulint,ulint*,const char*,ulint)"
"fil_open_single_table_tablespace(bool,bool,ulint,ulint,const char*,const char*)" -> "dict_update_filepath(ulint,const char*)"
"fil_space_create(const char*,ulint,ulint,ulint)" -> "hash_calc_hash(ulint,hash_table_t*)"
"fil_space_create(const char*,ulint,ulint,ulint)" -> "fil_space_free(ulint,ulint)"
"fil_space_create(const char*,ulint,ulint,ulint)" -> "hash_get_nth_cell(hash_table_t*,ulint)"
"fil_space_create(const char*,ulint,ulint,ulint)" -> "__builtin_expect(long int,long int)"
"fil_space_create(const char*,ulint,ulint,ulint)" -> "pfs_mutex_exit_func(ib_mutex_t*)"
"fil_space_create(const char*,ulint,ulint,ulint)" -> "fil_space_get_by_name(const char*)"
"fil_space_create(const char*,ulint,ulint,ulint)" -> "mem_alloc_func(ulint,ulint*)"
"fil_space_create(const char*,ulint,ulint,ulint)" -> "ut_fold_string(const char*)"
"fil_space_create(const char*,ulint,ulint,ulint)" -> "ut_list_append(List&,Type&,size_t) [with List = ut_list_base<fil_space_t>,Type = fil_space_t,size_t = long unsigned int]"
"fil_space_create(const char*,ulint,ulint,ulint)" -> "mem_strdup(const char*)"
"fil_space_create(const char*,ulint,ulint,ulint)" -> "ut_dbg_assertion_failed(const char*,const char*,ulint)"
"fil_space_create(const char*,ulint,ulint,ulint)" -> "pfs_rw_lock_create_func(mysql_pfs_key_t,rw_lock_t*,const char*,ulint)"
"fil_space_create(const char*,ulint,ulint,ulint)" -> "pfs_mutex_enter_func(ib_mutex_t*,const char*,ulint)"
"fil_space_create(const char*,ulint,ulint,ulint)" -> "memset(void*,int,size_t)"
"fil_space_create(const char*,ulint,ulint,ulint)" -> "ib_logf(ib_log_level_t,const char*,...)"
"fil_space_create(const char*,ulint,ulint,ulint)" -> "abort()"
"fil_space_create(const char*,ulint,ulint,ulint)" -> "fil_space_get_by_id(ulint)"
"fil_space_create(const char*,ulint,ulint,ulint)" -> "fsp_flags_is_valid(ulint)"
"fil_space_free(ulint,ulint)" -> "fil_space_get_by_name(const char*)"
"fil_space_free(ulint,ulint)" -> "mem_free_func(void*,const char*,ulint)"
"fil_space_free(ulint,ulint)" -> "fil_space_get_by_id(ulint)"
"fil_space_free(ulint,ulint)" -> "__builtin_expect(long int,long int)"
"fil_space_free(ulint,ulint)" -> "hash_get_nth_cell(hash_table_t*,ulint)"
"fil_space_free(ulint,ulint)" -> "ut_fold_string(const char*)"
"fil_space_free(ulint,ulint)" -> "ut_dbg_assertion_failed(const char*,const char*,ulint)"
"fil_space_free(ulint,ulint)" -> "pfs_rw_lock_x_unlock_func(rw_lock_t*)"
"fil_space_free(ulint,ulint)" -> "ut_print_timestamp(FILE*)"
"fil_space_free(ulint,ulint)" -> "ut_list_remove(List&,Type&,size_t) [with List = ut_list_base<fil_space_t>,Type = fil_space_t,size_t = long unsigned int]"
"fil_space_free(ulint,ulint)" -> "fil_node_free(fil_node_t*,fil_system_t*,fil_space_t*)"
"fil_space_free(ulint,ulint)" -> "abort()"
"fil_space_free(ulint,ulint)" -> "pfs_rw_lock_free_func(rw_lock_t*)"
"fil_space_free(ulint,ulint)" -> "hash_calc_hash(ulint,hash_table_t*)"
"fil_space_free(ulint,ulint)" -> "fprintf(FILE*,const char*,...)"
"fil_node_free(fil_node_t*,fil_system_t*,fil_space_t*)" -> "os_event_free(os_event_t)"
"fil_node_free(fil_node_t*,fil_system_t*,fil_space_t*)" -> "abort()"
"fil_node_free(fil_node_t*,fil_system_t*,fil_space_t*)" -> "ut_dbg_assertion_failed(const char*,const char*,ulint)"
"fil_node_free(fil_node_t*,fil_system_t*,fil_space_t*)" -> "fil_space_is_flushed(fil_space_t*)"
"fil_node_free(fil_node_t*,fil_system_t*,fil_space_t*)" -> "fil_node_close_file(fil_node_t*,fil_system_t*)"
"fil_node_free(fil_node_t*,fil_system_t*,fil_space_t*)" -> "mem_free_func(void*,const char*,ulint)"
"fil_node_free(fil_node_t*,fil_system_t*,fil_space_t*)" -> "__builtin_expect(long int,long int)"
"fil_node_free(fil_node_t*,fil_system_t*,fil_space_t*)" -> "ut_list_remove(List&,Type&,size_t) [with List = ut_list_base<fil_node_t>,Type = fil_node_t,size_t = long unsigned int]"
"fil_node_free(fil_node_t*,fil_system_t*,fil_space_t*)" -> "os_event_set(os_event_t)"
"fil_node_free(fil_node_t*,fil_system_t*,fil_space_t*)" -> "ut_list_remove(List&,Type&,size_t) [with List = ut_list_base<fil_space_t>,Type = fil_space_t,size_t = long unsigned int]"
"ut_list_append(List&,Type&,size_t) [with List = ut_list_base<fil_space_t>,Type = fil_space_t,size_t = long unsigned int]" -> "ut_elem_get_node(Type&,size_t) [with Type = fil_space_t,size_t = long unsigned int]"
"fil_open_linked_file(const char*,char**,os_file_t*)" -> "mem_free_func(void*,const char*,ulint)"
"fil_open_linked_file(const char*,char**,os_file_t*)" -> "fil_read_link_file(const char*)"
"fil_open_linked_file(const char*,char**,os_file_t*)" -> "fil_make_isl_name(const char*)"
"fil_open_linked_file(const char*,char**,os_file_t*)" -> "os_file_get_last_error(bool)"
"fil_open_linked_file(const char*,char**,os_file_t*)" -> "ib_logf(ib_log_level_t,const char*,...)"
"fil_open_linked_file(const char*,char**,os_file_t*)" -> "pfs_os_file_create_simple_no_error_handling_func(mysql_pfs_key_t,const char*,ulint,ulint,ulint*,const char*,ulint)"
"fil_read_link_file(const char*)" -> "fclose(FILE*)"
"fil_read_link_file(const char*)" -> "os_file_read_string(FILE*,char*,ulint)"
"fil_read_link_file(const char*)" -> "strlen(const char*)"
"fil_read_link_file(const char*)" -> "mem_free_func(void*,const char*,ulint)"
"fil_read_link_file(const char*)" -> "mem_alloc_func(ulint,ulint*)"
"fil_read_link_file(const char*)" -> "fil_make_isl_name(const char*)"
"fil_read_link_file(const char*)" -> "srv_normalize_path_for_win(char*)"
"fil_read_link_file(const char*)" -> "fopen(const char*,const char*)"
"os_file_read_string(FILE*,char*,ulint)" -> "fread(void*,size_t,size_t,FILE*)"
"os_file_read_string(FILE*,char*,ulint)" -> "rewind(FILE*)"
"fil_make_isl_name(const char*)" -> "srv_normalize_path_for_win(char*)"
"fil_make_isl_name(const char*)" -> "strlen(const char*)"
"fil_make_isl_name(const char*)" -> "mem_alloc_func(ulint,ulint*)"
"fil_make_isl_name(const char*)" -> "snprintf(char*,size_t,const char*,...)"
"fil_delete_link_file(const char*)" -> "pfs_os_file_delete_if_exists_func(mysql_pfs_key_t,const char*,const char*,ulint)"
"fil_delete_link_file(const char*)" -> "mem_free_func(void*,const char*,ulint)"
"fil_delete_link_file(const char*)" -> "fil_make_isl_name(const char*)"
"pfs_os_file_delete_if_exists_func(mysql_pfs_key_t,const char*,const char*,ulint)" -> "os_file_delete_if_exists_func(const char*)"
"pfs_os_file_delete_if_exists_func(mysql_pfs_key_t,const char*,const char*,ulint)" -> "__builtin_expect(long int,long int)"
"os_file_delete_if_exists_func(const char*)" -> "os_file_handle_error_no_exit(const char*,const char*,ulint)"
"os_file_delete_if_exists_func(const char*)" -> "unlink(const char*)"
"os_file_delete_if_exists_func(const char*)" -> "__errno_location()"
"fil_read_first_page(os_file_t,ulint,ulint*,ulint*,lsn_t*,lsn_t*)" -> "pfs_os_file_read_func(os_file_t,void*,os_offset_t,ulint,const char*,ulint)"
"fil_read_first_page(os_file_t,ulint,ulint*,ulint*,lsn_t*,lsn_t*)" -> "fsp_header_get_flags(const ib_page_t*)"
"fil_read_first_page(os_file_t,ulint,ulint*,ulint*,lsn_t*,lsn_t*)" -> "fil_check_first_page(const ib_page_t*)"
"fil_read_first_page(os_file_t,ulint,ulint*,ulint*,lsn_t*,lsn_t*)" -> "ut_free(void*)"
"fil_read_first_page(os_file_t,ulint,ulint*,ulint*,lsn_t*,lsn_t*)" -> "ut_malloc_low(ulint,ulint)"
"fil_read_first_page(os_file_t,ulint,ulint*,ulint*,lsn_t*,lsn_t*)" -> "fsp_header_get_space_id(const ib_page_t*)"
"fil_read_first_page(os_file_t,ulint,ulint*,ulint*,lsn_t*,lsn_t*)" -> "mach_read_from_8(const unsigned char*)"
"fil_read_first_page(os_file_t,ulint,ulint*,ulint*,lsn_t*,lsn_t*)" -> "ut_align(const void*,ulint)"
"fil_check_first_page(const ib_page_t*)" -> "page_get_page_no(const ib_page_t*)"
"fil_check_first_page(const ib_page_t*)" -> "fsp_flags_get_page_size(ulint)"
"fil_check_first_page(const ib_page_t*)" -> "buf_page_is_corrupted(bool,const unsigned char*,ulint)"
"fil_check_first_page(const ib_page_t*)" -> "mach_read_from_4(const unsigned char*)"
"fil_check_first_page(const ib_page_t*)" -> "page_get_space_id(const ib_page_t*)"
"fil_check_first_page(const ib_page_t*)" -> "fsp_flags_get_zip_size(ulint)"
"buf_page_is_corrupted(bool,const unsigned char*,ulint)" -> "buf_calc_page_crc32(const unsigned char*)"
"buf_page_is_corrupted(bool,const unsigned char*,ulint)" -> "fprintf(FILE*,const char*,...)"
"buf_page_is_corrupted(bool,const unsigned char*,ulint)" -> "buf_calc_page_old_checksum(const unsigned char*)"
"buf_page_is_corrupted(bool,const unsigned char*,ulint)" -> "ut_print_timestamp(FILE*)"
"buf_page_is_corrupted(bool,const unsigned char*,ulint)" -> "buf_calc_page_new_checksum(const unsigned char*)"
"buf_page_is_corrupted(bool,const unsigned char*,ulint)" -> "page_zip_verify_checksum(const void*,ulint)"
"buf_page_is_corrupted(bool,const unsigned char*,ulint)" -> "log_peek_lsn(lsn_t*)"
"buf_page_is_corrupted(bool,const unsigned char*,ulint)" -> "mach_read_from_4(const unsigned char*)"
"buf_page_is_corrupted(bool,const unsigned char*,ulint)" -> "ut_dbg_assertion_failed(const char*,const char*,ulint)"
"buf_page_is_corrupted(bool,const unsigned char*,ulint)" -> "mach_read_from_8(const unsigned char*)"
"buf_page_is_corrupted(bool,const unsigned char*,ulint)" -> "memcmp(const void*,const void*,size_t)"
"buf_page_is_corrupted(bool,const unsigned char*,ulint)" -> "abort()"
"log_peek_lsn(lsn_t*)" -> "pfs_mutex_enter_nowait_func(ib_mutex_t*,const char*,ulint)"
"log_peek_lsn(lsn_t*)" -> "pfs_mutex_exit_func(ib_mutex_t*)"
"pfs_mutex_enter_nowait_func(ib_mutex_t*,const char*,ulint)" -> "mutex_enter_nowait_func(ib_mutex_t*,const char*,ulint)"
"mutex_enter_nowait_func(ib_mutex_t*,const char*,ulint)" -> "ib_mutex_test_and_set(ib_mutex_t*)"
"fil_node_create(const char*,ulint,ulint,ulint)" -> "mem_alloc_func(ulint,ulint*)"
"fil_node_create(const char*,ulint,ulint,ulint)" -> "fprintf(FILE*,const char*,...)"
"fil_node_create(const char*,ulint,ulint,ulint)" -> "ut_print_timestamp(FILE*)"
"fil_node_create(const char*,ulint,ulint,ulint)" -> "fil_space_get_by_id(ulint)"
"fil_node_create(const char*,ulint,ulint,ulint)" -> "mem_free_func(void*,const char*,ulint)"
"fil_node_create(const char*,ulint,ulint,ulint)" -> "__builtin_expect(long int,long int)"
"fil_node_create(const char*,ulint,ulint,ulint)" -> "ut_print_filename(FILE*,const char*)"
"fil_node_create(const char*,ulint,ulint,ulint)" -> "mem_strdup(const char*)"
"fil_node_create(const char*,ulint,ulint,ulint)" -> "memset(void*,int,size_t)"
"fil_node_create(const char*,ulint,ulint,ulint)" -> "abort()"
"fil_node_create(const char*,ulint,ulint,ulint)" -> "__builtin_fwrite(const void*,size_t,size_t,FILE*)"
"fil_node_create(const char*,ulint,ulint,ulint)" -> "pfs_mutex_exit_func(ib_mutex_t*)"
"fil_node_create(const char*,ulint,ulint,ulint)" -> "os_event_create()"
"fil_node_create(const char*,ulint,ulint,ulint)" -> "ut_list_append(List&,Type&,size_t) [with List = ut_list_base<fil_node_t>,Type = fil_node_t,size_t = long unsigned int]"
"fil_node_create(const char*,ulint,ulint,ulint)" -> "pfs_mutex_enter_func(ib_mutex_t*,const char*,ulint)"
"fil_node_create(const char*,ulint,ulint,ulint)" -> "ut_dbg_assertion_failed(const char*,const char*,ulint)"
"ut_list_append(List&,Type&,size_t) [with List = ut_list_base<fil_node_t>,Type = fil_node_t,size_t = long unsigned int]" -> "ut_elem_get_node(Type&,size_t) [with Type = fil_node_t,size_t = long unsigned int]"
"fil_report_bad_tablespace(const char*,const char*,ulint,ulint,ulint,ulint)" -> "ib_logf(ib_log_level_t,const char*,...)"
"dict_insert_tablespace_and_filepath(ulint,const char*,const char*,ulint)" -> "trx_free_for_background(trx_t*)"
"dict_insert_tablespace_and_filepath(ulint,const char*,const char*,ulint)" -> "dict_create_add_tablespace_to_dictionary(ulint,const char*,ulint,const char*,trx_t*,bool)"
"dict_insert_tablespace_and_filepath(ulint,const char*,const char*,ulint)" -> "trx_commit_for_mysql(trx_t*)"
"dict_insert_tablespace_and_filepath(ulint,const char*,const char*,ulint)" -> "trx_start_for_ddl_low(trx_t*,trx_dict_op_t)"
"dict_insert_tablespace_and_filepath(ulint,const char*,const char*,ulint)" -> "trx_allocate_for_background()"
"dict_create_add_tablespace_to_dictionary(ulint,const char*,ulint,const char*,trx_t*,bool)" -> "__builtin_expect(long int,long int)"
"dict_create_add_tablespace_to_dictionary(ulint,const char*,ulint,const char*,trx_t*,bool)" -> "pars_info_create()"
"dict_create_add_tablespace_to_dictionary(ulint,const char*,ulint,const char*,trx_t*,bool)" -> "abort()"
"dict_create_add_tablespace_to_dictionary(ulint,const char*,ulint,const char*,trx_t*,bool)" -> "trx_commit(trx_t*)"
"dict_create_add_tablespace_to_dictionary(ulint,const char*,ulint,const char*,trx_t*,bool)" -> "que_eval_sql(pars_info_t*,const char*,ulint,trx_t*)"
"dict_create_add_tablespace_to_dictionary(ulint,const char*,ulint,const char*,trx_t*,bool)" -> "pars_info_add_str_literal(pars_info_t*,const char*,const char*)"
"dict_create_add_tablespace_to_dictionary(ulint,const char*,ulint,const char*,trx_t*,bool)" -> "ut_dbg_assertion_failed(const char*,const char*,ulint)"
"dict_create_add_tablespace_to_dictionary(ulint,const char*,ulint,const char*,trx_t*,bool)" -> "pars_info_add_int4_literal(pars_info_t*,const char*,lint)"
"pars_info_create()" -> "mem_heap_create_func(ulint,ulint)"
"pars_info_create()" -> "mem_heap_alloc(mem_heap_t*,ulint)"
"que_eval_sql(pars_info_t*,const char*,ulint,trx_t*)" -> "que_graph_free(que_t*)"
"que_eval_sql(pars_info_t*,const char*,ulint,trx_t*)" -> "que_fork_start_command(que_fork_t*)"
"que_eval_sql(pars_info_t*,const char*,ulint,trx_t*)" -> "pfs_mutex_exit_func(ib_mutex_t*)"
"que_eval_sql(pars_info_t*,const char*,ulint,trx_t*)" -> "pars_sql(pars_info_t*,const char*)"
"que_eval_sql(pars_info_t*,const char*,ulint,trx_t*)" -> "pfs_mutex_enter_func(ib_mutex_t*,const char*,ulint)"
"que_eval_sql(pars_info_t*,const char*,ulint,trx_t*)" -> "ut_dbg_assertion_failed(const char*,const char*,ulint)"
"que_eval_sql(pars_info_t*,const char*,ulint,trx_t*)" -> "abort()"
"que_eval_sql(pars_info_t*,const char*,ulint,trx_t*)" -> "__builtin_expect(long int,long int)"
"que_eval_sql(pars_info_t*,const char*,ulint,trx_t*)" -> "que_run_threads(que_thr_t*)"
"que_fork_start_command(que_fork_t*)" -> "ut_dbg_assertion_failed(const char*,const char*,ulint)"
"que_fork_start_command(que_fork_t*)" -> "que_thr_init_command(que_thr_t*)"
"que_fork_start_command(que_fork_t*)" -> "que_thr_move_to_run_state(que_thr_t*)"
"que_fork_start_command(que_fork_t*)" -> "abort()"
"que_thr_init_command(que_thr_t*)" -> "que_thr_move_to_run_state(que_thr_t*)"
"que_run_threads(que_thr_t*)" -> "abort()"
"que_run_threads(que_thr_t*)" -> "que_thr_dec_refer_count(que_thr_t*,que_thr_t**)"
"que_run_threads(que_thr_t*)" -> "ut_dbg_assertion_failed(const char*,const char*,ulint)"
"que_run_threads(que_thr_t*)" -> "thr_get_trx(que_thr_t*)"
"que_run_threads(que_thr_t*)" -> "pfs_mutex_enter_func(ib_mutex_t*,const char*,ulint)"
"que_run_threads(que_thr_t*)" -> "que_run_threads_low(que_thr_t*)"
"que_run_threads(que_thr_t*)" -> "lock_wait_suspend_thread(que_thr_t*)"
"que_run_threads(que_thr_t*)" -> "__builtin_expect(long int,long int)"
"que_run_threads(que_thr_t*)" -> "pfs_mutex_exit_func(ib_mutex_t*)"
"que_thr_dec_refer_count(que_thr_t*,que_thr_t**)" -> "que_thr_stop(que_thr_t*)"
"que_thr_dec_refer_count(que_thr_t*,que_thr_t**)" -> "__builtin_expect(long int,long int)"
"que_thr_dec_refer_count(que_thr_t*,que_thr_t**)" -> "ut_dbg_assertion_failed(const char*,const char*,ulint)"
"que_thr_dec_refer_count(que_thr_t*,que_thr_t**)" -> "thr_get_trx(que_thr_t*)"
"que_thr_dec_refer_count(que_thr_t*,que_thr_t**)" -> "abort()"
"que_run_threads_low(que_thr_t*)" -> "pfs_mutex_exit_func(ib_mutex_t*)"
"que_run_threads_low(que_thr_t*)" -> "que_thr_dec_refer_count(que_thr_t*,que_thr_t**)"
"que_run_threads_low(que_thr_t*)" -> "pfs_mutex_enter_func(ib_mutex_t*,const char*,ulint)"
"que_run_threads_low(que_thr_t*)" -> "__builtin_expect(long int,long int)"
"que_run_threads_low(que_thr_t*)" -> "que_thr_step(que_thr_t*)"
"que_run_threads_low(que_thr_t*)" -> "ut_dbg_assertion_failed(const char*,const char*,ulint)"
"que_run_threads_low(que_thr_t*)" -> "abort()"
"que_run_threads_low(que_thr_t*)" -> "log_free_check()"
"que_run_threads_low(que_thr_t*)" -> "thr_get_trx(que_thr_t*)"
"que_thr_step(que_thr_t*)" -> "for_step(que_thr_t*)"
"que_thr_step(que_thr_t*)" -> "return_step(que_thr_t*)"
"que_thr_step(que_thr_t*)" -> "dict_create_table_step(que_thr_t*)"
"que_thr_step(que_thr_t*)" -> "fetch_step(que_thr_t*)"
"que_thr_step(que_thr_t*)" -> "que_node_get_next(que_node_t*)"
"que_thr_step(que_thr_t*)" -> "row_purge_step(que_thr_t*)"
"que_thr_step(que_thr_t*)" -> "row_ins_step(que_thr_t*)"
"que_thr_step(que_thr_t*)" -> "assign_step(que_thr_t*)"
"que_thr_step(que_thr_t*)" -> "que_thr_node_step(que_thr_t*)"
"que_thr_step(que_thr_t*)" -> "dict_create_index_step(que_thr_t*)"
"que_thr_step(que_thr_t*)" -> "que_node_get_parent(que_node_t*)"
"que_thr_step(que_thr_t*)" -> "__builtin_expect(long int,long int)"
"que_thr_step(que_thr_t*)" -> "proc_eval_step(que_thr_t*)"
"que_thr_step(que_thr_t*)" -> "row_sel_step(que_thr_t*)"
"que_thr_step(que_thr_t*)" -> "thr_get_trx(que_thr_t*)"
"que_thr_step(que_thr_t*)" -> "que_node_get_containing_loop_node(que_node_t*)"
"que_thr_step(que_thr_t*)" -> "row_undo_step(que_thr_t*)"
"que_thr_step(que_thr_t*)" -> "open_step(que_thr_t*)"
"que_thr_step(que_thr_t*)" -> "proc_step(que_thr_t*)"
"que_thr_step(que_thr_t*)" -> "abort()"
"que_thr_step(que_thr_t*)" -> "ut_dbg_assertion_failed(const char*,const char*,ulint)"
"que_thr_step(que_thr_t*)" -> "que_node_get_type(que_node_t*)"
"que_thr_step(que_thr_t*)" -> "trx_rollback_step(que_thr_t*)"
"que_thr_step(que_thr_t*)" -> "trx_commit_step(que_thr_t*)"
"que_thr_step(que_thr_t*)" -> "exit_step(que_thr_t*)"
"que_thr_step(que_thr_t*)" -> "while_step(que_thr_t*)"
"que_thr_step(que_thr_t*)" -> "row_printf_step(que_thr_t*)"
"que_thr_step(que_thr_t*)" -> "row_upd_step(que_thr_t*)"
"que_thr_step(que_thr_t*)" -> "if_step(que_thr_t*)"
"for_step(que_thr_t*)" -> "eval_node_get_int_val(que_node_t*)"
"for_step(que_thr_t*)" -> "eval_exp(que_node_t*)"
"for_step(que_thr_t*)" -> "que_node_get_next(que_node_t*)"
"for_step(que_thr_t*)" -> "que_node_get_parent(que_node_t*)"
"for_step(que_thr_t*)" -> "eval_node_set_int_val(que_node_t*,lint)"
"eval_node_get_int_val(que_node_t*)" -> "que_node_get_val(que_node_t*)"
"eval_node_get_int_val(que_node_t*)" -> "mach_read_from_4(const unsigned char*)"
"eval_exp(que_node_t*)" -> "eval_func(func_node_t*)"
"eval_exp(que_node_t*)" -> "eval_sym(sym_node_t*)"
"eval_exp(que_node_t*)" -> "que_node_get_type(que_node_t*)"
"eval_func(func_node_t*)" -> "dfield_is_null(const dfield_t*)"
"eval_func(func_node_t*)" -> "eval_instr(func_node_t*)"
"eval_func(func_node_t*)" -> "eval_logical(func_node_t*)"
"eval_func(func_node_t*)" -> "que_node_get_next(que_node_t*)"
"eval_func(func_node_t*)" -> "eval_notfound(func_node_t*)"
"eval_func(func_node_t*)" -> "eval_arith(func_node_t*)"
"eval_func(func_node_t*)" -> "eval_concat(func_node_t*)"
"eval_func(func_node_t*)" -> "eval_to_binary(func_node_t*)"
"eval_func(func_node_t*)" -> "eval_exp(que_node_t*)"
"eval_func(func_node_t*)" -> "eval_binary_to_number(func_node_t*)"
"eval_func(func_node_t*)" -> "eval_replstr(func_node_t*)"
"eval_func(func_node_t*)" -> "que_node_get_val(que_node_t*)"
"eval_func(func_node_t*)" -> "eval_substr(func_node_t*)"
"eval_func(func_node_t*)" -> "abort()"
"eval_func(func_node_t*)" -> "eval_predefined(func_node_t*)"
"eval_func(func_node_t*)" -> "eval_cmp(func_node_t*)"
"eval_func(func_node_t*)" -> "ut_dbg_assertion_failed(const char*,const char*,ulint)"
"eval_func(func_node_t*)" -> "eval_aggregate(func_node_t*)"
"eval_instr(func_node_t*)" -> "que_node_get_val(que_node_t*)"
"eval_instr(func_node_t*)" -> "que_node_get_next(que_node_t*)"
"eval_instr(func_node_t*)" -> "dfield_get_len(const dfield_t*)"
"eval_instr(func_node_t*)" -> "eval_node_set_int_val(que_node_t*,lint)"
"eval_instr(func_node_t*)" -> "abort()"
"eval_instr(func_node_t*)" -> "ut_dbg_assertion_failed(const char*,const char*,ulint)"
"eval_node_set_int_val(que_node_t*,lint)" -> "mach_write_to_4(unsigned char*,ulint)"
"eval_node_set_int_val(que_node_t*,lint)" -> "que_node_get_val(que_node_t*)"
"eval_node_set_int_val(que_node_t*,lint)" -> "eval_node_alloc_val_buf(que_node_t*,ulint)"
"eval_node_alloc_val_buf(que_node_t*,ulint)" -> "que_node_get_val(que_node_t*)"
"eval_node_alloc_val_buf(que_node_t*,ulint)" -> "que_node_set_val_buf_size(que_node_t*,ulint)"
"eval_node_alloc_val_buf(que_node_t*,ulint)" -> "mem_free_func(void*,const char*,ulint)"
"eval_node_alloc_val_buf(que_node_t*,ulint)" -> "dfield_set_data(dfield_t*,const void*,ulint)"
"eval_node_alloc_val_buf(que_node_t*,ulint)" -> "mem_alloc_func(ulint,ulint*)"
"eval_logical(func_node_t*)" -> "ut_dbg_assertion_failed(const char*,const char*,ulint)"
"eval_logical(func_node_t*)" -> "que_node_get_next(que_node_t*)"
"eval_logical(func_node_t*)" -> "eval_node_get_ibool_val(que_node_t*)"
"eval_logical(func_node_t*)" -> "abort()"
"eval_logical(func_node_t*)" -> "eval_node_set_ibool_val(func_node_t*,ulint)"
"eval_node_get_ibool_val(que_node_t*)" -> "que_node_get_val(que_node_t*)"
"eval_node_get_ibool_val(que_node_t*)" -> "mach_read_from_1(const unsigned char*)"
"eval_node_set_ibool_val(func_node_t*,ulint)" -> "que_node_get_val(que_node_t*)"
"eval_node_set_ibool_val(func_node_t*,ulint)" -> "eval_node_alloc_val_buf(que_node_t*,ulint)"
"eval_node_set_ibool_val(func_node_t*,ulint)" -> "mach_write_to_1(unsigned char*,ulint)"
"eval_notfound(func_node_t*)" -> "eval_node_set_ibool_val(func_node_t*,ulint)"
"eval_arith(func_node_t*)" -> "eval_node_set_int_val(que_node_t*,lint)"
"eval_arith(func_node_t*)" -> "eval_node_get_int_val(que_node_t*)"
"eval_arith(func_node_t*)" -> "que_node_get_next(que_node_t*)"
"eval_concat(func_node_t*)" -> "dfield_get_len(const dfield_t*)"
"eval_concat(func_node_t*)" -> "que_node_get_val(que_node_t*)"
"eval_concat(func_node_t*)" -> "que_node_get_next(que_node_t*)"
"eval_concat(func_node_t*)" -> "ut_memcpy(void*,const void*,ulint)"
"eval_concat(func_node_t*)" -> "eval_node_ensure_val_buf(que_node_t*,ulint)"
"eval_node_ensure_val_buf(que_node_t*,ulint)" -> "que_node_get_val_buf_size(que_node_t*)"
"eval_node_ensure_val_buf(que_node_t*,ulint)" -> "dfield_set_len(dfield_t*,ulint)"
"eval_node_ensure_val_buf(que_node_t*,ulint)" -> "eval_node_alloc_val_buf(que_node_t*,ulint)"
"eval_node_ensure_val_buf(que_node_t*,ulint)" -> "que_node_get_val(que_node_t*)"
"eval_to_binary(func_node_t*)" -> "dfield_set_data(dfield_t*,const void*,ulint)"
"eval_to_binary(func_node_t*)" -> "que_node_get_data_type(que_node_t*)"
"eval_to_binary(func_node_t*)" -> "dfield_get_len(const dfield_t*)"
"eval_to_binary(func_node_t*)" -> "que_node_get_next(que_node_t*)"
"eval_to_binary(func_node_t*)" -> "que_node_get_val(que_node_t*)"
"eval_to_binary(func_node_t*)" -> "eval_node_get_int_val(que_node_t*)"
"eval_to_binary(func_node_t*)" -> "dtype_get_mtype(const dtype_t*)"
"eval_to_binary(func_node_t*)" -> "ut_dbg_assertion_failed(const char*,const char*,ulint)"
"eval_to_binary(func_node_t*)" -> "abort()"
"eval_binary_to_number(func_node_t*)" -> "ut_dbg_assertion_failed(const char*,const char*,ulint)"
"eval_binary_to_number(func_node_t*)" -> "ut_memcpy(void*,const void*,ulint)"
"eval_binary_to_number(func_node_t*)" -> "eval_node_copy_and_alloc_val(que_node_t*,const unsigned char*,ulint)"
"eval_binary_to_number(func_node_t*)" -> "que_node_get_val(que_node_t*)"
"eval_binary_to_number(func_node_t*)" -> "dfield_get_len(const dfield_t*)"
"eval_binary_to_number(func_node_t*)" -> "abort()"
"eval_node_copy_and_alloc_val(que_node_t*,const unsigned char*,ulint)" -> "eval_node_ensure_val_buf(que_node_t*,ulint)"
"eval_node_copy_and_alloc_val(que_node_t*,const unsigned char*,ulint)" -> "dfield_set_len(dfield_t*,ulint)"
"eval_node_copy_and_alloc_val(que_node_t*,const unsigned char*,ulint)" -> "ut_memcpy(void*,const void*,ulint)"
"eval_node_copy_and_alloc_val(que_node_t*,const unsigned char*,ulint)" -> "que_node_get_val(que_node_t*)"
"eval_replstr(func_node_t*)" -> "eval_node_get_int_val(que_node_t*)"
"eval_replstr(func_node_t*)" -> "ut_memcpy(void*,const void*,ulint)"
"eval_replstr(func_node_t*)" -> "abort()"
"eval_replstr(func_node_t*)" -> "que_node_get_val(que_node_t*)"
"eval_replstr(func_node_t*)" -> "que_node_get_next(que_node_t*)"
"eval_replstr(func_node_t*)" -> "ut_dbg_assertion_failed(const char*,const char*,ulint)"
"eval_replstr(func_node_t*)" -> "dfield_get_len(const dfield_t*)"
"eval_substr(func_node_t*)" -> "que_node_get_next(que_node_t*)"
"eval_substr(func_node_t*)" -> "dfield_set_data(dfield_t*,const void*,ulint)"
"eval_substr(func_node_t*)" -> "que_node_get_val(que_node_t*)"
"eval_substr(func_node_t*)" -> "eval_node_get_int_val(que_node_t*)"
"eval_predefined(func_node_t*)" -> "dfield_get_len(const dfield_t*)"
"eval_predefined(func_node_t*)" -> "eval_node_set_int_val(que_node_t*,lint)"
"eval_predefined(func_node_t*)" -> "eval_node_ensure_val_buf(que_node_t*,ulint)"
"eval_predefined(func_node_t*)" -> "atoi(const char*)"
"eval_predefined(func_node_t*)" -> "eval_predefined_2(func_node_t*)"
"eval_predefined(func_node_t*)" -> "que_node_get_val(que_node_t*)"
"eval_predefined(func_node_t*)" -> "ut_time()"
"eval_predefined(func_node_t*)" -> "eval_node_get_int_val(que_node_t*)"
"eval_predefined(func_node_t*)" -> "dfield_set_len(dfield_t*,ulint)"
"eval_predefined_2(func_node_t*)" -> "_IO_putc(int,_IO_FILE*)"
"eval_predefined_2(func_node_t*)" -> "abort()"
"eval_predefined_2(func_node_t*)" -> "que_node_get_val(que_node_t*)"
"eval_predefined_2(func_node_t*)" -> "ut_dbg_assertion_failed(const char*,const char*,ulint)"
"eval_predefined_2(func_node_t*)" -> "__builtin_expect(long int,long int)"
"eval_predefined_2(func_node_t*)" -> "dfield_print(const dfield_t*)"
"eval_predefined_2(func_node_t*)" -> "eval_node_get_ibool_val(que_node_t*)"
"eval_predefined_2(func_node_t*)" -> "ut_rnd_gen_next_ulint(ulint)"
"eval_predefined_2(func_node_t*)" -> "__builtin_fwrite(const void*,size_t,size_t,FILE*)"
"eval_predefined_2(func_node_t*)" -> "eval_node_get_int_val(que_node_t*)"
"eval_predefined_2(func_node_t*)" -> "que_node_get_next(que_node_t*)"
"eval_predefined_2(func_node_t*)" -> "eval_node_set_int_val(que_node_t*,lint)"
"eval_predefined_2(func_node_t*)" -> "eval_node_ensure_val_buf(que_node_t*,ulint)"
"dfield_print(const dfield_t*)" -> "__builtin_expect(long int,long int)"
"dfield_print(const dfield_t*)" -> "abort()"
"dfield_print(const dfield_t*)" -> "dfield_is_ext(const dfield_t*)"
"dfield_print(const dfield_t*)" -> "__builtin_fwrite(const void*,size_t,size_t,FILE*)"
"dfield_print(const dfield_t*)" -> "dtype_get_mtype(const dtype_t*)"
"dfield_print(const dfield_t*)" -> "dfield_get_len(const dfield_t*)"
"dfield_print(const dfield_t*)" -> "_IO_putc(int,_IO_FILE*)"
"dfield_print(const dfield_t*)" -> "dfield_is_null(const dfield_t*)"
"dfield_print(const dfield_t*)" -> "mach_read_from_4(const unsigned char*)"
"dfield_print(const dfield_t*)" -> "isprint(int)"
"dfield_print(const dfield_t*)" -> "ut_dbg_assertion_failed(const char*,const char*,ulint)"
"dfield_print(const dfield_t*)" -> "fprintf(FILE*,const char*,...)"
"eval_cmp(func_node_t*)" -> "que_node_get_next(que_node_t*)"
"eval_cmp(func_node_t*)" -> "cmp_dfield_dfield(const dfield_t*,const dfield_t*)"
"eval_cmp(func_node_t*)" -> "eval_cmp_like(que_node_t*,que_node_t*)"
"eval_cmp(func_node_t*)" -> "eval_node_set_ibool_val(func_node_t*,ulint)"
"eval_cmp(func_node_t*)" -> "que_node_get_val(que_node_t*)"
"eval_cmp_like(que_node_t*,que_node_t*)" -> "cmp_dfield_dfield(const dfield_t*,const dfield_t*)"
"eval_cmp_like(que_node_t*,que_node_t*)" -> "cmp_dfield_dfield_like_suffix(dfield_t*,dfield_t*)"
"eval_cmp_like(que_node_t*,que_node_t*)" -> "cmp_dfield_dfield_like_prefix(dfield_t*,dfield_t*)"
"eval_cmp_like(que_node_t*,que_node_t*)" -> "ut_dbg_assertion_failed(const char*,const char*,ulint)"
"eval_cmp_like(que_node_t*,que_node_t*)" -> "que_node_get_next(que_node_t*)"
"eval_cmp_like(que_node_t*,que_node_t*)" -> "que_node_get_like_node(que_node_t*)"
"eval_cmp_like(que_node_t*,que_node_t*)" -> "abort()"
"eval_cmp_like(que_node_t*,que_node_t*)" -> "__builtin_expect(long int,long int)"
"eval_cmp_like(que_node_t*,que_node_t*)" -> "cmp_dfield_dfield_like_substr(dfield_t*,dfield_t*)"
"eval_cmp_like(que_node_t*,que_node_t*)" -> "dtype_get_mtype(const dtype_t*)"
"eval_cmp_like(que_node_t*,que_node_t*)" -> "mach_read_from_4(const unsigned char*)"
"eval_cmp_like(que_node_t*,que_node_t*)" -> "que_node_get_val(que_node_t*)"
"cmp_dfield_dfield_like_suffix(dfield_t*,dfield_t*)" -> "dfield_get_len(const dfield_t*)"
"cmp_dfield_dfield_like_suffix(dfield_t*,dfield_t*)" -> "cmp_data_data_like_suffix(unsigned char*,ulint,unsigned char*,ulint)"
"cmp_data_data_like_suffix(unsigned char*,ulint,unsigned char*,ulint)" -> "cmp_data_data_slow_like_suffix(const unsigned char*,ulint,const unsigned char*,ulint)"
"cmp_data_data_slow_like_suffix(const unsigned char*,ulint,const unsigned char*,ulint)" -> "ut_dbg_assertion_failed(const char*,const char*,ulint)"
"cmp_data_data_slow_like_suffix(const unsigned char*,ulint,const unsigned char*,ulint)" -> "abort()"
"cmp_dfield_dfield_like_prefix(dfield_t*,dfield_t*)" -> "dfield_get_len(const dfield_t*)"
"cmp_dfield_dfield_like_prefix(dfield_t*,dfield_t*)" -> "dtype_get_charset_coll(ulint)"
"cmp_dfield_dfield_like_prefix(dfield_t*,dfield_t*)" -> "cmp_data_data_like_prefix(unsigned char*,ulint,unsigned char*,ulint)"
"cmp_dfield_dfield_like_prefix(dfield_t*,dfield_t*)" -> "innobase_mysql_cmp_prefix(int,uint,const unsigned char*,unsigned int,const unsigned char*,unsigned int)"
"cmp_data_data_like_prefix(unsigned char*,ulint,unsigned char*,ulint)" -> "cmp_data_data_slow_like_prefix(const unsigned char*,ulint,const unsigned char*,ulint)"
"cmp_data_data_slow_like_prefix(const unsigned char*,ulint,const unsigned char*,ulint)" -> "cmp_collate(ulint)"
"cmp_data_data_slow_like_prefix(const unsigned char*,ulint,const unsigned char*,ulint)" -> "ut_dbg_assertion_failed(const char*,const char*,ulint)"
"cmp_data_data_slow_like_prefix(const unsigned char*,ulint,const unsigned char*,ulint)" -> "abort()"
"cmp_data_data_slow_like_prefix(const unsigned char*,ulint,const unsigned char*,ulint)" -> "__builtin_expect(long int,long int)"
"innobase_mysql_cmp_prefix(int,uint,const unsigned char*,unsigned int,const unsigned char*,unsigned int)" -> "ha_compare_text(const CHARSET_INFO*,uchar*,uint,uchar*,uint,my_bool,my_bool)"
"innobase_mysql_cmp_prefix(int,uint,const unsigned char*,unsigned int,const unsigned char*,unsigned int)" -> "innobase_get_fts_charset(int,uint)"
"innobase_get_fts_charset(int,uint)" -> "ut_dbg_assertion_failed(const char*,const char*,ulint)"
"innobase_get_fts_charset(int,uint)" -> "sql_print_error(const char*,...)"
"innobase_get_fts_charset(int,uint)" -> "get_charset(uint,myf)"
"innobase_get_fts_charset(int,uint)" -> "abort()"
"cmp_dfield_dfield_like_substr(dfield_t*,dfield_t*)" -> "dfield_get_len(const dfield_t*)"
"cmp_dfield_dfield_like_substr(dfield_t*,dfield_t*)" -> "cmp_data_data_like_substr(unsigned char*,ulint,unsigned char*,ulint)"
"cmp_data_data_like_substr(unsigned char*,ulint,unsigned char*,ulint)" -> "cmp_data_data_slow_like_substr(const unsigned char*,ulint,const unsigned char*,ulint)"
"cmp_data_data_slow_like_substr(const unsigned char*,ulint,const unsigned char*,ulint)" -> "abort()"
"cmp_data_data_slow_like_substr(const unsigned char*,ulint,const unsigned char*,ulint)" -> "ut_dbg_assertion_failed(const char*,const char*,ulint)"
"eval_aggregate(func_node_t*)" -> "eval_node_set_int_val(que_node_t*,lint)"
"eval_aggregate(func_node_t*)" -> "eval_node_get_int_val(que_node_t*)"
"eval_sym(sym_node_t*)" -> "dfield_copy_data(dfield_t*,const dfield_t*)"
"eval_sym(sym_node_t*)" -> "que_node_get_val(que_node_t*)"
"return_step(que_thr_t*)" -> "que_node_get_parent(que_node_t*)"
"return_step(que_thr_t*)" -> "que_node_get_type(que_node_t*)"
"return_step(que_thr_t*)" -> "__builtin_expect(long int,long int)"
"return_step(que_thr_t*)" -> "ut_dbg_assertion_failed(const char*,const char*,ulint)"
"return_step(que_thr_t*)" -> "abort()"
"dict_create_table_step(que_thr_t*)" -> "dict_table_add_to_cache(dict_table_t*,ulint,mem_heap_t*)"
"dict_create_table_step(que_thr_t*)" -> "thr_get_trx(que_thr_t*)"
"dict_create_table_step(que_thr_t*)" -> "dict_build_table_def_step(que_thr_t*,tab_node_t*)"
"dict_create_table_step(que_thr_t*)" -> "dict_build_col_def_step(tab_node_t*)"
"dict_create_table_step(que_thr_t*)" -> "que_node_get_parent(que_node_t*)"
"dict_table_add_to_cache(dict_table_t*,ulint,mem_heap_t*)" -> "dict_table_add_system_columns(dict_table_t*,mem_heap_t*)"
"dict_table_add_to_cache(dict_table_t*,ulint,mem_heap_t*)" -> "ut_dbg_assertion_failed(const char*,const char*,ulint)"
"dict_table_add_to_cache(dict_table_t*,ulint,mem_heap_t*)" -> "ut_strcmp(const char*,const char*)"
"dict_table_add_to_cache(dict_table_t*,ulint,mem_heap_t*)" -> "ut_fold_ull(ib_uint64_t)"
"dict_table_add_to_cache(dict_table_t*,ulint,mem_heap_t*)" -> "strlen(const char*)"
"dict_table_add_to_cache(dict_table_t*,ulint,mem_heap_t*)" -> "mem_heap_get_size(mem_heap_t*)"
"dict_table_add_to_cache(dict_table_t*,ulint,mem_heap_t*)" -> "dict_col_get_max_size(const dict_col_t*)"
"dict_table_add_to_cache(dict_table_t*,ulint,mem_heap_t*)" -> "hash_calc_hash(ulint,hash_table_t*)"
"dict_table_add_to_cache(dict_table_t*,ulint,mem_heap_t*)" -> "ut_fold_string(const char*)"
"dict_table_add_to_cache(dict_table_t*,ulint,mem_heap_t*)" -> "hash_get_nth_cell(hash_table_t*,ulint)"
"dict_table_add_to_cache(dict_table_t*,ulint,mem_heap_t*)" -> "ut_list_prepend(List&,Type&,size_t) [with List = ut_list_base<dict_table_t>,Type = dict_table_t,size_t = long unsigned int]"
"dict_table_add_to_cache(dict_table_t*,ulint,mem_heap_t*)" -> "abort()"
"dict_table_add_to_cache(dict_table_t*,ulint,mem_heap_t*)" -> "__builtin_expect(long int,long int)"
"dict_col_get_max_size(const dict_col_t*)" -> "dtype_get_max_size_low(ulint,ulint)"
"dtype_get_max_size_low(ulint,ulint)" -> "ut_dbg_assertion_failed(const char*,const char*,ulint)"
"dtype_get_max_size_low(ulint,ulint)" -> "abort()"
"dict_build_table_def_step(que_thr_t*,tab_node_t*)" -> "ins_node_set_new_row(ins_node_t*,dtuple_t*)"
"dict_build_table_def_step(que_thr_t*,tab_node_t*)" -> "dict_tf_to_fsp_flags(ulint)"
"dict_build_table_def_step(que_thr_t*,tab_node_t*)" -> "mtr_commit(mtr_t*)"
"dict_build_table_def_step(que_thr_t*,tab_node_t*)" -> "thr_get_trx(que_thr_t*)"
"dict_build_table_def_step(que_thr_t*,tab_node_t*)" -> "fsp_header_init(ulint,ulint,mtr_t*)"
"dict_build_table_def_step(que_thr_t*,tab_node_t*)" -> "dict_create_sys_tables_tuple(const dict_table_t*,mem_heap_t*)"
"dict_build_table_def_step(que_thr_t*,tab_node_t*)" -> "fil_create_new_single_table_tablespace(ulint,const char*,const char*,ulint,ulint,ulint)"
"dict_build_table_def_step(que_thr_t*,tab_node_t*)" -> "mtr_start(mtr_t*)"
"dict_build_table_def_step(que_thr_t*,tab_node_t*)" -> "dict_hdr_get_new_id(table_id_t*,index_id_t*,ulint*)"
"dict_build_table_def_step(que_thr_t*,tab_node_t*)" -> "__builtin_expect(long int,long int)"
"ins_node_set_new_row(ins_node_t*,dtuple_t*)" -> "ins_node_create_entry_list(ins_node_t*)"
"ins_node_set_new_row(ins_node_t*,dtuple_t*)" -> "mem_heap_empty(mem_heap_t*)"
"ins_node_set_new_row(ins_node_t*,dtuple_t*)" -> "row_ins_alloc_sys_fields(ins_node_t*)"
"ins_node_create_entry_list(ins_node_t*)" -> "ut_list_append(List&,Type&,size_t) [with List = ut_list_base<dtuple_t>,Type = dtuple_t,size_t = long unsigned int]"
"ins_node_create_entry_list(ins_node_t*)" -> "row_build_index_entry(const dtuple_t*,const row_ext_t*,dict_index_t*,mem_heap_t*)"
"ut_list_append(List&,Type&,size_t) [with List = ut_list_base<dtuple_t>,Type = dtuple_t,size_t = long unsigned int]" -> "ut_elem_get_node(Type&,size_t) [with Type = dtuple_t,size_t = long unsigned int]"
"ut_elem_get_node(Type&,size_t) [with Type = dtuple_t,size_t = long unsigned int]" -> "__builtin_expect(long int,long int)"
"ut_elem_get_node(Type&,size_t) [with Type = dtuple_t,size_t = long unsigned int]" -> "ut_dbg_assertion_failed(const char*,const char*,ulint)"
"ut_elem_get_node(Type&,size_t) [with Type = dtuple_t,size_t = long unsigned int]" -> "abort()"
"row_ins_alloc_sys_fields(ins_node_t*)" -> "dict_col_get_no(const dict_col_t*)"
"row_ins_alloc_sys_fields(ins_node_t*)" -> "dfield_set_data(dfield_t*,const void*,ulint)"
"row_ins_alloc_sys_fields(ins_node_t*)" -> "mem_heap_zalloc(mem_heap_t*,ulint)"
"fsp_header_init(ulint,ulint,mtr_t*)" -> "fil_space_get_latch(ulint,ulint*)"
"fsp_header_init(ulint,ulint,mtr_t*)" -> "mlog_write_ulint(unsigned char*,ulint,unsigned char,mtr_t*)"
"fsp_header_init(ulint,ulint,mtr_t*)" -> "flst_init(flst_base_node_t*,mtr_t*)"
"fsp_header_init(ulint,ulint,mtr_t*)" -> "mlog_write_ull(unsigned char*,ib_uint64_t,mtr_t*)"
"fsp_header_init(ulint,ulint,mtr_t*)" -> "mtr_x_lock_func(rw_lock_t*,const char*,ulint,mtr_t*)"
"fsp_header_init(ulint,ulint,mtr_t*)" -> "fsp_flags_get_zip_size(ulint)"
"fsp_header_init(ulint,ulint,mtr_t*)" -> "btr_create(ulint,ulint,ulint,index_id_t,dict_index_t*,mtr_t*)"
"fsp_header_init(ulint,ulint,mtr_t*)" -> "fsp_init_file_page(buf_block_t*,mtr_t*)"
"fsp_header_init(ulint,ulint,mtr_t*)" -> "fsp_fill_free_list(ulint,ulint,fsp_header_t*,mtr_t*)"
"fsp_header_init(ulint,ulint,mtr_t*)" -> "buf_page_create(ulint,ulint,ulint,mtr_t*)"
"fsp_header_init(ulint,ulint,mtr_t*)" -> "buf_page_get_gen(ulint,ulint,ulint,ulint,buf_block_t*,ulint,const char*,ulint,mtr_t*)"
"btr_create(ulint,ulint,ulint,index_id_t,dict_index_t*,mtr_t*)" -> "btr_page_set_index_id(ib_page_t*,page_zip_des_t*,index_id_t,mtr_t*)"
"btr_create(ulint,ulint,ulint,index_id_t,dict_index_t*,mtr_t*)" -> "btr_page_set_next(ib_page_t*,page_zip_des_t*,ulint,mtr_t*)"
"btr_create(ulint,ulint,ulint,index_id_t,dict_index_t*,mtr_t*)" -> "btr_free_root(ulint,ulint,ulint,mtr_t*)"
"btr_create(ulint,ulint,ulint,index_id_t,dict_index_t*,mtr_t*)" -> "page_create_zip(buf_block_t*,dict_index_t*,ulint,trx_id_t,mtr_t*)"
"btr_create(ulint,ulint,ulint,index_id_t,dict_index_t*,mtr_t*)" -> "fseg_alloc_free_page_general(fseg_header_t*,ulint,unsigned char,ulint,mtr_t*,mtr_t*)"
"btr_create(ulint,ulint,ulint,index_id_t,dict_index_t*,mtr_t*)" -> "buf_block_get_page_no(const buf_block_t*)"
"btr_create(ulint,ulint,ulint,index_id_t,dict_index_t*,mtr_t*)" -> "dict_table_is_comp(const dict_table_t*)"
"btr_create(ulint,ulint,ulint,index_id_t,dict_index_t*,mtr_t*)" -> "flst_init(flst_base_node_t*,mtr_t*)"
"btr_create(ulint,ulint,ulint,index_id_t,dict_index_t*,mtr_t*)" -> "ibuf_reset_free_bits(buf_block_t*)"
"btr_create(ulint,ulint,ulint,index_id_t,dict_index_t*,mtr_t*)" -> "page_create(buf_block_t*,mtr_t*,ulint)"
"btr_create(ulint,ulint,ulint,index_id_t,dict_index_t*,mtr_t*)" -> "btr_page_set_prev(ib_page_t*,page_zip_des_t*,ulint,mtr_t*)"
"btr_create(ulint,ulint,ulint,index_id_t,dict_index_t*,mtr_t*)" -> "fseg_create(ulint,ulint,ulint,mtr_t*)"
"btr_create(ulint,ulint,ulint,index_id_t,dict_index_t*,mtr_t*)" -> "btr_page_set_level(ib_page_t*,page_zip_des_t*,ulint,mtr_t*)"
"btr_free_root(ulint,ulint,ulint,mtr_t*)" -> "btr_block_get_func(ulint,ulint,ulint,ulint,const char*,ulint,mtr_t*)"
"btr_free_root(ulint,ulint,ulint,mtr_t*)" -> "ut_dbg_assertion_failed(const char*,const char*,ulint)"
"btr_free_root(ulint,ulint,ulint,mtr_t*)" -> "fseg_free_step(fseg_header_t*,mtr_t*)"
"btr_free_root(ulint,ulint,ulint,mtr_t*)" -> "btr_search_drop_page_hash_index(buf_block_t*)"
"btr_free_root(ulint,ulint,ulint,mtr_t*)" -> "abort()"
"btr_free_root(ulint,ulint,ulint,mtr_t*)" -> "btr_root_fseg_validate(const fseg_header_t*,ulint)"
"btr_free_root(ulint,ulint,ulint,mtr_t*)" -> "__builtin_expect(long int,long int)"
"fseg_create(ulint,ulint,ulint,mtr_t*)" -> "fseg_create_general(ulint,ulint,ulint,ulint,mtr_t*)"
"dict_create_sys_tables_tuple(const dict_table_t*,mem_heap_t*)" -> "abort()"
"dict_create_sys_tables_tuple(const dict_table_t*,mem_heap_t*)" -> "dfield_set_null(dfield_t*)"
"dict_create_sys_tables_tuple(const dict_table_t*,mem_heap_t*)" -> "dtuple_create(mem_heap_t*,ulint)"
"dict_create_sys_tables_tuple(const dict_table_t*,mem_heap_t*)" -> "dict_table_copy_types(dtuple_t*,const dict_table_t*)"
"dict_create_sys_tables_tuple(const dict_table_t*,mem_heap_t*)" -> "dict_tf_to_sys_tables_type(ulint)"
"dict_create_sys_tables_tuple(const dict_table_t*,mem_heap_t*)" -> "ut_dbg_assertion_failed(const char*,const char*,ulint)"
"dict_create_sys_tables_tuple(const dict_table_t*,mem_heap_t*)" -> "ut_strlen(const char*)"
"dict_create_sys_tables_tuple(const dict_table_t*,mem_heap_t*)" -> "mach_write_to_4(unsigned char*,ulint)"
"dict_create_sys_tables_tuple(const dict_table_t*,mem_heap_t*)" -> "dfield_set_data(dfield_t*,const void*,ulint)"
"dict_create_sys_tables_tuple(const dict_table_t*,mem_heap_t*)" -> "mem_heap_zalloc(mem_heap_t*,ulint)"
"dict_create_sys_tables_tuple(const dict_table_t*,mem_heap_t*)" -> "mach_write_to_8(void*,ib_uint64_t)"
"dict_create_sys_tables_tuple(const dict_table_t*,mem_heap_t*)" -> "mem_heap_alloc(mem_heap_t*,ulint)"
"dict_create_sys_tables_tuple(const dict_table_t*,mem_heap_t*)" -> "__builtin_expect(long int,long int)"
"dict_tf_to_sys_tables_type(ulint)" -> "ut_dbg_assertion_failed(const char*,const char*,ulint)"
"dict_tf_to_sys_tables_type(ulint)" -> "dict_tf_is_valid(ulint)"
"dict_tf_to_sys_tables_type(ulint)" -> "__builtin_expect(long int,long int)"
"dict_tf_to_sys_tables_type(ulint)" -> "abort()"
"fil_create_new_single_table_tablespace(ulint,const char*,const char*,ulint,ulint,ulint)" -> "abort()"
"fil_create_new_single_table_tablespace(ulint,const char*,const char*,ulint,ulint,ulint)" -> "mtr_start(mtr_t*)"
"fil_create_new_single_table_tablespace(ulint,const char*,const char*,ulint,ulint,ulint)" -> "pfs_os_file_delete_func(mysql_pfs_key_t,const char*,const char*,ulint)"
"fil_create_new_single_table_tablespace(ulint,const char*,const char*,ulint,ulint,ulint)" -> "ut_free(void*)"
"fil_create_new_single_table_tablespace(ulint,const char*,const char*,ulint,ulint,ulint)" -> "fsp_header_init_fields(ib_page_t*,ulint,ulint)"
"fil_create_new_single_table_tablespace(ulint,const char*,const char*,ulint,ulint,ulint)" -> "mem_free_func(void*,const char*,ulint)"
"fil_create_new_single_table_tablespace(ulint,const char*,const char*,ulint,ulint,ulint)" -> "os_file_set_size(const char*,os_file_t,os_offset_t)"
"fil_create_new_single_table_tablespace(ulint,const char*,const char*,ulint,ulint,ulint)" -> "memset(void*,int,size_t)"
"fil_create_new_single_table_tablespace(ulint,const char*,const char*,ulint,ulint,ulint)" -> "fil_make_ibd_name(const char*,bool)"
"fil_create_new_single_table_tablespace(ulint,const char*,const char*,ulint,ulint,ulint)" -> "fil_space_create(const char*,ulint,ulint,ulint)"
"fil_create_new_single_table_tablespace(ulint,const char*,const char*,ulint,ulint,ulint)" -> "mach_write_to_4(unsigned char*,ulint)"
"fil_create_new_single_table_tablespace(ulint,const char*,const char*,ulint,ulint,ulint)" -> "ib_logf(ib_log_level_t,const char*,...)"
"fil_create_new_single_table_tablespace(ulint,const char*,const char*,ulint,ulint,ulint)" -> "buf_flush_init_for_writing(unsigned char*,void*,lsn_t)"
"fil_create_new_single_table_tablespace(ulint,const char*,const char*,ulint,ulint,ulint)" -> "pfs_os_file_flush_func(os_file_t,const char*,ulint)"
"fil_create_new_single_table_tablespace(ulint,const char*,const char*,ulint,ulint,ulint)" -> "fil_delete_link_file(const char*)"
"fil_create_new_single_table_tablespace(ulint,const char*,const char*,ulint,ulint,ulint)" -> "os_file_create_subdirs_if_needed(const char*)"
"fil_create_new_single_table_tablespace(ulint,const char*,const char*,ulint,ulint,ulint)" -> "pfs_os_file_create_func(mysql_pfs_key_t,const char*,ulint,ulint,ulint,ulint*,const char*,ulint)"
"fil_create_new_single_table_tablespace(ulint,const char*,const char*,ulint,ulint,ulint)" -> "fsp_flags_is_compressed(ulint)"
"fil_create_new_single_table_tablespace(ulint,const char*,const char*,ulint,ulint,ulint)" -> "fil_op_write_log(ulint,ulint,ulint,ulint,const char*,const char*,mtr_t*)"
"fil_create_new_single_table_tablespace(ulint,const char*,const char*,ulint,ulint,ulint)" -> "ut_malloc_low(ulint,ulint)"
"fil_create_new_single_table_tablespace(ulint,const char*,const char*,ulint,ulint,ulint)" -> "os_file_make_remote_pathname(const char*,const char*,const char*)"
"fil_create_new_single_table_tablespace(ulint,const char*,const char*,ulint,ulint,ulint)" -> "pfs_os_file_close_func(os_file_t,const char*,ulint)"
"fil_create_new_single_table_tablespace(ulint,const char*,const char*,ulint,ulint,ulint)" -> "pfs_os_file_write_func(const char*,os_file_t,const void*,os_offset_t,ulint,const char*,ulint)"
"fil_create_new_single_table_tablespace(ulint,const char*,const char*,ulint,ulint,ulint)" -> "__builtin_expect(long int,long int)"
"fil_create_new_single_table_tablespace(ulint,const char*,const char*,ulint,ulint,ulint)" -> "page_zip_set_size(page_zip_des_t*,ulint)"
"fil_create_new_single_table_tablespace(ulint,const char*,const char*,ulint,ulint,ulint)" -> "fsp_flags_get_zip_size(ulint)"
"fil_create_new_single_table_tablespace(ulint,const char*,const char*,ulint,ulint,ulint)" -> "ut_dbg_assertion_failed(const char*,const char*,ulint)"
"fil_create_new_single_table_tablespace(ulint,const char*,const char*,ulint,ulint,ulint)" -> "os_file_get_last_error(bool)"
"fil_create_new_single_table_tablespace(ulint,const char*,const char*,ulint,ulint,ulint)" -> "ut_align(const void*,ulint)"
"fil_create_new_single_table_tablespace(ulint,const char*,const char*,ulint,ulint,ulint)" -> "fsp_flags_is_valid(ulint)"
"fil_create_new_single_table_tablespace(ulint,const char*,const char*,ulint,ulint,ulint)" -> "fil_node_create(const char*,ulint,ulint,ulint)"
"fil_create_new_single_table_tablespace(ulint,const char*,const char*,ulint,ulint,ulint)" -> "fil_create_link_file(const char*,const char*)"
"fil_create_new_single_table_tablespace(ulint,const char*,const char*,ulint,ulint,ulint)" -> "mtr_commit(mtr_t*)"
"fil_create_new_single_table_tablespace(ulint,const char*,const char*,ulint,ulint,ulint)" -> "fsp_flags_set_page_size(ulint,ulint)"
"pfs_os_file_delete_func(mysql_pfs_key_t,const char*,const char*,ulint)" -> "os_file_delete_func(const char*)"
"pfs_os_file_delete_func(mysql_pfs_key_t,const char*,const char*,ulint)" -> "__builtin_expect(long int,long int)"
"os_file_delete_func(const char*)" -> "unlink(const char*)"
"os_file_delete_func(const char*)" -> "os_file_handle_error_no_exit(const char*,const char*,ulint)"
"fsp_header_init_fields(ib_page_t*,ulint,ulint)" -> "abort()"
"fsp_header_init_fields(ib_page_t*,ulint,ulint)" -> "ut_dbg_assertion_failed(const char*,const char*,ulint)"
"fsp_header_init_fields(ib_page_t*,ulint,ulint)" -> "mach_write_to_4(unsigned char*,ulint)"
"fsp_header_init_fields(ib_page_t*,ulint,ulint)" -> "__builtin_expect(long int,long int)"
"fsp_header_init_fields(ib_page_t*,ulint,ulint)" -> "fsp_flags_is_valid(ulint)"
"os_file_set_size(const char*,os_file_t,os_offset_t)" -> "fprintf(FILE*,const char*,...)"
"os_file_set_size(const char*,os_file_t,os_offset_t)" -> "pfs_os_file_flush_func(os_file_t,const char*,ulint)"
"os_file_set_size(const char*,os_file_t,os_offset_t)" -> "ut_free(void*)"
"os_file_set_size(const char*,os_file_t,os_offset_t)" -> "__builtin_fputc(int,FILE*)"
"os_file_set_size(const char*,os_file_t,os_offset_t)" -> "ut_malloc_low(ulint,ulint)"
"os_file_set_size(const char*,os_file_t,os_offset_t)" -> "pfs_os_file_write_func(const char*,os_file_t,const void*,os_offset_t,ulint,const char*,ulint)"
"os_file_set_size(const char*,os_file_t,os_offset_t)" -> "ut_align(const void*,ulint)"
"os_file_set_size(const char*,os_file_t,os_offset_t)" -> "memset(void*,int,size_t)"
"os_file_set_size(const char*,os_file_t,os_offset_t)" -> "ut_min(ulint,ulint)"
"os_file_set_size(const char*,os_file_t,os_offset_t)" -> "__builtin_fwrite(const void*,size_t,size_t,FILE*)"
"pfs_os_file_write_func(const char*,os_file_t,const void*,os_offset_t,ulint,const char*,ulint)" -> "__builtin_expect(long int,long int)"
"pfs_os_file_write_func(const char*,os_file_t,const void*,os_offset_t,ulint,const char*,ulint)" -> "os_file_write_func(const char*,os_file_t,const void*,os_offset_t,ulint)"
"buf_flush_init_for_writing(unsigned char*,void*,lsn_t)" -> "mach_write_to_8(void*,ib_uint64_t)"
"buf_flush_init_for_writing(unsigned char*,void*,lsn_t)" -> "buf_flush_update_zip_checksum(buf_frame_t*,ulint,lsn_t)"
"buf_flush_init_for_writing(unsigned char*,void*,lsn_t)" -> "__builtin_expect(long int,long int)"
"buf_flush_init_for_writing(unsigned char*,void*,lsn_t)" -> "__builtin_fwrite(const void*,size_t,size_t,FILE*)"
"buf_flush_init_for_writing(unsigned char*,void*,lsn_t)" -> "ut_print_timestamp(FILE*)"
"buf_flush_init_for_writing(unsigned char*,void*,lsn_t)" -> "fil_page_get_type(const unsigned char*)"
"buf_flush_init_for_writing(unsigned char*,void*,lsn_t)" -> "ut_print_buf(FILE*,const void*,ulint)"
"buf_flush_init_for_writing(unsigned char*,void*,lsn_t)" -> "memcpy(void*,const void*,size_t)"
"buf_flush_init_for_writing(unsigned char*,void*,lsn_t)" -> "mach_write_to_4(unsigned char*,ulint)"
"buf_flush_init_for_writing(unsigned char*,void*,lsn_t)" -> "_IO_putc(int,_IO_FILE*)"
"buf_flush_init_for_writing(unsigned char*,void*,lsn_t)" -> "buf_calc_page_old_checksum(const unsigned char*)"
"buf_flush_init_for_writing(unsigned char*,void*,lsn_t)" -> "buf_calc_page_crc32(const unsigned char*)"
"buf_flush_init_for_writing(unsigned char*,void*,lsn_t)" -> "buf_calc_page_new_checksum(const unsigned char*)"
"buf_flush_init_for_writing(unsigned char*,void*,lsn_t)" -> "page_zip_get_size(const page_zip_des_t*)"
"buf_flush_init_for_writing(unsigned char*,void*,lsn_t)" -> "ut_dbg_assertion_failed(const char*,const char*,ulint)"
"buf_flush_init_for_writing(unsigned char*,void*,lsn_t)" -> "abort()"
"buf_flush_update_zip_checksum(buf_frame_t*,ulint,lsn_t)" -> "abort()"
"buf_flush_update_zip_checksum(buf_frame_t*,ulint,lsn_t)" -> "mach_write_to_4(unsigned char*,ulint)"
"buf_flush_update_zip_checksum(buf_frame_t*,ulint,lsn_t)" -> "__builtin_expect(long int,long int)"
"buf_flush_update_zip_checksum(buf_frame_t*,ulint,lsn_t)" -> "memset(void*,int,size_t)"
"buf_flush_update_zip_checksum(buf_frame_t*,ulint,lsn_t)" -> "ut_dbg_assertion_failed(const char*,const char*,ulint)"
"buf_flush_update_zip_checksum(buf_frame_t*,ulint,lsn_t)" -> "page_zip_calc_checksum(const void*,ulint,srv_checksum_algorithm_t)"
"buf_flush_update_zip_checksum(buf_frame_t*,ulint,lsn_t)" -> "mach_write_to_8(void*,ib_uint64_t)"
"os_file_create_subdirs_if_needed(const char*)" -> "strlen(const char*)"
"os_file_create_subdirs_if_needed(const char*)" -> "os_file_create_directory(const char*,ulint)"
"os_file_create_subdirs_if_needed(const char*)" -> "ib_logf(ib_log_level_t,const char*,...)"
"os_file_create_subdirs_if_needed(const char*)" -> "mem_free_func(void*,const char*,ulint)"
"os_file_create_subdirs_if_needed(const char*)" -> "os_file_status(const char*,ulint*,os_file_type_t*)"
"os_file_create_subdirs_if_needed(const char*)" -> "os_file_dirname(const char*)"
"os_file_create_subdirs_if_needed(const char*)" -> "os_file_create_subdirs_if_needed(const char*)"
"os_file_create_directory(const char*,ulint)" -> "mkdir(const char*,__mode_t)"
"os_file_create_directory(const char*,ulint)" -> "os_file_handle_error_no_exit(const char*,const char*,ulint)"
"os_file_create_directory(const char*,ulint)" -> "__errno_location()"
"os_file_status(const char*,ulint*,os_file_type_t*)" -> "stat(const char*,stat*)"
"os_file_status(const char*,ulint*,os_file_type_t*)" -> "os_file_handle_error_no_exit(const char*,const char*,ulint)"
"os_file_status(const char*,ulint*,os_file_type_t*)" -> "__errno_location()"
"stat(const char*,stat*)" -> "__xstat(int,const char*,stat*)"
"os_file_dirname(const char*)" -> "mem_strdupl(const char*,ulint)"
"os_file_dirname(const char*)" -> "mem_strdup(const char*)"
"os_file_dirname(const char*)" -> "strrchr(const char*,int)"
"mem_strdupl(const char*,ulint)" -> "memcpy(void*,const void*,size_t)"
"mem_strdupl(const char*,ulint)" -> "mem_alloc_func(ulint,ulint*)"
"strrchr(const char*,int)" -> "__builtin_strrchr(const char*,int)"
"os_file_make_remote_pathname(const char*,const char*,const char*)" -> "memcpy(void*,const void*,size_t)"
"os_file_make_remote_pathname(const char*,const char*,const char*)" -> "strlen(const char*)"
"os_file_make_remote_pathname(const char*,const char*,const char*)" -> "strrchr(char*,int)"
"os_file_make_remote_pathname(const char*,const char*,const char*)" -> "srv_normalize_path_for_win(char*)"
"os_file_make_remote_pathname(const char*,const char*,const char*)" -> "snprintf(char*,size_t,const char*,...)"
"os_file_make_remote_pathname(const char*,const char*,const char*)" -> "mem_alloc_func(ulint,ulint*)"
"strrchr(char*,int)" -> "__builtin_strrchr(const char*,int)"
"fil_create_link_file(const char*,const char*)" -> "pfs_os_file_close_func(os_file_t,const char*,ulint)"
"fil_create_link_file(const char*,const char*)" -> "strcmp(const char*,const char*)"
"fil_create_link_file(const char*,const char*)" -> "fil_read_link_file(const char*)"
"fil_create_link_file(const char*,const char*)" -> "mem_free_func(void*,const char*,ulint)"
"fil_create_link_file(const char*,const char*)" -> "pfs_os_file_create_simple_no_error_handling_func(mysql_pfs_key_t,const char*,ulint,ulint,ulint*,const char*,ulint)"
"fil_create_link_file(const char*,const char*)" -> "ut_print_timestamp(FILE*)"
"fil_create_link_file(const char*,const char*)" -> "fil_make_isl_name(const char*)"
"fil_create_link_file(const char*,const char*)" -> "__builtin_fwrite(const void*,size_t,size_t,FILE*)"
"fil_create_link_file(const char*,const char*)" -> "pfs_os_file_write_func(const char*,os_file_t,const void*,os_offset_t,ulint,const char*,ulint)"
"fil_create_link_file(const char*,const char*)" -> "os_file_get_last_error(bool)"
"fil_create_link_file(const char*,const char*)" -> "strlen(const char*)"
"fil_create_link_file(const char*,const char*)" -> "ut_print_filename(FILE*,const char*)"
"dict_hdr_get_new_id(table_id_t*,index_id_t*,ulint*)" -> "mlog_write_ulint(unsigned char*,ulint,unsigned char,mtr_t*)"
"dict_hdr_get_new_id(table_id_t*,index_id_t*,ulint*)" -> "mlog_write_ull(unsigned char*,ib_uint64_t,mtr_t*)"
"dict_hdr_get_new_id(table_id_t*,index_id_t*,ulint*)" -> "mtr_start(mtr_t*)"
"dict_hdr_get_new_id(table_id_t*,index_id_t*,ulint*)" -> "fil_assign_new_space_id(ulint*)"
"dict_hdr_get_new_id(table_id_t*,index_id_t*,ulint*)" -> "mach_read_from_8(const unsigned char*)"
"dict_hdr_get_new_id(table_id_t*,index_id_t*,ulint*)" -> "dict_hdr_get(mtr_t*)"
"dict_hdr_get_new_id(table_id_t*,index_id_t*,ulint*)" -> "mtr_read_ulint(const unsigned char*,ulint,mtr_t*)"
"dict_hdr_get_new_id(table_id_t*,index_id_t*,ulint*)" -> "mtr_commit(mtr_t*)"
"fil_assign_new_space_id(ulint*)" -> "pfs_mutex_enter_func(ib_mutex_t*,const char*,ulint)"
"fil_assign_new_space_id(ulint*)" -> "ut_print_timestamp(FILE*)"
"fil_assign_new_space_id(ulint*)" -> "fprintf(FILE*,const char*,...)"
"fil_assign_new_space_id(ulint*)" -> "pfs_mutex_exit_func(ib_mutex_t*)"
"dict_hdr_get(mtr_t*)" -> "buf_page_get_gen(ulint,ulint,ulint,ulint,buf_block_t*,ulint,const char*,ulint,mtr_t*)"
"dict_build_col_def_step(tab_node_t*)" -> "ins_node_set_new_row(ins_node_t*,dtuple_t*)"
"dict_build_col_def_step(tab_node_t*)" -> "dict_create_sys_columns_tuple(const dict_table_t*,ulint,mem_heap_t*)"
"dict_create_sys_columns_tuple(const dict_table_t*,ulint,mem_heap_t*)" -> "dict_table_copy_types(dtuple_t*,const dict_table_t*)"
"dict_create_sys_columns_tuple(const dict_table_t*,ulint,mem_heap_t*)" -> "mach_write_to_4(unsigned char*,ulint)"
"dict_create_sys_columns_tuple(const dict_table_t*,ulint,mem_heap_t*)" -> "dtuple_create(mem_heap_t*,ulint)"
"dict_create_sys_columns_tuple(const dict_table_t*,ulint,mem_heap_t*)" -> "dfield_set_data(dfield_t*,const void*,ulint)"
"dict_create_sys_columns_tuple(const dict_table_t*,ulint,mem_heap_t*)" -> "ut_strlen(const char*)"
"dict_create_sys_columns_tuple(const dict_table_t*,ulint,mem_heap_t*)" -> "dict_table_get_col_name(const dict_table_t*,ulint)"
"dict_create_sys_columns_tuple(const dict_table_t*,ulint,mem_heap_t*)" -> "mach_write_to_8(void*,ib_uint64_t)"
"dict_create_sys_columns_tuple(const dict_table_t*,ulint,mem_heap_t*)" -> "mem_heap_alloc(mem_heap_t*,ulint)"
"fetch_step(que_thr_t*)" -> "thr_get_trx(que_thr_t*)"
"fetch_step(que_thr_t*)" -> "__builtin_fwrite(const void*,size_t,size_t,FILE*)"
"fetch_step(que_thr_t*)" -> "que_node_get_parent(que_node_t*)"
"fetch_step(que_thr_t*)" -> "sel_assign_into_var_values(sym_node_t*,sel_node_t*)"
"sel_assign_into_var_values(sym_node_t*,sel_node_t*)" -> "que_node_get_next(que_node_t*)"
"sel_assign_into_var_values(sym_node_t*,sel_node_t*)" -> "eval_node_copy_val(que_node_t*,que_node_t*)"
"eval_node_copy_val(que_node_t*,que_node_t*)" -> "dfield_get_len(const dfield_t*)"
"eval_node_copy_val(que_node_t*,que_node_t*)" -> "que_node_get_val(que_node_t*)"
"eval_node_copy_val(que_node_t*,que_node_t*)" -> "eval_node_copy_and_alloc_val(que_node_t*,const unsigned char*,ulint)"
"row_purge_step(que_thr_t*)" -> "row_purge_end(que_thr_t*)"
"row_purge_step(que_thr_t*)" -> "abort()"
"row_purge_step(que_thr_t*)" -> "ib_vector_pop(ib_vector_t*)"
"row_purge_step(que_thr_t*)" -> "ut_dbg_assertion_failed(const char*,const char*,ulint)"
"row_purge_step(que_thr_t*)" -> "__builtin_expect(long int,long int)"
"row_purge_step(que_thr_t*)" -> "row_purge(purge_node_t*,trx_undo_rec_t*,que_thr_t*)"
"row_purge_step(que_thr_t*)" -> "ib_vector_is_empty(const ib_vector_t*)"
"row_purge_end(que_thr_t*)" -> "mem_heap_empty(mem_heap_t*)"
"row_purge_end(que_thr_t*)" -> "abort()"
"row_purge_end(que_thr_t*)" -> "que_node_get_parent(que_node_t*)"
"row_purge_end(que_thr_t*)" -> "ut_dbg_assertion_failed(const char*,const char*,ulint)"
"row_purge_end(que_thr_t*)" -> "__builtin_expect(long int,long int)"
"row_purge(purge_node_t*,trx_undo_rec_t*,que_thr_t*)" -> "row_purge_record_func(purge_node_t*,trx_undo_rec_t*,bool)"
"row_purge(purge_node_t*,trx_undo_rec_t*,que_thr_t*)" -> "os_thread_sleep(ulint)"
"row_purge(purge_node_t*,trx_undo_rec_t*,que_thr_t*)" -> "pfs_rw_lock_s_unlock_func(rw_lock_t*)"
"row_purge(purge_node_t*,trx_undo_rec_t*,que_thr_t*)" -> "row_purge_parse_undo_rec(purge_node_t*,trx_undo_rec_t*,bool*,que_thr_t*)"
"row_purge_record_func(purge_node_t*,trx_undo_rec_t*,bool)" -> "row_purge_upd_exist_or_extern_func(purge_node_t*,trx_undo_rec_t*)"
"row_purge_record_func(purge_node_t*,trx_undo_rec_t*,bool)" -> "dict_table_close(dict_table_t*,ulint,ulint)"
"row_purge_record_func(purge_node_t*,trx_undo_rec_t*,bool)" -> "btr_pcur_close(btr_pcur_t*)"
"row_purge_record_func(purge_node_t*,trx_undo_rec_t*,bool)" -> "row_purge_del_mark(purge_node_t*)"
"row_purge_upd_exist_or_extern_func(purge_node_t*,trx_undo_rec_t*)" -> "dfield_is_ext(const dfield_t*)"
"row_purge_upd_exist_or_extern_func(purge_node_t*,trx_undo_rec_t*)" -> "upd_get_n_fields(const upd_t*)"
"row_purge_upd_exist_or_extern_func(purge_node_t*,trx_undo_rec_t*)" -> "mem_heap_empty(mem_heap_t*)"
"row_purge_upd_exist_or_extern_func(purge_node_t*,trx_undo_rec_t*)" -> "dfield_get_len(const dfield_t*)"
"row_purge_upd_exist_or_extern_func(purge_node_t*,trx_undo_rec_t*)" -> "row_purge_remove_sec_if_poss(purge_node_t*,dict_index_t*,const dtuple_t*)"
"row_purge_upd_exist_or_extern_func(purge_node_t*,trx_undo_rec_t*)" -> "buf_page_get_gen(ulint,ulint,ulint,ulint,buf_block_t*,ulint,const char*,ulint,mtr_t*)"
"row_purge_upd_exist_or_extern_func(purge_node_t*,trx_undo_rec_t*)" -> "btr_root_get(const dict_index_t*,mtr_t*)"
"row_purge_upd_exist_or_extern_func(purge_node_t*,trx_undo_rec_t*)" -> "btr_free_externally_stored_field(dict_index_t*,unsigned char*,const rec_t*,const ulint*,page_zip_des_t*,ulint,trx_rb_ctx,mtr_t*)"
"row_purge_upd_exist_or_extern_func(purge_node_t*,trx_undo_rec_t*)" -> "row_upd_changes_ord_field_binary_func(dict_index_t*,const upd_t*,const dtuple_t*,const row_ext_t*)"
"row_purge_upd_exist_or_extern_func(purge_node_t*,trx_undo_rec_t*)" -> "dict_index_is_corrupted(const dict_index_t*)"
"row_purge_upd_exist_or_extern_func(purge_node_t*,trx_undo_rec_t*)" -> "mem_heap_create_func(ulint,ulint)"
"row_purge_upd_exist_or_extern_func(purge_node_t*,trx_undo_rec_t*)" -> "row_build_index_entry_low(const dtuple_t*,const row_ext_t*,dict_index_t*,mem_heap_t*)"
"row_purge_upd_exist_or_extern_func(purge_node_t*,trx_undo_rec_t*)" -> "abort()"
"row_purge_upd_exist_or_extern_func(purge_node_t*,trx_undo_rec_t*)" -> "mem_heap_free_func(mem_heap_t*,const char*,ulint)"
"row_purge_upd_exist_or_extern_func(purge_node_t*,trx_undo_rec_t*)" -> "mtr_commit(mtr_t*)"
"row_purge_upd_exist_or_extern_func(purge_node_t*,trx_undo_rec_t*)" -> "mtr_x_lock_func(rw_lock_t*,const char*,ulint,mtr_t*)"
"row_purge_upd_exist_or_extern_func(purge_node_t*,trx_undo_rec_t*)" -> "mtr_start(mtr_t*)"
"row_purge_upd_exist_or_extern_func(purge_node_t*,trx_undo_rec_t*)" -> "ut_dbg_assertion_failed(const char*,const char*,ulint)"
"row_purge_upd_exist_or_extern_func(purge_node_t*,trx_undo_rec_t*)" -> "dict_index_get_lock(dict_index_t*)"
"row_purge_upd_exist_or_extern_func(purge_node_t*,trx_undo_rec_t*)" -> "trx_undo_decode_roll_ptr(roll_ptr_t,ulint*,ulint*,ulint*,ulint*)"
"row_purge_upd_exist_or_extern_func(purge_node_t*,trx_undo_rec_t*)" -> "trx_sys_get_nth_rseg(trx_sys_t*,ulint)"
"row_purge_upd_exist_or_extern_func(purge_node_t*,trx_undo_rec_t*)" -> "__builtin_expect(long int,long int)"
"row_purge_remove_sec_if_poss(purge_node_t*,dict_index_t*,const dtuple_t*)" -> "row_purge_remove_sec_if_poss_leaf(purge_node_t*,dict_index_t*,const dtuple_t*)"
"row_purge_remove_sec_if_poss(purge_node_t*,dict_index_t*,const dtuple_t*)" -> "abort()"
"row_purge_remove_sec_if_poss(purge_node_t*,dict_index_t*,const dtuple_t*)" -> "__builtin_expect(long int,long int)"
"row_purge_remove_sec_if_poss(purge_node_t*,dict_index_t*,const dtuple_t*)" -> "row_purge_remove_sec_if_poss_tree(purge_node_t*,dict_index_t*,const dtuple_t*)"
"row_purge_remove_sec_if_poss(purge_node_t*,dict_index_t*,const dtuple_t*)" -> "ut_dbg_assertion_failed(const char*,const char*,ulint)"
"row_purge_remove_sec_if_poss(purge_node_t*,dict_index_t*,const dtuple_t*)" -> "os_thread_sleep(ulint)"
"row_purge_remove_sec_if_poss_leaf(purge_node_t*,dict_index_t*,const dtuple_t*)" -> "rec_get_deleted_flag(const rec_t*,ulint)"
"row_purge_remove_sec_if_poss_leaf(purge_node_t*,dict_index_t*,const dtuple_t*)" -> "row_purge_poss_sec(purge_node_t*,dict_index_t*,const dtuple_t*)"
"row_purge_remove_sec_if_poss_leaf(purge_node_t*,dict_index_t*,const dtuple_t*)" -> "__builtin_fwrite(const void*,size_t,size_t,FILE*)"
"row_purge_remove_sec_if_poss_leaf(purge_node_t*,dict_index_t*,const dtuple_t*)" -> "mtr_s_lock_func(rw_lock_t*,const char*,ulint,mtr_t*)"
"row_purge_remove_sec_if_poss_leaf(purge_node_t*,dict_index_t*,const dtuple_t*)" -> "btr_cur_optimistic_delete_func(btr_cur_t*,mtr_t*)"
"row_purge_remove_sec_if_poss_leaf(purge_node_t*,dict_index_t*,const dtuple_t*)" -> "btr_pcur_close(btr_pcur_t*)"
"row_purge_remove_sec_if_poss_leaf(purge_node_t*,dict_index_t*,const dtuple_t*)" -> "dtuple_print(FILE*,const dtuple_t*)"
"row_purge_remove_sec_if_poss_leaf(purge_node_t*,dict_index_t*,const dtuple_t*)" -> "dict_table_is_comp(const dict_table_t*)"
"row_purge_remove_sec_if_poss_leaf(purge_node_t*,dict_index_t*,const dtuple_t*)" -> "dict_index_is_online_ddl(const dict_index_t*)"
"row_purge_remove_sec_if_poss_leaf(purge_node_t*,dict_index_t*,const dtuple_t*)" -> "log_free_check()"
"row_purge_remove_sec_if_poss_leaf(purge_node_t*,dict_index_t*,const dtuple_t*)" -> "abort()"
"row_purge_remove_sec_if_poss_leaf(purge_node_t*,dict_index_t*,const dtuple_t*)" -> "row_search_index_entry(dict_index_t*,const dtuple_t*,ulint,btr_pcur_t*,mtr_t*)"
"row_purge_remove_sec_if_poss_leaf(purge_node_t*,dict_index_t*,const dtuple_t*)" -> "dict_index_get_lock(dict_index_t*)"
"row_purge_remove_sec_if_poss_leaf(purge_node_t*,dict_index_t*,const dtuple_t*)" -> "que_node_get_parent(que_node_t*)"
"row_purge_remove_sec_if_poss_leaf(purge_node_t*,dict_index_t*,const dtuple_t*)" -> "dict_index_name_print(FILE*,const trx_t*,const dict_index_t*)"
"row_purge_remove_sec_if_poss_leaf(purge_node_t*,dict_index_t*,const dtuple_t*)" -> "mtr_commit(mtr_t*)"
"row_purge_remove_sec_if_poss_leaf(purge_node_t*,dict_index_t*,const dtuple_t*)" -> "_IO_putc(int,_IO_FILE*)"
"row_purge_remove_sec_if_poss_leaf(purge_node_t*,dict_index_t*,const dtuple_t*)" -> "mtr_start(mtr_t*)"
"row_purge_remove_sec_if_poss_leaf(purge_node_t*,dict_index_t*,const dtuple_t*)" -> "ut_dbg_assertion_failed(const char*,const char*,ulint)"
"row_purge_remove_sec_if_poss_leaf(purge_node_t*,dict_index_t*,const dtuple_t*)" -> "rec_print(FILE*,const rec_t*,const dict_index_t*)"
"log_free_check()" -> "log_check_margins()"
"log_check_margins()" -> "log_flush_margin()"
"log_check_margins()" -> "log_checkpoint_margin()"
"log_check_margins()" -> "pfs_mutex_enter_func(ib_mutex_t*,const char*,ulint)"
"log_check_margins()" -> "pfs_mutex_exit_func(ib_mutex_t*)"
"log_flush_margin()" -> "pfs_mutex_exit_func(ib_mutex_t*)"
"log_flush_margin()" -> "pfs_mutex_enter_func(ib_mutex_t*,const char*,ulint)"
"log_flush_margin()" -> "log_write_up_to(lsn_t,ulint,ulint)"
"log_checkpoint_margin()" -> "log_buf_pool_get_oldest_modification()"
"log_checkpoint_margin()" -> "pfs_mutex_exit_func(ib_mutex_t*)"
"log_checkpoint_margin()" -> "pfs_mutex_enter_func(ib_mutex_t*,const char*,ulint)"
"log_checkpoint_margin()" -> "log_checkpoint(ulint,ulint)"
"log_checkpoint_margin()" -> "log_preflush_pool_modified_pages(lsn_t)"
"log_buf_pool_get_oldest_modification()" -> "buf_pool_get_oldest_modification()"
"buf_pool_get_oldest_modification()" -> "pfs_mutex_exit_func(ib_mutex_t*)"
"buf_pool_get_oldest_modification()" -> "pfs_mutex_enter_func(ib_mutex_t*,const char*,ulint)"
"buf_pool_get_oldest_modification()" -> "buf_pool_from_array(ulint)"
"log_checkpoint(ulint,ulint)" -> "pfs_rw_lock_s_lock_func(rw_lock_t*,ulint,const char*,ulint)"
"log_checkpoint(ulint,ulint)" -> "recv_recovery_is_on()"
"log_checkpoint(ulint,ulint)" -> "fil_flush_file_spaces(ulint)"
"log_checkpoint(ulint,ulint)" -> "log_write_up_to(lsn_t,ulint,ulint)"
"log_checkpoint(ulint,ulint)" -> "log_buf_pool_get_oldest_modification()"
"log_checkpoint(ulint,ulint)" -> "pfs_mutex_enter_func(ib_mutex_t*,const char*,ulint)"
"log_checkpoint(ulint,ulint)" -> "log_groups_write_checkpoint_info()"
"log_checkpoint(ulint,ulint)" -> "recv_apply_hashed_log_recs(ulint)"
"log_checkpoint(ulint,ulint)" -> "pfs_mutex_exit_func(ib_mutex_t*)"
"log_checkpoint(ulint,ulint)" -> "pfs_rw_lock_s_unlock_func(rw_lock_t*)"
"log_groups_write_checkpoint_info()" -> "log_group_checkpoint(log_group_t*)"
"log_group_checkpoint(log_group_t*)" -> "pfs_rw_lock_x_lock_func(rw_lock_t*,ulint,const char*,ulint)"
"log_group_checkpoint(log_group_t*)" -> "mach_write_to_8(void*,ib_uint64_t)"
"log_group_checkpoint(log_group_t*)" -> "log_group_calc_lsn_offset(lsn_t,const log_group_t*)"
"log_group_checkpoint(log_group_t*)" -> "ut_fold_binary(const unsigned char*,ulint)"
"log_group_checkpoint(log_group_t*)" -> "mach_write_to_4(unsigned char*,ulint)"
"log_group_checkpoint(log_group_t*)" -> "log_checkpoint_set_nth_group_info(unsigned char*,ulint,ulint,ulint)"
"log_group_checkpoint(log_group_t*)" -> "fil_io(ulint,bool,ulint,ulint,ulint,ulint,ulint,void*,void*)"
"log_checkpoint_set_nth_group_info(unsigned char*,ulint,ulint,ulint)" -> "mach_write_to_4(unsigned char*,ulint)"
"recv_apply_hashed_log_recs(ulint)" -> "buf_page_get_gen(ulint,ulint,ulint,ulint,buf_block_t*,ulint,const char*,ulint,mtr_t*)"
"recv_apply_hashed_log_recs(ulint)" -> "recv_recover_page_func(ulint,buf_block_t*)"
"recv_apply_hashed_log_recs(ulint)" -> "buf_page_peek(ulint,ulint)"
"recv_apply_hashed_log_recs(ulint)" -> "ut_dbg_assertion_failed(const char*,const char*,ulint)"
"recv_apply_hashed_log_recs(ulint)" -> "recv_read_in_area(ulint,ulint,ulint)"
"recv_apply_hashed_log_recs(ulint)" -> "mtr_commit(mtr_t*)"
"recv_apply_hashed_log_recs(ulint)" -> "hash_get_n_cells(hash_table_t*)"
"recv_apply_hashed_log_recs(ulint)" -> "__builtin_fputc(int,FILE*)"
"recv_apply_hashed_log_recs(ulint)" -> "abort()"
"recv_apply_hashed_log_recs(ulint)" -> "buf_flush_wait_LRU_batch_end()"
"recv_apply_hashed_log_recs(ulint)" -> "pfs_mutex_exit_func(ib_mutex_t*)"
"recv_apply_hashed_log_recs(ulint)" -> "hash_get_nth_cell(hash_table_t*,ulint)"
"recv_apply_hashed_log_recs(ulint)" -> "os_thread_sleep(ulint)"
"recv_apply_hashed_log_recs(ulint)" -> "fprintf(FILE*,const char*,...)"
"recv_apply_hashed_log_recs(ulint)" -> "__builtin_fwrite(const void*,size_t,size_t,FILE*)"
"recv_apply_hashed_log_recs(ulint)" -> "buf_pool_invalidate()"
"recv_apply_hashed_log_recs(ulint)" -> "__builtin_expect(long int,long int)"
"recv_apply_hashed_log_recs(ulint)" -> "ib_logf(ib_log_level_t,const char*,...)"
"recv_apply_hashed_log_recs(ulint)" -> "fil_space_get_zip_size(ulint)"
"recv_apply_hashed_log_recs(ulint)" -> "mtr_start(mtr_t*)"
"recv_apply_hashed_log_recs(ulint)" -> "buf_flush_list(ulint,lsn_t,ulint*)"
"recv_apply_hashed_log_recs(ulint)" -> "recv_sys_empty_hash()"
"recv_apply_hashed_log_recs(ulint)" -> "pfs_mutex_enter_func(ib_mutex_t*,const char*,ulint)"
"recv_apply_hashed_log_recs(ulint)" -> "buf_flush_wait_batch_end(buf_pool_t*,buf_flush_t)"
"recv_read_in_area(ulint,ulint,ulint)" -> "pfs_mutex_enter_func(ib_mutex_t*,const char*,ulint)"
"recv_read_in_area(ulint,ulint,ulint)" -> "pfs_mutex_exit_func(ib_mutex_t*)"
"recv_read_in_area(ulint,ulint,ulint)" -> "buf_page_peek(ulint,ulint)"
"recv_read_in_area(ulint,ulint,ulint)" -> "recv_get_fil_addr_struct(ulint,ulint)"
"recv_read_in_area(ulint,ulint,ulint)" -> "buf_read_recv_pages(ulint,ulint,ulint,const ulint*,ulint)"
"recv_get_fil_addr_struct(ulint,ulint)" -> "hash_get_nth_cell(hash_table_t*,ulint)"
"recv_get_fil_addr_struct(ulint,ulint)" -> "recv_hash(ulint,ulint)"
"recv_hash(ulint,ulint)" -> "recv_fold(ulint,ulint)"
"recv_hash(ulint,ulint)" -> "hash_calc_hash(ulint,hash_table_t*)"
"recv_fold(ulint,ulint)" -> "ut_fold_ulint_pair(ulint,ulint)"
"buf_read_recv_pages(ulint,ulint,ulint,const ulint*,ulint)" -> "fil_space_get_zip_size(ulint)"
"buf_read_recv_pages(ulint,ulint,ulint,const ulint*,ulint)" -> "buf_pool_get(ulint,ulint)"
"buf_read_recv_pages(ulint,ulint,ulint,const ulint*,ulint)" -> "os_aio_simulated_wake_handler_threads()"
"buf_read_recv_pages(ulint,ulint,ulint,const ulint*,ulint)" -> "fprintf(FILE*,const char*,...)"
"buf_read_recv_pages(ulint,ulint,ulint,const ulint*,ulint)" -> "os_thread_sleep(ulint)"
"buf_read_recv_pages(ulint,ulint,ulint,const ulint*,ulint)" -> "fil_space_get_version(ulint)"
"buf_read_recv_pages(ulint,ulint,ulint,const ulint*,ulint)" -> "__builtin_expect(long int,long int)"
"buf_read_recv_pages(ulint,ulint,ulint,const ulint*,ulint)" -> "buf_read_page_low(dberr_t*,bool,ulint,ulint,ulint,ulint,ib_int64_t,ulint)"
"buf_flush_wait_LRU_batch_end()" -> "pfs_mutex_exit_func(ib_mutex_t*)"
"buf_flush_wait_LRU_batch_end()" -> "pfs_mutex_enter_func(ib_mutex_t*,const char*,ulint)"
"buf_flush_wait_LRU_batch_end()" -> "buf_flush_wait_batch_end(buf_pool_t*,buf_flush_t)"
"buf_flush_wait_LRU_batch_end()" -> "buf_pool_from_array(ulint)"
"buf_pool_invalidate()" -> "buf_pool_invalidate_instance(buf_pool_t*)"
"buf_pool_invalidate()" -> "buf_pool_from_array(ulint)"
"buf_pool_invalidate_instance(buf_pool_t*)" -> "buf_refresh_io_stats(buf_pool_t*)"
"buf_pool_invalidate_instance(buf_pool_t*)" -> "buf_flush_wait_batch_end(buf_pool_t*,buf_flush_t)"
"buf_pool_invalidate_instance(buf_pool_t*)" -> "buf_LRU_scan_and_free_block(buf_pool_t*,ulint)"
"buf_pool_invalidate_instance(buf_pool_t*)" -> "memset(void*,int,size_t)"
"buf_pool_invalidate_instance(buf_pool_t*)" -> "pfs_mutex_exit_func(ib_mutex_t*)"
"buf_pool_invalidate_instance(buf_pool_t*)" -> "pfs_mutex_enter_func(ib_mutex_t*,const char*,ulint)"
"buf_refresh_io_stats(buf_pool_t*)" -> "ut_time()"
"buf_LRU_scan_and_free_block(buf_pool_t*,ulint)" -> "buf_LRU_free_from_unzip_LRU_list(buf_pool_t*,ulint)"
"buf_LRU_scan_and_free_block(buf_pool_t*,ulint)" -> "buf_LRU_free_from_common_LRU_list(buf_pool_t*,ulint)"
"buf_LRU_free_from_unzip_LRU_list(buf_pool_t*,ulint)" -> "buf_LRU_free_page(buf_page_t*,bool)"
"buf_LRU_free_from_unzip_LRU_list(buf_pool_t*,ulint)" -> "buf_LRU_evict_from_unzip_LRU(buf_pool_t*)"
"buf_LRU_free_from_common_LRU_list(buf_pool_t*,ulint)" -> "buf_page_is_accessed(const buf_page_t*)"
"buf_LRU_free_from_common_LRU_list(buf_pool_t*,ulint)" -> "buf_LRU_free_page(buf_page_t*,bool)"
"buf_flush_list(ulint,lsn_t,ulint*)" -> "buf_flush_common(buf_flush_t,ulint)"
"buf_flush_list(ulint,lsn_t,ulint*)" -> "buf_flush_start(buf_pool_t*,buf_flush_t)"
"buf_flush_list(ulint,lsn_t,ulint*)" -> "buf_flush_end(buf_pool_t*,buf_flush_t)"
"buf_flush_list(ulint,lsn_t,ulint*)" -> "buf_pool_from_array(ulint)"
"buf_flush_list(ulint,lsn_t,ulint*)" -> "buf_flush_batch(buf_pool_t*,buf_flush_t,ulint,lsn_t)"
"buf_flush_common(buf_flush_t,ulint)" -> "ut_dbg_assertion_failed(const char*,const char*,ulint)"
"buf_flush_common(buf_flush_t,ulint)" -> "buf_dblwr_flush_buffered_writes()"
"buf_flush_common(buf_flush_t,ulint)" -> "__builtin_expect(long int,long int)"
"buf_flush_common(buf_flush_t,ulint)" -> "Indexer>::add(Type) [with Type = long unsigned int,int N = 1,Indexer = single_indexer_t]"
"buf_flush_common(buf_flush_t,ulint)" -> "abort()"
"buf_dblwr_flush_buffered_writes()" -> "buf_dblwr_check_block(const buf_block_t*)"
"buf_dblwr_flush_buffered_writes()" -> "buf_dblwr_sync_datafiles()"
"buf_dblwr_flush_buffered_writes()" -> "fil_flush(ulint)"
"buf_dblwr_flush_buffered_writes()" -> "__builtin_expect(long int,long int)"
"buf_dblwr_flush_buffered_writes()" -> "pfs_mutex_exit_func(ib_mutex_t*)"
"buf_dblwr_flush_buffered_writes()" -> "buf_dblwr_check_page_lsn(const ib_page_t*)"
"buf_dblwr_flush_buffered_writes()" -> "ut_min(ulint,ulint)"
"buf_dblwr_flush_buffered_writes()" -> "fil_io(ulint,bool,ulint,ulint,ulint,ulint,ulint,void*,void*)"
"buf_dblwr_flush_buffered_writes()" -> "ut_dbg_assertion_failed(const char*,const char*,ulint)"
"buf_dblwr_flush_buffered_writes()" -> "buf_block_get_state(const buf_block_t*)"
"buf_dblwr_flush_buffered_writes()" -> "abort()"
"buf_dblwr_flush_buffered_writes()" -> "Indexer>::add(Type) [with Type = long unsigned int,int N = 1,Indexer = single_indexer_t]"
"buf_dblwr_flush_buffered_writes()" -> "os_event_wait_low(os_event_t,ib_int64_t)"
"buf_dblwr_flush_buffered_writes()" -> "os_aio_simulated_wake_handler_threads()"
"buf_dblwr_flush_buffered_writes()" -> "os_event_reset(os_event_t)"
"buf_dblwr_flush_buffered_writes()" -> "buf_dblwr_write_block_to_datafile(const buf_page_t*,bool)"
"buf_dblwr_flush_buffered_writes()" -> "pfs_mutex_enter_func(ib_mutex_t*,const char*,ulint)"
"buf_dblwr_flush_buffered_writes()" -> "Indexer>::inc() [with Type = long unsigned int,int N = 1,Indexer = single_indexer_t]"
"buf_dblwr_check_block(const buf_block_t*)" -> "buf_block_get_state(const buf_block_t*)"
"buf_dblwr_check_block(const buf_block_t*)" -> "page_simple_validate_new(const ib_page_t*)"
"buf_dblwr_check_block(const buf_block_t*)" -> "buf_dblwr_check_page_lsn(const ib_page_t*)"
"buf_dblwr_check_block(const buf_block_t*)" -> "buf_dblwr_assert_on_corrupt_block(const buf_block_t*)"
"buf_dblwr_check_block(const buf_block_t*)" -> "page_simple_validate_old(const ib_page_t*)"
"buf_dblwr_check_block(const buf_block_t*)" -> "page_is_comp(const ib_page_t*)"
"page_simple_validate_new(const ib_page_t*)" -> "rec_get_n_owned_new(const rec_t*)"
"page_simple_validate_new(const ib_page_t*)" -> "page_dir_slot_get_rec(const page_dir_slot_t*)"
"page_simple_validate_new(const ib_page_t*)" -> "page_rec_get_next_const(const rec_t*)"
"page_simple_validate_new(const ib_page_t*)" -> "rec_get_next_offs(const rec_t*,ulint)"
"page_simple_validate_new(const ib_page_t*)" -> "page_is_comp(const ib_page_t*)"
"page_simple_validate_new(const ib_page_t*)" -> "__builtin_expect(long int,long int)"
"page_simple_validate_new(const ib_page_t*)" -> "ut_dbg_assertion_failed(const char*,const char*,ulint)"
"page_simple_validate_new(const ib_page_t*)" -> "abort()"
"page_simple_validate_new(const ib_page_t*)" -> "page_dir_get_n_slots(const ib_page_t*)"
"page_simple_validate_new(const ib_page_t*)" -> "page_header_get_field(const ib_page_t*,ulint)"
"page_simple_validate_new(const ib_page_t*)" -> "page_offset(const void*)"
"page_simple_validate_new(const ib_page_t*)" -> "page_header_get_offs(const ib_page_t*,ulint)"
"page_simple_validate_new(const ib_page_t*)" -> "page_get_infimum_offset(const ib_page_t*)"
"page_simple_validate_new(const ib_page_t*)" -> "fprintf(FILE*,const char*,...)"
"page_simple_validate_new(const ib_page_t*)" -> "__builtin_fwrite(const void*,size_t,size_t,FILE*)"
"page_simple_validate_new(const ib_page_t*)" -> "page_dir_get_n_heap(const ib_page_t*)"
"page_simple_validate_new(const ib_page_t*)" -> "page_rec_is_supremum(const rec_t*)"
"buf_dblwr_check_page_lsn(const ib_page_t*)" -> "fprintf(FILE*,const char*,...)"
"buf_dblwr_check_page_lsn(const ib_page_t*)" -> "ut_print_timestamp(FILE*)"
"buf_dblwr_check_page_lsn(const ib_page_t*)" -> "mach_read_from_4(const unsigned char*)"
"buf_dblwr_check_page_lsn(const ib_page_t*)" -> "memcmp(const void*,const void*,size_t)"
"buf_dblwr_assert_on_corrupt_block(const buf_block_t*)" -> "abort()"
"buf_dblwr_assert_on_corrupt_block(const buf_block_t*)" -> "ut_print_timestamp(FILE*)"
"buf_dblwr_assert_on_corrupt_block(const buf_block_t*)" -> "buf_block_get_space(const buf_block_t*)"
"buf_dblwr_assert_on_corrupt_block(const buf_block_t*)" -> "buf_page_print(const unsigned char*,ulint,ulint)"
"buf_dblwr_assert_on_corrupt_block(const buf_block_t*)" -> "buf_block_get_page_no(const buf_block_t*)"
"buf_dblwr_assert_on_corrupt_block(const buf_block_t*)" -> "fprintf(FILE*,const char*,...)"
"buf_dblwr_assert_on_corrupt_block(const buf_block_t*)" -> "ut_dbg_assertion_failed(const char*,const char*,ulint)"
"page_simple_validate_old(const ib_page_t*)" -> "fprintf(FILE*,const char*,...)"
"page_simple_validate_old(const ib_page_t*)" -> "page_dir_get_n_slots(const ib_page_t*)"
"page_simple_validate_old(const ib_page_t*)" -> "rec_get_next_offs(const rec_t*,ulint)"
"page_simple_validate_old(const ib_page_t*)" -> "page_offset(const void*)"
"page_simple_validate_old(const ib_page_t*)" -> "page_dir_get_n_heap(const ib_page_t*)"
"page_simple_validate_old(const ib_page_t*)" -> "page_is_comp(const ib_page_t*)"
"page_simple_validate_old(const ib_page_t*)" -> "page_get_infimum_offset(const ib_page_t*)"
"page_simple_validate_old(const ib_page_t*)" -> "page_header_get_offs(const ib_page_t*,ulint)"
"page_simple_validate_old(const ib_page_t*)" -> "page_rec_get_next_const(const rec_t*)"
"page_simple_validate_old(const ib_page_t*)" -> "rec_get_n_owned_old(const rec_t*)"
"page_simple_validate_old(const ib_page_t*)" -> "page_dir_slot_get_rec(const page_dir_slot_t*)"
"page_simple_validate_old(const ib_page_t*)" -> "__builtin_fwrite(const void*,size_t,size_t,FILE*)"
"page_simple_validate_old(const ib_page_t*)" -> "abort()"
"page_simple_validate_old(const ib_page_t*)" -> "page_header_get_field(const ib_page_t*,ulint)"
"page_simple_validate_old(const ib_page_t*)" -> "page_rec_is_supremum(const rec_t*)"
"page_simple_validate_old(const ib_page_t*)" -> "__builtin_expect(long int,long int)"
"page_simple_validate_old(const ib_page_t*)" -> "ut_dbg_assertion_failed(const char*,const char*,ulint)"
"buf_dblwr_sync_datafiles()" -> "fil_flush_file_spaces(ulint)"
"buf_dblwr_sync_datafiles()" -> "os_aio_wait_until_no_pending_writes()"
"buf_dblwr_sync_datafiles()" -> "os_aio_simulated_wake_handler_threads()"
"os_aio_wait_until_no_pending_writes()" -> "os_event_wait_low(os_event_t,ib_int64_t)"
"buf_dblwr_write_block_to_datafile(const buf_page_t*,bool)" -> "__builtin_expect(long int,long int)"
"buf_dblwr_write_block_to_datafile(const buf_page_t*,bool)" -> "buf_page_in_file(const buf_page_t*)"
"buf_dblwr_write_block_to_datafile(const buf_page_t*,bool)" -> "buf_page_get_page_no(const buf_page_t*)"
"buf_dblwr_write_block_to_datafile(const buf_page_t*,bool)" -> "buf_page_get_space(const buf_page_t*)"
"buf_dblwr_write_block_to_datafile(const buf_page_t*,bool)" -> "buf_block_get_page_no(const buf_block_t*)"
"buf_dblwr_write_block_to_datafile(const buf_page_t*,bool)" -> "fil_io(ulint,bool,ulint,ulint,ulint,ulint,ulint,void*,void*)"
"buf_dblwr_write_block_to_datafile(const buf_page_t*,bool)" -> "buf_page_get_zip_size(const buf_page_t*)"
"buf_dblwr_write_block_to_datafile(const buf_page_t*,bool)" -> "buf_block_get_space(const buf_block_t*)"
"buf_dblwr_write_block_to_datafile(const buf_page_t*,bool)" -> "ut_dbg_assertion_failed(const char*,const char*,ulint)"
"buf_dblwr_write_block_to_datafile(const buf_page_t*,bool)" -> "buf_block_get_state(const buf_block_t*)"
"buf_dblwr_write_block_to_datafile(const buf_page_t*,bool)" -> "buf_dblwr_check_page_lsn(const ib_page_t*)"
"buf_dblwr_write_block_to_datafile(const buf_page_t*,bool)" -> "abort()"
"buf_page_get_space(const buf_page_t*)" -> "abort()"
"buf_page_get_space(const buf_page_t*)" -> "ut_dbg_assertion_failed(const char*,const char*,ulint)"
"buf_page_get_space(const buf_page_t*)" -> "__builtin_expect(long int,long int)"
"buf_page_get_space(const buf_page_t*)" -> "buf_page_in_file(const buf_page_t*)"
"buf_flush_start(buf_pool_t*,buf_flush_t)" -> "pfs_mutex_enter_func(ib_mutex_t*,const char*,ulint)"
"buf_flush_start(buf_pool_t*,buf_flush_t)" -> "pfs_mutex_exit_func(ib_mutex_t*)"
"buf_flush_end(buf_pool_t*,buf_flush_t)" -> "pfs_mutex_exit_func(ib_mutex_t*)"
"buf_flush_end(buf_pool_t*,buf_flush_t)" -> "os_event_set(os_event_t)"
"buf_flush_end(buf_pool_t*,buf_flush_t)" -> "pfs_mutex_enter_func(ib_mutex_t*,const char*,ulint)"
"buf_flush_batch(buf_pool_t*,buf_flush_t,ulint,lsn_t)" -> "abort()"
"buf_flush_batch(buf_pool_t*,buf_flush_t,ulint,lsn_t)" -> "pfs_mutex_enter_func(ib_mutex_t*,const char*,ulint)"
"buf_flush_batch(buf_pool_t*,buf_flush_t,ulint,lsn_t)" -> "ut_dbg_assertion_failed(const char*,const char*,ulint)"
"buf_flush_batch(buf_pool_t*,buf_flush_t,ulint,lsn_t)" -> "buf_do_LRU_batch(buf_pool_t*,ulint)"
"buf_flush_batch(buf_pool_t*,buf_flush_t,ulint,lsn_t)" -> "pfs_mutex_exit_func(ib_mutex_t*)"
"buf_flush_batch(buf_pool_t*,buf_flush_t,ulint,lsn_t)" -> "buf_do_flush_list_batch(buf_pool_t*,ulint,lsn_t)"
"buf_do_LRU_batch(buf_pool_t*,ulint)" -> "buf_free_from_unzip_LRU_list_batch(buf_pool_t*,ulint)"
"buf_do_LRU_batch(buf_pool_t*,ulint)" -> "buf_LRU_evict_from_unzip_LRU(buf_pool_t*)"
"buf_do_LRU_batch(buf_pool_t*,ulint)" -> "buf_flush_LRU_list_batch(buf_pool_t*,ulint)"
"buf_free_from_unzip_LRU_list_batch(buf_pool_t*,ulint)" -> "buf_LRU_free_page(buf_page_t*,bool)"
"buf_flush_LRU_list_batch(buf_pool_t*,ulint)" -> "buf_flush_ready_for_replace(buf_page_t*)"
"buf_flush_LRU_list_batch(buf_pool_t*,ulint)" -> "pfs_mutex_exit_func(ib_mutex_t*)"
"buf_flush_LRU_list_batch(buf_pool_t*,ulint)" -> "buf_LRU_free_page(buf_page_t*,bool)"
"buf_flush_LRU_list_batch(buf_pool_t*,ulint)" -> "pfs_mutex_enter_func(ib_mutex_t*,const char*,ulint)"
"buf_flush_LRU_list_batch(buf_pool_t*,ulint)" -> "buf_page_get_mutex(const buf_page_t*)"
"buf_flush_LRU_list_batch(buf_pool_t*,ulint)" -> "buf_flush_page_and_try_neighbors(buf_page_t*,buf_flush_t,ulint,ulint*)"
"buf_flush_LRU_list_batch(buf_pool_t*,ulint)" -> "buf_page_hash_get_locked(buf_pool_t*,ulint,ulint,rw_lock_t**,ulint)"
"buf_flush_page_and_try_neighbors(buf_page_t*,buf_flush_t,ulint,ulint*)" -> "buf_page_get_page_no(const buf_page_t*)"
"buf_flush_page_and_try_neighbors(buf_page_t*,buf_flush_t,ulint,ulint*)" -> "pfs_mutex_enter_func(ib_mutex_t*,const char*,ulint)"
"buf_flush_page_and_try_neighbors(buf_page_t*,buf_flush_t,ulint,ulint*)" -> "__builtin_expect(long int,long int)"
"buf_flush_page_and_try_neighbors(buf_page_t*,buf_flush_t,ulint,ulint*)" -> "buf_pool_from_bpage(const buf_page_t*)"
"buf_flush_page_and_try_neighbors(buf_page_t*,buf_flush_t,ulint,ulint*)" -> "buf_flush_try_neighbors(ulint,ulint,buf_flush_t,ulint,ulint)"
"buf_flush_page_and_try_neighbors(buf_page_t*,buf_flush_t,ulint,ulint*)" -> "buf_page_in_file(const buf_page_t*)"
"buf_flush_page_and_try_neighbors(buf_page_t*,buf_flush_t,ulint,ulint*)" -> "buf_page_get_mutex(const buf_page_t*)"
"buf_flush_page_and_try_neighbors(buf_page_t*,buf_flush_t,ulint,ulint*)" -> "pfs_mutex_exit_func(ib_mutex_t*)"
"buf_flush_page_and_try_neighbors(buf_page_t*,buf_flush_t,ulint,ulint*)" -> "ut_dbg_assertion_failed(const char*,const char*,ulint)"
"buf_flush_page_and_try_neighbors(buf_page_t*,buf_flush_t,ulint,ulint*)" -> "buf_flush_ready_for_flush(buf_page_t*,buf_flush_t)"
"buf_flush_page_and_try_neighbors(buf_page_t*,buf_flush_t,ulint,ulint*)" -> "abort()"
"buf_flush_page_and_try_neighbors(buf_page_t*,buf_flush_t,ulint,ulint*)" -> "buf_page_get_space(const buf_page_t*)"
"buf_flush_try_neighbors(ulint,ulint,buf_flush_t,ulint,ulint)" -> "buf_pool_get(ulint,ulint)"
"buf_flush_try_neighbors(ulint,ulint,buf_flush_t,ulint,ulint)" -> "buf_page_in_file(const buf_page_t*)"
"buf_flush_try_neighbors(ulint,ulint,buf_flush_t,ulint,ulint)" -> "__builtin_expect(long int,long int)"
"buf_flush_try_neighbors(ulint,ulint,buf_flush_t,ulint,ulint)" -> "fil_space_get_size(ulint)"
"buf_flush_try_neighbors(ulint,ulint,buf_flush_t,ulint,ulint)" -> "ut_min(ulint,ulint)"
"buf_flush_try_neighbors(ulint,ulint,buf_flush_t,ulint,ulint)" -> "abort()"
"buf_flush_try_neighbors(ulint,ulint,buf_flush_t,ulint,ulint)" -> "buf_flush_check_neighbor(ulint,ulint,buf_flush_t)"
"buf_flush_try_neighbors(ulint,ulint,buf_flush_t,ulint,ulint)" -> "ut_2_power_up(ulint)"
"buf_flush_try_neighbors(ulint,ulint,buf_flush_t,ulint,ulint)" -> "buf_page_is_old(const buf_page_t*)"
"buf_flush_try_neighbors(ulint,ulint,buf_flush_t,ulint,ulint)" -> "buf_page_get_mutex(const buf_page_t*)"
"buf_flush_try_neighbors(ulint,ulint,buf_flush_t,ulint,ulint)" -> "buf_flush_page(buf_pool_t*,buf_page_t*,buf_flush_t,bool)"
"buf_flush_try_neighbors(ulint,ulint,buf_flush_t,ulint,ulint)" -> "ut_dbg_assertion_failed(const char*,const char*,ulint)"
"buf_flush_try_neighbors(ulint,ulint,buf_flush_t,ulint,ulint)" -> "pfs_mutex_enter_func(ib_mutex_t*,const char*,ulint)"
"buf_flush_try_neighbors(ulint,ulint,buf_flush_t,ulint,ulint)" -> "pfs_mutex_exit_func(ib_mutex_t*)"
"buf_flush_try_neighbors(ulint,ulint,buf_flush_t,ulint,ulint)" -> "buf_page_hash_get_locked(buf_pool_t*,ulint,ulint,rw_lock_t**,ulint)"
"buf_flush_try_neighbors(ulint,ulint,buf_flush_t,ulint,ulint)" -> "buf_flush_ready_for_flush(buf_page_t*,buf_flush_t)"
"buf_flush_check_neighbor(ulint,ulint,buf_flush_t)" -> "buf_pool_get(ulint,ulint)"
"buf_flush_check_neighbor(ulint,ulint,buf_flush_t)" -> "buf_flush_ready_for_flush(buf_page_t*,buf_flush_t)"
"buf_flush_check_neighbor(ulint,ulint,buf_flush_t)" -> "buf_page_get_mutex(const buf_page_t*)"
"buf_flush_check_neighbor(ulint,ulint,buf_flush_t)" -> "buf_page_hash_get_locked(buf_pool_t*,ulint,ulint,rw_lock_t**,ulint)"
"buf_flush_check_neighbor(ulint,ulint,buf_flush_t)" -> "buf_page_is_old(const buf_page_t*)"
"buf_flush_check_neighbor(ulint,ulint,buf_flush_t)" -> "pfs_mutex_enter_func(ib_mutex_t*,const char*,ulint)"
"buf_flush_check_neighbor(ulint,ulint,buf_flush_t)" -> "ut_dbg_assertion_failed(const char*,const char*,ulint)"
"buf_flush_check_neighbor(ulint,ulint,buf_flush_t)" -> "abort()"
"buf_flush_check_neighbor(ulint,ulint,buf_flush_t)" -> "buf_page_in_file(const buf_page_t*)"
"buf_flush_check_neighbor(ulint,ulint,buf_flush_t)" -> "__builtin_expect(long int,long int)"
"buf_flush_check_neighbor(ulint,ulint,buf_flush_t)" -> "pfs_mutex_exit_func(ib_mutex_t*)"
"buf_flush_ready_for_flush(buf_page_t*,buf_flush_t)" -> "__builtin_expect(long int,long int)"
"buf_flush_ready_for_flush(buf_page_t*,buf_flush_t)" -> "ut_dbg_assertion_failed(const char*,const char*,ulint)"
"buf_flush_ready_for_flush(buf_page_t*,buf_flush_t)" -> "buf_page_in_file(const buf_page_t*)"
"buf_flush_ready_for_flush(buf_page_t*,buf_flush_t)" -> "buf_page_get_io_fix(const buf_page_t*)"
"buf_flush_ready_for_flush(buf_page_t*,buf_flush_t)" -> "abort()"
"buf_do_flush_list_batch(buf_pool_t*,ulint,lsn_t)" -> "abort()"
"buf_do_flush_list_batch(buf_pool_t*,ulint,lsn_t)" -> "buf_flush_page_and_try_neighbors(buf_page_t*,buf_flush_t,ulint,ulint*)"
"buf_do_flush_list_batch(buf_pool_t*,ulint,lsn_t)" -> "__builtin_expect(long int,long int)"
"buf_do_flush_list_batch(buf_pool_t*,ulint,lsn_t)" -> "ut_dbg_assertion_failed(const char*,const char*,ulint)"
"buf_do_flush_list_batch(buf_pool_t*,ulint,lsn_t)" -> "pfs_mutex_exit_func(ib_mutex_t*)"
"buf_do_flush_list_batch(buf_pool_t*,ulint,lsn_t)" -> "buf_flush_is_hp(buf_pool_t*,const buf_page_t*)"
"buf_do_flush_list_batch(buf_pool_t*,ulint,lsn_t)" -> "buf_flush_set_hp(buf_pool_t*,const buf_page_t*)"
"buf_do_flush_list_batch(buf_pool_t*,ulint,lsn_t)" -> "pfs_mutex_enter_func(ib_mutex_t*,const char*,ulint)"
"recv_sys_empty_hash()" -> "buf_pool_get_curr_size()"
"recv_sys_empty_hash()" -> "ut_dbg_assertion_failed(const char*,const char*,ulint)"
"recv_sys_empty_hash()" -> "abort()"
"recv_sys_empty_hash()" -> "hash0_create(ulint)"
"recv_sys_empty_hash()" -> "fprintf(FILE*,const char*,...)"
"recv_sys_empty_hash()" -> "mem_heap_empty(mem_heap_t*)"
"recv_sys_empty_hash()" -> "hash_table_free(hash_table_t*)"
"hash0_create(ulint)" -> "ut_malloc_low(ulint,ulint)"
"hash0_create(ulint)" -> "hash_table_clear(hash_table_t*)"
"hash0_create(ulint)" -> "ut_find_prime(ulint)"
"hash0_create(ulint)" -> "mem_alloc_func(ulint,ulint*)"
"hash_table_clear(hash_table_t*)" -> "memset(void*,int,size_t)"
"hash_table_free(hash_table_t*)" -> "mem_free_func(void*,const char*,ulint)"
"hash_table_free(hash_table_t*)" -> "ut_free(void*)"
"log_preflush_pool_modified_pages(lsn_t)" -> "buf_flush_list(ulint,lsn_t,ulint*)"
"log_preflush_pool_modified_pages(lsn_t)" -> "buf_flush_wait_batch_end(buf_pool_t*,buf_flush_t)"
"log_preflush_pool_modified_pages(lsn_t)" -> "recv_apply_hashed_log_recs(ulint)"
"row_search_index_entry(dict_index_t*,const dtuple_t*,ulint,btr_pcur_t*,mtr_t*)" -> "page_rec_is_infimum(const rec_t*)"
"row_search_index_entry(dict_index_t*,const dtuple_t*,ulint,btr_pcur_t*,mtr_t*)" -> "btr_pcur_get_low_match(const btr_pcur_t*)"
"row_search_index_entry(dict_index_t*,const dtuple_t*,ulint,btr_pcur_t*,mtr_t*)" -> "btr_pcur_open_low(dict_index_t*,ulint,const dtuple_t*,ulint,ulint,btr_pcur_t*,const char*,ulint,mtr_t*)"
"row_search_index_entry(dict_index_t*,const dtuple_t*,ulint,btr_pcur_t*,mtr_t*)" -> "__builtin_expect(long int,long int)"
"row_search_index_entry(dict_index_t*,const dtuple_t*,ulint,btr_pcur_t*,mtr_t*)" -> "abort()"
"row_search_index_entry(dict_index_t*,const dtuple_t*,ulint,btr_pcur_t*,mtr_t*)" -> "dtuple_get_n_fields(const dtuple_t*)"
"row_search_index_entry(dict_index_t*,const dtuple_t*,ulint,btr_pcur_t*,mtr_t*)" -> "ut_dbg_assertion_failed(const char*,const char*,ulint)"
"row_purge_remove_sec_if_poss_tree(purge_node_t*,dict_index_t*,const dtuple_t*)" -> "dict_index_is_online_ddl(const dict_index_t*)"
"row_purge_remove_sec_if_poss_tree(purge_node_t*,dict_index_t*,const dtuple_t*)" -> "row_search_index_entry(dict_index_t*,const dtuple_t*,ulint,btr_pcur_t*,mtr_t*)"
"row_purge_remove_sec_if_poss_tree(purge_node_t*,dict_index_t*,const dtuple_t*)" -> "log_free_check()"
"row_purge_remove_sec_if_poss_tree(purge_node_t*,dict_index_t*,const dtuple_t*)" -> "dtuple_print(FILE*,const dtuple_t*)"
"row_purge_remove_sec_if_poss_tree(purge_node_t*,dict_index_t*,const dtuple_t*)" -> "btr_cur_pessimistic_delete(dberr_t*,ulint,btr_cur_t*,ulint,trx_rb_ctx,mtr_t*)"
"row_purge_remove_sec_if_poss_tree(purge_node_t*,dict_index_t*,const dtuple_t*)" -> "mtr_start(mtr_t*)"
"row_purge_remove_sec_if_poss_tree(purge_node_t*,dict_index_t*,const dtuple_t*)" -> "rec_get_deleted_flag(const rec_t*,ulint)"
"row_purge_remove_sec_if_poss_tree(purge_node_t*,dict_index_t*,const dtuple_t*)" -> "row_purge_poss_sec(purge_node_t*,dict_index_t*,const dtuple_t*)"
"row_purge_remove_sec_if_poss_tree(purge_node_t*,dict_index_t*,const dtuple_t*)" -> "dict_index_name_print(FILE*,const trx_t*,const dict_index_t*)"
"row_purge_remove_sec_if_poss_tree(purge_node_t*,dict_index_t*,const dtuple_t*)" -> "mtr_commit(mtr_t*)"
"row_purge_remove_sec_if_poss_tree(purge_node_t*,dict_index_t*,const dtuple_t*)" -> "abort()"
"row_purge_remove_sec_if_poss_tree(purge_node_t*,dict_index_t*,const dtuple_t*)" -> "dict_index_get_lock(dict_index_t*)"
"row_purge_remove_sec_if_poss_tree(purge_node_t*,dict_index_t*,const dtuple_t*)" -> "rec_print(FILE*,const rec_t*,const dict_index_t*)"
"row_purge_remove_sec_if_poss_tree(purge_node_t*,dict_index_t*,const dtuple_t*)" -> "dict_table_is_comp(const dict_table_t*)"
"row_purge_remove_sec_if_poss_tree(purge_node_t*,dict_index_t*,const dtuple_t*)" -> "mtr_x_lock_func(rw_lock_t*,const char*,ulint,mtr_t*)"
"row_purge_remove_sec_if_poss_tree(purge_node_t*,dict_index_t*,const dtuple_t*)" -> "btr_pcur_close(btr_pcur_t*)"
"row_purge_remove_sec_if_poss_tree(purge_node_t*,dict_index_t*,const dtuple_t*)" -> "_IO_putc(int,_IO_FILE*)"
"row_purge_remove_sec_if_poss_tree(purge_node_t*,dict_index_t*,const dtuple_t*)" -> "__builtin_expect(long int,long int)"
"row_purge_remove_sec_if_poss_tree(purge_node_t*,dict_index_t*,const dtuple_t*)" -> "__builtin_fwrite(const void*,size_t,size_t,FILE*)"
"row_purge_remove_sec_if_poss_tree(purge_node_t*,dict_index_t*,const dtuple_t*)" -> "ut_dbg_assertion_failed(const char*,const char*,ulint)"
"row_upd_changes_ord_field_binary_func(dict_index_t*,const upd_t*,const dtuple_t*,const row_ext_t*)" -> "abort()"
"row_upd_changes_ord_field_binary_func(dict_index_t*,const upd_t*,const dtuple_t*,const row_ext_t*)" -> "dfield_get_len(const dfield_t*)"
"row_upd_changes_ord_field_binary_func(dict_index_t*,const upd_t*,const dtuple_t*,const row_ext_t*)" -> "dict_col_get_clust_pos(const dict_col_t*,const dict_index_t*)"
"row_upd_changes_ord_field_binary_func(dict_index_t*,const upd_t*,const dtuple_t*,const row_ext_t*)" -> "dfield_is_ext(const dfield_t*)"
"row_upd_changes_ord_field_binary_func(dict_index_t*,const upd_t*,const dtuple_t*,const row_ext_t*)" -> "row_ext_lookup(const row_ext_t*,ulint,ulint*)"
"row_upd_changes_ord_field_binary_func(dict_index_t*,const upd_t*,const dtuple_t*,const row_ext_t*)" -> "ut_dbg_assertion_failed(const char*,const char*,ulint)"
"row_upd_changes_ord_field_binary_func(dict_index_t*,const upd_t*,const dtuple_t*,const row_ext_t*)" -> "dfield_datas_are_binary_equal(const dfield_t*,const dfield_t*,ulint)"
"row_upd_changes_ord_field_binary_func(dict_index_t*,const upd_t*,const dtuple_t*,const row_ext_t*)" -> "dfield_is_null(const dfield_t*)"
"row_upd_changes_ord_field_binary_func(dict_index_t*,const upd_t*,const dtuple_t*,const row_ext_t*)" -> "dict_index_get_n_unique(const dict_index_t*)"
"row_upd_changes_ord_field_binary_func(dict_index_t*,const upd_t*,const dtuple_t*,const row_ext_t*)" -> "upd_get_field_by_field_no(const upd_t*,ulint)"
"row_upd_changes_ord_field_binary_func(dict_index_t*,const upd_t*,const dtuple_t*,const row_ext_t*)" -> "dict_col_get_no(const dict_col_t*)"
"row_upd_changes_ord_field_binary_func(dict_index_t*,const upd_t*,const dtuple_t*,const row_ext_t*)" -> "dfield_copy(dfield_t*,const dfield_t*)"
"row_upd_changes_ord_field_binary_func(dict_index_t*,const upd_t*,const dtuple_t*,const row_ext_t*)" -> "dfield_set_data(dfield_t*,const void*,ulint)"
"row_upd_changes_ord_field_binary_func(dict_index_t*,const upd_t*,const dtuple_t*,const row_ext_t*)" -> "dict_index_is_clust(const dict_index_t*)"
"row_upd_changes_ord_field_binary_func(dict_index_t*,const upd_t*,const dtuple_t*,const row_ext_t*)" -> "__builtin_expect(long int,long int)"
"row_upd_changes_ord_field_binary_func(dict_index_t*,const upd_t*,const dtuple_t*,const row_ext_t*)" -> "dict_field_get_col(const dict_field_t*)"
"dfield_datas_are_binary_equal(const dfield_t*,const dfield_t*,ulint)" -> "memcmp(const void*,const void*,size_t)"
"row_purge_del_mark(purge_node_t*)" -> "row_purge_remove_clust_if_poss(purge_node_t*)"
"row_purge_del_mark(purge_node_t*)" -> "mem_heap_free_func(mem_heap_t*,const char*,ulint)"
"row_purge_del_mark(purge_node_t*)" -> "mem_heap_create_func(ulint,ulint)"
"row_purge_del_mark(purge_node_t*)" -> "dict_index_is_corrupted(const dict_index_t*)"
"row_purge_del_mark(purge_node_t*)" -> "row_build_index_entry_low(const dtuple_t*,const row_ext_t*,dict_index_t*,mem_heap_t*)"
"row_purge_del_mark(purge_node_t*)" -> "mem_heap_empty(mem_heap_t*)"
"row_purge_del_mark(purge_node_t*)" -> "row_purge_remove_sec_if_poss(purge_node_t*,dict_index_t*,const dtuple_t*)"
"row_purge_remove_clust_if_poss(purge_node_t*)" -> "os_thread_sleep(ulint)"
"row_purge_remove_clust_if_poss(purge_node_t*)" -> "row_purge_remove_clust_if_poss_low(purge_node_t*,ulint)"
"row_purge_remove_clust_if_poss_low(purge_node_t*,ulint)" -> "rec_get_offsets_func(const rec_t*,const dict_index_t*,ulint*,ulint,mem_heap_t**)"
"row_purge_remove_clust_if_poss_low(purge_node_t*,ulint)" -> "log_free_check()"
"row_purge_remove_clust_if_poss_low(purge_node_t*,ulint)" -> "ut_dbg_assertion_failed(const char*,const char*,ulint)"
"row_purge_remove_clust_if_poss_low(purge_node_t*,ulint)" -> "btr_pcur_commit_specify_mtr(btr_pcur_t*,mtr_t*)"
"row_purge_remove_clust_if_poss_low(purge_node_t*,ulint)" -> "abort()"
"row_purge_remove_clust_if_poss_low(purge_node_t*,ulint)" -> "row_get_rec_roll_ptr(const rec_t*,const dict_index_t*,const ulint*)"
"row_purge_remove_clust_if_poss_low(purge_node_t*,ulint)" -> "row_purge_reposition_pcur(ulint,purge_node_t*,mtr_t*)"
"row_purge_remove_clust_if_poss_low(purge_node_t*,ulint)" -> "btr_cur_optimistic_delete_func(btr_cur_t*,mtr_t*)"
"row_purge_remove_clust_if_poss_low(purge_node_t*,ulint)" -> "mtr_start(mtr_t*)"
"row_purge_remove_clust_if_poss_low(purge_node_t*,ulint)" -> "mem_heap_free_func(mem_heap_t*,const char*,ulint)"
"row_purge_remove_clust_if_poss_low(purge_node_t*,ulint)" -> "btr_cur_pessimistic_delete(dberr_t*,ulint,btr_cur_t*,ulint,trx_rb_ctx,mtr_t*)"
"row_purge_remove_clust_if_poss_low(purge_node_t*,ulint)" -> "rec_offs_set_n_alloc(ulint*,ulint)"
"row_purge_parse_undo_rec(purge_node_t*,trx_undo_rec_t*,bool*,que_thr_t*)" -> "trx_undo_update_rec_get_update(unsigned char*,dict_index_t*,ulint,trx_id_t,roll_ptr_t,ulint,trx_t*,mem_heap_t*,upd_t**)"
"row_purge_parse_undo_rec(purge_node_t*,trx_undo_rec_t*,bool*,que_thr_t*)" -> "thr_get_trx(que_thr_t*)"
"row_purge_parse_undo_rec(purge_node_t*,trx_undo_rec_t*,bool*,que_thr_t*)" -> "dict_table_close(dict_table_t*,ulint,ulint)"
"row_purge_parse_undo_rec(purge_node_t*,trx_undo_rec_t*,bool*,que_thr_t*)" -> "dict_table_open_on_id(table_id_t,ulint,dict_table_op_t)"
"row_purge_parse_undo_rec(purge_node_t*,trx_undo_rec_t*,bool*,que_thr_t*)" -> "pfs_rw_lock_s_lock_func(rw_lock_t*,ulint,const char*,ulint)"
"row_purge_parse_undo_rec(purge_node_t*,trx_undo_rec_t*,bool*,que_thr_t*)" -> "trx_undo_rec_get_pars(trx_undo_rec_t*,ulint*,ulint*,bool*,undo_no_t*,table_id_t*)"
"row_purge_parse_undo_rec(purge_node_t*,trx_undo_rec_t*,bool*,que_thr_t*)" -> "trx_undo_rec_get_partial_row(unsigned char*,dict_index_t*,dtuple_t**,ulint,mem_heap_t*)"
"row_purge_parse_undo_rec(purge_node_t*,trx_undo_rec_t*,bool*,que_thr_t*)" -> "pfs_rw_lock_s_unlock_func(rw_lock_t*)"
"row_purge_parse_undo_rec(purge_node_t*,trx_undo_rec_t*,bool*,que_thr_t*)" -> "trx_undo_rec_get_row_ref(unsigned char*,dict_index_t*,dtuple_t**,mem_heap_t*)"
"row_purge_parse_undo_rec(purge_node_t*,trx_undo_rec_t*,bool*,que_thr_t*)" -> "trx_undo_update_rec_get_sys_cols(unsigned char*,trx_id_t*,roll_ptr_t*,ulint*)"
"trx_undo_rec_get_partial_row(unsigned char*,dict_index_t*,dtuple_t**,ulint,mem_heap_t*)" -> "dict_col_get_no(const dict_col_t*)"
"trx_undo_rec_get_partial_row(unsigned char*,dict_index_t*,dtuple_t**,ulint,mem_heap_t*)" -> "dfield_set_ext(dfield_t*)"
"trx_undo_rec_get_partial_row(unsigned char*,dict_index_t*,dtuple_t**,ulint,mem_heap_t*)" -> "__builtin_expect(long int,long int)"
"trx_undo_rec_get_partial_row(unsigned char*,dict_index_t*,dtuple_t**,ulint,mem_heap_t*)" -> "trx_undo_rec_get_col_val(unsigned char*,unsigned char**,ulint*,ulint*)"
"trx_undo_rec_get_partial_row(unsigned char*,dict_index_t*,dtuple_t**,ulint,mem_heap_t*)" -> "dict_table_get_n_cols(const dict_table_t*)"
"trx_undo_rec_get_partial_row(unsigned char*,dict_index_t*,dtuple_t**,ulint,mem_heap_t*)" -> "dfield_get_len(const dfield_t*)"
"trx_undo_rec_get_partial_row(unsigned char*,dict_index_t*,dtuple_t**,ulint,mem_heap_t*)" -> "dfield_set_len(dfield_t*,ulint)"
"trx_undo_rec_get_partial_row(unsigned char*,dict_index_t*,dtuple_t**,ulint,mem_heap_t*)" -> "mach_read_from_2(const unsigned char*)"
"trx_undo_rec_get_partial_row(unsigned char*,dict_index_t*,dtuple_t**,ulint,mem_heap_t*)" -> "dict_table_get_format(const dict_table_t*)"
"trx_undo_rec_get_partial_row(unsigned char*,dict_index_t*,dtuple_t**,ulint,mem_heap_t*)" -> "dict_index_get_nth_col(const dict_index_t*,ulint)"
"trx_undo_rec_get_partial_row(unsigned char*,dict_index_t*,dtuple_t**,ulint,mem_heap_t*)" -> "dfield_set_data(dfield_t*,const void*,ulint)"
"trx_undo_rec_get_partial_row(unsigned char*,dict_index_t*,dtuple_t**,ulint,mem_heap_t*)" -> "dtuple_create(mem_heap_t*,ulint)"
"trx_undo_rec_get_partial_row(unsigned char*,dict_index_t*,dtuple_t**,ulint,mem_heap_t*)" -> "abort()"
"trx_undo_rec_get_partial_row(unsigned char*,dict_index_t*,dtuple_t**,ulint,mem_heap_t*)" -> "trx_undo_update_rec_get_field_no(unsigned char*,ulint*)"
"trx_undo_rec_get_partial_row(unsigned char*,dict_index_t*,dtuple_t**,ulint,mem_heap_t*)" -> "ut_dbg_assertion_failed(const char*,const char*,ulint)"
"trx_undo_rec_get_partial_row(unsigned char*,dict_index_t*,dtuple_t**,ulint,mem_heap_t*)" -> "dict_col_copy_type(const dict_col_t*,dtype_t*)"
"trx_undo_rec_get_row_ref(unsigned char*,dict_index_t*,dtuple_t**,mem_heap_t*)" -> "dict_index_get_n_unique(const dict_index_t*)"
"trx_undo_rec_get_row_ref(unsigned char*,dict_index_t*,dtuple_t**,mem_heap_t*)" -> "ut_dbg_assertion_failed(const char*,const char*,ulint)"
"trx_undo_rec_get_row_ref(unsigned char*,dict_index_t*,dtuple_t**,mem_heap_t*)" -> "dict_index_is_clust(const dict_index_t*)"
"trx_undo_rec_get_row_ref(unsigned char*,dict_index_t*,dtuple_t**,mem_heap_t*)" -> "abort()"
"trx_undo_rec_get_row_ref(unsigned char*,dict_index_t*,dtuple_t**,mem_heap_t*)" -> "trx_undo_rec_get_col_val(unsigned char*,unsigned char**,ulint*,ulint*)"
"trx_undo_rec_get_row_ref(unsigned char*,dict_index_t*,dtuple_t**,mem_heap_t*)" -> "dict_index_copy_types(dtuple_t*,const dict_index_t*,ulint)"
"trx_undo_rec_get_row_ref(unsigned char*,dict_index_t*,dtuple_t**,mem_heap_t*)" -> "dtuple_create(mem_heap_t*,ulint)"
"trx_undo_rec_get_row_ref(unsigned char*,dict_index_t*,dtuple_t**,mem_heap_t*)" -> "__builtin_expect(long int,long int)"
"trx_undo_rec_get_row_ref(unsigned char*,dict_index_t*,dtuple_t**,mem_heap_t*)" -> "dfield_set_data(dfield_t*,const void*,ulint)"
"row_ins_step(que_thr_t*)" -> "que_node_get_parent(que_node_t*)"
"row_ins_step(que_thr_t*)" -> "trx_write_trx_id(unsigned char*,trx_id_t)"
"row_ins_step(que_thr_t*)" -> "row_ins(ins_node_t*,que_thr_t*)"
"row_ins_step(que_thr_t*)" -> "lock_table(ulint,dict_table_t*,lock_mode,que_thr_t*)"
"row_ins_step(que_thr_t*)" -> "trx_start_if_not_started_xa_low(trx_t*)"
"row_ins_step(que_thr_t*)" -> "thr_get_trx(que_thr_t*)"
"row_ins(ins_node_t*,que_thr_t*)" -> "row_ins_get_row_from_values(ins_node_t*)"
"row_ins(ins_node_t*,que_thr_t*)" -> "row_ins_index_entry_step(ins_node_t*,que_thr_t*)"
"row_ins(ins_node_t*,que_thr_t*)" -> "dict_index_is_corrupted(const dict_index_t*)"
"row_ins(ins_node_t*,que_thr_t*)" -> "row_ins_alloc_row_id_step(ins_node_t*)"
"row_ins(ins_node_t*,que_thr_t*)" -> "row_ins_get_row_from_select(ins_node_t*)"
"row_ins_get_row_from_values(ins_node_t*)" -> "que_node_get_val(que_node_t*)"
"row_ins_get_row_from_values(ins_node_t*)" -> "eval_exp(que_node_t*)"
"row_ins_get_row_from_values(ins_node_t*)" -> "que_node_get_next(que_node_t*)"
"row_ins_get_row_from_values(ins_node_t*)" -> "dfield_copy_data(dfield_t*,const dfield_t*)"
"row_ins_index_entry_step(ins_node_t*,que_thr_t*)" -> "row_ins_index_entry_set_vals(dict_index_t*,dtuple_t*,const dtuple_t*)"
"row_ins_index_entry_step(ins_node_t*,que_thr_t*)" -> "row_ins_index_entry(dict_index_t*,dtuple_t*,que_thr_t*)"
"row_ins_index_entry_set_vals(dict_index_t*,dtuple_t*,const dtuple_t*)" -> "dfield_set_ext(dfield_t*)"
"row_ins_index_entry_set_vals(dict_index_t*,dtuple_t*,const dtuple_t*)" -> "dfield_set_data(dfield_t*,const void*,ulint)"
"row_ins_index_entry_set_vals(dict_index_t*,dtuple_t*,const dtuple_t*)" -> "dfield_get_len(const dfield_t*)"
"row_ins_index_entry_set_vals(dict_index_t*,dtuple_t*,const dtuple_t*)" -> "dtuple_get_n_fields(const dtuple_t*)"
"row_ins_index_entry_set_vals(dict_index_t*,dtuple_t*,const dtuple_t*)" -> "dict_field_get_col(const dict_field_t*)"
"row_ins_index_entry_set_vals(dict_index_t*,dtuple_t*,const dtuple_t*)" -> "dtype_get_at_most_n_mbchars(ulint,ulint,ulint,ulint,const char*)"
"row_ins_index_entry_set_vals(dict_index_t*,dtuple_t*,const dtuple_t*)" -> "dfield_is_ext(const dfield_t*)"
"row_ins_index_entry(dict_index_t*,dtuple_t*,que_thr_t*)" -> "row_ins_sec_index_entry(dict_index_t*,dtuple_t*,que_thr_t*)"
"row_ins_index_entry(dict_index_t*,dtuple_t*,que_thr_t*)" -> "row_ins_clust_index_entry(dict_index_t*,dtuple_t*,que_thr_t*,ulint)"
"row_ins_index_entry(dict_index_t*,dtuple_t*,que_thr_t*)" -> "dict_index_is_clust(const dict_index_t*)"
"row_ins_sec_index_entry(dict_index_t*,dtuple_t*,que_thr_t*)" -> "row_ins_check_foreign_constraints(dict_table_t*,dict_index_t*,dtuple_t*,que_thr_t*)"
"row_ins_sec_index_entry(dict_index_t*,dtuple_t*,que_thr_t*)" -> "mem_heap_free_func(mem_heap_t*,const char*,ulint)"
"row_ins_sec_index_entry(dict_index_t*,dtuple_t*,que_thr_t*)" -> "row_ins_sec_index_entry_low(ulint,ulint,dict_index_t*,mem_heap_t*,mem_heap_t*,dtuple_t*,trx_id_t,que_thr_t*)"
"row_ins_sec_index_entry(dict_index_t*,dtuple_t*,que_thr_t*)" -> "_Alloc>::empty() const [with _Key = dict_foreign_t*,_Compare = dict_foreign_compare,_Alloc = std::allocator<dict_foreign_t*>]"
"row_ins_sec_index_entry(dict_index_t*,dtuple_t*,que_thr_t*)" -> "mem_heap_empty(mem_heap_t*)"
"row_ins_sec_index_entry(dict_index_t*,dtuple_t*,que_thr_t*)" -> "log_free_check()"
"row_ins_sec_index_entry(dict_index_t*,dtuple_t*,que_thr_t*)" -> "mem_heap_create_func(ulint,ulint)"
"row_ins_check_foreign_constraints(dict_table_t*,dict_index_t*,dtuple_t*,que_thr_t*)" -> "std::_Rb_tree_const_iterator<_Tp>::operator*() const [with _Tp = dict_foreign_t*,std::_Rb_tree_const_iterator<_Tp>::reference = dict_foreign_t* const&]"
"row_ins_check_foreign_constraints(dict_table_t*,dict_index_t*,dtuple_t*,que_thr_t*)" -> "std::_Rb_tree_const_iterator<_Tp>::operator++() [with _Tp = dict_foreign_t*,std::_Rb_tree_const_iterator<_Tp>::_Self = std::_Rb_tree_const_iterator<dict_foreign_t*>]"
"row_ins_check_foreign_constraints(dict_table_t*,dict_index_t*,dtuple_t*,que_thr_t*)" -> "thr_get_trx(que_thr_t*)"
"row_ins_check_foreign_constraints(dict_table_t*,dict_index_t*,dtuple_t*,que_thr_t*)" -> "dict_table_close(dict_table_t*,ulint,ulint)"
"row_ins_check_foreign_constraints(dict_table_t*,dict_index_t*,dtuple_t*,que_thr_t*)" -> "_Alloc>::end() const [with _Key = dict_foreign_t*,_Compare = dict_foreign_compare,_Alloc = std::allocator<dict_foreign_t*>,std::set<_Key,_Compare,_Alloc>::iterator = std::_Rb_tree_const_iterator<dict_foreign_t*>]"
"row_ins_check_foreign_constraints(dict_table_t*,dict_index_t*,dtuple_t*,que_thr_t*)" -> "row_ins_check_foreign_constraint(ulint,dict_foreign_t*,dict_table_t*,dtuple_t*,que_thr_t*)"
"row_ins_check_foreign_constraints(dict_table_t*,dict_index_t*,dtuple_t*,que_thr_t*)" -> "std::_Rb_tree_const_iterator<_Tp>::operator!=(const _Self&) const [with _Tp = dict_foreign_t*,std::_Rb_tree_const_iterator<_Tp>::_Self = std::_Rb_tree_const_iterator<dict_foreign_t*>]"
"row_ins_check_foreign_constraints(dict_table_t*,dict_index_t*,dtuple_t*,que_thr_t*)" -> "_Alloc>::begin() const [with _Key = dict_foreign_t*,_Compare = dict_foreign_compare,_Alloc = std::allocator<dict_foreign_t*>,std::set<_Key,_Compare,_Alloc>::iterator = std::_Rb_tree_const_iterator<dict_foreign_t*>]"
"row_ins_check_foreign_constraints(dict_table_t*,dict_index_t*,dtuple_t*,que_thr_t*)" -> "row_mysql_freeze_data_dictionary_func(trx_t*,const char*,ulint)"
"row_ins_check_foreign_constraints(dict_table_t*,dict_index_t*,dtuple_t*,que_thr_t*)" -> "dict_table_open_on_name(const char*,ulint,ulint,dict_err_ignore_t)"
"row_ins_check_foreign_constraints(dict_table_t*,dict_index_t*,dtuple_t*,que_thr_t*)" -> "row_mysql_unfreeze_data_dictionary(trx_t*)"
"row_ins_check_foreign_constraints(dict_table_t*,dict_index_t*,dtuple_t*,que_thr_t*)" -> "__sync_add_and_fetch_8(volatile void*,long unsigned int)"
"std::_Rb_tree_const_iterator<_Tp>::operator++() [with _Tp = dict_foreign_t*,std::_Rb_tree_const_iterator<_Tp>::_Self = std::_Rb_tree_const_iterator<dict_foreign_t*>]" -> "std::_Rb_tree_increment(const std::_Rb_tree_node_base*)"
"row_ins_check_foreign_constraint(ulint,dict_foreign_t*,dict_table_t*,dtuple_t*,que_thr_t*)" -> "__builtin_expect(long int,long int)"
"row_ins_check_foreign_constraint(ulint,dict_foreign_t*,dict_table_t*,dtuple_t*,que_thr_t*)" -> "page_rec_is_supremum(const rec_t*)"
"row_ins_check_foreign_constraint(ulint,dict_foreign_t*,dict_table_t*,dtuple_t*,que_thr_t*)" -> "lock_table(ulint,dict_table_t*,lock_mode,que_thr_t*)"
"row_ins_check_foreign_constraint(ulint,dict_foreign_t*,dict_table_t*,dtuple_t*,que_thr_t*)" -> "btr_pcur_open_low(dict_index_t*,ulint,const dtuple_t*,ulint,ulint,btr_pcur_t*,const char*,ulint,mtr_t*)"
"row_ins_check_foreign_constraint(ulint,dict_foreign_t*,dict_table_t*,dtuple_t*,que_thr_t*)" -> "rec_offs_comp(const ulint*)"
"row_ins_check_foreign_constraint(ulint,dict_foreign_t*,dict_table_t*,dtuple_t*,que_thr_t*)" -> "dtuple_get_n_fields_cmp(const dtuple_t*)"
"row_ins_check_foreign_constraint(ulint,dict_foreign_t*,dict_table_t*,dtuple_t*,que_thr_t*)" -> "btr_pcur_close(btr_pcur_t*)"
"row_ins_check_foreign_constraint(ulint,dict_foreign_t*,dict_table_t*,dtuple_t*,que_thr_t*)" -> "btr_pcur_move_to_next(btr_pcur_t*,mtr_t*)"
"row_ins_check_foreign_constraint(ulint,dict_foreign_t*,dict_table_t*,dtuple_t*,que_thr_t*)" -> "dfield_get_len(const dfield_t*)"
"row_ins_check_foreign_constraint(ulint,dict_foreign_t*,dict_table_t*,dtuple_t*,que_thr_t*)" -> "std::_Rb_tree_const_iterator<_Tp>::operator++() [with _Tp = dict_foreign_t*,std::_Rb_tree_const_iterator<_Tp>::_Self = std::_Rb_tree_const_iterator<dict_foreign_t*>]"
"row_ins_check_foreign_constraint(ulint,dict_foreign_t*,dict_table_t*,dtuple_t*,que_thr_t*)" -> "lock_wait_suspend_thread(que_thr_t*)"
"row_ins_check_foreign_constraint(ulint,dict_foreign_t*,dict_table_t*,dtuple_t*,que_thr_t*)" -> "std::_Rb_tree_const_iterator<_Tp>::operator*() const [with _Tp = dict_foreign_t*,std::_Rb_tree_const_iterator<_Tp>::reference = dict_foreign_t* const&]"
"row_ins_check_foreign_constraint(ulint,dict_foreign_t*,dict_table_t*,dtuple_t*,que_thr_t*)" -> "ut_dbg_assertion_failed(const char*,const char*,ulint)"
"row_ins_check_foreign_constraint(ulint,dict_foreign_t*,dict_table_t*,dtuple_t*,que_thr_t*)" -> "ut_print_name(FILE*,const trx_t*,ulint,const char*)"
"row_ins_check_foreign_constraint(ulint,dict_foreign_t*,dict_table_t*,dtuple_t*,que_thr_t*)" -> "rec_offs_set_n_alloc(ulint*,ulint)"
"row_ins_check_foreign_constraint(ulint,dict_foreign_t*,dict_table_t*,dtuple_t*,que_thr_t*)" -> "cmp_dtuple_rec(const dtuple_t*,const rec_t*,const ulint*)"
"row_ins_check_foreign_constraint(ulint,dict_foreign_t*,dict_table_t*,dtuple_t*,que_thr_t*)" -> "abort()"
"row_ins_check_foreign_constraint(ulint,dict_foreign_t*,dict_table_t*,dtuple_t*,que_thr_t*)" -> "que_thr_stop_for_mysql(que_thr_t*)"
"row_ins_check_foreign_constraint(ulint,dict_foreign_t*,dict_table_t*,dtuple_t*,que_thr_t*)" -> "rec_get_offsets_func(const rec_t*,const dict_index_t*,ulint*,ulint,mem_heap_t**)"
"row_ins_check_foreign_constraint(ulint,dict_foreign_t*,dict_table_t*,dtuple_t*,que_thr_t*)" -> "row_ins_foreign_trx_print(trx_t*)"
"row_ins_check_foreign_constraint(ulint,dict_foreign_t*,dict_table_t*,dtuple_t*,que_thr_t*)" -> "row_ins_foreign_report_err(const char*,que_thr_t*,dict_foreign_t*,const rec_t*,const dtuple_t*)"
"row_ins_check_foreign_constraint(ulint,dict_foreign_t*,dict_table_t*,dtuple_t*,que_thr_t*)" -> "_Alloc>::begin() const [with _Key = dict_foreign_t*,_Compare = dict_foreign_compare,_Alloc = std::allocator<dict_foreign_t*>,std::set<_Key,_Compare,_Alloc>::iterator = std::_Rb_tree_const_iterator<dict_foreign_t*>]"
"row_ins_check_foreign_constraint(ulint,dict_foreign_t*,dict_table_t*,dtuple_t*,que_thr_t*)" -> "row_ins_foreign_report_add_err(trx_t*,dict_foreign_t*,const rec_t*,const dtuple_t*)"
"row_ins_check_foreign_constraint(ulint,dict_foreign_t*,dict_table_t*,dtuple_t*,que_thr_t*)" -> "row_ins_set_shared_rec_lock(ulint,const buf_block_t*,const rec_t*,dict_index_t*,const ulint*,que_thr_t*)"
"row_ins_check_foreign_constraint(ulint,dict_foreign_t*,dict_table_t*,dtuple_t*,que_thr_t*)" -> "rec_get_deleted_flag(const rec_t*,ulint)"
"row_ins_check_foreign_constraint(ulint,dict_foreign_t*,dict_table_t*,dtuple_t*,que_thr_t*)" -> "pfs_mutex_exit_func(ib_mutex_t*)"
"row_ins_check_foreign_constraint(ulint,dict_foreign_t*,dict_table_t*,dtuple_t*,que_thr_t*)" -> "dtuple_print(FILE*,const dtuple_t*)"
"row_ins_check_foreign_constraint(ulint,dict_foreign_t*,dict_table_t*,dtuple_t*,que_thr_t*)" -> "__builtin_fwrite(const void*,size_t,size_t,FILE*)"
"row_ins_check_foreign_constraint(ulint,dict_foreign_t*,dict_table_t*,dtuple_t*,que_thr_t*)" -> "std::_Rb_tree_const_iterator<_Tp>::operator!=(const _Self&) const [with _Tp = dict_foreign_t*,std::_Rb_tree_const_iterator<_Tp>::_Self = std::_Rb_tree_const_iterator<dict_foreign_t*>]"
"row_ins_check_foreign_constraint(ulint,dict_foreign_t*,dict_table_t*,dtuple_t*,que_thr_t*)" -> "page_rec_is_infimum(const rec_t*)"
"row_ins_check_foreign_constraint(ulint,dict_foreign_t*,dict_table_t*,dtuple_t*,que_thr_t*)" -> "_Alloc>::end() const [with _Key = dict_foreign_t*,_Compare = dict_foreign_compare,_Alloc = std::allocator<dict_foreign_t*>,std::set<_Key,_Compare,_Alloc>::iterator = std::_Rb_tree_const_iterator<dict_foreign_t*>]"
"row_ins_check_foreign_constraint(ulint,dict_foreign_t*,dict_table_t*,dtuple_t*,que_thr_t*)" -> "mtr_commit(mtr_t*)"
"row_ins_check_foreign_constraint(ulint,dict_foreign_t*,dict_table_t*,dtuple_t*,que_thr_t*)" -> "que_node_get_type(que_node_t*)"
"row_ins_check_foreign_constraint(ulint,dict_foreign_t*,dict_table_t*,dtuple_t*,que_thr_t*)" -> "dict_print_info_on_foreign_key_in_create_format(FILE*,trx_t*,dict_foreign_t*,ulint)"
"row_ins_check_foreign_constraint(ulint,dict_foreign_t*,dict_table_t*,dtuple_t*,que_thr_t*)" -> "row_ins_set_detailed(trx_t*,dict_foreign_t*)"
"row_ins_check_foreign_constraint(ulint,dict_foreign_t*,dict_table_t*,dtuple_t*,que_thr_t*)" -> "row_ins_foreign_check_on_constraint(que_thr_t*,dict_foreign_t*,btr_pcur_t*,dtuple_t*,mtr_t*)"
"row_ins_check_foreign_constraint(ulint,dict_foreign_t*,dict_table_t*,dtuple_t*,que_thr_t*)" -> "thr_get_trx(que_thr_t*)"
"row_ins_check_foreign_constraint(ulint,dict_foreign_t*,dict_table_t*,dtuple_t*,que_thr_t*)" -> "dtuple_set_n_fields_cmp(dtuple_t*,ulint)"
"row_ins_check_foreign_constraint(ulint,dict_foreign_t*,dict_table_t*,dtuple_t*,que_thr_t*)" -> "mem_heap_free_func(mem_heap_t*,const char*,ulint)"
"row_ins_check_foreign_constraint(ulint,dict_foreign_t*,dict_table_t*,dtuple_t*,que_thr_t*)" -> "mtr_start(mtr_t*)"
"lock_table(ulint,dict_table_t*,lock_mode,que_thr_t*)" -> "abort()"
"lock_table(ulint,dict_table_t*,lock_mode,que_thr_t*)" -> "__builtin_expect(long int,long int)"
"lock_table(ulint,dict_table_t*,lock_mode,que_thr_t*)" -> "lock_table_has(const trx_t*,const dict_table_t*,lock_mode)"
"lock_table(ulint,dict_table_t*,lock_mode,que_thr_t*)" -> "pfs_mutex_enter_func(ib_mutex_t*,const char*,ulint)"
"lock_table(ulint,dict_table_t*,lock_mode,que_thr_t*)" -> "ut_dbg_assertion_failed(const char*,const char*,ulint)"
"lock_table(ulint,dict_table_t*,lock_mode,que_thr_t*)" -> "lock_table_create(dict_table_t*,ulint,trx_t*)"
"lock_table(ulint,dict_table_t*,lock_mode,que_thr_t*)" -> "pfs_mutex_exit_func(ib_mutex_t*)"
"lock_table(ulint,dict_table_t*,lock_mode,que_thr_t*)" -> "lock_table_other_has_incompatible(const trx_t*,ulint,const dict_table_t*,lock_mode)"
"lock_table(ulint,dict_table_t*,lock_mode,que_thr_t*)" -> "thr_get_trx(que_thr_t*)"
"lock_table(ulint,dict_table_t*,lock_mode,que_thr_t*)" -> "lock_table_enqueue_waiting(ulint,dict_table_t*,que_thr_t*)"
"lock_table_has(const trx_t*,const dict_table_t*,lock_mode)" -> "ib_vector_size(const ib_vector_t*)"
"lock_table_has(const trx_t*,const dict_table_t*,lock_mode)" -> "ib_vector_is_empty(const ib_vector_t*)"
"lock_table_has(const trx_t*,const dict_table_t*,lock_mode)" -> "ib_vector_get(ib_vector_t*,ulint)"
"lock_table_has(const trx_t*,const dict_table_t*,lock_mode)" -> "lock_get_mode(const ib_lock_t*)"
"lock_table_has(const trx_t*,const dict_table_t*,lock_mode)" -> "lock_mode_stronger_or_eq(lock_mode,lock_mode)"
"lock_table_create(dict_table_t*,ulint,trx_t*)" -> "ib_vector_push(ib_vector_t*,const void*)"
"lock_table_create(dict_table_t*,ulint,trx_t*)" -> "ut_dbg_assertion_failed(const char*,const char*,ulint)"
"lock_table_create(dict_table_t*,ulint,trx_t*)" -> "mem_heap_alloc(mem_heap_t*,ulint)"
"lock_table_create(dict_table_t*,ulint,trx_t*)" -> "__builtin_expect(long int,long int)"
"lock_table_create(dict_table_t*,ulint,trx_t*)" -> "lock_set_lock_and_trx_wait(ib_lock_t*,trx_t*)"
"lock_table_create(dict_table_t*,ulint,trx_t*)" -> "ut_list_append(List&,Type&,size_t) [with List = ut_list_base<ib_lock_t>,Type = ib_lock_t,size_t = long unsigned int]"
"lock_table_create(dict_table_t*,ulint,trx_t*)" -> "abort()"
"lock_table_other_has_incompatible(const trx_t*,ulint,const dict_table_t*,lock_mode)" -> "lock_get_mode(const ib_lock_t*)"
"lock_table_other_has_incompatible(const trx_t*,ulint,const dict_table_t*,lock_mode)" -> "lock_get_wait(const ib_lock_t*)"
"lock_table_other_has_incompatible(const trx_t*,ulint,const dict_table_t*,lock_mode)" -> "lock_mode_compatible(lock_mode,lock_mode)"
"lock_table_enqueue_waiting(ulint,dict_table_t*,que_thr_t*)" -> "ut_print_name(FILE*,const trx_t*,ulint,const char*)"
"lock_table_enqueue_waiting(ulint,dict_table_t*,que_thr_t*)" -> "__builtin_fwrite(const void*,size_t,size_t,FILE*)"
"lock_table_enqueue_waiting(ulint,dict_table_t*,que_thr_t*)" -> "trx_get_dict_operation(const trx_t*)"
"lock_table_enqueue_waiting(ulint,dict_table_t*,que_thr_t*)" -> "pfs_mutex_enter_func(ib_mutex_t*,const char*,ulint)"
"lock_table_enqueue_waiting(ulint,dict_table_t*,que_thr_t*)" -> "lock_deadlock_check_and_resolve(const ib_lock_t*,const trx_t*)"
"lock_table_enqueue_waiting(ulint,dict_table_t*,que_thr_t*)" -> "thr_get_trx(que_thr_t*)"
"lock_table_enqueue_waiting(ulint,dict_table_t*,que_thr_t*)" -> "lock_table_remove_low(ib_lock_t*)"
"lock_table_enqueue_waiting(ulint,dict_table_t*,que_thr_t*)" -> "ut_time()"
"lock_table_enqueue_waiting(ulint,dict_table_t*,que_thr_t*)" -> "ut_dbg_assertion_failed(const char*,const char*,ulint)"
"lock_table_enqueue_waiting(ulint,dict_table_t*,que_thr_t*)" -> "que_thr_stop(que_thr_t*)"
"lock_table_enqueue_waiting(ulint,dict_table_t*,que_thr_t*)" -> "abort()"
"lock_table_enqueue_waiting(ulint,dict_table_t*,que_thr_t*)" -> "pfs_mutex_exit_func(ib_mutex_t*)"
"lock_table_enqueue_waiting(ulint,dict_table_t*,que_thr_t*)" -> "lock_reset_lock_and_trx_wait(ib_lock_t*)"
"lock_table_enqueue_waiting(ulint,dict_table_t*,que_thr_t*)" -> "__builtin_expect(long int,long int)"
"lock_table_enqueue_waiting(ulint,dict_table_t*,que_thr_t*)" -> "lock_table_create(dict_table_t*,ulint,trx_t*)"
"lock_table_enqueue_waiting(ulint,dict_table_t*,que_thr_t*)" -> "ut_print_timestamp(FILE*)"
"lock_wait_suspend_thread(que_thr_t*)" -> "__builtin_expect(long int,long int)"
"lock_wait_suspend_thread(que_thr_t*)" -> "ut_difftime(ib_time_t,ib_time_t)"
"lock_wait_suspend_thread(que_thr_t*)" -> "lock_wait_table_release_slot(srv_slot_t*)"
"lock_wait_suspend_thread(que_thr_t*)" -> "abort()"
"lock_wait_suspend_thread(que_thr_t*)" -> "Indexer>::inc() [with Type = long int,int N = 1,Indexer = single_indexer_t]"
"lock_wait_suspend_thread(que_thr_t*)" -> "trx_is_interrupted(const trx_t*)"
"lock_wait_suspend_thread(que_thr_t*)" -> "lock_get_type_low(const ib_lock_t*)"
"lock_wait_suspend_thread(que_thr_t*)" -> "os_event_set(os_event_t)"
"lock_wait_suspend_thread(que_thr_t*)" -> "ut_dbg_assertion_failed(const char*,const char*,ulint)"
"lock_wait_suspend_thread(que_thr_t*)" -> "lock_wait_table_reserve_slot(que_thr_t*,ulong)"
"lock_wait_suspend_thread(que_thr_t*)" -> "Indexer>::inc() [with Type = long unsigned int,int N = 1,Indexer = single_indexer_t]"
"lock_wait_suspend_thread(que_thr_t*)" -> "ut_usectime(ulint*,ulint*)"
"lock_wait_suspend_thread(que_thr_t*)" -> "row_mysql_unfreeze_data_dictionary(trx_t*)"
"lock_wait_suspend_thread(que_thr_t*)" -> "Indexer>::add(Type) [with Type = long int,int N = 1,Indexer = single_indexer_t]"
"lock_wait_suspend_thread(que_thr_t*)" -> "thr_get_trx(que_thr_t*)"
"lock_wait_suspend_thread(que_thr_t*)" -> "srv_conc_force_enter_innodb(trx_t*)"
"lock_wait_suspend_thread(que_thr_t*)" -> "row_mysql_freeze_data_dictionary_func(trx_t*,const char*,ulint)"
"lock_wait_suspend_thread(que_thr_t*)" -> "thd_wait_end(THD*)"
"lock_wait_suspend_thread(que_thr_t*)" -> "pfs_mutex_exit_func(ib_mutex_t*)"
"lock_wait_suspend_thread(que_thr_t*)" -> "os_event_wait_low(os_event_t,ib_int64_t)"
"lock_wait_suspend_thread(que_thr_t*)" -> "pfs_mutex_enter_func(ib_mutex_t*,const char*,ulint)"
"lock_wait_suspend_thread(que_thr_t*)" -> "ut_time()"
"lock_wait_suspend_thread(que_thr_t*)" -> "srv_conc_force_exit_innodb(trx_t*)"
"lock_wait_suspend_thread(que_thr_t*)" -> "thd_lock_wait_timeout(THD*)"
"lock_wait_suspend_thread(que_thr_t*)" -> "Indexer>::dec() [with Type = long int,int N = 1,Indexer = single_indexer_t]"
"lock_wait_suspend_thread(que_thr_t*)" -> "thd_set_lock_wait_time(THD*,ulint)"
"lock_wait_suspend_thread(que_thr_t*)" -> "thd_wait_begin(THD*,int)"
"lock_wait_table_release_slot(srv_slot_t*)" -> "pfs_mutex_enter_func(ib_mutex_t*,const char*,ulint)"
"lock_wait_table_release_slot(srv_slot_t*)" -> "pfs_mutex_exit_func(ib_mutex_t*)"
"trx_is_interrupted(const trx_t*)" -> "thd_killed(const THD*)"
"lock_wait_table_reserve_slot(que_thr_t*,ulong)" -> "ut_time()"
"lock_wait_table_reserve_slot(que_thr_t*,ulong)" -> "__builtin_expect(long int,long int)"
"lock_wait_table_reserve_slot(que_thr_t*,ulong)" -> "os_event_create()"
"lock_wait_table_reserve_slot(que_thr_t*,ulong)" -> "ut_dbg_assertion_failed(const char*,const char*,ulint)"
"lock_wait_table_reserve_slot(que_thr_t*,ulong)" -> "lock_wait_table_print()"
"lock_wait_table_reserve_slot(que_thr_t*,ulong)" -> "ut_print_timestamp(FILE*)"
"lock_wait_table_reserve_slot(que_thr_t*,ulong)" -> "fprintf(FILE*,const char*,...)"
"lock_wait_table_reserve_slot(que_thr_t*,ulong)" -> "os_event_reset(os_event_t)"
"lock_wait_table_reserve_slot(que_thr_t*,ulong)" -> "abort()"
"lock_wait_table_print()" -> "ut_time()"
"lock_wait_table_print()" -> "fprintf(FILE*,const char*,...)"
"lock_wait_table_print()" -> "difftime(time_t,time_t)"
"row_mysql_unfreeze_data_dictionary(trx_t*)" -> "ut_dbg_assertion_failed(const char*,const char*,ulint)"
"row_mysql_unfreeze_data_dictionary(trx_t*)" -> "abort()"
"row_mysql_unfreeze_data_dictionary(trx_t*)" -> "pfs_rw_lock_s_unlock_func(rw_lock_t*)"
"row_mysql_unfreeze_data_dictionary(trx_t*)" -> "__builtin_expect(long int,long int)"
"srv_conc_force_enter_innodb(trx_t*)" -> "__sync_add_and_fetch_8(volatile void*,long unsigned int)"
"row_mysql_freeze_data_dictionary_func(trx_t*,const char*,ulint)" -> "abort()"
"row_mysql_freeze_data_dictionary_func(trx_t*,const char*,ulint)" -> "__builtin_expect(long int,long int)"
"row_mysql_freeze_data_dictionary_func(trx_t*,const char*,ulint)" -> "pfs_rw_lock_s_lock_func(rw_lock_t*,ulint,const char*,ulint)"
"row_mysql_freeze_data_dictionary_func(trx_t*,const char*,ulint)" -> "ut_dbg_assertion_failed(const char*,const char*,ulint)"
"thd_set_lock_wait_time(THD*,ulint)" -> "thd_storage_lock_wait(THD*,long long int)"
"que_thr_stop_for_mysql(que_thr_t*)" -> "ut_dbg_assertion_failed(const char*,const char*,ulint)"
"que_thr_stop_for_mysql(que_thr_t*)" -> "abort()"
"que_thr_stop_for_mysql(que_thr_t*)" -> "pfs_mutex_exit_func(ib_mutex_t*)"
"que_thr_stop_for_mysql(que_thr_t*)" -> "__builtin_expect(long int,long int)"
"que_thr_stop_for_mysql(que_thr_t*)" -> "thr_get_trx(que_thr_t*)"
"que_thr_stop_for_mysql(que_thr_t*)" -> "pfs_mutex_enter_func(ib_mutex_t*,const char*,ulint)"
"row_ins_foreign_trx_print(trx_t*)" -> "mem_heap_get_size(mem_heap_t*)"
"row_ins_foreign_trx_print(trx_t*)" -> "trx_print_low(FILE*,const trx_t*,ulint,ulint,ulint,ulint)"
"row_ins_foreign_trx_print(trx_t*)" -> "__builtin_fwrite(const void*,size_t,size_t,FILE*)"
"row_ins_foreign_trx_print(trx_t*)" -> "lock_number_of_rows_locked(const trx_lock_t*)"
"row_ins_foreign_trx_print(trx_t*)" -> "pfs_mutex_exit_func(ib_mutex_t*)"
"row_ins_foreign_trx_print(trx_t*)" -> "ut_print_timestamp(FILE*)"
"row_ins_foreign_trx_print(trx_t*)" -> "pfs_mutex_enter_func(ib_mutex_t*,const char*,ulint)"
"row_ins_foreign_trx_print(trx_t*)" -> "rewind(FILE*)"
"row_ins_foreign_report_err(const char*,que_thr_t*,dict_foreign_t*,const rec_t*,const dtuple_t*)" -> "dict_print_info_on_foreign_key_in_create_format(FILE*,trx_t*,dict_foreign_t*,ulint)"
"row_ins_foreign_report_err(const char*,que_thr_t*,dict_foreign_t*,const rec_t*,const dtuple_t*)" -> "dtuple_print(FILE*,const dtuple_t*)"
"row_ins_foreign_report_err(const char*,que_thr_t*,dict_foreign_t*,const rec_t*,const dtuple_t*)" -> "fputs(const char*,FILE*)"
"row_ins_foreign_report_err(const char*,que_thr_t*,dict_foreign_t*,const rec_t*,const dtuple_t*)" -> "ut_print_name(FILE*,const trx_t*,ulint,const char*)"
"row_ins_foreign_report_err(const char*,que_thr_t*,dict_foreign_t*,const rec_t*,const dtuple_t*)" -> "row_ins_set_detailed(trx_t*,dict_foreign_t*)"
"row_ins_foreign_report_err(const char*,que_thr_t*,dict_foreign_t*,const rec_t*,const dtuple_t*)" -> "__builtin_fwrite(const void*,size_t,size_t,FILE*)"
"row_ins_foreign_report_err(const char*,que_thr_t*,dict_foreign_t*,const rec_t*,const dtuple_t*)" -> "putc(int,FILE*)"
"row_ins_foreign_report_err(const char*,que_thr_t*,dict_foreign_t*,const rec_t*,const dtuple_t*)" -> "pfs_mutex_exit_func(ib_mutex_t*)"
"row_ins_foreign_report_err(const char*,que_thr_t*,dict_foreign_t*,const rec_t*,const dtuple_t*)" -> "row_ins_foreign_trx_print(trx_t*)"
"row_ins_foreign_report_err(const char*,que_thr_t*,dict_foreign_t*,const rec_t*,const dtuple_t*)" -> "thr_get_trx(que_thr_t*)"
"row_ins_foreign_report_err(const char*,que_thr_t*,dict_foreign_t*,const rec_t*,const dtuple_t*)" -> "rec_print(FILE*,const rec_t*,const dict_index_t*)"
"row_ins_set_detailed(trx_t*,dict_foreign_t*)" -> "pfs_mutex_exit_func(ib_mutex_t*)"
"row_ins_set_detailed(trx_t*,dict_foreign_t*)" -> "pfs_mutex_enter_func(ib_mutex_t*,const char*,ulint)"
"row_ins_set_detailed(trx_t*,dict_foreign_t*)" -> "ut_print_name(FILE*,const trx_t*,ulint,const char*)"
"row_ins_set_detailed(trx_t*,dict_foreign_t*)" -> "dict_print_info_on_foreign_key_in_create_format(FILE*,trx_t*,dict_foreign_t*,ulint)"
"row_ins_set_detailed(trx_t*,dict_foreign_t*)" -> "trx_set_detailed_error_from_file(trx_t*,FILE*)"
"row_ins_set_detailed(trx_t*,dict_foreign_t*)" -> "os_file_set_eof(FILE*)"
"row_ins_set_detailed(trx_t*,dict_foreign_t*)" -> "rewind(FILE*)"
"row_ins_set_detailed(trx_t*,dict_foreign_t*)" -> "trx_set_detailed_error(trx_t*,const char*)"
"trx_set_detailed_error_from_file(trx_t*,FILE*)" -> "os_file_read_string(FILE*,char*,ulint)"
"os_file_set_eof(FILE*)" -> "fileno(FILE*)"
"os_file_set_eof(FILE*)" -> "ftell(FILE*)"
"os_file_set_eof(FILE*)" -> "ftruncate(int,__off64_t)"
"trx_set_detailed_error(trx_t*,const char*)" -> "ut_strlcpy(char*,const char*,ulint)"
"ut_strlcpy(char*,const char*,ulint)" -> "ut_min(ulint,ulint)"
"ut_strlcpy(char*,const char*,ulint)" -> "memcpy(void*,const void*,size_t)"
"ut_strlcpy(char*,const char*,ulint)" -> "strlen(const char*)"
"_Alloc>::begin() const [with _Key = dict_foreign_t*,_Compare = dict_foreign_compare,_Alloc = std::allocator<dict_foreign_t*>,std::set<_Key,_Compare,_Alloc>::iterator = std::_Rb_tree_const_iterator<dict_foreign_t*>]" -> "_Alloc>::begin() const [with _Key = dict_foreign_t*,_Val = dict_foreign_t*,_KeyOfValue = std::_Identity<dict_foreign_t*>,_Compare = dict_foreign_compare,_Alloc = std::allocator<dict_foreign_t*>,std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::const_iterator = std::_Rb_tree_const_iterator<dict_foreign_t*>]"
"_Alloc>::begin() const [with _Key = dict_foreign_t*,_Val = dict_foreign_t*,_KeyOfValue = std::_Identity<dict_foreign_t*>,_Compare = dict_foreign_compare,_Alloc = std::allocator<dict_foreign_t*>,std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::const_iterator = std::_Rb_tree_const_iterator<dict_foreign_t*>]" -> "std::_Rb_tree_const_iterator<_Tp>::_Rb_tree_const_iterator(std::_Rb_tree_const_iterator<_Tp>::_Link_type) [with _Tp = dict_foreign_t*,std::_Rb_tree_const_iterator<_Tp>::_Link_type = const std::_Rb_tree_node<dict_foreign_t*>*]"
"row_ins_foreign_report_add_err(trx_t*,dict_foreign_t*,const rec_t*,const dtuple_t*)" -> "page_rec_is_supremum(const rec_t*)"
"row_ins_foreign_report_add_err(trx_t*,dict_foreign_t*,const rec_t*,const dtuple_t*)" -> "rec_print(FILE*,const rec_t*,const dict_index_t*)"
"row_ins_foreign_report_add_err(trx_t*,dict_foreign_t*,const rec_t*,const dtuple_t*)" -> "page_rec_get_prev_const(const rec_t*)"
"row_ins_foreign_report_add_err(trx_t*,dict_foreign_t*,const rec_t*,const dtuple_t*)" -> "putc(int,FILE*)"
"row_ins_foreign_report_add_err(trx_t*,dict_foreign_t*,const rec_t*,const dtuple_t*)" -> "pfs_mutex_exit_func(ib_mutex_t*)"
"row_ins_foreign_report_add_err(trx_t*,dict_foreign_t*,const rec_t*,const dtuple_t*)" -> "ut_print_name(FILE*,const trx_t*,ulint,const char*)"
"row_ins_foreign_report_add_err(trx_t*,dict_foreign_t*,const rec_t*,const dtuple_t*)" -> "row_ins_set_detailed(trx_t*,dict_foreign_t*)"
"row_ins_foreign_report_add_err(trx_t*,dict_foreign_t*,const rec_t*,const dtuple_t*)" -> "row_ins_foreign_trx_print(trx_t*)"
"row_ins_foreign_report_add_err(trx_t*,dict_foreign_t*,const rec_t*,const dtuple_t*)" -> "dict_print_info_on_foreign_key_in_create_format(FILE*,trx_t*,dict_foreign_t*,ulint)"
"row_ins_foreign_report_add_err(trx_t*,dict_foreign_t*,const rec_t*,const dtuple_t*)" -> "dtuple_print(FILE*,const dtuple_t*)"
"row_ins_foreign_report_add_err(trx_t*,dict_foreign_t*,const rec_t*,const dtuple_t*)" -> "__builtin_fwrite(const void*,size_t,size_t,FILE*)"
"row_ins_set_shared_rec_lock(ulint,const buf_block_t*,const rec_t*,dict_index_t*,const ulint*,que_thr_t*)" -> "lock_sec_rec_read_check_and_lock(ulint,const buf_block_t*,const rec_t*,dict_index_t*,const ulint*,lock_mode,ulint,que_thr_t*)"
"row_ins_set_shared_rec_lock(ulint,const buf_block_t*,const rec_t*,dict_index_t*,const ulint*,que_thr_t*)" -> "dict_index_is_clust(const dict_index_t*)"
"row_ins_set_shared_rec_lock(ulint,const buf_block_t*,const rec_t*,dict_index_t*,const ulint*,que_thr_t*)" -> "lock_clust_rec_read_check_and_lock(ulint,const buf_block_t*,const rec_t*,dict_index_t*,const ulint*,lock_mode,ulint,que_thr_t*)"
"lock_sec_rec_read_check_and_lock(ulint,const buf_block_t*,const rec_t*,dict_index_t*,const ulint*,lock_mode,ulint,que_thr_t*)" -> "lock_rec_convert_impl_to_expl(const buf_block_t*,const rec_t*,dict_index_t*,const ulint*)"
"lock_sec_rec_read_check_and_lock(ulint,const buf_block_t*,const rec_t*,dict_index_t*,const ulint*,lock_mode,ulint,que_thr_t*)" -> "page_rec_get_heap_no(const rec_t*)"
"lock_sec_rec_read_check_and_lock(ulint,const buf_block_t*,const rec_t*,dict_index_t*,const ulint*,lock_mode,ulint,que_thr_t*)" -> "page_rec_is_supremum(const rec_t*)"
"lock_sec_rec_read_check_and_lock(ulint,const buf_block_t*,const rec_t*,dict_index_t*,const ulint*,lock_mode,ulint,que_thr_t*)" -> "pfs_mutex_enter_func(ib_mutex_t*,const char*,ulint)"
"lock_sec_rec_read_check_and_lock(ulint,const buf_block_t*,const rec_t*,dict_index_t*,const ulint*,lock_mode,ulint,que_thr_t*)" -> "page_get_max_trx_id(const ib_page_t*)"
"lock_sec_rec_read_check_and_lock(ulint,const buf_block_t*,const rec_t*,dict_index_t*,const ulint*,lock_mode,ulint,que_thr_t*)" -> "recv_recovery_is_on()"
"lock_sec_rec_read_check_and_lock(ulint,const buf_block_t*,const rec_t*,dict_index_t*,const ulint*,lock_mode,ulint,que_thr_t*)" -> "lock_rec_lock(ulint,ulint,const buf_block_t*,ulint,dict_index_t*,que_thr_t*)"
"lock_sec_rec_read_check_and_lock(ulint,const buf_block_t*,const rec_t*,dict_index_t*,const ulint*,lock_mode,ulint,que_thr_t*)" -> "pfs_mutex_exit_func(ib_mutex_t*)"
"lock_sec_rec_read_check_and_lock(ulint,const buf_block_t*,const rec_t*,dict_index_t*,const ulint*,lock_mode,ulint,que_thr_t*)" -> "trx_rw_min_trx_id()"
"lock_rec_convert_impl_to_expl(const buf_block_t*,const rec_t*,dict_index_t*,const ulint*)" -> "pfs_mutex_enter_func(ib_mutex_t*,const char*,ulint)"
"lock_rec_convert_impl_to_expl(const buf_block_t*,const rec_t*,dict_index_t*,const ulint*)" -> "lock_rec_has_expl(ulint,const buf_block_t*,ulint,const trx_t*)"
"lock_rec_convert_impl_to_expl(const buf_block_t*,const rec_t*,dict_index_t*,const ulint*)" -> "pfs_mutex_exit_func(ib_mutex_t*)"
"lock_rec_convert_impl_to_expl(const buf_block_t*,const rec_t*,dict_index_t*,const ulint*)" -> "lock_rec_add_to_queue(ulint,const buf_block_t*,ulint,dict_index_t*,trx_t*,ulint)"
"lock_rec_convert_impl_to_expl(const buf_block_t*,const rec_t*,dict_index_t*,const ulint*)" -> "lock_sec_rec_some_has_impl(const rec_t*,dict_index_t*,const ulint*)"
"lock_rec_convert_impl_to_expl(const buf_block_t*,const rec_t*,dict_index_t*,const ulint*)" -> "page_rec_get_heap_no(const rec_t*)"
"lock_rec_convert_impl_to_expl(const buf_block_t*,const rec_t*,dict_index_t*,const ulint*)" -> "lock_clust_rec_some_has_impl(const rec_t*,const dict_index_t*,const ulint*)"
"lock_rec_convert_impl_to_expl(const buf_block_t*,const rec_t*,dict_index_t*,const ulint*)" -> "dict_index_is_clust(const dict_index_t*)"
"lock_rec_convert_impl_to_expl(const buf_block_t*,const rec_t*,dict_index_t*,const ulint*)" -> "trx_rw_is_active(trx_id_t,ulint*)"
"lock_rec_has_expl(ulint,const buf_block_t*,ulint,const trx_t*)" -> "lock_mode_stronger_or_eq(lock_mode,lock_mode)"
"lock_rec_has_expl(ulint,const buf_block_t*,ulint,const trx_t*)" -> "lock_rec_get_first(const buf_block_t*,ulint)"
"lock_rec_has_expl(ulint,const buf_block_t*,ulint,const trx_t*)" -> "lock_rec_get_next(ulint,ib_lock_t*)"
"lock_rec_has_expl(ulint,const buf_block_t*,ulint,const trx_t*)" -> "lock_rec_get_rec_not_gap(const ib_lock_t*)"
"lock_rec_has_expl(ulint,const buf_block_t*,ulint,const trx_t*)" -> "lock_get_wait(const ib_lock_t*)"
"lock_rec_has_expl(ulint,const buf_block_t*,ulint,const trx_t*)" -> "lock_rec_get_gap(const ib_lock_t*)"
"lock_rec_has_expl(ulint,const buf_block_t*,ulint,const trx_t*)" -> "lock_rec_get_insert_intention(const ib_lock_t*)"
"lock_rec_has_expl(ulint,const buf_block_t*,ulint,const trx_t*)" -> "lock_get_mode(const ib_lock_t*)"
"lock_sec_rec_some_has_impl(const rec_t*,dict_index_t*,const ulint*)" -> "trx_rw_min_trx_id()"
"lock_sec_rec_some_has_impl(const rec_t*,dict_index_t*,const ulint*)" -> "buf_page_print(const unsigned char*,ulint,ulint)"
"lock_sec_rec_some_has_impl(const rec_t*,dict_index_t*,const ulint*)" -> "row_vers_impl_x_locked(const rec_t*,dict_index_t*,const ulint*)"
"lock_sec_rec_some_has_impl(const rec_t*,dict_index_t*,const ulint*)" -> "recv_recovery_is_on()"
"lock_sec_rec_some_has_impl(const rec_t*,dict_index_t*,const ulint*)" -> "page_get_max_trx_id(const ib_page_t*)"
"lock_sec_rec_some_has_impl(const rec_t*,dict_index_t*,const ulint*)" -> "lock_check_trx_id_sanity(trx_id_t,const rec_t*,dict_index_t*,const ulint*)"
"lock_sec_rec_some_has_impl(const rec_t*,dict_index_t*,const ulint*)" -> "page_align(const void*)"
"trx_rw_min_trx_id()" -> "pfs_mutex_enter_func(ib_mutex_t*,const char*,ulint)"
"trx_rw_min_trx_id()" -> "trx_rw_min_trx_id_low()"
"trx_rw_min_trx_id()" -> "pfs_mutex_exit_func(ib_mutex_t*)"
"trx_rw_min_trx_id_low()" -> "ut_dbg_assertion_failed(const char*,const char*,ulint)"
"trx_rw_min_trx_id_low()" -> "abort()"
"row_vers_impl_x_locked(const rec_t*,dict_index_t*,const ulint*)" -> "mtr_commit(mtr_t*)"
"row_vers_impl_x_locked(const rec_t*,dict_index_t*,const ulint*)" -> "mtr_start(mtr_t*)"
"row_vers_impl_x_locked(const rec_t*,dict_index_t*,const ulint*)" -> "__builtin_expect(long int,long int)"
"row_vers_impl_x_locked(const rec_t*,dict_index_t*,const ulint*)" -> "row_get_clust_rec(ulint,const rec_t*,dict_index_t*,dict_index_t**,mtr_t*)"
"row_vers_impl_x_locked(const rec_t*,dict_index_t*,const ulint*)" -> "row_vers_impl_x_locked_low(const rec_t*,dict_index_t*,const rec_t*,dict_index_t*,const ulint*,mtr_t*)"
"row_get_clust_rec(ulint,const rec_t*,dict_index_t*,dict_index_t**,mtr_t*)" -> "btr_pcur_close(btr_pcur_t*)"
"row_get_clust_rec(ulint,const rec_t*,dict_index_t*,dict_index_t**,mtr_t*)" -> "mem_heap_free_func(mem_heap_t*,const char*,ulint)"
"row_get_clust_rec(ulint,const rec_t*,dict_index_t*,dict_index_t**,mtr_t*)" -> "row_search_on_row_ref(btr_pcur_t*,ulint,const dict_table_t*,const dtuple_t*,mtr_t*)"
"row_get_clust_rec(ulint,const rec_t*,dict_index_t*,dict_index_t**,mtr_t*)" -> "mem_heap_create_func(ulint,ulint)"
"row_get_clust_rec(ulint,const rec_t*,dict_index_t*,dict_index_t**,mtr_t*)" -> "row_build_row_ref(ulint,dict_index_t*,const rec_t*,mem_heap_t*)"
"row_build_row_ref(ulint,dict_index_t*,const rec_t*,mem_heap_t*)" -> "rec_offs_set_n_alloc(ulint*,ulint)"
"row_build_row_ref(ulint,dict_index_t*,const rec_t*,mem_heap_t*)" -> "dfield_set_len(dfield_t*,ulint)"
"row_build_row_ref(ulint,dict_index_t*,const rec_t*,mem_heap_t*)" -> "mem_heap_alloc(mem_heap_t*,ulint)"
"row_build_row_ref(ulint,dict_index_t*,const rec_t*,mem_heap_t*)" -> "dtuple_create(mem_heap_t*,ulint)"
"row_build_row_ref(ulint,dict_index_t*,const rec_t*,mem_heap_t*)" -> "dict_index_get_n_unique(const dict_index_t*)"
"row_build_row_ref(ulint,dict_index_t*,const rec_t*,mem_heap_t*)" -> "abort()"
"row_build_row_ref(ulint,dict_index_t*,const rec_t*,mem_heap_t*)" -> "rec_get_nth_field_offs(const ulint*,ulint,ulint*)"
"row_build_row_ref(ulint,dict_index_t*,const rec_t*,mem_heap_t*)" -> "__builtin_expect(long int,long int)"
"row_build_row_ref(ulint,dict_index_t*,const rec_t*,mem_heap_t*)" -> "dtype_get_at_most_n_mbchars(ulint,ulint,ulint,ulint,const char*)"
"row_build_row_ref(ulint,dict_index_t*,const rec_t*,mem_heap_t*)" -> "dict_index_copy_types(dtuple_t*,const dict_index_t*,ulint)"
"row_build_row_ref(ulint,dict_index_t*,const rec_t*,mem_heap_t*)" -> "dfield_set_data(dfield_t*,const void*,ulint)"
"row_build_row_ref(ulint,dict_index_t*,const rec_t*,mem_heap_t*)" -> "ut_dbg_assertion_failed(const char*,const char*,ulint)"
"row_build_row_ref(ulint,dict_index_t*,const rec_t*,mem_heap_t*)" -> "mem_heap_free_func(mem_heap_t*,const char*,ulint)"
"row_build_row_ref(ulint,dict_index_t*,const rec_t*,mem_heap_t*)" -> "rec_get_offsets_func(const rec_t*,const dict_index_t*,ulint*,ulint,mem_heap_t**)"
"row_build_row_ref(ulint,dict_index_t*,const rec_t*,mem_heap_t*)" -> "dict_index_get_nth_field_pos(const dict_index_t*,const dict_index_t*,ulint)"
"row_build_row_ref(ulint,dict_index_t*,const rec_t*,mem_heap_t*)" -> "rec_offs_size(const ulint*)"
"row_build_row_ref(ulint,dict_index_t*,const rec_t*,mem_heap_t*)" -> "rec_copy(void*,const rec_t*,const ulint*)"
"row_vers_impl_x_locked_low(const rec_t*,dict_index_t*,const rec_t*,dict_index_t*,const ulint*,mtr_t*)" -> "dtuple_get_n_fields(const dtuple_t*)"
"row_vers_impl_x_locked_low(const rec_t*,dict_index_t*,const rec_t*,dict_index_t*,const ulint*,mtr_t*)" -> "row_build(ulint,const dict_index_t*,const rec_t*,const ulint*,const dict_table_t*,const dtuple_t*,const ulint*,row_ext_t**,mem_heap_t*)"
"row_vers_impl_x_locked_low(const rec_t*,dict_index_t*,const rec_t*,dict_index_t*,const ulint*,mtr_t*)" -> "row_get_rec_trx_id(const rec_t*,const dict_index_t*,const ulint*)"
"row_vers_impl_x_locked_low(const rec_t*,dict_index_t*,const rec_t*,dict_index_t*,const ulint*,mtr_t*)" -> "row_build_index_entry(const dtuple_t*,const row_ext_t*,dict_index_t*,mem_heap_t*)"
"row_vers_impl_x_locked_low(const rec_t*,dict_index_t*,const rec_t*,dict_index_t*,const ulint*,mtr_t*)" -> "mem_heap_free_func(mem_heap_t*,const char*,ulint)"
"row_vers_impl_x_locked_low(const rec_t*,dict_index_t*,const rec_t*,dict_index_t*,const ulint*,mtr_t*)" -> "trx_sys_get_max_trx_id()"
"row_vers_impl_x_locked_low(const rec_t*,dict_index_t*,const rec_t*,dict_index_t*,const ulint*,mtr_t*)" -> "trx_rw_is_active(trx_id_t,ulint*)"
"row_vers_impl_x_locked_low(const rec_t*,dict_index_t*,const rec_t*,dict_index_t*,const ulint*,mtr_t*)" -> "page_rec_is_comp(const rec_t*)"
"row_vers_impl_x_locked_low(const rec_t*,dict_index_t*,const rec_t*,dict_index_t*,const ulint*,mtr_t*)" -> "rec_get_deleted_flag(const rec_t*,ulint)"
"row_vers_impl_x_locked_low(const rec_t*,dict_index_t*,const rec_t*,dict_index_t*,const ulint*,mtr_t*)" -> "trx_undo_prev_version_build(const rec_t*,mtr_t*,const rec_t*,dict_index_t*,ulint*,mem_heap_t*,rec_t**)"
"row_vers_impl_x_locked_low(const rec_t*,dict_index_t*,const rec_t*,dict_index_t*,const ulint*,mtr_t*)" -> "rec_get_offsets_func(const rec_t*,const dict_index_t*,ulint*,ulint,mem_heap_t**)"
"row_vers_impl_x_locked_low(const rec_t*,dict_index_t*,const rec_t*,dict_index_t*,const ulint*,mtr_t*)" -> "__builtin_expect(long int,long int)"
"row_vers_impl_x_locked_low(const rec_t*,dict_index_t*,const rec_t*,dict_index_t*,const ulint*,mtr_t*)" -> "cmp_dtuple_rec(const dtuple_t*,const rec_t*,const ulint*)"
"row_vers_impl_x_locked_low(const rec_t*,dict_index_t*,const rec_t*,dict_index_t*,const ulint*,mtr_t*)" -> "abort()"
"row_vers_impl_x_locked_low(const rec_t*,dict_index_t*,const rec_t*,dict_index_t*,const ulint*,mtr_t*)" -> "dtuple_set_types_binary(dtuple_t*,ulint)"
"row_vers_impl_x_locked_low(const rec_t*,dict_index_t*,const rec_t*,dict_index_t*,const ulint*,mtr_t*)" -> "mem_heap_create_func(ulint,ulint)"
"row_vers_impl_x_locked_low(const rec_t*,dict_index_t*,const rec_t*,dict_index_t*,const ulint*,mtr_t*)" -> "ut_dbg_assertion_failed(const char*,const char*,ulint)"
"row_vers_impl_x_locked_low(const rec_t*,dict_index_t*,const rec_t*,dict_index_t*,const ulint*,mtr_t*)" -> "lock_report_trx_id_insanity(trx_id_t,const rec_t*,dict_index_t*,const ulint*,trx_id_t)"
"trx_rw_is_active(trx_id_t,ulint*)" -> "pfs_mutex_exit_func(ib_mutex_t*)"
"trx_rw_is_active(trx_id_t,ulint*)" -> "pfs_mutex_enter_func(ib_mutex_t*,const char*,ulint)"
"trx_rw_is_active(trx_id_t,ulint*)" -> "trx_rw_is_active_low(trx_id_t,ulint*)"
"trx_rw_is_active_low(trx_id_t,ulint*)" -> "trx_state_eq(const trx_t*,trx_state_t)"
"trx_rw_is_active_low(trx_id_t,ulint*)" -> "trx_rw_min_trx_id_low()"
"trx_rw_is_active_low(trx_id_t,ulint*)" -> "trx_get_rw_trx_by_id(trx_id_t)"
"trx_get_rw_trx_by_id(trx_id_t)" -> "abort()"
"trx_get_rw_trx_by_id(trx_id_t)" -> "ut_dbg_assertion_failed(const char*,const char*,ulint)"
"lock_report_trx_id_insanity(trx_id_t,const rec_t*,dict_index_t*,const ulint*,trx_id_t)" -> "__builtin_fwrite(const void*,size_t,size_t,FILE*)"
"lock_report_trx_id_insanity(trx_id_t,const rec_t*,dict_index_t*,const ulint*,trx_id_t)" -> "dict_index_name_print(FILE*,const trx_t*,const dict_index_t*)"
"lock_report_trx_id_insanity(trx_id_t,const rec_t*,dict_index_t*,const ulint*,trx_id_t)" -> "rec_print_new(FILE*,const rec_t*,const ulint*)"
"lock_report_trx_id_insanity(trx_id_t,const rec_t*,dict_index_t*,const ulint*,trx_id_t)" -> "fprintf(FILE*,const char*,...)"
"lock_report_trx_id_insanity(trx_id_t,const rec_t*,dict_index_t*,const ulint*,trx_id_t)" -> "ut_print_timestamp(FILE*)"
"lock_check_trx_id_sanity(trx_id_t,const rec_t*,dict_index_t*,const ulint*)" -> "lock_report_trx_id_insanity(trx_id_t,const rec_t*,dict_index_t*,const ulint*,trx_id_t)"
"lock_check_trx_id_sanity(trx_id_t,const rec_t*,dict_index_t*,const ulint*)" -> "trx_sys_get_max_trx_id()"
"lock_check_trx_id_sanity(trx_id_t,const rec_t*,dict_index_t*,const ulint*)" -> "__builtin_expect(long int,long int)"
"lock_clust_rec_some_has_impl(const rec_t*,const dict_index_t*,const ulint*)" -> "row_get_rec_trx_id(const rec_t*,const dict_index_t*,const ulint*)"
"lock_rec_lock(ulint,ulint,const buf_block_t*,ulint,dict_index_t*,que_thr_t*)" -> "lock_rec_lock_slow(ulint,ulint,const buf_block_t*,ulint,dict_index_t*,que_thr_t*)"
"lock_rec_lock(ulint,ulint,const buf_block_t*,ulint,dict_index_t*,que_thr_t*)" -> "lock_rec_lock_fast(ulint,ulint,const buf_block_t*,ulint,dict_index_t*,que_thr_t*)"
"lock_rec_lock(ulint,ulint,const buf_block_t*,ulint,dict_index_t*,que_thr_t*)" -> "ut_dbg_assertion_failed(const char*,const char*,ulint)"
"lock_rec_lock(ulint,ulint,const buf_block_t*,ulint,dict_index_t*,que_thr_t*)" -> "abort()"
"lock_rec_lock_slow(ulint,ulint,const buf_block_t*,ulint,dict_index_t*,que_thr_t*)" -> "pfs_mutex_enter_func(ib_mutex_t*,const char*,ulint)"
"lock_rec_lock_slow(ulint,ulint,const buf_block_t*,ulint,dict_index_t*,que_thr_t*)" -> "lock_rec_other_has_conflicting(lock_mode,const buf_block_t*,ulint,const trx_t*)"
"lock_rec_lock_slow(ulint,ulint,const buf_block_t*,ulint,dict_index_t*,que_thr_t*)" -> "lock_rec_has_expl(ulint,const buf_block_t*,ulint,const trx_t*)"
"lock_rec_lock_slow(ulint,ulint,const buf_block_t*,ulint,dict_index_t*,que_thr_t*)" -> "lock_rec_add_to_queue(ulint,const buf_block_t*,ulint,dict_index_t*,trx_t*,ulint)"
"lock_rec_lock_slow(ulint,ulint,const buf_block_t*,ulint,dict_index_t*,que_thr_t*)" -> "lock_rec_enqueue_waiting(ulint,const buf_block_t*,ulint,dict_index_t*,que_thr_t*)"
"lock_rec_lock_slow(ulint,ulint,const buf_block_t*,ulint,dict_index_t*,que_thr_t*)" -> "pfs_mutex_exit_func(ib_mutex_t*)"
"lock_rec_lock_slow(ulint,ulint,const buf_block_t*,ulint,dict_index_t*,que_thr_t*)" -> "thr_get_trx(que_thr_t*)"
"lock_rec_lock_fast(ulint,ulint,const buf_block_t*,ulint,dict_index_t*,que_thr_t*)" -> "thr_get_trx(que_thr_t*)"
"lock_rec_lock_fast(ulint,ulint,const buf_block_t*,ulint,dict_index_t*,que_thr_t*)" -> "lock_rec_get_nth_bit(const ib_lock_t*,ulint)"
"lock_rec_lock_fast(ulint,ulint,const buf_block_t*,ulint,dict_index_t*,que_thr_t*)" -> "lock_rec_create(ulint,const buf_block_t*,ulint,dict_index_t*,trx_t*,ulint)"
"lock_rec_lock_fast(ulint,ulint,const buf_block_t*,ulint,dict_index_t*,que_thr_t*)" -> "pfs_mutex_exit_func(ib_mutex_t*)"
"lock_rec_lock_fast(ulint,ulint,const buf_block_t*,ulint,dict_index_t*,que_thr_t*)" -> "lock_rec_get_next_on_page(ib_lock_t*)"
"lock_rec_lock_fast(ulint,ulint,const buf_block_t*,ulint,dict_index_t*,que_thr_t*)" -> "lock_rec_get_first_on_page(const buf_block_t*)"
"lock_rec_lock_fast(ulint,ulint,const buf_block_t*,ulint,dict_index_t*,que_thr_t*)" -> "lock_rec_set_nth_bit(ib_lock_t*,ulint)"
"lock_rec_lock_fast(ulint,ulint,const buf_block_t*,ulint,dict_index_t*,que_thr_t*)" -> "lock_rec_get_n_bits(const ib_lock_t*)"
"lock_rec_lock_fast(ulint,ulint,const buf_block_t*,ulint,dict_index_t*,que_thr_t*)" -> "pfs_mutex_enter_func(ib_mutex_t*,const char*,ulint)"
"lock_clust_rec_read_check_and_lock(ulint,const buf_block_t*,const rec_t*,dict_index_t*,const ulint*,lock_mode,ulint,que_thr_t*)" -> "__builtin_expect(long int,long int)"
"lock_clust_rec_read_check_and_lock(ulint,const buf_block_t*,const rec_t*,dict_index_t*,const ulint*,lock_mode,ulint,que_thr_t*)" -> "page_rec_get_heap_no(const rec_t*)"
"lock_clust_rec_read_check_and_lock(ulint,const buf_block_t*,const rec_t*,dict_index_t*,const ulint*,lock_mode,ulint,que_thr_t*)" -> "lock_rec_lock(ulint,ulint,const buf_block_t*,ulint,dict_index_t*,que_thr_t*)"
"lock_clust_rec_read_check_and_lock(ulint,const buf_block_t*,const rec_t*,dict_index_t*,const ulint*,lock_mode,ulint,que_thr_t*)" -> "lock_rec_convert_impl_to_expl(const buf_block_t*,const rec_t*,dict_index_t*,const ulint*)"
"lock_clust_rec_read_check_and_lock(ulint,const buf_block_t*,const rec_t*,dict_index_t*,const ulint*,lock_mode,ulint,que_thr_t*)" -> "pfs_mutex_enter_func(ib_mutex_t*,const char*,ulint)"
"lock_clust_rec_read_check_and_lock(ulint,const buf_block_t*,const rec_t*,dict_index_t*,const ulint*,lock_mode,ulint,que_thr_t*)" -> "pfs_mutex_exit_func(ib_mutex_t*)"
"row_ins_foreign_check_on_constraint(que_thr_t*,dict_foreign_t*,btr_pcur_t*,dtuple_t*,mtr_t*)" -> "que_node_set_parent(que_node_t*,que_node_t*)"
"row_ins_foreign_check_on_constraint(que_thr_t*,dict_foreign_t*,btr_pcur_t*,dtuple_t*,mtr_t*)" -> "dfield_set_null(dfield_t*)"
"row_ins_foreign_check_on_constraint(que_thr_t*,dict_foreign_t*,btr_pcur_t*,dtuple_t*,mtr_t*)" -> "upd_create(ulint,mem_heap_t*)"
"row_ins_foreign_check_on_constraint(que_thr_t*,dict_foreign_t*,btr_pcur_t*,dtuple_t*,mtr_t*)" -> "ut_dbg_assertion_failed(const char*,const char*,ulint)"
"row_ins_foreign_check_on_constraint(que_thr_t*,dict_foreign_t*,btr_pcur_t*,dtuple_t*,mtr_t*)" -> "row_build_row_ref(ulint,dict_index_t*,const rec_t*,mem_heap_t*)"
"row_ins_foreign_check_on_constraint(que_thr_t*,dict_foreign_t*,btr_pcur_t*,dtuple_t*,mtr_t*)" -> "dict_index_name_print(FILE*,const trx_t*,const dict_index_t*)"
"row_ins_foreign_check_on_constraint(que_thr_t*,dict_foreign_t*,btr_pcur_t*,dtuple_t*,mtr_t*)" -> "btr_pcur_copy_stored_position(btr_pcur_t*,btr_pcur_t*)"
"row_ins_foreign_check_on_constraint(que_thr_t*,dict_foreign_t*,btr_pcur_t*,dtuple_t*,mtr_t*)" -> "row_ins_cascade_ancestor_updates_table(que_node_t*,dict_table_t*)"
"row_ins_foreign_check_on_constraint(que_thr_t*,dict_foreign_t*,btr_pcur_t*,dtuple_t*,mtr_t*)" -> "btr_pcur_get_low_match(const btr_pcur_t*)"
"row_ins_foreign_check_on_constraint(que_thr_t*,dict_foreign_t*,btr_pcur_t*,dtuple_t*,mtr_t*)" -> "dict_index_get_nth_col_no(const dict_index_t*,ulint)"
"row_ins_foreign_check_on_constraint(que_thr_t*,dict_foreign_t*,btr_pcur_t*,dtuple_t*,mtr_t*)" -> "dict_index_get_n_unique(const dict_index_t*)"
"row_ins_foreign_check_on_constraint(que_thr_t*,dict_foreign_t*,btr_pcur_t*,dtuple_t*,mtr_t*)" -> "__builtin_fwrite(const void*,size_t,size_t,FILE*)"
"row_ins_foreign_check_on_constraint(que_thr_t*,dict_foreign_t*,btr_pcur_t*,dtuple_t*,mtr_t*)" -> "lock_clust_rec_read_check_and_lock_alt(ulint,const buf_block_t*,const rec_t*,dict_index_t*,lock_mode,ulint,que_thr_t*)"
"row_ins_foreign_check_on_constraint(que_thr_t*,dict_foreign_t*,btr_pcur_t*,dtuple_t*,mtr_t*)" -> "btr_pcur_open_with_no_init_func(dict_index_t*,const dtuple_t*,ulint,ulint,btr_pcur_t*,ulint,const char*,ulint,mtr_t*)"
"row_ins_foreign_check_on_constraint(que_thr_t*,dict_foreign_t*,btr_pcur_t*,dtuple_t*,mtr_t*)" -> "row_mysql_freeze_data_dictionary_func(trx_t*,const char*,ulint)"
"row_ins_foreign_check_on_constraint(que_thr_t*,dict_foreign_t*,btr_pcur_t*,dtuple_t*,mtr_t*)" -> "fprintf(FILE*,const char*,...)"
"row_ins_foreign_check_on_constraint(que_thr_t*,dict_foreign_t*,btr_pcur_t*,dtuple_t*,mtr_t*)" -> "row_mysql_unfreeze_data_dictionary(trx_t*)"
"row_ins_foreign_check_on_constraint(que_thr_t*,dict_foreign_t*,btr_pcur_t*,dtuple_t*,mtr_t*)" -> "page_rec_is_user_rec(const rec_t*)"
"row_ins_foreign_check_on_constraint(que_thr_t*,dict_foreign_t*,btr_pcur_t*,dtuple_t*,mtr_t*)" -> "abort()"
"row_ins_foreign_check_on_constraint(que_thr_t*,dict_foreign_t*,btr_pcur_t*,dtuple_t*,mtr_t*)" -> "row_create_update_node_for_mysql(dict_table_t*,mem_heap_t*)"
"row_ins_foreign_check_on_constraint(que_thr_t*,dict_foreign_t*,btr_pcur_t*,dtuple_t*,mtr_t*)" -> "btr_pcur_store_position(btr_pcur_t*,mtr_t*)"
"row_ins_foreign_check_on_constraint(que_thr_t*,dict_foreign_t*,btr_pcur_t*,dtuple_t*,mtr_t*)" -> "btr_pcur_restore_position_func(ulint,btr_pcur_t*,const char*,ulint,mtr_t*)"
"row_ins_foreign_check_on_constraint(que_thr_t*,dict_foreign_t*,btr_pcur_t*,dtuple_t*,mtr_t*)" -> "dict_table_is_fts_column(ib_vector_t*,ulint)"
"row_ins_foreign_check_on_constraint(que_thr_t*,dict_foreign_t*,btr_pcur_t*,dtuple_t*,mtr_t*)" -> "mtr_commit(mtr_t*)"
"row_ins_foreign_check_on_constraint(que_thr_t*,dict_foreign_t*,btr_pcur_t*,dtuple_t*,mtr_t*)" -> "mtr_start(mtr_t*)"
"row_ins_foreign_check_on_constraint(que_thr_t*,dict_foreign_t*,btr_pcur_t*,dtuple_t*,mtr_t*)" -> "row_ins_cascade_calc_update_vec(upd_node_t*,dict_foreign_t*,mem_heap_t*,trx_t*,ulint*)"
"row_ins_foreign_check_on_constraint(que_thr_t*,dict_foreign_t*,btr_pcur_t*,dtuple_t*,mtr_t*)" -> "row_ins_invalidate_query_cache(que_thr_t*,const char*)"
"row_ins_foreign_check_on_constraint(que_thr_t*,dict_foreign_t*,btr_pcur_t*,dtuple_t*,mtr_t*)" -> "mem_heap_create_func(ulint,ulint)"
"row_ins_foreign_check_on_constraint(que_thr_t*,dict_foreign_t*,btr_pcur_t*,dtuple_t*,mtr_t*)" -> "dict_table_get_nth_col_pos(const dict_table_t*,ulint)"
"row_ins_foreign_check_on_constraint(que_thr_t*,dict_foreign_t*,btr_pcur_t*,dtuple_t*,mtr_t*)" -> "rec_print(FILE*,const rec_t*,const dict_index_t*)"
"row_ins_foreign_check_on_constraint(que_thr_t*,dict_foreign_t*,btr_pcur_t*,dtuple_t*,mtr_t*)" -> "dict_index_is_clust(const dict_index_t*)"
"row_ins_foreign_check_on_constraint(que_thr_t*,dict_foreign_t*,btr_pcur_t*,dtuple_t*,mtr_t*)" -> "rec_get_deleted_flag(const rec_t*,ulint)"
"row_ins_foreign_check_on_constraint(que_thr_t*,dict_foreign_t*,btr_pcur_t*,dtuple_t*,mtr_t*)" -> "thr_get_trx(que_thr_t*)"
"row_ins_foreign_check_on_constraint(que_thr_t*,dict_foreign_t*,btr_pcur_t*,dtuple_t*,mtr_t*)" -> "fts_get_doc_id_from_rec(dict_table_t*,const rec_t*,mem_heap_t*)"
"row_ins_foreign_check_on_constraint(que_thr_t*,dict_foreign_t*,btr_pcur_t*,dtuple_t*,mtr_t*)" -> "__builtin_expect(long int,long int)"
"row_ins_foreign_check_on_constraint(que_thr_t*,dict_foreign_t*,btr_pcur_t*,dtuple_t*,mtr_t*)" -> "mem_heap_free_func(mem_heap_t*,const char*,ulint)"
"row_ins_foreign_check_on_constraint(que_thr_t*,dict_foreign_t*,btr_pcur_t*,dtuple_t*,mtr_t*)" -> "lock_table(ulint,dict_table_t*,lock_mode,que_thr_t*)"
"row_ins_foreign_check_on_constraint(que_thr_t*,dict_foreign_t*,btr_pcur_t*,dtuple_t*,mtr_t*)" -> "dict_table_is_comp(const dict_table_t*)"
"row_ins_foreign_check_on_constraint(que_thr_t*,dict_foreign_t*,btr_pcur_t*,dtuple_t*,mtr_t*)" -> "row_ins_foreign_report_err(const char*,que_thr_t*,dict_foreign_t*,const rec_t*,const dtuple_t*)"
"row_ins_foreign_check_on_constraint(que_thr_t*,dict_foreign_t*,btr_pcur_t*,dtuple_t*,mtr_t*)" -> "row_ins_cascade_n_ancestors(que_node_t*)"
"row_ins_foreign_check_on_constraint(que_thr_t*,dict_foreign_t*,btr_pcur_t*,dtuple_t*,mtr_t*)" -> "row_update_cascade_for_mysql(que_thr_t*,upd_node_t*,dict_table_t*)"
"row_ins_foreign_check_on_constraint(que_thr_t*,dict_foreign_t*,btr_pcur_t*,dtuple_t*,mtr_t*)" -> "fts_trx_add_op(trx_t*,dict_table_t*,doc_id_t,fts_row_state,ib_vector_t*)"
"btr_pcur_copy_stored_position(btr_pcur_t*,btr_pcur_t*)" -> "mem_free_func(void*,const char*,ulint)"
"btr_pcur_copy_stored_position(btr_pcur_t*,btr_pcur_t*)" -> "ut_memcpy(void*,const void*,ulint)"
"btr_pcur_copy_stored_position(btr_pcur_t*,btr_pcur_t*)" -> "mem_alloc_func(ulint,ulint*)"
"row_ins_cascade_ancestor_updates_table(que_node_t*,dict_table_t*)" -> "que_node_get_parent(que_node_t*)"
"row_ins_cascade_ancestor_updates_table(que_node_t*,dict_table_t*)" -> "que_node_get_type(que_node_t*)"
"lock_clust_rec_read_check_and_lock_alt(ulint,const buf_block_t*,const rec_t*,dict_index_t*,lock_mode,ulint,que_thr_t*)" -> "rec_get_offsets_func(const rec_t*,const dict_index_t*,ulint*,ulint,mem_heap_t**)"
"lock_clust_rec_read_check_and_lock_alt(ulint,const buf_block_t*,const rec_t*,dict_index_t*,lock_mode,ulint,que_thr_t*)" -> "lock_clust_rec_read_check_and_lock(ulint,const buf_block_t*,const rec_t*,dict_index_t*,const ulint*,lock_mode,ulint,que_thr_t*)"
"lock_clust_rec_read_check_and_lock_alt(ulint,const buf_block_t*,const rec_t*,dict_index_t*,lock_mode,ulint,que_thr_t*)" -> "mem_heap_free_func(mem_heap_t*,const char*,ulint)"
"lock_clust_rec_read_check_and_lock_alt(ulint,const buf_block_t*,const rec_t*,dict_index_t*,lock_mode,ulint,que_thr_t*)" -> "__builtin_expect(long int,long int)"
"lock_clust_rec_read_check_and_lock_alt(ulint,const buf_block_t*,const rec_t*,dict_index_t*,lock_mode,ulint,que_thr_t*)" -> "rec_offs_set_n_alloc(ulint*,ulint)"
"row_create_update_node_for_mysql(dict_table_t*,mem_heap_t*)" -> "upd_node_create(mem_heap_t*)"
"row_create_update_node_for_mysql(dict_table_t*,mem_heap_t*)" -> "dict_table_get_n_cols(const dict_table_t*)"
"row_create_update_node_for_mysql(dict_table_t*,mem_heap_t*)" -> "btr_pcur_create_for_mysql()"
"row_create_update_node_for_mysql(dict_table_t*,mem_heap_t*)" -> "upd_create(ulint,mem_heap_t*)"
"upd_node_create(mem_heap_t*)" -> "mem_heap_create_func(ulint,ulint)"
"upd_node_create(mem_heap_t*)" -> "mem_heap_alloc(mem_heap_t*,ulint)"
"btr_pcur_create_for_mysql()" -> "btr_pcur_init(btr_pcur_t*)"
"btr_pcur_create_for_mysql()" -> "mem_alloc_func(ulint,ulint*)"
"dict_table_is_fts_column(ib_vector_t*,ulint)" -> "ib_vector_size(const ib_vector_t*)"
"dict_table_is_fts_column(ib_vector_t*,ulint)" -> "dict_index_contains_col_or_prefix(const dict_index_t*,ulint)"
"dict_table_is_fts_column(ib_vector_t*,ulint)" -> "ib_vector_get(ib_vector_t*,ulint)"
"dict_index_contains_col_or_prefix(const dict_index_t*,ulint)" -> "dict_index_get_n_fields(const dict_index_t*)"
"dict_index_contains_col_or_prefix(const dict_index_t*,ulint)" -> "dict_index_is_clust(const dict_index_t*)"
"row_ins_cascade_calc_update_vec(upd_node_t*,dict_foreign_t*,mem_heap_t*,trx_t*,ulint*)" -> "fprintf(FILE*,const char*,...)"
"row_ins_cascade_calc_update_vec(upd_node_t*,dict_foreign_t*,mem_heap_t*,trx_t*,ulint*)" -> "fts_get_next_doc_id(const dict_table_t*,doc_id_t*)"
"row_ins_cascade_calc_update_vec(upd_node_t*,dict_foreign_t*,mem_heap_t*,trx_t*,ulint*)" -> "dict_table_is_fts_column(ib_vector_t*,ulint)"
"row_ins_cascade_calc_update_vec(upd_node_t*,dict_foreign_t*,mem_heap_t*,trx_t*,ulint*)" -> "__builtin_fwrite(const void*,size_t,size_t,FILE*)"
"row_ins_cascade_calc_update_vec(upd_node_t*,dict_foreign_t*,mem_heap_t*,trx_t*,ulint*)" -> "dfield_set_data(dfield_t*,const void*,ulint)"
"row_ins_cascade_calc_update_vec(upd_node_t*,dict_foreign_t*,mem_heap_t*,trx_t*,ulint*)" -> "fts_update_doc_id(dict_table_t*,upd_field_t*,doc_id_t*)"
"row_ins_cascade_calc_update_vec(upd_node_t*,dict_foreign_t*,mem_heap_t*,trx_t*,ulint*)" -> "ut_print_name(FILE*,const trx_t*,ulint,const char*)"
"row_ins_cascade_calc_update_vec(upd_node_t*,dict_foreign_t*,mem_heap_t*,trx_t*,ulint*)" -> "dtype_get_at_most_n_mbchars(ulint,ulint,ulint,ulint,const char*)"
"row_ins_cascade_calc_update_vec(upd_node_t*,dict_foreign_t*,mem_heap_t*,trx_t*,ulint*)" -> "dtype_get_charset_coll(ulint)"
"row_ins_cascade_calc_update_vec(upd_node_t*,dict_foreign_t*,mem_heap_t*,trx_t*,ulint*)" -> "putc(int,FILE*)"
"row_ins_cascade_calc_update_vec(upd_node_t*,dict_foreign_t*,mem_heap_t*,trx_t*,ulint*)" -> "abort()"
"row_ins_cascade_calc_update_vec(upd_node_t*,dict_foreign_t*,mem_heap_t*,trx_t*,ulint*)" -> "memcpy(void*,const void*,size_t)"
"row_ins_cascade_calc_update_vec(upd_node_t*,dict_foreign_t*,mem_heap_t*,trx_t*,ulint*)" -> "row_mysql_pad_col(ulint,unsigned char*,ulint)"
"row_ins_cascade_calc_update_vec(upd_node_t*,dict_foreign_t*,mem_heap_t*,trx_t*,ulint*)" -> "mem_heap_alloc(mem_heap_t*,ulint)"
"row_ins_cascade_calc_update_vec(upd_node_t*,dict_foreign_t*,mem_heap_t*,trx_t*,ulint*)" -> "mach_read_from_8(const unsigned char*)"
"row_ins_cascade_calc_update_vec(upd_node_t*,dict_foreign_t*,mem_heap_t*,trx_t*,ulint*)" -> "dfield_get_len(const dfield_t*)"
"row_ins_cascade_calc_update_vec(upd_node_t*,dict_foreign_t*,mem_heap_t*,trx_t*,ulint*)" -> "dict_index_get_nth_col_no(const dict_index_t*,ulint)"
"row_ins_cascade_calc_update_vec(upd_node_t*,dict_foreign_t*,mem_heap_t*,trx_t*,ulint*)" -> "dict_col_get_no(const dict_col_t*)"
"row_ins_cascade_calc_update_vec(upd_node_t*,dict_foreign_t*,mem_heap_t*,trx_t*,ulint*)" -> "dfield_is_null(const dfield_t*)"
"row_ins_cascade_calc_update_vec(upd_node_t*,dict_foreign_t*,mem_heap_t*,trx_t*,ulint*)" -> "dfield_set_len(dfield_t*,ulint)"
"row_ins_cascade_calc_update_vec(upd_node_t*,dict_foreign_t*,mem_heap_t*,trx_t*,ulint*)" -> "dict_col_get_mbminlen(const dict_col_t*)"
"row_ins_cascade_calc_update_vec(upd_node_t*,dict_foreign_t*,mem_heap_t*,trx_t*,ulint*)" -> "dict_col_get_min_size(const dict_col_t*)"
"row_ins_cascade_calc_update_vec(upd_node_t*,dict_foreign_t*,mem_heap_t*,trx_t*,ulint*)" -> "__builtin_expect(long int,long int)"
"row_ins_cascade_calc_update_vec(upd_node_t*,dict_foreign_t*,mem_heap_t*,trx_t*,ulint*)" -> "fts_trx_add_op(trx_t*,dict_table_t*,doc_id_t,fts_row_state,ib_vector_t*)"
"row_ins_cascade_calc_update_vec(upd_node_t*,dict_foreign_t*,mem_heap_t*,trx_t*,ulint*)" -> "ut_dbg_assertion_failed(const char*,const char*,ulint)"
"row_ins_cascade_calc_update_vec(upd_node_t*,dict_foreign_t*,mem_heap_t*,trx_t*,ulint*)" -> "dict_table_get_nth_col_pos(const dict_table_t*,ulint)"
"row_ins_cascade_calc_update_vec(upd_node_t*,dict_foreign_t*,mem_heap_t*,trx_t*,ulint*)" -> "dict_index_get_nth_col(const dict_index_t*,ulint)"
"fts_get_next_doc_id(const dict_table_t*,doc_id_t*)" -> "pfs_mutex_exit_func(ib_mutex_t*)"
"fts_get_next_doc_id(const dict_table_t*,doc_id_t*)" -> "pfs_mutex_enter_func(ib_mutex_t*,const char*,ulint)"
"fts_get_next_doc_id(const dict_table_t*,doc_id_t*)" -> "fts_init_doc_id(const dict_table_t*)"
"fts_init_doc_id(const dict_table_t*)" -> "pfs_rw_lock_x_unlock_func(rw_lock_t*)"
"fts_init_doc_id(const dict_table_t*)" -> "pfs_rw_lock_x_lock_func(rw_lock_t*,ulint,const char*,ulint)"
"fts_init_doc_id(const dict_table_t*)" -> "fts_init_index(dict_table_t*,ulint)"
"fts_init_doc_id(const dict_table_t*)" -> "fts_cmp_set_sync_doc_id(const dict_table_t*,doc_id_t,ulint,doc_id_t*)"
"fts_init_index(dict_table_t*,ulint)" -> "fts_doc_fetch_by_doc_id(fts_get_doc_t*,doc_id_t,dict_index_t*,ulint,fts_sql_callback,void*)"
"fts_init_index(dict_table_t*,ulint)" -> "pfs_mutex_exit_func(ib_mutex_t*)"
"fts_init_index(dict_table_t*,ulint)" -> "fts_load_stopword(const dict_table_t*,trx_t*,const char*,const char*,ulint,ulint)"
"fts_init_index(dict_table_t*,ulint)" -> "fts_optimize_add_table(dict_table_t*)"
"fts_init_index(dict_table_t*,ulint)" -> "fts_cmp_set_sync_doc_id(const dict_table_t*,doc_id_t,ulint,doc_id_t*)"
"fts_init_index(dict_table_t*,ulint)" -> "ib_vector_is_empty(const ib_vector_t*)"
"fts_init_index(dict_table_t*,ulint)" -> "pfs_rw_lock_x_unlock_func(rw_lock_t*)"
"fts_init_index(dict_table_t*,ulint)" -> "dict_table_get_index_on_name(dict_table_t*,const char*)"
"fts_init_index(dict_table_t*,ulint)" -> "fts_get_docs_clear(ib_vector_t*)"
"fts_init_index(dict_table_t*,ulint)" -> "ib_vector_get(ib_vector_t*,ulint)"
"fts_init_index(dict_table_t*,ulint)" -> "__builtin_expect(long int,long int)"
"fts_init_index(dict_table_t*,ulint)" -> "ut_dbg_assertion_failed(const char*,const char*,ulint)"
"fts_init_index(dict_table_t*,ulint)" -> "ib_vector_size(const ib_vector_t*)"
"fts_init_index(dict_table_t*,ulint)" -> "abort()"
"fts_init_index(dict_table_t*,ulint)" -> "pfs_mutex_enter_func(ib_mutex_t*,const char*,ulint)"
"fts_init_index(dict_table_t*,ulint)" -> "fts_get_docs_create(fts_cache_t*)"
"fts_init_index(dict_table_t*,ulint)" -> "pfs_rw_lock_x_lock_func(rw_lock_t*,ulint,const char*,ulint)"
"fts_doc_fetch_by_doc_id(fts_get_doc_t*,doc_id_t,dict_index_t*,ulint,fts_sql_callback,void*)" -> "pfs_mutex_enter_func(ib_mutex_t*,const char*,ulint)"
"fts_doc_fetch_by_doc_id(fts_get_doc_t*,doc_id_t,dict_index_t*,ulint,fts_sql_callback,void*)" -> "que_graph_free(que_t*)"
"fts_doc_fetch_by_doc_id(fts_get_doc_t*,doc_id_t,dict_index_t*,ulint,fts_sql_callback,void*)" -> "fts_eval_sql(trx_t*,que_t*)"
"fts_doc_fetch_by_doc_id(fts_get_doc_t*,doc_id_t,dict_index_t*,ulint,fts_sql_callback,void*)" -> "trx_free_for_background(trx_t*)"
"fts_doc_fetch_by_doc_id(fts_get_doc_t*,doc_id_t,dict_index_t*,ulint,fts_sql_callback,void*)" -> "pfs_mutex_exit_func(ib_mutex_t*)"
"fts_doc_fetch_by_doc_id(fts_get_doc_t*,doc_id_t,dict_index_t*,ulint,fts_sql_callback,void*)" -> "fts_get_select_columns_str(dict_index_t*,pars_info_t*,mem_heap_t*)"
"fts_doc_fetch_by_doc_id(fts_get_doc_t*,doc_id_t,dict_index_t*,ulint,fts_sql_callback,void*)" -> "mach_write_to_8(void*,ib_uint64_t)"
"fts_doc_fetch_by_doc_id(fts_get_doc_t*,doc_id_t,dict_index_t*,ulint,fts_sql_callback,void*)" -> "pars_info_bind_function(pars_info_t*,const char*,pars_user_func_cb_t,void*)"
"fts_doc_fetch_by_doc_id(fts_get_doc_t*,doc_id_t,dict_index_t*,ulint,fts_sql_callback,void*)" -> "pars_info_bind_int8_literal(pars_info_t*,const char*,const ib_uint64_t*)"
"fts_doc_fetch_by_doc_id(fts_get_doc_t*,doc_id_t,dict_index_t*,ulint,fts_sql_callback,void*)" -> "fts_sql_rollback(trx_t*)"
"fts_doc_fetch_by_doc_id(fts_get_doc_t*,doc_id_t,dict_index_t*,ulint,fts_sql_callback,void*)" -> "fts_parse_sql(fts_table_t*,pars_info_t*,const char*)"
"fts_doc_fetch_by_doc_id(fts_get_doc_t*,doc_id_t,dict_index_t*,ulint,fts_sql_callback,void*)" -> "mem_heap_printf(mem_heap_t*,const char*,...)"
"fts_doc_fetch_by_doc_id(fts_get_doc_t*,doc_id_t,dict_index_t*,ulint,fts_sql_callback,void*)" -> "pars_info_bind_id(pars_info_t*,ulint,const char*,const char*)"
"fts_doc_fetch_by_doc_id(fts_get_doc_t*,doc_id_t,dict_index_t*,ulint,fts_sql_callback,void*)" -> "fts_sql_commit(trx_t*)"
"fts_doc_fetch_by_doc_id(fts_get_doc_t*,doc_id_t,dict_index_t*,ulint,fts_sql_callback,void*)" -> "pars_info_create()"
"fts_doc_fetch_by_doc_id(fts_get_doc_t*,doc_id_t,dict_index_t*,ulint,fts_sql_callback,void*)" -> "trx_allocate_for_background()"
"fts_eval_sql(trx_t*,que_t*)" -> "que_run_threads(que_thr_t*)"
"fts_eval_sql(trx_t*,que_t*)" -> "abort()"
"fts_eval_sql(trx_t*,que_t*)" -> "ut_dbg_assertion_failed(const char*,const char*,ulint)"
"fts_eval_sql(trx_t*,que_t*)" -> "__builtin_expect(long int,long int)"
"fts_eval_sql(trx_t*,que_t*)" -> "que_fork_start_command(que_fork_t*)"
"fts_get_select_columns_str(dict_index_t*,pars_info_t*,mem_heap_t*)" -> "mem_heap_printf(mem_heap_t*,const char*,...)"
"fts_get_select_columns_str(dict_index_t*,pars_info_t*,mem_heap_t*)" -> "pars_info_bind_id(pars_info_t*,ulint,const char*,const char*)"
"mem_heap_printf(mem_heap_t*,const char*,...)" -> "mem_heap_alloc(mem_heap_t*,ulint)"
"mem_heap_printf(mem_heap_t*,const char*,...)" -> "mem_heap_printf_low(char*,const char*,__va_list_tag*)"
"mem_heap_printf(mem_heap_t*,const char*,...)" -> "__builtin_va_end(__va_list_tag*)"
"mem_heap_printf(mem_heap_t*,const char*,...)" -> "__builtin_va_start(__va_list_tag*,...)"
"mem_heap_printf_low(char*,const char*,__va_list_tag*)" -> "memcpy(void*,const void*,size_t)"
"mem_heap_printf_low(char*,const char*,__va_list_tag*)" -> "ut_dbg_assertion_failed(const char*,const char*,ulint)"
"mem_heap_printf_low(char*,const char*,__va_list_tag*)" -> "sprintf(char*,const char*,...)"
"mem_heap_printf_low(char*,const char*,__va_list_tag*)" -> "strlen(const char*)"
"mem_heap_printf_low(char*,const char*,__va_list_tag*)" -> "abort()"
"mem_heap_printf_low(char*,const char*,__va_list_tag*)" -> "__builtin_expect(long int,long int)"
"pars_info_bind_id(pars_info_t*,ulint,const char*,const char*)" -> "ib_heap_allocator_create(mem_heap_t*)"
"pars_info_bind_id(pars_info_t*,ulint,const char*,const char*)" -> "ib_vector_create(ib_alloc_t*,ulint,ulint)"
"pars_info_bind_id(pars_info_t*,ulint,const char*,const char*)" -> "ib_vector_push(ib_vector_t*,const void*)"
"pars_info_bind_id(pars_info_t*,ulint,const char*,const char*)" -> "mem_heap_strdup(mem_heap_t*,const char*)"
"pars_info_bind_id(pars_info_t*,ulint,const char*,const char*)" -> "pars_info_lookup_bound_id(pars_info_t*,const char*)"
"pars_info_lookup_bound_id(pars_info_t*,const char*)" -> "ib_vector_get(ib_vector_t*,ulint)"
"pars_info_lookup_bound_id(pars_info_t*,const char*)" -> "ib_vector_size(const ib_vector_t*)"
"pars_info_lookup_bound_id(pars_info_t*,const char*)" -> "strcmp(const char*,const char*)"
"pars_info_bind_function(pars_info_t*,const char*,pars_user_func_cb_t,void*)" -> "pars_info_lookup_user_func(pars_info_t*,const char*)"
"pars_info_bind_function(pars_info_t*,const char*,pars_user_func_cb_t,void*)" -> "ib_vector_push(ib_vector_t*,const void*)"
"pars_info_bind_function(pars_info_t*,const char*,pars_user_func_cb_t,void*)" -> "ib_vector_create(ib_alloc_t*,ulint,ulint)"
"pars_info_bind_function(pars_info_t*,const char*,pars_user_func_cb_t,void*)" -> "ib_heap_allocator_create(mem_heap_t*)"
"pars_info_lookup_user_func(pars_info_t*,const char*)" -> "strcmp(const char*,const char*)"
"pars_info_lookup_user_func(pars_info_t*,const char*)" -> "ib_vector_size(const ib_vector_t*)"
"pars_info_lookup_user_func(pars_info_t*,const char*)" -> "ib_vector_get(ib_vector_t*,ulint)"
"pars_info_bind_int8_literal(pars_info_t*,const char*,const ib_uint64_t*)" -> "pars_info_lookup_bound_lit(pars_info_t*,const char*)"
"pars_info_bind_int8_literal(pars_info_t*,const char*,const ib_uint64_t*)" -> "pars_info_add_literal(pars_info_t*,const char*,const void*,ulint,ulint,ulint)"
"pars_info_bind_int8_literal(pars_info_t*,const char*,const ib_uint64_t*)" -> "sym_tab_rebind_lit(sym_node_t*,const void*,ulint)"
"pars_info_lookup_bound_lit(pars_info_t*,const char*)" -> "ib_vector_size(const ib_vector_t*)"
"pars_info_lookup_bound_lit(pars_info_t*,const char*)" -> "strcmp(const char*,const char*)"
"pars_info_lookup_bound_lit(pars_info_t*,const char*)" -> "ib_vector_get(ib_vector_t*,ulint)"
"pars_info_add_literal(pars_info_t*,const char*,const void*,ulint,ulint,ulint)" -> "ib_heap_allocator_create(mem_heap_t*)"
"pars_info_add_literal(pars_info_t*,const char*,const void*,ulint,ulint,ulint)" -> "ib_vector_push(ib_vector_t*,const void*)"
"pars_info_add_literal(pars_info_t*,const char*,const void*,ulint,ulint,ulint)" -> "mem_heap_alloc(mem_heap_t*,ulint)"
"pars_info_add_literal(pars_info_t*,const char*,const void*,ulint,ulint,ulint)" -> "ib_vector_create(ib_alloc_t*,ulint,ulint)"
"sym_tab_rebind_lit(sym_node_t*,const void*,ulint)" -> "pars_like_rebind(sym_node_t*,const unsigned char*,ulint)"
"sym_tab_rebind_lit(sym_node_t*,const void*,ulint)" -> "que_node_get_val(que_node_t*)"
"sym_tab_rebind_lit(sym_node_t*,const void*,ulint)" -> "dtype_get_mtype(const dtype_t*)"
"sym_tab_rebind_lit(sym_node_t*,const void*,ulint)" -> "sel_col_prefetch_buf_free(sel_buf_t*)"
"sym_tab_rebind_lit(sym_node_t*,const void*,ulint)" -> "__builtin_expect(long int,long int)"
"sym_tab_rebind_lit(sym_node_t*,const void*,ulint)" -> "que_graph_free_recursive(que_node_t*)"
"sym_tab_rebind_lit(sym_node_t*,const void*,ulint)" -> "ut_dbg_assertion_failed(const char*,const char*,ulint)"
"sym_tab_rebind_lit(sym_node_t*,const void*,ulint)" -> "dfield_set_data(dfield_t*,const void*,ulint)"
"sym_tab_rebind_lit(sym_node_t*,const void*,ulint)" -> "abort()"
"pars_like_rebind(sym_node_t*,const unsigned char*,ulint)" -> "mach_write_to_4(unsigned char*,ulint)"
"pars_like_rebind(sym_node_t*,const unsigned char*,ulint)" -> "__builtin_expect(long int,long int)"
"pars_like_rebind(sym_node_t*,const unsigned char*,ulint)" -> "dtype_get_mtype(const dtype_t*)"
"pars_like_rebind(sym_node_t*,const unsigned char*,ulint)" -> "sym_tab_add_str_lit(sym_tab_t*,const unsigned char*,ulint)"
"pars_like_rebind(sym_node_t*,const unsigned char*,ulint)" -> "dfield_set_len(dfield_t*,ulint)"
"pars_like_rebind(sym_node_t*,const unsigned char*,ulint)" -> "dfield_set_data(dfield_t*,const void*,ulint)"
"pars_like_rebind(sym_node_t*,const unsigned char*,ulint)" -> "mach_read_from_4(const unsigned char*)"
"pars_like_rebind(sym_node_t*,const unsigned char*,ulint)" -> "abort()"
"pars_like_rebind(sym_node_t*,const unsigned char*,ulint)" -> "ut_dbg_assertion_failed(const char*,const char*,ulint)"
"pars_like_rebind(sym_node_t*,const unsigned char*,ulint)" -> "sym_tab_add_int_lit(sym_tab_t*,ulint)"
"pars_like_rebind(sym_node_t*,const unsigned char*,ulint)" -> "que_node_list_add_last(que_node_t*,que_node_t*)"
"pars_like_rebind(sym_node_t*,const unsigned char*,ulint)" -> "que_node_get_val(que_node_t*)"
"pars_like_rebind(sym_node_t*,const unsigned char*,ulint)" -> "que_node_list_get_last(que_node_t*)"
"sym_tab_add_str_lit(sym_tab_t*,const unsigned char*,ulint)" -> "mem_heap_alloc(mem_heap_t*,ulint)"
"sym_tab_add_str_lit(sym_tab_t*,const unsigned char*,ulint)" -> "ut_list_append(List&,Type&,size_t) [with List = ut_list_base<sym_node_t>,Type = sym_node_t,size_t = long unsigned int]"
"sym_tab_add_str_lit(sym_tab_t*,const unsigned char*,ulint)" -> "dfield_set_data(dfield_t*,const void*,ulint)"
"sym_tab_add_str_lit(sym_tab_t*,const unsigned char*,ulint)" -> "dtype_set(dtype_t*,ulint,ulint,ulint)"
"sym_tab_add_str_lit(sym_tab_t*,const unsigned char*,ulint)" -> "mem_heap_dup(mem_heap_t*,const void*,ulint)"
"sym_tab_add_int_lit(sym_tab_t*,ulint)" -> "ut_list_append(List&,Type&,size_t) [with List = ut_list_base<sym_node_t>,Type = sym_node_t,size_t = long unsigned int]"
"sym_tab_add_int_lit(sym_tab_t*,ulint)" -> "mach_write_to_4(unsigned char*,ulint)"
"sym_tab_add_int_lit(sym_tab_t*,ulint)" -> "dfield_set_data(dfield_t*,const void*,ulint)"
"sym_tab_add_int_lit(sym_tab_t*,ulint)" -> "mem_heap_alloc(mem_heap_t*,ulint)"
"sym_tab_add_int_lit(sym_tab_t*,ulint)" -> "dtype_set(dtype_t*,ulint,ulint,ulint)"
"que_node_list_get_last(que_node_t*)" -> "__builtin_expect(long int,long int)"
"que_node_list_get_last(que_node_t*)" -> "ut_dbg_assertion_failed(const char*,const char*,ulint)"
"que_node_list_get_last(que_node_t*)" -> "abort()"
"sel_col_prefetch_buf_free(sel_buf_t*)" -> "mem_free_func(void*,const char*,ulint)"
"fts_sql_rollback(trx_t*)" -> "trx_rollback_to_savepoint(trx_t*,trx_savept_t*)"
"trx_rollback_to_savepoint(trx_t*,trx_savept_t*)" -> "trx_start_if_not_started_xa_low(trx_t*)"
"trx_rollback_to_savepoint(trx_t*,trx_savept_t*)" -> "trx_rollback_to_savepoint_low(trx_t*,trx_savept_t*)"
"trx_start_if_not_started_xa_low(trx_t*)" -> "ut_dbg_assertion_failed(const char*,const char*,ulint)"
"trx_start_if_not_started_xa_low(trx_t*)" -> "trx_start_low(trx_t*)"
"trx_start_if_not_started_xa_low(trx_t*)" -> "thd_supports_xa(THD*)"
"trx_start_if_not_started_xa_low(trx_t*)" -> "abort()"
"trx_start_low(trx_t*)" -> "ut_dbg_assertion_failed(const char*,const char*,ulint)"
"trx_start_low(trx_t*)" -> "ut_time()"
"trx_start_low(trx_t*)" -> "pfs_mutex_exit_func(ib_mutex_t*)"
"trx_start_low(trx_t*)" -> "thd_trx_is_read_only(THD*)"
"trx_start_low(trx_t*)" -> "abort()"
"trx_start_low(trx_t*)" -> "pfs_mutex_enter_func(ib_mutex_t*,const char*,ulint)"
"trx_start_low(trx_t*)" -> "trx_sys_get_new_trx_id()"
"trx_start_low(trx_t*)" -> "__builtin_expect(long int,long int)"
"trx_start_low(trx_t*)" -> "ib_vector_is_empty(const ib_vector_t*)"
"trx_start_low(trx_t*)" -> "thd_trx_is_auto_commit(THD*)"
"trx_start_low(trx_t*)" -> "trx_assign_rseg_low(ulong,ulint)"
"trx_start_low(trx_t*)" -> "ut_list_prepend(List&,Type&,size_t) [with List = ut_list_base<trx_t>,Type = trx_t,size_t = long unsigned int]"
"thd_trx_is_read_only(THD*)" -> "thd_tx_is_read_only(const THD*)"
"thd_trx_is_auto_commit(THD*)" -> "thd_test_options(const THD*,long long int)"
"thd_trx_is_auto_commit(THD*)" -> "thd_is_select(const THD*)"
"thd_is_select(const THD*)" -> "thd_sql_command(const THD*)"
"ut_list_prepend(List&,Type&,size_t) [with List = ut_list_base<trx_t>,Type = trx_t,size_t = long unsigned int]" -> "ut_elem_get_node(Type&,size_t) [with Type = trx_t,size_t = long unsigned int]"
"trx_rollback_to_savepoint_low(trx_t*,trx_savept_t*)" -> "trx_rollback_finish(trx_t*)"
"trx_rollback_to_savepoint_low(trx_t*,trx_savept_t*)" -> "que_graph_free(que_t*)"
"trx_rollback_to_savepoint_low(trx_t*,trx_savept_t*)" -> "que_fork_start_command(que_fork_t*)"
"trx_rollback_to_savepoint_low(trx_t*,trx_savept_t*)" -> "abort()"
"trx_rollback_to_savepoint_low(trx_t*,trx_savept_t*)" -> "pars_complete_graph_for_exec(que_node_t*,trx_t*,mem_heap_t*)"
"trx_rollback_to_savepoint_low(trx_t*,trx_savept_t*)" -> "mem_heap_create_func(ulint,ulint)"
"trx_rollback_to_savepoint_low(trx_t*,trx_savept_t*)" -> "que_node_get_parent(que_node_t*)"
"trx_rollback_to_savepoint_low(trx_t*,trx_savept_t*)" -> "roll_node_create(mem_heap_t*)"
"trx_rollback_to_savepoint_low(trx_t*,trx_savept_t*)" -> "mem_heap_free_func(mem_heap_t*,const char*,ulint)"
"trx_rollback_to_savepoint_low(trx_t*,trx_savept_t*)" -> "que_run_threads(que_thr_t*)"
"trx_rollback_to_savepoint_low(trx_t*,trx_savept_t*)" -> "ut_dbg_assertion_failed(const char*,const char*,ulint)"
"trx_rollback_to_savepoint_low(trx_t*,trx_savept_t*)" -> "__builtin_expect(long int,long int)"
"trx_rollback_to_savepoint_low(trx_t*,trx_savept_t*)" -> "srv_active_wake_master_thread()"
"trx_rollback_finish(trx_t*)" -> "ut_dbg_assertion_failed(const char*,const char*,ulint)"
"trx_rollback_finish(trx_t*)" -> "__builtin_expect(long int,long int)"
"trx_rollback_finish(trx_t*)" -> "abort()"
"trx_rollback_finish(trx_t*)" -> "trx_commit(trx_t*)"
"pars_complete_graph_for_exec(que_node_t*,trx_t*,mem_heap_t*)" -> "que_thr_create(que_fork_t*,mem_heap_t*)"
"pars_complete_graph_for_exec(que_node_t*,trx_t*,mem_heap_t*)" -> "que_node_set_parent(que_node_t*,que_node_t*)"
"pars_complete_graph_for_exec(que_node_t*,trx_t*,mem_heap_t*)" -> "que_fork_create(que_t*,que_node_t*,ulint,mem_heap_t*)"
"que_thr_create(que_fork_t*,mem_heap_t*)" -> "ut_list_append(List&,Type&,size_t) [with List = ut_list_base<que_thr_t>,Type = que_thr_t,size_t = long unsigned int]"
"que_thr_create(que_fork_t*,mem_heap_t*)" -> "mem_heap_zalloc(mem_heap_t*,ulint)"
"ut_list_append(List&,Type&,size_t) [with List = ut_list_base<que_thr_t>,Type = que_thr_t,size_t = long unsigned int]" -> "ut_elem_get_node(Type&,size_t) [with Type = que_thr_t,size_t = long unsigned int]"
"ut_elem_get_node(Type&,size_t) [with Type = que_thr_t,size_t = long unsigned int]" -> "abort()"
"ut_elem_get_node(Type&,size_t) [with Type = que_thr_t,size_t = long unsigned int]" -> "ut_dbg_assertion_failed(const char*,const char*,ulint)"
"ut_elem_get_node(Type&,size_t) [with Type = que_thr_t,size_t = long unsigned int]" -> "__builtin_expect(long int,long int)"
"que_fork_create(que_t*,que_node_t*,ulint,mem_heap_t*)" -> "mem_heap_zalloc(mem_heap_t*,ulint)"
"roll_node_create(mem_heap_t*)" -> "mem_heap_zalloc(mem_heap_t*,ulint)"
"fts_sql_commit(trx_t*)" -> "trx_commit_for_mysql(trx_t*)"
"fts_sql_commit(trx_t*)" -> "ut_dbg_assertion_failed(const char*,const char*,ulint)"
"fts_sql_commit(trx_t*)" -> "__builtin_expect(long int,long int)"
"fts_sql_commit(trx_t*)" -> "abort()"
"fts_load_stopword(const dict_table_t*,trx_t*,const char*,const char*,ulint,ulint)" -> "trx_free_for_background(trx_t*)"
"fts_load_stopword(const dict_table_t*,trx_t*,const char*,const char*,ulint,ulint)" -> "ut_strlen(const char*)"
"fts_load_stopword(const dict_table_t*,trx_t*,const char*,const char*,ulint,ulint)" -> "fts_sql_rollback(trx_t*)"
"fts_load_stopword(const dict_table_t*,trx_t*,const char*,const char*,ulint,ulint)" -> "fts_config_get_value(trx_t*,fts_table_t*,const char*,fts_string_t*)"
"fts_load_stopword(const dict_table_t*,trx_t*,const char*,const char*,ulint,ulint)" -> "rbt_create(size_t,ib_rbt_compare)"
"fts_load_stopword(const dict_table_t*,trx_t*,const char*,const char*,ulint,ulint)" -> "fts_config_get_ulint(trx_t*,fts_table_t*,const char*,ulint*)"
"fts_load_stopword(const dict_table_t*,trx_t*,const char*,const char*,ulint,ulint)" -> "fts_load_default_stopword(fts_stopword_t*)"
"fts_load_stopword(const dict_table_t*,trx_t*,const char*,const char*,ulint,ulint)" -> "fts_sql_commit(trx_t*)"
"fts_load_stopword(const dict_table_t*,trx_t*,const char*,const char*,ulint,ulint)" -> "fts_load_user_stopword(fts_t*,const char*,fts_stopword_t*)"
"fts_load_stopword(const dict_table_t*,trx_t*,const char*,const char*,ulint,ulint)" -> "fts_config_set_value(trx_t*,fts_table_t*,const char*,const fts_string_t*)"
"fts_load_stopword(const dict_table_t*,trx_t*,const char*,const char*,ulint,ulint)" -> "fts_config_set_ulint(trx_t*,fts_table_t*,const char*,ulint)"
"fts_load_stopword(const dict_table_t*,trx_t*,const char*,const char*,ulint,ulint)" -> "trx_allocate_for_background()"
"fts_config_get_value(trx_t*,fts_table_t*,const char*,fts_string_t*)" -> "pars_info_bind_varchar_literal(pars_info_t*,const char*,const unsigned char*,ulint)"
"fts_config_get_value(trx_t*,fts_table_t*,const char*,fts_string_t*)" -> "fts_parse_sql(fts_table_t*,pars_info_t*,const char*)"
"fts_config_get_value(trx_t*,fts_table_t*,const char*,fts_string_t*)" -> "pars_info_bind_function(pars_info_t*,const char*,pars_user_func_cb_t,void*)"
"fts_config_get_value(trx_t*,fts_table_t*,const char*,fts_string_t*)" -> "pfs_mutex_exit_func(ib_mutex_t*)"
"fts_config_get_value(trx_t*,fts_table_t*,const char*,fts_string_t*)" -> "ut_dbg_assertion_failed(const char*,const char*,ulint)"
"fts_config_get_value(trx_t*,fts_table_t*,const char*,fts_string_t*)" -> "pfs_mutex_enter_func(ib_mutex_t*,const char*,ulint)"
"fts_config_get_value(trx_t*,fts_table_t*,const char*,fts_string_t*)" -> "que_graph_free(que_t*)"
"fts_config_get_value(trx_t*,fts_table_t*,const char*,fts_string_t*)" -> "pars_info_create()"
"fts_config_get_value(trx_t*,fts_table_t*,const char*,fts_string_t*)" -> "abort()"
"fts_config_get_value(trx_t*,fts_table_t*,const char*,fts_string_t*)" -> "strlen(const char*)"
"fts_config_get_value(trx_t*,fts_table_t*,const char*,fts_string_t*)" -> "__builtin_expect(long int,long int)"
"fts_config_get_value(trx_t*,fts_table_t*,const char*,fts_string_t*)" -> "fts_eval_sql(trx_t*,que_t*)"
"pars_info_bind_varchar_literal(pars_info_t*,const char*,const unsigned char*,ulint)" -> "pars_info_add_literal(pars_info_t*,const char*,const void*,ulint,ulint,ulint)"
"pars_info_bind_varchar_literal(pars_info_t*,const char*,const unsigned char*,ulint)" -> "pars_info_lookup_bound_lit(pars_info_t*,const char*)"
"pars_info_bind_varchar_literal(pars_info_t*,const char*,const unsigned char*,ulint)" -> "sym_tab_rebind_lit(sym_node_t*,const void*,ulint)"
"fts_config_get_ulint(trx_t*,fts_table_t*,const char*,ulint*)" -> "strtoul(const char*,char**,int)"
"fts_config_get_ulint(trx_t*,fts_table_t*,const char*,ulint*)" -> "ut_print_timestamp(FILE*)"
"fts_config_get_ulint(trx_t*,fts_table_t*,const char*,ulint*)" -> "ut_malloc_low(ulint,ulint)"
"fts_config_get_ulint(trx_t*,fts_table_t*,const char*,ulint*)" -> "ut_strerr(dberr_t)"
"fts_config_get_ulint(trx_t*,fts_table_t*,const char*,ulint*)" -> "__builtin_expect(long int,long int)"
"fts_config_get_ulint(trx_t*,fts_table_t*,const char*,ulint*)" -> "fts_config_get_value(trx_t*,fts_table_t*,const char*,fts_string_t*)"
"fts_config_get_ulint(trx_t*,fts_table_t*,const char*,ulint*)" -> "fprintf(FILE*,const char*,...)"
"fts_config_get_ulint(trx_t*,fts_table_t*,const char*,ulint*)" -> "ut_free(void*)"
"fts_load_default_stopword(fts_stopword_t*)" -> "ut_strlen(const char*)"
"fts_load_default_stopword(fts_stopword_t*)" -> "ib_vector_create(ib_alloc_t*,ulint,ulint)"
"fts_load_default_stopword(fts_stopword_t*)" -> "rbt_create(size_t,ib_rbt_compare)"
"fts_load_default_stopword(fts_stopword_t*)" -> "rbt_insert(ib_rbt_t*,const void*,const void*)"
"fts_load_default_stopword(fts_stopword_t*)" -> "fts_utf8_string_dup(fts_string_t*,const fts_string_t*,mem_heap_t*)"
"fts_utf8_string_dup(fts_string_t*,const fts_string_t*,mem_heap_t*)" -> "mem_heap_alloc(mem_heap_t*,ulint)"
"fts_utf8_string_dup(fts_string_t*,const fts_string_t*,mem_heap_t*)" -> "memcpy(void*,const void*,size_t)"
"fts_load_user_stopword(fts_t*,const char*,fts_stopword_t*)" -> "pars_info_bind_function(pars_info_t*,const char*,pars_user_func_cb_t,void*)"
"fts_load_user_stopword(fts_t*,const char*,fts_stopword_t*)" -> "rbt_create_arg_cmp(size_t,ib_rbt_arg_compare,void*)"
"fts_load_user_stopword(fts_t*,const char*,fts_stopword_t*)" -> "fts_valid_stopword_table(const char*)"
"fts_load_user_stopword(fts_t*,const char*,fts_stopword_t*)" -> "trx_allocate_for_background()"
"fts_load_user_stopword(fts_t*,const char*,fts_stopword_t*)" -> "fts_parse_sql_no_dict_lock(fts_table_t*,pars_info_t*,const char*)"
"fts_load_user_stopword(fts_t*,const char*,fts_stopword_t*)" -> "fts_sql_rollback(trx_t*)"
"fts_load_user_stopword(fts_t*,const char*,fts_stopword_t*)" -> "ut_print_timestamp(FILE*)"
"fts_load_user_stopword(fts_t*,const char*,fts_stopword_t*)" -> "pfs_mutex_enter_func(ib_mutex_t*,const char*,ulint)"
"fts_load_user_stopword(fts_t*,const char*,fts_stopword_t*)" -> "ut_strerr(dberr_t)"
"fts_load_user_stopword(fts_t*,const char*,fts_stopword_t*)" -> "trx_free_for_background(trx_t*)"
"fts_load_user_stopword(fts_t*,const char*,fts_stopword_t*)" -> "que_graph_free(que_t*)"
"fts_load_user_stopword(fts_t*,const char*,fts_stopword_t*)" -> "fprintf(FILE*,const char*,...)"
"fts_load_user_stopword(fts_t*,const char*,fts_stopword_t*)" -> "fts_sql_commit(trx_t*)"
"fts_load_user_stopword(fts_t*,const char*,fts_stopword_t*)" -> "pfs_mutex_exit_func(ib_mutex_t*)"
"fts_load_user_stopword(fts_t*,const char*,fts_stopword_t*)" -> "pars_info_create()"
"fts_load_user_stopword(fts_t*,const char*,fts_stopword_t*)" -> "fts_eval_sql(trx_t*,que_t*)"
"fts_load_user_stopword(fts_t*,const char*,fts_stopword_t*)" -> "pars_info_bind_id(pars_info_t*,ulint,const char*,const char*)"
"fts_load_user_stopword(fts_t*,const char*,fts_stopword_t*)" -> "__builtin_fwrite(const void*,size_t,size_t,FILE*)"
"fts_valid_stopword_table(const char*)" -> "ut_strcmp(const char*,const char*)"
"fts_valid_stopword_table(const char*)" -> "dict_table_get_low(const char*)"
"fts_valid_stopword_table(const char*)" -> "fprintf(FILE*,const char*,...)"
"fts_valid_stopword_table(const char*)" -> "dtype_get_charset_coll(ulint)"
"fts_valid_stopword_table(const char*)" -> "dict_table_get_col_name(const dict_table_t*,ulint)"
"fts_valid_stopword_table(const char*)" -> "innobase_get_fts_charset(int,uint)"
"fts_parse_sql_no_dict_lock(fts_table_t*,pars_info_t*,const char*)" -> "mem_free_func(void*,const char*,ulint)"
"fts_parse_sql_no_dict_lock(fts_table_t*,pars_info_t*,const char*)" -> "abort()"
"fts_parse_sql_no_dict_lock(fts_table_t*,pars_info_t*,const char*)" -> "fts_get_table_name(const fts_table_t*)"
"fts_parse_sql_no_dict_lock(fts_table_t*,pars_info_t*,const char*)" -> "ut_str3cat(const char*,const char*,const char*)"
"fts_parse_sql_no_dict_lock(fts_table_t*,pars_info_t*,const char*)" -> "pars_sql(pars_info_t*,const char*)"
"fts_parse_sql_no_dict_lock(fts_table_t*,pars_info_t*,const char*)" -> "__builtin_expect(long int,long int)"
"fts_parse_sql_no_dict_lock(fts_table_t*,pars_info_t*,const char*)" -> "ut_dbg_assertion_failed(const char*,const char*,ulint)"
"fts_parse_sql_no_dict_lock(fts_table_t*,pars_info_t*,const char*)" -> "ut_strreplace(const char*,const char*,const char*)"
"fts_config_set_value(trx_t*,fts_table_t*,const char*,const fts_string_t*)" -> "pars_info_bind_varchar_literal(pars_info_t*,const char*,const unsigned char*,ulint)"
"fts_config_set_value(trx_t*,fts_table_t*,const char*,const fts_string_t*)" -> "pars_info_create()"
"fts_config_set_value(trx_t*,fts_table_t*,const char*,const fts_string_t*)" -> "fts_parse_sql(fts_table_t*,pars_info_t*,const char*)"
"fts_config_set_value(trx_t*,fts_table_t*,const char*,const fts_string_t*)" -> "fts_que_graph_free_check_lock(fts_table_t*,const fts_index_cache_t*,que_t*)"
"fts_config_set_value(trx_t*,fts_table_t*,const char*,const fts_string_t*)" -> "strlen(const char*)"
"fts_config_set_value(trx_t*,fts_table_t*,const char*,const fts_string_t*)" -> "fts_eval_sql(trx_t*,que_t*)"
"fts_config_set_ulint(trx_t*,fts_table_t*,const char*,ulint)" -> "ut_free(void*)"
"fts_config_set_ulint(trx_t*,fts_table_t*,const char*,ulint)" -> "__builtin_expect(long int,long int)"
"fts_config_set_ulint(trx_t*,fts_table_t*,const char*,ulint)" -> "ut_malloc_low(ulint,ulint)"
"fts_config_set_ulint(trx_t*,fts_table_t*,const char*,ulint)" -> "ut_print_timestamp(FILE*)"
"fts_config_set_ulint(trx_t*,fts_table_t*,const char*,ulint)" -> "snprintf(char*,size_t,const char*,...)"
"fts_config_set_ulint(trx_t*,fts_table_t*,const char*,ulint)" -> "fts_config_set_value(trx_t*,fts_table_t*,const char*,const fts_string_t*)"
"fts_config_set_ulint(trx_t*,fts_table_t*,const char*,ulint)" -> "fprintf(FILE*,const char*,...)"
"fts_config_set_ulint(trx_t*,fts_table_t*,const char*,ulint)" -> "ut_strerr(dberr_t)"
"fts_optimize_add_table(dict_table_t*)" -> "fts_optimize_create_msg(fts_msg_type_t,void*)"
"fts_optimize_add_table(dict_table_t*)" -> "dict_table_move_from_lru_to_non_lru(dict_table_t*)"
"fts_optimize_add_table(dict_table_t*)" -> "ib_wqueue_add(ib_wqueue_t*,void*,mem_heap_t*)"
"fts_cmp_set_sync_doc_id(const dict_table_t*,doc_id_t,ulint,doc_id_t*)" -> "fts_eval_sql(trx_t*,que_t*)"
"fts_cmp_set_sync_doc_id(const dict_table_t*,doc_id_t,ulint,doc_id_t*)" -> "trx_allocate_for_background()"
"fts_cmp_set_sync_doc_id(const dict_table_t*,doc_id_t,ulint,doc_id_t*)" -> "abort()"
"fts_cmp_set_sync_doc_id(const dict_table_t*,doc_id_t,ulint,doc_id_t*)" -> "ut_dbg_assertion_failed(const char*,const char*,ulint)"
"fts_cmp_set_sync_doc_id(const dict_table_t*,doc_id_t,ulint,doc_id_t*)" -> "ut_print_timestamp(FILE*)"
"fts_cmp_set_sync_doc_id(const dict_table_t*,doc_id_t,ulint,doc_id_t*)" -> "pars_info_create()"
"fts_cmp_set_sync_doc_id(const dict_table_t*,doc_id_t,ulint,doc_id_t*)" -> "ut_max(ulint,ulint)"
"fts_cmp_set_sync_doc_id(const dict_table_t*,doc_id_t,ulint,doc_id_t*)" -> "fts_parse_sql(fts_table_t*,pars_info_t*,const char*)"
"fts_cmp_set_sync_doc_id(const dict_table_t*,doc_id_t,ulint,doc_id_t*)" -> "__builtin_expect(long int,long int)"
"fts_cmp_set_sync_doc_id(const dict_table_t*,doc_id_t,ulint,doc_id_t*)" -> "fts_sql_commit(trx_t*)"
"fts_cmp_set_sync_doc_id(const dict_table_t*,doc_id_t,ulint,doc_id_t*)" -> "fprintf(FILE*,const char*,...)"
"fts_cmp_set_sync_doc_id(const dict_table_t*,doc_id_t,ulint,doc_id_t*)" -> "os_thread_sleep(ulint)"
"fts_cmp_set_sync_doc_id(const dict_table_t*,doc_id_t,ulint,doc_id_t*)" -> "pfs_mutex_enter_func(ib_mutex_t*,const char*,ulint)"
"fts_cmp_set_sync_doc_id(const dict_table_t*,doc_id_t,ulint,doc_id_t*)" -> "fts_update_sync_doc_id(const dict_table_t*,const char*,doc_id_t,trx_t*)"
"fts_cmp_set_sync_doc_id(const dict_table_t*,doc_id_t,ulint,doc_id_t*)" -> "fts_que_graph_free_check_lock(fts_table_t*,const fts_index_cache_t*,que_t*)"
"fts_cmp_set_sync_doc_id(const dict_table_t*,doc_id_t,ulint,doc_id_t*)" -> "trx_free_for_background(trx_t*)"
"fts_cmp_set_sync_doc_id(const dict_table_t*,doc_id_t,ulint,doc_id_t*)" -> "pfs_mutex_exit_func(ib_mutex_t*)"
"fts_cmp_set_sync_doc_id(const dict_table_t*,doc_id_t,ulint,doc_id_t*)" -> "fts_sql_rollback(trx_t*)"
"fts_cmp_set_sync_doc_id(const dict_table_t*,doc_id_t,ulint,doc_id_t*)" -> "ut_strerr(dberr_t)"
"fts_cmp_set_sync_doc_id(const dict_table_t*,doc_id_t,ulint,doc_id_t*)" -> "pars_info_bind_function(pars_info_t*,const char*,pars_user_func_cb_t,void*)"
"fts_update_sync_doc_id(const dict_table_t*,const char*,doc_id_t,trx_t*)" -> "fts_sql_rollback(trx_t*)"
"fts_update_sync_doc_id(const dict_table_t*,const char*,doc_id_t,trx_t*)" -> "fts_parse_sql(fts_table_t*,pars_info_t*,const char*)"
"fts_update_sync_doc_id(const dict_table_t*,const char*,doc_id_t,trx_t*)" -> "fts_que_graph_free_check_lock(fts_table_t*,const fts_index_cache_t*,que_t*)"
"fts_update_sync_doc_id(const dict_table_t*,const char*,doc_id_t,trx_t*)" -> "trx_allocate_for_background()"
"fts_update_sync_doc_id(const dict_table_t*,const char*,doc_id_t,trx_t*)" -> "pars_info_bind_varchar_literal(pars_info_t*,const char*,const unsigned char*,ulint)"
"fts_update_sync_doc_id(const dict_table_t*,const char*,doc_id_t,trx_t*)" -> "trx_free_for_background(trx_t*)"
"fts_update_sync_doc_id(const dict_table_t*,const char*,doc_id_t,trx_t*)" -> "ib_logf(ib_log_level_t,const char*,...)"
"fts_update_sync_doc_id(const dict_table_t*,const char*,doc_id_t,trx_t*)" -> "ut_strerr(dberr_t)"
"fts_update_sync_doc_id(const dict_table_t*,const char*,doc_id_t,trx_t*)" -> "pars_info_create()"
"fts_update_sync_doc_id(const dict_table_t*,const char*,doc_id_t,trx_t*)" -> "snprintf(char*,size_t,const char*,...)"
"fts_update_sync_doc_id(const dict_table_t*,const char*,doc_id_t,trx_t*)" -> "fts_sql_commit(trx_t*)"
"fts_update_sync_doc_id(const dict_table_t*,const char*,doc_id_t,trx_t*)" -> "fts_eval_sql(trx_t*,que_t*)"
"dict_table_get_index_on_name(dict_table_t*,const char*)" -> "innobase_strcasecmp(const char*,const char*)"
"fts_get_docs_clear(ib_vector_t*)" -> "abort()"
"fts_get_docs_clear(ib_vector_t*)" -> "ut_dbg_assertion_failed(const char*,const char*,ulint)"
"fts_get_docs_clear(ib_vector_t*)" -> "__builtin_expect(long int,long int)"
"fts_get_docs_clear(ib_vector_t*)" -> "ib_vector_get(ib_vector_t*,ulint)"
"fts_get_docs_clear(ib_vector_t*)" -> "ib_vector_size(const ib_vector_t*)"
"fts_get_docs_clear(ib_vector_t*)" -> "pfs_mutex_enter_func(ib_mutex_t*,const char*,ulint)"
"fts_get_docs_clear(ib_vector_t*)" -> "que_graph_free(que_t*)"
"fts_get_docs_clear(ib_vector_t*)" -> "pfs_mutex_exit_func(ib_mutex_t*)"
"fts_get_docs_create(fts_cache_t*)" -> "ib_vector_create(ib_alloc_t*,ulint,ulint)"
"fts_get_docs_create(fts_cache_t*)" -> "ib_vector_size(const ib_vector_t*)"
"fts_get_docs_create(fts_cache_t*)" -> "fts_get_index_cache(fts_cache_t*,const dict_index_t*)"
"fts_get_docs_create(fts_cache_t*)" -> "abort()"
"fts_get_docs_create(fts_cache_t*)" -> "ib_vector_push(ib_vector_t*,const void*)"
"fts_get_docs_create(fts_cache_t*)" -> "memset(void*,int,size_t)"
"fts_get_docs_create(fts_cache_t*)" -> "ut_dbg_assertion_failed(const char*,const char*,ulint)"
"fts_get_docs_create(fts_cache_t*)" -> "__builtin_expect(long int,long int)"
"fts_get_docs_create(fts_cache_t*)" -> "ib_vector_get(ib_vector_t*,ulint)"
"fts_get_index_cache(fts_cache_t*,const dict_index_t*)" -> "ib_vector_size(const ib_vector_t*)"
"fts_get_index_cache(fts_cache_t*,const dict_index_t*)" -> "ib_vector_get(ib_vector_t*,ulint)"
"fts_update_doc_id(dict_table_t*,upd_field_t*,doc_id_t*)" -> "fts_get_next_doc_id(const dict_table_t*,doc_id_t*)"
"fts_update_doc_id(dict_table_t*,upd_field_t*,doc_id_t*)" -> "__builtin_expect(long int,long int)"
"fts_update_doc_id(dict_table_t*,upd_field_t*,doc_id_t*)" -> "ut_dbg_assertion_failed(const char*,const char*,ulint)"
"fts_update_doc_id(dict_table_t*,upd_field_t*,doc_id_t*)" -> "mach_write_to_8(void*,ib_uint64_t)"
"fts_update_doc_id(dict_table_t*,upd_field_t*,doc_id_t*)" -> "dict_col_get_clust_pos(const dict_col_t*,const dict_index_t*)"
"fts_update_doc_id(dict_table_t*,upd_field_t*,doc_id_t*)" -> "abort()"
"row_mysql_pad_col(ulint,unsigned char*,ulint)" -> "abort()"
"row_mysql_pad_col(ulint,unsigned char*,ulint)" -> "memset(void*,int,size_t)"
"row_mysql_pad_col(ulint,unsigned char*,ulint)" -> "ut_dbg_assertion_failed(const char*,const char*,ulint)"
"row_mysql_pad_col(ulint,unsigned char*,ulint)" -> "__builtin_expect(long int,long int)"
"dict_col_get_mbminlen(const dict_col_t*)" -> "__builtin_expect(long int,long int)"
"dict_col_get_min_size(const dict_col_t*)" -> "dtype_get_min_size_low(ulint,ulint,ulint,ulint)"
"dtype_get_min_size_low(ulint,ulint,ulint,ulint)" -> "ut_dbg_assertion_failed(const char*,const char*,ulint)"
"dtype_get_min_size_low(ulint,ulint,ulint,ulint)" -> "abort()"
"dtype_get_min_size_low(ulint,ulint,ulint,ulint)" -> "__builtin_expect(long int,long int)"
"fts_trx_add_op(trx_t*,dict_table_t*,doc_id_t,fts_row_state,ib_vector_t*)" -> "fts_trx_create(trx_t*)"
"fts_trx_add_op(trx_t*,dict_table_t*,doc_id_t,fts_row_state,ib_vector_t*)" -> "fts_trx_init(trx_t*,dict_table_t*,ib_vector_t*)"
"fts_trx_add_op(trx_t*,dict_table_t*,doc_id_t,fts_row_state,ib_vector_t*)" -> "fts_trx_table_add_op(fts_trx_table_t*,doc_id_t,fts_row_state,ib_vector_t*)"
"fts_trx_create(trx_t*)" -> "ib_vector_create(ib_alloc_t*,ulint,ulint)"
"fts_trx_create(trx_t*)" -> "__builtin_expect(long int,long int)"
"fts_trx_create(trx_t*)" -> "fts_savepoint_create(ib_vector_t*,const char*,mem_heap_t*)"
"fts_trx_create(trx_t*)" -> "abort()"
"fts_trx_create(trx_t*)" -> "mem_heap_alloc(mem_heap_t*,ulint)"
"fts_trx_create(trx_t*)" -> "fts_savepoint_take(trx_t*,fts_trx_t*,const char*)"
"fts_trx_create(trx_t*)" -> "ib_heap_allocator_create(mem_heap_t*)"
"fts_trx_create(trx_t*)" -> "ut_dbg_assertion_failed(const char*,const char*,ulint)"
"fts_trx_create(trx_t*)" -> "mem_heap_create_func(ulint,ulint)"
"fts_savepoint_create(ib_vector_t*,const char*,mem_heap_t*)" -> "memset(void*,int,size_t)"
"fts_savepoint_create(ib_vector_t*,const char*,mem_heap_t*)" -> "mem_heap_strdup(mem_heap_t*,const char*)"
"fts_savepoint_create(ib_vector_t*,const char*,mem_heap_t*)" -> "ib_vector_push(ib_vector_t*,const void*)"
"fts_savepoint_create(ib_vector_t*,const char*,mem_heap_t*)" -> "rbt_create(size_t,ib_rbt_compare)"
"fts_savepoint_take(trx_t*,fts_trx_t*,const char*)" -> "fts_savepoint_create(ib_vector_t*,const char*,mem_heap_t*)"
"fts_savepoint_take(trx_t*,fts_trx_t*,const char*)" -> "fts_savepoint_copy(const fts_savepoint_t*,fts_savepoint_t*)"
"fts_savepoint_take(trx_t*,fts_trx_t*,const char*)" -> "abort()"
"fts_savepoint_take(trx_t*,fts_trx_t*,const char*)" -> "ib_vector_last(ib_vector_t*)"
"fts_savepoint_take(trx_t*,fts_trx_t*,const char*)" -> "__builtin_expect(long int,long int)"
"fts_savepoint_take(trx_t*,fts_trx_t*,const char*)" -> "ut_dbg_assertion_failed(const char*,const char*,ulint)"
"fts_savepoint_take(trx_t*,fts_trx_t*,const char*)" -> "ib_vector_size(const ib_vector_t*)"
"fts_savepoint_copy(const fts_savepoint_t*,fts_savepoint_t*)" -> "rbt_next(const ib_rbt_t*,const ib_rbt_node_t*)"
"fts_savepoint_copy(const fts_savepoint_t*,fts_savepoint_t*)" -> "fts_trx_table_clone(const fts_trx_table_t*)"
"fts_savepoint_copy(const fts_savepoint_t*,fts_savepoint_t*)" -> "rbt_first(const ib_rbt_t*)"
"fts_savepoint_copy(const fts_savepoint_t*,fts_savepoint_t*)" -> "rbt_insert(ib_rbt_t*,const void*,const void*)"
"fts_trx_table_clone(const fts_trx_table_t*)" -> "rbt_create(size_t,ib_rbt_compare)"
"fts_trx_table_clone(const fts_trx_table_t*)" -> "mem_heap_alloc(mem_heap_t*,ulint)"
"fts_trx_table_clone(const fts_trx_table_t*)" -> "__builtin_expect(long int,long int)"
"fts_trx_table_clone(const fts_trx_table_t*)" -> "ut_dbg_assertion_failed(const char*,const char*,ulint)"
"fts_trx_table_clone(const fts_trx_table_t*)" -> "abort()"
"fts_trx_table_clone(const fts_trx_table_t*)" -> "memset(void*,int,size_t)"
"fts_trx_table_clone(const fts_trx_table_t*)" -> "rbt_merge_uniq(ib_rbt_t*,const ib_rbt_t*)"
"rbt_merge_uniq(ib_rbt_t*,const ib_rbt_t*)" -> "rbt_next(const ib_rbt_t*,const ib_rbt_node_t*)"
"rbt_merge_uniq(ib_rbt_t*,const ib_rbt_t*)" -> "rbt_first(const ib_rbt_t*)"
"rbt_merge_uniq(ib_rbt_t*,const ib_rbt_t*)" -> "rbt_search(const ib_rbt_t*,ib_rbt_bound_t*,const void*)"
"rbt_merge_uniq(ib_rbt_t*,const ib_rbt_t*)" -> "rbt_add_node(ib_rbt_t*,ib_rbt_bound_t*,const void*)"
"rbt_add_node(ib_rbt_t*,ib_rbt_bound_t*,const void*)" -> "memcpy(void*,const void*,size_t)"
"rbt_add_node(ib_rbt_t*,ib_rbt_bound_t*,const void*)" -> "rbt_balance_tree(const ib_rbt_t*,ib_rbt_node_t*)"
"rbt_add_node(ib_rbt_t*,ib_rbt_bound_t*,const void*)" -> "ut_malloc_low(ulint,ulint)"
"rbt_add_node(ib_rbt_t*,ib_rbt_bound_t*,const void*)" -> "rbt_tree_add_child(const ib_rbt_t*,ib_rbt_bound_t*,ib_rbt_node_t*)"
"fts_trx_init(trx_t*,dict_table_t*,ib_vector_t*)" -> "rbt_search_cmp(const ib_rbt_t*,ib_rbt_bound_t*,const void*,ib_rbt_compare,ib_rbt_arg_compare)"
"fts_trx_init(trx_t*,dict_table_t*,ib_vector_t*)" -> "abort()"
"fts_trx_init(trx_t*,dict_table_t*,ib_vector_t*)" -> "fts_trx_table_create(fts_trx_t*,dict_table_t*)"
"fts_trx_init(trx_t*,dict_table_t*,ib_vector_t*)" -> "ut_dbg_assertion_failed(const char*,const char*,ulint)"
"fts_trx_init(trx_t*,dict_table_t*,ib_vector_t*)" -> "ib_vector_last(ib_vector_t*)"
"fts_trx_init(trx_t*,dict_table_t*,ib_vector_t*)" -> "rbt_add_node(ib_rbt_t*,ib_rbt_bound_t*,const void*)"
"fts_trx_init(trx_t*,dict_table_t*,ib_vector_t*)" -> "__builtin_expect(long int,long int)"
"fts_trx_table_create(fts_trx_t*,dict_table_t*)" -> "mem_heap_alloc(mem_heap_t*,ulint)"
"fts_trx_table_create(fts_trx_t*,dict_table_t*)" -> "memset(void*,int,size_t)"
"fts_trx_table_create(fts_trx_t*,dict_table_t*)" -> "rbt_create(size_t,ib_rbt_compare)"
"fts_trx_table_add_op(fts_trx_table_t*,doc_id_t,fts_row_state,ib_vector_t*)" -> "fts_trx_row_get_new_state(fts_row_state,fts_row_state)"
"fts_trx_table_add_op(fts_trx_table_t*,doc_id_t,fts_row_state,ib_vector_t*)" -> "ut_free(void*)"
"fts_trx_table_add_op(fts_trx_table_t*,doc_id_t,fts_row_state,ib_vector_t*)" -> "rbt_add_node(ib_rbt_t*,ib_rbt_bound_t*,const void*)"
"fts_trx_table_add_op(fts_trx_table_t*,doc_id_t,fts_row_state,ib_vector_t*)" -> "rbt_remove_node(ib_rbt_t*,const ib_rbt_node_t*)"
"fts_trx_table_add_op(fts_trx_table_t*,doc_id_t,fts_row_state,ib_vector_t*)" -> "ib_vector_free(ib_vector_t*)"
"fts_trx_table_add_op(fts_trx_table_t*,doc_id_t,fts_row_state,ib_vector_t*)" -> "rbt_search(const ib_rbt_t*,ib_rbt_bound_t*,const void*)"
"fts_trx_row_get_new_state(fts_row_state,fts_row_state)" -> "ut_dbg_assertion_failed(const char*,const char*,ulint)"
"fts_trx_row_get_new_state(fts_row_state,fts_row_state)" -> "abort()"
"fts_trx_row_get_new_state(fts_row_state,fts_row_state)" -> "__builtin_expect(long int,long int)"
"dict_table_get_nth_col_pos(const dict_table_t*,ulint)" -> "dict_index_get_nth_col_pos(const dict_index_t*,ulint)"
"row_ins_invalidate_query_cache(que_thr_t*,const char*)" -> "ut_dbg_assertion_failed(const char*,const char*,ulint)"
"row_ins_invalidate_query_cache(que_thr_t*,const char*)" -> "innobase_invalidate_query_cache(trx_t*,const char*,ulint)"
"row_ins_invalidate_query_cache(que_thr_t*,const char*)" -> "thr_get_trx(que_thr_t*)"
"row_ins_invalidate_query_cache(que_thr_t*,const char*)" -> "abort()"
"row_ins_invalidate_query_cache(que_thr_t*,const char*)" -> "strchr(char*,int)"
"row_ins_invalidate_query_cache(que_thr_t*,const char*)" -> "mem_free_func(void*,const char*,ulint)"
"row_ins_invalidate_query_cache(que_thr_t*,const char*)" -> "mem_strdupl(const char*,ulint)"
"row_ins_invalidate_query_cache(que_thr_t*,const char*)" -> "__builtin_expect(long int,long int)"
"row_ins_invalidate_query_cache(que_thr_t*,const char*)" -> "strlen(const char*)"
"innobase_invalidate_query_cache(trx_t*,const char*,ulint)" -> "filename_to_tablename(const char*,char*,uint)"
"innobase_invalidate_query_cache(trx_t*,const char*,ulint)" -> "strlen(const char*)"
"innobase_invalidate_query_cache(trx_t*,const char*,ulint)" -> "mysql_query_cache_invalidate4(THD*,const char*,unsigned int,int)"
"filename_to_tablename(const char*,char*,uint)" -> "strconvert(CHARSET_INFO*,const char*,CHARSET_INFO*,char*,uint,uint*)"
"filename_to_tablename(const char*,char*,uint)" -> "strxnmov(char*,size_t,const char*,...)"
"filename_to_tablename(const char*,char*,uint)" -> "memcmp(const void*,const void*,size_t)"
"filename_to_tablename(const char*,char*,uint)" -> "strnmov(char*,const char*,size_t)"
"filename_to_tablename(const char*,char*,uint)" -> "strlen(const char*)"
"filename_to_tablename(const char*,char*,uint)" -> "sql_print_error(const char*,...)"
"mysql_query_cache_invalidate4(THD*,const char*,unsigned int,int)" -> "Query_cache::invalidate(THD*,const char*,uint32,my_bool)"
"Query_cache::invalidate(THD*,const char*,uint32,my_bool)" -> "Query_cache::invalidate_table(THD*,uchar*,uint32)"
"Query_cache::invalidate(THD*,const char*,uint32,my_bool)" -> "THD::in_multi_stmt_transaction_mode() const"
"Query_cache::invalidate(THD*,const char*,uint32,my_bool)" -> "Query_cache::is_disabled()"
"Query_cache::invalidate(THD*,const char*,uint32,my_bool)" -> "THD::add_changed_table(const char*,long int)"
"THD::add_changed_table(const char*,long int)" -> "THD::changed_table_dup(const char*,long int)"
"THD::add_changed_table(const char*,long int)" -> "memcmp(const void*,const void*,size_t)"
"THD::add_changed_table(const char*,long int)" -> "list_include(CHANGED_TABLE_LIST**,CHANGED_TABLE_LIST*,CHANGED_TABLE_LIST*)"
"THD::changed_table_dup(const char*,long int)" -> "memcpy(void*,const void*,size_t)"
"THD::changed_table_dup(const char*,long int)" -> "my_error(int,myf,...)"
"THD::changed_table_dup(const char*,long int)" -> "THD::trans_alloc(unsigned int)"
"THD::trans_alloc(unsigned int)" -> "alloc_root(MEM_ROOT*,size_t)"
"fts_get_doc_id_from_rec(dict_table_t*,const rec_t*,mem_heap_t*)" -> "rec_offs_set_n_alloc(ulint*,ulint)"
"fts_get_doc_id_from_rec(dict_table_t*,const rec_t*,mem_heap_t*)" -> "rec_get_nth_field_offs(const ulint*,ulint,ulint*)"
"fts_get_doc_id_from_rec(dict_table_t*,const rec_t*,mem_heap_t*)" -> "mem_heap_free_func(mem_heap_t*,const char*,ulint)"
"fts_get_doc_id_from_rec(dict_table_t*,const rec_t*,mem_heap_t*)" -> "abort()"
"fts_get_doc_id_from_rec(dict_table_t*,const rec_t*,mem_heap_t*)" -> "__builtin_expect(long int,long int)"
"fts_get_doc_id_from_rec(dict_table_t*,const rec_t*,mem_heap_t*)" -> "rec_get_offsets_func(const rec_t*,const dict_index_t*,ulint*,ulint,mem_heap_t**)"
"fts_get_doc_id_from_rec(dict_table_t*,const rec_t*,mem_heap_t*)" -> "ut_dbg_assertion_failed(const char*,const char*,ulint)"
"fts_get_doc_id_from_rec(dict_table_t*,const rec_t*,mem_heap_t*)" -> "mach_read_from_8(const unsigned char*)"
"fts_get_doc_id_from_rec(dict_table_t*,const rec_t*,mem_heap_t*)" -> "dict_col_get_clust_pos(const dict_col_t*,const dict_index_t*)"
"row_ins_cascade_n_ancestors(que_node_t*)" -> "que_node_get_parent(que_node_t*)"
"row_ins_cascade_n_ancestors(que_node_t*)" -> "que_node_get_type(que_node_t*)"
"row_update_cascade_for_mysql(que_thr_t*,upd_node_t*,dict_table_t*)" -> "thr_get_trx(que_thr_t*)"
"row_update_cascade_for_mysql(que_thr_t*,upd_node_t*,dict_table_t*)" -> "lock_wait_suspend_thread(que_thr_t*)"
"row_update_cascade_for_mysql(que_thr_t*,upd_node_t*,dict_table_t*)" -> "Indexer>::add(size_t,Type) [with Type = long unsigned int,int N = 64,Indexer = thread_id_indexer_t,size_t = long unsigned int]"
"row_update_cascade_for_mysql(que_thr_t*,upd_node_t*,dict_table_t*)" -> "row_update_statistics_if_needed(dict_table_t*)"
"row_update_cascade_for_mysql(que_thr_t*,upd_node_t*,dict_table_t*)" -> "dict_table_n_rows_dec(dict_table_t*)"
"row_update_cascade_for_mysql(que_thr_t*,upd_node_t*,dict_table_t*)" -> "row_upd_step(que_thr_t*)"
"row_update_cascade_for_mysql(que_thr_t*,upd_node_t*,dict_table_t*)" -> "que_thr_stop_for_mysql(que_thr_t*)"
"Indexer>::add(size_t,Type) [with Type = long unsigned int,int N = 64,Indexer = thread_id_indexer_t,size_t = long unsigned int]" -> "N>::offset(size_t) const [with Type = long unsigned int,int N = 64,size_t = long unsigned int]"
"row_update_statistics_if_needed(dict_table_t*)" -> "dict_stats_update(dict_table_t*,dict_stats_upd_option_t)"
"row_update_statistics_if_needed(dict_table_t*)" -> "dict_stats_auto_recalc_is_enabled(const dict_table_t*)"
"row_update_statistics_if_needed(dict_table_t*)" -> "dict_stats_recalc_pool_add(const dict_table_t*)"
"row_update_statistics_if_needed(dict_table_t*)" -> "dict_table_get_n_rows(const dict_table_t*)"
"row_update_statistics_if_needed(dict_table_t*)" -> "dict_stats_is_persistent_enabled(const dict_table_t*)"
"dict_stats_update(dict_table_t*,dict_stats_upd_option_t)" -> "dict_stats_auto_recalc_is_enabled(const dict_table_t*)"
"dict_stats_update(dict_table_t*,dict_stats_upd_option_t)" -> "dict_stats_table_clone_free(dict_table_t*)"
"dict_stats_update(dict_table_t*,dict_stats_upd_option_t)" -> "dict_stats_copy(dict_table_t*,const dict_table_t*)"
"dict_stats_update(dict_table_t*,dict_stats_upd_option_t)" -> "ut_strerr(dberr_t)"
"dict_stats_update(dict_table_t*,dict_stats_upd_option_t)" -> "dict_stats_update_transient(dict_table_t*)"
"dict_stats_update(dict_table_t*,dict_stats_upd_option_t)" -> "dict_stats_persistent_storage_check(bool)"
"dict_stats_update(dict_table_t*,dict_stats_upd_option_t)" -> "strchr(char*,int)"
"dict_stats_update(dict_table_t*,dict_stats_upd_option_t)" -> "fprintf(FILE*,const char*,...)"
"dict_stats_update(dict_table_t*,dict_stats_upd_option_t)" -> "abort()"
"dict_stats_update(dict_table_t*,dict_stats_upd_option_t)" -> "dict_stats_table_clone_create(const dict_table_t*)"
"dict_stats_update(dict_table_t*,dict_stats_upd_option_t)" -> "dict_stats_update_persistent(dict_table_t*)"
"dict_stats_update(dict_table_t*,dict_stats_upd_option_t)" -> "dict_stats_empty_table(dict_table_t*)"
"dict_stats_update(dict_table_t*,dict_stats_upd_option_t)" -> "dict_stats_fetch_from_ps(dict_table_t*)"
"dict_stats_update(dict_table_t*,dict_stats_upd_option_t)" -> "__builtin_expect(long int,long int)"
"dict_stats_update(dict_table_t*,dict_stats_upd_option_t)" -> "dict_stats_update(dict_table_t*,dict_stats_upd_option_t)"
"dict_stats_update(dict_table_t*,dict_stats_upd_option_t)" -> "dict_stats_is_persistent_enabled(const dict_table_t*)"
"dict_stats_update(dict_table_t*,dict_stats_upd_option_t)" -> "dict_stats_save(dict_table_t*,const index_id_t*)"
"dict_stats_update(dict_table_t*,dict_stats_upd_option_t)" -> "ut_format_name(const char*,ulint,char*,ulint)"
"dict_stats_update(dict_table_t*,dict_stats_upd_option_t)" -> "dict_stats_assert_initialized(const dict_table_t*)"
"dict_stats_update(dict_table_t*,dict_stats_upd_option_t)" -> "ut_print_timestamp(FILE*)"
"dict_stats_update(dict_table_t*,dict_stats_upd_option_t)" -> "ut_dbg_assertion_failed(const char*,const char*,ulint)"
"dict_stats_update(dict_table_t*,dict_stats_upd_option_t)" -> "dict_table_stats_unlock(dict_table_t*,ulint)"
"dict_stats_update(dict_table_t*,dict_stats_upd_option_t)" -> "dict_table_stats_lock(dict_table_t*,ulint)"
"dict_stats_table_clone_free(dict_table_t*)" -> "dict_table_stats_latch_destroy(dict_table_t*)"
"dict_stats_table_clone_free(dict_table_t*)" -> "mem_heap_free_func(mem_heap_t*,const char*,ulint)"
"dict_stats_copy(dict_table_t*,const dict_table_t*)" -> "dict_stats_empty_index(dict_index_t*)"
"dict_stats_copy(dict_table_t*,const dict_table_t*)" -> "dict_stats_should_ignore_index(const dict_index_t*)"
"dict_stats_copy(dict_table_t*,const dict_table_t*)" -> "memmove(void*,const void*,size_t)"
"dict_stats_copy(dict_table_t*,const dict_table_t*)" -> "strcmp(const char*,const char*)"
"dict_stats_should_ignore_index(const dict_index_t*)" -> "dict_index_is_corrupted(const dict_index_t*)"
"dict_stats_update_transient(dict_table_t*)" -> "dict_table_is_discarded(const dict_table_t*)"
"dict_stats_update_transient(dict_table_t*)" -> "dict_stats_empty_table(dict_table_t*)"
"dict_stats_update_transient(dict_table_t*)" -> "ut_time()"
"dict_stats_update_transient(dict_table_t*)" -> "ut_print_timestamp(FILE*)"
"dict_stats_update_transient(dict_table_t*)" -> "dict_index_get_n_unique(const dict_index_t*)"
"dict_stats_update_transient(dict_table_t*)" -> "fprintf(FILE*,const char*,...)"
"dict_stats_update_transient(dict_table_t*)" -> "dict_stats_should_ignore_index(const dict_index_t*)"
"dict_stats_update_transient(dict_table_t*)" -> "dict_stats_update_transient_for_index(dict_index_t*)"
"dict_stats_update_transient(dict_table_t*)" -> "ut_format_name(const char*,ulint,char*,ulint)"
"dict_stats_update_transient(dict_table_t*)" -> "dict_stats_empty_index(dict_index_t*)"
"dict_stats_empty_table(dict_table_t*)" -> "dict_table_stats_lock(dict_table_t*,ulint)"
"dict_stats_empty_table(dict_table_t*)" -> "dict_stats_empty_index(dict_index_t*)"
"dict_stats_empty_table(dict_table_t*)" -> "dict_table_stats_unlock(dict_table_t*,ulint)"
"dict_table_stats_lock(dict_table_t*,ulint)" -> "os_once::do_or_wait_for_done(volatile state_t*,void (*)(void*),void*)"
"dict_table_stats_lock(dict_table_t*,ulint)" -> "abort()"
"dict_table_stats_lock(dict_table_t*,ulint)" -> "pfs_rw_lock_s_lock_func(rw_lock_t*,ulint,const char*,ulint)"
"dict_table_stats_lock(dict_table_t*,ulint)" -> "ut_dbg_assertion_failed(const char*,const char*,ulint)"
"dict_table_stats_lock(dict_table_t*,ulint)" -> "pfs_rw_lock_x_lock_func(rw_lock_t*,ulint,const char*,ulint)"
"os_once::do_or_wait_for_done(volatile state_t*,void (*)(void*),void*)" -> "abort()"
"os_once::do_or_wait_for_done(volatile state_t*,void (*)(void*),void*)" -> "__sync_bool_compare_and_swap_4(volatile void*,unsigned int,unsigned int)"
"os_once::do_or_wait_for_done(volatile state_t*,void (*)(void*),void*)" -> "ut_dbg_assertion_failed(const char*,const char*,ulint)"
"os_once::do_or_wait_for_done(volatile state_t*,void (*)(void*),void*)" -> "__builtin_expect(long int,long int)"
"dict_table_stats_unlock(dict_table_t*,ulint)" -> "pfs_rw_lock_x_unlock_func(rw_lock_t*)"
"dict_table_stats_unlock(dict_table_t*,ulint)" -> "ut_dbg_assertion_failed(const char*,const char*,ulint)"
"dict_table_stats_unlock(dict_table_t*,ulint)" -> "pfs_rw_lock_s_unlock_func(rw_lock_t*)"
"dict_table_stats_unlock(dict_table_t*,ulint)" -> "abort()"
"dict_stats_update_transient_for_index(dict_index_t*)" -> "btr_estimate_number_of_different_key_vals(dict_index_t*)"
"dict_stats_update_transient_for_index(dict_index_t*)" -> "btr_get_size(dict_index_t*,ulint,mtr_t*)"
"dict_stats_update_transient_for_index(dict_index_t*)" -> "mtr_s_lock_func(rw_lock_t*,const char*,ulint,mtr_t*)"
"dict_stats_update_transient_for_index(dict_index_t*)" -> "dict_stats_empty_index(dict_index_t*)"
"dict_stats_update_transient_for_index(dict_index_t*)" -> "mtr_start(mtr_t*)"
"dict_stats_update_transient_for_index(dict_index_t*)" -> "dict_index_get_lock(dict_index_t*)"
"dict_stats_update_transient_for_index(dict_index_t*)" -> "dict_index_is_clust(const dict_index_t*)"
"dict_stats_update_transient_for_index(dict_index_t*)" -> "mtr_commit(mtr_t*)"
"btr_estimate_number_of_different_key_vals(dict_index_t*)" -> "dict_index_get_n_unique_in_tree(const dict_index_t*)"
"btr_estimate_number_of_different_key_vals(dict_index_t*)" -> "ut_dbg_assertion_failed(const char*,const char*,ulint)"
"btr_estimate_number_of_different_key_vals(dict_index_t*)" -> "btr_page_get_prev(const ib_page_t*,mtr_t*)"
"btr_estimate_number_of_different_key_vals(dict_index_t*)" -> "abort()"
"btr_estimate_number_of_different_key_vals(dict_index_t*)" -> "btr_page_get_next(const ib_page_t*,mtr_t*)"
"btr_estimate_number_of_different_key_vals(dict_index_t*)" -> "mem_heap_free_func(mem_heap_t*,const char*,ulint)"
"btr_estimate_number_of_different_key_vals(dict_index_t*)" -> "mem_heap_zalloc(mem_heap_t*,ulint)"
"btr_estimate_number_of_different_key_vals(dict_index_t*)" -> "cmp_rec_rec_with_match(const rec_t*,const rec_t*,const ulint*,const ulint*,dict_index_t*,ulint,ulint*,ulint*)"
"btr_estimate_number_of_different_key_vals(dict_index_t*)" -> "mem_heap_create_func(ulint,ulint)"
"btr_estimate_number_of_different_key_vals(dict_index_t*)" -> "page_rec_is_supremum(const rec_t*)"
"btr_estimate_number_of_different_key_vals(dict_index_t*)" -> "rec_get_offsets_func(const rec_t*,const dict_index_t*,ulint*,ulint,mem_heap_t**)"
"btr_estimate_number_of_different_key_vals(dict_index_t*)" -> "mtr_start(mtr_t*)"
"btr_estimate_number_of_different_key_vals(dict_index_t*)" -> "dict_index_get_n_fields(const dict_index_t*)"
"btr_estimate_number_of_different_key_vals(dict_index_t*)" -> "dict_index_get_n_unique(const dict_index_t*)"
"btr_estimate_number_of_different_key_vals(dict_index_t*)" -> "btr_rec_get_externally_stored_len(const rec_t*,const ulint*)"
"btr_estimate_number_of_different_key_vals(dict_index_t*)" -> "page_get_infimum_offset(const ib_page_t*)"
"btr_estimate_number_of_different_key_vals(dict_index_t*)" -> "btr_cur_open_at_rnd_pos_func(dict_index_t*,ulint,btr_cur_t*,const char*,ulint,mtr_t*)"
"btr_estimate_number_of_different_key_vals(dict_index_t*)" -> "mtr_commit(mtr_t*)"
"btr_estimate_number_of_different_key_vals(dict_index_t*)" -> "btr_record_not_null_field_in_rec(ulint,const ulint*,ib_uint64_t*)"
"btr_estimate_number_of_different_key_vals(dict_index_t*)" -> "btr_cur_get_page(btr_cur_t*)"
"btr_estimate_number_of_different_key_vals(dict_index_t*)" -> "page_rec_get_next(rec_t*)"
"cmp_rec_rec_with_match(const rec_t*,const rec_t*,const ulint*,const ulint*,dict_index_t*,ulint,ulint*,ulint*)" -> "__builtin_expect(long int,long int)"
"cmp_rec_rec_with_match(const rec_t*,const rec_t*,const ulint*,const ulint*,dict_index_t*,ulint,ulint*,ulint*)" -> "rec_offs_n_fields(const ulint*)"
"cmp_rec_rec_with_match(const rec_t*,const rec_t*,const ulint*,const ulint*,dict_index_t*,ulint,ulint*,ulint*)" -> "cmp_whole_field(ulint,ulint,const unsigned char*,unsigned int,const unsigned char*,unsigned int)"
"cmp_rec_rec_with_match(const rec_t*,const rec_t*,const ulint*,const ulint*,dict_index_t*,ulint,ulint*,ulint*)" -> "rec_offs_comp(const ulint*)"
"cmp_rec_rec_with_match(const rec_t*,const rec_t*,const ulint*,const ulint*,dict_index_t*,ulint,ulint*,ulint*)" -> "dict_index_get_nth_col(const dict_index_t*,ulint)"
"cmp_rec_rec_with_match(const rec_t*,const rec_t*,const ulint*,const ulint*,dict_index_t*,ulint,ulint*,ulint*)" -> "dict_index_is_univ(const dict_index_t*)"
"cmp_rec_rec_with_match(const rec_t*,const rec_t*,const ulint*,const ulint*,dict_index_t*,ulint,ulint*,ulint*)" -> "rec_offs_nth_extern(const ulint*,ulint)"
"cmp_rec_rec_with_match(const rec_t*,const rec_t*,const ulint*,const ulint*,dict_index_t*,ulint,ulint*,ulint*)" -> "cmp_collate(ulint)"
"cmp_rec_rec_with_match(const rec_t*,const rec_t*,const ulint*,const ulint*,dict_index_t*,ulint,ulint*,ulint*)" -> "rec_get_nth_field_offs(const ulint*,ulint,ulint*)"
"cmp_rec_rec_with_match(const rec_t*,const rec_t*,const ulint*,const ulint*,dict_index_t*,ulint,ulint*,ulint*)" -> "dtype_get_charset_coll(ulint)"
"cmp_rec_rec_with_match(const rec_t*,const rec_t*,const ulint*,const ulint*,dict_index_t*,ulint,ulint*,ulint*)" -> "dtype_get_pad_char(ulint,ulint)"
"cmp_rec_rec_with_match(const rec_t*,const rec_t*,const ulint*,const ulint*,dict_index_t*,ulint,ulint*,ulint*)" -> "rec_get_info_bits(const rec_t*,ulint)"
"btr_rec_get_externally_stored_len(const rec_t*,const ulint*)" -> "rec_offs_nth_extern(const ulint*,ulint)"
"btr_rec_get_externally_stored_len(const rec_t*,const ulint*)" -> "btr_rec_get_field_ref_offs(const ulint*,ulint)"
"btr_rec_get_externally_stored_len(const rec_t*,const ulint*)" -> "rec_offs_n_fields(const ulint*)"
"btr_rec_get_externally_stored_len(const rec_t*,const ulint*)" -> "rec_offs_any_extern(const ulint*)"
"btr_rec_get_externally_stored_len(const rec_t*,const ulint*)" -> "mach_read_from_4(const unsigned char*)"
"btr_record_not_null_field_in_rec(ulint,const ulint*,ib_uint64_t*)" -> "rec_offs_nth_sql_null(const ulint*,ulint)"
"btr_get_size(dict_index_t*,ulint,mtr_t*)" -> "dict_index_is_online_ddl(const dict_index_t*)"
"btr_get_size(dict_index_t*,ulint,mtr_t*)" -> "abort()"
"btr_get_size(dict_index_t*,ulint,mtr_t*)" -> "ut_dbg_assertion_failed(const char*,const char*,ulint)"
"btr_get_size(dict_index_t*,ulint,mtr_t*)" -> "btr_root_get(const dict_index_t*,mtr_t*)"
"btr_get_size(dict_index_t*,ulint,mtr_t*)" -> "fseg_n_reserved_pages(fseg_header_t*,ulint*,mtr_t*)"
"fseg_n_reserved_pages(fseg_header_t*,ulint*,mtr_t*)" -> "mtr_x_lock_func(rw_lock_t*,const char*,ulint,mtr_t*)"
"fseg_n_reserved_pages(fseg_header_t*,ulint*,mtr_t*)" -> "fsp_flags_get_zip_size(ulint)"
"fseg_n_reserved_pages(fseg_header_t*,ulint*,mtr_t*)" -> "fseg_inode_get(fseg_header_t*,ulint,ulint,mtr_t*)"
"fseg_n_reserved_pages(fseg_header_t*,ulint*,mtr_t*)" -> "fseg_n_reserved_pages_low(fseg_inode_t*,ulint*,mtr_t*)"
"fseg_n_reserved_pages(fseg_header_t*,ulint*,mtr_t*)" -> "page_get_space_id(const ib_page_t*)"
"fseg_n_reserved_pages(fseg_header_t*,ulint*,mtr_t*)" -> "fil_space_get_latch(ulint,ulint*)"
"fseg_n_reserved_pages(fseg_header_t*,ulint*,mtr_t*)" -> "page_align(const void*)"
"dict_stats_persistent_storage_check(bool)" -> "pfs_mutex_exit_func(ib_mutex_t*)"
"dict_stats_persistent_storage_check(bool)" -> "fprintf(FILE*,const char*,...)"
"dict_stats_persistent_storage_check(bool)" -> "dict_table_schema_check(dict_table_schema_t*,char*,size_t)"
"dict_stats_persistent_storage_check(bool)" -> "pfs_mutex_enter_func(ib_mutex_t*,const char*,ulint)"
"dict_stats_persistent_storage_check(bool)" -> "ut_print_timestamp(FILE*)"
"dict_table_schema_check(dict_table_schema_t*,char*,size_t)" -> "dtype_sql_name(unsigned int,unsigned int,unsigned int,char*,unsigned int)"
"dict_table_schema_check(dict_table_schema_t*,char*,size_t)" -> "_Alloc>::size() const [with _Key = dict_foreign_t*,_Compare = dict_foreign_compare,_Alloc = std::allocator<dict_foreign_t*>,std::set<_Key,_Compare,_Alloc>::size_type = long unsigned int]"
"dict_table_schema_check(dict_table_schema_t*,char*,size_t)" -> "dict_table_get_col_name(const dict_table_t*,ulint)"
"dict_table_schema_check(dict_table_schema_t*,char*,size_t)" -> "innobase_strcasecmp(const char*,const char*)"
"dict_table_schema_check(dict_table_schema_t*,char*,size_t)" -> "snprintf(char*,size_t,const char*,...)"
"dict_table_schema_check(dict_table_schema_t*,char*,size_t)" -> "dict_table_get_low(const char*)"
"dict_table_schema_check(dict_table_schema_t*,char*,size_t)" -> "ut_format_name(const char*,ulint,char*,ulint)"
"dtype_sql_name(unsigned int,unsigned int,unsigned int,char*,unsigned int)" -> "strlen(const char*)"
"dtype_sql_name(unsigned int,unsigned int,unsigned int,char*,unsigned int)" -> "snprintf(char*,size_t,const char*,...)"
"_Alloc>::size() const [with _Key = dict_foreign_t*,_Compare = dict_foreign_compare,_Alloc = std::allocator<dict_foreign_t*>,std::set<_Key,_Compare,_Alloc>::size_type = long unsigned int]" -> "_Alloc>::size() const [with _Key = dict_foreign_t*,_Val = dict_foreign_t*,_KeyOfValue = std::_Identity<dict_foreign_t*>,_Compare = dict_foreign_compare,_Alloc = std::allocator<dict_foreign_t*>,std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::size_type = long unsigned int]"
"dict_stats_table_clone_create(const dict_table_t*)" -> "mem_heap_alloc(mem_heap_t*,ulint)"
"dict_stats_table_clone_create(const dict_table_t*)" -> "dict_stats_should_ignore_index(const dict_index_t*)"
"dict_stats_table_clone_create(const dict_table_t*)" -> "mem_heap_strdup(mem_heap_t*,const char*)"
"dict_stats_table_clone_create(const dict_table_t*)" -> "ut_list_append(List&,Type&,size_t) [with List = ut_list_base<dict_index_t>,Type = dict_index_t,size_t = long unsigned int]"
"dict_stats_table_clone_create(const dict_table_t*)" -> "dict_index_get_n_unique(const dict_index_t*)"
"dict_stats_table_clone_create(const dict_table_t*)" -> "dict_table_stats_latch_create(dict_table_t*,bool)"
"dict_stats_table_clone_create(const dict_table_t*)" -> "mem_heap_create_func(ulint,ulint)"
"dict_stats_table_clone_create(const dict_table_t*)" -> "strlen(const char*)"
"ut_list_append(List&,Type&,size_t) [with List = ut_list_base<dict_index_t>,Type = dict_index_t,size_t = long unsigned int]" -> "ut_elem_get_node(Type&,size_t) [with Type = dict_index_t,size_t = long unsigned int]"
"ut_elem_get_node(Type&,size_t) [with Type = dict_index_t,size_t = long unsigned int]" -> "__builtin_expect(long int,long int)"
"ut_elem_get_node(Type&,size_t) [with Type = dict_index_t,size_t = long unsigned int]" -> "abort()"
"ut_elem_get_node(Type&,size_t) [with Type = dict_index_t,size_t = long unsigned int]" -> "ut_dbg_assertion_failed(const char*,const char*,ulint)"
"dict_stats_update_persistent(dict_table_t*)" -> "dict_index_is_corrupted(const dict_index_t*)"
"dict_stats_update_persistent(dict_table_t*)" -> "dict_stats_assert_initialized(const dict_table_t*)"
"dict_stats_update_persistent(dict_table_t*)" -> "ut_time()"
"dict_stats_update_persistent(dict_table_t*)" -> "dict_table_stats_unlock(dict_table_t*,ulint)"
"dict_stats_update_persistent(dict_table_t*)" -> "dict_stats_should_ignore_index(const dict_index_t*)"
"dict_stats_update_persistent(dict_table_t*)" -> "dict_index_get_n_unique(const dict_index_t*)"
"dict_stats_update_persistent(dict_table_t*)" -> "dict_stats_analyze_index(dict_index_t*)"
"dict_stats_update_persistent(dict_table_t*)" -> "dict_stats_empty_table(dict_table_t*)"
"dict_stats_update_persistent(dict_table_t*)" -> "dict_table_stats_lock(dict_table_t*,ulint)"
"dict_stats_update_persistent(dict_table_t*)" -> "dict_stats_empty_index(dict_index_t*)"
"dict_stats_assert_initialized(const dict_table_t*)" -> "abort()"
"dict_stats_assert_initialized(const dict_table_t*)" -> "__builtin_expect(long int,long int)"
"dict_stats_assert_initialized(const dict_table_t*)" -> "ut_dbg_assertion_failed(const char*,const char*,ulint)"
"dict_stats_assert_initialized(const dict_table_t*)" -> "dict_stats_should_ignore_index(const dict_index_t*)"
"dict_stats_assert_initialized(const dict_table_t*)" -> "dict_stats_assert_initialized_index(const dict_index_t*)"
"dict_stats_analyze_index(dict_index_t*)" -> "mtr_commit(mtr_t*)"
"dict_stats_analyze_index(dict_index_t*)" -> "mtr_s_lock_func(rw_lock_t*,const char*,ulint,mtr_t*)"
"dict_stats_analyze_index(dict_index_t*)" -> "mtr_start(mtr_t*)"
"dict_stats_analyze_index(dict_index_t*)" -> "dict_index_get_n_unique(const dict_index_t*)"
"dict_stats_analyze_index(dict_index_t*)" -> "dict_stats_analyze_index_level(dict_index_t*,ulint,ib_uint64_t*,ib_uint64_t*,ib_uint64_t*,boundaries_t*,mtr_t*)"
"dict_stats_analyze_index(dict_index_t*)" -> "dict_stats_assert_initialized_index(const dict_index_t*)"
"dict_stats_analyze_index(dict_index_t*)" -> "abort()"
"dict_stats_analyze_index(dict_index_t*)" -> "ut_dbg_assertion_failed(const char*,const char*,ulint)"
"dict_stats_analyze_index(dict_index_t*)" -> "_Alloc>::vector() [with _Tp = long unsigned int,_Alloc = std::allocator<long unsigned int>]"
"dict_stats_analyze_index(dict_index_t*)" -> "std::min(const _Tp&,const _Tp&) [with _Tp = long unsigned int]"
"dict_stats_analyze_index(dict_index_t*)" -> "dict_stats_empty_index(dict_index_t*)"
"dict_stats_analyze_index(dict_index_t*)" -> "btr_get_size(dict_index_t*,ulint,mtr_t*)"
"dict_stats_analyze_index(dict_index_t*)" -> "btr_height_get(dict_index_t*,mtr_t*)"
"dict_stats_analyze_index(dict_index_t*)" -> "dict_index_get_lock(dict_index_t*)"
"dict_stats_analyze_index(dict_index_t*)" -> "dict_stats_analyze_index_for_n_prefix(dict_index_t*,ulint,const boundaries_t*,n_diff_data_t*,mtr_t*)"
"dict_stats_analyze_index(dict_index_t*)" -> "dict_stats_index_set_n_diff(const n_diff_data_t*,dict_index_t*)"
"dict_stats_analyze_index(dict_index_t*)" -> "__builtin_expect(long int,long int)"
"dict_stats_analyze_index_level(dict_index_t*,ulint,ib_uint64_t*,ib_uint64_t*,ib_uint64_t*,boundaries_t*,mtr_t*)" -> "_Alloc>::erase(std::vector<_Tp,_Alloc>::iterator,std::vector<_Tp,_Alloc>::iterator) [with _Tp = long unsigned int,_Alloc = std::allocator<long unsigned int>,std::vector<_Tp,_Alloc>::iterator = __gnu_cxx::__normal_iterator<long unsigned int*,std::vector<long unsigned int> >,typename std::_Vector_base<_Tp,_Alloc>::_Tp_alloc_type::pointer = long unsigned int*]"
"dict_stats_analyze_index_level(dict_index_t*,ulint,ib_uint64_t*,ib_uint64_t*,ib_uint64_t*,boundaries_t*,mtr_t*)" -> "btr_pcur_open_at_index_side(bool,dict_index_t*,ulint,btr_pcur_t*,bool,ulint,mtr_t*)"
"dict_stats_analyze_index_level(dict_index_t*,ulint,ib_uint64_t*,ib_uint64_t*,ib_uint64_t*,boundaries_t*,mtr_t*)" -> "btr_leaf_page_release(buf_block_t*,ulint,mtr_t*)"
"dict_stats_analyze_index_level(dict_index_t*,ulint,ib_uint64_t*,ib_uint64_t*,ib_uint64_t*,boundaries_t*,mtr_t*)" -> "btr_pcur_close(btr_pcur_t*)"
"dict_stats_analyze_index_level(dict_index_t*,ulint,ib_uint64_t*,ib_uint64_t*,ib_uint64_t*,boundaries_t*,mtr_t*)" -> "page_rec_is_supremum(const rec_t*)"
"dict_stats_analyze_index_level(dict_index_t*,ulint,ib_uint64_t*,ib_uint64_t*,ib_uint64_t*,boundaries_t*,mtr_t*)" -> "_Alloc>::end() [with _Tp = long unsigned int,_Alloc = std::allocator<long unsigned int>,std::vector<_Tp,_Alloc>::iterator = __gnu_cxx::__normal_iterator<long unsigned int*,std::vector<long unsigned int> >,typename std::_Vector_base<_Tp,_Alloc>::_Tp_alloc_type::pointer = long unsigned int*]"
"dict_stats_analyze_index_level(dict_index_t*,ulint,ib_uint64_t*,ib_uint64_t*,ib_uint64_t*,boundaries_t*,mtr_t*)" -> "page_is_comp(const ib_page_t*)"
"dict_stats_analyze_index_level(dict_index_t*,ulint,ib_uint64_t*,ib_uint64_t*,ib_uint64_t*,boundaries_t*,mtr_t*)" -> "mem_heap_free_func(mem_heap_t*,const char*,ulint)"
"dict_stats_analyze_index_level(dict_index_t*,ulint,ib_uint64_t*,ib_uint64_t*,ib_uint64_t*,boundaries_t*,mtr_t*)" -> "btr_page_get_level_low(const ib_page_t*)"
"dict_stats_analyze_index_level(dict_index_t*,ulint,ib_uint64_t*,ib_uint64_t*,ib_uint64_t*,boundaries_t*,mtr_t*)" -> "rec_get_info_bits(const rec_t*,ulint)"
"dict_stats_analyze_index_level(dict_index_t*,ulint,ib_uint64_t*,ib_uint64_t*,ib_uint64_t*,boundaries_t*,mtr_t*)" -> "__builtin_expect(long int,long int)"
"dict_stats_analyze_index_level(dict_index_t*,ulint,ib_uint64_t*,ib_uint64_t*,ib_uint64_t*,boundaries_t*,mtr_t*)" -> "_Alloc>::begin() [with _Tp = long unsigned int,_Alloc = std::allocator<long unsigned int>,std::vector<_Tp,_Alloc>::iterator = __gnu_cxx::__normal_iterator<long unsigned int*,std::vector<long unsigned int> >,typename std::_Vector_base<_Tp,_Alloc>::_Tp_alloc_type::pointer = long unsigned int*]"
"dict_stats_analyze_index_level(dict_index_t*,ulint,ib_uint64_t*,ib_uint64_t*,ib_uint64_t*,boundaries_t*,mtr_t*)" -> "btr_pcur_is_on_user_rec(const btr_pcur_t*)"
"dict_stats_analyze_index_level(dict_index_t*,ulint,ib_uint64_t*,ib_uint64_t*,ib_uint64_t*,boundaries_t*,mtr_t*)" -> "memset(void*,int,size_t)"
"dict_stats_analyze_index_level(dict_index_t*,ulint,ib_uint64_t*,ib_uint64_t*,ib_uint64_t*,boundaries_t*,mtr_t*)" -> "_Alloc>::push_back(const value_type&) [with _Tp = long unsigned int,_Alloc = std::allocator<long unsigned int>,std::vector<_Tp,_Alloc>::value_type = long unsigned int]"
"dict_stats_analyze_index_level(dict_index_t*,ulint,ib_uint64_t*,ib_uint64_t*,ib_uint64_t*,boundaries_t*,mtr_t*)" -> "rec_get_deleted_flag(const rec_t*,ulint)"
"dict_stats_analyze_index_level(dict_index_t*,ulint,ib_uint64_t*,ib_uint64_t*,ib_uint64_t*,boundaries_t*,mtr_t*)" -> "page_rec_get_next_const(const rec_t*)"
"dict_stats_analyze_index_level(dict_index_t*,ulint,ib_uint64_t*,ib_uint64_t*,ib_uint64_t*,boundaries_t*,mtr_t*)" -> "rec_offs_n_fields(const ulint*)"
"dict_stats_analyze_index_level(dict_index_t*,ulint,ib_uint64_t*,ib_uint64_t*,ib_uint64_t*,boundaries_t*,mtr_t*)" -> "cmp_rec_rec_with_match(const rec_t*,const rec_t*,const ulint*,const ulint*,dict_index_t*,ulint,ulint*,ulint*)"
"dict_stats_analyze_index_level(dict_index_t*,ulint,ib_uint64_t*,ib_uint64_t*,ib_uint64_t*,boundaries_t*,mtr_t*)" -> "mem_heap_alloc(mem_heap_t*,ulint)"
"dict_stats_analyze_index_level(dict_index_t*,ulint,ib_uint64_t*,ib_uint64_t*,ib_uint64_t*,boundaries_t*,mtr_t*)" -> "rec_offs_set_n_alloc(ulint*,ulint)"
"dict_stats_analyze_index_level(dict_index_t*,ulint,ib_uint64_t*,ib_uint64_t*,ib_uint64_t*,boundaries_t*,mtr_t*)" -> "abort()"
"dict_stats_analyze_index_level(dict_index_t*,ulint,ib_uint64_t*,ib_uint64_t*,ib_uint64_t*,boundaries_t*,mtr_t*)" -> "dict_index_get_n_unique(const dict_index_t*)"
"dict_stats_analyze_index_level(dict_index_t*,ulint,ib_uint64_t*,ib_uint64_t*,ib_uint64_t*,boundaries_t*,mtr_t*)" -> "btr_page_get_prev(const ib_page_t*,mtr_t*)"
"dict_stats_analyze_index_level(dict_index_t*,ulint,ib_uint64_t*,ib_uint64_t*,ib_uint64_t*,boundaries_t*,mtr_t*)" -> "mem_heap_create_func(ulint,ulint)"
"dict_stats_analyze_index_level(dict_index_t*,ulint,ib_uint64_t*,ib_uint64_t*,ib_uint64_t*,boundaries_t*,mtr_t*)" -> "ut_dbg_assertion_failed(const char*,const char*,ulint)"
"dict_stats_analyze_index_level(dict_index_t*,ulint,ib_uint64_t*,ib_uint64_t*,ib_uint64_t*,boundaries_t*,mtr_t*)" -> "btr_pcur_move_to_next_user_rec(btr_pcur_t*,mtr_t*)"
"dict_stats_analyze_index_level(dict_index_t*,ulint,ib_uint64_t*,ib_uint64_t*,ib_uint64_t*,boundaries_t*,mtr_t*)" -> "mem_free_func(void*,const char*,ulint)"
"dict_stats_analyze_index_level(dict_index_t*,ulint,ib_uint64_t*,ib_uint64_t*,ib_uint64_t*,boundaries_t*,mtr_t*)" -> "page_align(const void*)"
"dict_stats_analyze_index_level(dict_index_t*,ulint,ib_uint64_t*,ib_uint64_t*,ib_uint64_t*,boundaries_t*,mtr_t*)" -> "rec_get_offsets_func(const rec_t*,const dict_index_t*,ulint*,ulint,mem_heap_t**)"
"dict_stats_analyze_index_level(dict_index_t*,ulint,ib_uint64_t*,ib_uint64_t*,ib_uint64_t*,boundaries_t*,mtr_t*)" -> "btr_pcur_move_to_next_on_page(btr_pcur_t*)"
"dict_stats_analyze_index_level(dict_index_t*,ulint,ib_uint64_t*,ib_uint64_t*,ib_uint64_t*,boundaries_t*,mtr_t*)" -> "rec_copy_prefix_to_buf(const rec_t*,const dict_index_t*,ulint,unsigned char**,ulint*)"
"_Alloc>::erase(std::vector<_Tp,_Alloc>::iterator,std::vector<_Tp,_Alloc>::iterator) [with _Tp = long unsigned int,_Alloc = std::allocator<long unsigned int>,std::vector<_Tp,_Alloc>::iterator = __gnu_cxx::__normal_iterator<long unsigned int*,std::vector<long unsigned int> >,typename std::_Vector_base<_Tp,_Alloc>::_Tp_alloc_type::pointer = long unsigned int*]" -> "_Container>::base() const [with _Iterator = long unsigned int*,_Container = std::vector<long unsigned int>]"
"_Alloc>::erase(std::vector<_Tp,_Alloc>::iterator,std::vector<_Tp,_Alloc>::iterator) [with _Tp = long unsigned int,_Alloc = std::allocator<long unsigned int>,std::vector<_Tp,_Alloc>::iterator = __gnu_cxx::__normal_iterator<long unsigned int*,std::vector<long unsigned int> >,typename std::_Vector_base<_Tp,_Alloc>::_Tp_alloc_type::pointer = long unsigned int*]" -> "_Alloc>::_M_erase_at_end(std::vector<_Tp,_Alloc>::pointer) [with _Tp = long unsigned int,_Alloc = std::allocator<long unsigned int>,std::vector<_Tp,_Alloc>::pointer = long unsigned int*]"
"_Alloc>::erase(std::vector<_Tp,_Alloc>::iterator,std::vector<_Tp,_Alloc>::iterator) [with _Tp = long unsigned int,_Alloc = std::allocator<long unsigned int>,std::vector<_Tp,_Alloc>::iterator = __gnu_cxx::__normal_iterator<long unsigned int*,std::vector<long unsigned int> >,typename std::_Vector_base<_Tp,_Alloc>::_Tp_alloc_type::pointer = long unsigned int*]" -> "__gnu_cxx::operator!=(const __gnu_cxx::__normal_iterator<_Iterator,_Container>&,const __gnu_cxx::__normal_iterator<_Iterator,_Container>&) [with _Iterator = long unsigned int*,_Container = std::vector<long unsigned int>]"
"_Alloc>::erase(std::vector<_Tp,_Alloc>::iterator,std::vector<_Tp,_Alloc>::iterator) [with _Tp = long unsigned int,_Alloc = std::allocator<long unsigned int>,std::vector<_Tp,_Alloc>::iterator = __gnu_cxx::__normal_iterator<long unsigned int*,std::vector<long unsigned int> >,typename std::_Vector_base<_Tp,_Alloc>::_Tp_alloc_type::pointer = long unsigned int*]" -> "_Alloc>::end() [with _Tp = long unsigned int,_Alloc = std::allocator<long unsigned int>,std::vector<_Tp,_Alloc>::iterator = __gnu_cxx::__normal_iterator<long unsigned int*,std::vector<long unsigned int> >,typename std::_Vector_base<_Tp,_Alloc>::_Tp_alloc_type::pointer = long unsigned int*]"
"_Alloc>::erase(std::vector<_Tp,_Alloc>::iterator,std::vector<_Tp,_Alloc>::iterator) [with _Tp = long unsigned int,_Alloc = std::allocator<long unsigned int>,std::vector<_Tp,_Alloc>::iterator = __gnu_cxx::__normal_iterator<long unsigned int*,std::vector<long unsigned int> >,typename std::_Vector_base<_Tp,_Alloc>::_Tp_alloc_type::pointer = long unsigned int*]" -> "std::copy(_II,_II,_OI) [with _II = __gnu_cxx::__normal_iterator<long unsigned int*,std::vector<long unsigned int> >,_OI = __gnu_cxx::__normal_iterator<long unsigned int*,std::vector<long unsigned int> >]"
"_Alloc>::erase(std::vector<_Tp,_Alloc>::iterator,std::vector<_Tp,_Alloc>::iterator) [with _Tp = long unsigned int,_Alloc = std::allocator<long unsigned int>,std::vector<_Tp,_Alloc>::iterator = __gnu_cxx::__normal_iterator<long unsigned int*,std::vector<long unsigned int> >,typename std::_Vector_base<_Tp,_Alloc>::_Tp_alloc_type::pointer = long unsigned int*]" -> "__gnu_cxx::operator-(const __gnu_cxx::__normal_iterator<_Iterator,_Container>&,const __gnu_cxx::__normal_iterator<_Iterator,_Container>&) [with _Iterator = long unsigned int*,_Container = std::vector<long unsigned int>,typename __gnu_cxx::__normal_iterator<_Iterator,_Container>::difference_type = long int]"
"_Alloc>::_M_erase_at_end(std::vector<_Tp,_Alloc>::pointer) [with _Tp = long unsigned int,_Alloc = std::allocator<long unsigned int>,std::vector<_Tp,_Alloc>::pointer = long unsigned int*]" -> "std::_Destroy(_ForwardIterator,_ForwardIterator,std::allocator<_T2>&) [with _ForwardIterator = long unsigned int*,_Tp = long unsigned int]"
"_Alloc>::_M_erase_at_end(std::vector<_Tp,_Alloc>::pointer) [with _Tp = long unsigned int,_Alloc = std::allocator<long unsigned int>,std::vector<_Tp,_Alloc>::pointer = long unsigned int*]" -> "_Alloc>::_M_get_Tp_allocator() [with _Tp = long unsigned int,_Alloc = std::allocator<long unsigned int>,std::_Vector_base<_Tp,_Alloc>::_Tp_alloc_type = std::allocator<long unsigned int>]"
"std::_Destroy(_ForwardIterator,_ForwardIterator,std::allocator<_T2>&) [with _ForwardIterator = long unsigned int*,_Tp = long unsigned int]" -> "std::_Destroy(_ForwardIterator,_ForwardIterator) [with _ForwardIterator = long unsigned int*]"
"std::_Destroy(_ForwardIterator,_ForwardIterator) [with _ForwardIterator = long unsigned int*]" -> "std::_Destroy_aux<true>::__destroy(_ForwardIterator,_ForwardIterator) [with _ForwardIterator = long unsigned int*]"
"__gnu_cxx::operator!=(const __gnu_cxx::__normal_iterator<_Iterator,_Container>&,const __gnu_cxx::__normal_iterator<_Iterator,_Container>&) [with _Iterator = long unsigned int*,_Container = std::vector<long unsigned int>]" -> "_Container>::base() const [with _Iterator = long unsigned int*,_Container = std::vector<long unsigned int>]"
"_Alloc>::end() [with _Tp = long unsigned int,_Alloc = std::allocator<long unsigned int>,std::vector<_Tp,_Alloc>::iterator = __gnu_cxx::__normal_iterator<long unsigned int*,std::vector<long unsigned int> >,typename std::_Vector_base<_Tp,_Alloc>::_Tp_alloc_type::pointer = long unsigned int*]" -> "_Container>::__normal_iterator(const _Iterator&) [with _Iterator = long unsigned int*,_Container = std::vector<long unsigned int>]"
"std::copy(_II,_II,_OI) [with _II = __gnu_cxx::__normal_iterator<long unsigned int*,std::vector<long unsigned int> >,_OI = __gnu_cxx::__normal_iterator<long unsigned int*,std::vector<long unsigned int> >]" -> "std::__miter_base(_Iterator) [with _Iterator = __gnu_cxx::__normal_iterator<long unsigned int*,std::vector<long unsigned int> >,typename std::_Miter_base<_Iterator>::iterator_type = __gnu_cxx::__normal_iterator<long unsigned int*,std::vector<long unsigned int> >]"
"std::copy(_II,_II,_OI) [with _II = __gnu_cxx::__normal_iterator<long unsigned int*,std::vector<long unsigned int> >,_OI = __gnu_cxx::__normal_iterator<long unsigned int*,std::vector<long unsigned int> >]" -> "std::__copy_move_a2(_II,_II,_OI) [with bool _IsMove = false,_II = __gnu_cxx::__normal_iterator<long unsigned int*,std::vector<long unsigned int> >,_OI = __gnu_cxx::__normal_iterator<long unsigned int*,std::vector<long unsigned int> >]"
"std::__miter_base(_Iterator) [with _Iterator = __gnu_cxx::__normal_iterator<long unsigned int*,std::vector<long unsigned int> >,typename std::_Miter_base<_Iterator>::iterator_type = __gnu_cxx::__normal_iterator<long unsigned int*,std::vector<long unsigned int> >]" -> "_HasBase>::_S_base(_Iterator) [with _Iterator = __gnu_cxx::__normal_iterator<long unsigned int*,std::vector<long unsigned int> >,bool _HasBase = false,std::_Iter_base<_Iterator,_HasBase>::iterator_type = __gnu_cxx::__normal_iterator<long unsigned int*,std::vector<long unsigned int> >]"
"std::__copy_move_a2(_II,_II,_OI) [with bool _IsMove = false,_II = __gnu_cxx::__normal_iterator<long unsigned int*,std::vector<long unsigned int> >,_OI = __gnu_cxx::__normal_iterator<long unsigned int*,std::vector<long unsigned int> >]" -> "std::__copy_move_a(_II,_II,_OI) [with bool _IsMove = false,_II = long unsigned int*,_OI = long unsigned int*]"
"std::__copy_move_a2(_II,_II,_OI) [with bool _IsMove = false,_II = __gnu_cxx::__normal_iterator<long unsigned int*,std::vector<long unsigned int> >,_OI = __gnu_cxx::__normal_iterator<long unsigned int*,std::vector<long unsigned int> >]" -> "std::__niter_base(_Iterator) [with _Iterator = __gnu_cxx::__normal_iterator<long unsigned int*,std::vector<long unsigned int> >,typename std::_Niter_base<_Iterator>::iterator_type = long unsigned int*]"
"std::__copy_move_a2(_II,_II,_OI) [with bool _IsMove = false,_II = __gnu_cxx::__normal_iterator<long unsigned int*,std::vector<long unsigned int> >,_OI = __gnu_cxx::__normal_iterator<long unsigned int*,std::vector<long unsigned int> >]" -> "_Container>::__normal_iterator(const _Iterator&) [with _Iterator = long unsigned int*,_Container = std::vector<long unsigned int>]"
"std::__copy_move_a(_II,_II,_OI) [with bool _IsMove = false,_II = long unsigned int*,_OI = long unsigned int*]" -> "std::random_access_iterator_tag>::__copy_m(const _Tp*,const _Tp*,_Tp*) [with _Tp = long unsigned int,bool _IsMove = false]"
"std::random_access_iterator_tag>::__copy_m(const _Tp*,const _Tp*,_Tp*) [with _Tp = long unsigned int,bool _IsMove = false]" -> "__builtin_memmove(void*,const void*,long unsigned int)"
"std::__niter_base(_Iterator) [with _Iterator = __gnu_cxx::__normal_iterator<long unsigned int*,std::vector<long unsigned int> >,typename std::_Niter_base<_Iterator>::iterator_type = long unsigned int*]" -> "true>::_S_base(_Iterator) [with _Iterator = __gnu_cxx::__normal_iterator<long unsigned int*,std::vector<long unsigned int> >,std::_Iter_base<_Iterator,true>::iterator_type = long unsigned int*]"
"true>::_S_base(_Iterator) [with _Iterator = __gnu_cxx::__normal_iterator<long unsigned int*,std::vector<long unsigned int> >,std::_Iter_base<_Iterator,true>::iterator_type = long unsigned int*]" -> "_Container>::base() const [with _Iterator = long unsigned int*,_Container = std::vector<long unsigned int>]"
"__gnu_cxx::operator-(const __gnu_cxx::__normal_iterator<_Iterator,_Container>&,const __gnu_cxx::__normal_iterator<_Iterator,_Container>&) [with _Iterator = long unsigned int*,_Container = std::vector<long unsigned int>,typename __gnu_cxx::__normal_iterator<_Iterator,_Container>::difference_type = long int]" -> "_Container>::base() const [with _Iterator = long unsigned int*,_Container = std::vector<long unsigned int>]"
"btr_pcur_open_at_index_side(bool,dict_index_t*,ulint,btr_pcur_t*,bool,ulint,mtr_t*)" -> "btr_pcur_init(btr_pcur_t*)"
"btr_pcur_open_at_index_side(bool,dict_index_t*,ulint,btr_pcur_t*,bool,ulint,mtr_t*)" -> "btr_cur_open_at_index_side_func(bool,dict_index_t*,ulint,btr_cur_t*,ulint,const char*,ulint,mtr_t*)"
"_Alloc>::begin() [with _Tp = long unsigned int,_Alloc = std::allocator<long unsigned int>,std::vector<_Tp,_Alloc>::iterator = __gnu_cxx::__normal_iterator<long unsigned int*,std::vector<long unsigned int> >,typename std::_Vector_base<_Tp,_Alloc>::_Tp_alloc_type::pointer = long unsigned int*]" -> "_Container>::__normal_iterator(const _Iterator&) [with _Iterator = long unsigned int*,_Container = std::vector<long unsigned int>]"
"_Alloc>::push_back(const value_type&) [with _Tp = long unsigned int,_Alloc = std::allocator<long unsigned int>,std::vector<_Tp,_Alloc>::value_type = long unsigned int]" -> "_Alloc>::_M_insert_aux(std::vector<_Tp,_Alloc>::iterator,const _Tp&) [with _Tp = long unsigned int,_Alloc = std::allocator<long unsigned int>,std::vector<_Tp,_Alloc>::iterator = __gnu_cxx::__normal_iterator<long unsigned int*,std::vector<long unsigned int> >,typename std::_Vector_base<_Tp,_Alloc>::_Tp_alloc_type::pointer = long unsigned int*]"
"_Alloc>::push_back(const value_type&) [with _Tp = long unsigned int,_Alloc = std::allocator<long unsigned int>,std::vector<_Tp,_Alloc>::value_type = long unsigned int]" -> "_Alloc>::end() [with _Tp = long unsigned int,_Alloc = std::allocator<long unsigned int>,std::vector<_Tp,_Alloc>::iterator = __gnu_cxx::__normal_iterator<long unsigned int*,std::vector<long unsigned int> >,typename std::_Vector_base<_Tp,_Alloc>::_Tp_alloc_type::pointer = long unsigned int*]"
"_Alloc>::push_back(const value_type&) [with _Tp = long unsigned int,_Alloc = std::allocator<long unsigned int>,std::vector<_Tp,_Alloc>::value_type = long unsigned int]" -> "__gnu_cxx::new_allocator<_Tp>::construct(__gnu_cxx::new_allocator<_Tp>::pointer,const _Tp&) [with _Tp = long unsigned int,__gnu_cxx::new_allocator<_Tp>::pointer = long unsigned int*]"
"_Alloc>::_M_insert_aux(std::vector<_Tp,_Alloc>::iterator,const _Tp&) [with _Tp = long unsigned int,_Alloc = std::allocator<long unsigned int>,std::vector<_Tp,_Alloc>::iterator = __gnu_cxx::__normal_iterator<long unsigned int*,std::vector<long unsigned int> >,typename std::_Vector_base<_Tp,_Alloc>::_Tp_alloc_type::pointer = long unsigned int*]" -> "_Alloc>::_M_allocate(std::size_t) [with _Tp = long unsigned int,_Alloc = std::allocator<long unsigned int>,typename _Alloc::rebind<_Tp>::other::pointer = long unsigned int*,std::size_t = long unsigned int]"
"_Alloc>::_M_insert_aux(std::vector<_Tp,_Alloc>::iterator,const _Tp&) [with _Tp = long unsigned int,_Alloc = std::allocator<long unsigned int>,std::vector<_Tp,_Alloc>::iterator = __gnu_cxx::__normal_iterator<long unsigned int*,std::vector<long unsigned int> >,typename std::_Vector_base<_Tp,_Alloc>::_Tp_alloc_type::pointer = long unsigned int*]" -> "std::_Destroy(_ForwardIterator,_ForwardIterator,std::allocator<_T2>&) [with _ForwardIterator = long unsigned int*,_Tp = long unsigned int]"
"_Alloc>::_M_insert_aux(std::vector<_Tp,_Alloc>::iterator,const _Tp&) [with _Tp = long unsigned int,_Alloc = std::allocator<long unsigned int>,std::vector<_Tp,_Alloc>::iterator = __gnu_cxx::__normal_iterator<long unsigned int*,std::vector<long unsigned int> >,typename std::_Vector_base<_Tp,_Alloc>::_Tp_alloc_type::pointer = long unsigned int*]" -> "_Container>::operator*() const [with _Iterator = long unsigned int*,_Container = std::vector<long unsigned int>,__gnu_cxx::__normal_iterator<_Iterator,_Container>::reference = long unsigned int&]"
"_Alloc>::_M_insert_aux(std::vector<_Tp,_Alloc>::iterator,const _Tp&) [with _Tp = long unsigned int,_Alloc = std::allocator<long unsigned int>,std::vector<_Tp,_Alloc>::iterator = __gnu_cxx::__normal_iterator<long unsigned int*,std::vector<long unsigned int> >,typename std::_Vector_base<_Tp,_Alloc>::_Tp_alloc_type::pointer = long unsigned int*]" -> "std::__uninitialized_move_a(_InputIterator,_InputIterator,_ForwardIterator,_Allocator&) [with _InputIterator = long unsigned int*,_ForwardIterator = long unsigned int*,_Allocator = std::allocator<long unsigned int>]"
"_Alloc>::_M_insert_aux(std::vector<_Tp,_Alloc>::iterator,const _Tp&) [with _Tp = long unsigned int,_Alloc = std::allocator<long unsigned int>,std::vector<_Tp,_Alloc>::iterator = __gnu_cxx::__normal_iterator<long unsigned int*,std::vector<long unsigned int> >,typename std::_Vector_base<_Tp,_Alloc>::_Tp_alloc_type::pointer = long unsigned int*]" -> "__cxa_end_catch()"
"_Alloc>::_M_insert_aux(std::vector<_Tp,_Alloc>::iterator,const _Tp&) [with _Tp = long unsigned int,_Alloc = std::allocator<long unsigned int>,std::vector<_Tp,_Alloc>::iterator = __gnu_cxx::__normal_iterator<long unsigned int*,std::vector<long unsigned int> >,typename std::_Vector_base<_Tp,_Alloc>::_Tp_alloc_type::pointer = long unsigned int*]" -> "_Alloc>::_M_check_len(std::vector<_Tp,_Alloc>::size_type,const char*) const [with _Tp = long unsigned int,_Alloc = std::allocator<long unsigned int>,std::vector<_Tp,_Alloc>::size_type = long unsigned int]"
"_Alloc>::_M_insert_aux(std::vector<_Tp,_Alloc>::iterator,const _Tp&) [with _Tp = long unsigned int,_Alloc = std::allocator<long unsigned int>,std::vector<_Tp,_Alloc>::iterator = __gnu_cxx::__normal_iterator<long unsigned int*,std::vector<long unsigned int> >,typename std::_Vector_base<_Tp,_Alloc>::_Tp_alloc_type::pointer = long unsigned int*]" -> "_Alloc>::_M_deallocate(typename _Alloc::rebind<_Tp>::other::pointer,std::size_t) [with _Tp = long unsigned int,_Alloc = std::allocator<long unsigned int>,typename _Alloc::rebind<_Tp>::other::pointer = long unsigned int*,std::size_t = long unsigned int]"
"_Alloc>::_M_insert_aux(std::vector<_Tp,_Alloc>::iterator,const _Tp&) [with _Tp = long unsigned int,_Alloc = std::allocator<long unsigned int>,std::vector<_Tp,_Alloc>::iterator = __gnu_cxx::__normal_iterator<long unsigned int*,std::vector<long unsigned int> >,typename std::_Vector_base<_Tp,_Alloc>::_Tp_alloc_type::pointer = long unsigned int*]" -> "__cxa_begin_catch(void*)"
"_Alloc>::_M_insert_aux(std::vector<_Tp,_Alloc>::iterator,const _Tp&) [with _Tp = long unsigned int,_Alloc = std::allocator<long unsigned int>,std::vector<_Tp,_Alloc>::iterator = __gnu_cxx::__normal_iterator<long unsigned int*,std::vector<long unsigned int> >,typename std::_Vector_base<_Tp,_Alloc>::_Tp_alloc_type::pointer = long unsigned int*]" -> "_Container>::base() const [with _Iterator = long unsigned int*,_Container = std::vector<long unsigned int>]"
"_Alloc>::_M_insert_aux(std::vector<_Tp,_Alloc>::iterator,const _Tp&) [with _Tp = long unsigned int,_Alloc = std::allocator<long unsigned int>,std::vector<_Tp,_Alloc>::iterator = __gnu_cxx::__normal_iterator<long unsigned int*,std::vector<long unsigned int> >,typename std::_Vector_base<_Tp,_Alloc>::_Tp_alloc_type::pointer = long unsigned int*]" -> "std::copy_backward(_BI1,_BI1,_BI2) [with _BI1 = long unsigned int*,_BI2 = long unsigned int*]"
"_Alloc>::_M_insert_aux(std::vector<_Tp,_Alloc>::iterator,const _Tp&) [with _Tp = long unsigned int,_Alloc = std::allocator<long unsigned int>,std::vector<_Tp,_Alloc>::iterator = __gnu_cxx::__normal_iterator<long unsigned int*,std::vector<long unsigned int> >,typename std::_Vector_base<_Tp,_Alloc>::_Tp_alloc_type::pointer = long unsigned int*]" -> "__gnu_cxx::operator-(const __gnu_cxx::__normal_iterator<_Iterator,_Container>&,const __gnu_cxx::__normal_iterator<_Iterator,_Container>&) [with _Iterator = long unsigned int*,_Container = std::vector<long unsigned int>,typename __gnu_cxx::__normal_iterator<_Iterator,_Container>::difference_type = long int]"
"_Alloc>::_M_insert_aux(std::vector<_Tp,_Alloc>::iterator,const _Tp&) [with _Tp = long unsigned int,_Alloc = std::allocator<long unsigned int>,std::vector<_Tp,_Alloc>::iterator = __gnu_cxx::__normal_iterator<long unsigned int*,std::vector<long unsigned int> >,typename std::_Vector_base<_Tp,_Alloc>::_Tp_alloc_type::pointer = long unsigned int*]" -> "__builtin_eh_pointer(int)"
"_Alloc>::_M_insert_aux(std::vector<_Tp,_Alloc>::iterator,const _Tp&) [with _Tp = long unsigned int,_Alloc = std::allocator<long unsigned int>,std::vector<_Tp,_Alloc>::iterator = __gnu_cxx::__normal_iterator<long unsigned int*,std::vector<long unsigned int> >,typename std::_Vector_base<_Tp,_Alloc>::_Tp_alloc_type::pointer = long unsigned int*]" -> "_Alloc>::_M_get_Tp_allocator() [with _Tp = long unsigned int,_Alloc = std::allocator<long unsigned int>,std::_Vector_base<_Tp,_Alloc>::_Tp_alloc_type = std::allocator<long unsigned int>]"
"_Alloc>::_M_insert_aux(std::vector<_Tp,_Alloc>::iterator,const _Tp&) [with _Tp = long unsigned int,_Alloc = std::allocator<long unsigned int>,std::vector<_Tp,_Alloc>::iterator = __gnu_cxx::__normal_iterator<long unsigned int*,std::vector<long unsigned int> >,typename std::_Vector_base<_Tp,_Alloc>::_Tp_alloc_type::pointer = long unsigned int*]" -> "__cxa_rethrow()"
"_Alloc>::_M_insert_aux(std::vector<_Tp,_Alloc>::iterator,const _Tp&) [with _Tp = long unsigned int,_Alloc = std::allocator<long unsigned int>,std::vector<_Tp,_Alloc>::iterator = __gnu_cxx::__normal_iterator<long unsigned int*,std::vector<long unsigned int> >,typename std::_Vector_base<_Tp,_Alloc>::_Tp_alloc_type::pointer = long unsigned int*]" -> "__gnu_cxx::new_allocator<_Tp>::destroy(__gnu_cxx::new_allocator<_Tp>::pointer) [with _Tp = long unsigned int,__gnu_cxx::new_allocator<_Tp>::pointer = long unsigned int*]"
"_Alloc>::_M_insert_aux(std::vector<_Tp,_Alloc>::iterator,const _Tp&) [with _Tp = long unsigned int,_Alloc = std::allocator<long unsigned int>,std::vector<_Tp,_Alloc>::iterator = __gnu_cxx::__normal_iterator<long unsigned int*,std::vector<long unsigned int> >,typename std::_Vector_base<_Tp,_Alloc>::_Tp_alloc_type::pointer = long unsigned int*]" -> "_Alloc>::begin() [with _Tp = long unsigned int,_Alloc = std::allocator<long unsigned int>,std::vector<_Tp,_Alloc>::iterator = __gnu_cxx::__normal_iterator<long unsigned int*,std::vector<long unsigned int> >,typename std::_Vector_base<_Tp,_Alloc>::_Tp_alloc_type::pointer = long unsigned int*]"
"_Alloc>::_M_insert_aux(std::vector<_Tp,_Alloc>::iterator,const _Tp&) [with _Tp = long unsigned int,_Alloc = std::allocator<long unsigned int>,std::vector<_Tp,_Alloc>::iterator = __gnu_cxx::__normal_iterator<long unsigned int*,std::vector<long unsigned int> >,typename std::_Vector_base<_Tp,_Alloc>::_Tp_alloc_type::pointer = long unsigned int*]" -> "__gnu_cxx::new_allocator<_Tp>::construct(__gnu_cxx::new_allocator<_Tp>::pointer,const _Tp&) [with _Tp = long unsigned int,__gnu_cxx::new_allocator<_Tp>::pointer = long unsigned int*]"
"_Alloc>::_M_allocate(std::size_t) [with _Tp = long unsigned int,_Alloc = std::allocator<long unsigned int>,typename _Alloc::rebind<_Tp>::other::pointer = long unsigned int*,std::size_t = long unsigned int]" -> "__gnu_cxx::new_allocator<_Tp>::allocate(__gnu_cxx::new_allocator<_Tp>::size_type,const void*) [with _Tp = long unsigned int,__gnu_cxx::new_allocator<_Tp>::pointer = long unsigned int*,__gnu_cxx::new_allocator<_Tp>::size_type = long unsigned int]"
"__gnu_cxx::new_allocator<_Tp>::allocate(__gnu_cxx::new_allocator<_Tp>::size_type,const void*) [with _Tp = long unsigned int,__gnu_cxx::new_allocator<_Tp>::pointer = long unsigned int*,__gnu_cxx::new_allocator<_Tp>::size_type = long unsigned int]" -> "std::__throw_bad_alloc()"
"__gnu_cxx::new_allocator<_Tp>::allocate(__gnu_cxx::new_allocator<_Tp>::size_type,const void*) [with _Tp = long unsigned int,__gnu_cxx::new_allocator<_Tp>::pointer = long unsigned int*,__gnu_cxx::new_allocator<_Tp>::size_type = long unsigned int]" -> "__gnu_cxx::new_allocator<_Tp>::max_size() const [with _Tp = long unsigned int,__gnu_cxx::new_allocator<_Tp>::size_type = long unsigned int]"
"std::__uninitialized_move_a(_InputIterator,_InputIterator,_ForwardIterator,_Allocator&) [with _InputIterator = long unsigned int*,_ForwardIterator = long unsigned int*,_Allocator = std::allocator<long unsigned int>]" -> "std::__uninitialized_copy_a(_InputIterator,_InputIterator,_ForwardIterator,std::allocator<_Tp>&) [with _InputIterator = long unsigned int*,_ForwardIterator = long unsigned int*,_Tp = long unsigned int]"
"std::__uninitialized_copy_a(_InputIterator,_InputIterator,_ForwardIterator,std::allocator<_Tp>&) [with _InputIterator = long unsigned int*,_ForwardIterator = long unsigned int*,_Tp = long unsigned int]" -> "std::uninitialized_copy(_InputIterator,_InputIterator,_ForwardIterator) [with _InputIterator = long unsigned int*,_ForwardIterator = long unsigned int*]"
"std::uninitialized_copy(_InputIterator,_InputIterator,_ForwardIterator) [with _InputIterator = long unsigned int*,_ForwardIterator = long unsigned int*]" -> "std::__uninitialized_copy<true>::__uninit_copy(_InputIterator,_InputIterator,_ForwardIterator) [with _InputIterator = long unsigned int*,_ForwardIterator = long unsigned int*]"
"std::__uninitialized_copy<true>::__uninit_copy(_InputIterator,_InputIterator,_ForwardIterator) [with _InputIterator = long unsigned int*,_ForwardIterator = long unsigned int*]" -> "std::copy(_II,_II,_OI) [with _II = long unsigned int*,_OI = long unsigned int*]"
"std::copy(_II,_II,_OI) [with _II = long unsigned int*,_OI = long unsigned int*]" -> "std::__miter_base(_Iterator) [with _Iterator = long unsigned int*,typename std::_Miter_base<_Iterator>::iterator_type = long unsigned int*]"
"std::copy(_II,_II,_OI) [with _II = long unsigned int*,_OI = long unsigned int*]" -> "std::__copy_move_a2(_II,_II,_OI) [with bool _IsMove = false,_II = long unsigned int*,_OI = long unsigned int*]"
"std::__miter_base(_Iterator) [with _Iterator = long unsigned int*,typename std::_Miter_base<_Iterator>::iterator_type = long unsigned int*]" -> "_HasBase>::_S_base(_Iterator) [with _Iterator = long unsigned int*,bool _HasBase = false,std::_Iter_base<_Iterator,_HasBase>::iterator_type = long unsigned int*]"
"std::__copy_move_a2(_II,_II,_OI) [with bool _IsMove = false,_II = long unsigned int*,_OI = long unsigned int*]" -> "std::__copy_move_a(_II,_II,_OI) [with bool _IsMove = false,_II = long unsigned int*,_OI = long unsigned int*]"
"std::__copy_move_a2(_II,_II,_OI) [with bool _IsMove = false,_II = long unsigned int*,_OI = long unsigned int*]" -> "std::__niter_base(_Iterator) [with _Iterator = long unsigned int*,typename std::_Niter_base<_Iterator>::iterator_type = long unsigned int*]"
"std::__niter_base(_Iterator) [with _Iterator = long unsigned int*,typename std::_Niter_base<_Iterator>::iterator_type = long unsigned int*]" -> "_HasBase>::_S_base(_Iterator) [with _Iterator = long unsigned int*,bool _HasBase = false,std::_Iter_base<_Iterator,_HasBase>::iterator_type = long unsigned int*]"
"_Alloc>::_M_check_len(std::vector<_Tp,_Alloc>::size_type,const char*) const [with _Tp = long unsigned int,_Alloc = std::allocator<long unsigned int>,std::vector<_Tp,_Alloc>::size_type = long unsigned int]" -> "_Alloc>::size() const [with _Tp = long unsigned int,_Alloc = std::allocator<long unsigned int>,std::vector<_Tp,_Alloc>::size_type = long unsigned int]"
"_Alloc>::_M_check_len(std::vector<_Tp,_Alloc>::size_type,const char*) const [with _Tp = long unsigned int,_Alloc = std::allocator<long unsigned int>,std::vector<_Tp,_Alloc>::size_type = long unsigned int]" -> "_Alloc>::max_size() const [with _Tp = long unsigned int,_Alloc = std::allocator<long unsigned int>,std::vector<_Tp,_Alloc>::size_type = long unsigned int]"
"_Alloc>::_M_check_len(std::vector<_Tp,_Alloc>::size_type,const char*) const [with _Tp = long unsigned int,_Alloc = std::allocator<long unsigned int>,std::vector<_Tp,_Alloc>::size_type = long unsigned int]" -> "std::__throw_length_error(const char*)"
"_Alloc>::_M_check_len(std::vector<_Tp,_Alloc>::size_type,const char*) const [with _Tp = long unsigned int,_Alloc = std::allocator<long unsigned int>,std::vector<_Tp,_Alloc>::size_type = long unsigned int]" -> "std::max(const _Tp&,const _Tp&) [with _Tp = long unsigned int]"
"_Alloc>::max_size() const [with _Tp = long unsigned int,_Alloc = std::allocator<long unsigned int>,std::vector<_Tp,_Alloc>::size_type = long unsigned int]" -> "__gnu_cxx::new_allocator<_Tp>::max_size() const [with _Tp = long unsigned int,__gnu_cxx::new_allocator<_Tp>::size_type = long unsigned int]"
"_Alloc>::max_size() const [with _Tp = long unsigned int,_Alloc = std::allocator<long unsigned int>,std::vector<_Tp,_Alloc>::size_type = long unsigned int]" -> "_Alloc>::_M_get_Tp_allocator() const [with _Tp = long unsigned int,_Alloc = std::allocator<long unsigned int>,std::_Vector_base<_Tp,_Alloc>::_Tp_alloc_type = std::allocator<long unsigned int>]"
"_Alloc>::_M_deallocate(typename _Alloc::rebind<_Tp>::other::pointer,std::size_t) [with _Tp = long unsigned int,_Alloc = std::allocator<long unsigned int>,typename _Alloc::rebind<_Tp>::other::pointer = long unsigned int*,std::size_t = long unsigned int]" -> "__gnu_cxx::new_allocator<_Tp>::deallocate(__gnu_cxx::new_allocator<_Tp>::pointer,__gnu_cxx::new_allocator<_Tp>::size_type) [with _Tp = long unsigned int,__gnu_cxx::new_allocator<_Tp>::pointer = long unsigned int*,__gnu_cxx::new_allocator<_Tp>::size_type = long unsigned int]"
"std::copy_backward(_BI1,_BI1,_BI2) [with _BI1 = long unsigned int*,_BI2 = long unsigned int*]" -> "std::__miter_base(_Iterator) [with _Iterator = long unsigned int*,typename std::_Miter_base<_Iterator>::iterator_type = long unsigned int*]"
"std::copy_backward(_BI1,_BI1,_BI2) [with _BI1 = long unsigned int*,_BI2 = long unsigned int*]" -> "std::__copy_move_backward_a2(_BI1,_BI1,_BI2) [with bool _IsMove = false,_BI1 = long unsigned int*,_BI2 = long unsigned int*]"
"std::__copy_move_backward_a2(_BI1,_BI1,_BI2) [with bool _IsMove = false,_BI1 = long unsigned int*,_BI2 = long unsigned int*]" -> "std::__niter_base(_Iterator) [with _Iterator = long unsigned int*,typename std::_Niter_base<_Iterator>::iterator_type = long unsigned int*]"
"std::__copy_move_backward_a2(_BI1,_BI1,_BI2) [with bool _IsMove = false,_BI1 = long unsigned int*,_BI2 = long unsigned int*]" -> "std::__copy_move_backward_a(_BI1,_BI1,_BI2) [with bool _IsMove = false,_BI1 = long unsigned int*,_BI2 = long unsigned int*]"
"std::__copy_move_backward_a(_BI1,_BI1,_BI2) [with bool _IsMove = false,_BI1 = long unsigned int*,_BI2 = long unsigned int*]" -> "std::random_access_iterator_tag>::__copy_move_b(const _Tp*,const _Tp*,_Tp*) [with _Tp = long unsigned int,bool _IsMove = false]"
"std::random_access_iterator_tag>::__copy_move_b(const _Tp*,const _Tp*,_Tp*) [with _Tp = long unsigned int,bool _IsMove = false]" -> "__builtin_memmove(void*,const void*,long unsigned int)"
"_Alloc>::vector() [with _Tp = long unsigned int,_Alloc = std::allocator<long unsigned int>]" -> "_Alloc>::_Vector_base() [with _Tp = long unsigned int,_Alloc = std::allocator<long unsigned int>]"
"_Alloc>::_Vector_base() [with _Tp = long unsigned int,_Alloc = std::allocator<long unsigned int>]" -> "_Alloc>::_Vector_impl::_Vector_impl() [with _Tp = long unsigned int,_Alloc = std::allocator<long unsigned int>]"
"_Alloc>::_Vector_impl::_Vector_impl() [with _Tp = long unsigned int,_Alloc = std::allocator<long unsigned int>]" -> "std::allocator<_Tp>::allocator() [with _Tp = long unsigned int]"
"std::allocator<_Tp>::allocator() [with _Tp = long unsigned int]" -> "__gnu_cxx::new_allocator<_Tp>::new_allocator() [with _Tp = long unsigned int]"
"btr_height_get(dict_index_t*,mtr_t*)" -> "btr_page_get_level_low(const ib_page_t*)"
"btr_height_get(dict_index_t*,mtr_t*)" -> "mtr_memo_release(mtr_t*,void*,ulint)"
"btr_height_get(dict_index_t*,mtr_t*)" -> "btr_root_block_get(const dict_index_t*,ulint,mtr_t*)"
"dict_stats_analyze_index_for_n_prefix(dict_index_t*,ulint,const boundaries_t*,n_diff_data_t*,mtr_t*)" -> "btr_page_get_level_low(const ib_page_t*)"
"dict_stats_analyze_index_for_n_prefix(dict_index_t*,ulint,const boundaries_t*,n_diff_data_t*,mtr_t*)" -> "rec_get_info_bits(const rec_t*,ulint)"
"dict_stats_analyze_index_for_n_prefix(dict_index_t*,ulint,const boundaries_t*,n_diff_data_t*,mtr_t*)" -> "dict_stats_analyze_index_below_cur(const btr_cur_t*,ulint,ib_uint64_t*,ib_uint64_t*,mtr_t*)"
"dict_stats_analyze_index_for_n_prefix(dict_index_t*,ulint,const boundaries_t*,n_diff_data_t*,mtr_t*)" -> "btr_page_get_prev(const ib_page_t*,mtr_t*)"
"dict_stats_analyze_index_for_n_prefix(dict_index_t*,ulint,const boundaries_t*,n_diff_data_t*,mtr_t*)" -> "page_is_comp(const ib_page_t*)"
"dict_stats_analyze_index_for_n_prefix(dict_index_t*,ulint,const boundaries_t*,n_diff_data_t*,mtr_t*)" -> "btr_pcur_close(btr_pcur_t*)"
"dict_stats_analyze_index_for_n_prefix(dict_index_t*,ulint,const boundaries_t*,n_diff_data_t*,mtr_t*)" -> "btr_pcur_move_to_next_on_page(btr_pcur_t*)"
"dict_stats_analyze_index_for_n_prefix(dict_index_t*,ulint,const boundaries_t*,n_diff_data_t*,mtr_t*)" -> "_Alloc>::at(std::vector<_Tp,_Alloc>::size_type) const [with _Tp = long unsigned int,_Alloc = std::allocator<long unsigned int>,std::vector<_Tp,_Alloc>::const_reference = const long unsigned int&,std::vector<_Tp,_Alloc>::size_type = long unsigned int]"
"dict_stats_analyze_index_for_n_prefix(dict_index_t*,ulint,const boundaries_t*,n_diff_data_t*,mtr_t*)" -> "__builtin_expect(long int,long int)"
"dict_stats_analyze_index_for_n_prefix(dict_index_t*,ulint,const boundaries_t*,n_diff_data_t*,mtr_t*)" -> "btr_pcur_open_at_index_side(bool,dict_index_t*,ulint,btr_pcur_t*,bool,ulint,mtr_t*)"
"dict_stats_analyze_index_for_n_prefix(dict_index_t*,ulint,const boundaries_t*,n_diff_data_t*,mtr_t*)" -> "ut_dbg_assertion_failed(const char*,const char*,ulint)"
"dict_stats_analyze_index_for_n_prefix(dict_index_t*,ulint,const boundaries_t*,n_diff_data_t*,mtr_t*)" -> "btr_pcur_move_to_next_user_rec(btr_pcur_t*,mtr_t*)"
"dict_stats_analyze_index_for_n_prefix(dict_index_t*,ulint,const boundaries_t*,n_diff_data_t*,mtr_t*)" -> "abort()"
"dict_stats_analyze_index_for_n_prefix(dict_index_t*,ulint,const boundaries_t*,n_diff_data_t*,mtr_t*)" -> "btr_pcur_is_on_user_rec(const btr_pcur_t*)"
"dict_stats_analyze_index_for_n_prefix(dict_index_t*,ulint,const boundaries_t*,n_diff_data_t*,mtr_t*)" -> "ut_rnd_interval(ulint,ulint)"
"dict_stats_analyze_index_below_cur(const btr_cur_t*,ulint,ib_uint64_t*,ib_uint64_t*,mtr_t*)" -> "dict_stats_scan_page(const rec_t**,ulint*,ulint*,dict_index_t*,const ib_page_t*,ulint,page_scan_method_t,ib_uint64_t*,ib_uint64_t*)"
"dict_stats_analyze_index_below_cur(const btr_cur_t*,ulint,ib_uint64_t*,ib_uint64_t*,mtr_t*)" -> "rec_get_offsets_func(const rec_t*,const dict_index_t*,ulint*,ulint,mem_heap_t**)"
"dict_stats_analyze_index_below_cur(const btr_cur_t*,ulint,ib_uint64_t*,ib_uint64_t*,mtr_t*)" -> "ut_dbg_assertion_failed(const char*,const char*,ulint)"
"dict_stats_analyze_index_below_cur(const btr_cur_t*,ulint,ib_uint64_t*,ib_uint64_t*,mtr_t*)" -> "btr_node_ptr_get_child_page_no(const rec_t*,const ulint*)"
"dict_stats_analyze_index_below_cur(const btr_cur_t*,ulint,ib_uint64_t*,ib_uint64_t*,mtr_t*)" -> "mem_heap_alloc(mem_heap_t*,ulint)"
"dict_stats_analyze_index_below_cur(const btr_cur_t*,ulint,ib_uint64_t*,ib_uint64_t*,mtr_t*)" -> "dict_table_zip_size(const dict_table_t*)"
"dict_stats_analyze_index_below_cur(const btr_cur_t*,ulint,ib_uint64_t*,ib_uint64_t*,mtr_t*)" -> "__builtin_expect(long int,long int)"
"dict_stats_analyze_index_below_cur(const btr_cur_t*,ulint,ib_uint64_t*,ib_uint64_t*,mtr_t*)" -> "dict_index_get_n_fields(const dict_index_t*)"
"dict_stats_analyze_index_below_cur(const btr_cur_t*,ulint,ib_uint64_t*,ib_uint64_t*,mtr_t*)" -> "mem_heap_free_func(mem_heap_t*,const char*,ulint)"
"dict_stats_analyze_index_below_cur(const btr_cur_t*,ulint,ib_uint64_t*,ib_uint64_t*,mtr_t*)" -> "buf_page_get_gen(ulint,ulint,ulint,ulint,buf_block_t*,ulint,const char*,ulint,mtr_t*)"
"dict_stats_analyze_index_below_cur(const btr_cur_t*,ulint,ib_uint64_t*,ib_uint64_t*,mtr_t*)" -> "dict_index_get_space(const dict_index_t*)"
"dict_stats_analyze_index_below_cur(const btr_cur_t*,ulint,ib_uint64_t*,ib_uint64_t*,mtr_t*)" -> "mem_heap_create_func(ulint,ulint)"
"dict_stats_analyze_index_below_cur(const btr_cur_t*,ulint,ib_uint64_t*,ib_uint64_t*,mtr_t*)" -> "btr_page_get_level_low(const ib_page_t*)"
"dict_stats_analyze_index_below_cur(const btr_cur_t*,ulint,ib_uint64_t*,ib_uint64_t*,mtr_t*)" -> "rec_offs_set_n_alloc(ulint*,ulint)"
"dict_stats_analyze_index_below_cur(const btr_cur_t*,ulint,ib_uint64_t*,ib_uint64_t*,mtr_t*)" -> "abort()"
"dict_stats_scan_page(const rec_t**,ulint*,ulint*,dict_index_t*,const ib_page_t*,ulint,page_scan_method_t,ib_uint64_t*,ib_uint64_t*)" -> "rec_get_offsets_func(const rec_t*,const dict_index_t*,ulint*,ulint,mem_heap_t**)"
"dict_stats_scan_page(const rec_t**,ulint*,ulint*,dict_index_t*,const ib_page_t*,ulint,page_scan_method_t,ib_uint64_t*,ib_uint64_t*)" -> "cmp_rec_rec_with_match(const rec_t*,const rec_t*,const ulint*,const ulint*,dict_index_t*,ulint,ulint*,ulint*)"
"dict_stats_scan_page(const rec_t**,ulint*,ulint*,dict_index_t*,const ib_page_t*,ulint,page_scan_method_t,ib_uint64_t*,ib_uint64_t*)" -> "__builtin_expect(long int,long int)"
"dict_stats_scan_page(const rec_t**,ulint*,ulint*,dict_index_t*,const ib_page_t*,ulint,page_scan_method_t,ib_uint64_t*,ib_uint64_t*)" -> "btr_rec_get_externally_stored_len(const rec_t*,const ulint*)"
"dict_stats_scan_page(const rec_t**,ulint*,ulint*,dict_index_t*,const ib_page_t*,ulint,page_scan_method_t,ib_uint64_t*,ib_uint64_t*)" -> "ut_dbg_assertion_failed(const char*,const char*,ulint)"
"dict_stats_scan_page(const rec_t**,ulint*,ulint*,dict_index_t*,const ib_page_t*,ulint,page_scan_method_t,ib_uint64_t*,ib_uint64_t*)" -> "page_get_infimum_offset(const ib_page_t*)"
"dict_stats_scan_page(const rec_t**,ulint*,ulint*,dict_index_t*,const ib_page_t*,ulint,page_scan_method_t,ib_uint64_t*,ib_uint64_t*)" -> "abort()"
"dict_stats_scan_page(const rec_t**,ulint*,ulint*,dict_index_t*,const ib_page_t*,ulint,page_scan_method_t,ib_uint64_t*,ib_uint64_t*)" -> "page_rec_is_supremum(const rec_t*)"
"_Alloc>::at(std::vector<_Tp,_Alloc>::size_type) const [with _Tp = long unsigned int,_Alloc = std::allocator<long unsigned int>,std::vector<_Tp,_Alloc>::const_reference = const long unsigned int&,std::vector<_Tp,_Alloc>::size_type = long unsigned int]" -> "_Alloc>::_M_range_check(std::vector<_Tp,_Alloc>::size_type) const [with _Tp = long unsigned int,_Alloc = std::allocator<long unsigned int>,std::vector<_Tp,_Alloc>::size_type = long unsigned int]"
"_Alloc>::at(std::vector<_Tp,_Alloc>::size_type) const [with _Tp = long unsigned int,_Alloc = std::allocator<long unsigned int>,std::vector<_Tp,_Alloc>::const_reference = const long unsigned int&,std::vector<_Tp,_Alloc>::size_type = long unsigned int]" -> "_Alloc>::operator[](std::vector<_Tp,_Alloc>::size_type) const [with _Tp = long unsigned int,_Alloc = std::allocator<long unsigned int>,std::vector<_Tp,_Alloc>::const_reference = const long unsigned int&,std::vector<_Tp,_Alloc>::size_type = long unsigned int]"
"_Alloc>::_M_range_check(std::vector<_Tp,_Alloc>::size_type) const [with _Tp = long unsigned int,_Alloc = std::allocator<long unsigned int>,std::vector<_Tp,_Alloc>::size_type = long unsigned int]" -> "_Alloc>::size() const [with _Tp = long unsigned int,_Alloc = std::allocator<long unsigned int>,std::vector<_Tp,_Alloc>::size_type = long unsigned int]"
"_Alloc>::_M_range_check(std::vector<_Tp,_Alloc>::size_type) const [with _Tp = long unsigned int,_Alloc = std::allocator<long unsigned int>,std::vector<_Tp,_Alloc>::size_type = long unsigned int]" -> "std::__throw_out_of_range(const char*)"
"dict_stats_index_set_n_diff(const n_diff_data_t*,dict_index_t*)" -> "dict_index_get_n_unique(const dict_index_t*)"
"dict_stats_fetch_from_ps(dict_table_t*)" -> "trx_allocate_for_background()"
"dict_stats_fetch_from_ps(dict_table_t*)" -> "pars_info_add_str_literal(pars_info_t*,const char*,const char*)"
"dict_stats_fetch_from_ps(dict_table_t*)" -> "que_eval_sql(pars_info_t*,const char*,ulint,trx_t*)"
"dict_stats_fetch_from_ps(dict_table_t*)" -> "pars_info_bind_function(pars_info_t*,const char*,pars_user_func_cb_t,void*)"
"dict_stats_fetch_from_ps(dict_table_t*)" -> "dict_fs2utf8(const char*,char*,size_t,char*,size_t)"
"dict_stats_fetch_from_ps(dict_table_t*)" -> "dict_stats_empty_table(dict_table_t*)"
"dict_stats_fetch_from_ps(dict_table_t*)" -> "pars_info_create()"
"dict_stats_fetch_from_ps(dict_table_t*)" -> "trx_start_if_not_started_low(trx_t*)"
"dict_stats_fetch_from_ps(dict_table_t*)" -> "trx_free_for_background(trx_t*)"
"dict_stats_fetch_from_ps(dict_table_t*)" -> "trx_commit_for_mysql(trx_t*)"
"pars_info_add_str_literal(pars_info_t*,const char*,const char*)" -> "strlen(const char*)"
"pars_info_add_str_literal(pars_info_t*,const char*,const char*)" -> "pars_info_add_literal(pars_info_t*,const char*,const void*,ulint,ulint,ulint)"
"dict_fs2utf8(const char*,char*,size_t,char*,size_t)" -> "abort()"
"dict_fs2utf8(const char*,char*,size_t,char*,size_t)" -> "snprintf(char*,size_t,const char*,...)"
"dict_fs2utf8(const char*,char*,size_t,char*,size_t)" -> "ut_dbg_assertion_failed(const char*,const char*,ulint)"
"dict_fs2utf8(const char*,char*,size_t,char*,size_t)" -> "dict_get_db_name_len(const char*)"
"dict_fs2utf8(const char*,char*,size_t,char*,size_t)" -> "__builtin_expect(long int,long int)"
"dict_fs2utf8(const char*,char*,size_t,char*,size_t)" -> "dict_remove_db_name(const char*)"
"dict_fs2utf8(const char*,char*,size_t,char*,size_t)" -> "memcpy(void*,const void*,size_t)"
"dict_fs2utf8(const char*,char*,size_t,char*,size_t)" -> "strconvert(CHARSET_INFO*,const char*,CHARSET_INFO*,char*,uint,uint*)"
"trx_start_if_not_started_low(trx_t*)" -> "ut_dbg_assertion_failed(const char*,const char*,ulint)"
"trx_start_if_not_started_low(trx_t*)" -> "trx_start_low(trx_t*)"
"trx_start_if_not_started_low(trx_t*)" -> "abort()"
"dict_stats_save(dict_table_t*,const index_id_t*)" -> "dict_fs2utf8(const char*,char*,size_t,char*,size_t)"
"dict_stats_save(dict_table_t*,const index_id_t*)" -> "snprintf(char*,size_t,const char*,...)"
"dict_stats_save(dict_table_t*,const index_id_t*)" -> "ut_print_timestamp(FILE*)"
"dict_stats_save(dict_table_t*,const index_id_t*)" -> "_Alloc>::operator[](const key_type&) [with _Key = const char*,_Tp = dict_index_t*,_Compare = index_cmp,_Alloc = std::allocator<std::pair<const char* const,dict_index_t*> >,std::map<_Key,_Tp,_Compare,_Alloc>::mapped_type = dict_index_t*,std::map<_Key,_Tp,_Compare,_Alloc>::key_type = const char*]"
"dict_stats_save(dict_table_t*,const index_id_t*)" -> "std::_Rb_tree_const_iterator<_Tp>::_Rb_tree_const_iterator() [with _Tp = std::pair<const char* const,dict_index_t*>]"
"dict_stats_save(dict_table_t*,const index_id_t*)" -> "pfs_rw_lock_x_unlock_func(rw_lock_t*)"
"dict_stats_save(dict_table_t*,const index_id_t*)" -> "ut_time()"
"dict_stats_save(dict_table_t*,const index_id_t*)" -> "std::_Rb_tree_const_iterator<_Tp>::_Rb_tree_const_iterator(const iterator&) [with _Tp = std::pair<const char* const,dict_index_t*>,std::_Rb_tree_const_iterator<_Tp>::iterator = std::_Rb_tree_iterator<std::pair<const char* const,dict_index_t*> >]"
"dict_stats_save(dict_table_t*,const index_id_t*)" -> "ut_format_name(const char*,ulint,char*,ulint)"
"dict_stats_save(dict_table_t*,const index_id_t*)" -> "dict_stats_snapshot_create(dict_table_t*)"
"dict_stats_save(dict_table_t*,const index_id_t*)" -> "trx_commit_for_mysql(trx_t*)"
"dict_stats_save(dict_table_t*,const index_id_t*)" -> "pfs_mutex_exit_func(ib_mutex_t*)"
"dict_stats_save(dict_table_t*,const index_id_t*)" -> "std::_Rb_tree_const_iterator<_Tp>::operator!=(const _Self&) const [with _Tp = std::pair<const char* const,dict_index_t*>,std::_Rb_tree_const_iterator<_Tp>::_Self = std::_Rb_tree_const_iterator<std::pair<const char* const,dict_index_t*> >]"
"dict_stats_save(dict_table_t*,const index_id_t*)" -> "trx_start_if_not_started_low(trx_t*)"
"dict_stats_save(dict_table_t*,const index_id_t*)" -> "dict_stats_exec_sql(pars_info_t*,const char*,trx_t*)"
"dict_stats_save(dict_table_t*,const index_id_t*)" -> "strlen(const char*)"
"dict_stats_save(dict_table_t*,const index_id_t*)" -> "pars_info_add_int4_literal(pars_info_t*,const char*,lint)"
"dict_stats_save(dict_table_t*,const index_id_t*)" -> "_Alloc>::end() [with _Key = const char*,_Tp = dict_index_t*,_Compare = index_cmp,_Alloc = std::allocator<std::pair<const char* const,dict_index_t*> >,std::map<_Key,_Tp,_Compare,_Alloc>::iterator = std::_Rb_tree_iterator<std::pair<const char* const,dict_index_t*> >]"
"dict_stats_save(dict_table_t*,const index_id_t*)" -> "dict_stats_snapshot_free(dict_table_t*)"
"dict_stats_save(dict_table_t*,const index_id_t*)" -> "dict_stats_save_index_stat(dict_index_t*,lint,const char*,ib_uint64_t,ib_uint64_t*,const char*,trx_t*)"
"dict_stats_save(dict_table_t*,const index_id_t*)" -> "trx_allocate_for_background()"
"dict_stats_save(dict_table_t*,const index_id_t*)" -> "fprintf(FILE*,const char*,...)"
"dict_stats_save(dict_table_t*,const index_id_t*)" -> "_Alloc>::map() [with _Key = const char*,_Tp = dict_index_t*,_Compare = index_cmp,_Alloc = std::allocator<std::pair<const char* const,dict_index_t*> >]"
"dict_stats_save(dict_table_t*,const index_id_t*)" -> "trx_free_for_background(trx_t*)"
"dict_stats_save(dict_table_t*,const index_id_t*)" -> "pfs_mutex_enter_func(ib_mutex_t*,const char*,ulint)"
"dict_stats_save(dict_table_t*,const index_id_t*)" -> "dict_stats_should_ignore_index(const dict_index_t*)"
"dict_stats_save(dict_table_t*,const index_id_t*)" -> "pfs_rw_lock_x_lock_func(rw_lock_t*,ulint,const char*,ulint)"
"dict_stats_save(dict_table_t*,const index_id_t*)" -> "pars_info_add_str_literal(pars_info_t*,const char*,const char*)"
"dict_stats_save(dict_table_t*,const index_id_t*)" -> "pars_info_add_ull_literal(pars_info_t*,const char*,ib_uint64_t)"
"dict_stats_save(dict_table_t*,const index_id_t*)" -> "_Alloc>::begin() [with _Key = const char*,_Tp = dict_index_t*,_Compare = index_cmp,_Alloc = std::allocator<std::pair<const char* const,dict_index_t*> >,std::map<_Key,_Tp,_Compare,_Alloc>::iterator = std::_Rb_tree_iterator<std::pair<const char* const,dict_index_t*> >]"
"dict_stats_save(dict_table_t*,const index_id_t*)" -> "std::_Rb_tree_const_iterator<_Tp>::operator->() const [with _Tp = std::pair<const char* const,dict_index_t*>,std::_Rb_tree_const_iterator<_Tp>::pointer = const std::pair<const char* const,dict_index_t*>*]"
"dict_stats_save(dict_table_t*,const index_id_t*)" -> "std::_Rb_tree_const_iterator<_Tp>::operator++() [with _Tp = std::pair<const char* const,dict_index_t*>,std::_Rb_tree_const_iterator<_Tp>::_Self = std::_Rb_tree_const_iterator<std::pair<const char* const,dict_index_t*> >]"
"dict_stats_save(dict_table_t*,const index_id_t*)" -> "ut_strerr(dberr_t)"
"dict_stats_save(dict_table_t*,const index_id_t*)" -> "pars_info_create()"
"_Alloc>::operator[](const key_type&) [with _Key = const char*,_Tp = dict_index_t*,_Compare = index_cmp,_Alloc = std::allocator<std::pair<const char* const,dict_index_t*> >,std::map<_Key,_Tp,_Compare,_Alloc>::mapped_type = dict_index_t*,std::map<_Key,_Tp,_Compare,_Alloc>::key_type = const char*]" -> "_Alloc>::insert(std::map<_Key,_Tp,_Compare,_Alloc>::iterator,const value_type&) [with _Key = const char*,_Tp = dict_index_t*,_Compare = index_cmp,_Alloc = std::allocator<std::pair<const char* const,dict_index_t*> >,std::map<_Key,_Tp,_Compare,_Alloc>::iterator = std::_Rb_tree_iterator<std::pair<const char* const,dict_index_t*> >,std::map<_Key,_Tp,_Compare,_Alloc>::value_type = std::pair<const char* const,dict_index_t*>]"
"_Alloc>::operator[](const key_type&) [with _Key = const char*,_Tp = dict_index_t*,_Compare = index_cmp,_Alloc = std::allocator<std::pair<const char* const,dict_index_t*> >,std::map<_Key,_Tp,_Compare,_Alloc>::mapped_type = dict_index_t*,std::map<_Key,_Tp,_Compare,_Alloc>::key_type = const char*]" -> "_T2>::pair(const _T1&,const _T2&) [with _T1 = const char* const,_T2 = dict_index_t*]"
"_Alloc>::operator[](const key_type&) [with _Key = const char*,_Tp = dict_index_t*,_Compare = index_cmp,_Alloc = std::allocator<std::pair<const char* const,dict_index_t*> >,std::map<_Key,_Tp,_Compare,_Alloc>::mapped_type = dict_index_t*,std::map<_Key,_Tp,_Compare,_Alloc>::key_type = const char*]" -> "index_cmp::operator()(const char*,const char*) const"
"_Alloc>::operator[](const key_type&) [with _Key = const char*,_Tp = dict_index_t*,_Compare = index_cmp,_Alloc = std::allocator<std::pair<const char* const,dict_index_t*> >,std::map<_Key,_Tp,_Compare,_Alloc>::mapped_type = dict_index_t*,std::map<_Key,_Tp,_Compare,_Alloc>::key_type = const char*]" -> "_Alloc>::key_comp() const [with _Key = const char*,_Tp = dict_index_t*,_Compare = index_cmp,_Alloc = std::allocator<std::pair<const char* const,dict_index_t*> >,std::map<_Key,_Tp,_Compare,_Alloc>::key_compare = index_cmp]"
"_Alloc>::operator[](const key_type&) [with _Key = const char*,_Tp = dict_index_t*,_Compare = index_cmp,_Alloc = std::allocator<std::pair<const char* const,dict_index_t*> >,std::map<_Key,_Tp,_Compare,_Alloc>::mapped_type = dict_index_t*,std::map<_Key,_Tp,_Compare,_Alloc>::key_type = const char*]" -> "_Alloc>::lower_bound(const key_type&) [with _Key = const char*,_Tp = dict_index_t*,_Compare = index_cmp,_Alloc = std::allocator<std::pair<const char* const,dict_index_t*> >,std::map<_Key,_Tp,_Compare,_Alloc>::iterator = std::_Rb_tree_iterator<std::pair<const char* const,dict_index_t*> >,std::map<_Key,_Tp,_Compare,_Alloc>::key_type = const char*]"
"_Alloc>::operator[](const key_type&) [with _Key = const char*,_Tp = dict_index_t*,_Compare = index_cmp,_Alloc = std::allocator<std::pair<const char* const,dict_index_t*> >,std::map<_Key,_Tp,_Compare,_Alloc>::mapped_type = dict_index_t*,std::map<_Key,_Tp,_Compare,_Alloc>::key_type = const char*]" -> "std::_Rb_tree_iterator<_Tp>::operator==(const _Self&) const [with _Tp = std::pair<const char* const,dict_index_t*>,std::_Rb_tree_iterator<_Tp>::_Self = std::_Rb_tree_iterator<std::pair<const char* const,dict_index_t*> >]"
"_Alloc>::operator[](const key_type&) [with _Key = const char*,_Tp = dict_index_t*,_Compare = index_cmp,_Alloc = std::allocator<std::pair<const char* const,dict_index_t*> >,std::map<_Key,_Tp,_Compare,_Alloc>::mapped_type = dict_index_t*,std::map<_Key,_Tp,_Compare,_Alloc>::key_type = const char*]" -> "_Alloc>::end() [with _Key = const char*,_Tp = dict_index_t*,_Compare = index_cmp,_Alloc = std::allocator<std::pair<const char* const,dict_index_t*> >,std::map<_Key,_Tp,_Compare,_Alloc>::iterator = std::_Rb_tree_iterator<std::pair<const char* const,dict_index_t*> >]"
"_Alloc>::operator[](const key_type&) [with _Key = const char*,_Tp = dict_index_t*,_Compare = index_cmp,_Alloc = std::allocator<std::pair<const char* const,dict_index_t*> >,std::map<_Key,_Tp,_Compare,_Alloc>::mapped_type = dict_index_t*,std::map<_Key,_Tp,_Compare,_Alloc>::key_type = const char*]" -> "std::_Rb_tree_iterator<_Tp>::operator*() const [with _Tp = std::pair<const char* const,dict_index_t*>,std::_Rb_tree_iterator<_Tp>::reference = std::pair<const char* const,dict_index_t*>&]"
"_Alloc>::insert(std::map<_Key,_Tp,_Compare,_Alloc>::iterator,const value_type&) [with _Key = const char*,_Tp = dict_index_t*,_Compare = index_cmp,_Alloc = std::allocator<std::pair<const char* const,dict_index_t*> >,std::map<_Key,_Tp,_Compare,_Alloc>::iterator = std::_Rb_tree_iterator<std::pair<const char* const,dict_index_t*> >,std::map<_Key,_Tp,_Compare,_Alloc>::value_type = std::pair<const char* const,dict_index_t*>]" -> "std::_Rb_tree_const_iterator<_Tp>::_Rb_tree_const_iterator(const iterator&) [with _Tp = std::pair<const char* const,dict_index_t*>,std::_Rb_tree_const_iterator<_Tp>::iterator = std::_Rb_tree_iterator<std::pair<const char* const,dict_index_t*> >]"
"_Alloc>::insert(std::map<_Key,_Tp,_Compare,_Alloc>::iterator,const value_type&) [with _Key = const char*,_Tp = dict_index_t*,_Compare = index_cmp,_Alloc = std::allocator<std::pair<const char* const,dict_index_t*> >,std::map<_Key,_Tp,_Compare,_Alloc>::iterator = std::_Rb_tree_iterator<std::pair<const char* const,dict_index_t*> >,std::map<_Key,_Tp,_Compare,_Alloc>::value_type = std::pair<const char* const,dict_index_t*>]" -> "_Alloc>::_M_insert_unique_(std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::const_iterator,const _Val&) [with _Key = const char*,_Val = std::pair<const char* const,dict_index_t*>,_KeyOfValue = std::_Select1st<std::pair<const char* const,dict_index_t*> >,_Compare = index_cmp,_Alloc = std::allocator<std::pair<const char* const,dict_index_t*> >,std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::iterator = std::_Rb_tree_iterator<std::pair<const char* const,dict_index_t*> >,std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::const_iterator = std::_Rb_tree_const_iterator<std::pair<const char* const,dict_index_t*> >]"
"_Alloc>::_M_insert_unique_(std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::const_iterator,const _Val&) [with _Key = const char*,_Val = std::pair<const char* const,dict_index_t*>,_KeyOfValue = std::_Select1st<std::pair<const char* const,dict_index_t*> >,_Compare = index_cmp,_Alloc = std::allocator<std::pair<const char* const,dict_index_t*> >,std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::iterator = std::_Rb_tree_iterator<std::pair<const char* const,dict_index_t*> >,std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::const_iterator = std::_Rb_tree_const_iterator<std::pair<const char* const,dict_index_t*> >]" -> "_Alloc>::_S_right(std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::_Const_Base_ptr) [with _Key = const char*,_Val = std::pair<const char* const,dict_index_t*>,_KeyOfValue = std::_Select1st<std::pair<const char* const,dict_index_t*> >,_Compare = index_cmp,_Alloc = std::allocator<std::pair<const char* const,dict_index_t*> >,std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::_Const_Link_type = const std::_Rb_tree_node<std::pair<const char* const,dict_index_t*> >*,std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::_Const_Base_ptr = const std::_Rb_tree_node_base*]"
"_Alloc>::_M_insert_unique_(std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::const_iterator,const _Val&) [with _Key = const char*,_Val = std::pair<const char* const,dict_index_t*>,_KeyOfValue = std::_Select1st<std::pair<const char* const,dict_index_t*> >,_Compare = index_cmp,_Alloc = std::allocator<std::pair<const char* const,dict_index_t*> >,std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::iterator = std::_Rb_tree_iterator<std::pair<const char* const,dict_index_t*> >,std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::const_iterator = std::_Rb_tree_const_iterator<std::pair<const char* const,dict_index_t*> >]" -> "std::_Rb_tree_const_iterator<_Tp>::operator--() [with _Tp = std::pair<const char* const,dict_index_t*>,std::_Rb_tree_const_iterator<_Tp>::_Self = std::_Rb_tree_const_iterator<std::pair<const char* const,dict_index_t*> >]"
"_Alloc>::_M_insert_unique_(std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::const_iterator,const _Val&) [with _Key = const char*,_Val = std::pair<const char* const,dict_index_t*>,_KeyOfValue = std::_Select1st<std::pair<const char* const,dict_index_t*> >,_Compare = index_cmp,_Alloc = std::allocator<std::pair<const char* const,dict_index_t*> >,std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::iterator = std::_Rb_tree_iterator<std::pair<const char* const,dict_index_t*> >,std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::const_iterator = std::_Rb_tree_const_iterator<std::pair<const char* const,dict_index_t*> >]" -> "std::_Select1st<_Pair>::operator()(const _Pair&) const [with _Pair = std::pair<const char* const,dict_index_t*>,typename _Pair::first_type = const char* const]"
"_Alloc>::_M_insert_unique_(std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::const_iterator,const _Val&) [with _Key = const char*,_Val = std::pair<const char* const,dict_index_t*>,_KeyOfValue = std::_Select1st<std::pair<const char* const,dict_index_t*> >,_Compare = index_cmp,_Alloc = std::allocator<std::pair<const char* const,dict_index_t*> >,std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::iterator = std::_Rb_tree_iterator<std::pair<const char* const,dict_index_t*> >,std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::const_iterator = std::_Rb_tree_const_iterator<std::pair<const char* const,dict_index_t*> >]" -> "_Alloc>::_M_insert_unique(const _Val&) [with _Key = const char*,_Val = std::pair<const char* const,dict_index_t*>,_KeyOfValue = std::_Select1st<std::pair<const char* const,dict_index_t*> >,_Compare = index_cmp,_Alloc = std::allocator<std::pair<const char* const,dict_index_t*> >]"
"_Alloc>::_M_insert_unique_(std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::const_iterator,const _Val&) [with _Key = const char*,_Val = std::pair<const char* const,dict_index_t*>,_KeyOfValue = std::_Select1st<std::pair<const char* const,dict_index_t*> >,_Compare = index_cmp,_Alloc = std::allocator<std::pair<const char* const,dict_index_t*> >,std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::iterator = std::_Rb_tree_iterator<std::pair<const char* const,dict_index_t*> >,std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::const_iterator = std::_Rb_tree_const_iterator<std::pair<const char* const,dict_index_t*> >]" -> "_Alloc>::_M_end() [with _Key = const char*,_Val = std::pair<const char* const,dict_index_t*>,_KeyOfValue = std::_Select1st<std::pair<const char* const,dict_index_t*> >,_Compare = index_cmp,_Alloc = std::allocator<std::pair<const char* const,dict_index_t*> >,std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::_Link_type = std::_Rb_tree_node<std::pair<const char* const,dict_index_t*> >*]"
"_Alloc>::_M_insert_unique_(std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::const_iterator,const _Val&) [with _Key = const char*,_Val = std::pair<const char* const,dict_index_t*>,_KeyOfValue = std::_Select1st<std::pair<const char* const,dict_index_t*> >,_Compare = index_cmp,_Alloc = std::allocator<std::pair<const char* const,dict_index_t*> >,std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::iterator = std::_Rb_tree_iterator<std::pair<const char* const,dict_index_t*> >,std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::const_iterator = std::_Rb_tree_const_iterator<std::pair<const char* const,dict_index_t*> >]" -> "_Alloc>::size() const [with _Key = const char*,_Val = std::pair<const char* const,dict_index_t*>,_KeyOfValue = std::_Select1st<std::pair<const char* const,dict_index_t*> >,_Compare = index_cmp,_Alloc = std::allocator<std::pair<const char* const,dict_index_t*> >,std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::size_type = long unsigned int]"
"_Alloc>::_M_insert_unique_(std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::const_iterator,const _Val&) [with _Key = const char*,_Val = std::pair<const char* const,dict_index_t*>,_KeyOfValue = std::_Select1st<std::pair<const char* const,dict_index_t*> >,_Compare = index_cmp,_Alloc = std::allocator<std::pair<const char* const,dict_index_t*> >,std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::iterator = std::_Rb_tree_iterator<std::pair<const char* const,dict_index_t*> >,std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::const_iterator = std::_Rb_tree_const_iterator<std::pair<const char* const,dict_index_t*> >]" -> "index_cmp::operator()(const char*,const char*) const"
"_Alloc>::_M_insert_unique_(std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::const_iterator,const _Val&) [with _Key = const char*,_Val = std::pair<const char* const,dict_index_t*>,_KeyOfValue = std::_Select1st<std::pair<const char* const,dict_index_t*> >,_Compare = index_cmp,_Alloc = std::allocator<std::pair<const char* const,dict_index_t*> >,std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::iterator = std::_Rb_tree_iterator<std::pair<const char* const,dict_index_t*> >,std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::const_iterator = std::_Rb_tree_const_iterator<std::pair<const char* const,dict_index_t*> >]" -> "std::_Rb_tree_const_iterator<_Tp>::_M_const_cast() const [with _Tp = std::pair<const char* const,dict_index_t*>,std::_Rb_tree_const_iterator<_Tp>::iterator = std::_Rb_tree_iterator<std::pair<const char* const,dict_index_t*> >]"
"_Alloc>::_M_insert_unique_(std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::const_iterator,const _Val&) [with _Key = const char*,_Val = std::pair<const char* const,dict_index_t*>,_KeyOfValue = std::_Select1st<std::pair<const char* const,dict_index_t*> >,_Compare = index_cmp,_Alloc = std::allocator<std::pair<const char* const,dict_index_t*> >,std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::iterator = std::_Rb_tree_iterator<std::pair<const char* const,dict_index_t*> >,std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::const_iterator = std::_Rb_tree_const_iterator<std::pair<const char* const,dict_index_t*> >]" -> "_Alloc>::_S_key(std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::_Const_Base_ptr) [with _Key = const char*,_Val = std::pair<const char* const,dict_index_t*>,_KeyOfValue = std::_Select1st<std::pair<const char* const,dict_index_t*> >,_Compare = index_cmp,_Alloc = std::allocator<std::pair<const char* const,dict_index_t*> >,std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::_Const_Base_ptr = const std::_Rb_tree_node_base*]"
"_Alloc>::_M_insert_unique_(std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::const_iterator,const _Val&) [with _Key = const char*,_Val = std::pair<const char* const,dict_index_t*>,_KeyOfValue = std::_Select1st<std::pair<const char* const,dict_index_t*> >,_Compare = index_cmp,_Alloc = std::allocator<std::pair<const char* const,dict_index_t*> >,std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::iterator = std::_Rb_tree_iterator<std::pair<const char* const,dict_index_t*> >,std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::const_iterator = std::_Rb_tree_const_iterator<std::pair<const char* const,dict_index_t*> >]" -> "_Alloc>::_M_insert_(std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::_Const_Base_ptr,std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::_Const_Base_ptr,const _Val&) [with _Key = const char*,_Val = std::pair<const char* const,dict_index_t*>,_KeyOfValue = std::_Select1st<std::pair<const char* const,dict_index_t*> >,_Compare = index_cmp,_Alloc = std::allocator<std::pair<const char* const,dict_index_t*> >,std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::iterator = std::_Rb_tree_iterator<std::pair<const char* const,dict_index_t*> >,std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::_Const_Base_ptr = const std::_Rb_tree_node_base*]"
"_Alloc>::_M_insert_unique_(std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::const_iterator,const _Val&) [with _Key = const char*,_Val = std::pair<const char* const,dict_index_t*>,_KeyOfValue = std::_Select1st<std::pair<const char* const,dict_index_t*> >,_Compare = index_cmp,_Alloc = std::allocator<std::pair<const char* const,dict_index_t*> >,std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::iterator = std::_Rb_tree_iterator<std::pair<const char* const,dict_index_t*> >,std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::const_iterator = std::_Rb_tree_const_iterator<std::pair<const char* const,dict_index_t*> >]" -> "_Alloc>::_M_rightmost() [with _Key = const char*,_Val = std::pair<const char* const,dict_index_t*>,_KeyOfValue = std::_Select1st<std::pair<const char* const,dict_index_t*> >,_Compare = index_cmp,_Alloc = std::allocator<std::pair<const char* const,dict_index_t*> >,std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::_Base_ptr = std::_Rb_tree_node_base*]"
"_Alloc>::_M_insert_unique_(std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::const_iterator,const _Val&) [with _Key = const char*,_Val = std::pair<const char* const,dict_index_t*>,_KeyOfValue = std::_Select1st<std::pair<const char* const,dict_index_t*> >,_Compare = index_cmp,_Alloc = std::allocator<std::pair<const char* const,dict_index_t*> >,std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::iterator = std::_Rb_tree_iterator<std::pair<const char* const,dict_index_t*> >,std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::const_iterator = std::_Rb_tree_const_iterator<std::pair<const char* const,dict_index_t*> >]" -> "std::_Rb_tree_const_iterator<_Tp>::operator++() [with _Tp = std::pair<const char* const,dict_index_t*>,std::_Rb_tree_const_iterator<_Tp>::_Self = std::_Rb_tree_const_iterator<std::pair<const char* const,dict_index_t*> >]"
"_Alloc>::_M_insert_unique_(std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::const_iterator,const _Val&) [with _Key = const char*,_Val = std::pair<const char* const,dict_index_t*>,_KeyOfValue = std::_Select1st<std::pair<const char* const,dict_index_t*> >,_Compare = index_cmp,_Alloc = std::allocator<std::pair<const char* const,dict_index_t*> >,std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::iterator = std::_Rb_tree_iterator<std::pair<const char* const,dict_index_t*> >,std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::const_iterator = std::_Rb_tree_const_iterator<std::pair<const char* const,dict_index_t*> >]" -> "_Alloc>::_M_leftmost() [with _Key = const char*,_Val = std::pair<const char* const,dict_index_t*>,_KeyOfValue = std::_Select1st<std::pair<const char* const,dict_index_t*> >,_Compare = index_cmp,_Alloc = std::allocator<std::pair<const char* const,dict_index_t*> >,std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::_Base_ptr = std::_Rb_tree_node_base*]"
"std::_Rb_tree_const_iterator<_Tp>::operator--() [with _Tp = std::pair<const char* const,dict_index_t*>,std::_Rb_tree_const_iterator<_Tp>::_Self = std::_Rb_tree_const_iterator<std::pair<const char* const,dict_index_t*> >]" -> "std::_Rb_tree_decrement(const std::_Rb_tree_node_base*)"
"_Alloc>::_M_insert_unique(const _Val&) [with _Key = const char*,_Val = std::pair<const char* const,dict_index_t*>,_KeyOfValue = std::_Select1st<std::pair<const char* const,dict_index_t*> >,_Compare = index_cmp,_Alloc = std::allocator<std::pair<const char* const,dict_index_t*> >]" -> "std::_Select1st<_Pair>::operator()(const _Pair&) const [with _Pair = std::pair<const char* const,dict_index_t*>,typename _Pair::first_type = const char* const]"
"_Alloc>::_M_insert_unique(const _Val&) [with _Key = const char*,_Val = std::pair<const char* const,dict_index_t*>,_KeyOfValue = std::_Select1st<std::pair<const char* const,dict_index_t*> >,_Compare = index_cmp,_Alloc = std::allocator<std::pair<const char* const,dict_index_t*> >]" -> "_Alloc>::_S_left(std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::_Base_ptr) [with _Key = const char*,_Val = std::pair<const char* const,dict_index_t*>,_KeyOfValue = std::_Select1st<std::pair<const char* const,dict_index_t*> >,_Compare = index_cmp,_Alloc = std::allocator<std::pair<const char* const,dict_index_t*> >,std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::_Link_type = std::_Rb_tree_node<std::pair<const char* const,dict_index_t*> >*,std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::_Base_ptr = std::_Rb_tree_node_base*]"
"_Alloc>::_M_insert_unique(const _Val&) [with _Key = const char*,_Val = std::pair<const char* const,dict_index_t*>,_KeyOfValue = std::_Select1st<std::pair<const char* const,dict_index_t*> >,_Compare = index_cmp,_Alloc = std::allocator<std::pair<const char* const,dict_index_t*> >]" -> "_T2>::pair(const _T1&,const _T2&) [with _T1 = std::_Rb_tree_iterator<std::pair<const char* const,dict_index_t*> >,_T2 = bool]"
"_Alloc>::_M_insert_unique(const _Val&) [with _Key = const char*,_Val = std::pair<const char* const,dict_index_t*>,_KeyOfValue = std::_Select1st<std::pair<const char* const,dict_index_t*> >,_Compare = index_cmp,_Alloc = std::allocator<std::pair<const char* const,dict_index_t*> >]" -> "_Alloc>::_M_begin() [with _Key = const char*,_Val = std::pair<const char* const,dict_index_t*>,_KeyOfValue = std::_Select1st<std::pair<const char* const,dict_index_t*> >,_Compare = index_cmp,_Alloc = std::allocator<std::pair<const char* const,dict_index_t*> >,std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::_Link_type = std::_Rb_tree_node<std::pair<const char* const,dict_index_t*> >*]"
"_Alloc>::_M_insert_unique(const _Val&) [with _Key = const char*,_Val = std::pair<const char* const,dict_index_t*>,_KeyOfValue = std::_Select1st<std::pair<const char* const,dict_index_t*> >,_Compare = index_cmp,_Alloc = std::allocator<std::pair<const char* const,dict_index_t*> >]" -> "_Alloc>::_S_right(std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::_Base_ptr) [with _Key = const char*,_Val = std::pair<const char* const,dict_index_t*>,_KeyOfValue = std::_Select1st<std::pair<const char* const,dict_index_t*> >,_Compare = index_cmp,_Alloc = std::allocator<std::pair<const char* const,dict_index_t*> >,std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::_Link_type = std::_Rb_tree_node<std::pair<const char* const,dict_index_t*> >*,std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::_Base_ptr = std::_Rb_tree_node_base*]"
"_Alloc>::_M_insert_unique(const _Val&) [with _Key = const char*,_Val = std::pair<const char* const,dict_index_t*>,_KeyOfValue = std::_Select1st<std::pair<const char* const,dict_index_t*> >,_Compare = index_cmp,_Alloc = std::allocator<std::pair<const char* const,dict_index_t*> >]" -> "std::_Rb_tree_iterator<_Tp>::operator--() [with _Tp = std::pair<const char* const,dict_index_t*>,std::_Rb_tree_iterator<_Tp>::_Self = std::_Rb_tree_iterator<std::pair<const char* const,dict_index_t*> >]"
"_Alloc>::_M_insert_unique(const _Val&) [with _Key = const char*,_Val = std::pair<const char* const,dict_index_t*>,_KeyOfValue = std::_Select1st<std::pair<const char* const,dict_index_t*> >,_Compare = index_cmp,_Alloc = std::allocator<std::pair<const char* const,dict_index_t*> >]" -> "_Alloc>::_S_key(std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::_Const_Base_ptr) [with _Key = const char*,_Val = std::pair<const char* const,dict_index_t*>,_KeyOfValue = std::_Select1st<std::pair<const char* const,dict_index_t*> >,_Compare = index_cmp,_Alloc = std::allocator<std::pair<const char* const,dict_index_t*> >,std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::_Const_Base_ptr = const std::_Rb_tree_node_base*]"
"_Alloc>::_M_insert_unique(const _Val&) [with _Key = const char*,_Val = std::pair<const char* const,dict_index_t*>,_KeyOfValue = std::_Select1st<std::pair<const char* const,dict_index_t*> >,_Compare = index_cmp,_Alloc = std::allocator<std::pair<const char* const,dict_index_t*> >]" -> "_Alloc>::begin() [with _Key = const char*,_Val = std::pair<const char* const,dict_index_t*>,_KeyOfValue = std::_Select1st<std::pair<const char* const,dict_index_t*> >,_Compare = index_cmp,_Alloc = std::allocator<std::pair<const char* const,dict_index_t*> >,std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::iterator = std::_Rb_tree_iterator<std::pair<const char* const,dict_index_t*> >]"
"_Alloc>::_M_insert_unique(const _Val&) [with _Key = const char*,_Val = std::pair<const char* const,dict_index_t*>,_KeyOfValue = std::_Select1st<std::pair<const char* const,dict_index_t*> >,_Compare = index_cmp,_Alloc = std::allocator<std::pair<const char* const,dict_index_t*> >]" -> "index_cmp::operator()(const char*,const char*) const"
"_Alloc>::_M_insert_unique(const _Val&) [with _Key = const char*,_Val = std::pair<const char* const,dict_index_t*>,_KeyOfValue = std::_Select1st<std::pair<const char* const,dict_index_t*> >,_Compare = index_cmp,_Alloc = std::allocator<std::pair<const char* const,dict_index_t*> >]" -> "std::_Rb_tree_iterator<_Tp>::operator==(const _Self&) const [with _Tp = std::pair<const char* const,dict_index_t*>,std::_Rb_tree_iterator<_Tp>::_Self = std::_Rb_tree_iterator<std::pair<const char* const,dict_index_t*> >]"
"_Alloc>::_M_insert_unique(const _Val&) [with _Key = const char*,_Val = std::pair<const char* const,dict_index_t*>,_KeyOfValue = std::_Select1st<std::pair<const char* const,dict_index_t*> >,_Compare = index_cmp,_Alloc = std::allocator<std::pair<const char* const,dict_index_t*> >]" -> "_Alloc>::_M_insert_(std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::_Const_Base_ptr,std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::_Const_Base_ptr,const _Val&) [with _Key = const char*,_Val = std::pair<const char* const,dict_index_t*>,_KeyOfValue = std::_Select1st<std::pair<const char* const,dict_index_t*> >,_Compare = index_cmp,_Alloc = std::allocator<std::pair<const char* const,dict_index_t*> >,std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::iterator = std::_Rb_tree_iterator<std::pair<const char* const,dict_index_t*> >,std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::_Const_Base_ptr = const std::_Rb_tree_node_base*]"
"_Alloc>::_M_insert_unique(const _Val&) [with _Key = const char*,_Val = std::pair<const char* const,dict_index_t*>,_KeyOfValue = std::_Select1st<std::pair<const char* const,dict_index_t*> >,_Compare = index_cmp,_Alloc = std::allocator<std::pair<const char* const,dict_index_t*> >]" -> "std::_Rb_tree_iterator<_Tp>::_Rb_tree_iterator(std::_Rb_tree_iterator<_Tp>::_Link_type) [with _Tp = std::pair<const char* const,dict_index_t*>,std::_Rb_tree_iterator<_Tp>::_Link_type = std::_Rb_tree_node<std::pair<const char* const,dict_index_t*> >*]"
"_Alloc>::_M_insert_unique(const _Val&) [with _Key = const char*,_Val = std::pair<const char* const,dict_index_t*>,_KeyOfValue = std::_Select1st<std::pair<const char* const,dict_index_t*> >,_Compare = index_cmp,_Alloc = std::allocator<std::pair<const char* const,dict_index_t*> >]" -> "_Alloc>::_M_end() [with _Key = const char*,_Val = std::pair<const char* const,dict_index_t*>,_KeyOfValue = std::_Select1st<std::pair<const char* const,dict_index_t*> >,_Compare = index_cmp,_Alloc = std::allocator<std::pair<const char* const,dict_index_t*> >,std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::_Link_type = std::_Rb_tree_node<std::pair<const char* const,dict_index_t*> >*]"
"_Alloc>::_M_insert_unique(const _Val&) [with _Key = const char*,_Val = std::pair<const char* const,dict_index_t*>,_KeyOfValue = std::_Select1st<std::pair<const char* const,dict_index_t*> >,_Compare = index_cmp,_Alloc = std::allocator<std::pair<const char* const,dict_index_t*> >]" -> "_Alloc>::_S_key(std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::_Const_Link_type) [with _Key = const char*,_Val = std::pair<const char* const,dict_index_t*>,_KeyOfValue = std::_Select1st<std::pair<const char* const,dict_index_t*> >,_Compare = index_cmp,_Alloc = std::allocator<std::pair<const char* const,dict_index_t*> >,std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::_Const_Link_type = const std::_Rb_tree_node<std::pair<const char* const,dict_index_t*> >*]"
"std::_Rb_tree_iterator<_Tp>::operator--() [with _Tp = std::pair<const char* const,dict_index_t*>,std::_Rb_tree_iterator<_Tp>::_Self = std::_Rb_tree_iterator<std::pair<const char* const,dict_index_t*> >]" -> "std::_Rb_tree_decrement(std::_Rb_tree_node_base*)"
"_Alloc>::_S_key(std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::_Const_Base_ptr) [with _Key = const char*,_Val = std::pair<const char* const,dict_index_t*>,_KeyOfValue = std::_Select1st<std::pair<const char* const,dict_index_t*> >,_Compare = index_cmp,_Alloc = std::allocator<std::pair<const char* const,dict_index_t*> >,std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::_Const_Base_ptr = const std::_Rb_tree_node_base*]" -> "std::_Select1st<_Pair>::operator()(const _Pair&) const [with _Pair = std::pair<const char* const,dict_index_t*>,typename _Pair::first_type = const char* const]"
"_Alloc>::_S_key(std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::_Const_Base_ptr) [with _Key = const char*,_Val = std::pair<const char* const,dict_index_t*>,_KeyOfValue = std::_Select1st<std::pair<const char* const,dict_index_t*> >,_Compare = index_cmp,_Alloc = std::allocator<std::pair<const char* const,dict_index_t*> >,std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::_Const_Base_ptr = const std::_Rb_tree_node_base*]" -> "_Alloc>::_S_value(std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::_Const_Base_ptr) [with _Key = const char*,_Val = std::pair<const char* const,dict_index_t*>,_KeyOfValue = std::_Select1st<std::pair<const char* const,dict_index_t*> >,_Compare = index_cmp,_Alloc = std::allocator<std::pair<const char* const,dict_index_t*> >,std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::const_reference = const std::pair<const char* const,dict_index_t*>&,std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::value_type = std::pair<const char* const,dict_index_t*>,std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::_Const_Base_ptr = const std::_Rb_tree_node_base*]"
"_Alloc>::begin() [with _Key = const char*,_Val = std::pair<const char* const,dict_index_t*>,_KeyOfValue = std::_Select1st<std::pair<const char* const,dict_index_t*> >,_Compare = index_cmp,_Alloc = std::allocator<std::pair<const char* const,dict_index_t*> >,std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::iterator = std::_Rb_tree_iterator<std::pair<const char* const,dict_index_t*> >]" -> "std::_Rb_tree_iterator<_Tp>::_Rb_tree_iterator(std::_Rb_tree_iterator<_Tp>::_Link_type) [with _Tp = std::pair<const char* const,dict_index_t*>,std::_Rb_tree_iterator<_Tp>::_Link_type = std::_Rb_tree_node<std::pair<const char* const,dict_index_t*> >*]"
"index_cmp::operator()(const char*,const char*) const" -> "strcmp(const char*,const char*)"
"_Alloc>::_M_insert_(std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::_Const_Base_ptr,std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::_Const_Base_ptr,const _Val&) [with _Key = const char*,_Val = std::pair<const char* const,dict_index_t*>,_KeyOfValue = std::_Select1st<std::pair<const char* const,dict_index_t*> >,_Compare = index_cmp,_Alloc = std::allocator<std::pair<const char* const,dict_index_t*> >,std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::iterator = std::_Rb_tree_iterator<std::pair<const char* const,dict_index_t*> >,std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::_Const_Base_ptr = const std::_Rb_tree_node_base*]" -> "std::_Rb_tree_iterator<_Tp>::_Rb_tree_iterator(std::_Rb_tree_iterator<_Tp>::_Link_type) [with _Tp = std::pair<const char* const,dict_index_t*>,std::_Rb_tree_iterator<_Tp>::_Link_type = std::_Rb_tree_node<std::pair<const char* const,dict_index_t*> >*]"
"_Alloc>::_M_insert_(std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::_Const_Base_ptr,std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::_Const_Base_ptr,const _Val&) [with _Key = const char*,_Val = std::pair<const char* const,dict_index_t*>,_KeyOfValue = std::_Select1st<std::pair<const char* const,dict_index_t*> >,_Compare = index_cmp,_Alloc = std::allocator<std::pair<const char* const,dict_index_t*> >,std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::iterator = std::_Rb_tree_iterator<std::pair<const char* const,dict_index_t*> >,std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::_Const_Base_ptr = const std::_Rb_tree_node_base*]" -> "_Alloc>::_M_end() [with _Key = const char*,_Val = std::pair<const char* const,dict_index_t*>,_KeyOfValue = std::_Select1st<std::pair<const char* const,dict_index_t*> >,_Compare = index_cmp,_Alloc = std::allocator<std::pair<const char* const,dict_index_t*> >,std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::_Link_type = std::_Rb_tree_node<std::pair<const char* const,dict_index_t*> >*]"
"_Alloc>::_M_insert_(std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::_Const_Base_ptr,std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::_Const_Base_ptr,const _Val&) [with _Key = const char*,_Val = std::pair<const char* const,dict_index_t*>,_KeyOfValue = std::_Select1st<std::pair<const char* const,dict_index_t*> >,_Compare = index_cmp,_Alloc = std::allocator<std::pair<const char* const,dict_index_t*> >,std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::iterator = std::_Rb_tree_iterator<std::pair<const char* const,dict_index_t*> >,std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::_Const_Base_ptr = const std::_Rb_tree_node_base*]" -> "std::_Rb_tree_insert_and_rebalance(bool,std::_Rb_tree_node_base*,std::_Rb_tree_node_base*,std::_Rb_tree_node_base&)"
"_Alloc>::_M_insert_(std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::_Const_Base_ptr,std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::_Const_Base_ptr,const _Val&) [with _Key = const char*,_Val = std::pair<const char* const,dict_index_t*>,_KeyOfValue = std::_Select1st<std::pair<const char* const,dict_index_t*> >,_Compare = index_cmp,_Alloc = std::allocator<std::pair<const char* const,dict_index_t*> >,std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::iterator = std::_Rb_tree_iterator<std::pair<const char* const,dict_index_t*> >,std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::_Const_Base_ptr = const std::_Rb_tree_node_base*]" -> "_Alloc>::_S_key(std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::_Const_Base_ptr) [with _Key = const char*,_Val = std::pair<const char* const,dict_index_t*>,_KeyOfValue = std::_Select1st<std::pair<const char* const,dict_index_t*> >,_Compare = index_cmp,_Alloc = std::allocator<std::pair<const char* const,dict_index_t*> >,std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::_Const_Base_ptr = const std::_Rb_tree_node_base*]"
"_Alloc>::_M_insert_(std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::_Const_Base_ptr,std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::_Const_Base_ptr,const _Val&) [with _Key = const char*,_Val = std::pair<const char* const,dict_index_t*>,_KeyOfValue = std::_Select1st<std::pair<const char* const,dict_index_t*> >,_Compare = index_cmp,_Alloc = std::allocator<std::pair<const char* const,dict_index_t*> >,std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::iterator = std::_Rb_tree_iterator<std::pair<const char* const,dict_index_t*> >,std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::_Const_Base_ptr = const std::_Rb_tree_node_base*]" -> "_Alloc>::_M_create_node(const value_type&) [with _Key = const char*,_Val = std::pair<const char* const,dict_index_t*>,_KeyOfValue = std::_Select1st<std::pair<const char* const,dict_index_t*> >,_Compare = index_cmp,_Alloc = std::allocator<std::pair<const char* const,dict_index_t*> >,std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::_Link_type = std::_Rb_tree_node<std::pair<const char* const,dict_index_t*> >*,std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::value_type = std::pair<const char* const,dict_index_t*>]"
"_Alloc>::_M_insert_(std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::_Const_Base_ptr,std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::_Const_Base_ptr,const _Val&) [with _Key = const char*,_Val = std::pair<const char* const,dict_index_t*>,_KeyOfValue = std::_Select1st<std::pair<const char* const,dict_index_t*> >,_Compare = index_cmp,_Alloc = std::allocator<std::pair<const char* const,dict_index_t*> >,std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::iterator = std::_Rb_tree_iterator<std::pair<const char* const,dict_index_t*> >,std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::_Const_Base_ptr = const std::_Rb_tree_node_base*]" -> "std::_Select1st<_Pair>::operator()(const _Pair&) const [with _Pair = std::pair<const char* const,dict_index_t*>,typename _Pair::first_type = const char* const]"
"_Alloc>::_M_insert_(std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::_Const_Base_ptr,std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::_Const_Base_ptr,const _Val&) [with _Key = const char*,_Val = std::pair<const char* const,dict_index_t*>,_KeyOfValue = std::_Select1st<std::pair<const char* const,dict_index_t*> >,_Compare = index_cmp,_Alloc = std::allocator<std::pair<const char* const,dict_index_t*> >,std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::iterator = std::_Rb_tree_iterator<std::pair<const char* const,dict_index_t*> >,std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::_Const_Base_ptr = const std::_Rb_tree_node_base*]" -> "index_cmp::operator()(const char*,const char*) const"
"_Alloc>::_M_create_node(const value_type&) [with _Key = const char*,_Val = std::pair<const char* const,dict_index_t*>,_KeyOfValue = std::_Select1st<std::pair<const char* const,dict_index_t*> >,_Compare = index_cmp,_Alloc = std::allocator<std::pair<const char* const,dict_index_t*> >,std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::_Link_type = std::_Rb_tree_node<std::pair<const char* const,dict_index_t*> >*,std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::value_type = std::pair<const char* const,dict_index_t*>]" -> "std::__addressof(_Tp&) [with _Tp = std::pair<const char* const,dict_index_t*>]"
"_Alloc>::_M_create_node(const value_type&) [with _Key = const char*,_Val = std::pair<const char* const,dict_index_t*>,_KeyOfValue = std::_Select1st<std::pair<const char* const,dict_index_t*> >,_Compare = index_cmp,_Alloc = std::allocator<std::pair<const char* const,dict_index_t*> >,std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::_Link_type = std::_Rb_tree_node<std::pair<const char* const,dict_index_t*> >*,std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::value_type = std::pair<const char* const,dict_index_t*>]" -> "_Alloc>::_M_put_node(std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::_Link_type) [with _Key = const char*,_Val = std::pair<const char* const,dict_index_t*>,_KeyOfValue = std::_Select1st<std::pair<const char* const,dict_index_t*> >,_Compare = index_cmp,_Alloc = std::allocator<std::pair<const char* const,dict_index_t*> >,std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::_Link_type = std::_Rb_tree_node<std::pair<const char* const,dict_index_t*> >*]"
"_Alloc>::_M_create_node(const value_type&) [with _Key = const char*,_Val = std::pair<const char* const,dict_index_t*>,_KeyOfValue = std::_Select1st<std::pair<const char* const,dict_index_t*> >,_Compare = index_cmp,_Alloc = std::allocator<std::pair<const char* const,dict_index_t*> >,std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::_Link_type = std::_Rb_tree_node<std::pair<const char* const,dict_index_t*> >*,std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::value_type = std::pair<const char* const,dict_index_t*>]" -> "__cxa_rethrow()"
"_Alloc>::_M_create_node(const value_type&) [with _Key = const char*,_Val = std::pair<const char* const,dict_index_t*>,_KeyOfValue = std::_Select1st<std::pair<const char* const,dict_index_t*> >,_Compare = index_cmp,_Alloc = std::allocator<std::pair<const char* const,dict_index_t*> >,std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::_Link_type = std::_Rb_tree_node<std::pair<const char* const,dict_index_t*> >*,std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::value_type = std::pair<const char* const,dict_index_t*>]" -> "__cxa_begin_catch(void*)"
"_Alloc>::_M_create_node(const value_type&) [with _Key = const char*,_Val = std::pair<const char* const,dict_index_t*>,_KeyOfValue = std::_Select1st<std::pair<const char* const,dict_index_t*> >,_Compare = index_cmp,_Alloc = std::allocator<std::pair<const char* const,dict_index_t*> >,std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::_Link_type = std::_Rb_tree_node<std::pair<const char* const,dict_index_t*> >*,std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::value_type = std::pair<const char* const,dict_index_t*>]" -> "_Alloc>::_M_get_node() [with _Key = const char*,_Val = std::pair<const char* const,dict_index_t*>,_KeyOfValue = std::_Select1st<std::pair<const char* const,dict_index_t*> >,_Compare = index_cmp,_Alloc = std::allocator<std::pair<const char* const,dict_index_t*> >,std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::_Link_type = std::_Rb_tree_node<std::pair<const char* const,dict_index_t*> >*]"
"_Alloc>::_M_create_node(const value_type&) [with _Key = const char*,_Val = std::pair<const char* const,dict_index_t*>,_KeyOfValue = std::_Select1st<std::pair<const char* const,dict_index_t*> >,_Compare = index_cmp,_Alloc = std::allocator<std::pair<const char* const,dict_index_t*> >,std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::_Link_type = std::_Rb_tree_node<std::pair<const char* const,dict_index_t*> >*,std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::value_type = std::pair<const char* const,dict_index_t*>]" -> "__gnu_cxx::new_allocator<_Tp>::construct(__gnu_cxx::new_allocator<_Tp>::pointer,const _Tp&) [with _Tp = std::pair<const char* const,dict_index_t*>,__gnu_cxx::new_allocator<_Tp>::pointer = std::pair<const char* const,dict_index_t*>*]"
"_Alloc>::_M_create_node(const value_type&) [with _Key = const char*,_Val = std::pair<const char* const,dict_index_t*>,_KeyOfValue = std::_Select1st<std::pair<const char* const,dict_index_t*> >,_Compare = index_cmp,_Alloc = std::allocator<std::pair<const char* const,dict_index_t*> >,std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::_Link_type = std::_Rb_tree_node<std::pair<const char* const,dict_index_t*> >*,std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::value_type = std::pair<const char* const,dict_index_t*>]" -> "__builtin_eh_pointer(int)"
"_Alloc>::_M_create_node(const value_type&) [with _Key = const char*,_Val = std::pair<const char* const,dict_index_t*>,_KeyOfValue = std::_Select1st<std::pair<const char* const,dict_index_t*> >,_Compare = index_cmp,_Alloc = std::allocator<std::pair<const char* const,dict_index_t*> >,std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::_Link_type = std::_Rb_tree_node<std::pair<const char* const,dict_index_t*> >*,std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::value_type = std::pair<const char* const,dict_index_t*>]" -> "_Alloc>::get_allocator() const [with _Key = const char*,_Val = std::pair<const char* const,dict_index_t*>,_KeyOfValue = std::_Select1st<std::pair<const char* const,dict_index_t*> >,_Compare = index_cmp,_Alloc = std::allocator<std::pair<const char* const,dict_index_t*> >,std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::allocator_type = std::allocator<std::pair<const char* const,dict_index_t*> >]"
"_Alloc>::_M_create_node(const value_type&) [with _Key = const char*,_Val = std::pair<const char* const,dict_index_t*>,_KeyOfValue = std::_Select1st<std::pair<const char* const,dict_index_t*> >,_Compare = index_cmp,_Alloc = std::allocator<std::pair<const char* const,dict_index_t*> >,std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::_Link_type = std::_Rb_tree_node<std::pair<const char* const,dict_index_t*> >*,std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::value_type = std::pair<const char* const,dict_index_t*>]" -> "__cxa_end_catch()"
"_Alloc>::_M_put_node(std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::_Link_type) [with _Key = const char*,_Val = std::pair<const char* const,dict_index_t*>,_KeyOfValue = std::_Select1st<std::pair<const char* const,dict_index_t*> >,_Compare = index_cmp,_Alloc = std::allocator<std::pair<const char* const,dict_index_t*> >,std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::_Link_type = std::_Rb_tree_node<std::pair<const char* const,dict_index_t*> >*]" -> "__gnu_cxx::new_allocator<_Tp>::deallocate(__gnu_cxx::new_allocator<_Tp>::pointer,__gnu_cxx::new_allocator<_Tp>::size_type) [with _Tp = std::_Rb_tree_node<std::pair<const char* const,dict_index_t*> >,__gnu_cxx::new_allocator<_Tp>::pointer = std::_Rb_tree_node<std::pair<const char* const,dict_index_t*> >*,__gnu_cxx::new_allocator<_Tp>::size_type = long unsigned int]"
"_Alloc>::_M_get_node() [with _Key = const char*,_Val = std::pair<const char* const,dict_index_t*>,_KeyOfValue = std::_Select1st<std::pair<const char* const,dict_index_t*> >,_Compare = index_cmp,_Alloc = std::allocator<std::pair<const char* const,dict_index_t*> >,std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::_Link_type = std::_Rb_tree_node<std::pair<const char* const,dict_index_t*> >*]" -> "__gnu_cxx::new_allocator<_Tp>::allocate(__gnu_cxx::new_allocator<_Tp>::size_type,const void*) [with _Tp = std::_Rb_tree_node<std::pair<const char* const,dict_index_t*> >,__gnu_cxx::new_allocator<_Tp>::pointer = std::_Rb_tree_node<std::pair<const char* const,dict_index_t*> >*,__gnu_cxx::new_allocator<_Tp>::size_type = long unsigned int]"
"__gnu_cxx::new_allocator<_Tp>::allocate(__gnu_cxx::new_allocator<_Tp>::size_type,const void*) [with _Tp = std::_Rb_tree_node<std::pair<const char* const,dict_index_t*> >,__gnu_cxx::new_allocator<_Tp>::pointer = std::_Rb_tree_node<std::pair<const char* const,dict_index_t*> >*,__gnu_cxx::new_allocator<_Tp>::size_type = long unsigned int]" -> "std::__throw_bad_alloc()"
"__gnu_cxx::new_allocator<_Tp>::allocate(__gnu_cxx::new_allocator<_Tp>::size_type,const void*) [with _Tp = std::_Rb_tree_node<std::pair<const char* const,dict_index_t*> >,__gnu_cxx::new_allocator<_Tp>::pointer = std::_Rb_tree_node<std::pair<const char* const,dict_index_t*> >*,__gnu_cxx::new_allocator<_Tp>::size_type = long unsigned int]" -> "__gnu_cxx::new_allocator<_Tp>::max_size() const [with _Tp = std::_Rb_tree_node<std::pair<const char* const,dict_index_t*> >,__gnu_cxx::new_allocator<_Tp>::size_type = long unsigned int]"
"_Alloc>::get_allocator() const [with _Key = const char*,_Val = std::pair<const char* const,dict_index_t*>,_KeyOfValue = std::_Select1st<std::pair<const char* const,dict_index_t*> >,_Compare = index_cmp,_Alloc = std::allocator<std::pair<const char* const,dict_index_t*> >,std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::allocator_type = std::allocator<std::pair<const char* const,dict_index_t*> >]" -> "std::allocator<_Tp>::allocator(const std::allocator<_Tp1>&) [with _Tp1 = std::_Rb_tree_node<std::pair<const char* const,dict_index_t*> >,_Tp = std::pair<const char* const,dict_index_t*>]"
"_Alloc>::get_allocator() const [with _Key = const char*,_Val = std::pair<const char* const,dict_index_t*>,_KeyOfValue = std::_Select1st<std::pair<const char* const,dict_index_t*> >,_Compare = index_cmp,_Alloc = std::allocator<std::pair<const char* const,dict_index_t*> >,std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::allocator_type = std::allocator<std::pair<const char* const,dict_index_t*> >]" -> "_Alloc>::_M_get_Node_allocator() const [with _Key = const char*,_Val = std::pair<const char* const,dict_index_t*>,_KeyOfValue = std::_Select1st<std::pair<const char* const,dict_index_t*> >,_Compare = index_cmp,_Alloc = std::allocator<std::pair<const char* const,dict_index_t*> >,std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::_Node_allocator = std::allocator<std::_Rb_tree_node<std::pair<const char* const,dict_index_t*> > >]"
"std::allocator<_Tp>::allocator(const std::allocator<_Tp1>&) [with _Tp1 = std::_Rb_tree_node<std::pair<const char* const,dict_index_t*> >,_Tp = std::pair<const char* const,dict_index_t*>]" -> "__gnu_cxx::new_allocator<_Tp>::new_allocator() [with _Tp = std::pair<const char* const,dict_index_t*>]"
"_Alloc>::_S_key(std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::_Const_Link_type) [with _Key = const char*,_Val = std::pair<const char* const,dict_index_t*>,_KeyOfValue = std::_Select1st<std::pair<const char* const,dict_index_t*> >,_Compare = index_cmp,_Alloc = std::allocator<std::pair<const char* const,dict_index_t*> >,std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::_Const_Link_type = const std::_Rb_tree_node<std::pair<const char* const,dict_index_t*> >*]" -> "std::_Select1st<_Pair>::operator()(const _Pair&) const [with _Pair = std::pair<const char* const,dict_index_t*>,typename _Pair::first_type = const char* const]"
"_Alloc>::_S_key(std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::_Const_Link_type) [with _Key = const char*,_Val = std::pair<const char* const,dict_index_t*>,_KeyOfValue = std::_Select1st<std::pair<const char* const,dict_index_t*> >,_Compare = index_cmp,_Alloc = std::allocator<std::pair<const char* const,dict_index_t*> >,std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::_Const_Link_type = const std::_Rb_tree_node<std::pair<const char* const,dict_index_t*> >*]" -> "_Alloc>::_S_value(std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::_Const_Link_type) [with _Key = const char*,_Val = std::pair<const char* const,dict_index_t*>,_KeyOfValue = std::_Select1st<std::pair<const char* const,dict_index_t*> >,_Compare = index_cmp,_Alloc = std::allocator<std::pair<const char* const,dict_index_t*> >,std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::const_reference = const std::pair<const char* const,dict_index_t*>&,std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::value_type = std::pair<const char* const,dict_index_t*>,std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::_Const_Link_type = const std::_Rb_tree_node<std::pair<const char* const,dict_index_t*> >*]"
"std::_Rb_tree_const_iterator<_Tp>::_M_const_cast() const [with _Tp = std::pair<const char* const,dict_index_t*>,std::_Rb_tree_const_iterator<_Tp>::iterator = std::_Rb_tree_iterator<std::pair<const char* const,dict_index_t*> >]" -> "std::_Rb_tree_iterator<_Tp>::_Rb_tree_iterator(std::_Rb_tree_iterator<_Tp>::_Link_type) [with _Tp = std::pair<const char* const,dict_index_t*>,std::_Rb_tree_iterator<_Tp>::_Link_type = std::_Rb_tree_node<std::pair<const char* const,dict_index_t*> >*]"
"std::_Rb_tree_const_iterator<_Tp>::operator++() [with _Tp = std::pair<const char* const,dict_index_t*>,std::_Rb_tree_const_iterator<_Tp>::_Self = std::_Rb_tree_const_iterator<std::pair<const char* const,dict_index_t*> >]" -> "std::_Rb_tree_increment(const std::_Rb_tree_node_base*)"
"_Alloc>::key_comp() const [with _Key = const char*,_Tp = dict_index_t*,_Compare = index_cmp,_Alloc = std::allocator<std::pair<const char* const,dict_index_t*> >,std::map<_Key,_Tp,_Compare,_Alloc>::key_compare = index_cmp]" -> "_Alloc>::key_comp() const [with _Key = const char*,_Val = std::pair<const char* const,dict_index_t*>,_KeyOfValue = std::_Select1st<std::pair<const char* const,dict_index_t*> >,_Compare = index_cmp,_Alloc = std::allocator<std::pair<const char* const,dict_index_t*> >]"
"_Alloc>::lower_bound(const key_type&) [with _Key = const char*,_Tp = dict_index_t*,_Compare = index_cmp,_Alloc = std::allocator<std::pair<const char* const,dict_index_t*> >,std::map<_Key,_Tp,_Compare,_Alloc>::iterator = std::_Rb_tree_iterator<std::pair<const char* const,dict_index_t*> >,std::map<_Key,_Tp,_Compare,_Alloc>::key_type = const char*]" -> "_Alloc>::lower_bound(const key_type&) [with _Key = const char*,_Val = std::pair<const char* const,dict_index_t*>,_KeyOfValue = std::_Select1st<std::pair<const char* const,dict_index_t*> >,_Compare = index_cmp,_Alloc = std::allocator<std::pair<const char* const,dict_index_t*> >,std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::iterator = std::_Rb_tree_iterator<std::pair<const char* const,dict_index_t*> >,std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::key_type = const char*]"
"_Alloc>::lower_bound(const key_type&) [with _Key = const char*,_Val = std::pair<const char* const,dict_index_t*>,_KeyOfValue = std::_Select1st<std::pair<const char* const,dict_index_t*> >,_Compare = index_cmp,_Alloc = std::allocator<std::pair<const char* const,dict_index_t*> >,std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::iterator = std::_Rb_tree_iterator<std::pair<const char* const,dict_index_t*> >,std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::key_type = const char*]" -> "_Alloc>::_M_end() [with _Key = const char*,_Val = std::pair<const char* const,dict_index_t*>,_KeyOfValue = std::_Select1st<std::pair<const char* const,dict_index_t*> >,_Compare = index_cmp,_Alloc = std::allocator<std::pair<const char* const,dict_index_t*> >,std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::_Link_type = std::_Rb_tree_node<std::pair<const char* const,dict_index_t*> >*]"
"_Alloc>::lower_bound(const key_type&) [with _Key = const char*,_Val = std::pair<const char* const,dict_index_t*>,_KeyOfValue = std::_Select1st<std::pair<const char* const,dict_index_t*> >,_Compare = index_cmp,_Alloc = std::allocator<std::pair<const char* const,dict_index_t*> >,std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::iterator = std::_Rb_tree_iterator<std::pair<const char* const,dict_index_t*> >,std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::key_type = const char*]" -> "_Alloc>::_M_begin() [with _Key = const char*,_Val = std::pair<const char* const,dict_index_t*>,_KeyOfValue = std::_Select1st<std::pair<const char* const,dict_index_t*> >,_Compare = index_cmp,_Alloc = std::allocator<std::pair<const char* const,dict_index_t*> >,std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::_Link_type = std::_Rb_tree_node<std::pair<const char* const,dict_index_t*> >*]"
"_Alloc>::lower_bound(const key_type&) [with _Key = const char*,_Val = std::pair<const char* const,dict_index_t*>,_KeyOfValue = std::_Select1st<std::pair<const char* const,dict_index_t*> >,_Compare = index_cmp,_Alloc = std::allocator<std::pair<const char* const,dict_index_t*> >,std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::iterator = std::_Rb_tree_iterator<std::pair<const char* const,dict_index_t*> >,std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::key_type = const char*]" -> "_Alloc>::_M_lower_bound(std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::_Link_type,std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::_Link_type,const _Key&) [with _Key = const char*,_Val = std::pair<const char* const,dict_index_t*>,_KeyOfValue = std::_Select1st<std::pair<const char* const,dict_index_t*> >,_Compare = index_cmp,_Alloc = std::allocator<std::pair<const char* const,dict_index_t*> >,std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::iterator = std::_Rb_tree_iterator<std::pair<const char* const,dict_index_t*> >,std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::_Link_type = std::_Rb_tree_node<std::pair<const char* const,dict_index_t*> >*]"
"_Alloc>::_M_lower_bound(std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::_Link_type,std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::_Link_type,const _Key&) [with _Key = const char*,_Val = std::pair<const char* const,dict_index_t*>,_KeyOfValue = std::_Select1st<std::pair<const char* const,dict_index_t*> >,_Compare = index_cmp,_Alloc = std::allocator<std::pair<const char* const,dict_index_t*> >,std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::iterator = std::_Rb_tree_iterator<std::pair<const char* const,dict_index_t*> >,std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::_Link_type = std::_Rb_tree_node<std::pair<const char* const,dict_index_t*> >*]" -> "std::_Rb_tree_iterator<_Tp>::_Rb_tree_iterator(std::_Rb_tree_iterator<_Tp>::_Link_type) [with _Tp = std::pair<const char* const,dict_index_t*>,std::_Rb_tree_iterator<_Tp>::_Link_type = std::_Rb_tree_node<std::pair<const char* const,dict_index_t*> >*]"
"_Alloc>::_M_lower_bound(std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::_Link_type,std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::_Link_type,const _Key&) [with _Key = const char*,_Val = std::pair<const char* const,dict_index_t*>,_KeyOfValue = std::_Select1st<std::pair<const char* const,dict_index_t*> >,_Compare = index_cmp,_Alloc = std::allocator<std::pair<const char* const,dict_index_t*> >,std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::iterator = std::_Rb_tree_iterator<std::pair<const char* const,dict_index_t*> >,std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::_Link_type = std::_Rb_tree_node<std::pair<const char* const,dict_index_t*> >*]" -> "_Alloc>::_S_left(std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::_Base_ptr) [with _Key = const char*,_Val = std::pair<const char* const,dict_index_t*>,_KeyOfValue = std::_Select1st<std::pair<const char* const,dict_index_t*> >,_Compare = index_cmp,_Alloc = std::allocator<std::pair<const char* const,dict_index_t*> >,std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::_Link_type = std::_Rb_tree_node<std::pair<const char* const,dict_index_t*> >*,std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::_Base_ptr = std::_Rb_tree_node_base*]"
"_Alloc>::_M_lower_bound(std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::_Link_type,std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::_Link_type,const _Key&) [with _Key = const char*,_Val = std::pair<const char* const,dict_index_t*>,_KeyOfValue = std::_Select1st<std::pair<const char* const,dict_index_t*> >,_Compare = index_cmp,_Alloc = std::allocator<std::pair<const char* const,dict_index_t*> >,std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::iterator = std::_Rb_tree_iterator<std::pair<const char* const,dict_index_t*> >,std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::_Link_type = std::_Rb_tree_node<std::pair<const char* const,dict_index_t*> >*]" -> "_Alloc>::_S_right(std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::_Base_ptr) [with _Key = const char*,_Val = std::pair<const char* const,dict_index_t*>,_KeyOfValue = std::_Select1st<std::pair<const char* const,dict_index_t*> >,_Compare = index_cmp,_Alloc = std::allocator<std::pair<const char* const,dict_index_t*> >,std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::_Link_type = std::_Rb_tree_node<std::pair<const char* const,dict_index_t*> >*,std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::_Base_ptr = std::_Rb_tree_node_base*]"
"_Alloc>::_M_lower_bound(std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::_Link_type,std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::_Link_type,const _Key&) [with _Key = const char*,_Val = std::pair<const char* const,dict_index_t*>,_KeyOfValue = std::_Select1st<std::pair<const char* const,dict_index_t*> >,_Compare = index_cmp,_Alloc = std::allocator<std::pair<const char* const,dict_index_t*> >,std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::iterator = std::_Rb_tree_iterator<std::pair<const char* const,dict_index_t*> >,std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::_Link_type = std::_Rb_tree_node<std::pair<const char* const,dict_index_t*> >*]" -> "index_cmp::operator()(const char*,const char*) const"
"_Alloc>::_M_lower_bound(std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::_Link_type,std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::_Link_type,const _Key&) [with _Key = const char*,_Val = std::pair<const char* const,dict_index_t*>,_KeyOfValue = std::_Select1st<std::pair<const char* const,dict_index_t*> >,_Compare = index_cmp,_Alloc = std::allocator<std::pair<const char* const,dict_index_t*> >,std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::iterator = std::_Rb_tree_iterator<std::pair<const char* const,dict_index_t*> >,std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::_Link_type = std::_Rb_tree_node<std::pair<const char* const,dict_index_t*> >*]" -> "_Alloc>::_S_key(std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::_Const_Link_type) [with _Key = const char*,_Val = std::pair<const char* const,dict_index_t*>,_KeyOfValue = std::_Select1st<std::pair<const char* const,dict_index_t*> >,_Compare = index_cmp,_Alloc = std::allocator<std::pair<const char* const,dict_index_t*> >,std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::_Const_Link_type = const std::_Rb_tree_node<std::pair<const char* const,dict_index_t*> >*]"
"_Alloc>::end() [with _Key = const char*,_Tp = dict_index_t*,_Compare = index_cmp,_Alloc = std::allocator<std::pair<const char* const,dict_index_t*> >,std::map<_Key,_Tp,_Compare,_Alloc>::iterator = std::_Rb_tree_iterator<std::pair<const char* const,dict_index_t*> >]" -> "_Alloc>::end() [with _Key = const char*,_Val = std::pair<const char* const,dict_index_t*>,_KeyOfValue = std::_Select1st<std::pair<const char* const,dict_index_t*> >,_Compare = index_cmp,_Alloc = std::allocator<std::pair<const char* const,dict_index_t*> >,std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::iterator = std::_Rb_tree_iterator<std::pair<const char* const,dict_index_t*> >]"
"_Alloc>::end() [with _Key = const char*,_Val = std::pair<const char* const,dict_index_t*>,_KeyOfValue = std::_Select1st<std::pair<const char* const,dict_index_t*> >,_Compare = index_cmp,_Alloc = std::allocator<std::pair<const char* const,dict_index_t*> >,std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::iterator = std::_Rb_tree_iterator<std::pair<const char* const,dict_index_t*> >]" -> "std::_Rb_tree_iterator<_Tp>::_Rb_tree_iterator(std::_Rb_tree_iterator<_Tp>::_Link_type) [with _Tp = std::pair<const char* const,dict_index_t*>,std::_Rb_tree_iterator<_Tp>::_Link_type = std::_Rb_tree_node<std::pair<const char* const,dict_index_t*> >*]"
"dict_stats_snapshot_create(dict_table_t*)" -> "dict_stats_copy(dict_table_t*,const dict_table_t*)"
"dict_stats_snapshot_create(dict_table_t*)" -> "dict_table_stats_unlock(dict_table_t*,ulint)"
"dict_stats_snapshot_create(dict_table_t*)" -> "dict_table_stats_lock(dict_table_t*,ulint)"
"dict_stats_snapshot_create(dict_table_t*)" -> "dict_stats_table_clone_create(const dict_table_t*)"
"dict_stats_snapshot_create(dict_table_t*)" -> "pfs_mutex_exit_func(ib_mutex_t*)"
"dict_stats_snapshot_create(dict_table_t*)" -> "pfs_mutex_enter_func(ib_mutex_t*,const char*,ulint)"
"dict_stats_snapshot_create(dict_table_t*)" -> "dict_stats_assert_initialized(const dict_table_t*)"
"dict_stats_exec_sql(pars_info_t*,const char*,trx_t*)" -> "ut_dbg_assertion_failed(const char*,const char*,ulint)"
"dict_stats_exec_sql(pars_info_t*,const char*,trx_t*)" -> "dict_stats_persistent_storage_check(bool)"
"dict_stats_exec_sql(pars_info_t*,const char*,trx_t*)" -> "pars_info_free(pars_info_t*)"
"dict_stats_exec_sql(pars_info_t*,const char*,trx_t*)" -> "abort()"
"dict_stats_exec_sql(pars_info_t*,const char*,trx_t*)" -> "trx_commit_for_mysql(trx_t*)"
"dict_stats_exec_sql(pars_info_t*,const char*,trx_t*)" -> "trx_start_if_not_started_low(trx_t*)"
"dict_stats_exec_sql(pars_info_t*,const char*,trx_t*)" -> "trx_rollback_to_savepoint(trx_t*,trx_savept_t*)"
"dict_stats_exec_sql(pars_info_t*,const char*,trx_t*)" -> "trx_allocate_for_background()"
"dict_stats_exec_sql(pars_info_t*,const char*,trx_t*)" -> "__builtin_expect(long int,long int)"
"dict_stats_exec_sql(pars_info_t*,const char*,trx_t*)" -> "trx_free_for_background(trx_t*)"
"dict_stats_exec_sql(pars_info_t*,const char*,trx_t*)" -> "que_eval_sql(pars_info_t*,const char*,ulint,trx_t*)"
"pars_info_add_int4_literal(pars_info_t*,const char*,lint)" -> "mach_write_to_4(unsigned char*,ulint)"
"pars_info_add_int4_literal(pars_info_t*,const char*,lint)" -> "mem_heap_alloc(mem_heap_t*,ulint)"
"pars_info_add_int4_literal(pars_info_t*,const char*,lint)" -> "pars_info_add_literal(pars_info_t*,const char*,const void*,ulint,ulint,ulint)"
"dict_stats_snapshot_free(dict_table_t*)" -> "dict_stats_table_clone_free(dict_table_t*)"
"dict_stats_save_index_stat(dict_index_t*,lint,const char*,ib_uint64_t,ib_uint64_t*,const char*,trx_t*)" -> "dict_stats_exec_sql(pars_info_t*,const char*,trx_t*)"
"dict_stats_save_index_stat(dict_index_t*,lint,const char*,ib_uint64_t,ib_uint64_t*,const char*,trx_t*)" -> "pars_info_add_literal(pars_info_t*,const char*,const void*,ulint,ulint,ulint)"
"dict_stats_save_index_stat(dict_index_t*,lint,const char*,ib_uint64_t,ib_uint64_t*,const char*,trx_t*)" -> "dict_fs2utf8(const char*,char*,size_t,char*,size_t)"
"dict_stats_save_index_stat(dict_index_t*,lint,const char*,ib_uint64_t,ib_uint64_t*,const char*,trx_t*)" -> "pars_info_add_str_literal(pars_info_t*,const char*,const char*)"
"dict_stats_save_index_stat(dict_index_t*,lint,const char*,ib_uint64_t,ib_uint64_t*,const char*,trx_t*)" -> "ut_print_timestamp(FILE*)"
"dict_stats_save_index_stat(dict_index_t*,lint,const char*,ib_uint64_t,ib_uint64_t*,const char*,trx_t*)" -> "ut_strerr(dberr_t)"
"dict_stats_save_index_stat(dict_index_t*,lint,const char*,ib_uint64_t,ib_uint64_t*,const char*,trx_t*)" -> "ut_format_name(const char*,ulint,char*,ulint)"
"dict_stats_save_index_stat(dict_index_t*,lint,const char*,ib_uint64_t,ib_uint64_t*,const char*,trx_t*)" -> "fprintf(FILE*,const char*,...)"
"dict_stats_save_index_stat(dict_index_t*,lint,const char*,ib_uint64_t,ib_uint64_t*,const char*,trx_t*)" -> "pars_info_add_ull_literal(pars_info_t*,const char*,ib_uint64_t)"
"dict_stats_save_index_stat(dict_index_t*,lint,const char*,ib_uint64_t,ib_uint64_t*,const char*,trx_t*)" -> "pars_info_create()"
"dict_stats_save_index_stat(dict_index_t*,lint,const char*,ib_uint64_t,ib_uint64_t*,const char*,trx_t*)" -> "pars_info_add_int4_literal(pars_info_t*,const char*,lint)"
"pars_info_add_ull_literal(pars_info_t*,const char*,ib_uint64_t)" -> "pars_info_add_literal(pars_info_t*,const char*,const void*,ulint,ulint,ulint)"
"pars_info_add_ull_literal(pars_info_t*,const char*,ib_uint64_t)" -> "mach_write_to_8(void*,ib_uint64_t)"
"pars_info_add_ull_literal(pars_info_t*,const char*,ib_uint64_t)" -> "mem_heap_alloc(mem_heap_t*,ulint)"
"_Alloc>::map() [with _Key = const char*,_Tp = dict_index_t*,_Compare = index_cmp,_Alloc = std::allocator<std::pair<const char* const,dict_index_t*> >]" -> "_Alloc>::_Rb_tree() [with _Key = const char*,_Val = std::pair<const char* const,dict_index_t*>,_KeyOfValue = std::_Select1st<std::pair<const char* const,dict_index_t*> >,_Compare = index_cmp,_Alloc = std::allocator<std::pair<const char* const,dict_index_t*> >]"
"_Alloc>::_Rb_tree() [with _Key = const char*,_Val = std::pair<const char* const,dict_index_t*>,_KeyOfValue = std::_Select1st<std::pair<const char* const,dict_index_t*> >,_Compare = index_cmp,_Alloc = std::allocator<std::pair<const char* const,dict_index_t*> >]" -> "_Is_pod_comparator>::_Rb_tree_impl() [with _Key_compare = index_cmp,bool _Is_pod_comparator = true,_Key = const char*,_Val = std::pair<const char* const,dict_index_t*>,_KeyOfValue = std::_Select1st<std::pair<const char* const,dict_index_t*> >,_Compare = index_cmp,_Alloc = std::allocator<std::pair<const char* const,dict_index_t*> >]"
"_Is_pod_comparator>::_Rb_tree_impl() [with _Key_compare = index_cmp,bool _Is_pod_comparator = true,_Key = const char*,_Val = std::pair<const char* const,dict_index_t*>,_KeyOfValue = std::_Select1st<std::pair<const char* const,dict_index_t*> >,_Compare = index_cmp,_Alloc = std::allocator<std::pair<const char* const,dict_index_t*> >]" -> "std::allocator<_Tp>::allocator() [with _Tp = std::_Rb_tree_node<std::pair<const char* const,dict_index_t*> >]"
"_Is_pod_comparator>::_Rb_tree_impl() [with _Key_compare = index_cmp,bool _Is_pod_comparator = true,_Key = const char*,_Val = std::pair<const char* const,dict_index_t*>,_KeyOfValue = std::_Select1st<std::pair<const char* const,dict_index_t*> >,_Compare = index_cmp,_Alloc = std::allocator<std::pair<const char* const,dict_index_t*> >]" -> "_Is_pod_comparator>::_M_initialize() [with _Key_compare = index_cmp,bool _Is_pod_comparator = true,_Key = const char*,_Val = std::pair<const char* const,dict_index_t*>,_KeyOfValue = std::_Select1st<std::pair<const char* const,dict_index_t*> >,_Compare = index_cmp,_Alloc = std::allocator<std::pair<const char* const,dict_index_t*> >]"
"std::allocator<_Tp>::allocator() [with _Tp = std::_Rb_tree_node<std::pair<const char* const,dict_index_t*> >]" -> "__gnu_cxx::new_allocator<_Tp>::new_allocator() [with _Tp = std::_Rb_tree_node<std::pair<const char* const,dict_index_t*> >]"
"_Alloc>::begin() [with _Key = const char*,_Tp = dict_index_t*,_Compare = index_cmp,_Alloc = std::allocator<std::pair<const char* const,dict_index_t*> >,std::map<_Key,_Tp,_Compare,_Alloc>::iterator = std::_Rb_tree_iterator<std::pair<const char* const,dict_index_t*> >]" -> "_Alloc>::begin() [with _Key = const char*,_Val = std::pair<const char* const,dict_index_t*>,_KeyOfValue = std::_Select1st<std::pair<const char* const,dict_index_t*> >,_Compare = index_cmp,_Alloc = std::allocator<std::pair<const char* const,dict_index_t*> >,std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::iterator = std::_Rb_tree_iterator<std::pair<const char* const,dict_index_t*> >]"
"std::_Rb_tree_const_iterator<_Tp>::operator->() const [with _Tp = std::pair<const char* const,dict_index_t*>,std::_Rb_tree_const_iterator<_Tp>::pointer = const std::pair<const char* const,dict_index_t*>*]" -> "std::__addressof(_Tp&) [with _Tp = const std::pair<const char* const,dict_index_t*>]"
"dict_stats_recalc_pool_add(const dict_table_t*)" -> "pfs_mutex_exit_func(ib_mutex_t*)"
"dict_stats_recalc_pool_add(const dict_table_t*)" -> "os_event_set(os_event_t)"
"dict_stats_recalc_pool_add(const dict_table_t*)" -> "_Alloc>::begin() [with _Tp = long unsigned int,_Alloc = std::allocator<long unsigned int>,std::vector<_Tp,_Alloc>::iterator = __gnu_cxx::__normal_iterator<long unsigned int*,std::vector<long unsigned int> >,typename std::_Vector_base<_Tp,_Alloc>::_Tp_alloc_type::pointer = long unsigned int*]"
"dict_stats_recalc_pool_add(const dict_table_t*)" -> "__gnu_cxx::operator!=(const __gnu_cxx::__normal_iterator<_Iterator,_Container>&,const __gnu_cxx::__normal_iterator<_Iterator,_Container>&) [with _Iterator = long unsigned int*,_Container = std::vector<long unsigned int>]"
"dict_stats_recalc_pool_add(const dict_table_t*)" -> "pfs_mutex_enter_func(ib_mutex_t*,const char*,ulint)"
"dict_stats_recalc_pool_add(const dict_table_t*)" -> "_Alloc>::push_back(const value_type&) [with _Tp = long unsigned int,_Alloc = std::allocator<long unsigned int>,std::vector<_Tp,_Alloc>::value_type = long unsigned int]"
"dict_stats_recalc_pool_add(const dict_table_t*)" -> "_Container>::operator++() [with _Iterator = long unsigned int*,_Container = std::vector<long unsigned int>,__gnu_cxx::__normal_iterator<_Iterator,_Container> = __gnu_cxx::__normal_iterator<long unsigned int*,std::vector<long unsigned int> >]"
"dict_stats_recalc_pool_add(const dict_table_t*)" -> "_Alloc>::end() [with _Tp = long unsigned int,_Alloc = std::allocator<long unsigned int>,std::vector<_Tp,_Alloc>::iterator = __gnu_cxx::__normal_iterator<long unsigned int*,std::vector<long unsigned int> >,typename std::_Vector_base<_Tp,_Alloc>::_Tp_alloc_type::pointer = long unsigned int*]"
"dict_stats_recalc_pool_add(const dict_table_t*)" -> "_Container>::operator*() const [with _Iterator = long unsigned int*,_Container = std::vector<long unsigned int>,__gnu_cxx::__normal_iterator<_Iterator,_Container>::reference = long unsigned int&]"
"row_upd_step(que_thr_t*)" -> "abort()"
"row_upd_step(que_thr_t*)" -> "row_upd(upd_node_t*,que_thr_t*)"
"row_upd_step(que_thr_t*)" -> "que_node_get_parent(que_node_t*)"
"row_upd_step(que_thr_t*)" -> "trx_start_if_not_started_xa_low(trx_t*)"
"row_upd_step(que_thr_t*)" -> "thr_get_trx(que_thr_t*)"
"row_upd_step(que_thr_t*)" -> "lock_table(ulint,dict_table_t*,lock_mode,que_thr_t*)"
"row_upd_step(que_thr_t*)" -> "ut_dbg_assertion_failed(const char*,const char*,ulint)"
"row_upd(upd_node_t*,que_thr_t*)" -> "row_upd_sec_step(upd_node_t*,que_thr_t*)"
"row_upd(upd_node_t*,que_thr_t*)" -> "row_upd_clust_step(upd_node_t*,que_thr_t*)"
"row_upd(upd_node_t*,que_thr_t*)" -> "mem_heap_empty(mem_heap_t*)"
"row_upd(upd_node_t*,que_thr_t*)" -> "__builtin_expect(long int,long int)"
"row_upd(upd_node_t*,que_thr_t*)" -> "log_free_check()"
"row_upd(upd_node_t*,que_thr_t*)" -> "dict_index_is_corrupted(const dict_index_t*)"
"row_upd(upd_node_t*,que_thr_t*)" -> "row_upd_changes_some_index_ord_field_binary(const dict_table_t*,const upd_t*)"
"row_upd_sec_step(upd_node_t*,que_thr_t*)" -> "row_upd_changes_ord_field_binary_func(dict_index_t*,const upd_t*,const dtuple_t*,const row_ext_t*)"
"row_upd_sec_step(upd_node_t*,que_thr_t*)" -> "row_upd_sec_index_entry(upd_node_t*,que_thr_t*)"
"row_upd_sec_index_entry(upd_node_t*,que_thr_t*)" -> "dict_index_name_print(FILE*,const trx_t*,const dict_index_t*)"
"row_upd_sec_index_entry(upd_node_t*,que_thr_t*)" -> "row_log_online_op(dict_index_t*,const dtuple_t*,trx_id_t)"
"row_upd_sec_index_entry(upd_node_t*,que_thr_t*)" -> "dict_index_get_lock(dict_index_t*)"
"row_upd_sec_index_entry(upd_node_t*,que_thr_t*)" -> "rec_print(FILE*,const rec_t*,const dict_index_t*)"
"row_upd_sec_index_entry(upd_node_t*,que_thr_t*)" -> "btr_pcur_close(btr_pcur_t*)"
"row_upd_sec_index_entry(upd_node_t*,que_thr_t*)" -> "__builtin_fwrite(const void*,size_t,size_t,FILE*)"
"row_upd_sec_index_entry(upd_node_t*,que_thr_t*)" -> "trx_print(FILE*,const trx_t*,ulint)"
"row_upd_sec_index_entry(upd_node_t*,que_thr_t*)" -> "rec_get_offsets_func(const rec_t*,const dict_index_t*,ulint*,ulint,mem_heap_t**)"
"row_upd_sec_index_entry(upd_node_t*,que_thr_t*)" -> "abort()"
"row_upd_sec_index_entry(upd_node_t*,que_thr_t*)" -> "dict_index_get_online_status(const dict_index_t*)"
"row_upd_sec_index_entry(upd_node_t*,que_thr_t*)" -> "row_search_index_entry(dict_index_t*,const dtuple_t*,ulint,btr_pcur_t*,mtr_t*)"
"row_upd_sec_index_entry(upd_node_t*,que_thr_t*)" -> "__builtin_expect(long int,long int)"
"row_upd_sec_index_entry(upd_node_t*,que_thr_t*)" -> "row_upd_index_is_referenced(dict_index_t*,trx_t*)"
"row_upd_sec_index_entry(upd_node_t*,que_thr_t*)" -> "row_ins_sec_index_entry(dict_index_t*,dtuple_t*,que_thr_t*)"
"row_upd_sec_index_entry(upd_node_t*,que_thr_t*)" -> "dtuple_print(FILE*,const dtuple_t*)"
"row_upd_sec_index_entry(upd_node_t*,que_thr_t*)" -> "_IO_putc(int,_IO_FILE*)"
"row_upd_sec_index_entry(upd_node_t*,que_thr_t*)" -> "rec_get_deleted_flag(const rec_t*,ulint)"
"row_upd_sec_index_entry(upd_node_t*,que_thr_t*)" -> "mem_heap_create_func(ulint,ulint)"
"row_upd_sec_index_entry(upd_node_t*,que_thr_t*)" -> "mem_heap_empty(mem_heap_t*)"
"row_upd_sec_index_entry(upd_node_t*,que_thr_t*)" -> "mtr_start(mtr_t*)"
"row_upd_sec_index_entry(upd_node_t*,que_thr_t*)" -> "dict_table_is_comp(const dict_table_t*)"
"row_upd_sec_index_entry(upd_node_t*,que_thr_t*)" -> "thr_get_trx(que_thr_t*)"
"row_upd_sec_index_entry(upd_node_t*,que_thr_t*)" -> "ut_dbg_assertion_failed(const char*,const char*,ulint)"
"row_upd_sec_index_entry(upd_node_t*,que_thr_t*)" -> "log_free_check()"
"row_upd_sec_index_entry(upd_node_t*,que_thr_t*)" -> "row_upd_check_references_constraints(upd_node_t*,btr_pcur_t*,dict_table_t*,dict_index_t*,ulint*,que_thr_t*,mtr_t*)"
"row_upd_sec_index_entry(upd_node_t*,que_thr_t*)" -> "row_build_index_entry(const dtuple_t*,const row_ext_t*,dict_index_t*,mem_heap_t*)"
"row_upd_sec_index_entry(upd_node_t*,que_thr_t*)" -> "mtr_commit(mtr_t*)"
"row_upd_sec_index_entry(upd_node_t*,que_thr_t*)" -> "mem_heap_free_func(mem_heap_t*,const char*,ulint)"
"row_upd_sec_index_entry(upd_node_t*,que_thr_t*)" -> "btr_cur_del_mark_set_sec_rec(ulint,btr_cur_t*,ulint,que_thr_t*,mtr_t*)"
"row_upd_sec_index_entry(upd_node_t*,que_thr_t*)" -> "mtr_s_lock_func(rw_lock_t*,const char*,ulint,mtr_t*)"
"row_log_online_op(dict_index_t*,const dtuple_t*,trx_id_t)" -> "pfs_mutex_enter_func(ib_mutex_t*,const char*,ulint)"
"row_log_online_op(dict_index_t*,const dtuple_t*,trx_id_t)" -> "rec_convert_dtuple_to_temp(rec_t*,const dict_index_t*,const dfield_t*,ulint)"
"row_log_online_op(dict_index_t*,const dtuple_t*,trx_id_t)" -> "row_log_block_allocate(row_log_buf_t&)"
"row_log_online_op(dict_index_t*,const dtuple_t*,trx_id_t)" -> "dict_index_is_corrupted(const dict_index_t*)"
"row_log_online_op(dict_index_t*,const dtuple_t*,trx_id_t)" -> "trx_write_trx_id(unsigned char*,trx_id_t)"
"row_log_online_op(dict_index_t*,const dtuple_t*,trx_id_t)" -> "pfs_os_file_write_func(const char*,os_file_t,const void*,os_offset_t,ulint,const char*,ulint)"
"row_log_online_op(dict_index_t*,const dtuple_t*,trx_id_t)" -> "pfs_mutex_exit_func(ib_mutex_t*)"
"row_log_online_op(dict_index_t*,const dtuple_t*,trx_id_t)" -> "rec_get_converted_size_temp(const dict_index_t*,const dfield_t*,ulint,ulint*)"
"row_log_online_op(dict_index_t*,const dtuple_t*,trx_id_t)" -> "memcpy(void*,const void*,size_t)"
"rec_convert_dtuple_to_temp(rec_t*,const dict_index_t*,const dfield_t*,ulint)" -> "rec_convert_dtuple_to_rec_comp(rec_t*,const dict_index_t*,const dfield_t*,ulint,ulint,bool)"
"row_log_block_allocate(row_log_buf_t&)" -> "os_mem_alloc_large(ulint*)"
"os_mem_alloc_large(ulint*)" -> "fprintf(FILE*,const char*,...)"
"os_mem_alloc_large(ulint*)" -> "pfs_os_fast_mutex_unlock(os_fast_mutex_t*)"
"os_mem_alloc_large(ulint*)" -> "shmat(int,const void*,int)"
"os_mem_alloc_large(ulint*)" -> "__errno_location()"
"os_mem_alloc_large(ulint*)" -> "getpagesize()"
"os_mem_alloc_large(ulint*)" -> "pfs_os_fast_mutex_lock(os_fast_mutex_t*,const char*,ulint)"
"os_mem_alloc_large(ulint*)" -> "__builtin_expect(long int,long int)"
"os_mem_alloc_large(ulint*)" -> "shmget(key_t,size_t,int)"
"os_mem_alloc_large(ulint*)" -> "shmctl(int,int,shmid_ds*)"
"os_mem_alloc_large(ulint*)" -> "__builtin_fwrite(const void*,size_t,size_t,FILE*)"
"os_mem_alloc_large(ulint*)" -> "mmap(void*,size_t,int,int,int,__off64_t)"
"rec_get_converted_size_temp(const dict_index_t*,const dfield_t*,ulint,ulint*)" -> "rec_get_converted_size_comp_prefix_low(const dict_index_t*,const dfield_t*,ulint,ulint*,bool)"
"row_upd_index_is_referenced(dict_index_t*,trx_t*)" -> "_Alloc>::end() const [with _Key = dict_foreign_t*,_Compare = dict_foreign_compare,_Alloc = std::allocator<dict_foreign_t*>,std::set<_Key,_Compare,_Alloc>::iterator = std::_Rb_tree_const_iterator<dict_foreign_t*>]"
"row_upd_index_is_referenced(dict_index_t*,trx_t*)" -> "std::_Rb_tree_const_iterator<_Tp>::operator!=(const _Self&) const [with _Tp = dict_foreign_t*,std::_Rb_tree_const_iterator<_Tp>::_Self = std::_Rb_tree_const_iterator<dict_foreign_t*>]"
"row_upd_index_is_referenced(dict_index_t*,trx_t*)" -> "row_mysql_freeze_data_dictionary_func(trx_t*,const char*,ulint)"
"row_upd_index_is_referenced(dict_index_t*,trx_t*)" -> "_Alloc>::begin() const [with _Key = dict_foreign_t*,_Compare = dict_foreign_compare,_Alloc = std::allocator<dict_foreign_t*>,std::set<_Key,_Compare,_Alloc>::iterator = std::_Rb_tree_const_iterator<dict_foreign_t*>]"
"row_upd_index_is_referenced(dict_index_t*,trx_t*)" -> "row_mysql_unfreeze_data_dictionary(trx_t*)"
"row_upd_index_is_referenced(dict_index_t*,trx_t*)" -> "std::find_if(_IIter,_IIter,_Predicate) [with _IIter = std::_Rb_tree_const_iterator<dict_foreign_t*>,_Predicate = dict_foreign_with_index]"
"row_upd_index_is_referenced(dict_index_t*,trx_t*)" -> "dict_foreign_with_index::dict_foreign_with_index(const dict_index_t*)"
"row_upd_index_is_referenced(dict_index_t*,trx_t*)" -> "_Alloc>::empty() const [with _Key = dict_foreign_t*,_Compare = dict_foreign_compare,_Alloc = std::allocator<dict_foreign_t*>]"
"std::find_if(_IIter,_IIter,_Predicate) [with _IIter = std::_Rb_tree_const_iterator<dict_foreign_t*>,_Predicate = dict_foreign_with_index]" -> "std::__find_if(_InputIterator,_InputIterator,_Predicate,std::input_iterator_tag) [with _InputIterator = std::_Rb_tree_const_iterator<dict_foreign_t*>,_Predicate = dict_foreign_with_index]"
"std::find_if(_IIter,_IIter,_Predicate) [with _IIter = std::_Rb_tree_const_iterator<dict_foreign_t*>,_Predicate = dict_foreign_with_index]" -> "std::__iterator_category(const _Iter&) [with _Iter = std::_Rb_tree_const_iterator<dict_foreign_t*>,typename std::iterator_traits<_Iterator>::iterator_category = std::bidirectional_iterator_tag]"
"std::__find_if(_InputIterator,_InputIterator,_Predicate,std::input_iterator_tag) [with _InputIterator = std::_Rb_tree_const_iterator<dict_foreign_t*>,_Predicate = dict_foreign_with_index]" -> "dict_foreign_with_index::operator()(const dict_foreign_t*) const"
"std::__find_if(_InputIterator,_InputIterator,_Predicate,std::input_iterator_tag) [with _InputIterator = std::_Rb_tree_const_iterator<dict_foreign_t*>,_Predicate = dict_foreign_with_index]" -> "std::_Rb_tree_const_iterator<_Tp>::operator!=(const _Self&) const [with _Tp = dict_foreign_t*,std::_Rb_tree_const_iterator<_Tp>::_Self = std::_Rb_tree_const_iterator<dict_foreign_t*>]"
"std::__find_if(_InputIterator,_InputIterator,_Predicate,std::input_iterator_tag) [with _InputIterator = std::_Rb_tree_const_iterator<dict_foreign_t*>,_Predicate = dict_foreign_with_index]" -> "std::_Rb_tree_const_iterator<_Tp>::operator*() const [with _Tp = dict_foreign_t*,std::_Rb_tree_const_iterator<_Tp>::reference = dict_foreign_t* const&]"
"std::__find_if(_InputIterator,_InputIterator,_Predicate,std::input_iterator_tag) [with _InputIterator = std::_Rb_tree_const_iterator<dict_foreign_t*>,_Predicate = dict_foreign_with_index]" -> "std::_Rb_tree_const_iterator<_Tp>::operator++() [with _Tp = dict_foreign_t*,std::_Rb_tree_const_iterator<_Tp>::_Self = std::_Rb_tree_const_iterator<dict_foreign_t*>]"
"_Alloc>::empty() const [with _Key = dict_foreign_t*,_Compare = dict_foreign_compare,_Alloc = std::allocator<dict_foreign_t*>]" -> "_Alloc>::empty() const [with _Key = dict_foreign_t*,_Val = dict_foreign_t*,_KeyOfValue = std::_Identity<dict_foreign_t*>,_Compare = dict_foreign_compare,_Alloc = std::allocator<dict_foreign_t*>]"
"row_upd_check_references_constraints(upd_node_t*,btr_pcur_t*,dict_table_t*,dict_index_t*,ulint*,que_thr_t*,mtr_t*)" -> "_Alloc>::end() const [with _Key = dict_foreign_t*,_Compare = dict_foreign_compare,_Alloc = std::allocator<dict_foreign_t*>,std::set<_Key,_Compare,_Alloc>::iterator = std::_Rb_tree_const_iterator<dict_foreign_t*>]"
"row_upd_check_references_constraints(upd_node_t*,btr_pcur_t*,dict_table_t*,dict_index_t*,ulint*,que_thr_t*,mtr_t*)" -> "std::_Rb_tree_const_iterator<_Tp>::operator++() [with _Tp = dict_foreign_t*,std::_Rb_tree_const_iterator<_Tp>::_Self = std::_Rb_tree_const_iterator<dict_foreign_t*>]"
"row_upd_check_references_constraints(upd_node_t*,btr_pcur_t*,dict_table_t*,dict_index_t*,ulint*,que_thr_t*,mtr_t*)" -> "_Alloc>::empty() const [with _Key = dict_foreign_t*,_Compare = dict_foreign_compare,_Alloc = std::allocator<dict_foreign_t*>]"
"row_upd_check_references_constraints(upd_node_t*,btr_pcur_t*,dict_table_t*,dict_index_t*,ulint*,que_thr_t*,mtr_t*)" -> "mem_heap_create_func(ulint,ulint)"
"row_upd_check_references_constraints(upd_node_t*,btr_pcur_t*,dict_table_t*,dict_index_t*,ulint*,que_thr_t*,mtr_t*)" -> "row_rec_to_index_entry(const rec_t*,const dict_index_t*,const ulint*,ulint*,mem_heap_t*)"
"row_upd_check_references_constraints(upd_node_t*,btr_pcur_t*,dict_table_t*,dict_index_t*,ulint*,que_thr_t*,mtr_t*)" -> "row_ins_check_foreign_constraint(ulint,dict_foreign_t*,dict_table_t*,dtuple_t*,que_thr_t*)"
"row_upd_check_references_constraints(upd_node_t*,btr_pcur_t*,dict_table_t*,dict_index_t*,ulint*,que_thr_t*,mtr_t*)" -> "mtr_commit(mtr_t*)"
"row_upd_check_references_constraints(upd_node_t*,btr_pcur_t*,dict_table_t*,dict_index_t*,ulint*,que_thr_t*,mtr_t*)" -> "row_mysql_unfreeze_data_dictionary(trx_t*)"
"row_upd_check_references_constraints(upd_node_t*,btr_pcur_t*,dict_table_t*,dict_index_t*,ulint*,que_thr_t*,mtr_t*)" -> "row_upd_changes_first_fields_binary(dtuple_t*,dict_index_t*,const upd_t*,ulint)"
"row_upd_check_references_constraints(upd_node_t*,btr_pcur_t*,dict_table_t*,dict_index_t*,ulint*,que_thr_t*,mtr_t*)" -> "mtr_start(mtr_t*)"
"row_upd_check_references_constraints(upd_node_t*,btr_pcur_t*,dict_table_t*,dict_index_t*,ulint*,que_thr_t*,mtr_t*)" -> "thr_get_trx(que_thr_t*)"
"row_upd_check_references_constraints(upd_node_t*,btr_pcur_t*,dict_table_t*,dict_index_t*,ulint*,que_thr_t*,mtr_t*)" -> "std::_Rb_tree_const_iterator<_Tp>::operator!=(const _Self&) const [with _Tp = dict_foreign_t*,std::_Rb_tree_const_iterator<_Tp>::_Self = std::_Rb_tree_const_iterator<dict_foreign_t*>]"
"row_upd_check_references_constraints(upd_node_t*,btr_pcur_t*,dict_table_t*,dict_index_t*,ulint*,que_thr_t*,mtr_t*)" -> "mem_heap_free_func(mem_heap_t*,const char*,ulint)"
"row_upd_check_references_constraints(upd_node_t*,btr_pcur_t*,dict_table_t*,dict_index_t*,ulint*,que_thr_t*,mtr_t*)" -> "row_mysql_freeze_data_dictionary_func(trx_t*,const char*,ulint)"
"row_upd_check_references_constraints(upd_node_t*,btr_pcur_t*,dict_table_t*,dict_index_t*,ulint*,que_thr_t*,mtr_t*)" -> "dict_table_open_on_name(const char*,ulint,ulint,dict_err_ignore_t)"
"row_upd_check_references_constraints(upd_node_t*,btr_pcur_t*,dict_table_t*,dict_index_t*,ulint*,que_thr_t*,mtr_t*)" -> "_Alloc>::begin() const [with _Key = dict_foreign_t*,_Compare = dict_foreign_compare,_Alloc = std::allocator<dict_foreign_t*>,std::set<_Key,_Compare,_Alloc>::iterator = std::_Rb_tree_const_iterator<dict_foreign_t*>]"
"row_upd_check_references_constraints(upd_node_t*,btr_pcur_t*,dict_table_t*,dict_index_t*,ulint*,que_thr_t*,mtr_t*)" -> "dict_table_close(dict_table_t*,ulint,ulint)"
"row_upd_check_references_constraints(upd_node_t*,btr_pcur_t*,dict_table_t*,dict_index_t*,ulint*,que_thr_t*,mtr_t*)" -> "std::_Rb_tree_const_iterator<_Tp>::operator*() const [with _Tp = dict_foreign_t*,std::_Rb_tree_const_iterator<_Tp>::reference = dict_foreign_t* const&]"
"row_upd_check_references_constraints(upd_node_t*,btr_pcur_t*,dict_table_t*,dict_index_t*,ulint*,que_thr_t*,mtr_t*)" -> "__sync_add_and_fetch_8(volatile void*,long unsigned int)"
"row_upd_changes_first_fields_binary(dtuple_t*,dict_index_t*,const upd_t*,ulint)" -> "dict_col_get_clust_pos(const dict_col_t*,const dict_index_t*)"
"row_upd_changes_first_fields_binary(dtuple_t*,dict_index_t*,const upd_t*,ulint)" -> "upd_get_n_fields(const upd_t*)"
"row_upd_changes_first_fields_binary(dtuple_t*,dict_index_t*,const upd_t*,ulint)" -> "__builtin_expect(long int,long int)"
"row_upd_changes_first_fields_binary(dtuple_t*,dict_index_t*,const upd_t*,ulint)" -> "dfield_datas_are_binary_equal(const dfield_t*,const dfield_t*,ulint)"
"row_upd_changes_first_fields_binary(dtuple_t*,dict_index_t*,const upd_t*,ulint)" -> "abort()"
"row_upd_changes_first_fields_binary(dtuple_t*,dict_index_t*,const upd_t*,ulint)" -> "dict_field_get_col(const dict_field_t*)"
"row_upd_changes_first_fields_binary(dtuple_t*,dict_index_t*,const upd_t*,ulint)" -> "ut_dbg_assertion_failed(const char*,const char*,ulint)"
"btr_cur_del_mark_set_sec_rec(ulint,btr_cur_t*,ulint,que_thr_t*,mtr_t*)" -> "lock_sec_rec_modify_check_and_lock(ulint,buf_block_t*,const rec_t*,dict_index_t*,que_thr_t*,mtr_t*)"
"btr_cur_del_mark_set_sec_rec(ulint,btr_cur_t*,ulint,que_thr_t*,mtr_t*)" -> "btr_cur_del_mark_set_sec_rec_log(rec_t*,ulint,mtr_t*)"
"btr_cur_del_mark_set_sec_rec(ulint,btr_cur_t*,ulint,que_thr_t*,mtr_t*)" -> "btr_rec_set_deleted_flag(rec_t*,page_zip_des_t*,ulint)"
"lock_sec_rec_modify_check_and_lock(ulint,buf_block_t*,const rec_t*,dict_index_t*,que_thr_t*,mtr_t*)" -> "pfs_mutex_enter_func(ib_mutex_t*,const char*,ulint)"
"lock_sec_rec_modify_check_and_lock(ulint,buf_block_t*,const rec_t*,dict_index_t*,que_thr_t*,mtr_t*)" -> "lock_rec_lock(ulint,ulint,const buf_block_t*,ulint,dict_index_t*,que_thr_t*)"
"lock_sec_rec_modify_check_and_lock(ulint,buf_block_t*,const rec_t*,dict_index_t*,que_thr_t*,mtr_t*)" -> "pfs_mutex_exit_func(ib_mutex_t*)"
"lock_sec_rec_modify_check_and_lock(ulint,buf_block_t*,const rec_t*,dict_index_t*,que_thr_t*,mtr_t*)" -> "thr_get_trx(que_thr_t*)"
"lock_sec_rec_modify_check_and_lock(ulint,buf_block_t*,const rec_t*,dict_index_t*,que_thr_t*,mtr_t*)" -> "page_rec_get_heap_no(const rec_t*)"
"lock_sec_rec_modify_check_and_lock(ulint,buf_block_t*,const rec_t*,dict_index_t*,que_thr_t*,mtr_t*)" -> "page_update_max_trx_id(buf_block_t*,page_zip_des_t*,trx_id_t,mtr_t*)"
"row_upd_clust_step(upd_node_t*,que_thr_t*)" -> "row_upd_del_mark_clust_rec(upd_node_t*,dict_index_t*,ulint*,que_thr_t*,ulint,mtr_t*)"
"row_upd_clust_step(upd_node_t*,que_thr_t*)" -> "mem_heap_free_func(mem_heap_t*,const char*,ulint)"
"row_upd_clust_step(upd_node_t*,que_thr_t*)" -> "row_upd_clust_rec_by_insert(upd_node_t*,dict_index_t*,que_thr_t*,ulint,mtr_t*)"
"row_upd_clust_step(upd_node_t*,que_thr_t*)" -> "rec_get_offsets_func(const rec_t*,const dict_index_t*,ulint*,ulint,mem_heap_t**)"
"row_upd_clust_step(upd_node_t*,que_thr_t*)" -> "dict_index_get_lock(dict_index_t*)"
"row_upd_clust_step(upd_node_t*,que_thr_t*)" -> "lock_clust_rec_modify_check_and_lock(ulint,const buf_block_t*,const rec_t*,dict_index_t*,const ulint*,que_thr_t*)"
"row_upd_clust_step(upd_node_t*,que_thr_t*)" -> "dict_index_is_online_ddl(const dict_index_t*)"
"row_upd_clust_step(upd_node_t*,que_thr_t*)" -> "mtr_start(mtr_t*)"
"row_upd_clust_step(upd_node_t*,que_thr_t*)" -> "row_upd_index_is_referenced(dict_index_t*,trx_t*)"
"row_upd_clust_step(upd_node_t*,que_thr_t*)" -> "btr_pcur_restore_position_func(ulint,btr_pcur_t*,const char*,ulint,mtr_t*)"
"row_upd_clust_step(upd_node_t*,que_thr_t*)" -> "row_upd_store_row(upd_node_t*)"
"row_upd_clust_step(upd_node_t*,que_thr_t*)" -> "dict_drop_index_tree(rec_t*,mtr_t*)"
"row_upd_clust_step(upd_node_t*,que_thr_t*)" -> "mtr_commit(mtr_t*)"
"row_upd_clust_step(upd_node_t*,que_thr_t*)" -> "thr_get_trx(que_thr_t*)"
"row_upd_clust_step(upd_node_t*,que_thr_t*)" -> "abort()"
"row_upd_clust_step(upd_node_t*,que_thr_t*)" -> "ut_dbg_assertion_failed(const char*,const char*,ulint)"
"row_upd_clust_step(upd_node_t*,que_thr_t*)" -> "row_upd_changes_ord_field_binary_func(dict_index_t*,const upd_t*,const dtuple_t*,const row_ext_t*)"
"row_upd_clust_step(upd_node_t*,que_thr_t*)" -> "mtr_s_lock_func(rw_lock_t*,const char*,ulint,mtr_t*)"
"row_upd_clust_step(upd_node_t*,que_thr_t*)" -> "row_upd_eval_new_vals(upd_t*)"
"row_upd_clust_step(upd_node_t*,que_thr_t*)" -> "row_upd_clust_rec(upd_node_t*,dict_index_t*,ulint*,mem_heap_t**,que_thr_t*,mtr_t*)"
"row_upd_clust_step(upd_node_t*,que_thr_t*)" -> "__builtin_expect(long int,long int)"
"row_upd_clust_step(upd_node_t*,que_thr_t*)" -> "row_upd_copy_columns(rec_t*,const ulint*,sym_node_t*)"
"row_upd_clust_step(upd_node_t*,que_thr_t*)" -> "rec_offs_set_n_alloc(ulint*,ulint)"
"row_upd_del_mark_clust_rec(upd_node_t*,dict_index_t*,ulint*,que_thr_t*,ulint,mtr_t*)" -> "row_upd_check_references_constraints(upd_node_t*,btr_pcur_t*,dict_table_t*,dict_index_t*,ulint*,que_thr_t*,mtr_t*)"
"row_upd_del_mark_clust_rec(upd_node_t*,dict_index_t*,ulint*,que_thr_t*,ulint,mtr_t*)" -> "mtr_commit(mtr_t*)"
"row_upd_del_mark_clust_rec(upd_node_t*,dict_index_t*,ulint*,que_thr_t*,ulint,mtr_t*)" -> "row_upd_store_row(upd_node_t*)"
"row_upd_del_mark_clust_rec(upd_node_t*,dict_index_t*,ulint*,que_thr_t*,ulint,mtr_t*)" -> "btr_cur_del_mark_set_clust_rec(buf_block_t*,rec_t*,dict_index_t*,const ulint*,que_thr_t*,mtr_t*)"
"row_upd_store_row(upd_node_t*)" -> "rec_get_offsets_func(const rec_t*,const dict_index_t*,ulint*,ulint,mem_heap_t**)"
"row_upd_store_row(upd_node_t*)" -> "__builtin_expect(long int,long int)"
"row_upd_store_row(upd_node_t*)" -> "row_upd_replace(dtuple_t*,row_ext_t**,const dict_index_t*,const upd_t*,mem_heap_t*)"
"row_upd_store_row(upd_node_t*)" -> "rec_offs_set_n_alloc(ulint*,ulint)"
"row_upd_store_row(upd_node_t*)" -> "row_build(ulint,const dict_index_t*,const rec_t*,const ulint*,const dict_table_t*,const dtuple_t*,const ulint*,row_ext_t**,mem_heap_t*)"
"row_upd_store_row(upd_node_t*)" -> "mem_heap_empty(mem_heap_t*)"
"row_upd_store_row(upd_node_t*)" -> "mem_heap_free_func(mem_heap_t*,const char*,ulint)"
"row_upd_store_row(upd_node_t*)" -> "dtuple_copy(const dtuple_t*,mem_heap_t*)"
"row_upd_store_row(upd_node_t*)" -> "dict_table_get_format(const dict_table_t*)"
"row_upd_replace(dtuple_t*,row_ext_t**,const dict_index_t*,const upd_t*,mem_heap_t*)" -> "dict_col_get_clust_pos(const dict_col_t*,const dict_index_t*)"
"row_upd_replace(dtuple_t*,row_ext_t**,const dict_index_t*,const upd_t*,mem_heap_t*)" -> "upd_get_n_fields(const upd_t*)"
"row_upd_replace(dtuple_t*,row_ext_t**,const dict_index_t*,const upd_t*,mem_heap_t*)" -> "dtuple_set_info_bits(dtuple_t*,ulint)"
"row_upd_replace(dtuple_t*,row_ext_t**,const dict_index_t*,const upd_t*,mem_heap_t*)" -> "dtuple_get_n_fields(const dtuple_t*)"
"row_upd_replace(dtuple_t*,row_ext_t**,const dict_index_t*,const upd_t*,mem_heap_t*)" -> "__builtin_expect(long int,long int)"
"row_upd_replace(dtuple_t*,row_ext_t**,const dict_index_t*,const upd_t*,mem_heap_t*)" -> "dfield_copy_data(dfield_t*,const dfield_t*)"
"row_upd_replace(dtuple_t*,row_ext_t**,const dict_index_t*,const upd_t*,mem_heap_t*)" -> "dfield_is_ext(const dfield_t*)"
"row_upd_replace(dtuple_t*,row_ext_t**,const dict_index_t*,const upd_t*,mem_heap_t*)" -> "mem_heap_alloc(mem_heap_t*,ulint)"
"row_upd_replace(dtuple_t*,row_ext_t**,const dict_index_t*,const upd_t*,mem_heap_t*)" -> "row_ext_create(ulint,const ulint*,ulint,const dtuple_t*,mem_heap_t*)"
"btr_cur_del_mark_set_clust_rec(buf_block_t*,rec_t*,dict_index_t*,const ulint*,que_thr_t*,mtr_t*)" -> "btr_rec_set_deleted_flag(rec_t*,page_zip_des_t*,ulint)"
"btr_cur_del_mark_set_clust_rec(buf_block_t*,rec_t*,dict_index_t*,const ulint*,que_thr_t*,mtr_t*)" -> "lock_clust_rec_modify_check_and_lock(ulint,const buf_block_t*,const rec_t*,dict_index_t*,const ulint*,que_thr_t*)"
"btr_cur_del_mark_set_clust_rec(buf_block_t*,rec_t*,dict_index_t*,const ulint*,que_thr_t*,mtr_t*)" -> "dict_index_is_online_ddl(const dict_index_t*)"
"btr_cur_del_mark_set_clust_rec(buf_block_t*,rec_t*,dict_index_t*,const ulint*,que_thr_t*,mtr_t*)" -> "trx_undo_report_row_operation(ulint,ulint,que_thr_t*,dict_index_t*,const dtuple_t*,const upd_t*,ulint,const rec_t*,const ulint*,roll_ptr_t*)"
"btr_cur_del_mark_set_clust_rec(buf_block_t*,rec_t*,dict_index_t*,const ulint*,que_thr_t*,mtr_t*)" -> "row_log_table_delete(const rec_t*,dict_index_t*,const ulint*,const unsigned char*)"
"btr_cur_del_mark_set_clust_rec(buf_block_t*,rec_t*,dict_index_t*,const ulint*,que_thr_t*,mtr_t*)" -> "row_upd_rec_sys_fields(rec_t*,page_zip_des_t*,dict_index_t*,const ulint*,const trx_t*,roll_ptr_t)"
"btr_cur_del_mark_set_clust_rec(buf_block_t*,rec_t*,dict_index_t*,const ulint*,que_thr_t*,mtr_t*)" -> "btr_cur_del_mark_set_clust_rec_log(rec_t*,dict_index_t*,trx_id_t,roll_ptr_t,mtr_t*)"
"btr_cur_del_mark_set_clust_rec(buf_block_t*,rec_t*,dict_index_t*,const ulint*,que_thr_t*,mtr_t*)" -> "thr_get_trx(que_thr_t*)"
"lock_clust_rec_modify_check_and_lock(ulint,const buf_block_t*,const rec_t*,dict_index_t*,const ulint*,que_thr_t*)" -> "lock_rec_lock(ulint,ulint,const buf_block_t*,ulint,dict_index_t*,que_thr_t*)"
"lock_clust_rec_modify_check_and_lock(ulint,const buf_block_t*,const rec_t*,dict_index_t*,const ulint*,que_thr_t*)" -> "lock_rec_convert_impl_to_expl(const buf_block_t*,const rec_t*,dict_index_t*,const ulint*)"
"lock_clust_rec_modify_check_and_lock(ulint,const buf_block_t*,const rec_t*,dict_index_t*,const ulint*,que_thr_t*)" -> "pfs_mutex_exit_func(ib_mutex_t*)"
"lock_clust_rec_modify_check_and_lock(ulint,const buf_block_t*,const rec_t*,dict_index_t*,const ulint*,que_thr_t*)" -> "rec_get_heap_no_old(const rec_t*)"
"lock_clust_rec_modify_check_and_lock(ulint,const buf_block_t*,const rec_t*,dict_index_t*,const ulint*,que_thr_t*)" -> "rec_offs_comp(const ulint*)"
"lock_clust_rec_modify_check_and_lock(ulint,const buf_block_t*,const rec_t*,dict_index_t*,const ulint*,que_thr_t*)" -> "pfs_mutex_enter_func(ib_mutex_t*,const char*,ulint)"
"lock_clust_rec_modify_check_and_lock(ulint,const buf_block_t*,const rec_t*,dict_index_t*,const ulint*,que_thr_t*)" -> "rec_get_heap_no_new(const rec_t*)"
"lock_clust_rec_modify_check_and_lock(ulint,const buf_block_t*,const rec_t*,dict_index_t*,const ulint*,que_thr_t*)" -> "__builtin_expect(long int,long int)"
"row_log_table_delete(const rec_t*,dict_index_t*,const ulint*,const unsigned char*)" -> "mach_write_to_2(unsigned char*,ulint)"
"row_log_table_delete(const rec_t*,dict_index_t*,const ulint*,const unsigned char*)" -> "rec_convert_dtuple_to_temp(rec_t*,const dict_index_t*,const dfield_t*,ulint)"
"row_log_table_delete(const rec_t*,dict_index_t*,const ulint*,const unsigned char*)" -> "dtuple_set_n_fields_cmp(dtuple_t*,ulint)"
"row_log_table_delete(const rec_t*,dict_index_t*,const ulint*,const unsigned char*)" -> "dtuple_create(mem_heap_t*,ulint)"
"row_log_table_delete(const rec_t*,dict_index_t*,const ulint*,const unsigned char*)" -> "row_log_table_open(row_log_t*,ulint,ulint*)"
"row_log_table_delete(const rec_t*,dict_index_t*,const ulint*,const unsigned char*)" -> "memcpy(void*,const void*,size_t)"
"row_log_table_delete(const rec_t*,dict_index_t*,const ulint*,const unsigned char*)" -> "rec_get_converted_size_temp(const dict_index_t*,const dfield_t*,ulint,ulint*)"
"row_log_table_delete(const rec_t*,dict_index_t*,const ulint*,const unsigned char*)" -> "rec_offs_any_extern(const ulint*)"
"row_log_table_delete(const rec_t*,dict_index_t*,const ulint*,const unsigned char*)" -> "row_log_table_close_func(row_log_t*,ulint,ulint)"
"row_log_table_delete(const rec_t*,dict_index_t*,const ulint*,const unsigned char*)" -> "dfield_set_data(dfield_t*,const void*,ulint)"
"row_log_table_delete(const rec_t*,dict_index_t*,const ulint*,const unsigned char*)" -> "dict_index_is_online_ddl(const dict_index_t*)"
"row_log_table_delete(const rec_t*,dict_index_t*,const ulint*,const unsigned char*)" -> "dtuple_get_n_fields(const dtuple_t*)"
"row_log_table_delete(const rec_t*,dict_index_t*,const ulint*,const unsigned char*)" -> "dict_index_is_corrupted(const dict_index_t*)"
"row_log_table_delete(const rec_t*,dict_index_t*,const ulint*,const unsigned char*)" -> "row_build(ulint,const dict_index_t*,const rec_t*,const ulint*,const dict_table_t*,const dtuple_t*,const ulint*,row_ext_t**,mem_heap_t*)"
"row_log_table_delete(const rec_t*,dict_index_t*,const ulint*,const unsigned char*)" -> "dict_table_get_format(const dict_table_t*)"
"row_log_table_delete(const rec_t*,dict_index_t*,const ulint*,const unsigned char*)" -> "row_log_table_get_pk(const rec_t*,dict_index_t*,const ulint*,unsigned char*,mem_heap_t**)"
"row_log_table_delete(const rec_t*,dict_index_t*,const ulint*,const unsigned char*)" -> "mem_heap_create_func(ulint,ulint)"
"row_log_table_delete(const rec_t*,dict_index_t*,const ulint*,const unsigned char*)" -> "mem_heap_free_func(mem_heap_t*,const char*,ulint)"
"row_log_table_delete(const rec_t*,dict_index_t*,const ulint*,const unsigned char*)" -> "rec_get_nth_field_offs(const ulint*,ulint,ulint*)"
"row_log_table_delete(const rec_t*,dict_index_t*,const ulint*,const unsigned char*)" -> "dict_index_copy_types(dtuple_t*,const dict_index_t*,ulint)"
"row_log_table_open(row_log_t*,ulint,ulint*)" -> "pfs_mutex_enter_func(ib_mutex_t*,const char*,ulint)"
"row_log_table_open(row_log_t*,ulint,ulint*)" -> "pfs_mutex_exit_func(ib_mutex_t*)"
"row_log_table_open(row_log_t*,ulint,ulint*)" -> "row_log_block_allocate(row_log_buf_t&)"
"row_log_table_close_func(row_log_t*,ulint,ulint)" -> "memcpy(void*,const void*,size_t)"
"row_log_table_close_func(row_log_t*,ulint,ulint)" -> "pfs_os_file_write_func(const char*,os_file_t,const void*,os_offset_t,ulint,const char*,ulint)"
"row_log_table_close_func(row_log_t*,ulint,ulint)" -> "pfs_mutex_exit_func(ib_mutex_t*)"
"row_log_table_get_pk(const rec_t*,dict_index_t*,const ulint*,unsigned char*,mem_heap_t**)" -> "dfield_get_len(const dfield_t*)"
"row_log_table_get_pk(const rec_t*,dict_index_t*,const ulint*,unsigned char*,mem_heap_t**)" -> "dfield_set_data(dfield_t*,const void*,ulint)"
"row_log_table_get_pk(const rec_t*,dict_index_t*,const ulint*,unsigned char*,mem_heap_t**)" -> "memcpy(void*,const void*,size_t)"
"row_log_table_get_pk(const rec_t*,dict_index_t*,const ulint*,unsigned char*,mem_heap_t**)" -> "dtype_get_at_most_n_mbchars(ulint,ulint,ulint,ulint,const char*)"
"row_log_table_get_pk(const rec_t*,dict_index_t*,const ulint*,unsigned char*,mem_heap_t**)" -> "pfs_mutex_exit_func(ib_mutex_t*)"
"row_log_table_get_pk(const rec_t*,dict_index_t*,const ulint*,unsigned char*,mem_heap_t**)" -> "row_log_table_get_pk_col(const dict_col_t*,const dict_field_t*,dfield_t*,mem_heap_t*,const rec_t*,const ulint*,ulint,ulint,ulint)"
"row_log_table_get_pk(const rec_t*,dict_index_t*,const ulint*,unsigned char*,mem_heap_t**)" -> "dtuple_set_n_fields_cmp(dtuple_t*,ulint)"
"row_log_table_get_pk(const rec_t*,dict_index_t*,const ulint*,unsigned char*,mem_heap_t**)" -> "rec_get_nth_field_offs(const ulint*,ulint,ulint*)"
"row_log_table_get_pk(const rec_t*,dict_index_t*,const ulint*,unsigned char*,mem_heap_t**)" -> "dict_table_zip_size(const dict_table_t*)"
"row_log_table_get_pk(const rec_t*,dict_index_t*,const ulint*,unsigned char*,mem_heap_t**)" -> "dict_index_copy_types(dtuple_t*,const dict_index_t*,ulint)"
"row_log_table_get_pk(const rec_t*,dict_index_t*,const ulint*,unsigned char*,mem_heap_t**)" -> "rec_get_offsets_func(const rec_t*,const dict_index_t*,ulint*,ulint,mem_heap_t**)"
"row_log_table_get_pk(const rec_t*,dict_index_t*,const ulint*,unsigned char*,mem_heap_t**)" -> "dict_col_get_min_size(const dict_col_t*)"
"row_log_table_get_pk(const rec_t*,dict_index_t*,const ulint*,unsigned char*,mem_heap_t**)" -> "dict_index_get_sys_col_pos(const dict_index_t*,ulint)"
"row_log_table_get_pk(const rec_t*,dict_index_t*,const ulint*,unsigned char*,mem_heap_t**)" -> "dict_index_get_nth_col(const dict_index_t*,ulint)"
"row_log_table_get_pk(const rec_t*,dict_index_t*,const ulint*,unsigned char*,mem_heap_t**)" -> "row_log_table_get_pk_old_col(const dict_table_t*,const ulint*,ulint)"
"row_log_table_get_pk(const rec_t*,dict_index_t*,const ulint*,unsigned char*,mem_heap_t**)" -> "row_get_trx_id_offset(const dict_index_t*,const ulint*)"
"row_log_table_get_pk(const rec_t*,dict_index_t*,const ulint*,unsigned char*,mem_heap_t**)" -> "dict_field_get_col(const dict_field_t*)"
"row_log_table_get_pk(const rec_t*,dict_index_t*,const ulint*,unsigned char*,mem_heap_t**)" -> "pfs_mutex_enter_func(ib_mutex_t*,const char*,ulint)"
"row_log_table_get_pk(const rec_t*,dict_index_t*,const ulint*,unsigned char*,mem_heap_t**)" -> "dict_table_get_format(const dict_table_t*)"
"row_log_table_get_pk(const rec_t*,dict_index_t*,const ulint*,unsigned char*,mem_heap_t**)" -> "dfield_copy(dfield_t*,const dfield_t*)"
"row_log_table_get_pk(const rec_t*,dict_index_t*,const ulint*,unsigned char*,mem_heap_t**)" -> "dict_index_get_n_unique(const dict_index_t*)"
"row_log_table_get_pk(const rec_t*,dict_index_t*,const ulint*,unsigned char*,mem_heap_t**)" -> "dfield_set_len(dfield_t*,ulint)"
"row_log_table_get_pk(const rec_t*,dict_index_t*,const ulint*,unsigned char*,mem_heap_t**)" -> "mem_heap_create_func(ulint,ulint)"
"row_log_table_get_pk(const rec_t*,dict_index_t*,const ulint*,unsigned char*,mem_heap_t**)" -> "mem_heap_dup(mem_heap_t*,const void*,ulint)"
"row_log_table_get_pk(const rec_t*,dict_index_t*,const ulint*,unsigned char*,mem_heap_t**)" -> "dict_col_get_clust_pos(const dict_col_t*,const dict_index_t*)"
"row_log_table_get_pk(const rec_t*,dict_index_t*,const ulint*,unsigned char*,mem_heap_t**)" -> "dtuple_create(mem_heap_t*,ulint)"
"row_log_table_get_pk_col(const dict_col_t*,const dict_field_t*,dfield_t*,mem_heap_t*,const rec_t*,const ulint*,ulint,ulint,ulint)" -> "mem_heap_alloc(mem_heap_t*,ulint)"
"row_log_table_get_pk_col(const dict_col_t*,const dict_field_t*,dfield_t*,mem_heap_t*,const rec_t*,const ulint*,ulint,ulint,ulint)" -> "rec_offs_nth_extern(const ulint*,ulint)"
"row_log_table_get_pk_col(const dict_col_t*,const dict_field_t*,dfield_t*,mem_heap_t*,const rec_t*,const ulint*,ulint,ulint,ulint)" -> "rec_get_nth_field_offs(const ulint*,ulint,ulint*)"
"row_log_table_get_pk_col(const dict_col_t*,const dict_field_t*,dfield_t*,mem_heap_t*,const rec_t*,const ulint*,ulint,ulint,ulint)" -> "mem_heap_dup(mem_heap_t*,const void*,ulint)"
"row_log_table_get_pk_col(const dict_col_t*,const dict_field_t*,dfield_t*,mem_heap_t*,const rec_t*,const ulint*,ulint,ulint,ulint)" -> "btr_copy_externally_stored_field_prefix(unsigned char*,ulint,ulint,const unsigned char*,ulint)"
"row_log_table_get_pk_col(const dict_col_t*,const dict_field_t*,dfield_t*,mem_heap_t*,const rec_t*,const ulint*,ulint,ulint,ulint)" -> "dfield_set_data(dfield_t*,const void*,ulint)"
"row_upd_rec_sys_fields(rec_t*,page_zip_des_t*,dict_index_t*,const ulint*,const trx_t*,roll_ptr_t)" -> "trx_write_roll_ptr(unsigned char*,roll_ptr_t)"
"row_upd_rec_sys_fields(rec_t*,page_zip_des_t*,dict_index_t*,const ulint*,const trx_t*,roll_ptr_t)" -> "trx_write_trx_id(unsigned char*,trx_id_t)"
"row_upd_rec_sys_fields(rec_t*,page_zip_des_t*,dict_index_t*,const ulint*,const trx_t*,roll_ptr_t)" -> "row_get_trx_id_offset(const dict_index_t*,const ulint*)"
"row_upd_rec_sys_fields(rec_t*,page_zip_des_t*,dict_index_t*,const ulint*,const trx_t*,roll_ptr_t)" -> "dict_index_get_sys_col_pos(const dict_index_t*,ulint)"
"row_upd_rec_sys_fields(rec_t*,page_zip_des_t*,dict_index_t*,const ulint*,const trx_t*,roll_ptr_t)" -> "page_zip_write_trx_id_and_roll_ptr(page_zip_des_t*,unsigned char*,const ulint*,ulint,trx_id_t,roll_ptr_t)"
"page_zip_write_trx_id_and_roll_ptr(page_zip_des_t*,unsigned char*,const ulint*,ulint,trx_id_t,roll_ptr_t)" -> "page_zip_dir_elems(const page_zip_des_t*)"
"page_zip_write_trx_id_and_roll_ptr(page_zip_des_t*,unsigned char*,const ulint*,ulint,trx_id_t,roll_ptr_t)" -> "rec_get_nth_field_offs(const ulint*,ulint,ulint*)"
"page_zip_write_trx_id_and_roll_ptr(page_zip_des_t*,unsigned char*,const ulint*,ulint,trx_id_t,roll_ptr_t)" -> "memcpy(void*,const void*,size_t)"
"page_zip_write_trx_id_and_roll_ptr(page_zip_des_t*,unsigned char*,const ulint*,ulint,trx_id_t,roll_ptr_t)" -> "mach_write_to_7(unsigned char*,ib_uint64_t)"
"page_zip_write_trx_id_and_roll_ptr(page_zip_des_t*,unsigned char*,const ulint*,ulint,trx_id_t,roll_ptr_t)" -> "mach_write_to_6(unsigned char*,ib_uint64_t)"
"page_zip_write_trx_id_and_roll_ptr(page_zip_des_t*,unsigned char*,const ulint*,ulint,trx_id_t,roll_ptr_t)" -> "page_zip_dir_start_offs(const page_zip_des_t*,ulint)"
"page_zip_write_trx_id_and_roll_ptr(page_zip_des_t*,unsigned char*,const ulint*,ulint,trx_id_t,roll_ptr_t)" -> "rec_get_heap_no_new(const rec_t*)"
"btr_cur_del_mark_set_clust_rec_log(rec_t*,dict_index_t*,trx_id_t,roll_ptr_t,mtr_t*)" -> "page_offset(const void*)"
"btr_cur_del_mark_set_clust_rec_log(rec_t*,dict_index_t*,trx_id_t,roll_ptr_t,mtr_t*)" -> "page_rec_is_comp(const rec_t*)"
"btr_cur_del_mark_set_clust_rec_log(rec_t*,dict_index_t*,trx_id_t,roll_ptr_t,mtr_t*)" -> "row_upd_write_sys_vals_to_log(dict_index_t*,trx_id_t,roll_ptr_t,unsigned char*,mtr_t*)"
"btr_cur_del_mark_set_clust_rec_log(rec_t*,dict_index_t*,trx_id_t,roll_ptr_t,mtr_t*)" -> "mach_write_to_2(unsigned char*,ulint)"
"btr_cur_del_mark_set_clust_rec_log(rec_t*,dict_index_t*,trx_id_t,roll_ptr_t,mtr_t*)" -> "mlog_open_and_write_index(mtr_t*,const unsigned char*,const dict_index_t*,unsigned char,ulint)"
"btr_cur_del_mark_set_clust_rec_log(rec_t*,dict_index_t*,trx_id_t,roll_ptr_t,mtr_t*)" -> "mlog_close(mtr_t*,unsigned char*)"
"row_upd_clust_rec_by_insert(upd_node_t*,dict_index_t*,que_thr_t*,ulint,mtr_t*)" -> "rec_offs_any_extern(const ulint*)"
"row_upd_clust_rec_by_insert(upd_node_t*,dict_index_t*,que_thr_t*,ulint,mtr_t*)" -> "mtr_commit(mtr_t*)"
"row_upd_clust_rec_by_insert(upd_node_t*,dict_index_t*,que_thr_t*,ulint,mtr_t*)" -> "thr_get_trx(que_thr_t*)"
"row_upd_clust_rec_by_insert(upd_node_t*,dict_index_t*,que_thr_t*,ulint,mtr_t*)" -> "row_upd_index_entry_sys_field(dtuple_t*,dict_index_t*,ulint,ib_uint64_t)"
"row_upd_clust_rec_by_insert(upd_node_t*,dict_index_t*,que_thr_t*,ulint,mtr_t*)" -> "rec_get_offsets_func(const rec_t*,const dict_index_t*,ulint*,ulint,mem_heap_t**)"
"row_upd_clust_rec_by_insert(upd_node_t*,dict_index_t*,que_thr_t*,ulint,mtr_t*)" -> "row_build_index_entry(const dtuple_t*,const row_ext_t*,dict_index_t*,mem_heap_t*)"
"row_upd_clust_rec_by_insert(upd_node_t*,dict_index_t*,que_thr_t*,ulint,mtr_t*)" -> "row_upd_check_references_constraints(upd_node_t*,btr_pcur_t*,dict_table_t*,dict_index_t*,ulint*,que_thr_t*,mtr_t*)"
"row_upd_clust_rec_by_insert(upd_node_t*,dict_index_t*,que_thr_t*,ulint,mtr_t*)" -> "mem_heap_create_func(ulint,ulint)"
"row_upd_clust_rec_by_insert(upd_node_t*,dict_index_t*,que_thr_t*,ulint,mtr_t*)" -> "__builtin_expect(long int,long int)"
"row_upd_clust_rec_by_insert(upd_node_t*,dict_index_t*,que_thr_t*,ulint,mtr_t*)" -> "btr_cur_get_page_zip(btr_cur_t*)"
"row_upd_clust_rec_by_insert(upd_node_t*,dict_index_t*,que_thr_t*,ulint,mtr_t*)" -> "btr_cur_disown_inherited_fields(page_zip_des_t*,rec_t*,dict_index_t*,const ulint*,const upd_t*,mtr_t*)"
"row_upd_clust_rec_by_insert(upd_node_t*,dict_index_t*,que_thr_t*,ulint,mtr_t*)" -> "btr_cur_del_mark_set_clust_rec(buf_block_t*,rec_t*,dict_index_t*,const ulint*,que_thr_t*,mtr_t*)"
"row_upd_clust_rec_by_insert(upd_node_t*,dict_index_t*,que_thr_t*,ulint,mtr_t*)" -> "row_ins_clust_index_entry(dict_index_t*,dtuple_t*,que_thr_t*,ulint)"
"row_upd_clust_rec_by_insert(upd_node_t*,dict_index_t*,que_thr_t*,ulint,mtr_t*)" -> "mem_heap_free_func(mem_heap_t*,const char*,ulint)"
"row_upd_clust_rec_by_insert(upd_node_t*,dict_index_t*,que_thr_t*,ulint,mtr_t*)" -> "abort()"
"row_upd_clust_rec_by_insert(upd_node_t*,dict_index_t*,que_thr_t*,ulint,mtr_t*)" -> "row_upd_clust_rec_by_insert_inherit_func(dtuple_t*,const upd_t*)"
"row_upd_clust_rec_by_insert(upd_node_t*,dict_index_t*,que_thr_t*,ulint,mtr_t*)" -> "ut_dbg_assertion_failed(const char*,const char*,ulint)"
"btr_cur_disown_inherited_fields(page_zip_des_t*,rec_t*,dict_index_t*,const ulint*,const upd_t*,mtr_t*)" -> "rec_offs_n_fields(const ulint*)"
"btr_cur_disown_inherited_fields(page_zip_des_t*,rec_t*,dict_index_t*,const ulint*,const upd_t*,mtr_t*)" -> "btr_cur_set_ownership_of_extern_field(page_zip_des_t*,rec_t*,dict_index_t*,const ulint*,ulint,ulint,mtr_t*)"
"btr_cur_disown_inherited_fields(page_zip_des_t*,rec_t*,dict_index_t*,const ulint*,const upd_t*,mtr_t*)" -> "upd_get_field_by_field_no(const upd_t*,ulint)"
"btr_cur_disown_inherited_fields(page_zip_des_t*,rec_t*,dict_index_t*,const ulint*,const upd_t*,mtr_t*)" -> "rec_offs_nth_extern(const ulint*,ulint)"
"btr_cur_set_ownership_of_extern_field(page_zip_des_t*,rec_t*,dict_index_t*,const ulint*,ulint,ulint,mtr_t*)" -> "mach_read_from_1(const unsigned char*)"
"btr_cur_set_ownership_of_extern_field(page_zip_des_t*,rec_t*,dict_index_t*,const ulint*,ulint,ulint,mtr_t*)" -> "__builtin_expect(long int,long int)"
"btr_cur_set_ownership_of_extern_field(page_zip_des_t*,rec_t*,dict_index_t*,const ulint*,ulint,ulint,mtr_t*)" -> "rec_get_nth_field_offs(const ulint*,ulint,ulint*)"
"btr_cur_set_ownership_of_extern_field(page_zip_des_t*,rec_t*,dict_index_t*,const ulint*,ulint,ulint,mtr_t*)" -> "abort()"
"btr_cur_set_ownership_of_extern_field(page_zip_des_t*,rec_t*,dict_index_t*,const ulint*,ulint,ulint,mtr_t*)" -> "mach_write_to_1(unsigned char*,ulint)"
"btr_cur_set_ownership_of_extern_field(page_zip_des_t*,rec_t*,dict_index_t*,const ulint*,ulint,ulint,mtr_t*)" -> "mlog_write_ulint(unsigned char*,ulint,unsigned char,mtr_t*)"
"btr_cur_set_ownership_of_extern_field(page_zip_des_t*,rec_t*,dict_index_t*,const ulint*,ulint,ulint,mtr_t*)" -> "ut_dbg_assertion_failed(const char*,const char*,ulint)"
"btr_cur_set_ownership_of_extern_field(page_zip_des_t*,rec_t*,dict_index_t*,const ulint*,ulint,ulint,mtr_t*)" -> "page_zip_write_blob_ptr(page_zip_des_t*,const unsigned char*,dict_index_t*,const ulint*,ulint,mtr_t*)"
"row_ins_clust_index_entry(dict_index_t*,dtuple_t*,que_thr_t*,ulint)" -> "row_ins_check_foreign_constraints(dict_table_t*,dict_index_t*,dtuple_t*,que_thr_t*)"
"row_ins_clust_index_entry(dict_index_t*,dtuple_t*,que_thr_t*,ulint)" -> "dict_index_is_unique(const dict_index_t*)"
"row_ins_clust_index_entry(dict_index_t*,dtuple_t*,que_thr_t*,ulint)" -> "log_free_check()"
"row_ins_clust_index_entry(dict_index_t*,dtuple_t*,que_thr_t*,ulint)" -> "row_ins_clust_index_entry_low(ulint,ulint,dict_index_t*,ulint,dtuple_t*,ulint,que_thr_t*)"
"row_ins_clust_index_entry(dict_index_t*,dtuple_t*,que_thr_t*,ulint)" -> "_Alloc>::empty() const [with _Key = dict_foreign_t*,_Compare = dict_foreign_compare,_Alloc = std::allocator<dict_foreign_t*>]"
"row_ins_clust_index_entry_low(ulint,ulint,dict_index_t*,ulint,dtuple_t*,ulint,que_thr_t*)" -> "row_ins_clust_index_entry_by_modify(ulint,ulint,btr_cur_t*,ulint**,mem_heap_t**,mem_heap_t*,big_rec_t**,const dtuple_t*,que_thr_t*,mtr_t*)"
"row_ins_clust_index_entry_low(ulint,ulint,dict_index_t*,ulint,dtuple_t*,ulint,que_thr_t*)" -> "dtuple_big_rec_free(big_rec_t*)"
"row_ins_clust_index_entry_low(ulint,ulint,dict_index_t*,ulint,dtuple_t*,ulint,que_thr_t*)" -> "thr_get_trx(que_thr_t*)"
"row_ins_clust_index_entry_low(ulint,ulint,dict_index_t*,ulint,dtuple_t*,ulint,que_thr_t*)" -> "row_ins_must_modify_rec(const btr_cur_t*)"
"row_ins_clust_index_entry_low(ulint,ulint,dict_index_t*,ulint,dtuple_t*,ulint,que_thr_t*)" -> "row_log_table_insert(const rec_t*,dict_index_t*,const ulint*)"
"row_ins_clust_index_entry_low(ulint,ulint,dict_index_t*,ulint,dtuple_t*,ulint,que_thr_t*)" -> "btr_store_big_rec_extern_fields(dict_index_t*,buf_block_t*,rec_t*,const ulint*,const big_rec_t*,mtr_t*,blob_op)"
"row_ins_clust_index_entry_low(ulint,ulint,dict_index_t*,ulint,dtuple_t*,ulint,que_thr_t*)" -> "mtr_start(mtr_t*)"
"row_ins_clust_index_entry_low(ulint,ulint,dict_index_t*,ulint,dtuple_t*,ulint,que_thr_t*)" -> "btr_cur_search_to_nth_level(dict_index_t*,ulint,const dtuple_t*,ulint,ulint,btr_cur_t*,ulint,const char*,ulint,mtr_t*)"
"row_ins_clust_index_entry_low(ulint,ulint,dict_index_t*,ulint,dtuple_t*,ulint,que_thr_t*)" -> "ut_dbg_assertion_failed(const char*,const char*,ulint)"
"row_ins_clust_index_entry_low(ulint,ulint,dict_index_t*,ulint,dtuple_t*,ulint,que_thr_t*)" -> "dtuple_convert_back_big_rec(dict_index_t*,dtuple_t*,big_rec_t*)"
"row_ins_clust_index_entry_low(ulint,ulint,dict_index_t*,ulint,dtuple_t*,ulint,que_thr_t*)" -> "btr_cur_pessimistic_insert(ulint,btr_cur_t*,ulint**,mem_heap_t**,dtuple_t*,rec_t**,big_rec_t**,ulint,que_thr_t*,mtr_t*)"
"row_ins_clust_index_entry_low(ulint,ulint,dict_index_t*,ulint,dtuple_t*,ulint,que_thr_t*)" -> "mtr_s_lock_func(rw_lock_t*,const char*,ulint,mtr_t*)"
"row_ins_clust_index_entry_low(ulint,ulint,dict_index_t*,ulint,dtuple_t*,ulint,que_thr_t*)" -> "row_ins_index_entry_big_rec_func(const dtuple_t*,const big_rec_t*,ulint*,mem_heap_t**,dict_index_t*,const char*,ulint)"
"row_ins_clust_index_entry_low(ulint,ulint,dict_index_t*,ulint,dtuple_t*,ulint,que_thr_t*)" -> "btr_cur_optimistic_insert(ulint,btr_cur_t*,ulint**,mem_heap_t**,dtuple_t*,rec_t**,big_rec_t**,ulint,que_thr_t*,mtr_t*)"
"row_ins_clust_index_entry_low(ulint,ulint,dict_index_t*,ulint,dtuple_t*,ulint,que_thr_t*)" -> "__builtin_expect(long int,long int)"
"row_ins_clust_index_entry_low(ulint,ulint,dict_index_t*,ulint,dtuple_t*,ulint,que_thr_t*)" -> "mem_heap_free_func(mem_heap_t*,const char*,ulint)"
"row_ins_clust_index_entry_low(ulint,ulint,dict_index_t*,ulint,dtuple_t*,ulint,que_thr_t*)" -> "mtr_commit(mtr_t*)"
"row_ins_clust_index_entry_low(ulint,ulint,dict_index_t*,ulint,dtuple_t*,ulint,que_thr_t*)" -> "mem_heap_create_func(ulint,ulint)"
"row_ins_clust_index_entry_low(ulint,ulint,dict_index_t*,ulint,dtuple_t*,ulint,que_thr_t*)" -> "dict_index_get_lock(dict_index_t*)"
"row_ins_clust_index_entry_low(ulint,ulint,dict_index_t*,ulint,dtuple_t*,ulint,que_thr_t*)" -> "abort()"
"row_ins_clust_index_entry_low(ulint,ulint,dict_index_t*,ulint,dtuple_t*,ulint,que_thr_t*)" -> "row_ins_duplicate_error_in_clust_online(ulint,const dtuple_t*,const btr_cur_t*,ulint**,mem_heap_t**)"
"row_ins_clust_index_entry_low(ulint,ulint,dict_index_t*,ulint,dtuple_t*,ulint,que_thr_t*)" -> "buf_LRU_buf_pool_running_out()"
"row_ins_clust_index_entry_low(ulint,ulint,dict_index_t*,ulint,dtuple_t*,ulint,que_thr_t*)" -> "row_ins_duplicate_error_in_clust(ulint,btr_cur_t*,const dtuple_t*,que_thr_t*,mtr_t*)"
"row_ins_clust_index_entry_low(ulint,ulint,dict_index_t*,ulint,dtuple_t*,ulint,que_thr_t*)" -> "dict_index_is_online_ddl(const dict_index_t*)"
"row_ins_clust_index_entry_by_modify(ulint,ulint,btr_cur_t*,ulint**,mem_heap_t**,mem_heap_t*,big_rec_t**,const dtuple_t*,que_thr_t*,mtr_t*)" -> "buf_LRU_buf_pool_running_out()"
"row_ins_clust_index_entry_by_modify(ulint,ulint,btr_cur_t*,ulint**,mem_heap_t**,mem_heap_t*,big_rec_t**,const dtuple_t*,que_thr_t*,mtr_t*)" -> "thr_get_trx(que_thr_t*)"
"row_ins_clust_index_entry_by_modify(ulint,ulint,btr_cur_t*,ulint**,mem_heap_t**,mem_heap_t*,big_rec_t**,const dtuple_t*,que_thr_t*,mtr_t*)" -> "btr_cur_optimistic_update(ulint,btr_cur_t*,ulint**,mem_heap_t**,const upd_t*,ulint,que_thr_t*,trx_id_t,mtr_t*)"
"row_ins_clust_index_entry_by_modify(ulint,ulint,btr_cur_t*,ulint**,mem_heap_t**,mem_heap_t*,big_rec_t**,const dtuple_t*,que_thr_t*,mtr_t*)" -> "row_upd_build_difference_binary(dict_index_t*,const dtuple_t*,const rec_t*,const ulint*,bool,trx_t*,mem_heap_t*)"
"row_ins_clust_index_entry_by_modify(ulint,ulint,btr_cur_t*,ulint**,mem_heap_t**,mem_heap_t*,big_rec_t**,const dtuple_t*,que_thr_t*,mtr_t*)" -> "btr_cur_pessimistic_update(ulint,btr_cur_t*,ulint**,mem_heap_t**,mem_heap_t*,big_rec_t**,const upd_t*,ulint,que_thr_t*,trx_id_t,mtr_t*)"
"buf_LRU_buf_pool_running_out()" -> "pfs_mutex_exit_func(ib_mutex_t*)"
"buf_LRU_buf_pool_running_out()" -> "buf_pool_from_array(ulint)"
"buf_LRU_buf_pool_running_out()" -> "pfs_mutex_enter_func(ib_mutex_t*,const char*,ulint)"
"btr_cur_optimistic_update(ulint,btr_cur_t*,ulint**,mem_heap_t**,const upd_t*,ulint,que_thr_t*,trx_id_t,mtr_t*)" -> "row_rec_to_index_entry(const rec_t*,const dict_index_t*,const ulint*,ulint*,mem_heap_t*)"
"btr_cur_optimistic_update(ulint,btr_cur_t*,ulint**,mem_heap_t**,const upd_t*,ulint,que_thr_t*,trx_id_t,mtr_t*)" -> "page_cur_move_to_prev(page_cur_t*)"
"btr_cur_optimistic_update(ulint,btr_cur_t*,ulint**,mem_heap_t**,const upd_t*,ulint,que_thr_t*,trx_id_t,mtr_t*)" -> "btr_cur_update_in_place(ulint,btr_cur_t*,ulint*,const upd_t*,ulint,que_thr_t*,trx_id_t,mtr_t*)"
"btr_cur_optimistic_update(ulint,btr_cur_t*,ulint**,mem_heap_t**,const upd_t*,ulint,que_thr_t*,trx_id_t,mtr_t*)" -> "dict_index_is_clust(const dict_index_t*)"
"btr_cur_optimistic_update(ulint,btr_cur_t*,ulint**,mem_heap_t**,const upd_t*,ulint,que_thr_t*,trx_id_t,mtr_t*)" -> "page_get_data_size(const ib_page_t*)"
"btr_cur_optimistic_update(ulint,btr_cur_t*,ulint**,mem_heap_t**,const upd_t*,ulint,que_thr_t*,trx_id_t,mtr_t*)" -> "page_get_n_recs(const ib_page_t*)"
"btr_cur_optimistic_update(ulint,btr_cur_t*,ulint**,mem_heap_t**,const upd_t*,ulint,que_thr_t*,trx_id_t,mtr_t*)" -> "btr_cur_update_alloc_zip_func(page_zip_des_t*,page_cur_t*,dict_index_t*,ulint,bool,mtr_t*)"
"btr_cur_optimistic_update(ulint,btr_cur_t*,ulint**,mem_heap_t**,const upd_t*,ulint,que_thr_t*,trx_id_t,mtr_t*)" -> "page_get_max_insert_size(const ib_page_t*,ulint)"
"btr_cur_optimistic_update(ulint,btr_cur_t*,ulint**,mem_heap_t**,const upd_t*,ulint,que_thr_t*,trx_id_t,mtr_t*)" -> "btr_search_update_hash_on_delete(btr_cur_t*)"
"btr_cur_optimistic_update(ulint,btr_cur_t*,ulint**,mem_heap_t**,const upd_t*,ulint,que_thr_t*,trx_id_t,mtr_t*)" -> "btr_cur_upd_lock_and_undo(ulint,btr_cur_t*,const ulint*,const upd_t*,ulint,que_thr_t*,mtr_t*,roll_ptr_t*)"
"btr_cur_optimistic_update(ulint,btr_cur_t*,ulint**,mem_heap_t**,const upd_t*,ulint,que_thr_t*,trx_id_t,mtr_t*)" -> "page_cur_move_to_next(page_cur_t*)"
"btr_cur_optimistic_update(ulint,btr_cur_t*,ulint**,mem_heap_t**,const upd_t*,ulint,que_thr_t*,trx_id_t,mtr_t*)" -> "dfield_is_ext(const dfield_t*)"
"btr_cur_optimistic_update(ulint,btr_cur_t*,ulint**,mem_heap_t**,const upd_t*,ulint,que_thr_t*,trx_id_t,mtr_t*)" -> "abort()"
"btr_cur_optimistic_update(ulint,btr_cur_t*,ulint**,mem_heap_t**,const upd_t*,ulint,que_thr_t*,trx_id_t,mtr_t*)" -> "rec_offs_any_extern(const ulint*)"
"btr_cur_optimistic_update(ulint,btr_cur_t*,ulint**,mem_heap_t**,const upd_t*,ulint,que_thr_t*,trx_id_t,mtr_t*)" -> "page_get_max_insert_size_after_reorganize(const ib_page_t*,ulint)"
"btr_cur_optimistic_update(ulint,btr_cur_t*,ulint**,mem_heap_t**,const upd_t*,ulint,que_thr_t*,trx_id_t,mtr_t*)" -> "page_is_comp(const ib_page_t*)"
"btr_cur_optimistic_update(ulint,btr_cur_t*,ulint**,mem_heap_t**,const upd_t*,ulint,que_thr_t*,trx_id_t,mtr_t*)" -> "mem_heap_create_func(ulint,ulint)"
"btr_cur_optimistic_update(ulint,btr_cur_t*,ulint**,mem_heap_t**,const upd_t*,ulint,que_thr_t*,trx_id_t,mtr_t*)" -> "upd_get_n_fields(const upd_t*)"
"btr_cur_optimistic_update(ulint,btr_cur_t*,ulint**,mem_heap_t**,const upd_t*,ulint,que_thr_t*,trx_id_t,mtr_t*)" -> "rec_offs_n_fields(const ulint*)"
"btr_cur_optimistic_update(ulint,btr_cur_t*,ulint**,mem_heap_t**,const upd_t*,ulint,que_thr_t*,trx_id_t,mtr_t*)" -> "lock_rec_store_on_page_infimum(const buf_block_t*,const rec_t*)"
"btr_cur_optimistic_update(ulint,btr_cur_t*,ulint**,mem_heap_t**,const upd_t*,ulint,que_thr_t*,trx_id_t,mtr_t*)" -> "page_cur_delete_rec(page_cur_t*,const dict_index_t*,const ulint*,mtr_t*)"
"btr_cur_optimistic_update(ulint,btr_cur_t*,ulint**,mem_heap_t**,const upd_t*,ulint,que_thr_t*,trx_id_t,mtr_t*)" -> "lock_rec_restore_from_page_infimum(const buf_block_t*,const rec_t*,const buf_block_t*)"
"btr_cur_optimistic_update(ulint,btr_cur_t*,ulint**,mem_heap_t**,const upd_t*,ulint,que_thr_t*,trx_id_t,mtr_t*)" -> "ibuf_update_free_bits_zip(buf_block_t*,mtr_t*)"
"btr_cur_optimistic_update(ulint,btr_cur_t*,ulint**,mem_heap_t**,const upd_t*,ulint,que_thr_t*,trx_id_t,mtr_t*)" -> "row_upd_index_entry_sys_field(dtuple_t*,dict_index_t*,ulint,ib_uint64_t)"
"btr_cur_optimistic_update(ulint,btr_cur_t*,ulint**,mem_heap_t**,const upd_t*,ulint,que_thr_t*,trx_id_t,mtr_t*)" -> "rec_get_converted_size(dict_index_t*,const dtuple_t*,ulint)"
"btr_cur_optimistic_update(ulint,btr_cur_t*,ulint**,mem_heap_t**,const upd_t*,ulint,que_thr_t*,trx_id_t,mtr_t*)" -> "page_is_leaf(const ib_page_t*)"
"btr_cur_optimistic_update(ulint,btr_cur_t*,ulint**,mem_heap_t**,const upd_t*,ulint,que_thr_t*,trx_id_t,mtr_t*)" -> "ut_dbg_assertion_failed(const char*,const char*,ulint)"
"btr_cur_optimistic_update(ulint,btr_cur_t*,ulint**,mem_heap_t**,const upd_t*,ulint,que_thr_t*,trx_id_t,mtr_t*)" -> "rec_offs_size(const ulint*)"
"btr_cur_optimistic_update(ulint,btr_cur_t*,ulint**,mem_heap_t**,const upd_t*,ulint,que_thr_t*,trx_id_t,mtr_t*)" -> "btr_cur_insert_if_possible(btr_cur_t*,const dtuple_t*,ulint**,mem_heap_t**,ulint,mtr_t*)"
"btr_cur_optimistic_update(ulint,btr_cur_t*,ulint**,mem_heap_t**,const upd_t*,ulint,que_thr_t*,trx_id_t,mtr_t*)" -> "row_upd_changes_field_size_or_external(dict_index_t*,const ulint*,const upd_t*)"
"btr_cur_optimistic_update(ulint,btr_cur_t*,ulint**,mem_heap_t**,const upd_t*,ulint,que_thr_t*,trx_id_t,mtr_t*)" -> "rec_get_offsets_func(const rec_t*,const dict_index_t*,ulint*,ulint,mem_heap_t**)"
"btr_cur_optimistic_update(ulint,btr_cur_t*,ulint**,mem_heap_t**,const upd_t*,ulint,que_thr_t*,trx_id_t,mtr_t*)" -> "__builtin_expect(long int,long int)"
"btr_cur_optimistic_update(ulint,btr_cur_t*,ulint**,mem_heap_t**,const upd_t*,ulint,que_thr_t*,trx_id_t,mtr_t*)" -> "row_upd_index_replace_new_col_vals_index_pos(dtuple_t*,dict_index_t*,const upd_t*,ulint,mem_heap_t*)"
"btr_cur_optimistic_update(ulint,btr_cur_t*,ulint**,mem_heap_t**,const upd_t*,ulint,que_thr_t*,trx_id_t,mtr_t*)" -> "page_get_free_space_of_empty(ulint)"
"btr_cur_update_in_place(ulint,btr_cur_t*,ulint*,const upd_t*,ulint,que_thr_t*,trx_id_t,mtr_t*)" -> "pfs_rw_lock_x_lock_func(rw_lock_t*,ulint,const char*,ulint)"
"btr_cur_update_in_place(ulint,btr_cur_t*,ulint*,const upd_t*,ulint,que_thr_t*,trx_id_t,mtr_t*)" -> "rec_offs_size(const ulint*)"
"btr_cur_update_in_place(ulint,btr_cur_t*,ulint*,const upd_t*,ulint,que_thr_t*,trx_id_t,mtr_t*)" -> "page_is_leaf(const ib_page_t*)"
"btr_cur_update_in_place(ulint,btr_cur_t*,ulint*,const upd_t*,ulint,que_thr_t*,trx_id_t,mtr_t*)" -> "ibuf_update_free_bits_zip(buf_block_t*,mtr_t*)"
"btr_cur_update_in_place(ulint,btr_cur_t*,ulint*,const upd_t*,ulint,que_thr_t*,trx_id_t,mtr_t*)" -> "row_upd_changes_ord_field_binary_func(dict_index_t*,const upd_t*,const dtuple_t*,const row_ext_t*)"
"btr_cur_update_in_place(ulint,btr_cur_t*,ulint*,const upd_t*,ulint,que_thr_t*,trx_id_t,mtr_t*)" -> "row_upd_rec_sys_fields(rec_t*,page_zip_des_t*,dict_index_t*,const ulint*,const trx_t*,roll_ptr_t)"
"btr_cur_update_in_place(ulint,btr_cur_t*,ulint*,const upd_t*,ulint,que_thr_t*,trx_id_t,mtr_t*)" -> "btr_search_update_hash_on_delete(btr_cur_t*)"
"btr_cur_update_in_place(ulint,btr_cur_t*,ulint*,const upd_t*,ulint,que_thr_t*,trx_id_t,mtr_t*)" -> "pfs_rw_lock_x_unlock_func(rw_lock_t*)"
"btr_cur_update_in_place(ulint,btr_cur_t*,ulint*,const upd_t*,ulint,que_thr_t*,trx_id_t,mtr_t*)" -> "row_upd_rec_in_place(rec_t*,dict_index_t*,const ulint*,const upd_t*,page_zip_des_t*)"
"btr_cur_update_in_place(ulint,btr_cur_t*,ulint*,const upd_t*,ulint,que_thr_t*,trx_id_t,mtr_t*)" -> "btr_cur_unmark_extern_fields(page_zip_des_t*,rec_t*,dict_index_t*,const ulint*,mtr_t*)"
"btr_cur_update_in_place(ulint,btr_cur_t*,ulint*,const upd_t*,ulint,que_thr_t*,trx_id_t,mtr_t*)" -> "dict_index_is_clust(const dict_index_t*)"
"btr_cur_update_in_place(ulint,btr_cur_t*,ulint*,const upd_t*,ulint,que_thr_t*,trx_id_t,mtr_t*)" -> "btr_cur_upd_lock_and_undo(ulint,btr_cur_t*,const ulint*,const upd_t*,ulint,que_thr_t*,mtr_t*,roll_ptr_t*)"
"btr_cur_update_in_place(ulint,btr_cur_t*,ulint*,const upd_t*,ulint,que_thr_t*,trx_id_t,mtr_t*)" -> "btr_cur_update_alloc_zip_func(page_zip_des_t*,page_cur_t*,dict_index_t*,ulint,bool,mtr_t*)"
"btr_cur_update_in_place(ulint,btr_cur_t*,ulint*,const upd_t*,ulint,que_thr_t*,trx_id_t,mtr_t*)" -> "page_is_comp(const ib_page_t*)"
"btr_cur_update_in_place(ulint,btr_cur_t*,ulint*,const upd_t*,ulint,que_thr_t*,trx_id_t,mtr_t*)" -> "rec_get_deleted_flag(const rec_t*,ulint)"
"btr_cur_update_in_place(ulint,btr_cur_t*,ulint*,const upd_t*,ulint,que_thr_t*,trx_id_t,mtr_t*)" -> "thr_get_trx(que_thr_t*)"
"btr_cur_update_in_place(ulint,btr_cur_t*,ulint*,const upd_t*,ulint,que_thr_t*,trx_id_t,mtr_t*)" -> "btr_cur_update_in_place_log(ulint,const rec_t*,dict_index_t*,const upd_t*,trx_id_t,roll_ptr_t,mtr_t*)"
"btr_cur_update_in_place(ulint,btr_cur_t*,ulint*,const upd_t*,ulint,que_thr_t*,trx_id_t,mtr_t*)" -> "__builtin_expect(long int,long int)"
"btr_cur_unmark_extern_fields(page_zip_des_t*,rec_t*,dict_index_t*,const ulint*,mtr_t*)" -> "btr_cur_set_ownership_of_extern_field(page_zip_des_t*,rec_t*,dict_index_t*,const ulint*,ulint,ulint,mtr_t*)"
"btr_cur_unmark_extern_fields(page_zip_des_t*,rec_t*,dict_index_t*,const ulint*,mtr_t*)" -> "rec_offs_nth_extern(const ulint*,ulint)"
"btr_cur_unmark_extern_fields(page_zip_des_t*,rec_t*,dict_index_t*,const ulint*,mtr_t*)" -> "rec_offs_n_fields(const ulint*)"
"btr_cur_unmark_extern_fields(page_zip_des_t*,rec_t*,dict_index_t*,const ulint*,mtr_t*)" -> "rec_offs_any_extern(const ulint*)"
"btr_cur_upd_lock_and_undo(ulint,btr_cur_t*,const ulint*,const upd_t*,ulint,que_thr_t*,mtr_t*,roll_ptr_t*)" -> "lock_sec_rec_modify_check_and_lock(ulint,buf_block_t*,const rec_t*,dict_index_t*,que_thr_t*,mtr_t*)"
"btr_cur_upd_lock_and_undo(ulint,btr_cur_t*,const ulint*,const upd_t*,ulint,que_thr_t*,mtr_t*,roll_ptr_t*)" -> "lock_clust_rec_modify_check_and_lock(ulint,const buf_block_t*,const rec_t*,dict_index_t*,const ulint*,que_thr_t*)"
"btr_cur_upd_lock_and_undo(ulint,btr_cur_t*,const ulint*,const upd_t*,ulint,que_thr_t*,mtr_t*,roll_ptr_t*)" -> "dict_index_is_clust(const dict_index_t*)"
"btr_cur_upd_lock_and_undo(ulint,btr_cur_t*,const ulint*,const upd_t*,ulint,que_thr_t*,mtr_t*,roll_ptr_t*)" -> "trx_undo_report_row_operation(ulint,ulint,que_thr_t*,dict_index_t*,const dtuple_t*,const upd_t*,ulint,const rec_t*,const ulint*,roll_ptr_t*)"
"btr_cur_insert_if_possible(btr_cur_t*,const dtuple_t*,ulint**,mem_heap_t**,ulint,mtr_t*)" -> "btr_page_reorganize(page_cur_t*,dict_index_t*,mtr_t*)"
"btr_cur_insert_if_possible(btr_cur_t*,const dtuple_t*,ulint**,mem_heap_t**,ulint,mtr_t*)" -> "page_cur_tuple_insert(page_cur_t*,const dtuple_t*,dict_index_t*,ulint**,mem_heap_t**,ulint,mtr_t*)"
"row_upd_index_replace_new_col_vals_index_pos(dtuple_t*,dict_index_t*,const upd_t*,ulint,mem_heap_t*)" -> "dict_table_zip_size(const dict_table_t*)"
"row_upd_index_replace_new_col_vals_index_pos(dtuple_t*,dict_index_t*,const upd_t*,ulint,mem_heap_t*)" -> "dict_index_get_n_fields(const dict_index_t*)"
"row_upd_index_replace_new_col_vals_index_pos(dtuple_t*,dict_index_t*,const upd_t*,ulint,mem_heap_t*)" -> "dict_index_get_n_unique(const dict_index_t*)"
"row_upd_index_replace_new_col_vals_index_pos(dtuple_t*,dict_index_t*,const upd_t*,ulint,mem_heap_t*)" -> "upd_get_field_by_field_no(const upd_t*,ulint)"
"row_upd_index_replace_new_col_vals_index_pos(dtuple_t*,dict_index_t*,const upd_t*,ulint,mem_heap_t*)" -> "dtuple_set_info_bits(dtuple_t*,ulint)"
"row_upd_index_replace_new_col_vals_index_pos(dtuple_t*,dict_index_t*,const upd_t*,ulint,mem_heap_t*)" -> "row_upd_index_replace_new_col_val(dfield_t*,const dict_field_t*,const dict_col_t*,const upd_field_t*,mem_heap_t*,ulint)"
"row_upd_index_replace_new_col_vals_index_pos(dtuple_t*,dict_index_t*,const upd_t*,ulint,mem_heap_t*)" -> "dict_field_get_col(const dict_field_t*)"
"row_upd_build_difference_binary(dict_index_t*,const dtuple_t*,const rec_t*,const ulint*,bool,trx_t*,mem_heap_t*)" -> "dfield_data_is_binary_equal(const dfield_t*,ulint,const unsigned char*)"
"row_upd_build_difference_binary(dict_index_t*,const dtuple_t*,const rec_t*,const ulint*,bool,trx_t*,mem_heap_t*)" -> "ut_dbg_assertion_failed(const char*,const char*,ulint)"
"row_upd_build_difference_binary(dict_index_t*,const dtuple_t*,const rec_t*,const ulint*,bool,trx_t*,mem_heap_t*)" -> "rec_get_nth_field_offs(const ulint*,ulint,ulint*)"
"row_upd_build_difference_binary(dict_index_t*,const dtuple_t*,const rec_t*,const ulint*,bool,trx_t*,mem_heap_t*)" -> "rec_get_offsets_func(const rec_t*,const dict_index_t*,ulint*,ulint,mem_heap_t**)"
"row_upd_build_difference_binary(dict_index_t*,const dtuple_t*,const rec_t*,const ulint*,bool,trx_t*,mem_heap_t*)" -> "upd_field_set_field_no(upd_field_t*,ulint,dict_index_t*,trx_t*)"
"row_upd_build_difference_binary(dict_index_t*,const dtuple_t*,const rec_t*,const ulint*,bool,trx_t*,mem_heap_t*)" -> "dfield_copy(dfield_t*,const dfield_t*)"
"row_upd_build_difference_binary(dict_index_t*,const dtuple_t*,const rec_t*,const ulint*,bool,trx_t*,mem_heap_t*)" -> "upd_create(ulint,mem_heap_t*)"
"row_upd_build_difference_binary(dict_index_t*,const dtuple_t*,const rec_t*,const ulint*,bool,trx_t*,mem_heap_t*)" -> "abort()"
"row_upd_build_difference_binary(dict_index_t*,const dtuple_t*,const rec_t*,const ulint*,bool,trx_t*,mem_heap_t*)" -> "dfield_is_ext(const dfield_t*)"
"row_upd_build_difference_binary(dict_index_t*,const dtuple_t*,const rec_t*,const ulint*,bool,trx_t*,mem_heap_t*)" -> "rec_offs_nth_extern(const ulint*,ulint)"
"row_upd_build_difference_binary(dict_index_t*,const dtuple_t*,const rec_t*,const ulint*,bool,trx_t*,mem_heap_t*)" -> "dict_index_get_sys_col_pos(const dict_index_t*,ulint)"
"row_upd_build_difference_binary(dict_index_t*,const dtuple_t*,const rec_t*,const ulint*,bool,trx_t*,mem_heap_t*)" -> "__builtin_expect(long int,long int)"
"row_upd_build_difference_binary(dict_index_t*,const dtuple_t*,const rec_t*,const ulint*,bool,trx_t*,mem_heap_t*)" -> "rec_offs_set_n_alloc(ulint*,ulint)"
"row_upd_build_difference_binary(dict_index_t*,const dtuple_t*,const rec_t*,const ulint*,bool,trx_t*,mem_heap_t*)" -> "dict_index_is_clust(const dict_index_t*)"
"row_upd_build_difference_binary(dict_index_t*,const dtuple_t*,const rec_t*,const ulint*,bool,trx_t*,mem_heap_t*)" -> "dtuple_get_n_fields(const dtuple_t*)"
"btr_cur_pessimistic_update(ulint,btr_cur_t*,ulint**,mem_heap_t**,mem_heap_t*,big_rec_t**,const upd_t*,ulint,que_thr_t*,trx_id_t,mtr_t*)" -> "btr_cur_optimistic_update(ulint,btr_cur_t*,ulint**,mem_heap_t**,const upd_t*,ulint,que_thr_t*,trx_id_t,mtr_t*)"
"btr_cur_pessimistic_update(ulint,btr_cur_t*,ulint**,mem_heap_t**,mem_heap_t*,big_rec_t**,const upd_t*,ulint,que_thr_t*,trx_id_t,mtr_t*)" -> "fsp_reserve_free_extents(ulint*,ulint,ulint,ulint,mtr_t*)"
"btr_cur_pessimistic_update(ulint,btr_cur_t*,ulint**,mem_heap_t**,mem_heap_t*,big_rec_t**,const upd_t*,ulint,que_thr_t*,trx_id_t,mtr_t*)" -> "rec_get_deleted_flag(const rec_t*,ulint)"
"btr_cur_pessimistic_update(ulint,btr_cur_t*,ulint**,mem_heap_t**,mem_heap_t*,big_rec_t**,const upd_t*,ulint,que_thr_t*,trx_id_t,mtr_t*)" -> "mtr_x_lock_func(rw_lock_t*,const char*,ulint,mtr_t*)"
"btr_cur_pessimistic_update(ulint,btr_cur_t*,ulint**,mem_heap_t**,mem_heap_t*,big_rec_t**,const upd_t*,ulint,que_thr_t*,trx_id_t,mtr_t*)" -> "fil_space_release_free_extents(ulint,ulint)"
"btr_cur_pessimistic_update(ulint,btr_cur_t*,ulint**,mem_heap_t**,mem_heap_t*,big_rec_t**,const upd_t*,ulint,que_thr_t*,trx_id_t,mtr_t*)" -> "dict_index_get_lock(dict_index_t*)"
"btr_cur_pessimistic_update(ulint,btr_cur_t*,ulint**,mem_heap_t**,mem_heap_t*,big_rec_t**,const upd_t*,ulint,que_thr_t*,trx_id_t,mtr_t*)" -> "dtuple_convert_big_rec(dict_index_t*,dtuple_t*,ulint*)"
"btr_cur_pessimistic_update(ulint,btr_cur_t*,ulint**,mem_heap_t**,mem_heap_t*,big_rec_t**,const upd_t*,ulint,que_thr_t*,trx_id_t,mtr_t*)" -> "rec_offs_comp(const ulint*)"
"btr_cur_pessimistic_update(ulint,btr_cur_t*,ulint**,mem_heap_t**,mem_heap_t*,big_rec_t**,const upd_t*,ulint,que_thr_t*,trx_id_t,mtr_t*)" -> "abort()"
"btr_cur_pessimistic_update(ulint,btr_cur_t*,ulint**,mem_heap_t**,mem_heap_t*,big_rec_t**,const upd_t*,ulint,que_thr_t*,trx_id_t,mtr_t*)" -> "btr_push_update_extern_fields(dtuple_t*,const upd_t*,mem_heap_t*)"
"btr_cur_pessimistic_update(ulint,btr_cur_t*,ulint**,mem_heap_t**,mem_heap_t*,big_rec_t**,const upd_t*,ulint,que_thr_t*,trx_id_t,mtr_t*)" -> "page_zip_rec_needs_ext(ulint,ulint,ulint,ulint)"
"btr_cur_pessimistic_update(ulint,btr_cur_t*,ulint**,mem_heap_t**,mem_heap_t*,big_rec_t**,const upd_t*,ulint,que_thr_t*,trx_id_t,mtr_t*)" -> "rec_offs_any_extern(const ulint*)"
"btr_cur_pessimistic_update(ulint,btr_cur_t*,ulint**,mem_heap_t**,mem_heap_t*,big_rec_t**,const upd_t*,ulint,que_thr_t*,trx_id_t,mtr_t*)" -> "__builtin_expect(long int,long int)"
"btr_cur_pessimistic_update(ulint,btr_cur_t*,ulint**,mem_heap_t**,mem_heap_t*,big_rec_t**,const upd_t*,ulint,que_thr_t*,trx_id_t,mtr_t*)" -> "btr_cur_pess_upd_restore_supremum(buf_block_t*,const rec_t*,mtr_t*)"
"btr_cur_pessimistic_update(ulint,btr_cur_t*,ulint**,mem_heap_t**,mem_heap_t*,big_rec_t**,const upd_t*,ulint,que_thr_t*,trx_id_t,mtr_t*)" -> "row_rec_to_index_entry(const rec_t*,const dict_index_t*,const ulint*,ulint*,mem_heap_t*)"
"btr_cur_pessimistic_update(ulint,btr_cur_t*,ulint**,mem_heap_t**,mem_heap_t*,big_rec_t**,const upd_t*,ulint,que_thr_t*,trx_id_t,mtr_t*)" -> "thr_get_trx(que_thr_t*)"
"btr_cur_pessimistic_update(ulint,btr_cur_t*,ulint**,mem_heap_t**,mem_heap_t*,big_rec_t**,const upd_t*,ulint,que_thr_t*,trx_id_t,mtr_t*)" -> "page_is_leaf(const ib_page_t*)"
"btr_cur_pessimistic_update(ulint,btr_cur_t*,ulint**,mem_heap_t**,mem_heap_t*,big_rec_t**,const upd_t*,ulint,que_thr_t*,trx_id_t,mtr_t*)" -> "page_cur_is_before_first(const page_cur_t*)"
"btr_cur_pessimistic_update(ulint,btr_cur_t*,ulint**,mem_heap_t**,mem_heap_t*,big_rec_t**,const upd_t*,ulint,que_thr_t*,trx_id_t,mtr_t*)" -> "btr_search_update_hash_on_delete(btr_cur_t*)"
"btr_cur_pessimistic_update(ulint,btr_cur_t*,ulint**,mem_heap_t**,mem_heap_t*,big_rec_t**,const upd_t*,ulint,que_thr_t*,trx_id_t,mtr_t*)" -> "rec_get_converted_size(dict_index_t*,const dtuple_t*,ulint)"
"btr_cur_pessimistic_update(ulint,btr_cur_t*,ulint**,mem_heap_t**,mem_heap_t*,big_rec_t**,const upd_t*,ulint,que_thr_t*,trx_id_t,mtr_t*)" -> "rec_get_offsets_func(const rec_t*,const dict_index_t*,ulint*,ulint,mem_heap_t**)"
"btr_cur_pessimistic_update(ulint,btr_cur_t*,ulint**,mem_heap_t**,mem_heap_t*,big_rec_t**,const upd_t*,ulint,que_thr_t*,trx_id_t,mtr_t*)" -> "ib_logf(ib_log_level_t,const char*,...)"
"btr_cur_pessimistic_update(ulint,btr_cur_t*,ulint**,mem_heap_t**,mem_heap_t*,big_rec_t**,const upd_t*,ulint,que_thr_t*,trx_id_t,mtr_t*)" -> "ibuf_update_free_bits_zip(buf_block_t*,mtr_t*)"
"btr_cur_pessimistic_update(ulint,btr_cur_t*,ulint**,mem_heap_t**,mem_heap_t*,big_rec_t**,const upd_t*,ulint,que_thr_t*,trx_id_t,mtr_t*)" -> "btr_cur_pessimistic_insert(ulint,btr_cur_t*,ulint**,mem_heap_t**,dtuple_t*,rec_t**,big_rec_t**,ulint,que_thr_t*,mtr_t*)"
"btr_cur_pessimistic_update(ulint,btr_cur_t*,ulint**,mem_heap_t**,mem_heap_t*,big_rec_t**,const upd_t*,ulint,que_thr_t*,trx_id_t,mtr_t*)" -> "dict_index_is_sec_or_ibuf(const dict_index_t*)"
"btr_cur_pessimistic_update(ulint,btr_cur_t*,ulint**,mem_heap_t**,mem_heap_t*,big_rec_t**,const upd_t*,ulint,que_thr_t*,trx_id_t,mtr_t*)" -> "lock_rec_store_on_page_infimum(const buf_block_t*,const rec_t*)"
"btr_cur_pessimistic_update(ulint,btr_cur_t*,ulint**,mem_heap_t**,mem_heap_t*,big_rec_t**,const upd_t*,ulint,que_thr_t*,trx_id_t,mtr_t*)" -> "trx_is_recv(const trx_t*)"
"btr_cur_pessimistic_update(ulint,btr_cur_t*,ulint**,mem_heap_t**,mem_heap_t*,big_rec_t**,const upd_t*,ulint,que_thr_t*,trx_id_t,mtr_t*)" -> "ut_dbg_assertion_failed(const char*,const char*,ulint)"
"btr_cur_pessimistic_update(ulint,btr_cur_t*,ulint**,mem_heap_t**,mem_heap_t*,big_rec_t**,const upd_t*,ulint,que_thr_t*,trx_id_t,mtr_t*)" -> "ibuf_reset_free_bits(buf_block_t*)"
"btr_cur_pessimistic_update(ulint,btr_cur_t*,ulint**,mem_heap_t**,mem_heap_t*,big_rec_t**,const upd_t*,ulint,que_thr_t*,trx_id_t,mtr_t*)" -> "btr_cur_compress_if_useful(btr_cur_t*,ulint,mtr_t*)"
"btr_cur_pessimistic_update(ulint,btr_cur_t*,ulint**,mem_heap_t**,mem_heap_t*,big_rec_t**,const upd_t*,ulint,que_thr_t*,trx_id_t,mtr_t*)" -> "dict_index_get_n_fields(const dict_index_t*)"
"btr_cur_pessimistic_update(ulint,btr_cur_t*,ulint**,mem_heap_t**,mem_heap_t*,big_rec_t**,const upd_t*,ulint,que_thr_t*,trx_id_t,mtr_t*)" -> "btr_cur_unmark_extern_fields(page_zip_des_t*,rec_t*,dict_index_t*,const ulint*,mtr_t*)"
"btr_cur_pessimistic_update(ulint,btr_cur_t*,ulint**,mem_heap_t**,mem_heap_t*,big_rec_t**,const upd_t*,ulint,que_thr_t*,trx_id_t,mtr_t*)" -> "page_is_comp(const ib_page_t*)"
"btr_cur_pessimistic_update(ulint,btr_cur_t*,ulint**,mem_heap_t**,mem_heap_t*,big_rec_t**,const upd_t*,ulint,que_thr_t*,trx_id_t,mtr_t*)" -> "dict_index_is_clust(const dict_index_t*)"
"btr_cur_pessimistic_update(ulint,btr_cur_t*,ulint**,mem_heap_t**,mem_heap_t*,big_rec_t**,const upd_t*,ulint,que_thr_t*,trx_id_t,mtr_t*)" -> "lock_rec_restore_from_page_infimum(const buf_block_t*,const rec_t*,const buf_block_t*)"
"btr_cur_pessimistic_update(ulint,btr_cur_t*,ulint**,mem_heap_t**,mem_heap_t*,big_rec_t**,const upd_t*,ulint,que_thr_t*,trx_id_t,mtr_t*)" -> "row_upd_index_replace_new_col_vals_index_pos(dtuple_t*,dict_index_t*,const upd_t*,ulint,mem_heap_t*)"
"btr_cur_pessimistic_update(ulint,btr_cur_t*,ulint**,mem_heap_t**,mem_heap_t*,big_rec_t**,const upd_t*,ulint,que_thr_t*,trx_id_t,mtr_t*)" -> "page_cur_delete_rec(page_cur_t*,const dict_index_t*,const ulint*,mtr_t*)"
"btr_cur_pessimistic_update(ulint,btr_cur_t*,ulint**,mem_heap_t**,mem_heap_t*,big_rec_t**,const upd_t*,ulint,que_thr_t*,trx_id_t,mtr_t*)" -> "page_zip_get_size(const page_zip_des_t*)"
"btr_cur_pessimistic_update(ulint,btr_cur_t*,ulint**,mem_heap_t**,mem_heap_t*,big_rec_t**,const upd_t*,ulint,que_thr_t*,trx_id_t,mtr_t*)" -> "btr_rec_free_updated_extern_fields(dict_index_t*,rec_t*,page_zip_des_t*,const ulint*,const upd_t*,trx_rb_ctx,mtr_t*)"
"btr_cur_pessimistic_update(ulint,btr_cur_t*,ulint**,mem_heap_t**,mem_heap_t*,big_rec_t**,const upd_t*,ulint,que_thr_t*,trx_id_t,mtr_t*)" -> "row_upd_index_entry_sys_field(dtuple_t*,dict_index_t*,ulint,ib_uint64_t)"
"btr_cur_pessimistic_update(ulint,btr_cur_t*,ulint**,mem_heap_t**,mem_heap_t*,big_rec_t**,const upd_t*,ulint,que_thr_t*,trx_id_t,mtr_t*)" -> "page_cur_move_to_prev(page_cur_t*)"
"btr_cur_pessimistic_update(ulint,btr_cur_t*,ulint**,mem_heap_t**,mem_heap_t*,big_rec_t**,const upd_t*,ulint,que_thr_t*,trx_id_t,mtr_t*)" -> "page_update_max_trx_id(buf_block_t*,page_zip_des_t*,trx_id_t,mtr_t*)"
"btr_cur_pessimistic_update(ulint,btr_cur_t*,ulint**,mem_heap_t**,mem_heap_t*,big_rec_t**,const upd_t*,ulint,que_thr_t*,trx_id_t,mtr_t*)" -> "btr_cur_insert_if_possible(btr_cur_t*,const dtuple_t*,ulint**,mem_heap_t**,ulint,mtr_t*)"
"btr_cur_pessimistic_update(ulint,btr_cur_t*,ulint**,mem_heap_t**,mem_heap_t*,big_rec_t**,const upd_t*,ulint,que_thr_t*,trx_id_t,mtr_t*)" -> "btr_cur_upd_lock_and_undo(ulint,btr_cur_t*,const ulint*,const upd_t*,ulint,que_thr_t*,mtr_t*,roll_ptr_t*)"
"btr_cur_pess_upd_restore_supremum(buf_block_t*,const rec_t*,mtr_t*)" -> "btr_page_get_prev(const ib_page_t*,mtr_t*)"
"btr_cur_pess_upd_restore_supremum(buf_block_t*,const rec_t*,mtr_t*)" -> "page_get_infimum_offset(const ib_page_t*)"
"btr_cur_pess_upd_restore_supremum(buf_block_t*,const rec_t*,mtr_t*)" -> "lock_rec_reset_and_inherit_gap_locks(const buf_block_t*,const buf_block_t*,ulint,ulint)"
"btr_cur_pess_upd_restore_supremum(buf_block_t*,const rec_t*,mtr_t*)" -> "buf_page_get_gen(ulint,ulint,ulint,ulint,buf_block_t*,ulint,const char*,ulint,mtr_t*)"
"btr_cur_pess_upd_restore_supremum(buf_block_t*,const rec_t*,mtr_t*)" -> "__builtin_expect(long int,long int)"
"btr_cur_pess_upd_restore_supremum(buf_block_t*,const rec_t*,mtr_t*)" -> "page_rec_get_heap_no(const rec_t*)"
"btr_cur_pess_upd_restore_supremum(buf_block_t*,const rec_t*,mtr_t*)" -> "abort()"
"btr_cur_pess_upd_restore_supremum(buf_block_t*,const rec_t*,mtr_t*)" -> "buf_block_get_zip_size(const buf_block_t*)"
"btr_cur_pess_upd_restore_supremum(buf_block_t*,const rec_t*,mtr_t*)" -> "page_rec_get_next(rec_t*)"
"btr_cur_pess_upd_restore_supremum(buf_block_t*,const rec_t*,mtr_t*)" -> "btr_page_get_next(const ib_page_t*,mtr_t*)"
"btr_cur_pess_upd_restore_supremum(buf_block_t*,const rec_t*,mtr_t*)" -> "buf_block_get_space(const buf_block_t*)"
"btr_cur_pess_upd_restore_supremum(buf_block_t*,const rec_t*,mtr_t*)" -> "page_get_page_no(const ib_page_t*)"
"btr_cur_pess_upd_restore_supremum(buf_block_t*,const rec_t*,mtr_t*)" -> "ut_dbg_assertion_failed(const char*,const char*,ulint)"
"lock_rec_reset_and_inherit_gap_locks(const buf_block_t*,const buf_block_t*,ulint,ulint)" -> "lock_rec_inherit_to_gap(const buf_block_t*,const buf_block_t*,ulint,ulint)"
"lock_rec_reset_and_inherit_gap_locks(const buf_block_t*,const buf_block_t*,ulint,ulint)" -> "pfs_mutex_exit_func(ib_mutex_t*)"
"lock_rec_reset_and_inherit_gap_locks(const buf_block_t*,const buf_block_t*,ulint,ulint)" -> "lock_rec_reset_and_release_wait(const buf_block_t*,ulint)"
"lock_rec_reset_and_inherit_gap_locks(const buf_block_t*,const buf_block_t*,ulint,ulint)" -> "pfs_mutex_enter_func(ib_mutex_t*,const char*,ulint)"
"btr_rec_free_updated_extern_fields(dict_index_t*,rec_t*,page_zip_des_t*,const ulint*,const upd_t*,trx_rb_ctx,mtr_t*)" -> "__builtin_expect(long int,long int)"
"btr_rec_free_updated_extern_fields(dict_index_t*,rec_t*,page_zip_des_t*,const ulint*,const upd_t*,trx_rb_ctx,mtr_t*)" -> "rec_get_nth_field_offs(const ulint*,ulint,ulint*)"
"btr_rec_free_updated_extern_fields(dict_index_t*,rec_t*,page_zip_des_t*,const ulint*,const upd_t*,trx_rb_ctx,mtr_t*)" -> "upd_get_n_fields(const upd_t*)"
"btr_rec_free_updated_extern_fields(dict_index_t*,rec_t*,page_zip_des_t*,const ulint*,const upd_t*,trx_rb_ctx,mtr_t*)" -> "ut_dbg_assertion_failed(const char*,const char*,ulint)"
"btr_rec_free_updated_extern_fields(dict_index_t*,rec_t*,page_zip_des_t*,const ulint*,const upd_t*,trx_rb_ctx,mtr_t*)" -> "rec_offs_nth_extern(const ulint*,ulint)"
"btr_rec_free_updated_extern_fields(dict_index_t*,rec_t*,page_zip_des_t*,const ulint*,const upd_t*,trx_rb_ctx,mtr_t*)" -> "btr_free_externally_stored_field(dict_index_t*,unsigned char*,const rec_t*,const ulint*,page_zip_des_t*,ulint,trx_rb_ctx,mtr_t*)"
"btr_rec_free_updated_extern_fields(dict_index_t*,rec_t*,page_zip_des_t*,const ulint*,const upd_t*,trx_rb_ctx,mtr_t*)" -> "abort()"
"dtuple_big_rec_free(big_rec_t*)" -> "mem_heap_free_func(mem_heap_t*,const char*,ulint)"
"row_ins_must_modify_rec(const btr_cur_t*)" -> "dict_index_get_n_unique_in_tree(const dict_index_t*)"
"row_ins_must_modify_rec(const btr_cur_t*)" -> "page_rec_is_infimum(const rec_t*)"
"row_log_table_insert(const rec_t*,dict_index_t*,const ulint*)" -> "row_log_table_low(const rec_t*,dict_index_t*,const ulint*,bool,const dtuple_t*)"
"row_log_table_low(const rec_t*,dict_index_t*,const ulint*,bool,const dtuple_t*)" -> "memcpy(void*,const void*,size_t)"
"row_log_table_low(const rec_t*,dict_index_t*,const ulint*,bool,const dtuple_t*)" -> "rec_offs_extra_size(const ulint*)"
"row_log_table_low(const rec_t*,dict_index_t*,const ulint*,bool,const dtuple_t*)" -> "rec_offs_comp(const ulint*)"
"row_log_table_low(const rec_t*,dict_index_t*,const ulint*,bool,const dtuple_t*)" -> "row_log_table_close_func(row_log_t*,ulint,ulint)"
"row_log_table_low(const rec_t*,dict_index_t*,const ulint*,bool,const dtuple_t*)" -> "dict_index_is_corrupted(const dict_index_t*)"
"row_log_table_low(const rec_t*,dict_index_t*,const ulint*,bool,const dtuple_t*)" -> "rec_offs_data_size(const ulint*)"
"row_log_table_low(const rec_t*,dict_index_t*,const ulint*,bool,const dtuple_t*)" -> "rec_get_converted_size_temp(const dict_index_t*,const dfield_t*,ulint,ulint*)"
"row_log_table_low(const rec_t*,dict_index_t*,const ulint*,bool,const dtuple_t*)" -> "row_log_table_low_redundant(const rec_t*,dict_index_t*,bool,const dtuple_t*,const dict_index_t*)"
"row_log_table_low(const rec_t*,dict_index_t*,const ulint*,bool,const dtuple_t*)" -> "rec_convert_dtuple_to_temp(rec_t*,const dict_index_t*,const dfield_t*,ulint)"
"row_log_table_low(const rec_t*,dict_index_t*,const ulint*,bool,const dtuple_t*)" -> "row_log_table_open(row_log_t*,ulint,ulint*)"
"row_log_table_low(const rec_t*,dict_index_t*,const ulint*,bool,const dtuple_t*)" -> "rec_offs_size(const ulint*)"
"row_log_table_low(const rec_t*,dict_index_t*,const ulint*,bool,const dtuple_t*)" -> "dict_index_is_online_ddl(const dict_index_t*)"
"row_log_table_low_redundant(const rec_t*,dict_index_t*,bool,const dtuple_t*,const dict_index_t*)" -> "row_log_table_open(row_log_t*,ulint,ulint*)"
"row_log_table_low_redundant(const rec_t*,dict_index_t*,bool,const dtuple_t*,const dict_index_t*)" -> "rec_get_converted_size_temp(const dict_index_t*,const dfield_t*,ulint,ulint*)"
"row_log_table_low_redundant(const rec_t*,dict_index_t*,bool,const dtuple_t*,const dict_index_t*)" -> "dfield_set_data(dfield_t*,const void*,ulint)"
"row_log_table_low_redundant(const rec_t*,dict_index_t*,bool,const dtuple_t*,const dict_index_t*)" -> "dtuple_set_n_fields_cmp(dtuple_t*,ulint)"
"row_log_table_low_redundant(const rec_t*,dict_index_t*,bool,const dtuple_t*,const dict_index_t*)" -> "rec_get_nth_field_offs_old(const rec_t*,ulint,ulint*)"
"row_log_table_low_redundant(const rec_t*,dict_index_t*,bool,const dtuple_t*,const dict_index_t*)" -> "dtuple_create(mem_heap_t*,ulint)"
"row_log_table_low_redundant(const rec_t*,dict_index_t*,bool,const dtuple_t*,const dict_index_t*)" -> "row_log_table_close_func(row_log_t*,ulint,ulint)"
"row_log_table_low_redundant(const rec_t*,dict_index_t*,bool,const dtuple_t*,const dict_index_t*)" -> "rec_2_is_field_extern(const rec_t*,ulint)"
"row_log_table_low_redundant(const rec_t*,dict_index_t*,bool,const dtuple_t*,const dict_index_t*)" -> "rec_convert_dtuple_to_temp(rec_t*,const dict_index_t*,const dfield_t*,ulint)"
"row_log_table_low_redundant(const rec_t*,dict_index_t*,bool,const dtuple_t*,const dict_index_t*)" -> "mem_heap_create_func(ulint,ulint)"
"row_log_table_low_redundant(const rec_t*,dict_index_t*,bool,const dtuple_t*,const dict_index_t*)" -> "dfield_set_ext(dfield_t*)"
"row_log_table_low_redundant(const rec_t*,dict_index_t*,bool,const dtuple_t*,const dict_index_t*)" -> "mem_heap_free_func(mem_heap_t*,const char*,ulint)"
"row_log_table_low_redundant(const rec_t*,dict_index_t*,bool,const dtuple_t*,const dict_index_t*)" -> "dict_index_copy_types(dtuple_t*,const dict_index_t*,ulint)"
"row_log_table_low_redundant(const rec_t*,dict_index_t*,bool,const dtuple_t*,const dict_index_t*)" -> "dict_index_get_n_unique(const dict_index_t*)"
"row_log_table_low_redundant(const rec_t*,dict_index_t*,bool,const dtuple_t*,const dict_index_t*)" -> "rec_get_1byte_offs_flag(const rec_t*)"
"rec_2_is_field_extern(const rec_t*,ulint)" -> "rec_2_get_field_end_info(const rec_t*,ulint)"
"btr_store_big_rec_extern_fields(dict_index_t*,buf_block_t*,rec_t*,const ulint*,const big_rec_t*,mtr_t*,blob_op)" -> "abort()"
"btr_store_big_rec_extern_fields(dict_index_t*,buf_block_t*,rec_t*,const ulint*,const big_rec_t*,mtr_t*,blob_op)" -> "page_align(const void*)"
"btr_store_big_rec_extern_fields(dict_index_t*,buf_block_t*,rec_t*,const ulint*,const big_rec_t*,mtr_t*,blob_op)" -> "dict_index_is_clust(const dict_index_t*)"
"btr_store_big_rec_extern_fields(dict_index_t*,buf_block_t*,rec_t*,const ulint*,const big_rec_t*,mtr_t*,blob_op)" -> "dict_table_zip_size(const dict_table_t*)"
"btr_store_big_rec_extern_fields(dict_index_t*,buf_block_t*,rec_t*,const ulint*,const big_rec_t*,mtr_t*,blob_op)" -> "mtr_start(mtr_t*)"
"btr_store_big_rec_extern_fields(dict_index_t*,buf_block_t*,rec_t*,const ulint*,const big_rec_t*,mtr_t*,blob_op)" -> "mach_write_to_4(unsigned char*,ulint)"
"btr_store_big_rec_extern_fields(dict_index_t*,buf_block_t*,rec_t*,const ulint*,const big_rec_t*,mtr_t*,blob_op)" -> "btr_blob_op_is_update(blob_op)"
"btr_store_big_rec_extern_fields(dict_index_t*,buf_block_t*,rec_t*,const ulint*,const big_rec_t*,mtr_t*,blob_op)" -> "mem_heap_free_func(mem_heap_t*,const char*,ulint)"
"btr_store_big_rec_extern_fields(dict_index_t*,buf_block_t*,rec_t*,const ulint*,const big_rec_t*,mtr_t*,blob_op)" -> "buf_block_get_space(const buf_block_t*)"
"btr_store_big_rec_extern_fields(dict_index_t*,buf_block_t*,rec_t*,const ulint*,const big_rec_t*,mtr_t*,blob_op)" -> "mem_heap_alloc(mem_heap_t*,ulint)"
"btr_store_big_rec_extern_fields(dict_index_t*,buf_block_t*,rec_t*,const ulint*,const big_rec_t*,mtr_t*,blob_op)" -> "__builtin_expect(long int,long int)"
"btr_store_big_rec_extern_fields(dict_index_t*,buf_block_t*,rec_t*,const ulint*,const big_rec_t*,mtr_t*,blob_op)" -> "mem_heap_create_func(ulint,ulint)"
"btr_store_big_rec_extern_fields(dict_index_t*,buf_block_t*,rec_t*,const ulint*,const big_rec_t*,mtr_t*,blob_op)" -> "btr_blob_free(buf_block_t*,ulint,mtr_t*)"
"btr_store_big_rec_extern_fields(dict_index_t*,buf_block_t*,rec_t*,const ulint*,const big_rec_t*,mtr_t*,blob_op)" -> "fil_page_get_type(const unsigned char*)"
"btr_store_big_rec_extern_fields(dict_index_t*,buf_block_t*,rec_t*,const ulint*,const big_rec_t*,mtr_t*,blob_op)" -> "row_log_table_blob_alloc(dict_index_t*,ulint)"
"btr_store_big_rec_extern_fields(dict_index_t*,buf_block_t*,rec_t*,const ulint*,const big_rec_t*,mtr_t*,blob_op)" -> "deflateReset(z_streamp)"
"btr_store_big_rec_extern_fields(dict_index_t*,buf_block_t*,rec_t*,const ulint*,const big_rec_t*,mtr_t*,blob_op)" -> "page_zip_write_blob_ptr(page_zip_des_t*,const unsigned char*,dict_index_t*,const ulint*,ulint,mtr_t*)"
"btr_store_big_rec_extern_fields(dict_index_t*,buf_block_t*,rec_t*,const ulint*,const big_rec_t*,mtr_t*,blob_op)" -> "mlog_log_string(unsigned char*,ulint,mtr_t*)"
"btr_store_big_rec_extern_fields(dict_index_t*,buf_block_t*,rec_t*,const ulint*,const big_rec_t*,mtr_t*,blob_op)" -> "page_zip_get_size(const page_zip_des_t*)"
"btr_store_big_rec_extern_fields(dict_index_t*,buf_block_t*,rec_t*,const ulint*,const big_rec_t*,mtr_t*,blob_op)" -> "rw_lock_get_x_lock_count(const rw_lock_t*)"
"btr_store_big_rec_extern_fields(dict_index_t*,buf_block_t*,rec_t*,const ulint*,const big_rec_t*,mtr_t*,blob_op)" -> "buf_page_get_gen(ulint,ulint,ulint,ulint,buf_block_t*,ulint,const char*,ulint,mtr_t*)"
"btr_store_big_rec_extern_fields(dict_index_t*,buf_block_t*,rec_t*,const ulint*,const big_rec_t*,mtr_t*,blob_op)" -> "ib_logf(ib_log_level_t,const char*,...)"
"btr_store_big_rec_extern_fields(dict_index_t*,buf_block_t*,rec_t*,const ulint*,const big_rec_t*,mtr_t*,blob_op)" -> "mtr_commit(mtr_t*)"
"btr_store_big_rec_extern_fields(dict_index_t*,buf_block_t*,rec_t*,const ulint*,const big_rec_t*,mtr_t*,blob_op)" -> "btr_page_alloc(dict_index_t*,ulint,unsigned char,ulint,mtr_t*,mtr_t*)"
"btr_store_big_rec_extern_fields(dict_index_t*,buf_block_t*,rec_t*,const ulint*,const big_rec_t*,mtr_t*,blob_op)" -> "memset(void*,int,size_t)"
"btr_store_big_rec_extern_fields(dict_index_t*,buf_block_t*,rec_t*,const ulint*,const big_rec_t*,mtr_t*,blob_op)" -> "buf_block_get_page_no(const buf_block_t*)"
"btr_store_big_rec_extern_fields(dict_index_t*,buf_block_t*,rec_t*,const ulint*,const big_rec_t*,mtr_t*,blob_op)" -> "deflate(z_streamp,int)"
"btr_store_big_rec_extern_fields(dict_index_t*,buf_block_t*,rec_t*,const ulint*,const big_rec_t*,mtr_t*,blob_op)" -> "dict_index_is_online_ddl(const dict_index_t*)"
"btr_store_big_rec_extern_fields(dict_index_t*,buf_block_t*,rec_t*,const ulint*,const big_rec_t*,mtr_t*,blob_op)" -> "deflateInit2_(z_streamp,int,int,int,int,int,const char*,int)"
"btr_store_big_rec_extern_fields(dict_index_t*,buf_block_t*,rec_t*,const ulint*,const big_rec_t*,mtr_t*,blob_op)" -> "ut_dbg_assertion_failed(const char*,const char*,ulint)"
"btr_store_big_rec_extern_fields(dict_index_t*,buf_block_t*,rec_t*,const ulint*,const big_rec_t*,mtr_t*,blob_op)" -> "mlog_write_ulint(unsigned char*,ulint,unsigned char,mtr_t*)"
"btr_store_big_rec_extern_fields(dict_index_t*,buf_block_t*,rec_t*,const ulint*,const big_rec_t*,mtr_t*,blob_op)" -> "buf_block_get_zip_size(const buf_block_t*)"
"btr_store_big_rec_extern_fields(dict_index_t*,buf_block_t*,rec_t*,const ulint*,const big_rec_t*,mtr_t*,blob_op)" -> "mlog_write_string(unsigned char*,const unsigned char*,ulint,mtr_t*)"
"btr_store_big_rec_extern_fields(dict_index_t*,buf_block_t*,rec_t*,const ulint*,const big_rec_t*,mtr_t*,blob_op)" -> "memcpy(void*,const void*,size_t)"
"btr_store_big_rec_extern_fields(dict_index_t*,buf_block_t*,rec_t*,const ulint*,const big_rec_t*,mtr_t*,blob_op)" -> "btr_page_free_low(dict_index_t*,buf_block_t*,ulint,mtr_t*)"
"btr_store_big_rec_extern_fields(dict_index_t*,buf_block_t*,rec_t*,const ulint*,const big_rec_t*,mtr_t*,blob_op)" -> "deflateEnd(z_streamp)"
"btr_store_big_rec_extern_fields(dict_index_t*,buf_block_t*,rec_t*,const ulint*,const big_rec_t*,mtr_t*,blob_op)" -> "page_zip_set_alloc(void*,mem_heap_t*)"
"btr_store_big_rec_extern_fields(dict_index_t*,buf_block_t*,rec_t*,const ulint*,const big_rec_t*,mtr_t*,blob_op)" -> "btr_rec_get_field_ref_offs(const ulint*,ulint)"
"row_log_table_blob_alloc(dict_index_t*,ulint)" -> "row_log_table_blob_t::blob_alloc(ulonglong)"
"row_log_table_blob_alloc(dict_index_t*,ulint)" -> "_Alloc>::find(const key_type&) [with _Key = long unsigned int,_Tp = row_log_table_blob_t,_Compare = std::less<long unsigned int>,_Alloc = std::allocator<std::pair<const long unsigned int,row_log_table_blob_t> >,std::map<_Key,_Tp,_Compare,_Alloc>::iterator = std::_Rb_tree_iterator<std::pair<const long unsigned int,row_log_table_blob_t> >,std::map<_Key,_Tp,_Compare,_Alloc>::key_type = long unsigned int]"
"row_log_table_blob_alloc(dict_index_t*,ulint)" -> "_Alloc>::end() [with _Key = long unsigned int,_Tp = row_log_table_blob_t,_Compare = std::less<long unsigned int>,_Alloc = std::allocator<std::pair<const long unsigned int,row_log_table_blob_t> >,std::map<_Key,_Tp,_Compare,_Alloc>::iterator = std::_Rb_tree_iterator<std::pair<const long unsigned int,row_log_table_blob_t> >]"
"row_log_table_blob_alloc(dict_index_t*,ulint)" -> "std::_Rb_tree_iterator<_Tp>::operator->() const [with _Tp = std::pair<const long unsigned int,row_log_table_blob_t>,std::_Rb_tree_iterator<_Tp>::pointer = std::pair<const long unsigned int,row_log_table_blob_t>*]"
"row_log_table_blob_alloc(dict_index_t*,ulint)" -> "std::_Rb_tree_iterator<_Tp>::operator!=(const _Self&) const [with _Tp = std::pair<const long unsigned int,row_log_table_blob_t>,std::_Rb_tree_iterator<_Tp>::_Self = std::_Rb_tree_iterator<std::pair<const long unsigned int,row_log_table_blob_t> >]"
"_Alloc>::find(const key_type&) [with _Key = long unsigned int,_Tp = row_log_table_blob_t,_Compare = std::less<long unsigned int>,_Alloc = std::allocator<std::pair<const long unsigned int,row_log_table_blob_t> >,std::map<_Key,_Tp,_Compare,_Alloc>::iterator = std::_Rb_tree_iterator<std::pair<const long unsigned int,row_log_table_blob_t> >,std::map<_Key,_Tp,_Compare,_Alloc>::key_type = long unsigned int]" -> "_Alloc>::find(const _Key&) [with _Key = long unsigned int,_Val = std::pair<const long unsigned int,row_log_table_blob_t>,_KeyOfValue = std::_Select1st<std::pair<const long unsigned int,row_log_table_blob_t> >,_Compare = std::less<long unsigned int>,_Alloc = std::allocator<std::pair<const long unsigned int,row_log_table_blob_t> >,std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::iterator = std::_Rb_tree_iterator<std::pair<const long unsigned int,row_log_table_blob_t> >]"
"_Alloc>::find(const _Key&) [with _Key = long unsigned int,_Val = std::pair<const long unsigned int,row_log_table_blob_t>,_KeyOfValue = std::_Select1st<std::pair<const long unsigned int,row_log_table_blob_t> >,_Compare = std::less<long unsigned int>,_Alloc = std::allocator<std::pair<const long unsigned int,row_log_table_blob_t> >,std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::iterator = std::_Rb_tree_iterator<std::pair<const long unsigned int,row_log_table_blob_t> >]" -> "_Alloc>::_M_begin() [with _Key = long unsigned int,_Val = std::pair<const long unsigned int,row_log_table_blob_t>,_KeyOfValue = std::_Select1st<std::pair<const long unsigned int,row_log_table_blob_t> >,_Compare = std::less<long unsigned int>,_Alloc = std::allocator<std::pair<const long unsigned int,row_log_table_blob_t> >,std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::_Link_type = std::_Rb_tree_node<std::pair<const long unsigned int,row_log_table_blob_t> >*]"
"_Alloc>::find(const _Key&) [with _Key = long unsigned int,_Val = std::pair<const long unsigned int,row_log_table_blob_t>,_KeyOfValue = std::_Select1st<std::pair<const long unsigned int,row_log_table_blob_t> >,_Compare = std::less<long unsigned int>,_Alloc = std::allocator<std::pair<const long unsigned int,row_log_table_blob_t> >,std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::iterator = std::_Rb_tree_iterator<std::pair<const long unsigned int,row_log_table_blob_t> >]" -> "_Alloc>::_M_end() [with _Key = long unsigned int,_Val = std::pair<const long unsigned int,row_log_table_blob_t>,_KeyOfValue = std::_Select1st<std::pair<const long unsigned int,row_log_table_blob_t> >,_Compare = std::less<long unsigned int>,_Alloc = std::allocator<std::pair<const long unsigned int,row_log_table_blob_t> >,std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::_Link_type = std::_Rb_tree_node<std::pair<const long unsigned int,row_log_table_blob_t> >*]"
"_Alloc>::find(const _Key&) [with _Key = long unsigned int,_Val = std::pair<const long unsigned int,row_log_table_blob_t>,_KeyOfValue = std::_Select1st<std::pair<const long unsigned int,row_log_table_blob_t> >,_Compare = std::less<long unsigned int>,_Alloc = std::allocator<std::pair<const long unsigned int,row_log_table_blob_t> >,std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::iterator = std::_Rb_tree_iterator<std::pair<const long unsigned int,row_log_table_blob_t> >]" -> "_Alloc>::_M_lower_bound(std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::_Link_type,std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::_Link_type,const _Key&) [with _Key = long unsigned int,_Val = std::pair<const long unsigned int,row_log_table_blob_t>,_KeyOfValue = std::_Select1st<std::pair<const long unsigned int,row_log_table_blob_t> >,_Compare = std::less<long unsigned int>,_Alloc = std::allocator<std::pair<const long unsigned int,row_log_table_blob_t> >,std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::iterator = std::_Rb_tree_iterator<std::pair<const long unsigned int,row_log_table_blob_t> >,std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::_Link_type = std::_Rb_tree_node<std::pair<const long unsigned int,row_log_table_blob_t> >*]"
"_Alloc>::find(const _Key&) [with _Key = long unsigned int,_Val = std::pair<const long unsigned int,row_log_table_blob_t>,_KeyOfValue = std::_Select1st<std::pair<const long unsigned int,row_log_table_blob_t> >,_Compare = std::less<long unsigned int>,_Alloc = std::allocator<std::pair<const long unsigned int,row_log_table_blob_t> >,std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::iterator = std::_Rb_tree_iterator<std::pair<const long unsigned int,row_log_table_blob_t> >]" -> "_Alloc>::_S_key(std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::_Const_Base_ptr) [with _Key = long unsigned int,_Val = std::pair<const long unsigned int,row_log_table_blob_t>,_KeyOfValue = std::_Select1st<std::pair<const long unsigned int,row_log_table_blob_t> >,_Compare = std::less<long unsigned int>,_Alloc = std::allocator<std::pair<const long unsigned int,row_log_table_blob_t> >,std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::_Const_Base_ptr = const std::_Rb_tree_node_base*]"
"_Alloc>::find(const _Key&) [with _Key = long unsigned int,_Val = std::pair<const long unsigned int,row_log_table_blob_t>,_KeyOfValue = std::_Select1st<std::pair<const long unsigned int,row_log_table_blob_t> >,_Compare = std::less<long unsigned int>,_Alloc = std::allocator<std::pair<const long unsigned int,row_log_table_blob_t> >,std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::iterator = std::_Rb_tree_iterator<std::pair<const long unsigned int,row_log_table_blob_t> >]" -> "_Alloc>::end() [with _Key = long unsigned int,_Val = std::pair<const long unsigned int,row_log_table_blob_t>,_KeyOfValue = std::_Select1st<std::pair<const long unsigned int,row_log_table_blob_t> >,_Compare = std::less<long unsigned int>,_Alloc = std::allocator<std::pair<const long unsigned int,row_log_table_blob_t> >,std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::iterator = std::_Rb_tree_iterator<std::pair<const long unsigned int,row_log_table_blob_t> >]"
"_Alloc>::find(const _Key&) [with _Key = long unsigned int,_Val = std::pair<const long unsigned int,row_log_table_blob_t>,_KeyOfValue = std::_Select1st<std::pair<const long unsigned int,row_log_table_blob_t> >,_Compare = std::less<long unsigned int>,_Alloc = std::allocator<std::pair<const long unsigned int,row_log_table_blob_t> >,std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::iterator = std::_Rb_tree_iterator<std::pair<const long unsigned int,row_log_table_blob_t> >]" -> "std::less<_Tp>::operator()(const _Tp&,const _Tp&) const [with _Tp = long unsigned int]"
"_Alloc>::find(const _Key&) [with _Key = long unsigned int,_Val = std::pair<const long unsigned int,row_log_table_blob_t>,_KeyOfValue = std::_Select1st<std::pair<const long unsigned int,row_log_table_blob_t> >,_Compare = std::less<long unsigned int>,_Alloc = std::allocator<std::pair<const long unsigned int,row_log_table_blob_t> >,std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::iterator = std::_Rb_tree_iterator<std::pair<const long unsigned int,row_log_table_blob_t> >]" -> "std::_Rb_tree_iterator<_Tp>::operator==(const _Self&) const [with _Tp = std::pair<const long unsigned int,row_log_table_blob_t>,std::_Rb_tree_iterator<_Tp>::_Self = std::_Rb_tree_iterator<std::pair<const long unsigned int,row_log_table_blob_t> >]"
"_Alloc>::_M_lower_bound(std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::_Link_type,std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::_Link_type,const _Key&) [with _Key = long unsigned int,_Val = std::pair<const long unsigned int,row_log_table_blob_t>,_KeyOfValue = std::_Select1st<std::pair<const long unsigned int,row_log_table_blob_t> >,_Compare = std::less<long unsigned int>,_Alloc = std::allocator<std::pair<const long unsigned int,row_log_table_blob_t> >,std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::iterator = std::_Rb_tree_iterator<std::pair<const long unsigned int,row_log_table_blob_t> >,std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::_Link_type = std::_Rb_tree_node<std::pair<const long unsigned int,row_log_table_blob_t> >*]" -> "_Alloc>::_S_right(std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::_Base_ptr) [with _Key = long unsigned int,_Val = std::pair<const long unsigned int,row_log_table_blob_t>,_KeyOfValue = std::_Select1st<std::pair<const long unsigned int,row_log_table_blob_t> >,_Compare = std::less<long unsigned int>,_Alloc = std::allocator<std::pair<const long unsigned int,row_log_table_blob_t> >,std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::_Link_type = std::_Rb_tree_node<std::pair<const long unsigned int,row_log_table_blob_t> >*,std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::_Base_ptr = std::_Rb_tree_node_base*]"
"_Alloc>::_M_lower_bound(std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::_Link_type,std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::_Link_type,const _Key&) [with _Key = long unsigned int,_Val = std::pair<const long unsigned int,row_log_table_blob_t>,_KeyOfValue = std::_Select1st<std::pair<const long unsigned int,row_log_table_blob_t> >,_Compare = std::less<long unsigned int>,_Alloc = std::allocator<std::pair<const long unsigned int,row_log_table_blob_t> >,std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::iterator = std::_Rb_tree_iterator<std::pair<const long unsigned int,row_log_table_blob_t> >,std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::_Link_type = std::_Rb_tree_node<std::pair<const long unsigned int,row_log_table_blob_t> >*]" -> "_Alloc>::_S_left(std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::_Base_ptr) [with _Key = long unsigned int,_Val = std::pair<const long unsigned int,row_log_table_blob_t>,_KeyOfValue = std::_Select1st<std::pair<const long unsigned int,row_log_table_blob_t> >,_Compare = std::less<long unsigned int>,_Alloc = std::allocator<std::pair<const long unsigned int,row_log_table_blob_t> >,std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::_Link_type = std::_Rb_tree_node<std::pair<const long unsigned int,row_log_table_blob_t> >*,std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::_Base_ptr = std::_Rb_tree_node_base*]"
"_Alloc>::_M_lower_bound(std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::_Link_type,std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::_Link_type,const _Key&) [with _Key = long unsigned int,_Val = std::pair<const long unsigned int,row_log_table_blob_t>,_KeyOfValue = std::_Select1st<std::pair<const long unsigned int,row_log_table_blob_t> >,_Compare = std::less<long unsigned int>,_Alloc = std::allocator<std::pair<const long unsigned int,row_log_table_blob_t> >,std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::iterator = std::_Rb_tree_iterator<std::pair<const long unsigned int,row_log_table_blob_t> >,std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::_Link_type = std::_Rb_tree_node<std::pair<const long unsigned int,row_log_table_blob_t> >*]" -> "_Alloc>::_S_key(std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::_Const_Link_type) [with _Key = long unsigned int,_Val = std::pair<const long unsigned int,row_log_table_blob_t>,_KeyOfValue = std::_Select1st<std::pair<const long unsigned int,row_log_table_blob_t> >,_Compare = std::less<long unsigned int>,_Alloc = std::allocator<std::pair<const long unsigned int,row_log_table_blob_t> >,std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::_Const_Link_type = const std::_Rb_tree_node<std::pair<const long unsigned int,row_log_table_blob_t> >*]"
"_Alloc>::_M_lower_bound(std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::_Link_type,std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::_Link_type,const _Key&) [with _Key = long unsigned int,_Val = std::pair<const long unsigned int,row_log_table_blob_t>,_KeyOfValue = std::_Select1st<std::pair<const long unsigned int,row_log_table_blob_t> >,_Compare = std::less<long unsigned int>,_Alloc = std::allocator<std::pair<const long unsigned int,row_log_table_blob_t> >,std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::iterator = std::_Rb_tree_iterator<std::pair<const long unsigned int,row_log_table_blob_t> >,std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::_Link_type = std::_Rb_tree_node<std::pair<const long unsigned int,row_log_table_blob_t> >*]" -> "std::_Rb_tree_iterator<_Tp>::_Rb_tree_iterator(std::_Rb_tree_iterator<_Tp>::_Link_type) [with _Tp = std::pair<const long unsigned int,row_log_table_blob_t>,std::_Rb_tree_iterator<_Tp>::_Link_type = std::_Rb_tree_node<std::pair<const long unsigned int,row_log_table_blob_t> >*]"
"_Alloc>::_M_lower_bound(std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::_Link_type,std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::_Link_type,const _Key&) [with _Key = long unsigned int,_Val = std::pair<const long unsigned int,row_log_table_blob_t>,_KeyOfValue = std::_Select1st<std::pair<const long unsigned int,row_log_table_blob_t> >,_Compare = std::less<long unsigned int>,_Alloc = std::allocator<std::pair<const long unsigned int,row_log_table_blob_t> >,std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::iterator = std::_Rb_tree_iterator<std::pair<const long unsigned int,row_log_table_blob_t> >,std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::_Link_type = std::_Rb_tree_node<std::pair<const long unsigned int,row_log_table_blob_t> >*]" -> "std::less<_Tp>::operator()(const _Tp&,const _Tp&) const [with _Tp = long unsigned int]"
"_Alloc>::end() [with _Key = long unsigned int,_Val = std::pair<const long unsigned int,row_log_table_blob_t>,_KeyOfValue = std::_Select1st<std::pair<const long unsigned int,row_log_table_blob_t> >,_Compare = std::less<long unsigned int>,_Alloc = std::allocator<std::pair<const long unsigned int,row_log_table_blob_t> >,std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::iterator = std::_Rb_tree_iterator<std::pair<const long unsigned int,row_log_table_blob_t> >]" -> "std::_Rb_tree_iterator<_Tp>::_Rb_tree_iterator(std::_Rb_tree_iterator<_Tp>::_Link_type) [with _Tp = std::pair<const long unsigned int,row_log_table_blob_t>,std::_Rb_tree_iterator<_Tp>::_Link_type = std::_Rb_tree_node<std::pair<const long unsigned int,row_log_table_blob_t> >*]"
"_Alloc>::end() [with _Key = long unsigned int,_Tp = row_log_table_blob_t,_Compare = std::less<long unsigned int>,_Alloc = std::allocator<std::pair<const long unsigned int,row_log_table_blob_t> >,std::map<_Key,_Tp,_Compare,_Alloc>::iterator = std::_Rb_tree_iterator<std::pair<const long unsigned int,row_log_table_blob_t> >]" -> "_Alloc>::end() [with _Key = long unsigned int,_Val = std::pair<const long unsigned int,row_log_table_blob_t>,_KeyOfValue = std::_Select1st<std::pair<const long unsigned int,row_log_table_blob_t> >,_Compare = std::less<long unsigned int>,_Alloc = std::allocator<std::pair<const long unsigned int,row_log_table_blob_t> >,std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::iterator = std::_Rb_tree_iterator<std::pair<const long unsigned int,row_log_table_blob_t> >]"
"row_ins_index_entry_big_rec_func(const dtuple_t*,const big_rec_t*,ulint*,mem_heap_t**,dict_index_t*,const char*,ulint)" -> "btr_cur_search_to_nth_level(dict_index_t*,ulint,const dtuple_t*,ulint,ulint,btr_cur_t*,ulint,const char*,ulint,mtr_t*)"
"row_ins_index_entry_big_rec_func(const dtuple_t*,const big_rec_t*,ulint*,mem_heap_t**,dict_index_t*,const char*,ulint)" -> "rec_get_offsets_func(const rec_t*,const dict_index_t*,ulint*,ulint,mem_heap_t**)"
"row_ins_index_entry_big_rec_func(const dtuple_t*,const big_rec_t*,ulint*,mem_heap_t**,dict_index_t*,const char*,ulint)" -> "dict_index_is_online_ddl(const dict_index_t*)"
"row_ins_index_entry_big_rec_func(const dtuple_t*,const big_rec_t*,ulint*,mem_heap_t**,dict_index_t*,const char*,ulint)" -> "row_log_table_insert(const rec_t*,dict_index_t*,const ulint*)"
"row_ins_index_entry_big_rec_func(const dtuple_t*,const big_rec_t*,ulint*,mem_heap_t**,dict_index_t*,const char*,ulint)" -> "mtr_start(mtr_t*)"
"row_ins_index_entry_big_rec_func(const dtuple_t*,const big_rec_t*,ulint*,mem_heap_t**,dict_index_t*,const char*,ulint)" -> "btr_store_big_rec_extern_fields(dict_index_t*,buf_block_t*,rec_t*,const ulint*,const big_rec_t*,mtr_t*,blob_op)"
"row_ins_index_entry_big_rec_func(const dtuple_t*,const big_rec_t*,ulint*,mem_heap_t**,dict_index_t*,const char*,ulint)" -> "mtr_commit(mtr_t*)"
"row_ins_duplicate_error_in_clust_online(ulint,const dtuple_t*,const btr_cur_t*,ulint**,mem_heap_t**)" -> "page_rec_is_infimum(const rec_t*)"
"row_ins_duplicate_error_in_clust_online(ulint,const dtuple_t*,const btr_cur_t*,ulint**,mem_heap_t**)" -> "page_rec_is_supremum(const rec_t*)"
"row_ins_duplicate_error_in_clust_online(ulint,const dtuple_t*,const btr_cur_t*,ulint**,mem_heap_t**)" -> "rec_get_offsets_func(const rec_t*,const dict_index_t*,ulint*,ulint,mem_heap_t**)"
"row_ins_duplicate_error_in_clust_online(ulint,const dtuple_t*,const btr_cur_t*,ulint**,mem_heap_t**)" -> "row_ins_duplicate_online(ulint,const dtuple_t*,const rec_t*,ulint*)"
"row_ins_duplicate_error_in_clust_online(ulint,const dtuple_t*,const btr_cur_t*,ulint**,mem_heap_t**)" -> "page_rec_get_next_const(const rec_t*)"
"row_ins_duplicate_online(ulint,const dtuple_t*,const rec_t*,ulint*)" -> "cmp_dtuple_rec_with_match_low(const dtuple_t*,const rec_t*,const ulint*,ulint,ulint*,ulint*)"
"row_ins_duplicate_error_in_clust(ulint,btr_cur_t*,const dtuple_t*,que_thr_t*,mtr_t*)" -> "rec_get_offsets_func(const rec_t*,const dict_index_t*,ulint*,ulint,mem_heap_t**)"
"row_ins_duplicate_error_in_clust(ulint,btr_cur_t*,const dtuple_t*,que_thr_t*,mtr_t*)" -> "row_ins_dupl_error_with_rec(const rec_t*,const dtuple_t*,dict_index_t*,const ulint*)"
"row_ins_duplicate_error_in_clust(ulint,btr_cur_t*,const dtuple_t*,que_thr_t*,mtr_t*)" -> "page_rec_get_next(rec_t*)"
"row_ins_duplicate_error_in_clust(ulint,btr_cur_t*,const dtuple_t*,que_thr_t*,mtr_t*)" -> "rec_offs_set_n_alloc(ulint*,ulint)"
"row_ins_duplicate_error_in_clust(ulint,btr_cur_t*,const dtuple_t*,que_thr_t*,mtr_t*)" -> "mem_heap_free_func(mem_heap_t*,const char*,ulint)"
"row_ins_duplicate_error_in_clust(ulint,btr_cur_t*,const dtuple_t*,que_thr_t*,mtr_t*)" -> "row_ins_set_exclusive_rec_lock(ulint,const buf_block_t*,const rec_t*,dict_index_t*,const ulint*,que_thr_t*)"
"row_ins_duplicate_error_in_clust(ulint,btr_cur_t*,const dtuple_t*,que_thr_t*,mtr_t*)" -> "dict_index_get_n_unique(const dict_index_t*)"
"row_ins_duplicate_error_in_clust(ulint,btr_cur_t*,const dtuple_t*,que_thr_t*,mtr_t*)" -> "thr_get_trx(que_thr_t*)"
"row_ins_duplicate_error_in_clust(ulint,btr_cur_t*,const dtuple_t*,que_thr_t*,mtr_t*)" -> "page_rec_is_supremum(const rec_t*)"
"row_ins_duplicate_error_in_clust(ulint,btr_cur_t*,const dtuple_t*,que_thr_t*,mtr_t*)" -> "__builtin_expect(long int,long int)"
"row_ins_duplicate_error_in_clust(ulint,btr_cur_t*,const dtuple_t*,que_thr_t*,mtr_t*)" -> "page_rec_is_infimum(const rec_t*)"
"row_ins_duplicate_error_in_clust(ulint,btr_cur_t*,const dtuple_t*,que_thr_t*,mtr_t*)" -> "row_ins_set_shared_rec_lock(ulint,const buf_block_t*,const rec_t*,dict_index_t*,const ulint*,que_thr_t*)"
"row_ins_duplicate_error_in_clust(ulint,btr_cur_t*,const dtuple_t*,que_thr_t*,mtr_t*)" -> "ut_dbg_assertion_failed(const char*,const char*,ulint)"
"row_ins_duplicate_error_in_clust(ulint,btr_cur_t*,const dtuple_t*,que_thr_t*,mtr_t*)" -> "abort()"
"row_ins_dupl_error_with_rec(const rec_t*,const dtuple_t*,dict_index_t*,const ulint*)" -> "dict_index_get_n_unique(const dict_index_t*)"
"row_ins_dupl_error_with_rec(const rec_t*,const dtuple_t*,dict_index_t*,const ulint*)" -> "dict_index_is_clust(const dict_index_t*)"
"row_ins_dupl_error_with_rec(const rec_t*,const dtuple_t*,dict_index_t*,const ulint*)" -> "rec_get_deleted_flag(const rec_t*,ulint)"
"row_ins_dupl_error_with_rec(const rec_t*,const dtuple_t*,dict_index_t*,const ulint*)" -> "dfield_is_null(const dfield_t*)"
"row_ins_dupl_error_with_rec(const rec_t*,const dtuple_t*,dict_index_t*,const ulint*)" -> "cmp_dtuple_rec_with_match_low(const dtuple_t*,const rec_t*,const ulint*,ulint,ulint*,ulint*)"
"row_ins_dupl_error_with_rec(const rec_t*,const dtuple_t*,dict_index_t*,const ulint*)" -> "dtuple_get_n_fields_cmp(const dtuple_t*)"
"row_ins_dupl_error_with_rec(const rec_t*,const dtuple_t*,dict_index_t*,const ulint*)" -> "rec_offs_comp(const ulint*)"
"row_ins_set_exclusive_rec_lock(ulint,const buf_block_t*,const rec_t*,dict_index_t*,const ulint*,que_thr_t*)" -> "dict_index_is_clust(const dict_index_t*)"
"row_ins_set_exclusive_rec_lock(ulint,const buf_block_t*,const rec_t*,dict_index_t*,const ulint*,que_thr_t*)" -> "lock_clust_rec_read_check_and_lock(ulint,const buf_block_t*,const rec_t*,dict_index_t*,const ulint*,lock_mode,ulint,que_thr_t*)"
"row_ins_set_exclusive_rec_lock(ulint,const buf_block_t*,const rec_t*,dict_index_t*,const ulint*,que_thr_t*)" -> "lock_sec_rec_read_check_and_lock(ulint,const buf_block_t*,const rec_t*,dict_index_t*,const ulint*,lock_mode,ulint,que_thr_t*)"
"row_upd_clust_rec_by_insert_inherit_func(dtuple_t*,const upd_t*)" -> "abort()"
"row_upd_clust_rec_by_insert_inherit_func(dtuple_t*,const upd_t*)" -> "memcmp(const void*,const void*,size_t)"
"row_upd_clust_rec_by_insert_inherit_func(dtuple_t*,const upd_t*)" -> "upd_get_field_by_field_no(const upd_t*,ulint)"
"row_upd_clust_rec_by_insert_inherit_func(dtuple_t*,const upd_t*)" -> "ut_dbg_assertion_failed(const char*,const char*,ulint)"
"row_upd_clust_rec_by_insert_inherit_func(dtuple_t*,const upd_t*)" -> "__builtin_expect(long int,long int)"
"row_upd_clust_rec_by_insert_inherit_func(dtuple_t*,const upd_t*)" -> "dtuple_get_n_fields(const dtuple_t*)"
"row_upd_clust_rec_by_insert_inherit_func(dtuple_t*,const upd_t*)" -> "dfield_get_len(const dfield_t*)"
"row_upd_clust_rec_by_insert_inherit_func(dtuple_t*,const upd_t*)" -> "dfield_is_ext(const dfield_t*)"
"dict_drop_index_tree(rec_t*,mtr_t*)" -> "mtr_read_ulint(const unsigned char*,ulint,mtr_t*)"
"dict_drop_index_tree(rec_t*,mtr_t*)" -> "__builtin_expect(long int,long int)"
"dict_drop_index_tree(rec_t*,mtr_t*)" -> "btr_free_but_not_root(ulint,ulint,ulint)"
"dict_drop_index_tree(rec_t*,mtr_t*)" -> "abort()"
"dict_drop_index_tree(rec_t*,mtr_t*)" -> "fil_space_get_zip_size(ulint)"
"dict_drop_index_tree(rec_t*,mtr_t*)" -> "btr_free_root(ulint,ulint,ulint,mtr_t*)"
"dict_drop_index_tree(rec_t*,mtr_t*)" -> "dict_table_is_comp(const dict_table_t*)"
"dict_drop_index_tree(rec_t*,mtr_t*)" -> "ut_dbg_assertion_failed(const char*,const char*,ulint)"
"dict_drop_index_tree(rec_t*,mtr_t*)" -> "page_rec_write_field(rec_t*,ulint,ulint,mtr_t*)"
"dict_drop_index_tree(rec_t*,mtr_t*)" -> "rec_get_nth_field_offs_old(const rec_t*,ulint,ulint*)"
"btr_free_but_not_root(ulint,ulint,ulint)" -> "mtr_commit(mtr_t*)"
"btr_free_but_not_root(ulint,ulint,ulint)" -> "abort()"
"btr_free_but_not_root(ulint,ulint,ulint)" -> "mtr_start(mtr_t*)"
"btr_free_but_not_root(ulint,ulint,ulint)" -> "fseg_free_step(fseg_header_t*,mtr_t*)"
"btr_free_but_not_root(ulint,ulint,ulint)" -> "btr_root_fseg_validate(const fseg_header_t*,ulint)"
"btr_free_but_not_root(ulint,ulint,ulint)" -> "btr_block_get_func(ulint,ulint,ulint,ulint,const char*,ulint,mtr_t*)"
"btr_free_but_not_root(ulint,ulint,ulint)" -> "__builtin_expect(long int,long int)"
"btr_free_but_not_root(ulint,ulint,ulint)" -> "ut_dbg_assertion_failed(const char*,const char*,ulint)"
"btr_free_but_not_root(ulint,ulint,ulint)" -> "fseg_free_step_not_header(fseg_header_t*,mtr_t*)"
"fseg_free_step_not_header(fseg_header_t*,mtr_t*)" -> "page_get_page_no(const ib_page_t*)"
"fseg_free_step_not_header(fseg_header_t*,mtr_t*)" -> "page_get_space_id(const ib_page_t*)"
"fseg_free_step_not_header(fseg_header_t*,mtr_t*)" -> "fil_space_get_latch(ulint,ulint*)"
"fseg_free_step_not_header(fseg_header_t*,mtr_t*)" -> "fseg_get_first_extent(fseg_inode_t*,ulint,ulint,mtr_t*)"
"fseg_free_step_not_header(fseg_header_t*,mtr_t*)" -> "fseg_free_extent(fseg_inode_t*,ulint,ulint,ulint,mtr_t*)"
"fseg_free_step_not_header(fseg_header_t*,mtr_t*)" -> "page_align(const void*)"
"fseg_free_step_not_header(fseg_header_t*,mtr_t*)" -> "fseg_free_page_low(fseg_inode_t*,ulint,ulint,ulint,mtr_t*)"
"fseg_free_step_not_header(fseg_header_t*,mtr_t*)" -> "ut_dbg_assertion_failed(const char*,const char*,ulint)"
"fseg_free_step_not_header(fseg_header_t*,mtr_t*)" -> "xdes_get_offset(const xdes_t*)"
"fseg_free_step_not_header(fseg_header_t*,mtr_t*)" -> "mtr_x_lock_func(rw_lock_t*,const char*,ulint,mtr_t*)"
"fseg_free_step_not_header(fseg_header_t*,mtr_t*)" -> "fseg_inode_get(fseg_header_t*,ulint,ulint,mtr_t*)"
"fseg_free_step_not_header(fseg_header_t*,mtr_t*)" -> "fseg_get_nth_frag_page_no(fseg_inode_t*,ulint,mtr_t*)"
"fseg_free_step_not_header(fseg_header_t*,mtr_t*)" -> "fseg_find_last_used_frag_page_slot(fseg_inode_t*,mtr_t*)"
"fseg_free_step_not_header(fseg_header_t*,mtr_t*)" -> "abort()"
"fseg_free_step_not_header(fseg_header_t*,mtr_t*)" -> "fsp_flags_get_zip_size(ulint)"
"page_rec_write_field(rec_t*,ulint,ulint,mtr_t*)" -> "mlog_write_ulint(unsigned char*,ulint,unsigned char,mtr_t*)"
"page_rec_write_field(rec_t*,ulint,ulint,mtr_t*)" -> "rec_get_nth_field_offs_old(const rec_t*,ulint,ulint*)"
"row_upd_eval_new_vals(upd_t*)" -> "eval_exp(que_node_t*)"
"row_upd_eval_new_vals(upd_t*)" -> "upd_get_n_fields(const upd_t*)"
"row_upd_eval_new_vals(upd_t*)" -> "que_node_get_val(que_node_t*)"
"row_upd_eval_new_vals(upd_t*)" -> "dfield_copy_data(dfield_t*,const dfield_t*)"
"row_upd_clust_rec(upd_node_t*,dict_index_t*,ulint*,mem_heap_t**,que_thr_t*,mtr_t*)" -> "row_log_table_get_pk(const rec_t*,dict_index_t*,const ulint*,unsigned char*,mem_heap_t**)"
"row_upd_clust_rec(upd_node_t*,dict_index_t*,ulint*,mem_heap_t**,que_thr_t*,mtr_t*)" -> "mtr_commit(mtr_t*)"
"row_upd_clust_rec(upd_node_t*,dict_index_t*,ulint*,mem_heap_t**,que_thr_t*,mtr_t*)" -> "buf_LRU_buf_pool_running_out()"
"row_upd_clust_rec(upd_node_t*,dict_index_t*,ulint*,mem_heap_t**,que_thr_t*,mtr_t*)" -> "mtr_start(mtr_t*)"
"row_upd_clust_rec(upd_node_t*,dict_index_t*,ulint*,mem_heap_t**,que_thr_t*,mtr_t*)" -> "btr_cur_update_in_place(ulint,btr_cur_t*,ulint*,const upd_t*,ulint,que_thr_t*,trx_id_t,mtr_t*)"
"row_upd_clust_rec(upd_node_t*,dict_index_t*,ulint*,mem_heap_t**,que_thr_t*,mtr_t*)" -> "thr_get_trx(que_thr_t*)"
"row_upd_clust_rec(upd_node_t*,dict_index_t*,ulint*,mem_heap_t**,que_thr_t*,mtr_t*)" -> "mem_heap_free_func(mem_heap_t*,const char*,ulint)"
"row_upd_clust_rec(upd_node_t*,dict_index_t*,ulint*,mem_heap_t**,que_thr_t*,mtr_t*)" -> "btr_cur_pessimistic_update(ulint,btr_cur_t*,ulint**,mem_heap_t**,mem_heap_t*,big_rec_t**,const upd_t*,ulint,que_thr_t*,trx_id_t,mtr_t*)"
"row_upd_clust_rec(upd_node_t*,dict_index_t*,ulint*,mem_heap_t**,que_thr_t*,mtr_t*)" -> "btr_store_big_rec_extern_fields(dict_index_t*,buf_block_t*,rec_t*,const ulint*,const big_rec_t*,mtr_t*,blob_op)"
"row_upd_clust_rec(upd_node_t*,dict_index_t*,ulint*,mem_heap_t**,que_thr_t*,mtr_t*)" -> "abort()"
"row_upd_clust_rec(upd_node_t*,dict_index_t*,ulint*,mem_heap_t**,que_thr_t*,mtr_t*)" -> "ut_dbg_assertion_failed(const char*,const char*,ulint)"
"row_upd_clust_rec(upd_node_t*,dict_index_t*,ulint*,mem_heap_t**,que_thr_t*,mtr_t*)" -> "__builtin_expect(long int,long int)"
"row_upd_clust_rec(upd_node_t*,dict_index_t*,ulint*,mem_heap_t**,que_thr_t*,mtr_t*)" -> "mem_heap_create_func(ulint,ulint)"
"row_upd_clust_rec(upd_node_t*,dict_index_t*,ulint*,mem_heap_t**,que_thr_t*,mtr_t*)" -> "btr_pcur_restore_position_func(ulint,btr_pcur_t*,const char*,ulint,mtr_t*)"
"row_upd_clust_rec(upd_node_t*,dict_index_t*,ulint*,mem_heap_t**,que_thr_t*,mtr_t*)" -> "dtuple_big_rec_free(big_rec_t*)"
"row_upd_clust_rec(upd_node_t*,dict_index_t*,ulint*,mem_heap_t**,que_thr_t*,mtr_t*)" -> "row_log_table_update(const rec_t*,dict_index_t*,const ulint*,const dtuple_t*)"
"row_upd_clust_rec(upd_node_t*,dict_index_t*,ulint*,mem_heap_t**,que_thr_t*,mtr_t*)" -> "dict_index_is_online_ddl(const dict_index_t*)"
"row_upd_clust_rec(upd_node_t*,dict_index_t*,ulint*,mem_heap_t**,que_thr_t*,mtr_t*)" -> "btr_cur_optimistic_update(ulint,btr_cur_t*,ulint**,mem_heap_t**,const upd_t*,ulint,que_thr_t*,trx_id_t,mtr_t*)"
"row_log_table_update(const rec_t*,dict_index_t*,const ulint*,const dtuple_t*)" -> "row_log_table_low(const rec_t*,dict_index_t*,const ulint*,bool,const dtuple_t*)"
"row_upd_copy_columns(rec_t*,const ulint*,sym_node_t*)" -> "rec_get_nth_field_offs(const ulint*,ulint,ulint*)"
"row_upd_copy_columns(rec_t*,const ulint*,sym_node_t*)" -> "eval_node_copy_and_alloc_val(que_node_t*,const unsigned char*,ulint)"
"row_ins_sec_index_entry_low(ulint,ulint,dict_index_t*,mem_heap_t*,mem_heap_t*,dtuple_t*,trx_id_t,que_thr_t*)" -> "row_ins_sec_mtr_start_and_check_if_aborted(mtr_t*,dict_index_t*,bool,ulint)"
"row_ins_sec_index_entry_low(ulint,ulint,dict_index_t*,mem_heap_t*,mem_heap_t*,dtuple_t*,trx_id_t,que_thr_t*)" -> "mtr_commit(mtr_t*)"
"row_ins_sec_index_entry_low(ulint,ulint,dict_index_t*,mem_heap_t*,mem_heap_t*,dtuple_t*,trx_id_t,que_thr_t*)" -> "dict_set_corrupted_index_cache_only(dict_index_t*,dict_table_t*)"
"row_ins_sec_index_entry_low(ulint,ulint,dict_index_t*,mem_heap_t*,mem_heap_t*,dtuple_t*,trx_id_t,que_thr_t*)" -> "page_update_max_trx_id(buf_block_t*,page_zip_des_t*,trx_id_t,mtr_t*)"
"row_ins_sec_index_entry_low(ulint,ulint,dict_index_t*,mem_heap_t*,mem_heap_t*,dtuple_t*,trx_id_t,que_thr_t*)" -> "pfs_mutex_enter_func(ib_mutex_t*,const char*,ulint)"
"row_ins_sec_index_entry_low(ulint,ulint,dict_index_t*,mem_heap_t*,mem_heap_t*,dtuple_t*,trx_id_t,que_thr_t*)" -> "row_ins_must_modify_rec(const btr_cur_t*)"
"row_ins_sec_index_entry_low(ulint,ulint,dict_index_t*,mem_heap_t*,mem_heap_t*,dtuple_t*,trx_id_t,que_thr_t*)" -> "dict_index_get_n_unique(const dict_index_t*)"
"row_ins_sec_index_entry_low(ulint,ulint,dict_index_t*,mem_heap_t*,mem_heap_t*,dtuple_t*,trx_id_t,que_thr_t*)" -> "dict_index_get_lock(dict_index_t*)"
"row_ins_sec_index_entry_low(ulint,ulint,dict_index_t*,mem_heap_t*,mem_heap_t*,dtuple_t*,trx_id_t,que_thr_t*)" -> "btr_cur_pessimistic_insert(ulint,btr_cur_t*,ulint**,mem_heap_t**,dtuple_t*,rec_t**,big_rec_t**,ulint,que_thr_t*,mtr_t*)"
"row_ins_sec_index_entry_low(ulint,ulint,dict_index_t*,mem_heap_t*,mem_heap_t*,dtuple_t*,trx_id_t,que_thr_t*)" -> "mtr_start(mtr_t*)"
"row_ins_sec_index_entry_low(ulint,ulint,dict_index_t*,mem_heap_t*,mem_heap_t*,dtuple_t*,trx_id_t,que_thr_t*)" -> "pfs_mutex_exit_func(ib_mutex_t*)"
"row_ins_sec_index_entry_low(ulint,ulint,dict_index_t*,mem_heap_t*,mem_heap_t*,dtuple_t*,trx_id_t,que_thr_t*)" -> "buf_LRU_buf_pool_running_out()"
"row_ins_sec_index_entry_low(ulint,ulint,dict_index_t*,mem_heap_t*,mem_heap_t*,dtuple_t*,trx_id_t,que_thr_t*)" -> "btr_cur_search_to_nth_level(dict_index_t*,ulint,const dtuple_t*,ulint,ulint,btr_cur_t*,ulint,const char*,ulint,mtr_t*)"
"row_ins_sec_index_entry_low(ulint,ulint,dict_index_t*,mem_heap_t*,mem_heap_t*,dtuple_t*,trx_id_t,que_thr_t*)" -> "row_ins_sec_index_entry_by_modify(ulint,ulint,btr_cur_t*,ulint**,mem_heap_t*,mem_heap_t*,const dtuple_t*,que_thr_t*,mtr_t*)"
"row_ins_sec_index_entry_low(ulint,ulint,dict_index_t*,mem_heap_t*,mem_heap_t*,dtuple_t*,trx_id_t,que_thr_t*)" -> "rec_get_offsets_func(const rec_t*,const dict_index_t*,ulint*,ulint,mem_heap_t**)"
"row_ins_sec_index_entry_low(ulint,ulint,dict_index_t*,mem_heap_t*,mem_heap_t*,dtuple_t*,trx_id_t,que_thr_t*)" -> "row_log_online_op_try(dict_index_t*,const dtuple_t*,trx_id_t)"
"row_ins_sec_index_entry_low(ulint,ulint,dict_index_t*,mem_heap_t*,mem_heap_t*,dtuple_t*,trx_id_t,que_thr_t*)" -> "thr_get_trx(que_thr_t*)"
"row_ins_sec_index_entry_low(ulint,ulint,dict_index_t*,mem_heap_t*,mem_heap_t*,dtuple_t*,trx_id_t,que_thr_t*)" -> "btr_cur_optimistic_insert(ulint,btr_cur_t*,ulint**,mem_heap_t**,dtuple_t*,rec_t**,big_rec_t**,ulint,que_thr_t*,mtr_t*)"
"row_ins_sec_index_entry_low(ulint,ulint,dict_index_t*,mem_heap_t*,mem_heap_t*,dtuple_t*,trx_id_t,que_thr_t*)" -> "btr_cur_get_page_zip(btr_cur_t*)"
"row_ins_sec_index_entry_low(ulint,ulint,dict_index_t*,mem_heap_t*,mem_heap_t*,dtuple_t*,trx_id_t,que_thr_t*)" -> "mtr_x_lock_func(rw_lock_t*,const char*,ulint,mtr_t*)"
"row_ins_sec_index_entry_low(ulint,ulint,dict_index_t*,mem_heap_t*,mem_heap_t*,dtuple_t*,trx_id_t,que_thr_t*)" -> "mtr_s_lock_func(rw_lock_t*,const char*,ulint,mtr_t*)"
"row_ins_sec_index_entry_low(ulint,ulint,dict_index_t*,mem_heap_t*,mem_heap_t*,dtuple_t*,trx_id_t,que_thr_t*)" -> "dict_index_is_unique(const dict_index_t*)"
"row_ins_sec_index_entry_low(ulint,ulint,dict_index_t*,mem_heap_t*,mem_heap_t*,dtuple_t*,trx_id_t,que_thr_t*)" -> "row_ins_scan_sec_index_for_duplicate(ulint,dict_index_t*,dtuple_t*,que_thr_t*,bool,mtr_t*,mem_heap_t*)"
"row_ins_sec_mtr_start_and_check_if_aborted(mtr_t*,dict_index_t*,bool,ulint)" -> "ut_dbg_assertion_failed(const char*,const char*,ulint)"
"row_ins_sec_mtr_start_and_check_if_aborted(mtr_t*,dict_index_t*,bool,ulint)" -> "abort()"
"row_ins_sec_mtr_start_and_check_if_aborted(mtr_t*,dict_index_t*,bool,ulint)" -> "dict_index_get_lock(dict_index_t*)"
"row_ins_sec_mtr_start_and_check_if_aborted(mtr_t*,dict_index_t*,bool,ulint)" -> "mtr_start(mtr_t*)"
"row_ins_sec_mtr_start_and_check_if_aborted(mtr_t*,dict_index_t*,bool,ulint)" -> "mtr_x_lock_func(rw_lock_t*,const char*,ulint,mtr_t*)"
"row_ins_sec_mtr_start_and_check_if_aborted(mtr_t*,dict_index_t*,bool,ulint)" -> "mtr_s_lock_func(rw_lock_t*,const char*,ulint,mtr_t*)"
"dict_set_corrupted_index_cache_only(dict_index_t*,dict_table_t*)" -> "dict_index_is_clust(const dict_index_t*)"
"row_ins_sec_index_entry_by_modify(ulint,ulint,btr_cur_t*,ulint**,mem_heap_t*,mem_heap_t*,const dtuple_t*,que_thr_t*,mtr_t*)" -> "abort()"
"row_ins_sec_index_entry_by_modify(ulint,ulint,btr_cur_t*,ulint**,mem_heap_t*,mem_heap_t*,const dtuple_t*,que_thr_t*,mtr_t*)" -> "rec_get_deleted_flag(const rec_t*,ulint)"
"row_ins_sec_index_entry_by_modify(ulint,ulint,btr_cur_t*,ulint**,mem_heap_t*,mem_heap_t*,const dtuple_t*,que_thr_t*,mtr_t*)" -> "buf_LRU_buf_pool_running_out()"
"row_ins_sec_index_entry_by_modify(ulint,ulint,btr_cur_t*,ulint**,mem_heap_t*,mem_heap_t*,const dtuple_t*,que_thr_t*,mtr_t*)" -> "btr_cur_pessimistic_update(ulint,btr_cur_t*,ulint**,mem_heap_t**,mem_heap_t*,big_rec_t**,const upd_t*,ulint,que_thr_t*,trx_id_t,mtr_t*)"
"row_ins_sec_index_entry_by_modify(ulint,ulint,btr_cur_t*,ulint**,mem_heap_t*,mem_heap_t*,const dtuple_t*,que_thr_t*,mtr_t*)" -> "row_upd_build_sec_rec_difference_binary(const rec_t*,dict_index_t*,const ulint*,const dtuple_t*,mem_heap_t*)"
"row_ins_sec_index_entry_by_modify(ulint,ulint,btr_cur_t*,ulint**,mem_heap_t*,mem_heap_t*,const dtuple_t*,que_thr_t*,mtr_t*)" -> "btr_cur_optimistic_update(ulint,btr_cur_t*,ulint**,mem_heap_t**,const upd_t*,ulint,que_thr_t*,trx_id_t,mtr_t*)"
"row_ins_sec_index_entry_by_modify(ulint,ulint,btr_cur_t*,ulint**,mem_heap_t*,mem_heap_t*,const dtuple_t*,que_thr_t*,mtr_t*)" -> "ut_dbg_assertion_failed(const char*,const char*,ulint)"
"row_ins_sec_index_entry_by_modify(ulint,ulint,btr_cur_t*,ulint**,mem_heap_t*,mem_heap_t*,const dtuple_t*,que_thr_t*,mtr_t*)" -> "thr_get_trx(que_thr_t*)"
"row_ins_sec_index_entry_by_modify(ulint,ulint,btr_cur_t*,ulint**,mem_heap_t*,mem_heap_t*,const dtuple_t*,que_thr_t*,mtr_t*)" -> "__builtin_expect(long int,long int)"
"row_ins_sec_index_entry_by_modify(ulint,ulint,btr_cur_t*,ulint**,mem_heap_t*,mem_heap_t*,const dtuple_t*,que_thr_t*,mtr_t*)" -> "rec_offs_comp(const ulint*)"
"row_log_online_op_try(dict_index_t*,const dtuple_t*,trx_id_t)" -> "row_log_online_op(dict_index_t*,const dtuple_t*,trx_id_t)"
"row_log_online_op_try(dict_index_t*,const dtuple_t*,trx_id_t)" -> "dict_index_get_online_status(const dict_index_t*)"
"row_ins_scan_sec_index_for_duplicate(ulint,dict_index_t*,dtuple_t*,que_thr_t*,bool,mtr_t*,mem_heap_t*)" -> "dtuple_set_n_fields_cmp(dtuple_t*,ulint)"
"row_ins_scan_sec_index_for_duplicate(ulint,dict_index_t*,dtuple_t*,que_thr_t*,bool,mtr_t*,mem_heap_t*)" -> "row_ins_set_shared_rec_lock(ulint,const buf_block_t*,const rec_t*,dict_index_t*,const ulint*,que_thr_t*)"
"row_ins_scan_sec_index_for_duplicate(ulint,dict_index_t*,dtuple_t*,que_thr_t*,bool,mtr_t*,mem_heap_t*)" -> "strcmp(const char*,const char*)"
"row_ins_scan_sec_index_for_duplicate(ulint,dict_index_t*,dtuple_t*,que_thr_t*,bool,mtr_t*,mem_heap_t*)" -> "thr_get_trx(que_thr_t*)"
"row_ins_scan_sec_index_for_duplicate(ulint,dict_index_t*,dtuple_t*,que_thr_t*,bool,mtr_t*,mem_heap_t*)" -> "rec_get_offsets_func(const rec_t*,const dict_index_t*,ulint*,ulint,mem_heap_t**)"
"row_ins_scan_sec_index_for_duplicate(ulint,dict_index_t*,dtuple_t*,que_thr_t*,bool,mtr_t*,mem_heap_t*)" -> "btr_pcur_open_low(dict_index_t*,ulint,const dtuple_t*,ulint,ulint,btr_pcur_t*,const char*,ulint,mtr_t*)"
"row_ins_scan_sec_index_for_duplicate(ulint,dict_index_t*,dtuple_t*,que_thr_t*,bool,mtr_t*,mem_heap_t*)" -> "page_rec_is_supremum(const rec_t*)"
"row_ins_scan_sec_index_for_duplicate(ulint,dict_index_t*,dtuple_t*,que_thr_t*,bool,mtr_t*,mem_heap_t*)" -> "abort()"
"row_ins_scan_sec_index_for_duplicate(ulint,dict_index_t*,dtuple_t*,que_thr_t*,bool,mtr_t*,mem_heap_t*)" -> "page_rec_is_infimum(const rec_t*)"
"row_ins_scan_sec_index_for_duplicate(ulint,dict_index_t*,dtuple_t*,que_thr_t*,bool,mtr_t*,mem_heap_t*)" -> "ib_logf(ib_log_level_t,const char*,...)"
"row_ins_scan_sec_index_for_duplicate(ulint,dict_index_t*,dtuple_t*,que_thr_t*,bool,mtr_t*,mem_heap_t*)" -> "dict_index_get_n_unique(const dict_index_t*)"
"row_ins_scan_sec_index_for_duplicate(ulint,dict_index_t*,dtuple_t*,que_thr_t*,bool,mtr_t*,mem_heap_t*)" -> "dfield_get_len(const dfield_t*)"
"row_ins_scan_sec_index_for_duplicate(ulint,dict_index_t*,dtuple_t*,que_thr_t*,bool,mtr_t*,mem_heap_t*)" -> "btr_pcur_move_to_next(btr_pcur_t*,mtr_t*)"
"row_ins_scan_sec_index_for_duplicate(ulint,dict_index_t*,dtuple_t*,que_thr_t*,bool,mtr_t*,mem_heap_t*)" -> "dtuple_get_n_fields_cmp(const dtuple_t*)"
"row_ins_scan_sec_index_for_duplicate(ulint,dict_index_t*,dtuple_t*,que_thr_t*,bool,mtr_t*,mem_heap_t*)" -> "cmp_dtuple_rec(const dtuple_t*,const rec_t*,const ulint*)"
"row_ins_scan_sec_index_for_duplicate(ulint,dict_index_t*,dtuple_t*,que_thr_t*,bool,mtr_t*,mem_heap_t*)" -> "row_ins_dupl_error_with_rec(const rec_t*,const dtuple_t*,dict_index_t*,const ulint*)"
"row_ins_scan_sec_index_for_duplicate(ulint,dict_index_t*,dtuple_t*,que_thr_t*,bool,mtr_t*,mem_heap_t*)" -> "row_ins_set_exclusive_rec_lock(ulint,const buf_block_t*,const rec_t*,dict_index_t*,const ulint*,que_thr_t*)"
"row_ins_scan_sec_index_for_duplicate(ulint,dict_index_t*,dtuple_t*,que_thr_t*,bool,mtr_t*,mem_heap_t*)" -> "__builtin_expect(long int,long int)"
"row_ins_scan_sec_index_for_duplicate(ulint,dict_index_t*,dtuple_t*,que_thr_t*,bool,mtr_t*,mem_heap_t*)" -> "ut_dbg_assertion_failed(const char*,const char*,ulint)"
"row_ins_alloc_row_id_step(ins_node_t*)" -> "dict_index_is_unique(const dict_index_t*)"
"row_ins_alloc_row_id_step(ins_node_t*)" -> "dict_sys_write_row_id(unsigned char*,row_id_t)"
"row_ins_alloc_row_id_step(ins_node_t*)" -> "dict_sys_get_new_row_id()"
"dict_sys_write_row_id(unsigned char*,row_id_t)" -> "mach_write_to_6(unsigned char*,ib_uint64_t)"
"dict_sys_get_new_row_id()" -> "pfs_mutex_exit_func(ib_mutex_t*)"
"dict_sys_get_new_row_id()" -> "dict_hdr_flush_row_id()"
"dict_sys_get_new_row_id()" -> "pfs_mutex_enter_func(ib_mutex_t*,const char*,ulint)"
"dict_hdr_flush_row_id()" -> "dict_hdr_get(mtr_t*)"
"dict_hdr_flush_row_id()" -> "mtr_start(mtr_t*)"
"dict_hdr_flush_row_id()" -> "mlog_write_ull(unsigned char*,ib_uint64_t,mtr_t*)"
"dict_hdr_flush_row_id()" -> "mtr_commit(mtr_t*)"
"row_ins_get_row_from_select(ins_node_t*)" -> "que_node_get_next(que_node_t*)"
"row_ins_get_row_from_select(ins_node_t*)" -> "que_node_get_val(que_node_t*)"
"row_ins_get_row_from_select(ins_node_t*)" -> "dfield_copy_data(dfield_t*,const dfield_t*)"
"assign_step(que_thr_t*)" -> "eval_node_copy_val(que_node_t*,que_node_t*)"
"assign_step(que_thr_t*)" -> "eval_exp(que_node_t*)"
"assign_step(que_thr_t*)" -> "que_node_get_parent(que_node_t*)"
"que_thr_node_step(que_thr_t*)" -> "que_thr_peek_stop(que_thr_t*)"
"que_thr_node_step(que_thr_t*)" -> "thr_get_trx(que_thr_t*)"
"que_thr_node_step(que_thr_t*)" -> "pfs_mutex_exit_func(ib_mutex_t*)"
"que_thr_node_step(que_thr_t*)" -> "pfs_mutex_enter_func(ib_mutex_t*,const char*,ulint)"
"dict_create_index_step(que_thr_t*)" -> "abort()"
"dict_create_index_step(que_thr_t*)" -> "rbt_free(ib_rbt_t*)"
"dict_create_index_step(que_thr_t*)" -> "trx_is_strict(trx_t*)"
"dict_create_index_step(que_thr_t*)" -> "dict_index_remove_from_cache(dict_table_t*,dict_index_t*)"
"dict_create_index_step(que_thr_t*)" -> "fts_find_index_cache(const fts_cache_t*,const dict_index_t*)"
"dict_create_index_step(que_thr_t*)" -> "dict_table_get_format(const dict_table_t*)"
"dict_create_index_step(que_thr_t*)" -> "thr_get_trx(que_thr_t*)"
"dict_create_index_step(que_thr_t*)" -> "pfs_rw_lock_x_lock_func(rw_lock_t*,ulint,const char*,ulint)"
"dict_create_index_step(que_thr_t*)" -> "dict_build_field_def_step(ind_node_t*)"
"dict_create_index_step(que_thr_t*)" -> "que_node_get_parent(que_node_t*)"
"dict_create_index_step(que_thr_t*)" -> "ib_vector_remove(ib_vector_t*,const void*)"
"dict_create_index_step(que_thr_t*)" -> "dict_index_get_if_in_cache_low(index_id_t)"
"dict_create_index_step(que_thr_t*)" -> "dict_create_index_tree_step(ind_node_t*)"
"dict_create_index_step(que_thr_t*)" -> "ut_dbg_assertion_failed(const char*,const char*,ulint)"
"dict_create_index_step(que_thr_t*)" -> "dict_build_index_def_step(que_thr_t*,ind_node_t*)"
"dict_create_index_step(que_thr_t*)" -> "__builtin_expect(long int,long int)"
"dict_create_index_step(que_thr_t*)" -> "pfs_rw_lock_x_unlock_func(rw_lock_t*)"
"dict_create_index_step(que_thr_t*)" -> "dict_index_add_to_cache(dict_table_t*,dict_index_t*,ulint,ulint)"
"dict_index_remove_from_cache(dict_table_t*,dict_index_t*)" -> "dict_index_remove_from_cache_low(dict_table_t*,dict_index_t*,ulint)"
"dict_index_remove_from_cache_low(dict_table_t*,dict_index_t*,ulint)" -> "fprintf(FILE*,const char*,...)"
"dict_index_remove_from_cache_low(dict_table_t*,dict_index_t*,ulint)" -> "btr_search_info_get_ref_count(btr_search_t*)"
"dict_index_remove_from_cache_low(dict_table_t*,dict_index_t*,ulint)" -> "os_thread_sleep(ulint)"
"dict_index_remove_from_cache_low(dict_table_t*,dict_index_t*,ulint)" -> "row_log_free(row_log_t*&)"
"dict_index_remove_from_cache_low(dict_table_t*,dict_index_t*,ulint)" -> "abort()"
"dict_index_remove_from_cache_low(dict_table_t*,dict_index_t*,ulint)" -> "ut_dbg_assertion_failed(const char*,const char*,ulint)"
"dict_index_remove_from_cache_low(dict_table_t*,dict_index_t*,ulint)" -> "dict_mem_index_free(dict_index_t*)"
"dict_index_remove_from_cache_low(dict_table_t*,dict_index_t*,ulint)" -> "ut_list_remove(List&,Type&,size_t) [with List = ut_list_base<dict_index_t>,Type = dict_index_t,size_t = long unsigned int]"
"dict_index_remove_from_cache_low(dict_table_t*,dict_index_t*,ulint)" -> "pfs_rw_lock_free_func(rw_lock_t*)"
"dict_index_remove_from_cache_low(dict_table_t*,dict_index_t*,ulint)" -> "mem_heap_get_size(mem_heap_t*)"
"dict_index_remove_from_cache_low(dict_table_t*,dict_index_t*,ulint)" -> "btr_search_get_info(dict_index_t*)"
"btr_search_info_get_ref_count(btr_search_t*)" -> "pfs_rw_lock_s_lock_func(rw_lock_t*,ulint,const char*,ulint)"
"btr_search_info_get_ref_count(btr_search_t*)" -> "pfs_rw_lock_s_unlock_func(rw_lock_t*)"
"row_log_free(row_log_t*&)" -> "row_merge_file_destroy_low(int)"
"row_log_free(row_log_t*&)" -> "ut_free(void*)"
"row_log_free(row_log_t*&)" -> "row_log_block_free(row_log_buf_t&)"
"row_log_free(row_log_t*&)" -> "pfs_mutex_free_func(ib_mutex_t*)"
"row_log_free(row_log_t*&)" -> "__sync_sub_and_fetch_8(volatile void*,long unsigned int)"
"row_merge_file_destroy_low(int)" -> "close(int)"
"row_merge_file_destroy_low(int)" -> "__builtin_expect(long int,long int)"
"row_log_block_free(row_log_buf_t&)" -> "os_mem_free_large(void*,ulint)"
"os_mem_free_large(void*,ulint)" -> "fprintf(FILE*,const char*,...)"
"os_mem_free_large(void*,ulint)" -> "__errno_location()"
"os_mem_free_large(void*,ulint)" -> "__builtin_expect(long int,long int)"
"os_mem_free_large(void*,ulint)" -> "pfs_os_fast_mutex_lock(os_fast_mutex_t*,const char*,ulint)"
"os_mem_free_large(void*,ulint)" -> "munmap(void*,size_t)"
"os_mem_free_large(void*,ulint)" -> "abort()"
"os_mem_free_large(void*,ulint)" -> "pfs_os_fast_mutex_unlock(os_fast_mutex_t*)"
"os_mem_free_large(void*,ulint)" -> "shmdt(const void*)"
"os_mem_free_large(void*,ulint)" -> "ut_dbg_assertion_failed(const char*,const char*,ulint)"
"ut_list_remove(List&,Type&,size_t) [with List = ut_list_base<dict_index_t>,Type = dict_index_t,size_t = long unsigned int]" -> "abort()"
"ut_list_remove(List&,Type&,size_t) [with List = ut_list_base<dict_index_t>,Type = dict_index_t,size_t = long unsigned int]" -> "ut_dbg_assertion_failed(const char*,const char*,ulint)"
"ut_list_remove(List&,Type&,size_t) [with List = ut_list_base<dict_index_t>,Type = dict_index_t,size_t = long unsigned int]" -> "__builtin_expect(long int,long int)"
"ut_list_remove(List&,Type&,size_t) [with List = ut_list_base<dict_index_t>,Type = dict_index_t,size_t = long unsigned int]" -> "ut_elem_get_node(Type&,size_t) [with Type = dict_index_t,size_t = long unsigned int]"
"fts_find_index_cache(const fts_cache_t*,const dict_index_t*)" -> "fts_get_index_cache(fts_cache_t*,const dict_index_t*)"
"dict_build_field_def_step(ind_node_t*)" -> "ins_node_set_new_row(ins_node_t*,dtuple_t*)"
"dict_build_field_def_step(ind_node_t*)" -> "dict_create_sys_fields_tuple(const dict_index_t*,ulint,mem_heap_t*)"
"dict_create_sys_fields_tuple(const dict_index_t*,ulint,mem_heap_t*)" -> "dtuple_create(mem_heap_t*,ulint)"
"dict_create_sys_fields_tuple(const dict_index_t*,ulint,mem_heap_t*)" -> "dfield_set_data(dfield_t*,const void*,ulint)"
"dict_create_sys_fields_tuple(const dict_index_t*,ulint,mem_heap_t*)" -> "ut_strlen(const char*)"
"dict_create_sys_fields_tuple(const dict_index_t*,ulint,mem_heap_t*)" -> "mach_write_to_8(void*,ib_uint64_t)"
"dict_create_sys_fields_tuple(const dict_index_t*,ulint,mem_heap_t*)" -> "mem_heap_alloc(mem_heap_t*,ulint)"
"dict_create_sys_fields_tuple(const dict_index_t*,ulint,mem_heap_t*)" -> "mach_write_to_4(unsigned char*,ulint)"
"dict_create_sys_fields_tuple(const dict_index_t*,ulint,mem_heap_t*)" -> "dict_table_copy_types(dtuple_t*,const dict_table_t*)"
"ib_vector_remove(ib_vector_t*,const void*)" -> "memmove(void*,const void*,size_t)"
"ib_vector_remove(ib_vector_t*,const void*)" -> "ib_vector_pop(ib_vector_t*)"
"ib_vector_remove(ib_vector_t*,const void*)" -> "ib_vector_get(ib_vector_t*,ulint)"
"dict_index_get_if_in_cache_low(index_id_t)" -> "dict_index_find_on_id_low(index_id_t)"
"dict_create_index_tree_step(ind_node_t*)" -> "btr_pcur_move_to_next_user_rec(btr_pcur_t*,mtr_t*)"
"dict_create_index_tree_step(ind_node_t*)" -> "dict_create_search_tuple(const dtuple_t*,mem_heap_t*)"
"dict_create_index_tree_step(ind_node_t*)" -> "dict_table_is_discarded(const dict_table_t*)"
"dict_create_index_tree_step(ind_node_t*)" -> "dict_table_zip_size(const dict_table_t*)"
"dict_create_index_tree_step(ind_node_t*)" -> "mtr_start(mtr_t*)"
"dict_create_index_tree_step(ind_node_t*)" -> "btr_create(ulint,ulint,ulint,index_id_t,dict_index_t*,mtr_t*)"
"dict_create_index_tree_step(ind_node_t*)" -> "btr_pcur_open_low(dict_index_t*,ulint,const dtuple_t*,ulint,ulint,btr_pcur_t*,const char*,ulint,mtr_t*)"
"dict_create_index_tree_step(ind_node_t*)" -> "page_rec_write_field(rec_t*,ulint,ulint,mtr_t*)"
"dict_create_index_tree_step(ind_node_t*)" -> "mtr_commit(mtr_t*)"
"dict_create_index_tree_step(ind_node_t*)" -> "btr_pcur_close(btr_pcur_t*)"
"dict_create_search_tuple(const dtuple_t*,mem_heap_t*)" -> "dfield_copy(dfield_t*,const dfield_t*)"
"dict_create_search_tuple(const dtuple_t*,mem_heap_t*)" -> "dtuple_create(mem_heap_t*,ulint)"
"dict_build_index_def_step(que_thr_t*,ind_node_t*)" -> "dict_create_sys_indexes_tuple(const dict_index_t*,mem_heap_t*)"
"dict_build_index_def_step(que_thr_t*,ind_node_t*)" -> "thr_get_trx(que_thr_t*)"
"dict_build_index_def_step(que_thr_t*,ind_node_t*)" -> "ins_node_set_new_row(ins_node_t*,dtuple_t*)"
"dict_build_index_def_step(que_thr_t*,ind_node_t*)" -> "dict_table_get_low(const char*)"
"dict_build_index_def_step(que_thr_t*,ind_node_t*)" -> "dict_hdr_get_new_id(table_id_t*,index_id_t*,ulint*)"
"dict_create_sys_indexes_tuple(const dict_index_t*,mem_heap_t*)" -> "mach_write_to_4(unsigned char*,ulint)"
"dict_create_sys_indexes_tuple(const dict_index_t*,mem_heap_t*)" -> "dict_table_copy_types(dtuple_t*,const dict_table_t*)"
"dict_create_sys_indexes_tuple(const dict_index_t*,mem_heap_t*)" -> "dict_table_get_low(const char*)"
"dict_create_sys_indexes_tuple(const dict_index_t*,mem_heap_t*)" -> "mach_write_to_8(void*,ib_uint64_t)"
"dict_create_sys_indexes_tuple(const dict_index_t*,mem_heap_t*)" -> "ut_strlen(const char*)"
"dict_create_sys_indexes_tuple(const dict_index_t*,mem_heap_t*)" -> "dfield_set_data(dfield_t*,const void*,ulint)"
"dict_create_sys_indexes_tuple(const dict_index_t*,mem_heap_t*)" -> "dtuple_create(mem_heap_t*,ulint)"
"dict_create_sys_indexes_tuple(const dict_index_t*,mem_heap_t*)" -> "mem_heap_alloc(mem_heap_t*,ulint)"
"dict_index_add_to_cache(dict_table_t*,dict_index_t*,ulint,ulint)" -> "ut_list_append(List&,Type&,size_t) [with List = ut_list_base<dict_index_t>,Type = dict_index_t,size_t = long unsigned int]"
"dict_index_add_to_cache(dict_table_t*,dict_index_t*,ulint,ulint)" -> "dict_field_get_col(const dict_field_t*)"
"dict_index_add_to_cache(dict_table_t*,dict_index_t*,ulint,ulint)" -> "btr_search_info_create(mem_heap_t*)"
"dict_index_add_to_cache(dict_table_t*,dict_index_t*,ulint,ulint)" -> "dict_mem_index_free(dict_index_t*)"
"dict_index_add_to_cache(dict_table_t*,dict_index_t*,ulint,ulint)" -> "dict_col_get_fixed_size(const dict_col_t*,ulint)"
"dict_index_add_to_cache(dict_table_t*,dict_index_t*,ulint,ulint)" -> "dict_table_get_format(const dict_table_t*)"
"dict_index_add_to_cache(dict_table_t*,dict_index_t*,ulint,ulint)" -> "dict_col_get_max_size(const dict_col_t*)"
"dict_index_add_to_cache(dict_table_t*,dict_index_t*,ulint,ulint)" -> "dict_index_is_clust(const dict_index_t*)"
"dict_index_add_to_cache(dict_table_t*,dict_index_t*,ulint,ulint)" -> "dict_index_find_cols(dict_table_t*,dict_index_t*)"
"dict_index_add_to_cache(dict_table_t*,dict_index_t*,ulint,ulint)" -> "dict_index_build_internal_clust(const dict_table_t*,dict_index_t*)"
"dict_index_add_to_cache(dict_table_t*,dict_index_t*,ulint,ulint)" -> "dict_index_too_big_for_tree(const dict_table_t*,const dict_index_t*)"
"dict_index_add_to_cache(dict_table_t*,dict_index_t*,ulint,ulint)" -> "ut_dbg_assertion_failed(const char*,const char*,ulint)"
"dict_index_add_to_cache(dict_table_t*,dict_index_t*,ulint,ulint)" -> "dict_index_build_internal_non_clust(const dict_table_t*,dict_index_t*)"
"dict_index_add_to_cache(dict_table_t*,dict_index_t*,ulint,ulint)" -> "abort()"
"dict_index_add_to_cache(dict_table_t*,dict_index_t*,ulint,ulint)" -> "__builtin_expect(long int,long int)"
"dict_index_add_to_cache(dict_table_t*,dict_index_t*,ulint,ulint)" -> "dict_index_get_n_unique(const dict_index_t*)"
"dict_index_add_to_cache(dict_table_t*,dict_index_t*,ulint,ulint)" -> "mem_heap_zalloc(mem_heap_t*,ulint)"
"dict_index_add_to_cache(dict_table_t*,dict_index_t*,ulint,ulint)" -> "pfs_rw_lock_create_func(mysql_pfs_key_t,rw_lock_t*,const char*,ulint)"
"dict_index_add_to_cache(dict_table_t*,dict_index_t*,ulint,ulint)" -> "mem_heap_get_size(mem_heap_t*)"
"dict_index_add_to_cache(dict_table_t*,dict_index_t*,ulint,ulint)" -> "dict_index_build_internal_fts(dict_table_t*,dict_index_t*)"
"dict_index_add_to_cache(dict_table_t*,dict_index_t*,ulint,ulint)" -> "dict_index_is_univ(const dict_index_t*)"
"dict_index_add_to_cache(dict_table_t*,dict_index_t*,ulint,ulint)" -> "dict_index_too_big_for_undo(const dict_table_t*,const dict_index_t*)"
"btr_search_info_create(mem_heap_t*)" -> "mem_heap_alloc(mem_heap_t*,ulint)"
"dict_index_find_cols(dict_table_t*,dict_index_t*)" -> "strcmp(const char*,const char*)"
"dict_index_find_cols(dict_table_t*,dict_index_t*)" -> "dict_table_get_col_name(const dict_table_t*,ulint)"
"dict_index_build_internal_clust(const dict_table_t*,dict_index_t*)" -> "dict_index_get_nth_col(const dict_index_t*,ulint)"
"dict_index_build_internal_clust(const dict_table_t*,dict_index_t*)" -> "dict_index_is_univ(const dict_index_t*)"
"dict_index_build_internal_clust(const dict_table_t*,dict_index_t*)" -> "dict_col_get_fixed_size(const dict_col_t*,ulint)"
"dict_index_build_internal_clust(const dict_table_t*,dict_index_t*)" -> "dict_table_is_comp(const dict_table_t*)"
"dict_index_build_internal_clust(const dict_table_t*,dict_index_t*)" -> "mem_alloc_func(ulint,ulint*)"
"dict_index_build_internal_clust(const dict_table_t*,dict_index_t*)" -> "dict_mem_index_create(const char*,const char*,ulint,ulint,ulint)"
"dict_index_build_internal_clust(const dict_table_t*,dict_index_t*)" -> "dict_index_copy(dict_index_t*,dict_index_t*,const dict_table_t*,ulint,ulint)"
"dict_index_build_internal_clust(const dict_table_t*,dict_index_t*)" -> "dict_index_add_col(dict_index_t*,const dict_table_t*,dict_col_t*,ulint)"
"dict_index_build_internal_clust(const dict_table_t*,dict_index_t*)" -> "dict_index_is_unique(const dict_index_t*)"
"dict_index_build_internal_clust(const dict_table_t*,dict_index_t*)" -> "dict_index_is_ibuf(const dict_index_t*)"
"dict_index_build_internal_clust(const dict_table_t*,dict_index_t*)" -> "memset(void*,int,size_t)"
"dict_index_build_internal_clust(const dict_table_t*,dict_index_t*)" -> "mem_free_func(void*,const char*,ulint)"
"dict_index_copy(dict_index_t*,dict_index_t*,const dict_table_t*,ulint,ulint)" -> "dict_index_add_col(dict_index_t*,const dict_table_t*,dict_col_t*,ulint)"
"dict_index_too_big_for_tree(const dict_table_t*,const dict_index_t*)" -> "dict_field_get_col(const dict_field_t*)"
"dict_index_too_big_for_tree(const dict_table_t*,const dict_index_t*)" -> "page_zip_empty_size(ulint,ulint)"
"dict_index_too_big_for_tree(const dict_table_t*,const dict_index_t*)" -> "page_get_free_space_of_empty(ulint)"
"dict_index_too_big_for_tree(const dict_table_t*,const dict_index_t*)" -> "dict_table_zip_size(const dict_table_t*)"
"dict_index_too_big_for_tree(const dict_table_t*,const dict_index_t*)" -> "dict_col_get_fixed_size(const dict_col_t*,ulint)"
"dict_index_too_big_for_tree(const dict_table_t*,const dict_index_t*)" -> "dict_index_get_n_unique_in_tree(const dict_index_t*)"
"dict_index_too_big_for_tree(const dict_table_t*,const dict_index_t*)" -> "__builtin_expect(long int,long int)"
"dict_index_too_big_for_tree(const dict_table_t*,const dict_index_t*)" -> "dict_index_is_clust(const dict_index_t*)"
"dict_index_too_big_for_tree(const dict_table_t*,const dict_index_t*)" -> "dict_col_get_max_size(const dict_col_t*)"
"dict_index_too_big_for_tree(const dict_table_t*,const dict_index_t*)" -> "dict_table_is_comp(const dict_table_t*)"
"dict_index_build_internal_non_clust(const dict_table_t*,dict_index_t*)" -> "dict_index_is_unique(const dict_index_t*)"
"dict_index_build_internal_non_clust(const dict_table_t*,dict_index_t*)" -> "dict_index_add_col(dict_index_t*,const dict_table_t*,dict_col_t*,ulint)"
"dict_index_build_internal_non_clust(const dict_table_t*,dict_index_t*)" -> "dict_index_copy(dict_index_t*,dict_index_t*,const dict_table_t*,ulint,ulint)"
"dict_index_build_internal_non_clust(const dict_table_t*,dict_index_t*)" -> "memset(void*,int,size_t)"
"dict_index_build_internal_non_clust(const dict_table_t*,dict_index_t*)" -> "dict_mem_index_create(const char*,const char*,ulint,ulint,ulint)"
"dict_index_build_internal_non_clust(const dict_table_t*,dict_index_t*)" -> "mem_alloc_func(ulint,ulint*)"
"dict_index_build_internal_non_clust(const dict_table_t*,dict_index_t*)" -> "mem_free_func(void*,const char*,ulint)"
"dict_index_build_internal_fts(dict_table_t*,dict_index_t*)" -> "pfs_rw_lock_x_unlock_func(rw_lock_t*)"
"dict_index_build_internal_fts(dict_table_t*,dict_index_t*)" -> "dict_index_copy(dict_index_t*,dict_index_t*,const dict_table_t*,ulint,ulint)"
"dict_index_build_internal_fts(dict_table_t*,dict_index_t*)" -> "fts_cache_index_cache_create(dict_table_t*,dict_index_t*)"
"dict_index_build_internal_fts(dict_table_t*,dict_index_t*)" -> "fts_cache_create(dict_table_t*)"
"dict_index_build_internal_fts(dict_table_t*,dict_index_t*)" -> "dict_mem_index_create(const char*,const char*,ulint,ulint,ulint)"
"dict_index_build_internal_fts(dict_table_t*,dict_index_t*)" -> "pfs_rw_lock_x_lock_func(rw_lock_t*,ulint,const char*,ulint)"
"fts_cache_index_cache_create(dict_table_t*,dict_index_t*)" -> "fts_index_get_charset(dict_index_t*)"
"fts_cache_index_cache_create(dict_table_t*,dict_index_t*)" -> "abort()"
"fts_cache_index_cache_create(dict_table_t*,dict_index_t*)" -> "fts_find_index_cache(const fts_cache_t*,const dict_index_t*)"
"fts_cache_index_cache_create(dict_table_t*,dict_index_t*)" -> "mem_heap_zalloc(mem_heap_t*,ulint)"
"fts_cache_index_cache_create(dict_table_t*,dict_index_t*)" -> "__builtin_expect(long int,long int)"
"fts_cache_index_cache_create(dict_table_t*,dict_index_t*)" -> "ut_dbg_assertion_failed(const char*,const char*,ulint)"
"fts_cache_index_cache_create(dict_table_t*,dict_index_t*)" -> "memset(void*,int,size_t)"
"fts_cache_index_cache_create(dict_table_t*,dict_index_t*)" -> "ib_vector_push(ib_vector_t*,const void*)"
"fts_cache_index_cache_create(dict_table_t*,dict_index_t*)" -> "fts_index_cache_init(ib_alloc_t*,fts_index_cache_t*)"
"fts_cache_index_cache_create(dict_table_t*,dict_index_t*)" -> "fts_reset_get_doc(fts_cache_t*)"
"fts_index_get_charset(dict_index_t*)" -> "dtype_get_charset_coll(ulint)"
"fts_index_get_charset(dict_index_t*)" -> "innobase_get_fts_charset(int,uint)"
"fts_reset_get_doc(fts_cache_t*)" -> "ib_vector_reset(ib_vector_t*)"
"fts_reset_get_doc(fts_cache_t*)" -> "memset(void*,int,size_t)"
"fts_reset_get_doc(fts_cache_t*)" -> "ib_vector_size(const ib_vector_t*)"
"fts_reset_get_doc(fts_cache_t*)" -> "ib_vector_get(ib_vector_t*,ulint)"
"fts_reset_get_doc(fts_cache_t*)" -> "ib_vector_push(ib_vector_t*,const void*)"
"dict_index_too_big_for_undo(const dict_table_t*,const dict_index_t*)" -> "dict_col_get_max_size(const dict_col_t*)"
"dict_index_too_big_for_undo(const dict_table_t*,const dict_index_t*)" -> "dict_table_get_n_cols(const dict_table_t*)"
"dict_index_too_big_for_undo(const dict_table_t*,const dict_index_t*)" -> "abort()"
"dict_index_too_big_for_undo(const dict_table_t*,const dict_index_t*)" -> "dict_table_get_format(const dict_table_t*)"
"dict_index_too_big_for_undo(const dict_table_t*,const dict_index_t*)" -> "dict_table_is_comp(const dict_table_t*)"
"dict_index_too_big_for_undo(const dict_table_t*,const dict_index_t*)" -> "ut_dbg_assertion_failed(const char*,const char*,ulint)"
"dict_index_too_big_for_undo(const dict_table_t*,const dict_index_t*)" -> "__builtin_expect(long int,long int)"
"dict_index_too_big_for_undo(const dict_table_t*,const dict_index_t*)" -> "dict_index_get_nth_col(const dict_index_t*,ulint)"
"dict_index_too_big_for_undo(const dict_table_t*,const dict_index_t*)" -> "ut_min(ulint,ulint)"
"dict_index_too_big_for_undo(const dict_table_t*,const dict_index_t*)" -> "dict_col_get_fixed_size(const dict_col_t*,ulint)"
"dict_index_too_big_for_undo(const dict_table_t*,const dict_index_t*)" -> "dict_index_is_clust(const dict_index_t*)"
"proc_eval_step(que_thr_t*)" -> "que_node_get_parent(que_node_t*)"
"proc_eval_step(que_thr_t*)" -> "eval_exp(que_node_t*)"
"row_sel_step(que_thr_t*)" -> "row_sel_copy_input_variable_vals(sel_node_t*)"
"row_sel_step(que_thr_t*)" -> "trx_assign_read_view(trx_t*)"
"row_sel_step(que_thr_t*)" -> "trx_start_if_not_started_xa_low(trx_t*)"
"row_sel_step(que_thr_t*)" -> "sel_node_get_nth_plan(sel_node_t*,ulint)"
"row_sel_step(que_thr_t*)" -> "plan_reset_cursor(plan_t*)"
"row_sel_step(que_thr_t*)" -> "que_node_get_parent(que_node_t*)"
"row_sel_step(que_thr_t*)" -> "row_sel(sel_node_t*,que_thr_t*)"
"row_sel_step(que_thr_t*)" -> "sel_reset_aggregate_vals(sel_node_t*)"
"row_sel_step(que_thr_t*)" -> "lock_table(ulint,dict_table_t*,lock_mode,que_thr_t*)"
"row_sel_step(que_thr_t*)" -> "que_node_get_next(que_node_t*)"
"row_sel_step(que_thr_t*)" -> "thr_get_trx(que_thr_t*)"
"row_sel_copy_input_variable_vals(sel_node_t*)" -> "eval_node_copy_val(que_node_t*,que_node_t*)"
"trx_assign_read_view(trx_t*)" -> "read_view_open_now(trx_id_t,mem_heap_t*)"
"read_view_open_now(trx_id_t,mem_heap_t*)" -> "pfs_mutex_enter_func(ib_mutex_t*,const char*,ulint)"
"read_view_open_now(trx_id_t,mem_heap_t*)" -> "pfs_mutex_exit_func(ib_mutex_t*)"
"read_view_open_now(trx_id_t,mem_heap_t*)" -> "read_view_open_now_low(trx_id_t,mem_heap_t*)"
"read_view_open_now_low(trx_id_t,mem_heap_t*)" -> "CreateView::CreateView(read_view_t*)"
"read_view_open_now_low(trx_id_t,mem_heap_t*)" -> "read_view_add(read_view_t*)"
"read_view_open_now_low(trx_id_t,mem_heap_t*)" -> "ut_list_map(List&,ut_list_node<typename List::elem_type> typename List::elem_type::*,Functor) [with List = ut_list_base<trx_t>,Functor = CreateView,typename List::elem_type = trx_t]"
"read_view_open_now_low(trx_id_t,mem_heap_t*)" -> "read_view_create_low(ulint,mem_heap_t*)"
"read_view_add(read_view_t*)" -> "ut_list_insert(List&,Type&,Type&,size_t) [with List = ut_list_base<read_view_t>,Type = read_view_t,size_t = long unsigned int]"
"read_view_add(read_view_t*)" -> "ut_list_prepend(List&,Type&,size_t) [with List = ut_list_base<read_view_t>,Type = read_view_t,size_t = long unsigned int]"
"ut_list_insert(List&,Type&,Type&,size_t) [with List = ut_list_base<read_view_t>,Type = read_view_t,size_t = long unsigned int]" -> "ut_elem_get_node(Type&,size_t) [with Type = read_view_t,size_t = long unsigned int]"
"ut_list_prepend(List&,Type&,size_t) [with List = ut_list_base<read_view_t>,Type = read_view_t,size_t = long unsigned int]" -> "ut_elem_get_node(Type&,size_t) [with Type = read_view_t,size_t = long unsigned int]"
"ut_list_map(List&,ut_list_node<typename List::elem_type> typename List::elem_type::*,Functor) [with List = ut_list_base<trx_t>,Functor = CreateView,typename List::elem_type = trx_t]" -> "ut_dbg_assertion_failed(const char*,const char*,ulint)"
"ut_list_map(List&,ut_list_node<typename List::elem_type> typename List::elem_type::*,Functor) [with List = ut_list_base<trx_t>,Functor = CreateView,typename List::elem_type = trx_t]" -> "CreateView::operator()(const trx_t*)"
"ut_list_map(List&,ut_list_node<typename List::elem_type> typename List::elem_type::*,Functor) [with List = ut_list_base<trx_t>,Functor = CreateView,typename List::elem_type = trx_t]" -> "abort()"
"ut_list_map(List&,ut_list_node<typename List::elem_type> typename List::elem_type::*,Functor) [with List = ut_list_base<trx_t>,Functor = CreateView,typename List::elem_type = trx_t]" -> "__builtin_expect(long int,long int)"
"CreateView::operator()(const trx_t*)" -> "trx_state_eq(const trx_t*,trx_state_t)"
"read_view_create_low(ulint,mem_heap_t*)" -> "mem_heap_alloc(mem_heap_t*,ulint)"
"row_sel(sel_node_t*,que_thr_t*)" -> "rec_offs_set_n_alloc(ulint*,ulint)"
"row_sel(sel_node_t*,que_thr_t*)" -> "pfs_rw_lock_s_unlock_func(rw_lock_t*)"
"row_sel(sel_node_t*,que_thr_t*)" -> "plan_reset_cursor(plan_t*)"
"row_sel(sel_node_t*,que_thr_t*)" -> "dict_index_is_clust(const dict_index_t*)"
"row_sel(sel_node_t*,que_thr_t*)" -> "page_rec_is_infimum(const rec_t*)"
"row_sel(sel_node_t*,que_thr_t*)" -> "lock_clust_rec_cons_read_sees(const rec_t*,dict_index_t*,const ulint*,read_view_t*)"
"row_sel(sel_node_t*,que_thr_t*)" -> "btr_pcur_store_position(btr_pcur_t*,mtr_t*)"
"row_sel(sel_node_t*,que_thr_t*)" -> "rw_lock_get_writer(const rw_lock_t*)"
"row_sel(sel_node_t*,que_thr_t*)" -> "row_sel_try_search_shortcut(sel_node_t*,plan_t*,ulint,mtr_t*)"
"row_sel(sel_node_t*,que_thr_t*)" -> "row_sel_open_pcur(plan_t*,ulint,mtr_t*)"
"row_sel(sel_node_t*,que_thr_t*)" -> "mtr_commit(mtr_t*)"
"row_sel(sel_node_t*,que_thr_t*)" -> "row_sel_get_clust_rec(sel_node_t*,plan_t*,rec_t*,que_thr_t*,rec_t**,mtr_t*)"
"row_sel(sel_node_t*,que_thr_t*)" -> "pfs_rw_lock_s_lock_func(rw_lock_t*,ulint,const char*,ulint)"
"row_sel(sel_node_t*,que_thr_t*)" -> "mtr_start(mtr_t*)"
"row_sel(sel_node_t*,que_thr_t*)" -> "rec_get_offsets_func(const rec_t*,const dict_index_t*,ulint*,ulint,mem_heap_t**)"
"row_sel(sel_node_t*,que_thr_t*)" -> "btr_pcur_get_up_match(const btr_pcur_t*)"
"row_sel(sel_node_t*,que_thr_t*)" -> "thr_get_trx(que_thr_t*)"
"row_sel(sel_node_t*,que_thr_t*)" -> "page_rec_is_supremum(const rec_t*)"
"row_sel(sel_node_t*,que_thr_t*)" -> "sel_dequeue_prefetched_row(plan_t*)"
"row_sel(sel_node_t*,que_thr_t*)" -> "sel_set_rec_lock(const buf_block_t*,const rec_t*,dict_index_t*,const ulint*,ulint,ulint,que_thr_t*)"
"row_sel(sel_node_t*,que_thr_t*)" -> "sel_assign_into_var_values(sym_node_t*,sel_node_t*)"
"row_sel(sel_node_t*,que_thr_t*)" -> "sel_eval_select_list(sel_node_t*)"
"row_sel(sel_node_t*,que_thr_t*)" -> "btr_pcur_move_to_next(btr_pcur_t*,mtr_t*)"
"row_sel(sel_node_t*,que_thr_t*)" -> "row_sel_test_end_conds(plan_t*)"
"row_sel(sel_node_t*,que_thr_t*)" -> "page_rec_get_next(rec_t*)"
"row_sel(sel_node_t*,que_thr_t*)" -> "row_sel_build_prev_vers(read_view_t*,dict_index_t*,rec_t*,ulint**,mem_heap_t**,mem_heap_t**,rec_t**,mtr_t*)"
"row_sel(sel_node_t*,que_thr_t*)" -> "mem_heap_free_func(mem_heap_t*,const char*,ulint)"
"row_sel(sel_node_t*,que_thr_t*)" -> "__builtin_expect(long int,long int)"
"row_sel(sel_node_t*,que_thr_t*)" -> "que_node_get_parent(que_node_t*)"
"row_sel(sel_node_t*,que_thr_t*)" -> "rec_get_deleted_flag(const rec_t*,ulint)"
"row_sel(sel_node_t*,que_thr_t*)" -> "row_sel_fetch_columns(dict_index_t*,const rec_t*,const ulint*,sym_node_t*)"
"row_sel(sel_node_t*,que_thr_t*)" -> "sel_node_get_nth_plan(sel_node_t*,ulint)"
"row_sel(sel_node_t*,que_thr_t*)" -> "lock_sec_rec_cons_read_sees(const rec_t*,const read_view_t*)"
"row_sel(sel_node_t*,que_thr_t*)" -> "row_sel_restore_pcur_pos(plan_t*,mtr_t*)"
"row_sel(sel_node_t*,que_thr_t*)" -> "dict_table_is_comp(const dict_table_t*)"
"row_sel(sel_node_t*,que_thr_t*)" -> "btr_pcur_move_to_prev(btr_pcur_t*,mtr_t*)"
"row_sel(sel_node_t*,que_thr_t*)" -> "row_sel_test_other_conds(plan_t*)"
"row_sel(sel_node_t*,que_thr_t*)" -> "sel_enqueue_prefetched_row(plan_t*)"
"row_sel_try_search_shortcut(sel_node_t*,plan_t*,ulint,mtr_t*)" -> "btr_pcur_get_up_match(const btr_pcur_t*)"
"row_sel_try_search_shortcut(sel_node_t*,plan_t*,ulint,mtr_t*)" -> "page_rec_is_user_rec(const rec_t*)"
"row_sel_try_search_shortcut(sel_node_t*,plan_t*,ulint,mtr_t*)" -> "row_sel_open_pcur(plan_t*,ulint,mtr_t*)"
"row_sel_try_search_shortcut(sel_node_t*,plan_t*,ulint,mtr_t*)" -> "row_sel_fetch_columns(dict_index_t*,const rec_t*,const ulint*,sym_node_t*)"
"row_sel_try_search_shortcut(sel_node_t*,plan_t*,ulint,mtr_t*)" -> "lock_clust_rec_cons_read_sees(const rec_t*,dict_index_t*,const ulint*,read_view_t*)"
"row_sel_try_search_shortcut(sel_node_t*,plan_t*,ulint,mtr_t*)" -> "dict_table_is_comp(const dict_table_t*)"
"row_sel_try_search_shortcut(sel_node_t*,plan_t*,ulint,mtr_t*)" -> "mem_heap_free_func(mem_heap_t*,const char*,ulint)"
"row_sel_try_search_shortcut(sel_node_t*,plan_t*,ulint,mtr_t*)" -> "lock_sec_rec_cons_read_sees(const rec_t*,const read_view_t*)"
"row_sel_try_search_shortcut(sel_node_t*,plan_t*,ulint,mtr_t*)" -> "rec_get_offsets_func(const rec_t*,const dict_index_t*,ulint*,ulint,mem_heap_t**)"
"row_sel_try_search_shortcut(sel_node_t*,plan_t*,ulint,mtr_t*)" -> "dict_index_is_clust(const dict_index_t*)"
"row_sel_try_search_shortcut(sel_node_t*,plan_t*,ulint,mtr_t*)" -> "rec_offs_set_n_alloc(ulint*,ulint)"
"row_sel_try_search_shortcut(sel_node_t*,plan_t*,ulint,mtr_t*)" -> "rec_get_deleted_flag(const rec_t*,ulint)"
"row_sel_try_search_shortcut(sel_node_t*,plan_t*,ulint,mtr_t*)" -> "__builtin_expect(long int,long int)"
"row_sel_try_search_shortcut(sel_node_t*,plan_t*,ulint,mtr_t*)" -> "row_sel_test_other_conds(plan_t*)"
"row_sel_open_pcur(plan_t*,ulint,mtr_t*)" -> "eval_exp(que_node_t*)"
"row_sel_open_pcur(plan_t*,ulint,mtr_t*)" -> "dfield_copy_data(dfield_t*,const dfield_t*)"
"row_sel_open_pcur(plan_t*,ulint,mtr_t*)" -> "que_node_get_val(que_node_t*)"
"row_sel_open_pcur(plan_t*,ulint,mtr_t*)" -> "btr_pcur_open_with_no_init_func(dict_index_t*,const dtuple_t*,ulint,ulint,btr_pcur_t*,ulint,const char*,ulint,mtr_t*)"
"row_sel_open_pcur(plan_t*,ulint,mtr_t*)" -> "btr_pcur_open_at_index_side(bool,dict_index_t*,ulint,btr_pcur_t*,bool,ulint,mtr_t*)"
"row_sel_open_pcur(plan_t*,ulint,mtr_t*)" -> "que_node_get_next(que_node_t*)"
"row_sel_open_pcur(plan_t*,ulint,mtr_t*)" -> "dtuple_get_n_fields(const dtuple_t*)"
"row_sel_fetch_columns(dict_index_t*,const rec_t*,const ulint*,sym_node_t*)" -> "btr_rec_copy_externally_stored_field(const rec_t*,const ulint*,ulint,ulint,ulint*,mem_heap_t*)"
"row_sel_fetch_columns(dict_index_t*,const rec_t*,const ulint*,sym_node_t*)" -> "dict_table_zip_size(const dict_table_t*)"
"row_sel_fetch_columns(dict_index_t*,const rec_t*,const ulint*,sym_node_t*)" -> "mem_heap_create_func(ulint,ulint)"
"row_sel_fetch_columns(dict_index_t*,const rec_t*,const ulint*,sym_node_t*)" -> "dict_index_is_clust(const dict_index_t*)"
"row_sel_fetch_columns(dict_index_t*,const rec_t*,const ulint*,sym_node_t*)" -> "que_node_get_val(que_node_t*)"
"row_sel_fetch_columns(dict_index_t*,const rec_t*,const ulint*,sym_node_t*)" -> "__builtin_expect(long int,long int)"
"row_sel_fetch_columns(dict_index_t*,const rec_t*,const ulint*,sym_node_t*)" -> "ut_dbg_assertion_failed(const char*,const char*,ulint)"
"row_sel_fetch_columns(dict_index_t*,const rec_t*,const ulint*,sym_node_t*)" -> "abort()"
"row_sel_fetch_columns(dict_index_t*,const rec_t*,const ulint*,sym_node_t*)" -> "rec_offs_nth_extern(const ulint*,ulint)"
"row_sel_fetch_columns(dict_index_t*,const rec_t*,const ulint*,sym_node_t*)" -> "rec_get_nth_field_offs(const ulint*,ulint,ulint*)"
"row_sel_fetch_columns(dict_index_t*,const rec_t*,const ulint*,sym_node_t*)" -> "mem_heap_free_func(mem_heap_t*,const char*,ulint)"
"row_sel_fetch_columns(dict_index_t*,const rec_t*,const ulint*,sym_node_t*)" -> "eval_node_copy_and_alloc_val(que_node_t*,const unsigned char*,ulint)"
"row_sel_fetch_columns(dict_index_t*,const rec_t*,const ulint*,sym_node_t*)" -> "dfield_set_data(dfield_t*,const void*,ulint)"
"btr_rec_copy_externally_stored_field(const rec_t*,const ulint*,ulint,ulint,ulint*,mem_heap_t*)" -> "memcmp(const void*,const void*,size_t)"
"btr_rec_copy_externally_stored_field(const rec_t*,const ulint*,ulint,ulint,ulint*,mem_heap_t*)" -> "btr_copy_externally_stored_field(ulint*,const unsigned char*,ulint,ulint,mem_heap_t*)"
"btr_rec_copy_externally_stored_field(const rec_t*,const ulint*,ulint,ulint,ulint*,mem_heap_t*)" -> "rec_offs_nth_extern(const ulint*,ulint)"
"btr_rec_copy_externally_stored_field(const rec_t*,const ulint*,ulint,ulint,ulint*,mem_heap_t*)" -> "ut_dbg_assertion_failed(const char*,const char*,ulint)"
"btr_rec_copy_externally_stored_field(const rec_t*,const ulint*,ulint,ulint,ulint*,mem_heap_t*)" -> "__builtin_expect(long int,long int)"
"btr_rec_copy_externally_stored_field(const rec_t*,const ulint*,ulint,ulint,ulint*,mem_heap_t*)" -> "abort()"
"btr_rec_copy_externally_stored_field(const rec_t*,const ulint*,ulint,ulint,ulint*,mem_heap_t*)" -> "rec_get_nth_field_offs(const ulint*,ulint,ulint*)"
"btr_copy_externally_stored_field(ulint*,const unsigned char*,ulint,ulint,mem_heap_t*)" -> "memcpy(void*,const void*,size_t)"
"btr_copy_externally_stored_field(ulint*,const unsigned char*,ulint,ulint,mem_heap_t*)" -> "ut_dbg_assertion_failed(const char*,const char*,ulint)"
"btr_copy_externally_stored_field(ulint*,const unsigned char*,ulint,ulint,mem_heap_t*)" -> "btr_copy_externally_stored_field_prefix_low(unsigned char*,ulint,ulint,ulint,ulint,ulint)"
"btr_copy_externally_stored_field(ulint*,const unsigned char*,ulint,ulint,mem_heap_t*)" -> "abort()"
"btr_copy_externally_stored_field(ulint*,const unsigned char*,ulint,ulint,mem_heap_t*)" -> "mem_heap_alloc(mem_heap_t*,ulint)"
"btr_copy_externally_stored_field(ulint*,const unsigned char*,ulint,ulint,mem_heap_t*)" -> "mach_read_from_4(const unsigned char*)"
"btr_copy_externally_stored_field(ulint*,const unsigned char*,ulint,ulint,mem_heap_t*)" -> "__builtin_expect(long int,long int)"
"row_sel_test_other_conds(plan_t*)" -> "eval_exp(que_node_t*)"
"row_sel_test_other_conds(plan_t*)" -> "eval_node_get_ibool_val(que_node_t*)"
"row_sel_get_clust_rec(sel_node_t*,plan_t*,rec_t*,que_thr_t*,rec_t**,mtr_t*)" -> "row_sel_fetch_columns(dict_index_t*,const rec_t*,const ulint*,sym_node_t*)"
"row_sel_get_clust_rec(sel_node_t*,plan_t*,rec_t*,que_thr_t*,rec_t**,mtr_t*)" -> "lock_clust_rec_read_check_and_lock(ulint,const buf_block_t*,const rec_t*,dict_index_t*,const ulint*,lock_mode,ulint,que_thr_t*)"
"row_sel_get_clust_rec(sel_node_t*,plan_t*,rec_t*,que_thr_t*,rec_t**,mtr_t*)" -> "row_sel_build_prev_vers(read_view_t*,dict_index_t*,rec_t*,ulint**,mem_heap_t**,mem_heap_t**,rec_t**,mtr_t*)"
"row_sel_get_clust_rec(sel_node_t*,plan_t*,rec_t*,que_thr_t*,rec_t**,mtr_t*)" -> "dict_table_is_comp(const dict_table_t*)"
"row_sel_get_clust_rec(sel_node_t*,plan_t*,rec_t*,que_thr_t*,rec_t**,mtr_t*)" -> "rec_get_offsets_func(const rec_t*,const dict_index_t*,ulint*,ulint,mem_heap_t**)"
"row_sel_get_clust_rec(sel_node_t*,plan_t*,rec_t*,que_thr_t*,rec_t**,mtr_t*)" -> "row_build_row_ref_fast(dtuple_t*,const ulint*,const rec_t*,const ulint*)"
"row_sel_get_clust_rec(sel_node_t*,plan_t*,rec_t*,que_thr_t*,rec_t**,mtr_t*)" -> "dict_index_get_n_unique(const dict_index_t*)"
"row_sel_get_clust_rec(sel_node_t*,plan_t*,rec_t*,que_thr_t*,rec_t**,mtr_t*)" -> "rec_get_deleted_flag(const rec_t*,ulint)"
"row_sel_get_clust_rec(sel_node_t*,plan_t*,rec_t*,que_thr_t*,rec_t**,mtr_t*)" -> "page_rec_is_user_rec(const rec_t*)"
"row_sel_get_clust_rec(sel_node_t*,plan_t*,rec_t*,que_thr_t*,rec_t**,mtr_t*)" -> "lock_clust_rec_cons_read_sees(const rec_t*,dict_index_t*,const ulint*,read_view_t*)"
"row_sel_get_clust_rec(sel_node_t*,plan_t*,rec_t*,que_thr_t*,rec_t**,mtr_t*)" -> "abort()"
"row_sel_get_clust_rec(sel_node_t*,plan_t*,rec_t*,que_thr_t*,rec_t**,mtr_t*)" -> "rec_offs_set_n_alloc(ulint*,ulint)"
"row_sel_get_clust_rec(sel_node_t*,plan_t*,rec_t*,que_thr_t*,rec_t**,mtr_t*)" -> "btr_pcur_get_low_match(const btr_pcur_t*)"
"row_sel_get_clust_rec(sel_node_t*,plan_t*,rec_t*,que_thr_t*,rec_t**,mtr_t*)" -> "mem_heap_free_func(mem_heap_t*,const char*,ulint)"
"row_sel_get_clust_rec(sel_node_t*,plan_t*,rec_t*,que_thr_t*,rec_t**,mtr_t*)" -> "thr_get_trx(que_thr_t*)"
"row_sel_get_clust_rec(sel_node_t*,plan_t*,rec_t*,que_thr_t*,rec_t**,mtr_t*)" -> "ut_dbg_assertion_failed(const char*,const char*,ulint)"
"row_sel_get_clust_rec(sel_node_t*,plan_t*,rec_t*,que_thr_t*,rec_t**,mtr_t*)" -> "btr_pcur_open_with_no_init_func(dict_index_t*,const dtuple_t*,ulint,ulint,btr_pcur_t*,ulint,const char*,ulint,mtr_t*)"
"row_sel_get_clust_rec(sel_node_t*,plan_t*,rec_t*,que_thr_t*,rec_t**,mtr_t*)" -> "row_sel_sec_rec_is_for_clust_rec(const rec_t*,dict_index_t*,const rec_t*,dict_index_t*)"
"row_sel_get_clust_rec(sel_node_t*,plan_t*,rec_t*,que_thr_t*,rec_t**,mtr_t*)" -> "__builtin_expect(long int,long int)"
"row_sel_build_prev_vers(read_view_t*,dict_index_t*,rec_t*,ulint**,mem_heap_t**,mem_heap_t**,rec_t**,mtr_t*)" -> "mem_heap_create_func(ulint,ulint)"
"row_sel_build_prev_vers(read_view_t*,dict_index_t*,rec_t*,ulint**,mem_heap_t**,mem_heap_t**,rec_t**,mtr_t*)" -> "row_vers_build_for_consistent_read(const rec_t*,mtr_t*,dict_index_t*,ulint**,read_view_t*,mem_heap_t**,mem_heap_t*,rec_t**)"
"row_sel_build_prev_vers(read_view_t*,dict_index_t*,rec_t*,ulint**,mem_heap_t**,mem_heap_t**,rec_t**,mtr_t*)" -> "mem_heap_empty(mem_heap_t*)"
"row_vers_build_for_consistent_read(const rec_t*,mtr_t*,dict_index_t*,ulint**,read_view_t*,mem_heap_t**,mem_heap_t*,rec_t**)" -> "mem_heap_empty(mem_heap_t*)"
"row_vers_build_for_consistent_read(const rec_t*,mtr_t*,dict_index_t*,ulint**,read_view_t*,mem_heap_t**,mem_heap_t*,rec_t**)" -> "mem_heap_alloc(mem_heap_t*,ulint)"
"row_vers_build_for_consistent_read(const rec_t*,mtr_t*,dict_index_t*,ulint**,read_view_t*,mem_heap_t**,mem_heap_t*,rec_t**)" -> "read_view_sees_trx_id(const read_view_t*,trx_id_t)"
"row_vers_build_for_consistent_read(const rec_t*,mtr_t*,dict_index_t*,ulint**,read_view_t*,mem_heap_t**,mem_heap_t*,rec_t**)" -> "mem_heap_free_func(mem_heap_t*,const char*,ulint)"
"row_vers_build_for_consistent_read(const rec_t*,mtr_t*,dict_index_t*,ulint**,read_view_t*,mem_heap_t**,mem_heap_t*,rec_t**)" -> "trx_undo_prev_version_build(const rec_t*,mtr_t*,const rec_t*,dict_index_t*,ulint*,mem_heap_t*,rec_t**)"
"row_vers_build_for_consistent_read(const rec_t*,mtr_t*,dict_index_t*,ulint**,read_view_t*,mem_heap_t**,mem_heap_t*,rec_t**)" -> "mem_heap_create_func(ulint,ulint)"
"row_vers_build_for_consistent_read(const rec_t*,mtr_t*,dict_index_t*,ulint**,read_view_t*,mem_heap_t**,mem_heap_t*,rec_t**)" -> "trx_undo_rec_get_undo_no(const trx_undo_rec_t*)"
"row_vers_build_for_consistent_read(const rec_t*,mtr_t*,dict_index_t*,ulint**,read_view_t*,mem_heap_t**,mem_heap_t*,rec_t**)" -> "row_get_rec_roll_ptr(const rec_t*,const dict_index_t*,const ulint*)"
"row_vers_build_for_consistent_read(const rec_t*,mtr_t*,dict_index_t*,ulint**,read_view_t*,mem_heap_t**,mem_heap_t*,rec_t**)" -> "rec_get_offsets_func(const rec_t*,const dict_index_t*,ulint*,ulint,mem_heap_t**)"
"row_vers_build_for_consistent_read(const rec_t*,mtr_t*,dict_index_t*,ulint**,read_view_t*,mem_heap_t**,mem_heap_t*,rec_t**)" -> "row_get_rec_trx_id(const rec_t*,const dict_index_t*,const ulint*)"
"row_vers_build_for_consistent_read(const rec_t*,mtr_t*,dict_index_t*,ulint**,read_view_t*,mem_heap_t**,mem_heap_t*,rec_t**)" -> "rec_offs_size(const ulint*)"
"row_vers_build_for_consistent_read(const rec_t*,mtr_t*,dict_index_t*,ulint**,read_view_t*,mem_heap_t**,mem_heap_t*,rec_t**)" -> "rec_copy(void*,const rec_t*,const ulint*)"
"row_vers_build_for_consistent_read(const rec_t*,mtr_t*,dict_index_t*,ulint**,read_view_t*,mem_heap_t**,mem_heap_t*,rec_t**)" -> "trx_undo_get_undo_rec_low(roll_ptr_t,mem_heap_t*)"
"trx_undo_rec_get_undo_no(const trx_undo_rec_t*)" -> "mach_ull_read_much_compressed(const unsigned char*)"
"row_build_row_ref_fast(dtuple_t*,const ulint*,const rec_t*,const ulint*)" -> "rec_get_nth_field_offs(const ulint*,ulint,ulint*)"
"row_build_row_ref_fast(dtuple_t*,const ulint*,const rec_t*,const ulint*)" -> "dtuple_get_n_fields(const dtuple_t*)"
"row_build_row_ref_fast(dtuple_t*,const ulint*,const rec_t*,const ulint*)" -> "dfield_set_data(dfield_t*,const void*,ulint)"
"row_sel_sec_rec_is_for_clust_rec(const rec_t*,dict_index_t*,const rec_t*,dict_index_t*)" -> "dict_index_get_n_ordering_defined_by_user(const dict_index_t*)"
"row_sel_sec_rec_is_for_clust_rec(const rec_t*,dict_index_t*,const rec_t*,dict_index_t*)" -> "dict_col_get_clust_pos(const dict_col_t*,const dict_index_t*)"
"row_sel_sec_rec_is_for_clust_rec(const rec_t*,dict_index_t*,const rec_t*,dict_index_t*)" -> "rec_get_nth_field_offs(const ulint*,ulint,ulint*)"
"row_sel_sec_rec_is_for_clust_rec(const rec_t*,dict_index_t*,const rec_t*,dict_index_t*)" -> "dict_field_get_col(const dict_field_t*)"
"row_sel_sec_rec_is_for_clust_rec(const rec_t*,dict_index_t*,const rec_t*,dict_index_t*)" -> "__builtin_expect(long int,long int)"
"row_sel_sec_rec_is_for_clust_rec(const rec_t*,dict_index_t*,const rec_t*,dict_index_t*)" -> "rec_get_deleted_flag(const rec_t*,ulint)"
"row_sel_sec_rec_is_for_clust_rec(const rec_t*,dict_index_t*,const rec_t*,dict_index_t*)" -> "row_sel_sec_rec_is_for_blob(ulint,ulint,ulint,const unsigned char*,ulint,const unsigned char*,ulint,ulint,dict_table_t*)"
"row_sel_sec_rec_is_for_clust_rec(const rec_t*,dict_index_t*,const rec_t*,dict_index_t*)" -> "mem_heap_free_func(mem_heap_t*,const char*,ulint)"
"row_sel_sec_rec_is_for_clust_rec(const rec_t*,dict_index_t*,const rec_t*,dict_index_t*)" -> "rec_get_offsets_func(const rec_t*,const dict_index_t*,ulint*,ulint,mem_heap_t**)"
"row_sel_sec_rec_is_for_clust_rec(const rec_t*,dict_index_t*,const rec_t*,dict_index_t*)" -> "dtype_get_at_most_n_mbchars(ulint,ulint,ulint,ulint,const char*)"
"row_sel_sec_rec_is_for_clust_rec(const rec_t*,dict_index_t*,const rec_t*,dict_index_t*)" -> "dict_table_is_comp(const dict_table_t*)"
"row_sel_sec_rec_is_for_clust_rec(const rec_t*,dict_index_t*,const rec_t*,dict_index_t*)" -> "rec_offs_nth_extern(const ulint*,ulint)"
"row_sel_sec_rec_is_for_clust_rec(const rec_t*,dict_index_t*,const rec_t*,dict_index_t*)" -> "rec_offs_set_n_alloc(ulint*,ulint)"
"row_sel_sec_rec_is_for_clust_rec(const rec_t*,dict_index_t*,const rec_t*,dict_index_t*)" -> "cmp_data_data(ulint,ulint,const unsigned char*,ulint,const unsigned char*,ulint)"
"row_sel_sec_rec_is_for_blob(ulint,ulint,ulint,const unsigned char*,ulint,const unsigned char*,ulint,ulint,dict_table_t*)" -> "btr_copy_externally_stored_field_prefix(unsigned char*,ulint,ulint,const unsigned char*,ulint)"
"row_sel_sec_rec_is_for_blob(ulint,ulint,ulint,const unsigned char*,ulint,const unsigned char*,ulint,ulint,dict_table_t*)" -> "dict_tf_get_zip_size(ulint)"
"row_sel_sec_rec_is_for_blob(ulint,ulint,ulint,const unsigned char*,ulint,const unsigned char*,ulint,ulint,dict_table_t*)" -> "cmp_data_data(ulint,ulint,const unsigned char*,ulint,const unsigned char*,ulint)"
"row_sel_sec_rec_is_for_blob(ulint,ulint,ulint,const unsigned char*,ulint,const unsigned char*,ulint,ulint,dict_table_t*)" -> "__builtin_expect(long int,long int)"
"row_sel_sec_rec_is_for_blob(ulint,ulint,ulint,const unsigned char*,ulint,const unsigned char*,ulint,ulint,dict_table_t*)" -> "dtype_get_at_most_n_mbchars(ulint,ulint,ulint,ulint,const char*)"
"row_sel_sec_rec_is_for_blob(ulint,ulint,ulint,const unsigned char*,ulint,const unsigned char*,ulint,ulint,dict_table_t*)" -> "ut_dbg_assertion_failed(const char*,const char*,ulint)"
"row_sel_sec_rec_is_for_blob(ulint,ulint,ulint,const unsigned char*,ulint,const unsigned char*,ulint,ulint,dict_table_t*)" -> "abort()"
"row_sel_sec_rec_is_for_blob(ulint,ulint,ulint,const unsigned char*,ulint,const unsigned char*,ulint,ulint,dict_table_t*)" -> "memcmp(const void*,const void*,size_t)"
"sel_dequeue_prefetched_row(plan_t*)" -> "que_node_set_val_buf_size(que_node_t*,ulint)"
"sel_dequeue_prefetched_row(plan_t*)" -> "dfield_get_len(const dfield_t*)"
"sel_dequeue_prefetched_row(plan_t*)" -> "que_node_get_val_buf_size(que_node_t*)"
"sel_dequeue_prefetched_row(plan_t*)" -> "dfield_set_data(dfield_t*,const void*,ulint)"
"sel_dequeue_prefetched_row(plan_t*)" -> "que_node_get_val(que_node_t*)"
"sel_set_rec_lock(const buf_block_t*,const rec_t*,dict_index_t*,const ulint*,ulint,ulint,que_thr_t*)" -> "lock_sec_rec_read_check_and_lock(ulint,const buf_block_t*,const rec_t*,dict_index_t*,const ulint*,lock_mode,ulint,que_thr_t*)"
"sel_set_rec_lock(const buf_block_t*,const rec_t*,dict_index_t*,const ulint*,ulint,ulint,que_thr_t*)" -> "buf_LRU_buf_pool_running_out()"
"sel_set_rec_lock(const buf_block_t*,const rec_t*,dict_index_t*,const ulint*,ulint,ulint,que_thr_t*)" -> "thr_get_trx(que_thr_t*)"
"sel_set_rec_lock(const buf_block_t*,const rec_t*,dict_index_t*,const ulint*,ulint,ulint,que_thr_t*)" -> "dict_index_is_clust(const dict_index_t*)"
"sel_set_rec_lock(const buf_block_t*,const rec_t*,dict_index_t*,const ulint*,ulint,ulint,que_thr_t*)" -> "lock_clust_rec_read_check_and_lock(ulint,const buf_block_t*,const rec_t*,dict_index_t*,const ulint*,lock_mode,ulint,que_thr_t*)"
"sel_eval_select_list(sel_node_t*)" -> "que_node_get_next(que_node_t*)"
"sel_eval_select_list(sel_node_t*)" -> "eval_exp(que_node_t*)"
"row_sel_test_end_conds(plan_t*)" -> "eval_sym(sym_node_t*)"
"row_sel_test_end_conds(plan_t*)" -> "eval_cmp(func_node_t*)"
"row_sel_restore_pcur_pos(plan_t*,mtr_t*)" -> "btr_pcur_restore_position_func(ulint,btr_pcur_t*,const char*,ulint,mtr_t*)"
"row_sel_restore_pcur_pos(plan_t*,mtr_t*)" -> "btr_pcur_get_rel_pos(const btr_pcur_t*)"
"btr_pcur_move_to_prev(btr_pcur_t*,mtr_t*)" -> "btr_pcur_is_before_first_on_page(const btr_pcur_t*)"
"btr_pcur_move_to_prev(btr_pcur_t*,mtr_t*)" -> "btr_pcur_move_backward_from_page(btr_pcur_t*,mtr_t*)"
"btr_pcur_move_to_prev(btr_pcur_t*,mtr_t*)" -> "btr_pcur_is_before_first_in_tree(btr_pcur_t*,mtr_t*)"
"btr_pcur_move_to_prev(btr_pcur_t*,mtr_t*)" -> "btr_pcur_move_to_prev_on_page(btr_pcur_t*)"
"btr_pcur_move_backward_from_page(btr_pcur_t*,mtr_t*)" -> "mtr_commit(mtr_t*)"
"btr_pcur_move_backward_from_page(btr_pcur_t*,mtr_t*)" -> "btr_pcur_restore_position_func(ulint,btr_pcur_t*,const char*,ulint,mtr_t*)"
"btr_pcur_move_backward_from_page(btr_pcur_t*,mtr_t*)" -> "mtr_start(mtr_t*)"
"btr_pcur_move_backward_from_page(btr_pcur_t*,mtr_t*)" -> "btr_pcur_store_position(btr_pcur_t*,mtr_t*)"
"btr_pcur_move_backward_from_page(btr_pcur_t*,mtr_t*)" -> "btr_leaf_page_release(buf_block_t*,ulint,mtr_t*)"
"btr_pcur_move_backward_from_page(btr_pcur_t*,mtr_t*)" -> "ut_dbg_assertion_failed(const char*,const char*,ulint)"
"btr_pcur_move_backward_from_page(btr_pcur_t*,mtr_t*)" -> "abort()"
"btr_pcur_move_backward_from_page(btr_pcur_t*,mtr_t*)" -> "btr_pcur_is_before_first_on_page(const btr_pcur_t*)"
"btr_pcur_move_backward_from_page(btr_pcur_t*,mtr_t*)" -> "page_cur_set_after_last(const buf_block_t*,page_cur_t*)"
"btr_pcur_move_backward_from_page(btr_pcur_t*,mtr_t*)" -> "btr_page_get_prev(const ib_page_t*,mtr_t*)"
"btr_pcur_is_before_first_in_tree(btr_pcur_t*,mtr_t*)" -> "btr_page_get_prev(const ib_page_t*,mtr_t*)"
"btr_pcur_is_before_first_in_tree(btr_pcur_t*,mtr_t*)" -> "page_cur_is_before_first(const page_cur_t*)"
"btr_pcur_move_to_prev_on_page(btr_pcur_t*)" -> "page_cur_move_to_prev(page_cur_t*)"
"sel_enqueue_prefetched_row(plan_t*)" -> "dfield_get_len(const dfield_t*)"
"sel_enqueue_prefetched_row(plan_t*)" -> "dfield_set_data(dfield_t*,const void*,ulint)"
"sel_enqueue_prefetched_row(plan_t*)" -> "que_node_get_val(que_node_t*)"
"sel_enqueue_prefetched_row(plan_t*)" -> "que_node_set_val_buf_size(que_node_t*,ulint)"
"sel_enqueue_prefetched_row(plan_t*)" -> "que_node_get_val_buf_size(que_node_t*)"
"sel_enqueue_prefetched_row(plan_t*)" -> "sel_col_prefetch_buf_alloc(sym_node_t*)"
"sel_col_prefetch_buf_alloc(sym_node_t*)" -> "mem_alloc_func(ulint,ulint*)"
"sel_reset_aggregate_vals(sel_node_t*)" -> "que_node_get_next(que_node_t*)"
"sel_reset_aggregate_vals(sel_node_t*)" -> "eval_node_set_int_val(que_node_t*,lint)"
"que_node_get_containing_loop_node(que_node_t*)" -> "que_node_get_parent(que_node_t*)"
"que_node_get_containing_loop_node(que_node_t*)" -> "que_node_get_type(que_node_t*)"
"row_undo_step(que_thr_t*)" -> "thr_get_trx(que_thr_t*)"
"row_undo_step(que_thr_t*)" -> "ut_strerr(dberr_t)"
"row_undo_step(que_thr_t*)" -> "abort()"
"row_undo_step(que_thr_t*)" -> "srv_inc_activity_count()"
"row_undo_step(que_thr_t*)" -> "ut_dbg_assertion_failed(const char*,const char*,ulint)"
"row_undo_step(que_thr_t*)" -> "fprintf(FILE*,const char*,...)"
"row_undo_step(que_thr_t*)" -> "row_undo(undo_node_t*,que_thr_t*)"
"row_undo_step(que_thr_t*)" -> "__builtin_fwrite(const void*,size_t,size_t,FILE*)"
"row_undo_step(que_thr_t*)" -> "exit(int)"
"row_undo(undo_node_t*,que_thr_t*)" -> "row_undo_ins(undo_node_t*)"
"row_undo(undo_node_t*,que_thr_t*)" -> "mem_heap_empty(mem_heap_t*)"
"row_undo(undo_node_t*,que_thr_t*)" -> "trx_roll_pop_top_rec_of_trx(trx_t*,undo_no_t,roll_ptr_t*,mem_heap_t*)"
"row_undo(undo_node_t*,que_thr_t*)" -> "que_node_get_parent(que_node_t*)"
"row_undo(undo_node_t*,que_thr_t*)" -> "row_undo_mod(undo_node_t*,que_thr_t*)"
"row_undo(undo_node_t*,que_thr_t*)" -> "btr_pcur_close(btr_pcur_t*)"
"row_undo(undo_node_t*,que_thr_t*)" -> "row_mysql_unfreeze_data_dictionary(trx_t*)"
"row_undo(undo_node_t*,que_thr_t*)" -> "row_mysql_freeze_data_dictionary_func(trx_t*,const char*,ulint)"
"row_undo(undo_node_t*,que_thr_t*)" -> "trx_undo_rec_get_undo_no(const trx_undo_rec_t*)"
"row_undo(undo_node_t*,que_thr_t*)" -> "trx_undo_roll_ptr_is_insert(roll_ptr_t)"
"row_undo_ins(undo_node_t*)" -> "pfs_mutex_exit_func(ib_mutex_t*)"
"row_undo_ins(undo_node_t*)" -> "row_undo_ins_remove_sec_rec(undo_node_t*)"
"row_undo_ins(undo_node_t*)" -> "dict_table_close(dict_table_t*,ulint,ulint)"
"row_undo_ins(undo_node_t*)" -> "pfs_mutex_enter_func(ib_mutex_t*,const char*,ulint)"
"row_undo_ins(undo_node_t*)" -> "row_undo_ins_parse_undo_rec(undo_node_t*,ulint)"
"row_undo_ins(undo_node_t*)" -> "trx_undo_rec_release(trx_t*,undo_no_t)"
"row_undo_ins(undo_node_t*)" -> "dict_index_is_corrupted(const dict_index_t*)"
"row_undo_ins(undo_node_t*)" -> "log_free_check()"
"row_undo_ins(undo_node_t*)" -> "row_undo_ins_remove_clust_rec(undo_node_t*)"
"row_undo_ins_remove_sec_rec(undo_node_t*)" -> "__builtin_expect(long int,long int)"
"row_undo_ins_remove_sec_rec(undo_node_t*)" -> "row_build_index_entry(const dtuple_t*,const row_ext_t*,dict_index_t*,mem_heap_t*)"
"row_undo_ins_remove_sec_rec(undo_node_t*)" -> "mem_heap_empty(mem_heap_t*)"
"row_undo_ins_remove_sec_rec(undo_node_t*)" -> "mem_heap_free_func(mem_heap_t*,const char*,ulint)"
"row_undo_ins_remove_sec_rec(undo_node_t*)" -> "mem_heap_create_func(ulint,ulint)"
"row_undo_ins_remove_sec_rec(undo_node_t*)" -> "dict_index_is_corrupted(const dict_index_t*)"
"row_undo_ins_remove_sec_rec(undo_node_t*)" -> "row_undo_ins_remove_sec(dict_index_t*,dtuple_t*)"
"row_undo_ins_remove_sec(dict_index_t*,dtuple_t*)" -> "row_undo_ins_remove_sec_low(ulint,dict_index_t*,dtuple_t*)"
"row_undo_ins_remove_sec(dict_index_t*,dtuple_t*)" -> "os_thread_sleep(ulint)"
"row_undo_ins_remove_sec_low(ulint,dict_index_t*,dtuple_t*)" -> "abort()"
"row_undo_ins_remove_sec_low(ulint,dict_index_t*,dtuple_t*)" -> "mtr_s_lock_func(rw_lock_t*,const char*,ulint,mtr_t*)"
"row_undo_ins_remove_sec_low(ulint,dict_index_t*,dtuple_t*)" -> "mtr_commit(mtr_t*)"
"row_undo_ins_remove_sec_low(ulint,dict_index_t*,dtuple_t*)" -> "dict_index_get_lock(dict_index_t*)"
"row_undo_ins_remove_sec_low(ulint,dict_index_t*,dtuple_t*)" -> "btr_cur_pessimistic_delete(dberr_t*,ulint,btr_cur_t*,ulint,trx_rb_ctx,mtr_t*)"
"row_undo_ins_remove_sec_low(ulint,dict_index_t*,dtuple_t*)" -> "row_search_index_entry(dict_index_t*,const dtuple_t*,ulint,btr_pcur_t*,mtr_t*)"
"row_undo_ins_remove_sec_low(ulint,dict_index_t*,dtuple_t*)" -> "mtr_x_lock_func(rw_lock_t*,const char*,ulint,mtr_t*)"
"row_undo_ins_remove_sec_low(ulint,dict_index_t*,dtuple_t*)" -> "mtr_start(mtr_t*)"
"row_undo_ins_remove_sec_low(ulint,dict_index_t*,dtuple_t*)" -> "btr_cur_optimistic_delete_func(btr_cur_t*,mtr_t*)"
"row_undo_ins_remove_sec_low(ulint,dict_index_t*,dtuple_t*)" -> "ut_dbg_assertion_failed(const char*,const char*,ulint)"
"row_undo_ins_remove_sec_low(ulint,dict_index_t*,dtuple_t*)" -> "log_free_check()"
"row_undo_ins_remove_sec_low(ulint,dict_index_t*,dtuple_t*)" -> "btr_pcur_close(btr_pcur_t*)"
"row_undo_ins_remove_sec_low(ulint,dict_index_t*,dtuple_t*)" -> "row_log_online_op_try(dict_index_t*,const dtuple_t*,trx_id_t)"
"row_undo_ins_parse_undo_rec(undo_node_t*,ulint)" -> "trx_undo_rec_get_row_ref(unsigned char*,dict_index_t*,dtuple_t**,mem_heap_t*)"
"row_undo_ins_parse_undo_rec(undo_node_t*,ulint)" -> "trx_undo_rec_get_pars(trx_undo_rec_t*,ulint*,ulint*,bool*,undo_no_t*,table_id_t*)"
"row_undo_ins_parse_undo_rec(undo_node_t*,ulint)" -> "row_undo_search_clust_to_pcur(undo_node_t*)"
"row_undo_ins_parse_undo_rec(undo_node_t*,ulint)" -> "__builtin_expect(long int,long int)"
"row_undo_ins_parse_undo_rec(undo_node_t*,ulint)" -> "dict_table_open_on_id(table_id_t,ulint,dict_table_op_t)"
"row_undo_ins_parse_undo_rec(undo_node_t*,ulint)" -> "ut_print_name(FILE*,const trx_t*,ulint,const char*)"
"row_undo_ins_parse_undo_rec(undo_node_t*,ulint)" -> "dict_table_close(dict_table_t*,ulint,ulint)"
"row_undo_ins_parse_undo_rec(undo_node_t*,ulint)" -> "ut_print_timestamp(FILE*)"
"row_undo_ins_parse_undo_rec(undo_node_t*,ulint)" -> "__builtin_fwrite(const void*,size_t,size_t,FILE*)"
"row_undo_search_clust_to_pcur(undo_node_t*)" -> "btr_pcur_store_position(btr_pcur_t*,mtr_t*)"
"row_undo_search_clust_to_pcur(undo_node_t*)" -> "dtuple_copy(const dtuple_t*,mem_heap_t*)"
"row_undo_search_clust_to_pcur(undo_node_t*)" -> "row_upd_replace(dtuple_t*,row_ext_t**,const dict_index_t*,const upd_t*,mem_heap_t*)"
"row_undo_search_clust_to_pcur(undo_node_t*)" -> "rec_offs_set_n_alloc(ulint*,ulint)"
"row_undo_search_clust_to_pcur(undo_node_t*)" -> "mem_heap_free_func(mem_heap_t*,const char*,ulint)"
"row_undo_search_clust_to_pcur(undo_node_t*)" -> "__builtin_expect(long int,long int)"
"row_undo_search_clust_to_pcur(undo_node_t*)" -> "row_get_rec_roll_ptr(const rec_t*,const dict_index_t*,const ulint*)"
"row_undo_search_clust_to_pcur(undo_node_t*)" -> "row_search_on_row_ref(btr_pcur_t*,ulint,const dict_table_t*,const dtuple_t*,mtr_t*)"
"row_undo_search_clust_to_pcur(undo_node_t*)" -> "btr_pcur_commit_specify_mtr(btr_pcur_t*,mtr_t*)"
"row_undo_search_clust_to_pcur(undo_node_t*)" -> "mtr_start(mtr_t*)"
"row_undo_search_clust_to_pcur(undo_node_t*)" -> "rec_get_offsets_func(const rec_t*,const dict_index_t*,ulint*,ulint,mem_heap_t**)"
"row_undo_search_clust_to_pcur(undo_node_t*)" -> "dict_table_get_format(const dict_table_t*)"
"row_undo_search_clust_to_pcur(undo_node_t*)" -> "row_build(ulint,const dict_index_t*,const rec_t*,const ulint*,const dict_table_t*,const dtuple_t*,const ulint*,row_ext_t**,mem_heap_t*)"
"trx_undo_rec_release(trx_t*,undo_no_t)" -> "pfs_mutex_enter_func(ib_mutex_t*,const char*,ulint)"
"trx_undo_rec_release(trx_t*,undo_no_t)" -> "pfs_mutex_exit_func(ib_mutex_t*)"
"trx_undo_rec_release(trx_t*,undo_no_t)" -> "trx_undo_arr_remove_info(trx_undo_arr_t*,undo_no_t)"
"trx_undo_arr_remove_info(trx_undo_arr_t*,undo_no_t)" -> "trx_undo_arr_get_nth_info(trx_undo_arr_t*,ulint)"
"row_undo_ins_remove_clust_rec(undo_node_t*)" -> "ut_dbg_assertion_failed(const char*,const char*,ulint)"
"row_undo_ins_remove_clust_rec(undo_node_t*)" -> "rec_get_offsets_func(const rec_t*,const dict_index_t*,ulint*,ulint,mem_heap_t**)"
"row_undo_ins_remove_clust_rec(undo_node_t*)" -> "trx_is_recv(const trx_t*)"
"row_undo_ins_remove_clust_rec(undo_node_t*)" -> "mtr_s_lock_func(rw_lock_t*,const char*,ulint,mtr_t*)"
"row_undo_ins_remove_clust_rec(undo_node_t*)" -> "mtr_commit(mtr_t*)"
"row_undo_ins_remove_clust_rec(undo_node_t*)" -> "__builtin_expect(long int,long int)"
"row_undo_ins_remove_clust_rec(undo_node_t*)" -> "os_thread_sleep(ulint)"
"row_undo_ins_remove_clust_rec(undo_node_t*)" -> "dict_index_get_lock(dict_index_t*)"
"row_undo_ins_remove_clust_rec(undo_node_t*)" -> "row_log_table_delete(const rec_t*,dict_index_t*,const ulint*,const unsigned char*)"
"row_undo_ins_remove_clust_rec(undo_node_t*)" -> "btr_pcur_restore_position_func(ulint,btr_pcur_t*,const char*,ulint,mtr_t*)"
"row_undo_ins_remove_clust_rec(undo_node_t*)" -> "btr_cur_optimistic_delete_func(btr_cur_t*,mtr_t*)"
"row_undo_ins_remove_clust_rec(undo_node_t*)" -> "mem_heap_free_func(mem_heap_t*,const char*,ulint)"
"row_undo_ins_remove_clust_rec(undo_node_t*)" -> "trx_undo_rec_release(trx_t*,undo_no_t)"
"row_undo_ins_remove_clust_rec(undo_node_t*)" -> "btr_cur_pessimistic_delete(dberr_t*,ulint,btr_cur_t*,ulint,trx_rb_ctx,mtr_t*)"
"row_undo_ins_remove_clust_rec(undo_node_t*)" -> "mtr_start(mtr_t*)"
"row_undo_ins_remove_clust_rec(undo_node_t*)" -> "btr_pcur_commit_specify_mtr(btr_pcur_t*,mtr_t*)"
"row_undo_ins_remove_clust_rec(undo_node_t*)" -> "abort()"
"row_undo_ins_remove_clust_rec(undo_node_t*)" -> "dict_index_is_online_ddl(const dict_index_t*)"
"row_undo_ins_remove_clust_rec(undo_node_t*)" -> "dict_drop_index_tree(rec_t*,mtr_t*)"
"trx_roll_pop_top_rec_of_trx(trx_t*,undo_no_t,roll_ptr_t*,mem_heap_t*)" -> "trx_undo_arr_store_info(trx_t*,undo_no_t)"
"trx_roll_pop_top_rec_of_trx(trx_t*,undo_no_t,roll_ptr_t*,mem_heap_t*)" -> "mtr_start(mtr_t*)"
"trx_roll_pop_top_rec_of_trx(trx_t*,undo_no_t,roll_ptr_t*,mem_heap_t*)" -> "fflush(FILE*)"
"trx_roll_pop_top_rec_of_trx(trx_t*,undo_no_t,roll_ptr_t*,mem_heap_t*)" -> "trx_roll_pop_top_rec(trx_t*,trx_undo_t*,mtr_t*)"
"trx_roll_pop_top_rec_of_trx(trx_t*,undo_no_t,roll_ptr_t*,mem_heap_t*)" -> "trx_undo_rec_get_undo_no(const trx_undo_rec_t*)"
"trx_roll_pop_top_rec_of_trx(trx_t*,undo_no_t,roll_ptr_t*,mem_heap_t*)" -> "trx_undo_rec_copy(const trx_undo_rec_t*,mem_heap_t*)"
"trx_roll_pop_top_rec_of_trx(trx_t*,undo_no_t,roll_ptr_t*,mem_heap_t*)" -> "trx_roll_try_truncate(trx_t*)"
"trx_roll_pop_top_rec_of_trx(trx_t*,undo_no_t,roll_ptr_t*,mem_heap_t*)" -> "fprintf(FILE*,const char*,...)"
"trx_roll_pop_top_rec_of_trx(trx_t*,undo_no_t,roll_ptr_t*,mem_heap_t*)" -> "trx_undo_build_roll_ptr(ulint,ulint,ulint,ulint)"
"trx_roll_pop_top_rec_of_trx(trx_t*,undo_no_t,roll_ptr_t*,mem_heap_t*)" -> "mtr_commit(mtr_t*)"
"trx_roll_pop_top_rec_of_trx(trx_t*,undo_no_t,roll_ptr_t*,mem_heap_t*)" -> "pfs_mutex_enter_func(ib_mutex_t*,const char*,ulint)"
"trx_roll_pop_top_rec_of_trx(trx_t*,undo_no_t,roll_ptr_t*,mem_heap_t*)" -> "pfs_mutex_exit_func(ib_mutex_t*)"
"trx_undo_arr_store_info(trx_t*,undo_no_t)" -> "ut_dbg_assertion_failed(const char*,const char*,ulint)"
"trx_undo_arr_store_info(trx_t*,undo_no_t)" -> "abort()"
"trx_undo_arr_store_info(trx_t*,undo_no_t)" -> "trx_undo_arr_get_nth_info(trx_undo_arr_t*,ulint)"
"trx_roll_pop_top_rec(trx_t*,trx_undo_t*,mtr_t*)" -> "trx_undo_page_get_s_latched(ulint,ulint,ulint,mtr_t*)"
"trx_roll_pop_top_rec(trx_t*,trx_undo_t*,mtr_t*)" -> "page_get_page_no(const ib_page_t*)"
"trx_roll_pop_top_rec(trx_t*,trx_undo_t*,mtr_t*)" -> "trx_undo_get_prev_rec(trx_undo_rec_t*,ulint,ulint,bool,mtr_t*)"
"trx_roll_pop_top_rec(trx_t*,trx_undo_t*,mtr_t*)" -> "trx_undo_rec_get_undo_no(const trx_undo_rec_t*)"
"trx_roll_pop_top_rec(trx_t*,trx_undo_t*,mtr_t*)" -> "page_align(const void*)"
"trx_undo_get_prev_rec(trx_undo_rec_t*,ulint,ulint,bool,mtr_t*)" -> "trx_undo_get_prev_rec_from_prev_page(trx_undo_rec_t*,ulint,ulint,bool,mtr_t*)"
"trx_undo_get_prev_rec(trx_undo_rec_t*,ulint,ulint,bool,mtr_t*)" -> "trx_undo_page_get_prev_rec(trx_undo_rec_t*,ulint,ulint)"
"trx_undo_get_prev_rec_from_prev_page(trx_undo_rec_t*,ulint,ulint,bool,mtr_t*)" -> "page_align(const void*)"
"trx_undo_get_prev_rec_from_prev_page(trx_undo_rec_t*,ulint,ulint,bool,mtr_t*)" -> "trx_undo_page_get_last_rec(ib_page_t*,ulint,ulint)"
"trx_undo_get_prev_rec_from_prev_page(trx_undo_rec_t*,ulint,ulint,bool,mtr_t*)" -> "buf_page_get_gen(ulint,ulint,ulint,ulint,buf_block_t*,ulint,const char*,ulint,mtr_t*)"
"trx_undo_get_prev_rec_from_prev_page(trx_undo_rec_t*,ulint,ulint,bool,mtr_t*)" -> "fil_space_get_zip_size(ulint)"
"trx_undo_get_prev_rec_from_prev_page(trx_undo_rec_t*,ulint,ulint,bool,mtr_t*)" -> "flst_get_prev_addr(const flst_node_t*,mtr_t*)"
"trx_undo_get_prev_rec_from_prev_page(trx_undo_rec_t*,ulint,ulint,bool,mtr_t*)" -> "page_get_space_id(const ib_page_t*)"
"trx_undo_page_get_last_rec(ib_page_t*,ulint,ulint)" -> "trx_undo_page_get_end(ib_page_t*,ulint,ulint)"
"trx_undo_page_get_last_rec(ib_page_t*,ulint,ulint)" -> "trx_undo_page_get_start(ib_page_t*,ulint,ulint)"
"trx_undo_page_get_last_rec(ib_page_t*,ulint,ulint)" -> "mach_read_from_2(const unsigned char*)"
"trx_undo_page_get_end(ib_page_t*,ulint,ulint)" -> "page_get_page_no(const ib_page_t*)"
"trx_undo_page_get_end(ib_page_t*,ulint,ulint)" -> "mach_read_from_2(const unsigned char*)"
"trx_undo_page_get_start(ib_page_t*,ulint,ulint)" -> "page_get_page_no(const ib_page_t*)"
"trx_undo_page_get_start(ib_page_t*,ulint,ulint)" -> "mach_read_from_2(const unsigned char*)"
"trx_undo_page_get_prev_rec(trx_undo_rec_t*,ulint,ulint)" -> "mach_read_from_2(const unsigned char*)"
"trx_undo_page_get_prev_rec(trx_undo_rec_t*,ulint,ulint)" -> "trx_undo_page_get_start(ib_page_t*,ulint,ulint)"
"trx_undo_page_get_prev_rec(trx_undo_rec_t*,ulint,ulint)" -> "ut_align_down(const void*,ulint)"
"trx_roll_try_truncate(trx_t*)" -> "trx_undo_truncate_end_func(trx_undo_t*,undo_no_t)"
"trx_roll_try_truncate(trx_t*)" -> "trx_undo_arr_get_biggest(const trx_undo_arr_t*)"
"trx_undo_truncate_end_func(trx_undo_t*,undo_no_t)" -> "trx_undo_free_last_page_func(trx_undo_t*,mtr_t*)"
"trx_undo_truncate_end_func(trx_undo_t*,undo_no_t)" -> "trx_undo_page_get_last_rec(ib_page_t*,ulint,ulint)"
"trx_undo_truncate_end_func(trx_undo_t*,undo_no_t)" -> "trx_undo_page_get(ulint,ulint,ulint,mtr_t*)"
"trx_undo_truncate_end_func(trx_undo_t*,undo_no_t)" -> "mtr_start(mtr_t*)"
"trx_undo_truncate_end_func(trx_undo_t*,undo_no_t)" -> "trx_undo_page_get_prev_rec(trx_undo_rec_t*,ulint,ulint)"
"trx_undo_truncate_end_func(trx_undo_t*,undo_no_t)" -> "trx_undo_rec_get_undo_no(const trx_undo_rec_t*)"
"trx_undo_truncate_end_func(trx_undo_t*,undo_no_t)" -> "mlog_write_ulint(unsigned char*,ulint,unsigned char,mtr_t*)"
"trx_undo_truncate_end_func(trx_undo_t*,undo_no_t)" -> "mtr_commit(mtr_t*)"
"row_undo_mod(undo_node_t*,que_thr_t*)" -> "abort()"
"row_undo_mod(undo_node_t*,que_thr_t*)" -> "dict_index_is_corrupted(const dict_index_t*)"
"row_undo_mod(undo_node_t*,que_thr_t*)" -> "thr_get_trx(que_thr_t*)"
"row_undo_mod(undo_node_t*,que_thr_t*)" -> "ut_dbg_assertion_failed(const char*,const char*,ulint)"
"row_undo_mod(undo_node_t*,que_thr_t*)" -> "row_undo_mod_upd_exist_sec(undo_node_t*,que_thr_t*)"
"row_undo_mod(undo_node_t*,que_thr_t*)" -> "trx_undo_rec_release(trx_t*,undo_no_t)"
"row_undo_mod(undo_node_t*,que_thr_t*)" -> "row_undo_mod_clust(undo_node_t*,que_thr_t*)"
"row_undo_mod(undo_node_t*,que_thr_t*)" -> "row_undo_mod_del_mark_sec(undo_node_t*,que_thr_t*)"
"row_undo_mod(undo_node_t*,que_thr_t*)" -> "row_undo_mod_upd_del_sec(undo_node_t*,que_thr_t*)"
"row_undo_mod(undo_node_t*,que_thr_t*)" -> "row_undo_mod_parse_undo_rec(undo_node_t*,ulint)"
"row_undo_mod(undo_node_t*,que_thr_t*)" -> "dict_table_close(dict_table_t*,ulint,ulint)"
"row_undo_mod_upd_exist_sec(undo_node_t*,que_thr_t*)" -> "dict_index_is_corrupted(const dict_index_t*)"
"row_undo_mod_upd_exist_sec(undo_node_t*,que_thr_t*)" -> "row_upd_changes_ord_field_binary_func(dict_index_t*,const upd_t*,const dtuple_t*,const row_ext_t*)"
"row_undo_mod_upd_exist_sec(undo_node_t*,que_thr_t*)" -> "mem_heap_empty(mem_heap_t*)"
"row_undo_mod_upd_exist_sec(undo_node_t*,que_thr_t*)" -> "mem_heap_free_func(mem_heap_t*,const char*,ulint)"
"row_undo_mod_upd_exist_sec(undo_node_t*,que_thr_t*)" -> "row_build_index_entry(const dtuple_t*,const row_ext_t*,dict_index_t*,mem_heap_t*)"
"row_undo_mod_upd_exist_sec(undo_node_t*,que_thr_t*)" -> "ut_dbg_assertion_failed(const char*,const char*,ulint)"
"row_undo_mod_upd_exist_sec(undo_node_t*,que_thr_t*)" -> "row_undo_mod_del_mark_or_remove_sec(undo_node_t*,que_thr_t*,dict_index_t*,dtuple_t*)"
"row_undo_mod_upd_exist_sec(undo_node_t*,que_thr_t*)" -> "__builtin_expect(long int,long int)"
"row_undo_mod_upd_exist_sec(undo_node_t*,que_thr_t*)" -> "mem_heap_create_func(ulint,ulint)"
"row_undo_mod_upd_exist_sec(undo_node_t*,que_thr_t*)" -> "row_undo_mod_sec_flag_corrupted(trx_t*,dict_index_t*)"
"row_undo_mod_upd_exist_sec(undo_node_t*,que_thr_t*)" -> "abort()"
"row_undo_mod_upd_exist_sec(undo_node_t*,que_thr_t*)" -> "dict_table_get_format(const dict_table_t*)"
"row_undo_mod_upd_exist_sec(undo_node_t*,que_thr_t*)" -> "thr_get_trx(que_thr_t*)"
"row_undo_mod_upd_exist_sec(undo_node_t*,que_thr_t*)" -> "row_undo_mod_del_unmark_sec_and_undo_update(ulint,que_thr_t*,dict_index_t*,dtuple_t*)"
"row_undo_mod_del_mark_or_remove_sec(undo_node_t*,que_thr_t*,dict_index_t*,dtuple_t*)" -> "row_undo_mod_del_mark_or_remove_sec_low(undo_node_t*,que_thr_t*,dict_index_t*,dtuple_t*,ulint)"
"row_undo_mod_del_mark_or_remove_sec_low(undo_node_t*,que_thr_t*,dict_index_t*,dtuple_t*,ulint)" -> "abort()"
"row_undo_mod_del_mark_or_remove_sec_low(undo_node_t*,que_thr_t*,dict_index_t*,dtuple_t*,ulint)" -> "btr_cur_optimistic_delete_func(btr_cur_t*,mtr_t*)"
"row_undo_mod_del_mark_or_remove_sec_low(undo_node_t*,que_thr_t*,dict_index_t*,dtuple_t*,ulint)" -> "btr_cur_del_mark_set_sec_rec(ulint,btr_cur_t*,ulint,que_thr_t*,mtr_t*)"
"row_undo_mod_del_mark_or_remove_sec_low(undo_node_t*,que_thr_t*,dict_index_t*,dtuple_t*,ulint)" -> "row_vers_old_has_index_entry(ulint,const rec_t*,mtr_t*,dict_index_t*,const dtuple_t*)"
"row_undo_mod_del_mark_or_remove_sec_low(undo_node_t*,que_thr_t*,dict_index_t*,dtuple_t*,ulint)" -> "dict_index_get_lock(dict_index_t*)"
"row_undo_mod_del_mark_or_remove_sec_low(undo_node_t*,que_thr_t*,dict_index_t*,dtuple_t*,ulint)" -> "btr_pcur_restore_position_func(ulint,btr_pcur_t*,const char*,ulint,mtr_t*)"
"row_undo_mod_del_mark_or_remove_sec_low(undo_node_t*,que_thr_t*,dict_index_t*,dtuple_t*,ulint)" -> "row_log_online_op_try(dict_index_t*,const dtuple_t*,trx_id_t)"
"row_undo_mod_del_mark_or_remove_sec_low(undo_node_t*,que_thr_t*,dict_index_t*,dtuple_t*,ulint)" -> "mtr_commit(mtr_t*)"
"row_undo_mod_del_mark_or_remove_sec_low(undo_node_t*,que_thr_t*,dict_index_t*,dtuple_t*,ulint)" -> "btr_pcur_close(btr_pcur_t*)"
"row_undo_mod_del_mark_or_remove_sec_low(undo_node_t*,que_thr_t*,dict_index_t*,dtuple_t*,ulint)" -> "mtr_x_lock_func(rw_lock_t*,const char*,ulint,mtr_t*)"
"row_undo_mod_del_mark_or_remove_sec_low(undo_node_t*,que_thr_t*,dict_index_t*,dtuple_t*,ulint)" -> "log_free_check()"
"row_undo_mod_del_mark_or_remove_sec_low(undo_node_t*,que_thr_t*,dict_index_t*,dtuple_t*,ulint)" -> "ut_dbg_assertion_failed(const char*,const char*,ulint)"
"row_undo_mod_del_mark_or_remove_sec_low(undo_node_t*,que_thr_t*,dict_index_t*,dtuple_t*,ulint)" -> "btr_pcur_commit_specify_mtr(btr_pcur_t*,mtr_t*)"
"row_undo_mod_del_mark_or_remove_sec_low(undo_node_t*,que_thr_t*,dict_index_t*,dtuple_t*,ulint)" -> "btr_cur_pessimistic_delete(dberr_t*,ulint,btr_cur_t*,ulint,trx_rb_ctx,mtr_t*)"
"row_undo_mod_del_mark_or_remove_sec_low(undo_node_t*,que_thr_t*,dict_index_t*,dtuple_t*,ulint)" -> "row_search_index_entry(dict_index_t*,const dtuple_t*,ulint,btr_pcur_t*,mtr_t*)"
"row_undo_mod_del_mark_or_remove_sec_low(undo_node_t*,que_thr_t*,dict_index_t*,dtuple_t*,ulint)" -> "__builtin_expect(long int,long int)"
"row_undo_mod_del_mark_or_remove_sec_low(undo_node_t*,que_thr_t*,dict_index_t*,dtuple_t*,ulint)" -> "mtr_s_lock_func(rw_lock_t*,const char*,ulint,mtr_t*)"
"row_undo_mod_del_mark_or_remove_sec_low(undo_node_t*,que_thr_t*,dict_index_t*,dtuple_t*,ulint)" -> "mtr_start(mtr_t*)"
"row_undo_mod_sec_flag_corrupted(trx_t*,dict_index_t*)" -> "pfs_mutex_enter_func(ib_mutex_t*,const char*,ulint)"
"row_undo_mod_sec_flag_corrupted(trx_t*,dict_index_t*)" -> "pfs_mutex_exit_func(ib_mutex_t*)"
"row_undo_mod_sec_flag_corrupted(trx_t*,dict_index_t*)" -> "dict_set_corrupted(dict_index_t*,trx_t*,const char*)"
"row_undo_mod_sec_flag_corrupted(trx_t*,dict_index_t*)" -> "dict_set_corrupted_index_cache_only(dict_index_t*,dict_table_t*)"
"dict_set_corrupted(dict_index_t*,trx_t*,const char*)" -> "row_mysql_unlock_data_dictionary(trx_t*)"
"dict_set_corrupted(dict_index_t*,trx_t*,const char*)" -> "mem_heap_create_func(ulint,ulint)"
"dict_set_corrupted(dict_index_t*,trx_t*,const char*)" -> "btr_cur_search_to_nth_level(dict_index_t*,ulint,const dtuple_t*,ulint,ulint,btr_cur_t*,ulint,const char*,ulint,mtr_t*)"
"dict_set_corrupted(dict_index_t*,trx_t*,const char*)" -> "dict_index_copy_types(dtuple_t*,const dict_index_t*,ulint)"
"dict_set_corrupted(dict_index_t*,trx_t*,const char*)" -> "mtr_start(mtr_t*)"
"dict_set_corrupted(dict_index_t*,trx_t*,const char*)" -> "mem_heap_alloc(mem_heap_t*,ulint)"
"dict_set_corrupted(dict_index_t*,trx_t*,const char*)" -> "rec_get_nth_field_offs_old(const rec_t*,ulint,ulint*)"
"dict_set_corrupted(dict_index_t*,trx_t*,const char*)" -> "dfield_set_data(dfield_t*,const void*,ulint)"
"dict_set_corrupted(dict_index_t*,trx_t*,const char*)" -> "mtr_commit(mtr_t*)"
"dict_set_corrupted(dict_index_t*,trx_t*,const char*)" -> "mem_heap_free_func(mem_heap_t*,const char*,ulint)"
"dict_set_corrupted(dict_index_t*,trx_t*,const char*)" -> "dtuple_get_n_fields(const dtuple_t*)"
"dict_set_corrupted(dict_index_t*,trx_t*,const char*)" -> "strlen(const char*)"
"dict_set_corrupted(dict_index_t*,trx_t*,const char*)" -> "dtuple_create(mem_heap_t*,ulint)"
"dict_set_corrupted(dict_index_t*,trx_t*,const char*)" -> "mem_heap_empty(mem_heap_t*)"
"dict_set_corrupted(dict_index_t*,trx_t*,const char*)" -> "innobase_convert_name(char*,ulint,const char*,ulint,THD*,ulint)"
"dict_set_corrupted(dict_index_t*,trx_t*,const char*)" -> "ib_logf(ib_log_level_t,const char*,...)"
"dict_set_corrupted(dict_index_t*,trx_t*,const char*)" -> "row_mysql_lock_data_dictionary_func(trx_t*,const char*,ulint)"
"dict_set_corrupted(dict_index_t*,trx_t*,const char*)" -> "mlog_write_ulint(unsigned char*,ulint,unsigned char,mtr_t*)"
"dict_set_corrupted(dict_index_t*,trx_t*,const char*)" -> "dict_index_is_clust(const dict_index_t*)"
"dict_set_corrupted(dict_index_t*,trx_t*,const char*)" -> "mach_write_to_8(void*,ib_uint64_t)"
"row_undo_mod_del_unmark_sec_and_undo_update(ulint,que_thr_t*,dict_index_t*,dtuple_t*)" -> "mem_heap_create_func(ulint,ulint)"
"row_undo_mod_del_unmark_sec_and_undo_update(ulint,que_thr_t*,dict_index_t*,dtuple_t*)" -> "btr_cur_del_mark_set_sec_rec(ulint,btr_cur_t*,ulint,que_thr_t*,mtr_t*)"
"row_undo_mod_del_unmark_sec_and_undo_update(ulint,que_thr_t*,dict_index_t*,dtuple_t*)" -> "row_search_index_entry(dict_index_t*,const dtuple_t*,ulint,btr_pcur_t*,mtr_t*)"
"row_undo_mod_del_unmark_sec_and_undo_update(ulint,que_thr_t*,dict_index_t*,dtuple_t*)" -> "ut_dbg_assertion_failed(const char*,const char*,ulint)"
"row_undo_mod_del_unmark_sec_and_undo_update(ulint,que_thr_t*,dict_index_t*,dtuple_t*)" -> "rec_print(FILE*,const rec_t*,const dict_index_t*)"
"row_undo_mod_del_unmark_sec_and_undo_update(ulint,que_thr_t*,dict_index_t*,dtuple_t*)" -> "abort()"
"row_undo_mod_del_unmark_sec_and_undo_update(ulint,que_thr_t*,dict_index_t*,dtuple_t*)" -> "row_log_online_op_try(dict_index_t*,const dtuple_t*,trx_id_t)"
"row_undo_mod_del_unmark_sec_and_undo_update(ulint,que_thr_t*,dict_index_t*,dtuple_t*)" -> "thr_get_trx(que_thr_t*)"
"row_undo_mod_del_unmark_sec_and_undo_update(ulint,que_thr_t*,dict_index_t*,dtuple_t*)" -> "upd_get_n_fields(const upd_t*)"
"row_undo_mod_del_unmark_sec_and_undo_update(ulint,que_thr_t*,dict_index_t*,dtuple_t*)" -> "rec_get_offsets_func(const rec_t*,const dict_index_t*,ulint*,ulint,mem_heap_t**)"
"row_undo_mod_del_unmark_sec_and_undo_update(ulint,que_thr_t*,dict_index_t*,dtuple_t*)" -> "btr_pcur_close(btr_pcur_t*)"
"row_undo_mod_del_unmark_sec_and_undo_update(ulint,que_thr_t*,dict_index_t*,dtuple_t*)" -> "mtr_commit(mtr_t*)"
"row_undo_mod_del_unmark_sec_and_undo_update(ulint,que_thr_t*,dict_index_t*,dtuple_t*)" -> "dict_index_name_print(FILE*,const trx_t*,const dict_index_t*)"
"row_undo_mod_del_unmark_sec_and_undo_update(ulint,que_thr_t*,dict_index_t*,dtuple_t*)" -> "mtr_start(mtr_t*)"
"row_undo_mod_del_unmark_sec_and_undo_update(ulint,que_thr_t*,dict_index_t*,dtuple_t*)" -> "__builtin_expect(long int,long int)"
"row_undo_mod_del_unmark_sec_and_undo_update(ulint,que_thr_t*,dict_index_t*,dtuple_t*)" -> "row_upd_build_sec_rec_difference_binary(const rec_t*,dict_index_t*,const ulint*,const dtuple_t*,mem_heap_t*)"
"row_undo_mod_del_unmark_sec_and_undo_update(ulint,que_thr_t*,dict_index_t*,dtuple_t*)" -> "mtr_x_lock_func(rw_lock_t*,const char*,ulint,mtr_t*)"
"row_undo_mod_del_unmark_sec_and_undo_update(ulint,que_thr_t*,dict_index_t*,dtuple_t*)" -> "trx_print(FILE*,const trx_t*,ulint)"
"row_undo_mod_del_unmark_sec_and_undo_update(ulint,que_thr_t*,dict_index_t*,dtuple_t*)" -> "btr_cur_pessimistic_update(ulint,btr_cur_t*,ulint**,mem_heap_t**,mem_heap_t*,big_rec_t**,const upd_t*,ulint,que_thr_t*,trx_id_t,mtr_t*)"
"row_undo_mod_del_unmark_sec_and_undo_update(ulint,que_thr_t*,dict_index_t*,dtuple_t*)" -> "dtuple_get_n_fields(const dtuple_t*)"
"row_undo_mod_del_unmark_sec_and_undo_update(ulint,que_thr_t*,dict_index_t*,dtuple_t*)" -> "btr_cur_optimistic_insert(ulint,btr_cur_t*,ulint**,mem_heap_t**,dtuple_t*,rec_t**,big_rec_t**,ulint,que_thr_t*,mtr_t*)"
"row_undo_mod_del_unmark_sec_and_undo_update(ulint,que_thr_t*,dict_index_t*,dtuple_t*)" -> "page_update_max_trx_id(buf_block_t*,page_zip_des_t*,trx_id_t,mtr_t*)"
"row_undo_mod_del_unmark_sec_and_undo_update(ulint,que_thr_t*,dict_index_t*,dtuple_t*)" -> "__builtin_fwrite(const void*,size_t,size_t,FILE*)"
"row_undo_mod_del_unmark_sec_and_undo_update(ulint,que_thr_t*,dict_index_t*,dtuple_t*)" -> "mem_heap_free_func(mem_heap_t*,const char*,ulint)"
"row_undo_mod_del_unmark_sec_and_undo_update(ulint,que_thr_t*,dict_index_t*,dtuple_t*)" -> "btr_cur_pessimistic_insert(ulint,btr_cur_t*,ulint**,mem_heap_t**,dtuple_t*,rec_t**,big_rec_t**,ulint,que_thr_t*,mtr_t*)"
"row_undo_mod_del_unmark_sec_and_undo_update(ulint,que_thr_t*,dict_index_t*,dtuple_t*)" -> "ib_logf(ib_log_level_t,const char*,...)"
"row_undo_mod_del_unmark_sec_and_undo_update(ulint,que_thr_t*,dict_index_t*,dtuple_t*)" -> "log_free_check()"
"row_undo_mod_del_unmark_sec_and_undo_update(ulint,que_thr_t*,dict_index_t*,dtuple_t*)" -> "_IO_putc(int,_IO_FILE*)"
"row_undo_mod_del_unmark_sec_and_undo_update(ulint,que_thr_t*,dict_index_t*,dtuple_t*)" -> "dict_index_get_lock(dict_index_t*)"
"row_undo_mod_del_unmark_sec_and_undo_update(ulint,que_thr_t*,dict_index_t*,dtuple_t*)" -> "mtr_s_lock_func(rw_lock_t*,const char*,ulint,mtr_t*)"
"row_undo_mod_del_unmark_sec_and_undo_update(ulint,que_thr_t*,dict_index_t*,dtuple_t*)" -> "btr_cur_optimistic_update(ulint,btr_cur_t*,ulint**,mem_heap_t**,const upd_t*,ulint,que_thr_t*,trx_id_t,mtr_t*)"
"row_undo_mod_del_unmark_sec_and_undo_update(ulint,que_thr_t*,dict_index_t*,dtuple_t*)" -> "btr_cur_get_page_zip(btr_cur_t*)"
"row_undo_mod_del_unmark_sec_and_undo_update(ulint,que_thr_t*,dict_index_t*,dtuple_t*)" -> "dict_index_get_n_unique(const dict_index_t*)"
"row_undo_mod_del_unmark_sec_and_undo_update(ulint,que_thr_t*,dict_index_t*,dtuple_t*)" -> "dtuple_print(FILE*,const dtuple_t*)"
"row_undo_mod_clust(undo_node_t*,que_thr_t*)" -> "dict_index_is_online_ddl(const dict_index_t*)"
"row_undo_mod_clust(undo_node_t*,que_thr_t*)" -> "row_undo_mod_remove_clust_low(undo_node_t*,que_thr_t*,mtr_t*,ulint)"
"row_undo_mod_clust(undo_node_t*,que_thr_t*)" -> "row_undo_mod_clust_low(undo_node_t*,ulint**,mem_heap_t**,mem_heap_t*,const dtuple_t**,unsigned char*,que_thr_t*,mtr_t*,ulint)"
"row_undo_mod_clust(undo_node_t*,que_thr_t*)" -> "dict_index_get_lock(dict_index_t*)"
"row_undo_mod_clust(undo_node_t*,que_thr_t*)" -> "row_log_table_delete(const rec_t*,dict_index_t*,const ulint*,const unsigned char*)"
"row_undo_mod_clust(undo_node_t*,que_thr_t*)" -> "log_free_check()"
"row_undo_mod_clust(undo_node_t*,que_thr_t*)" -> "mtr_start(mtr_t*)"
"row_undo_mod_clust(undo_node_t*,que_thr_t*)" -> "trx_undo_rec_release(trx_t*,undo_no_t)"
"row_undo_mod_clust(undo_node_t*,que_thr_t*)" -> "row_log_table_update(const rec_t*,dict_index_t*,const ulint*,const dtuple_t*)"
"row_undo_mod_clust(undo_node_t*,que_thr_t*)" -> "btr_pcur_commit_specify_mtr(btr_pcur_t*,mtr_t*)"
"row_undo_mod_clust(undo_node_t*,que_thr_t*)" -> "row_log_table_insert(const rec_t*,dict_index_t*,const ulint*)"
"row_undo_mod_clust(undo_node_t*,que_thr_t*)" -> "mtr_s_lock_func(rw_lock_t*,const char*,ulint,mtr_t*)"
"row_undo_mod_clust(undo_node_t*,que_thr_t*)" -> "mem_heap_create_func(ulint,ulint)"
"row_undo_mod_clust(undo_node_t*,que_thr_t*)" -> "mem_heap_free_func(mem_heap_t*,const char*,ulint)"
"row_undo_mod_remove_clust_low(undo_node_t*,que_thr_t*,mtr_t*,ulint)" -> "trx_read_trx_id(const unsigned char*)"
"row_undo_mod_remove_clust_low(undo_node_t*,que_thr_t*,mtr_t*,ulint)" -> "rec_get_nth_field_offs(const ulint*,ulint,ulint*)"
"row_undo_mod_remove_clust_low(undo_node_t*,que_thr_t*,mtr_t*,ulint)" -> "rec_get_offsets_func(const rec_t*,const dict_index_t*,ulint*,ulint,mem_heap_t**)"
"row_undo_mod_remove_clust_low(undo_node_t*,que_thr_t*,mtr_t*,ulint)" -> "btr_pcur_restore_position_func(ulint,btr_pcur_t*,const char*,ulint,mtr_t*)"
"row_undo_mod_remove_clust_low(undo_node_t*,que_thr_t*,mtr_t*,ulint)" -> "row_vers_must_preserve_del_marked(trx_id_t,mtr_t*)"
"row_undo_mod_remove_clust_low(undo_node_t*,que_thr_t*,mtr_t*,ulint)" -> "btr_cur_optimistic_delete_func(btr_cur_t*,mtr_t*)"
"row_undo_mod_remove_clust_low(undo_node_t*,que_thr_t*,mtr_t*,ulint)" -> "btr_cur_pessimistic_delete(dberr_t*,ulint,btr_cur_t*,ulint,trx_rb_ctx,mtr_t*)"
"row_undo_mod_remove_clust_low(undo_node_t*,que_thr_t*,mtr_t*,ulint)" -> "thr_is_recv(const que_thr_t*)"
"row_undo_mod_remove_clust_low(undo_node_t*,que_thr_t*,mtr_t*,ulint)" -> "dict_index_get_sys_col_pos(const dict_index_t*,ulint)"
"row_undo_mod_remove_clust_low(undo_node_t*,que_thr_t*,mtr_t*,ulint)" -> "mem_heap_free_func(mem_heap_t*,const char*,ulint)"
"row_vers_must_preserve_del_marked(trx_id_t,mtr_t*)" -> "mtr_s_lock_func(rw_lock_t*,const char*,ulint,mtr_t*)"
"row_vers_must_preserve_del_marked(trx_id_t,mtr_t*)" -> "read_view_sees_trx_id(const read_view_t*,trx_id_t)"
"thr_is_recv(const que_thr_t*)" -> "trx_is_recv(const trx_t*)"
"row_undo_mod_clust_low(undo_node_t*,ulint**,mem_heap_t**,mem_heap_t*,const dtuple_t**,unsigned char*,que_thr_t*,mtr_t*,ulint)" -> "ut_dbg_assertion_failed(const char*,const char*,ulint)"
"row_undo_mod_clust_low(undo_node_t*,ulint**,mem_heap_t**,mem_heap_t*,const dtuple_t**,unsigned char*,que_thr_t*,mtr_t*,ulint)" -> "row_log_table_get_pk(const rec_t*,dict_index_t*,const ulint*,unsigned char*,mem_heap_t**)"
"row_undo_mod_clust_low(undo_node_t*,ulint**,mem_heap_t**,mem_heap_t*,const dtuple_t**,unsigned char*,que_thr_t*,mtr_t*,ulint)" -> "abort()"
"row_undo_mod_clust_low(undo_node_t*,ulint**,mem_heap_t**,mem_heap_t*,const dtuple_t**,unsigned char*,que_thr_t*,mtr_t*,ulint)" -> "btr_cur_optimistic_update(ulint,btr_cur_t*,ulint**,mem_heap_t**,const upd_t*,ulint,que_thr_t*,trx_id_t,mtr_t*)"
"row_undo_mod_clust_low(undo_node_t*,ulint**,mem_heap_t**,mem_heap_t*,const dtuple_t**,unsigned char*,que_thr_t*,mtr_t*,ulint)" -> "dict_index_is_online_ddl(const dict_index_t*)"
"row_undo_mod_clust_low(undo_node_t*,ulint**,mem_heap_t**,mem_heap_t*,const dtuple_t**,unsigned char*,que_thr_t*,mtr_t*,ulint)" -> "btr_pcur_restore_position_func(ulint,btr_pcur_t*,const char*,ulint,mtr_t*)"
"row_undo_mod_clust_low(undo_node_t*,ulint**,mem_heap_t**,mem_heap_t*,const dtuple_t**,unsigned char*,que_thr_t*,mtr_t*,ulint)" -> "btr_cur_pessimistic_update(ulint,btr_cur_t*,ulint**,mem_heap_t**,mem_heap_t*,big_rec_t**,const upd_t*,ulint,que_thr_t*,trx_id_t,mtr_t*)"
"row_undo_mod_clust_low(undo_node_t*,ulint**,mem_heap_t**,mem_heap_t*,const dtuple_t**,unsigned char*,que_thr_t*,mtr_t*,ulint)" -> "thr_get_trx(que_thr_t*)"
"row_undo_mod_clust_low(undo_node_t*,ulint**,mem_heap_t**,mem_heap_t*,const dtuple_t**,unsigned char*,que_thr_t*,mtr_t*,ulint)" -> "__builtin_expect(long int,long int)"
"row_undo_mod_del_mark_sec(undo_node_t*,que_thr_t*)" -> "abort()"
"row_undo_mod_del_mark_sec(undo_node_t*,que_thr_t*)" -> "__builtin_expect(long int,long int)"
"row_undo_mod_del_mark_sec(undo_node_t*,que_thr_t*)" -> "row_undo_mod_del_unmark_sec_and_undo_update(ulint,que_thr_t*,dict_index_t*,dtuple_t*)"
"row_undo_mod_del_mark_sec(undo_node_t*,que_thr_t*)" -> "mem_heap_create_func(ulint,ulint)"
"row_undo_mod_del_mark_sec(undo_node_t*,que_thr_t*)" -> "row_undo_mod_sec_flag_corrupted(trx_t*,dict_index_t*)"
"row_undo_mod_del_mark_sec(undo_node_t*,que_thr_t*)" -> "ut_dbg_assertion_failed(const char*,const char*,ulint)"
"row_undo_mod_del_mark_sec(undo_node_t*,que_thr_t*)" -> "thr_get_trx(que_thr_t*)"
"row_undo_mod_del_mark_sec(undo_node_t*,que_thr_t*)" -> "mem_heap_free_func(mem_heap_t*,const char*,ulint)"
"row_undo_mod_del_mark_sec(undo_node_t*,que_thr_t*)" -> "dict_index_is_corrupted(const dict_index_t*)"
"row_undo_mod_del_mark_sec(undo_node_t*,que_thr_t*)" -> "mem_heap_empty(mem_heap_t*)"
"row_undo_mod_del_mark_sec(undo_node_t*,que_thr_t*)" -> "row_build_index_entry(const dtuple_t*,const row_ext_t*,dict_index_t*,mem_heap_t*)"
"row_undo_mod_upd_del_sec(undo_node_t*,que_thr_t*)" -> "mem_heap_free_func(mem_heap_t*,const char*,ulint)"
"row_undo_mod_upd_del_sec(undo_node_t*,que_thr_t*)" -> "__builtin_expect(long int,long int)"
"row_undo_mod_upd_del_sec(undo_node_t*,que_thr_t*)" -> "mem_heap_create_func(ulint,ulint)"
"row_undo_mod_upd_del_sec(undo_node_t*,que_thr_t*)" -> "dict_index_is_corrupted(const dict_index_t*)"
"row_undo_mod_upd_del_sec(undo_node_t*,que_thr_t*)" -> "row_build_index_entry(const dtuple_t*,const row_ext_t*,dict_index_t*,mem_heap_t*)"
"row_undo_mod_upd_del_sec(undo_node_t*,que_thr_t*)" -> "abort()"
"row_undo_mod_upd_del_sec(undo_node_t*,que_thr_t*)" -> "thr_is_recv(const que_thr_t*)"
"row_undo_mod_upd_del_sec(undo_node_t*,que_thr_t*)" -> "row_undo_mod_del_mark_or_remove_sec(undo_node_t*,que_thr_t*,dict_index_t*,dtuple_t*)"
"row_undo_mod_upd_del_sec(undo_node_t*,que_thr_t*)" -> "mem_heap_empty(mem_heap_t*)"
"row_undo_mod_upd_del_sec(undo_node_t*,que_thr_t*)" -> "ut_dbg_assertion_failed(const char*,const char*,ulint)"
"row_undo_mod_parse_undo_rec(undo_node_t*,ulint)" -> "trx_undo_update_rec_get_sys_cols(unsigned char*,trx_id_t*,roll_ptr_t*,ulint*)"
"row_undo_mod_parse_undo_rec(undo_node_t*,ulint)" -> "row_undo_search_clust_to_pcur(undo_node_t*)"
"row_undo_mod_parse_undo_rec(undo_node_t*,ulint)" -> "trx_undo_rec_get_row_ref(unsigned char*,dict_index_t*,dtuple_t**,mem_heap_t*)"
"row_undo_mod_parse_undo_rec(undo_node_t*,ulint)" -> "trx_undo_update_rec_get_update(unsigned char*,dict_index_t*,ulint,trx_id_t,roll_ptr_t,ulint,trx_t*,mem_heap_t*,upd_t**)"
"row_undo_mod_parse_undo_rec(undo_node_t*,ulint)" -> "trx_undo_rec_get_pars(trx_undo_rec_t*,ulint*,ulint*,bool*,undo_no_t*,table_id_t*)"
"row_undo_mod_parse_undo_rec(undo_node_t*,ulint)" -> "dict_table_close(dict_table_t*,ulint,ulint)"
"row_undo_mod_parse_undo_rec(undo_node_t*,ulint)" -> "dict_table_open_on_id(table_id_t,ulint,dict_table_op_t)"
"open_step(que_thr_t*)" -> "fprintf(FILE*,const char*,...)"
"open_step(que_thr_t*)" -> "abort()"
"open_step(que_thr_t*)" -> "que_node_get_parent(que_node_t*)"
"open_step(que_thr_t*)" -> "ut_dbg_assertion_failed(const char*,const char*,ulint)"
"open_step(que_thr_t*)" -> "sel_node_reset_cursor(sel_node_t*)"
"proc_step(que_thr_t*)" -> "que_node_get_parent(que_node_t*)"
"trx_rollback_step(que_thr_t*)" -> "trx_rollback_start(trx_t*,ib_id_t)"
"trx_rollback_step(que_thr_t*)" -> "que_node_get_parent(que_node_t*)"
"trx_rollback_step(que_thr_t*)" -> "ut_dbg_assertion_failed(const char*,const char*,ulint)"
"trx_rollback_step(que_thr_t*)" -> "thr_get_trx(que_thr_t*)"
"trx_rollback_step(que_thr_t*)" -> "pfs_mutex_enter_func(ib_mutex_t*,const char*,ulint)"
"trx_rollback_step(que_thr_t*)" -> "abort()"
"trx_rollback_step(que_thr_t*)" -> "pfs_mutex_exit_func(ib_mutex_t*)"
"trx_rollback_step(que_thr_t*)" -> "__builtin_expect(long int,long int)"
"trx_rollback_step(que_thr_t*)" -> "trx_commit_or_rollback_prepare(trx_t*)"
"trx_rollback_start(trx_t*,ib_id_t)" -> "__builtin_expect(long int,long int)"
"trx_rollback_start(trx_t*,ib_id_t)" -> "abort()"
"trx_rollback_start(trx_t*,ib_id_t)" -> "que_fork_start_command(que_fork_t*)"
"trx_rollback_start(trx_t*,ib_id_t)" -> "trx_roll_graph_build(trx_t*)"
"trx_rollback_start(trx_t*,ib_id_t)" -> "trx_undo_arr_create(ulint)"
"trx_rollback_start(trx_t*,ib_id_t)" -> "ut_dbg_assertion_failed(const char*,const char*,ulint)"
"trx_roll_graph_build(trx_t*)" -> "que_fork_create(que_t*,que_node_t*,ulint,mem_heap_t*)"
"trx_roll_graph_build(trx_t*)" -> "row_undo_node_create(trx_t*,que_thr_t*,mem_heap_t*)"
"trx_roll_graph_build(trx_t*)" -> "mem_heap_create_func(ulint,ulint)"
"trx_roll_graph_build(trx_t*)" -> "que_thr_create(que_fork_t*,mem_heap_t*)"
"row_undo_node_create(trx_t*,que_thr_t*,mem_heap_t*)" -> "btr_pcur_init(btr_pcur_t*)"
"row_undo_node_create(trx_t*,que_thr_t*,mem_heap_t*)" -> "mem_heap_alloc(mem_heap_t*,ulint)"
"row_undo_node_create(trx_t*,que_thr_t*,mem_heap_t*)" -> "mem_heap_create_func(ulint,ulint)"
"trx_undo_arr_create(ulint)" -> "mem_heap_create_func(ulint,ulint)"
"trx_undo_arr_create(ulint)" -> "mem_heap_zalloc(mem_heap_t*,ulint)"
"trx_commit_or_rollback_prepare(trx_t*)" -> "__builtin_expect(long int,long int)"
"trx_commit_or_rollback_prepare(trx_t*)" -> "ut_dbg_assertion_failed(const char*,const char*,ulint)"
"trx_commit_or_rollback_prepare(trx_t*)" -> "trx_start_low(trx_t*)"
"trx_commit_or_rollback_prepare(trx_t*)" -> "abort()"
"trx_commit_step(que_thr_t*)" -> "thr_get_trx(que_thr_t*)"
"trx_commit_step(que_thr_t*)" -> "que_node_get_parent(que_node_t*)"
"trx_commit_step(que_thr_t*)" -> "trx_commit_or_rollback_prepare(trx_t*)"
"trx_commit_step(que_thr_t*)" -> "ut_dbg_assertion_failed(const char*,const char*,ulint)"
"trx_commit_step(que_thr_t*)" -> "abort()"
"trx_commit_step(que_thr_t*)" -> "trx_commit(trx_t*)"
"trx_commit_step(que_thr_t*)" -> "__builtin_expect(long int,long int)"
"exit_step(que_thr_t*)" -> "que_node_get_parent(que_node_t*)"
"exit_step(que_thr_t*)" -> "abort()"
"exit_step(que_thr_t*)" -> "ut_dbg_assertion_failed(const char*,const char*,ulint)"
"exit_step(que_thr_t*)" -> "__builtin_expect(long int,long int)"
"exit_step(que_thr_t*)" -> "que_node_get_containing_loop_node(que_node_t*)"
"while_step(que_thr_t*)" -> "eval_exp(que_node_t*)"
"while_step(que_thr_t*)" -> "que_node_get_parent(que_node_t*)"
"while_step(que_thr_t*)" -> "eval_node_get_ibool_val(que_node_t*)"
"row_printf_step(que_thr_t*)" -> "dfield_print_also_hex(const dfield_t*)"
"row_printf_step(que_thr_t*)" -> "que_node_get_parent(que_node_t*)"
"row_printf_step(que_thr_t*)" -> "que_node_get_next(que_node_t*)"
"row_printf_step(que_thr_t*)" -> "que_node_get_val(que_node_t*)"
"row_printf_step(que_thr_t*)" -> "__builtin_fwrite(const void*,size_t,size_t,FILE*)"
"row_printf_step(que_thr_t*)" -> "putc(int,FILE*)"
"dfield_print_also_hex(const dfield_t*)" -> "dfield_is_ext(const dfield_t*)"
"dfield_print_also_hex(const dfield_t*)" -> "fprintf(FILE*,const char*,...)"
"dfield_print_also_hex(const dfield_t*)" -> "isprint(int)"
"dfield_print_also_hex(const dfield_t*)" -> "mach_read_from_7(const unsigned char*)"
"dfield_print_also_hex(const dfield_t*)" -> "mach_read_from_2(const unsigned char*)"
"dfield_print_also_hex(const dfield_t*)" -> "dfield_is_null(const dfield_t*)"
"dfield_print_also_hex(const dfield_t*)" -> "dfield_get_len(const dfield_t*)"
"dfield_print_also_hex(const dfield_t*)" -> "_IO_putc(int,_IO_FILE*)"
"dfield_print_also_hex(const dfield_t*)" -> "mach_read_from_3(const unsigned char*)"
"dfield_print_also_hex(const dfield_t*)" -> "mach_read_from_6(const unsigned char*)"
"dfield_print_also_hex(const dfield_t*)" -> "mach_read_from_8(const unsigned char*)"
"dfield_print_also_hex(const dfield_t*)" -> "mach_read_from_4(const unsigned char*)"
"dfield_print_also_hex(const dfield_t*)" -> "dtype_get_prtype(const dtype_t*)"
"dfield_print_also_hex(const dfield_t*)" -> "__builtin_fwrite(const void*,size_t,size_t,FILE*)"
"dfield_print_also_hex(const dfield_t*)" -> "mach_read_from_1(const unsigned char*)"
"dfield_print_also_hex(const dfield_t*)" -> "dtype_get_mtype(const dtype_t*)"
"dfield_print_also_hex(const dfield_t*)" -> "mach_ull_read_compressed(const unsigned char*)"
"if_step(que_thr_t*)" -> "eval_node_get_ibool_val(que_node_t*)"
"if_step(que_thr_t*)" -> "que_node_get_parent(que_node_t*)"
"if_step(que_thr_t*)" -> "que_node_get_next(que_node_t*)"
"if_step(que_thr_t*)" -> "eval_exp(que_node_t*)"
"trx_start_for_ddl_low(trx_t*,trx_dict_op_t)" -> "trx_set_dict_operation(trx_t*,trx_dict_op_t)"
"trx_start_for_ddl_low(trx_t*,trx_dict_op_t)" -> "abort()"
"trx_start_for_ddl_low(trx_t*,trx_dict_op_t)" -> "trx_start_low(trx_t*)"
"trx_start_for_ddl_low(trx_t*,trx_dict_op_t)" -> "ut_dbg_assertion_failed(const char*,const char*,ulint)"
"dict_update_filepath(ulint,const char*)" -> "trx_start_for_ddl_low(trx_t*,trx_dict_op_t)"
"dict_update_filepath(ulint,const char*)" -> "ib_logf(ib_log_level_t,const char*,...)"
"dict_update_filepath(ulint,const char*)" -> "que_eval_sql(pars_info_t*,const char*,ulint,trx_t*)"
"dict_update_filepath(ulint,const char*)" -> "pars_info_add_int4_literal(pars_info_t*,const char*,lint)"
"dict_update_filepath(ulint,const char*)" -> "pars_info_create()"
"dict_update_filepath(ulint,const char*)" -> "trx_commit_for_mysql(trx_t*)"
"dict_update_filepath(ulint,const char*)" -> "pars_info_add_str_literal(pars_info_t*,const char*,const char*)"
"dict_update_filepath(ulint,const char*)" -> "trx_allocate_for_background()"
"dict_update_filepath(ulint,const char*)" -> "trx_free_for_background(trx_t*)"
"dict_load_table_low(const char*,const rec_t*,dict_table_t**)" -> "rec_get_nth_field_offs_old(const rec_t*,ulint,ulint*)"
"dict_load_table_low(const char*,const rec_t*,dict_table_t**)" -> "mach_read_from_4(const unsigned char*)"
"dict_load_table_low(const char*,const rec_t*,dict_table_t**)" -> "dict_mem_table_create(const char*,ulint,ulint,ulint,ulint)"
"dict_load_table_low(const char*,const rec_t*,dict_table_t**)" -> "ut_print_timestamp(FILE*)"
"dict_load_table_low(const char*,const rec_t*,dict_table_t**)" -> "dict_sys_tables_get_flags(const rec_t*)"
"dict_load_table_low(const char*,const rec_t*,dict_table_t**)" -> "__builtin_fwrite(const void*,size_t,size_t,FILE*)"
"dict_load_table_low(const char*,const rec_t*,dict_table_t**)" -> "rec_get_n_fields_old(const rec_t*)"
"dict_load_table_low(const char*,const rec_t*,dict_table_t**)" -> "rec_get_deleted_flag(const rec_t*,ulint)"
"dict_load_table_low(const char*,const rec_t*,dict_table_t**)" -> "ut_print_filename(FILE*,const char*)"
"dict_load_table_low(const char*,const rec_t*,dict_table_t**)" -> "fprintf(FILE*,const char*,...)"
"dict_load_table_low(const char*,const rec_t*,dict_table_t**)" -> "mach_read_from_8(const unsigned char*)"
"dict_load_table_low(const char*,const rec_t*,dict_table_t**)" -> "__builtin_expect(long int,long int)"
"dict_sys_tables_get_flags(const rec_t*)" -> "__builtin_expect(long int,long int)"
"dict_sys_tables_get_flags(const rec_t*)" -> "abort()"
"dict_sys_tables_get_flags(const rec_t*)" -> "mach_read_from_4(const unsigned char*)"
"dict_sys_tables_get_flags(const rec_t*)" -> "rec_get_nth_field_offs_old(const rec_t*,ulint,ulint*)"
"dict_sys_tables_get_flags(const rec_t*)" -> "dict_sys_tables_type_validate(ulint,ulint)"
"dict_sys_tables_get_flags(const rec_t*)" -> "ut_dbg_assertion_failed(const char*,const char*,ulint)"
"dict_sys_tables_get_flags(const rec_t*)" -> "dict_sys_tables_type_to_tf(ulint,ulint)"
"dict_get_and_save_data_dir_path(dict_table_t*,bool)" -> "dict_save_data_dir_path(dict_table_t*,char*)"
"dict_get_and_save_data_dir_path(dict_table_t*,bool)" -> "mem_free_func(void*,const char*,ulint)"
"dict_get_and_save_data_dir_path(dict_table_t*,bool)" -> "dict_mutex_exit_for_mysql()"
"dict_get_and_save_data_dir_path(dict_table_t*,bool)" -> "dict_get_first_path(ulint,const char*)"
"dict_get_and_save_data_dir_path(dict_table_t*,bool)" -> "fil_space_get_first_path(ulint)"
"dict_get_and_save_data_dir_path(dict_table_t*,bool)" -> "dict_mutex_enter_for_mysql()"
"dict_save_data_dir_path(dict_table_t*,char*)" -> "strcmp(const char*,const char*)"
"dict_save_data_dir_path(dict_table_t*,char*)" -> "os_file_make_data_dir_path(char*)"
"dict_save_data_dir_path(dict_table_t*,char*)" -> "fil_make_ibd_name(const char*,bool)"
"dict_save_data_dir_path(dict_table_t*,char*)" -> "__builtin_expect(long int,long int)"
"dict_save_data_dir_path(dict_table_t*,char*)" -> "abort()"
"dict_save_data_dir_path(dict_table_t*,char*)" -> "mem_free_func(void*,const char*,ulint)"
"dict_save_data_dir_path(dict_table_t*,char*)" -> "mem_heap_strdup(mem_heap_t*,const char*)"
"dict_save_data_dir_path(dict_table_t*,char*)" -> "ut_dbg_assertion_failed(const char*,const char*,ulint)"
"dict_save_data_dir_path(dict_table_t*,char*)" -> "strlen(const char*)"
"os_file_make_data_dir_path(char*)" -> "ut_strlen(const char*)"
"os_file_make_data_dir_path(char*)" -> "ut_memmove(void*,const void*,ulint)"
"os_file_make_data_dir_path(char*)" -> "strrchr(char*,int)"
"dict_mutex_exit_for_mysql()" -> "pfs_mutex_exit_func(ib_mutex_t*)"
"dict_get_first_path(ulint,const char*)" -> "mem_heap_create_func(ulint,ulint)"
"dict_get_first_path(ulint,const char*)" -> "mtr_start(mtr_t*)"
"dict_get_first_path(ulint,const char*)" -> "dict_index_copy_types(dtuple_t*,const dict_index_t*,ulint)"
"dict_get_first_path(ulint,const char*)" -> "mem_strdupl(const char*,ulint)"
"dict_get_first_path(ulint,const char*)" -> "mach_write_to_4(unsigned char*,ulint)"
"dict_get_first_path(ulint,const char*)" -> "abort()"
"dict_get_first_path(ulint,const char*)" -> "__builtin_expect(long int,long int)"
"dict_get_first_path(ulint,const char*)" -> "mem_heap_free_func(mem_heap_t*,const char*,ulint)"
"dict_get_first_path(ulint,const char*)" -> "btr_pcur_open_on_user_rec_func(dict_index_t*,const dtuple_t*,ulint,ulint,btr_pcur_t*,const char*,ulint,mtr_t*)"
"dict_get_first_path(ulint,const char*)" -> "btr_pcur_is_on_user_rec(const btr_pcur_t*)"
"dict_get_first_path(ulint,const char*)" -> "rec_get_nth_field_offs_old(const rec_t*,ulint,ulint*)"
"dict_get_first_path(ulint,const char*)" -> "mem_heap_alloc(mem_heap_t*,ulint)"
"dict_get_first_path(ulint,const char*)" -> "dtuple_create(mem_heap_t*,ulint)"
"dict_get_first_path(ulint,const char*)" -> "dict_table_get_low(const char*)"
"dict_get_first_path(ulint,const char*)" -> "dfield_set_data(dfield_t*,const void*,ulint)"
"dict_get_first_path(ulint,const char*)" -> "mtr_commit(mtr_t*)"
"dict_get_first_path(ulint,const char*)" -> "ut_dbg_assertion_failed(const char*,const char*,ulint)"
"dict_get_first_path(ulint,const char*)" -> "btr_pcur_close(btr_pcur_t*)"
"fil_space_get_first_path(ulint)" -> "fil_space_get_space(ulint)"
"fil_space_get_first_path(ulint)" -> "fil_mutex_enter_and_prepare_for_io(ulint)"
"fil_space_get_first_path(ulint)" -> "__builtin_expect(long int,long int)"
"fil_space_get_first_path(ulint)" -> "ut_dbg_assertion_failed(const char*,const char*,ulint)"
"fil_space_get_first_path(ulint)" -> "pfs_mutex_exit_func(ib_mutex_t*)"
"fil_space_get_first_path(ulint)" -> "abort()"
"fil_space_get_first_path(ulint)" -> "mem_strdup(const char*)"
"dict_mutex_enter_for_mysql()" -> "pfs_mutex_enter_func(ib_mutex_t*,const char*,ulint)"
"dict_load_indexes(dict_table_t*,mem_heap_t*,dict_err_ignore_t)" -> "mem_heap_alloc(mem_heap_t*,ulint)"
"dict_load_indexes(dict_table_t*,mem_heap_t*,dict_err_ignore_t)" -> "dict_index_is_corrupted(const dict_index_t*)"
"dict_load_indexes(dict_table_t*,mem_heap_t*,dict_err_ignore_t)" -> "dict_index_copy_types(dtuple_t*,const dict_index_t*,ulint)"
"dict_load_indexes(dict_table_t*,mem_heap_t*,dict_err_ignore_t)" -> "dict_mem_index_free(dict_index_t*)"
"dict_load_indexes(dict_table_t*,mem_heap_t*,dict_err_ignore_t)" -> "btr_pcur_close(btr_pcur_t*)"
"dict_load_indexes(dict_table_t*,mem_heap_t*,dict_err_ignore_t)" -> "mach_write_to_8(void*,ib_uint64_t)"
"dict_load_indexes(dict_table_t*,mem_heap_t*,dict_err_ignore_t)" -> "ut_print_timestamp(FILE*)"
"dict_load_indexes(dict_table_t*,mem_heap_t*,dict_err_ignore_t)" -> "btr_pcur_move_to_next_user_rec(btr_pcur_t*,mtr_t*)"
"dict_load_indexes(dict_table_t*,mem_heap_t*,dict_err_ignore_t)" -> "dict_load_index_low(unsigned char*,const char*,mem_heap_t*,const rec_t*,ulint,dict_index_t**)"
"dict_load_indexes(dict_table_t*,mem_heap_t*,dict_err_ignore_t)" -> "dict_index_name_print(FILE*,const trx_t*,const dict_index_t*)"
"dict_load_indexes(dict_table_t*,mem_heap_t*,dict_err_ignore_t)" -> "ib_logf(ib_log_level_t,const char*,...)"
"dict_load_indexes(dict_table_t*,mem_heap_t*,dict_err_ignore_t)" -> "btr_pcur_is_on_user_rec(const btr_pcur_t*)"
"dict_load_indexes(dict_table_t*,mem_heap_t*,dict_err_ignore_t)" -> "fprintf(FILE*,const char*,...)"
"dict_load_indexes(dict_table_t*,mem_heap_t*,dict_err_ignore_t)" -> "dict_load_fields(dict_index_t*,mem_heap_t*)"
"dict_load_indexes(dict_table_t*,mem_heap_t*,dict_err_ignore_t)" -> "abort()"
"dict_load_indexes(dict_table_t*,mem_heap_t*,dict_err_ignore_t)" -> "_IO_putc(int,_IO_FILE*)"
"dict_load_indexes(dict_table_t*,mem_heap_t*,dict_err_ignore_t)" -> "dtuple_create(mem_heap_t*,ulint)"
"dict_load_indexes(dict_table_t*,mem_heap_t*,dict_err_ignore_t)" -> "dict_table_get_low(const char*)"
"dict_load_indexes(dict_table_t*,mem_heap_t*,dict_err_ignore_t)" -> "__builtin_expect(long int,long int)"
"dict_load_indexes(dict_table_t*,mem_heap_t*,dict_err_ignore_t)" -> "mtr_commit(mtr_t*)"
"dict_load_indexes(dict_table_t*,mem_heap_t*,dict_err_ignore_t)" -> "rec_get_nth_field_offs_old(const rec_t*,ulint,ulint*)"
"dict_load_indexes(dict_table_t*,mem_heap_t*,dict_err_ignore_t)" -> "dict_index_add_to_cache(dict_table_t*,dict_index_t*,ulint,ulint)"
"dict_load_indexes(dict_table_t*,mem_heap_t*,dict_err_ignore_t)" -> "dict_index_is_clust(const dict_index_t*)"
"dict_load_indexes(dict_table_t*,mem_heap_t*,dict_err_ignore_t)" -> "rec_get_n_fields_old(const rec_t*)"
"dict_load_indexes(dict_table_t*,mem_heap_t*,dict_err_ignore_t)" -> "mtr_start(mtr_t*)"
"dict_load_indexes(dict_table_t*,mem_heap_t*,dict_err_ignore_t)" -> "strcmp(const char*,const char*)"
"dict_load_indexes(dict_table_t*,mem_heap_t*,dict_err_ignore_t)" -> "dict_set_corrupted_index_cache_only(dict_index_t*,dict_table_t*)"
"dict_load_indexes(dict_table_t*,mem_heap_t*,dict_err_ignore_t)" -> "ut_dbg_assertion_failed(const char*,const char*,ulint)"
"dict_load_indexes(dict_table_t*,mem_heap_t*,dict_err_ignore_t)" -> "__builtin_fwrite(const void*,size_t,size_t,FILE*)"
"dict_load_indexes(dict_table_t*,mem_heap_t*,dict_err_ignore_t)" -> "dfield_set_data(dfield_t*,const void*,ulint)"
"dict_load_indexes(dict_table_t*,mem_heap_t*,dict_err_ignore_t)" -> "btr_pcur_open_on_user_rec_func(dict_index_t*,const dtuple_t*,ulint,ulint,btr_pcur_t*,const char*,ulint,mtr_t*)"
"dict_load_indexes(dict_table_t*,mem_heap_t*,dict_err_ignore_t)" -> "dict_table_get_all_fts_indexes(dict_table_t*,ib_vector_t*)"
"dict_load_indexes(dict_table_t*,mem_heap_t*,dict_err_ignore_t)" -> "ut_print_name(FILE*,const trx_t*,ulint,const char*)"
"dict_load_indexes(dict_table_t*,mem_heap_t*,dict_err_ignore_t)" -> "dict_is_sys_table(table_id_t)"
"dict_load_index_low(unsigned char*,const char*,mem_heap_t*,const rec_t*,ulint,dict_index_t**)" -> "rec_get_nth_field_offs_old(const rec_t*,ulint,ulint*)"
"dict_load_index_low(unsigned char*,const char*,mem_heap_t*,const rec_t*,ulint,dict_index_t**)" -> "ut_dbg_assertion_failed(const char*,const char*,ulint)"
"dict_load_index_low(unsigned char*,const char*,mem_heap_t*,const rec_t*,ulint,dict_index_t**)" -> "mach_read_from_8(const unsigned char*)"
"dict_load_index_low(unsigned char*,const char*,mem_heap_t*,const rec_t*,ulint,dict_index_t**)" -> "dict_mem_fill_index_struct(dict_index_t*,mem_heap_t*,const char*,const char*,ulint,ulint,ulint)"
"dict_load_index_low(unsigned char*,const char*,mem_heap_t*,const rec_t*,ulint,dict_index_t**)" -> "mach_read_from_4(const unsigned char*)"
"dict_load_index_low(unsigned char*,const char*,mem_heap_t*,const rec_t*,ulint,dict_index_t**)" -> "abort()"
"dict_load_index_low(unsigned char*,const char*,mem_heap_t*,const rec_t*,ulint,dict_index_t**)" -> "mem_heap_strdupl(mem_heap_t*,const char*,ulint)"
"dict_load_index_low(unsigned char*,const char*,mem_heap_t*,const rec_t*,ulint,dict_index_t**)" -> "memcmp(const void*,const void*,size_t)"
"dict_load_index_low(unsigned char*,const char*,mem_heap_t*,const rec_t*,ulint,dict_index_t**)" -> "rec_get_n_fields_old(const rec_t*)"
"dict_load_index_low(unsigned char*,const char*,mem_heap_t*,const rec_t*,ulint,dict_index_t**)" -> "dict_mem_index_create(const char*,const char*,ulint,ulint,ulint)"
"dict_load_index_low(unsigned char*,const char*,mem_heap_t*,const rec_t*,ulint,dict_index_t**)" -> "memcpy(void*,const void*,size_t)"
"dict_load_index_low(unsigned char*,const char*,mem_heap_t*,const rec_t*,ulint,dict_index_t**)" -> "__builtin_expect(long int,long int)"
"dict_load_index_low(unsigned char*,const char*,mem_heap_t*,const rec_t*,ulint,dict_index_t**)" -> "rec_get_deleted_flag(const rec_t*,ulint)"
"dict_load_fields(dict_index_t*,mem_heap_t*)" -> "dict_index_copy_types(dtuple_t*,const dict_index_t*,ulint)"
"dict_load_fields(dict_index_t*,mem_heap_t*)" -> "abort()"
"dict_load_fields(dict_index_t*,mem_heap_t*)" -> "fprintf(FILE*,const char*,...)"
"dict_load_fields(dict_index_t*,mem_heap_t*)" -> "ut_dbg_assertion_failed(const char*,const char*,ulint)"
"dict_load_fields(dict_index_t*,mem_heap_t*)" -> "btr_pcur_move_to_next_user_rec(btr_pcur_t*,mtr_t*)"
"dict_load_fields(dict_index_t*,mem_heap_t*)" -> "btr_pcur_close(btr_pcur_t*)"
"dict_load_fields(dict_index_t*,mem_heap_t*)" -> "dfield_set_data(dfield_t*,const void*,ulint)"
"dict_load_fields(dict_index_t*,mem_heap_t*)" -> "mach_write_to_8(void*,ib_uint64_t)"
"dict_load_fields(dict_index_t*,mem_heap_t*)" -> "btr_pcur_is_on_user_rec(const btr_pcur_t*)"
"dict_load_fields(dict_index_t*,mem_heap_t*)" -> "__builtin_expect(long int,long int)"
"dict_load_fields(dict_index_t*,mem_heap_t*)" -> "btr_pcur_open_on_user_rec_func(dict_index_t*,const dtuple_t*,ulint,ulint,btr_pcur_t*,const char*,ulint,mtr_t*)"
"dict_load_fields(dict_index_t*,mem_heap_t*)" -> "dict_load_field_low(unsigned char*,dict_index_t*,dict_field_t*,ulint*,unsigned char*,mem_heap_t*,const rec_t*)"
"dict_load_fields(dict_index_t*,mem_heap_t*)" -> "dict_table_get_low(const char*)"
"dict_load_fields(dict_index_t*,mem_heap_t*)" -> "dtuple_create(mem_heap_t*,ulint)"
"dict_load_fields(dict_index_t*,mem_heap_t*)" -> "mem_heap_alloc(mem_heap_t*,ulint)"
"dict_load_fields(dict_index_t*,mem_heap_t*)" -> "mtr_commit(mtr_t*)"
"dict_load_fields(dict_index_t*,mem_heap_t*)" -> "mtr_start(mtr_t*)"
"dict_load_field_low(unsigned char*,dict_index_t*,dict_field_t*,ulint*,unsigned char*,mem_heap_t*,const rec_t*)" -> "rec_get_deleted_flag(const rec_t*,ulint)"
"dict_load_field_low(unsigned char*,dict_index_t*,dict_field_t*,ulint*,unsigned char*,mem_heap_t*,const rec_t*)" -> "memcpy(void*,const void*,size_t)"
"dict_load_field_low(unsigned char*,dict_index_t*,dict_field_t*,ulint*,unsigned char*,mem_heap_t*,const rec_t*)" -> "abort()"
"dict_load_field_low(unsigned char*,dict_index_t*,dict_field_t*,ulint*,unsigned char*,mem_heap_t*,const rec_t*)" -> "dict_mem_index_add_field(dict_index_t*,const char*,ulint)"
"dict_load_field_low(unsigned char*,dict_index_t*,dict_field_t*,ulint*,unsigned char*,mem_heap_t*,const rec_t*)" -> "memcmp(const void*,const void*,size_t)"
"dict_load_field_low(unsigned char*,dict_index_t*,dict_field_t*,ulint*,unsigned char*,mem_heap_t*,const rec_t*)" -> "rec_get_nth_field_offs_old(const rec_t*,ulint,ulint*)"
"dict_load_field_low(unsigned char*,dict_index_t*,dict_field_t*,ulint*,unsigned char*,mem_heap_t*,const rec_t*)" -> "mach_read_from_4(const unsigned char*)"
"dict_load_field_low(unsigned char*,dict_index_t*,dict_field_t*,ulint*,unsigned char*,mem_heap_t*,const rec_t*)" -> "mem_heap_strdupl(mem_heap_t*,const char*,ulint)"
"dict_load_field_low(unsigned char*,dict_index_t*,dict_field_t*,ulint*,unsigned char*,mem_heap_t*,const rec_t*)" -> "rec_get_n_fields_old(const rec_t*)"
"dict_load_field_low(unsigned char*,dict_index_t*,dict_field_t*,ulint*,unsigned char*,mem_heap_t*,const rec_t*)" -> "ut_dbg_assertion_failed(const char*,const char*,ulint)"
"dict_load_field_low(unsigned char*,dict_index_t*,dict_field_t*,ulint*,unsigned char*,mem_heap_t*,const rec_t*)" -> "__builtin_expect(long int,long int)"
"dict_table_remove_from_cache(dict_table_t*)" -> "dict_table_remove_from_cache_low(dict_table_t*,ulint)"
"dict_table_remove_from_cache_low(dict_table_t*,ulint)" -> "_Alloc>::begin() const [with _Key = dict_foreign_t*,_Compare = dict_foreign_compare,_Alloc = std::allocator<dict_foreign_t*>,std::set<_Key,_Compare,_Alloc>::iterator = std::_Rb_tree_const_iterator<dict_foreign_t*>]"
"dict_table_remove_from_cache_low(dict_table_t*,ulint)" -> "trx_free_for_background(trx_t*)"
"dict_table_remove_from_cache_low(dict_table_t*,ulint)" -> "ut_dbg_assertion_failed(const char*,const char*,ulint)"
"dict_table_remove_from_cache_low(dict_table_t*,ulint)" -> "strlen(const char*)"
"dict_table_remove_from_cache_low(dict_table_t*,ulint)" -> "trx_commit_for_mysql(trx_t*)"
"dict_table_remove_from_cache_low(dict_table_t*,ulint)" -> "ut_fold_ull(ib_uint64_t)"
"dict_table_remove_from_cache_low(dict_table_t*,ulint)" -> "mem_heap_get_size(mem_heap_t*)"
"dict_table_remove_from_cache_low(dict_table_t*,ulint)" -> "__builtin_expect(long int,long int)"
"dict_table_remove_from_cache_low(dict_table_t*,ulint)" -> "std::_Rb_tree_const_iterator<_Tp>::operator*() const [with _Tp = dict_foreign_t*,std::_Rb_tree_const_iterator<_Tp>::reference = dict_foreign_t* const&]"
"dict_table_remove_from_cache_low(dict_table_t*,ulint)" -> "std::for_each(_IIter,_IIter,_Funct) [with _IIter = std::_Rb_tree_const_iterator<dict_foreign_t*>,_Funct = dict_foreign_remove_partial]"
"dict_table_remove_from_cache_low(dict_table_t*,ulint)" -> "trx_allocate_for_background()"
"dict_table_remove_from_cache_low(dict_table_t*,ulint)" -> "_Alloc>::clear() [with _Key = dict_foreign_t*,_Compare = dict_foreign_compare,_Alloc = std::allocator<dict_foreign_t*>]"
"dict_table_remove_from_cache_low(dict_table_t*,ulint)" -> "std::_Rb_tree_const_iterator<_Tp>::operator!=(const _Self&) const [with _Tp = dict_foreign_t*,std::_Rb_tree_const_iterator<_Tp>::_Self = std::_Rb_tree_const_iterator<dict_foreign_t*>]"
"dict_table_remove_from_cache_low(dict_table_t*,ulint)" -> "_Alloc>::end() const [with _Key = dict_foreign_t*,_Compare = dict_foreign_compare,_Alloc = std::allocator<dict_foreign_t*>,std::set<_Key,_Compare,_Alloc>::iterator = std::_Rb_tree_const_iterator<dict_foreign_t*>]"
"dict_table_remove_from_cache_low(dict_table_t*,ulint)" -> "hash_calc_hash(ulint,hash_table_t*)"
"dict_table_remove_from_cache_low(dict_table_t*,ulint)" -> "std::_Rb_tree_const_iterator<_Tp>::operator++() [with _Tp = dict_foreign_t*,std::_Rb_tree_const_iterator<_Tp>::_Self = std::_Rb_tree_const_iterator<dict_foreign_t*>]"
"dict_table_remove_from_cache_low(dict_table_t*,ulint)" -> "dict_mem_table_free(dict_table_t*)"
"dict_table_remove_from_cache_low(dict_table_t*,ulint)" -> "row_merge_drop_indexes(trx_t*,dict_table_t*,ulint)"
"dict_table_remove_from_cache_low(dict_table_t*,ulint)" -> "dict_index_remove_from_cache_low(dict_table_t*,dict_index_t*,ulint)"
"dict_table_remove_from_cache_low(dict_table_t*,ulint)" -> "ut_list_remove(List&,Type&,size_t) [with List = ut_list_base<dict_table_t>,Type = dict_table_t,size_t = long unsigned int]"
"dict_table_remove_from_cache_low(dict_table_t*,ulint)" -> "trx_set_dict_operation(trx_t*,trx_dict_op_t)"
"dict_table_remove_from_cache_low(dict_table_t*,ulint)" -> "hash_get_nth_cell(hash_table_t*,ulint)"
"dict_table_remove_from_cache_low(dict_table_t*,ulint)" -> "ut_fold_string(const char*)"
"dict_table_remove_from_cache_low(dict_table_t*,ulint)" -> "abort()"
"std::for_each(_IIter,_IIter,_Funct) [with _IIter = std::_Rb_tree_const_iterator<dict_foreign_t*>,_Funct = dict_foreign_remove_partial]" -> "std::_Rb_tree_const_iterator<_Tp>::operator++() [with _Tp = dict_foreign_t*,std::_Rb_tree_const_iterator<_Tp>::_Self = std::_Rb_tree_const_iterator<dict_foreign_t*>]"
"std::for_each(_IIter,_IIter,_Funct) [with _IIter = std::_Rb_tree_const_iterator<dict_foreign_t*>,_Funct = dict_foreign_remove_partial]" -> "std::_Rb_tree_const_iterator<_Tp>::operator*() const [with _Tp = dict_foreign_t*,std::_Rb_tree_const_iterator<_Tp>::reference = dict_foreign_t* const&]"
"std::for_each(_IIter,_IIter,_Funct) [with _IIter = std::_Rb_tree_const_iterator<dict_foreign_t*>,_Funct = dict_foreign_remove_partial]" -> "dict_foreign_remove_partial::operator()(dict_foreign_t*)"
"std::for_each(_IIter,_IIter,_Funct) [with _IIter = std::_Rb_tree_const_iterator<dict_foreign_t*>,_Funct = dict_foreign_remove_partial]" -> "std::_Rb_tree_const_iterator<_Tp>::operator!=(const _Self&) const [with _Tp = dict_foreign_t*,std::_Rb_tree_const_iterator<_Tp>::_Self = std::_Rb_tree_const_iterator<dict_foreign_t*>]"
"dict_foreign_remove_partial::operator()(dict_foreign_t*)" -> "dict_foreign_free(dict_foreign_t*)"
"dict_foreign_remove_partial::operator()(dict_foreign_t*)" -> "_Alloc>::erase(const key_type&) [with _Key = dict_foreign_t*,_Compare = dict_foreign_compare,_Alloc = std::allocator<dict_foreign_t*>,std::set<_Key,_Compare,_Alloc>::size_type = long unsigned int,std::set<_Key,_Compare,_Alloc>::key_type = dict_foreign_t*]"
"dict_foreign_free(dict_foreign_t*)" -> "mem_heap_free_func(mem_heap_t*,const char*,ulint)"
"_Alloc>::clear() [with _Key = dict_foreign_t*,_Compare = dict_foreign_compare,_Alloc = std::allocator<dict_foreign_t*>]" -> "_Alloc>::clear() [with _Key = dict_foreign_t*,_Val = dict_foreign_t*,_KeyOfValue = std::_Identity<dict_foreign_t*>,_Compare = dict_foreign_compare,_Alloc = std::allocator<dict_foreign_t*>]"
"row_merge_drop_indexes(trx_t*,dict_table_t*,ulint)" -> "dict_index_set_online_status(dict_index_t*,online_index_status)"
"row_merge_drop_indexes(trx_t*,dict_table_t*,ulint)" -> "ut_dbg_assertion_failed(const char*,const char*,ulint)"
"row_merge_drop_indexes(trx_t*,dict_table_t*,ulint)" -> "dict_index_remove_from_cache(dict_table_t*,dict_index_t*)"
"row_merge_drop_indexes(trx_t*,dict_table_t*,ulint)" -> "pfs_rw_lock_x_lock_func(rw_lock_t*,ulint,const char*,ulint)"
"row_merge_drop_indexes(trx_t*,dict_table_t*,ulint)" -> "fts_drop_index(dict_table_t*,dict_index_t*,trx_t*)"
"row_merge_drop_indexes(trx_t*,dict_table_t*,ulint)" -> "__builtin_expect(long int,long int)"
"row_merge_drop_indexes(trx_t*,dict_table_t*,ulint)" -> "dict_index_get_online_status(const dict_index_t*)"
"row_merge_drop_indexes(trx_t*,dict_table_t*,ulint)" -> "row_merge_drop_indexes_dict(trx_t*,table_id_t)"
"row_merge_drop_indexes(trx_t*,dict_table_t*,ulint)" -> "dict_index_get_lock(dict_index_t*)"
"row_merge_drop_indexes(trx_t*,dict_table_t*,ulint)" -> "pfs_rw_lock_x_unlock_func(rw_lock_t*)"
"row_merge_drop_indexes(trx_t*,dict_table_t*,ulint)" -> "abort()"
"row_merge_drop_indexes(trx_t*,dict_table_t*,ulint)" -> "row_log_abort_sec(dict_index_t*)"
"row_merge_drop_indexes(trx_t*,dict_table_t*,ulint)" -> "row_merge_drop_index_dict(trx_t*,index_id_t)"
"fts_drop_index(dict_table_t*,dict_index_t*,trx_t*)" -> "ut_dbg_assertion_failed(const char*,const char*,ulint)"
"fts_drop_index(dict_table_t*,dict_index_t*,trx_t*)" -> "__builtin_expect(long int,long int)"
"fts_drop_index(dict_table_t*,dict_index_t*,trx_t*)" -> "rbt_free(ib_rbt_t*)"
"fts_drop_index(dict_table_t*,dict_index_t*,trx_t*)" -> "ib_vector_size(const ib_vector_t*)"
"fts_drop_index(dict_table_t*,dict_index_t*,trx_t*)" -> "fts_cache_create(dict_table_t*)"
"fts_drop_index(dict_table_t*,dict_index_t*,trx_t*)" -> "fts_drop_index_tables(trx_t*,dict_index_t*)"
"fts_drop_index(dict_table_t*,dict_index_t*,trx_t*)" -> "fts_reset_get_doc(fts_cache_t*)"
"fts_drop_index(dict_table_t*,dict_index_t*,trx_t*)" -> "fts_find_index_cache(const fts_cache_t*,const dict_index_t*)"
"fts_drop_index(dict_table_t*,dict_index_t*,trx_t*)" -> "abort()"
"fts_drop_index(dict_table_t*,dict_index_t*,trx_t*)" -> "pfs_rw_lock_x_lock_func(rw_lock_t*,ulint,const char*,ulint)"
"fts_drop_index(dict_table_t*,dict_index_t*,trx_t*)" -> "pfs_rw_lock_x_unlock_func(rw_lock_t*)"
"fts_drop_index(dict_table_t*,dict_index_t*,trx_t*)" -> "ib_vector_get(ib_vector_t*,ulint)"
"fts_drop_index(dict_table_t*,dict_index_t*,trx_t*)" -> "fts_optimize_remove_table(dict_table_t*)"
"fts_drop_index(dict_table_t*,dict_index_t*,trx_t*)" -> "fts_drop_tables(trx_t*,dict_table_t*)"
"fts_drop_index(dict_table_t*,dict_index_t*,trx_t*)" -> "ib_vector_remove(ib_vector_t*,const void*)"
"fts_drop_index(dict_table_t*,dict_index_t*,trx_t*)" -> "fts_cache_destroy(fts_cache_t*)"
"fts_drop_index(dict_table_t*,dict_index_t*,trx_t*)" -> "ib_vector_is_empty(const ib_vector_t*)"
"fts_drop_index(dict_table_t*,dict_index_t*,trx_t*)" -> "fts_words_free(ib_rbt_t*)"
"fts_drop_index(dict_table_t*,dict_index_t*,trx_t*)" -> "fts_cache_clear(fts_cache_t*)"
"fts_drop_index(dict_table_t*,dict_index_t*,trx_t*)" -> "fts_free(dict_table_t*)"
"fts_drop_index_tables(trx_t*,dict_index_t*)" -> "fts_drop_index_split_tables(trx_t*,dict_index_t*)"
"fts_drop_index_split_tables(trx_t*,dict_index_t*)" -> "fts_get_table_name(const fts_table_t*)"
"fts_drop_index_split_tables(trx_t*,dict_index_t*)" -> "fts_get_suffix(ulint)"
"fts_drop_index_split_tables(trx_t*,dict_index_t*)" -> "mem_free_func(void*,const char*,ulint)"
"fts_drop_index_split_tables(trx_t*,dict_index_t*)" -> "fts_drop_table(trx_t*,const char*)"
"fts_drop_table(trx_t*,const char*)" -> "dict_table_close(dict_table_t*,ulint,ulint)"
"fts_drop_table(trx_t*,const char*)" -> "dict_table_open_on_name(const char*,ulint,ulint,dict_err_ignore_t)"
"fts_drop_table(trx_t*,const char*)" -> "ut_strerr(dberr_t)"
"fts_drop_table(trx_t*,const char*)" -> "row_drop_table_for_mysql(const char*,trx_t*,bool,bool)"
"fts_drop_table(trx_t*,const char*)" -> "ib_logf(ib_log_level_t,const char*,...)"
"row_drop_table_for_mysql(const char*,trx_t*,bool,bool)" -> "dict_get_and_save_data_dir_path(dict_table_t*,bool)"
"row_drop_table_for_mysql(const char*,trx_t*,bool,bool)" -> "fts_optimize_remove_table(dict_table_t*)"
"row_drop_table_for_mysql(const char*,trx_t*,bool,bool)" -> "ut_dbg_assertion_failed(const char*,const char*,ulint)"
"row_drop_table_for_mysql(const char*,trx_t*,bool,bool)" -> "dict_load_table(const char*,ulint,dict_err_ignore_t)"
"row_drop_table_for_mysql(const char*,trx_t*,bool,bool)" -> "pfs_mutex_exit_func(ib_mutex_t*)"
"row_drop_table_for_mysql(const char*,trx_t*,bool,bool)" -> "memcmp(const void*,const void*,size_t)"
"row_drop_table_for_mysql(const char*,trx_t*,bool,bool)" -> "ut_print_name(FILE*,const trx_t*,ulint,const char*)"
"row_drop_table_for_mysql(const char*,trx_t*,bool,bool)" -> "fil_space_for_table_exists_in_mem(ulint,const char*,ulint,ulint,bool,mem_heap_t*,table_id_t)"
"row_drop_table_for_mysql(const char*,trx_t*,bool,bool)" -> "dict_tables_have_same_db(const char*,const char*)"
"row_drop_table_for_mysql(const char*,trx_t*,bool,bool)" -> "pars_info_create()"
"row_drop_table_for_mysql(const char*,trx_t*,bool,bool)" -> "trx_start_for_ddl_low(trx_t*,trx_dict_op_t)"
"row_drop_table_for_mysql(const char*,trx_t*,bool,bool)" -> "dict_table_is_temporary(const dict_table_t*)"
"row_drop_table_for_mysql(const char*,trx_t*,bool,bool)" -> "abort()"
"row_drop_table_for_mysql(const char*,trx_t*,bool,bool)" -> "strlen(const char*)"
"row_drop_table_for_mysql(const char*,trx_t*,bool,bool)" -> "dict_table_remove_from_cache(dict_table_t*)"
"row_drop_table_for_mysql(const char*,trx_t*,bool,bool)" -> "pfs_mutex_enter_func(ib_mutex_t*,const char*,ulint)"
"row_drop_table_for_mysql(const char*,trx_t*,bool,bool)" -> "ut_strerr(dberr_t)"
"row_drop_table_for_mysql(const char*,trx_t*,bool,bool)" -> "strchr(const char*,int)"
"row_drop_table_for_mysql(const char*,trx_t*,bool,bool)" -> "std::_Rb_tree_const_iterator<_Tp>::operator*() const [with _Tp = dict_foreign_t*,std::_Rb_tree_const_iterator<_Tp>::reference = dict_foreign_t* const&]"
"row_drop_table_for_mysql(const char*,trx_t*,bool,bool)" -> "rewind(FILE*)"
"row_drop_table_for_mysql(const char*,trx_t*,bool,bool)" -> "dict_table_close(dict_table_t*,ulint,ulint)"
"row_drop_table_for_mysql(const char*,trx_t*,bool,bool)" -> "__builtin_fwrite(const void*,size_t,size_t,FILE*)"
"row_drop_table_for_mysql(const char*,trx_t*,bool,bool)" -> "mem_heap_strdup(mem_heap_t*,const char*)"
"row_drop_table_for_mysql(const char*,trx_t*,bool,bool)" -> "trx_set_dict_operation(trx_t*,trx_dict_op_t)"
"row_drop_table_for_mysql(const char*,trx_t*,bool,bool)" -> "fil_delete_link_file(const char*)"
"row_drop_table_for_mysql(const char*,trx_t*,bool,bool)" -> "row_add_table_to_background_drop_list(const char*)"
"row_drop_table_for_mysql(const char*,trx_t*,bool,bool)" -> "dict_table_open_on_name(const char*,ulint,ulint,dict_err_ignore_t)"
"row_drop_table_for_mysql(const char*,trx_t*,bool,bool)" -> "innobase_format_name(char*,ulint,const char*,ulint)"
"row_drop_table_for_mysql(const char*,trx_t*,bool,bool)" -> "fprintf(FILE*,const char*,...)"
"row_drop_table_for_mysql(const char*,trx_t*,bool,bool)" -> "trx_commit_for_mysql(trx_t*)"
"row_drop_table_for_mysql(const char*,trx_t*,bool,bool)" -> "trx_rollback_to_savepoint(trx_t*,trx_savept_t*)"
"row_drop_table_for_mysql(const char*,trx_t*,bool,bool)" -> "__builtin_fputc(int,FILE*)"
"row_drop_table_for_mysql(const char*,trx_t*,bool,bool)" -> "dict_stats_drop_table(const char*,char*,ulint)"
"row_drop_table_for_mysql(const char*,trx_t*,bool,bool)" -> "fil_delete_file(const char*)"
"row_drop_table_for_mysql(const char*,trx_t*,bool,bool)" -> "que_eval_sql(pars_info_t*,const char*,ulint,trx_t*)"
"row_drop_table_for_mysql(const char*,trx_t*,bool,bool)" -> "mem_heap_create_func(ulint,ulint)"
"row_drop_table_for_mysql(const char*,trx_t*,bool,bool)" -> "mem_free_func(void*,const char*,ulint)"
"row_drop_table_for_mysql(const char*,trx_t*,bool,bool)" -> "row_mysql_lock_data_dictionary_func(trx_t*,const char*,ulint)"
"row_drop_table_for_mysql(const char*,trx_t*,bool,bool)" -> "trx_get_dict_operation(const trx_t*)"
"row_drop_table_for_mysql(const char*,trx_t*,bool,bool)" -> "fil_make_ibd_name(const char*,bool)"
"row_drop_table_for_mysql(const char*,trx_t*,bool,bool)" -> "__builtin_expect(long int,long int)"
"row_drop_table_for_mysql(const char*,trx_t*,bool,bool)" -> "pfs_rw_lock_x_lock_func(rw_lock_t*,ulint,const char*,ulint)"
"row_drop_table_for_mysql(const char*,trx_t*,bool,bool)" -> "mem_heap_free_func(mem_heap_t*,const char*,ulint)"
"row_drop_table_for_mysql(const char*,trx_t*,bool,bool)" -> "dict_table_has_fts_index(dict_table_t*)"
"row_drop_table_for_mysql(const char*,trx_t*,bool,bool)" -> "dict_stats_wait_bg_to_stop_using_table(dict_table_t*,trx_t*)"
"row_drop_table_for_mysql(const char*,trx_t*,bool,bool)" -> "os_file_make_remote_pathname(const char*,const char*,const char*)"
"row_drop_table_for_mysql(const char*,trx_t*,bool,bool)" -> "row_mysql_unlock_data_dictionary(trx_t*)"
"row_drop_table_for_mysql(const char*,trx_t*,bool,bool)" -> "fts_drop_tables(trx_t*,dict_table_t*)"
"row_drop_table_for_mysql(const char*,trx_t*,bool,bool)" -> "dict_table_is_discarded(const dict_table_t*)"
"row_drop_table_for_mysql(const char*,trx_t*,bool,bool)" -> "std::_Rb_tree_const_iterator<_Tp>::operator++() [with _Tp = dict_foreign_t*,std::_Rb_tree_const_iterator<_Tp>::_Self = std::_Rb_tree_const_iterator<dict_foreign_t*>]"
"row_drop_table_for_mysql(const char*,trx_t*,bool,bool)" -> "std::_Rb_tree_const_iterator<_Tp>::operator!=(const _Self&) const [with _Tp = dict_foreign_t*,std::_Rb_tree_const_iterator<_Tp>::_Self = std::_Rb_tree_const_iterator<dict_foreign_t*>]"
"row_drop_table_for_mysql(const char*,trx_t*,bool,bool)" -> "srv_wake_master_thread()"
"row_drop_table_for_mysql(const char*,trx_t*,bool,bool)" -> "fts_free(dict_table_t*)"
"row_drop_table_for_mysql(const char*,trx_t*,bool,bool)" -> "_Alloc>::begin() const [with _Key = dict_foreign_t*,_Compare = dict_foreign_compare,_Alloc = std::allocator<dict_foreign_t*>,std::set<_Key,_Compare,_Alloc>::iterator = std::_Rb_tree_const_iterator<dict_foreign_t*>]"
"row_drop_table_for_mysql(const char*,trx_t*,bool,bool)" -> "lock_table_has_locks(const dict_table_t*)"
"row_drop_table_for_mysql(const char*,trx_t*,bool,bool)" -> "ib_logf(ib_log_level_t,const char*,...)"
"row_drop_table_for_mysql(const char*,trx_t*,bool,bool)" -> "mem_heap_alloc(mem_heap_t*,ulint)"
"row_drop_table_for_mysql(const char*,trx_t*,bool,bool)" -> "lock_remove_all_on_table(dict_table_t*,ulint)"
"row_drop_table_for_mysql(const char*,trx_t*,bool,bool)" -> "ut_print_timestamp(FILE*)"
"row_drop_table_for_mysql(const char*,trx_t*,bool,bool)" -> "pfs_rw_lock_x_unlock_func(rw_lock_t*)"
"row_drop_table_for_mysql(const char*,trx_t*,bool,bool)" -> "fil_delete_tablespace(ulint,buf_remove_t)"
"row_drop_table_for_mysql(const char*,trx_t*,bool,bool)" -> "pars_info_add_str_literal(pars_info_t*,const char*,const char*)"
"row_drop_table_for_mysql(const char*,trx_t*,bool,bool)" -> "dict_index_get_lock(dict_index_t*)"
"row_drop_table_for_mysql(const char*,trx_t*,bool,bool)" -> "dict_stats_recalc_pool_del(const dict_table_t*)"
"row_drop_table_for_mysql(const char*,trx_t*,bool,bool)" -> "dict_table_move_from_lru_to_non_lru(dict_table_t*)"
"row_drop_table_for_mysql(const char*,trx_t*,bool,bool)" -> "row_mysql_handle_errors(dberr_t*,trx_t*,que_thr_t*,trx_savept_t*)"
"row_drop_table_for_mysql(const char*,trx_t*,bool,bool)" -> "putc(int,FILE*)"
"row_drop_table_for_mysql(const char*,trx_t*,bool,bool)" -> "_Alloc>::end() const [with _Key = dict_foreign_t*,_Compare = dict_foreign_compare,_Alloc = std::allocator<dict_foreign_t*>,std::set<_Key,_Compare,_Alloc>::iterator = std::_Rb_tree_const_iterator<dict_foreign_t*>]"
"row_add_table_to_background_drop_list(const char*)" -> "mem_strdup(const char*)"
"row_add_table_to_background_drop_list(const char*)" -> "pfs_mutex_enter_func(ib_mutex_t*,const char*,ulint)"
"row_add_table_to_background_drop_list(const char*)" -> "__builtin_expect(long int,long int)"
"row_add_table_to_background_drop_list(const char*)" -> "pfs_mutex_exit_func(ib_mutex_t*)"
"row_add_table_to_background_drop_list(const char*)" -> "mem_alloc_func(ulint,ulint*)"
"row_add_table_to_background_drop_list(const char*)" -> "strcmp(const char*,const char*)"
"row_add_table_to_background_drop_list(const char*)" -> "abort()"
"row_add_table_to_background_drop_list(const char*)" -> "ut_list_append(List&,Type&,size_t) [with List = ut_list_base<row_mysql_drop_t>,Type = row_mysql_drop_t,size_t = long unsigned int]"
"row_add_table_to_background_drop_list(const char*)" -> "ut_dbg_assertion_failed(const char*,const char*,ulint)"
"ut_list_append(List&,Type&,size_t) [with List = ut_list_base<row_mysql_drop_t>,Type = row_mysql_drop_t,size_t = long unsigned int]" -> "ut_elem_get_node(Type&,size_t) [with Type = row_mysql_drop_t,size_t = long unsigned int]"
"ut_elem_get_node(Type&,size_t) [with Type = row_mysql_drop_t,size_t = long unsigned int]" -> "abort()"
"ut_elem_get_node(Type&,size_t) [with Type = row_mysql_drop_t,size_t = long unsigned int]" -> "ut_dbg_assertion_failed(const char*,const char*,ulint)"
"ut_elem_get_node(Type&,size_t) [with Type = row_mysql_drop_t,size_t = long unsigned int]" -> "__builtin_expect(long int,long int)"
"dict_stats_drop_table(const char*,char*,ulint)" -> "dict_stats_delete_from_index_stats(const char*,const char*)"
"dict_stats_drop_table(const char*,char*,ulint)" -> "dict_fs2utf8(const char*,char*,size_t,char*,size_t)"
"dict_stats_drop_table(const char*,char*,ulint)" -> "ut_strerr(dberr_t)"
"dict_stats_drop_table(const char*,char*,ulint)" -> "dict_stats_delete_from_table_stats(const char*,const char*)"
"dict_stats_drop_table(const char*,char*,ulint)" -> "snprintf(char*,size_t,const char*,...)"
"dict_stats_drop_table(const char*,char*,ulint)" -> "strchr(const char*,int)"
"dict_stats_drop_table(const char*,char*,ulint)" -> "strcmp(const char*,const char*)"
"dict_stats_delete_from_index_stats(const char*,const char*)" -> "pars_info_add_str_literal(pars_info_t*,const char*,const char*)"
"dict_stats_delete_from_index_stats(const char*,const char*)" -> "dict_stats_exec_sql(pars_info_t*,const char*,trx_t*)"
"dict_stats_delete_from_index_stats(const char*,const char*)" -> "pars_info_create()"
"dict_stats_delete_from_table_stats(const char*,const char*)" -> "pars_info_create()"
"dict_stats_delete_from_table_stats(const char*,const char*)" -> "pars_info_add_str_literal(pars_info_t*,const char*,const char*)"
"dict_stats_delete_from_table_stats(const char*,const char*)" -> "dict_stats_exec_sql(pars_info_t*,const char*,trx_t*)"
"fil_delete_file(const char*)" -> "ib_logf(ib_log_level_t,const char*,...)"
"fil_delete_file(const char*)" -> "fil_make_cfg_name(const char*)"
"fil_delete_file(const char*)" -> "pfs_os_file_delete_if_exists_func(mysql_pfs_key_t,const char*,const char*,ulint)"
"fil_delete_file(const char*)" -> "mem_free_func(void*,const char*,ulint)"
"fil_make_cfg_name(const char*)" -> "snprintf(char*,size_t,const char*,...)"
"fil_make_cfg_name(const char*)" -> "mem_strdup(const char*)"
"fil_make_cfg_name(const char*)" -> "strlen(const char*)"
"dict_stats_wait_bg_to_stop_using_table(dict_table_t*,trx_t*)" -> "dict_stats_stop_bg(dict_table_t*)"
"dict_stats_wait_bg_to_stop_using_table(dict_table_t*,trx_t*)" -> "row_mysql_lock_data_dictionary_func(trx_t*,const char*,ulint)"
"dict_stats_wait_bg_to_stop_using_table(dict_table_t*,trx_t*)" -> "os_thread_sleep(ulint)"
"dict_stats_wait_bg_to_stop_using_table(dict_table_t*,trx_t*)" -> "row_mysql_unlock_data_dictionary(trx_t*)"
"fts_drop_tables(trx_t*,dict_table_t*)" -> "fts_drop_common_tables(trx_t*,fts_table_t*)"
"fts_drop_tables(trx_t*,dict_table_t*)" -> "fts_drop_all_index_tables(trx_t*,fts_t*)"
"fts_drop_common_tables(trx_t*,fts_table_t*)" -> "fts_drop_table(trx_t*,const char*)"
"fts_drop_common_tables(trx_t*,fts_table_t*)" -> "mem_free_func(void*,const char*,ulint)"
"fts_drop_common_tables(trx_t*,fts_table_t*)" -> "fts_get_table_name(const fts_table_t*)"
"fts_drop_all_index_tables(trx_t*,fts_t*)" -> "ib_vector_get(ib_vector_t*,ulint)"
"fts_drop_all_index_tables(trx_t*,fts_t*)" -> "ib_vector_size(const ib_vector_t*)"
"fts_drop_all_index_tables(trx_t*,fts_t*)" -> "fts_drop_index_tables(trx_t*,dict_index_t*)"
"srv_wake_master_thread()" -> "srv_inc_activity_count()"
"srv_wake_master_thread()" -> "srv_release_threads(srv_thread_type,ulint)"
"lock_table_has_locks(const dict_table_t*)" -> "pfs_mutex_enter_func(ib_mutex_t*,const char*,ulint)"
"lock_table_has_locks(const dict_table_t*)" -> "pfs_mutex_exit_func(ib_mutex_t*)"
"lock_remove_all_on_table(dict_table_t*,ulint)" -> "abort()"
"lock_remove_all_on_table(dict_table_t*,ulint)" -> "__builtin_expect(long int,long int)"
"lock_remove_all_on_table(dict_table_t*,ulint)" -> "lock_get_mode(const ib_lock_t*)"
"lock_remove_all_on_table(dict_table_t*,ulint)" -> "lock_get_type(const ib_lock_t*)"
"lock_remove_all_on_table(dict_table_t*,ulint)" -> "pfs_mutex_exit_func(ib_mutex_t*)"
"lock_remove_all_on_table(dict_table_t*,ulint)" -> "pfs_mutex_enter_func(ib_mutex_t*,const char*,ulint)"
"lock_remove_all_on_table(dict_table_t*,ulint)" -> "ut_dbg_assertion_failed(const char*,const char*,ulint)"
"lock_remove_all_on_table(dict_table_t*,ulint)" -> "lock_remove_recovered_trx_record_locks(dict_table_t*)"
"lock_remove_all_on_table(dict_table_t*,ulint)" -> "lock_remove_all_on_table_for_trx(dict_table_t*,trx_t*,ulint)"
"lock_remove_all_on_table(dict_table_t*,ulint)" -> "lock_get_wait(const ib_lock_t*)"
"lock_remove_recovered_trx_record_locks(dict_table_t*)" -> "pfs_mutex_exit_func(ib_mutex_t*)"
"lock_remove_recovered_trx_record_locks(dict_table_t*)" -> "lock_table_remove_low(ib_lock_t*)"
"lock_remove_recovered_trx_record_locks(dict_table_t*)" -> "pfs_mutex_enter_func(ib_mutex_t*,const char*,ulint)"
"lock_remove_recovered_trx_record_locks(dict_table_t*)" -> "lock_rec_discard(ib_lock_t*)"
"lock_remove_recovered_trx_record_locks(dict_table_t*)" -> "lock_get_wait(const ib_lock_t*)"
"lock_remove_recovered_trx_record_locks(dict_table_t*)" -> "lock_get_type_low(const ib_lock_t*)"
"lock_remove_recovered_trx_record_locks(dict_table_t*)" -> "lock_trx_table_locks_remove(const ib_lock_t*)"
"lock_remove_recovered_trx_record_locks(dict_table_t*)" -> "abort()"
"lock_remove_recovered_trx_record_locks(dict_table_t*)" -> "__builtin_expect(long int,long int)"
"lock_remove_recovered_trx_record_locks(dict_table_t*)" -> "ut_dbg_assertion_failed(const char*,const char*,ulint)"
"lock_remove_all_on_table_for_trx(dict_table_t*,trx_t*,ulint)" -> "lock_rec_discard(ib_lock_t*)"
"lock_remove_all_on_table_for_trx(dict_table_t*,trx_t*,ulint)" -> "lock_table_remove_low(ib_lock_t*)"
"lock_remove_all_on_table_for_trx(dict_table_t*,trx_t*,ulint)" -> "__builtin_expect(long int,long int)"
"lock_remove_all_on_table_for_trx(dict_table_t*,trx_t*,ulint)" -> "lock_trx_table_locks_remove(const ib_lock_t*)"
"lock_remove_all_on_table_for_trx(dict_table_t*,trx_t*,ulint)" -> "lock_get_mode(const ib_lock_t*)"
"lock_remove_all_on_table_for_trx(dict_table_t*,trx_t*,ulint)" -> "lock_get_wait(const ib_lock_t*)"
"lock_remove_all_on_table_for_trx(dict_table_t*,trx_t*,ulint)" -> "ut_dbg_assertion_failed(const char*,const char*,ulint)"
"lock_remove_all_on_table_for_trx(dict_table_t*,trx_t*,ulint)" -> "lock_get_type_low(const ib_lock_t*)"
"lock_remove_all_on_table_for_trx(dict_table_t*,trx_t*,ulint)" -> "abort()"
"fil_delete_tablespace(ulint,buf_remove_t)" -> "ut_dbg_assertion_failed(const char*,const char*,ulint)"
"fil_delete_tablespace(ulint,buf_remove_t)" -> "mtr_commit(mtr_t*)"
"fil_delete_tablespace(ulint,buf_remove_t)" -> "abort()"
"fil_delete_tablespace(ulint,buf_remove_t)" -> "pfs_os_file_delete_func(mysql_pfs_key_t,const char*,const char*,ulint)"
"fil_delete_tablespace(ulint,buf_remove_t)" -> "pfs_rw_lock_x_unlock_func(rw_lock_t*)"
"fil_delete_tablespace(ulint,buf_remove_t)" -> "fil_op_write_log(ulint,ulint,ulint,ulint,const char*,const char*,mtr_t*)"
"fil_delete_tablespace(ulint,buf_remove_t)" -> "__builtin_expect(long int,long int)"
"fil_delete_tablespace(ulint,buf_remove_t)" -> "ib_logf(ib_log_level_t,const char*,...)"
"fil_delete_tablespace(ulint,buf_remove_t)" -> "fil_space_free(ulint,ulint)"
"fil_delete_tablespace(ulint,buf_remove_t)" -> "pfs_os_file_delete_if_exists_func(mysql_pfs_key_t,const char*,const char*,ulint)"
"fil_delete_tablespace(ulint,buf_remove_t)" -> "buf_LRU_flush_or_remove_pages(ulint,buf_remove_t,const trx_t*)"
"fil_delete_tablespace(ulint,buf_remove_t)" -> "fil_check_pending_operations(ulint,fil_space_t**,char**)"
"fil_delete_tablespace(ulint,buf_remove_t)" -> "mem_free_func(void*,const char*,ulint)"
"fil_delete_tablespace(ulint,buf_remove_t)" -> "fil_make_cfg_name(const char*)"
"fil_delete_tablespace(ulint,buf_remove_t)" -> "pfs_rw_lock_x_lock_func(rw_lock_t*,ulint,const char*,ulint)"
"fil_delete_tablespace(ulint,buf_remove_t)" -> "pfs_mutex_exit_func(ib_mutex_t*)"
"fil_delete_tablespace(ulint,buf_remove_t)" -> "pfs_mutex_enter_func(ib_mutex_t*,const char*,ulint)"
"fil_delete_tablespace(ulint,buf_remove_t)" -> "fil_delete_link_file(const char*)"
"fil_delete_tablespace(ulint,buf_remove_t)" -> "fil_space_get_by_id(ulint)"
"fil_delete_tablespace(ulint,buf_remove_t)" -> "mtr_start(mtr_t*)"
"buf_LRU_flush_or_remove_pages(ulint,buf_remove_t,const trx_t*)" -> "buf_LRU_drop_page_hash_for_tablespace(buf_pool_t*,ulint)"
"buf_LRU_flush_or_remove_pages(ulint,buf_remove_t,const trx_t*)" -> "buf_LRU_remove_pages(buf_pool_t*,ulint,buf_remove_t,const trx_t*)"
"buf_LRU_flush_or_remove_pages(ulint,buf_remove_t,const trx_t*)" -> "buf_pool_from_array(ulint)"
"buf_LRU_drop_page_hash_for_tablespace(buf_pool_t*,ulint)" -> "buf_page_in_file(const buf_page_t*)"
"buf_LRU_drop_page_hash_for_tablespace(buf_pool_t*,ulint)" -> "buf_page_get_state(const buf_page_t*)"
"buf_LRU_drop_page_hash_for_tablespace(buf_pool_t*,ulint)" -> "ut_free(void*)"
"buf_LRU_drop_page_hash_for_tablespace(buf_pool_t*,ulint)" -> "ut_dbg_assertion_failed(const char*,const char*,ulint)"
"buf_LRU_drop_page_hash_for_tablespace(buf_pool_t*,ulint)" -> "pfs_mutex_enter_func(ib_mutex_t*,const char*,ulint)"
"buf_LRU_drop_page_hash_for_tablespace(buf_pool_t*,ulint)" -> "__builtin_expect(long int,long int)"
"buf_LRU_drop_page_hash_for_tablespace(buf_pool_t*,ulint)" -> "buf_LRU_drop_page_hash_batch(ulint,ulint,const ulint*,ulint)"
"buf_LRU_drop_page_hash_for_tablespace(buf_pool_t*,ulint)" -> "abort()"
"buf_LRU_drop_page_hash_for_tablespace(buf_pool_t*,ulint)" -> "fil_space_get_zip_size(ulint)"
"buf_LRU_drop_page_hash_for_tablespace(buf_pool_t*,ulint)" -> "ut_malloc_low(ulint,ulint)"
"buf_LRU_drop_page_hash_for_tablespace(buf_pool_t*,ulint)" -> "pfs_mutex_exit_func(ib_mutex_t*)"
"buf_LRU_drop_page_hash_batch(ulint,ulint,const ulint*,ulint)" -> "btr_search_drop_page_hash_when_freed(ulint,ulint,ulint)"
"buf_LRU_remove_pages(buf_pool_t*,ulint,buf_remove_t,const trx_t*)" -> "buf_flush_dirty_pages(buf_pool_t*,ulint,bool,const trx_t*)"
"buf_LRU_remove_pages(buf_pool_t*,ulint,buf_remove_t,const trx_t*)" -> "abort()"
"buf_LRU_remove_pages(buf_pool_t*,ulint,buf_remove_t,const trx_t*)" -> "buf_LRU_remove_all_pages(buf_pool_t*,ulint)"
"buf_LRU_remove_pages(buf_pool_t*,ulint,buf_remove_t,const trx_t*)" -> "os_aio_wait_until_no_pending_writes()"
"buf_LRU_remove_pages(buf_pool_t*,ulint,buf_remove_t,const trx_t*)" -> "__builtin_expect(long int,long int)"
"buf_LRU_remove_pages(buf_pool_t*,ulint,buf_remove_t,const trx_t*)" -> "fil_flush(ulint)"
"buf_LRU_remove_pages(buf_pool_t*,ulint,buf_remove_t,const trx_t*)" -> "ut_dbg_assertion_failed(const char*,const char*,ulint)"
"buf_flush_dirty_pages(buf_pool_t*,ulint,bool,const trx_t*)" -> "pfs_mutex_exit_func(ib_mutex_t*)"
"buf_flush_dirty_pages(buf_pool_t*,ulint,bool,const trx_t*)" -> "pfs_mutex_enter_func(ib_mutex_t*,const char*,ulint)"
"buf_flush_dirty_pages(buf_pool_t*,ulint,bool,const trx_t*)" -> "os_thread_sleep(ulint)"
"buf_flush_dirty_pages(buf_pool_t*,ulint,bool,const trx_t*)" -> "buf_flush_or_remove_pages(buf_pool_t*,ulint,bool,const trx_t*)"
"buf_flush_or_remove_pages(buf_pool_t*,ulint,bool,const trx_t*)" -> "pfs_mutex_exit_func(ib_mutex_t*)"
"buf_flush_or_remove_pages(buf_pool_t*,ulint,bool,const trx_t*)" -> "pfs_mutex_enter_func(ib_mutex_t*,const char*,ulint)"
"buf_flush_or_remove_pages(buf_pool_t*,ulint,bool,const trx_t*)" -> "buf_page_get_space(const buf_page_t*)"
"buf_flush_or_remove_pages(buf_pool_t*,ulint,bool,const trx_t*)" -> "trx_is_interrupted(const trx_t*)"
"buf_flush_or_remove_pages(buf_pool_t*,ulint,bool,const trx_t*)" -> "__builtin_expect(long int,long int)"
"buf_flush_or_remove_pages(buf_pool_t*,ulint,bool,const trx_t*)" -> "buf_flush_or_remove_page(buf_pool_t*,buf_page_t*,bool)"
"buf_flush_or_remove_pages(buf_pool_t*,ulint,bool,const trx_t*)" -> "buf_flush_try_yield(buf_pool_t*,buf_page_t*,ulint)"
"buf_flush_or_remove_pages(buf_pool_t*,ulint,bool,const trx_t*)" -> "buf_page_in_file(const buf_page_t*)"
"buf_flush_or_remove_pages(buf_pool_t*,ulint,bool,const trx_t*)" -> "ut_dbg_assertion_failed(const char*,const char*,ulint)"
"buf_flush_or_remove_pages(buf_pool_t*,ulint,bool,const trx_t*)" -> "abort()"
"buf_flush_or_remove_page(buf_pool_t*,buf_page_t*,bool)" -> "buf_page_get_io_fix(const buf_page_t*)"
"buf_flush_or_remove_page(buf_pool_t*,buf_page_t*,bool)" -> "pfs_mutex_enter_func(ib_mutex_t*,const char*,ulint)"
"buf_flush_or_remove_page(buf_pool_t*,buf_page_t*,bool)" -> "buf_flush_remove(buf_page_t*)"
"buf_flush_or_remove_page(buf_pool_t*,buf_page_t*,bool)" -> "buf_page_get_mutex(const buf_page_t*)"
"buf_flush_or_remove_page(buf_pool_t*,buf_page_t*,bool)" -> "buf_flush_page(buf_pool_t*,buf_page_t*,buf_flush_t,bool)"
"buf_flush_or_remove_page(buf_pool_t*,buf_page_t*,bool)" -> "os_aio_simulated_wake_handler_threads()"
"buf_flush_or_remove_page(buf_pool_t*,buf_page_t*,bool)" -> "pfs_mutex_exit_func(ib_mutex_t*)"
"buf_flush_or_remove_page(buf_pool_t*,buf_page_t*,bool)" -> "buf_flush_ready_for_flush(buf_page_t*,buf_flush_t)"
"buf_flush_remove(buf_page_t*)" -> "ut_dbg_assertion_failed(const char*,const char*,ulint)"
"buf_flush_remove(buf_page_t*)" -> "ut_list_remove(List&,Type&,size_t) [with List = ut_list_base<buf_page_t>,Type = buf_page_t,size_t = long unsigned int]"
"buf_flush_remove(buf_page_t*)" -> "buf_flush_update_hp(buf_pool_t*,buf_page_t*)"
"buf_flush_remove(buf_page_t*)" -> "pfs_mutex_exit_func(ib_mutex_t*)"
"buf_flush_remove(buf_page_t*)" -> "pfs_mutex_enter_func(ib_mutex_t*,const char*,ulint)"
"buf_flush_remove(buf_page_t*)" -> "__builtin_expect(long int,long int)"
"buf_flush_remove(buf_page_t*)" -> "abort()"
"buf_flush_remove(buf_page_t*)" -> "buf_flush_delete_from_flush_rbt(buf_page_t*)"
"buf_flush_remove(buf_page_t*)" -> "page_zip_get_size(const page_zip_des_t*)"
"buf_flush_remove(buf_page_t*)" -> "buf_pool_from_bpage(const buf_page_t*)"
"buf_flush_remove(buf_page_t*)" -> "buf_page_get_state(const buf_page_t*)"
"buf_flush_remove(buf_page_t*)" -> "buf_page_set_state(buf_page_t*,buf_page_state)"
"buf_flush_try_yield(buf_pool_t*,buf_page_t*,ulint)" -> "buf_page_get_io_fix(const buf_page_t*)"
"buf_flush_try_yield(buf_pool_t*,buf_page_t*,ulint)" -> "pfs_mutex_exit_func(ib_mutex_t*)"
"buf_flush_try_yield(buf_pool_t*,buf_page_t*,ulint)" -> "pfs_mutex_enter_func(ib_mutex_t*,const char*,ulint)"
"buf_flush_try_yield(buf_pool_t*,buf_page_t*,ulint)" -> "buf_flush_yield(buf_pool_t*,buf_page_t*)"
"buf_flush_yield(buf_pool_t*,buf_page_t*)" -> "buf_page_unset_sticky(buf_page_t*)"
"buf_flush_yield(buf_pool_t*,buf_page_t*)" -> "os_thread_yield()"
"buf_flush_yield(buf_pool_t*,buf_page_t*)" -> "pfs_mutex_enter_func(ib_mutex_t*,const char*,ulint)"
"buf_flush_yield(buf_pool_t*,buf_page_t*)" -> "buf_page_set_sticky(buf_page_t*)"
"buf_flush_yield(buf_pool_t*,buf_page_t*)" -> "pfs_mutex_exit_func(ib_mutex_t*)"
"buf_flush_yield(buf_pool_t*,buf_page_t*)" -> "buf_page_get_mutex(const buf_page_t*)"
"buf_LRU_remove_all_pages(buf_pool_t*,ulint)" -> "pfs_mutex_enter_func(ib_mutex_t*,const char*,ulint)"
"buf_LRU_remove_all_pages(buf_pool_t*,ulint)" -> "buf_LRU_block_remove_hashed(buf_page_t*,bool)"
"buf_LRU_remove_all_pages(buf_pool_t*,ulint)" -> "pfs_rw_lock_x_unlock_func(rw_lock_t*)"
"buf_LRU_remove_all_pages(buf_pool_t*,ulint)" -> "pfs_rw_lock_x_lock_func(rw_lock_t*,ulint,const char*,ulint)"
"buf_LRU_remove_all_pages(buf_pool_t*,ulint)" -> "abort()"
"buf_LRU_remove_all_pages(buf_pool_t*,ulint)" -> "buf_page_get_io_fix(const buf_page_t*)"
"buf_LRU_remove_all_pages(buf_pool_t*,ulint)" -> "buf_flush_remove(buf_page_t*)"
"buf_LRU_remove_all_pages(buf_pool_t*,ulint)" -> "buf_LRU_block_free_hashed_page(buf_block_t*)"
"buf_LRU_remove_all_pages(buf_pool_t*,ulint)" -> "buf_page_get_state(const buf_page_t*)"
"buf_LRU_remove_all_pages(buf_pool_t*,ulint)" -> "buf_page_in_file(const buf_page_t*)"
"buf_LRU_remove_all_pages(buf_pool_t*,ulint)" -> "ut_dbg_assertion_failed(const char*,const char*,ulint)"
"buf_LRU_remove_all_pages(buf_pool_t*,ulint)" -> "__builtin_expect(long int,long int)"
"buf_LRU_remove_all_pages(buf_pool_t*,ulint)" -> "buf_page_get_zip_size(const buf_page_t*)"
"buf_LRU_remove_all_pages(buf_pool_t*,ulint)" -> "hash_get_lock(hash_table_t*,ulint)"
"buf_LRU_remove_all_pages(buf_pool_t*,ulint)" -> "btr_search_drop_page_hash_when_freed(ulint,ulint,ulint)"
"buf_LRU_remove_all_pages(buf_pool_t*,ulint)" -> "pfs_mutex_exit_func(ib_mutex_t*)"
"buf_LRU_remove_all_pages(buf_pool_t*,ulint)" -> "os_thread_sleep(ulint)"
"buf_LRU_remove_all_pages(buf_pool_t*,ulint)" -> "buf_page_address_fold(ulint,ulint)"
"buf_LRU_remove_all_pages(buf_pool_t*,ulint)" -> "buf_page_get_page_no(const buf_page_t*)"
"buf_LRU_remove_all_pages(buf_pool_t*,ulint)" -> "buf_page_get_space(const buf_page_t*)"
"buf_LRU_remove_all_pages(buf_pool_t*,ulint)" -> "buf_page_get_mutex(const buf_page_t*)"
"fil_check_pending_operations(ulint,fil_space_t**,char**)" -> "pfs_mutex_enter_func(ib_mutex_t*,const char*,ulint)"
"fil_check_pending_operations(ulint,fil_space_t**,char**)" -> "fil_space_get_by_id(ulint)"
"fil_check_pending_operations(ulint,fil_space_t**,char**)" -> "ut_dbg_assertion_failed(const char*,const char*,ulint)"
"fil_check_pending_operations(ulint,fil_space_t**,char**)" -> "abort()"
"fil_check_pending_operations(ulint,fil_space_t**,char**)" -> "os_thread_sleep(ulint)"
"fil_check_pending_operations(ulint,fil_space_t**,char**)" -> "fil_check_pending_io(fil_space_t*,fil_node_t**,ulint)"
"fil_check_pending_operations(ulint,fil_space_t**,char**)" -> "mem_strdup(const char*)"
"fil_check_pending_operations(ulint,fil_space_t**,char**)" -> "__builtin_expect(long int,long int)"
"fil_check_pending_operations(ulint,fil_space_t**,char**)" -> "pfs_mutex_exit_func(ib_mutex_t*)"
"fil_check_pending_operations(ulint,fil_space_t**,char**)" -> "fil_ibuf_check_pending_ops(fil_space_t*,ulint)"
"fil_check_pending_io(fil_space_t*,fil_node_t**,ulint)" -> "ib_logf(ib_log_level_t,const char*,...)"
"fil_check_pending_io(fil_space_t*,fil_node_t**,ulint)" -> "__builtin_expect(long int,long int)"
"fil_check_pending_io(fil_space_t*,fil_node_t**,ulint)" -> "abort()"
"fil_check_pending_io(fil_space_t*,fil_node_t**,ulint)" -> "ut_dbg_assertion_failed(const char*,const char*,ulint)"
"fil_ibuf_check_pending_ops(fil_space_t*,ulint)" -> "ib_logf(ib_log_level_t,const char*,...)"
"dict_stats_recalc_pool_del(const dict_table_t*)" -> "_Container>::operator++() [with _Iterator = long unsigned int*,_Container = std::vector<long unsigned int>,__gnu_cxx::__normal_iterator<_Iterator,_Container> = __gnu_cxx::__normal_iterator<long unsigned int*,std::vector<long unsigned int> >]"
"dict_stats_recalc_pool_del(const dict_table_t*)" -> "pfs_mutex_exit_func(ib_mutex_t*)"
"dict_stats_recalc_pool_del(const dict_table_t*)" -> "_Alloc>::end() [with _Tp = long unsigned int,_Alloc = std::allocator<long unsigned int>,std::vector<_Tp,_Alloc>::iterator = __gnu_cxx::__normal_iterator<long unsigned int*,std::vector<long unsigned int> >,typename std::_Vector_base<_Tp,_Alloc>::_Tp_alloc_type::pointer = long unsigned int*]"
"dict_stats_recalc_pool_del(const dict_table_t*)" -> "_Container>::operator*() const [with _Iterator = long unsigned int*,_Container = std::vector<long unsigned int>,__gnu_cxx::__normal_iterator<_Iterator,_Container>::reference = long unsigned int&]"
"dict_stats_recalc_pool_del(const dict_table_t*)" -> "_Alloc>::erase(std::vector<_Tp,_Alloc>::iterator) [with _Tp = long unsigned int,_Alloc = std::allocator<long unsigned int>,std::vector<_Tp,_Alloc>::iterator = __gnu_cxx::__normal_iterator<long unsigned int*,std::vector<long unsigned int> >,typename std::_Vector_base<_Tp,_Alloc>::_Tp_alloc_type::pointer = long unsigned int*]"
"dict_stats_recalc_pool_del(const dict_table_t*)" -> "_Alloc>::begin() [with _Tp = long unsigned int,_Alloc = std::allocator<long unsigned int>,std::vector<_Tp,_Alloc>::iterator = __gnu_cxx::__normal_iterator<long unsigned int*,std::vector<long unsigned int> >,typename std::_Vector_base<_Tp,_Alloc>::_Tp_alloc_type::pointer = long unsigned int*]"
"dict_stats_recalc_pool_del(const dict_table_t*)" -> "__gnu_cxx::operator!=(const __gnu_cxx::__normal_iterator<_Iterator,_Container>&,const __gnu_cxx::__normal_iterator<_Iterator,_Container>&) [with _Iterator = long unsigned int*,_Container = std::vector<long unsigned int>]"
"dict_stats_recalc_pool_del(const dict_table_t*)" -> "pfs_mutex_enter_func(ib_mutex_t*,const char*,ulint)"
"_Alloc>::erase(std::vector<_Tp,_Alloc>::iterator) [with _Tp = long unsigned int,_Alloc = std::allocator<long unsigned int>,std::vector<_Tp,_Alloc>::iterator = __gnu_cxx::__normal_iterator<long unsigned int*,std::vector<long unsigned int> >,typename std::_Vector_base<_Tp,_Alloc>::_Tp_alloc_type::pointer = long unsigned int*]" -> "_Container>::operator+(const difference_type&) const [with _Iterator = long unsigned int*,_Container = std::vector<long unsigned int>,__gnu_cxx::__normal_iterator<_Iterator,_Container> = __gnu_cxx::__normal_iterator<long unsigned int*,std::vector<long unsigned int> >,__gnu_cxx::__normal_iterator<_Iterator,_Container>::difference_type = long int]"
"_Alloc>::erase(std::vector<_Tp,_Alloc>::iterator) [with _Tp = long unsigned int,_Alloc = std::allocator<long unsigned int>,std::vector<_Tp,_Alloc>::iterator = __gnu_cxx::__normal_iterator<long unsigned int*,std::vector<long unsigned int> >,typename std::_Vector_base<_Tp,_Alloc>::_Tp_alloc_type::pointer = long unsigned int*]" -> "__gnu_cxx::operator!=(const __gnu_cxx::__normal_iterator<_Iterator,_Container>&,const __gnu_cxx::__normal_iterator<_Iterator,_Container>&) [with _Iterator = long unsigned int*,_Container = std::vector<long unsigned int>]"
"_Alloc>::erase(std::vector<_Tp,_Alloc>::iterator) [with _Tp = long unsigned int,_Alloc = std::allocator<long unsigned int>,std::vector<_Tp,_Alloc>::iterator = __gnu_cxx::__normal_iterator<long unsigned int*,std::vector<long unsigned int> >,typename std::_Vector_base<_Tp,_Alloc>::_Tp_alloc_type::pointer = long unsigned int*]" -> "std::copy(_II,_II,_OI) [with _II = __gnu_cxx::__normal_iterator<long unsigned int*,std::vector<long unsigned int> >,_OI = __gnu_cxx::__normal_iterator<long unsigned int*,std::vector<long unsigned int> >]"
"_Alloc>::erase(std::vector<_Tp,_Alloc>::iterator) [with _Tp = long unsigned int,_Alloc = std::allocator<long unsigned int>,std::vector<_Tp,_Alloc>::iterator = __gnu_cxx::__normal_iterator<long unsigned int*,std::vector<long unsigned int> >,typename std::_Vector_base<_Tp,_Alloc>::_Tp_alloc_type::pointer = long unsigned int*]" -> "_Alloc>::end() [with _Tp = long unsigned int,_Alloc = std::allocator<long unsigned int>,std::vector<_Tp,_Alloc>::iterator = __gnu_cxx::__normal_iterator<long unsigned int*,std::vector<long unsigned int> >,typename std::_Vector_base<_Tp,_Alloc>::_Tp_alloc_type::pointer = long unsigned int*]"
"_Alloc>::erase(std::vector<_Tp,_Alloc>::iterator) [with _Tp = long unsigned int,_Alloc = std::allocator<long unsigned int>,std::vector<_Tp,_Alloc>::iterator = __gnu_cxx::__normal_iterator<long unsigned int*,std::vector<long unsigned int> >,typename std::_Vector_base<_Tp,_Alloc>::_Tp_alloc_type::pointer = long unsigned int*]" -> "__gnu_cxx::new_allocator<_Tp>::destroy(__gnu_cxx::new_allocator<_Tp>::pointer) [with _Tp = long unsigned int,__gnu_cxx::new_allocator<_Tp>::pointer = long unsigned int*]"
"_Container>::operator+(const difference_type&) const [with _Iterator = long unsigned int*,_Container = std::vector<long unsigned int>,__gnu_cxx::__normal_iterator<_Iterator,_Container> = __gnu_cxx::__normal_iterator<long unsigned int*,std::vector<long unsigned int> >,__gnu_cxx::__normal_iterator<_Iterator,_Container>::difference_type = long int]" -> "_Container>::__normal_iterator(const _Iterator&) [with _Iterator = long unsigned int*,_Container = std::vector<long unsigned int>]"
"row_mysql_handle_errors(dberr_t*,trx_t*,que_thr_t*,trx_savept_t*)" -> "que_thr_stop_for_mysql(que_thr_t*)"
"row_mysql_handle_errors(dberr_t*,trx_t*,que_thr_t*,trx_savept_t*)" -> "exit(int)"
"row_mysql_handle_errors(dberr_t*,trx_t*,que_thr_t*,trx_savept_t*)" -> "trx_rollback_to_savepoint(trx_t*,trx_savept_t*)"
"row_mysql_handle_errors(dberr_t*,trx_t*,que_thr_t*,trx_savept_t*)" -> "__builtin_fwrite(const void*,size_t,size_t,FILE*)"
"row_mysql_handle_errors(dberr_t*,trx_t*,que_thr_t*,trx_savept_t*)" -> "fprintf(FILE*,const char*,...)"
"row_mysql_handle_errors(dberr_t*,trx_t*,que_thr_t*,trx_savept_t*)" -> "__builtin_expect(long int,long int)"
"row_mysql_handle_errors(dberr_t*,trx_t*,que_thr_t*,trx_savept_t*)" -> "ut_dbg_assertion_failed(const char*,const char*,ulint)"
"row_mysql_handle_errors(dberr_t*,trx_t*,que_thr_t*,trx_savept_t*)" -> "lock_wait_suspend_thread(que_thr_t*)"
"row_mysql_handle_errors(dberr_t*,trx_t*,que_thr_t*,trx_savept_t*)" -> "abort()"
"row_merge_drop_indexes_dict(trx_t*,table_id_t)" -> "pars_info_create()"
"row_merge_drop_indexes_dict(trx_t*,table_id_t)" -> "que_eval_sql(pars_info_t*,const char*,ulint,trx_t*)"
"row_merge_drop_indexes_dict(trx_t*,table_id_t)" -> "ut_print_timestamp(FILE*)"
"row_merge_drop_indexes_dict(trx_t*,table_id_t)" -> "fprintf(FILE*,const char*,...)"
"row_merge_drop_indexes_dict(trx_t*,table_id_t)" -> "pars_info_add_ull_literal(pars_info_t*,const char*,ib_uint64_t)"
"row_log_abort_sec(dict_index_t*)" -> "dict_index_set_online_status(dict_index_t*,online_index_status)"
"row_log_abort_sec(dict_index_t*)" -> "row_log_free(row_log_t*&)"
"row_merge_drop_index_dict(trx_t*,index_id_t)" -> "pars_info_add_ull_literal(pars_info_t*,const char*,ib_uint64_t)"
"row_merge_drop_index_dict(trx_t*,index_id_t)" -> "que_eval_sql(pars_info_t*,const char*,ulint,trx_t*)"
"row_merge_drop_index_dict(trx_t*,index_id_t)" -> "fprintf(FILE*,const char*,...)"
"row_merge_drop_index_dict(trx_t*,index_id_t)" -> "pars_info_create()"
"row_merge_drop_index_dict(trx_t*,index_id_t)" -> "ut_print_timestamp(FILE*)"
"dict_load_columns(dict_table_t*,mem_heap_t*)" -> "__builtin_expect(long int,long int)"
"dict_load_columns(dict_table_t*,mem_heap_t*)" -> "mem_heap_alloc(mem_heap_t*,ulint)"
"dict_load_columns(dict_table_t*,mem_heap_t*)" -> "mtr_commit(mtr_t*)"
"dict_load_columns(dict_table_t*,mem_heap_t*)" -> "mtr_start(mtr_t*)"
"dict_load_columns(dict_table_t*,mem_heap_t*)" -> "abort()"
"dict_load_columns(dict_table_t*,mem_heap_t*)" -> "fts_create(dict_table_t*)"
"dict_load_columns(dict_table_t*,mem_heap_t*)" -> "dict_index_copy_types(dtuple_t*,const dict_index_t*,ulint)"
"dict_load_columns(dict_table_t*,mem_heap_t*)" -> "btr_pcur_open_on_user_rec_func(dict_index_t*,const dtuple_t*,ulint,ulint,btr_pcur_t*,const char*,ulint,mtr_t*)"
"dict_load_columns(dict_table_t*,mem_heap_t*)" -> "dict_load_column_low(dict_table_t*,mem_heap_t*,dict_col_t*,table_id_t*,const char**,const rec_t*)"
"dict_load_columns(dict_table_t*,mem_heap_t*)" -> "btr_pcur_move_to_next_user_rec(btr_pcur_t*,mtr_t*)"
"dict_load_columns(dict_table_t*,mem_heap_t*)" -> "dict_table_get_low(const char*)"
"dict_load_columns(dict_table_t*,mem_heap_t*)" -> "btr_pcur_close(btr_pcur_t*)"
"dict_load_columns(dict_table_t*,mem_heap_t*)" -> "fts_optimize_add_table(dict_table_t*)"
"dict_load_columns(dict_table_t*,mem_heap_t*)" -> "fprintf(FILE*,const char*,...)"
"dict_load_columns(dict_table_t*,mem_heap_t*)" -> "dfield_set_data(dfield_t*,const void*,ulint)"
"dict_load_columns(dict_table_t*,mem_heap_t*)" -> "innobase_strcasecmp(const char*,const char*)"
"dict_load_columns(dict_table_t*,mem_heap_t*)" -> "btr_pcur_is_on_user_rec(const btr_pcur_t*)"
"dict_load_columns(dict_table_t*,mem_heap_t*)" -> "dtuple_create(mem_heap_t*,ulint)"
"dict_load_columns(dict_table_t*,mem_heap_t*)" -> "ut_dbg_assertion_failed(const char*,const char*,ulint)"
"dict_load_columns(dict_table_t*,mem_heap_t*)" -> "mach_write_to_8(void*,ib_uint64_t)"
"dict_load_column_low(dict_table_t*,mem_heap_t*,dict_col_t*,table_id_t*,const char**,const rec_t*)" -> "rec_get_nth_field_offs_old(const rec_t*,ulint,ulint*)"
"dict_load_column_low(dict_table_t*,mem_heap_t*,dict_col_t*,table_id_t*,const char**,const rec_t*)" -> "dtype_is_binary_string_type(ulint,ulint)"
"dict_load_column_low(dict_table_t*,mem_heap_t*,dict_col_t*,table_id_t*,const char**,const rec_t*)" -> "dtype_get_charset_coll(ulint)"
"dict_load_column_low(dict_table_t*,mem_heap_t*,dict_col_t*,table_id_t*,const char**,const rec_t*)" -> "dict_mem_table_add_col(dict_table_t*,mem_heap_t*,const char*,ulint,ulint,ulint)"
"dict_load_column_low(dict_table_t*,mem_heap_t*,dict_col_t*,table_id_t*,const char**,const rec_t*)" -> "mem_heap_strdupl(mem_heap_t*,const char*,ulint)"
"dict_load_column_low(dict_table_t*,mem_heap_t*,dict_col_t*,table_id_t*,const char**,const rec_t*)" -> "rec_get_n_fields_old(const rec_t*)"
"dict_load_column_low(dict_table_t*,mem_heap_t*,dict_col_t*,table_id_t*,const char**,const rec_t*)" -> "dict_mem_fill_column_struct(dict_col_t*,ulint,ulint,ulint,ulint)"
"dict_load_column_low(dict_table_t*,mem_heap_t*,dict_col_t*,table_id_t*,const char**,const rec_t*)" -> "mach_read_from_4(const unsigned char*)"
"dict_load_column_low(dict_table_t*,mem_heap_t*,dict_col_t*,table_id_t*,const char**,const rec_t*)" -> "dtype_is_string_type(ulint)"
"dict_load_column_low(dict_table_t*,mem_heap_t*,dict_col_t*,table_id_t*,const char**,const rec_t*)" -> "dtype_form_prtype(ulint,ulint)"
"dict_load_column_low(dict_table_t*,mem_heap_t*,dict_col_t*,table_id_t*,const char**,const rec_t*)" -> "rec_get_deleted_flag(const rec_t*,ulint)"
"dict_load_column_low(dict_table_t*,mem_heap_t*,dict_col_t*,table_id_t*,const char**,const rec_t*)" -> "mach_read_from_8(const unsigned char*)"
"pars_function_declaration(sym_node_t*)" -> "__builtin_expect(long int,long int)"
"pars_function_declaration(sym_node_t*)" -> "pars_info_lookup_user_func(pars_info_t*,const char*)"
"pars_function_declaration(sym_node_t*)" -> "abort()"
"pars_function_declaration(sym_node_t*)" -> "ut_dbg_assertion_failed(const char*,const char*,ulint)"
"pars_open_statement(ulint,sym_node_t*)" -> "abort()"
"pars_open_statement(ulint,sym_node_t*)" -> "mem_heap_alloc(mem_heap_t*,ulint)"
"pars_open_statement(ulint,sym_node_t*)" -> "pars_resolve_exp_variables_and_types(sel_node_t*,que_node_t*)"
"pars_open_statement(ulint,sym_node_t*)" -> "__builtin_expect(long int,long int)"
"pars_open_statement(ulint,sym_node_t*)" -> "ut_dbg_assertion_failed(const char*,const char*,ulint)"
"pars_stored_procedure_call(sym_node_t*)" -> "ut_dbg_assertion_failed(const char*,const char*,ulint)"
"pars_stored_procedure_call(sym_node_t*)" -> "abort()"
"pars_rollback_statement()" -> "roll_node_create(mem_heap_t*)"
"pars_return_statement()" -> "mem_heap_alloc(mem_heap_t*,ulint)"
"pars_column_assignment(sym_node_t*,que_node_t*)" -> "mem_heap_alloc(mem_heap_t*,ulint)"
"pars_order_by(sym_node_t*,pars_res_word_t*)" -> "abort()"
"pars_order_by(sym_node_t*,pars_res_word_t*)" -> "mem_heap_alloc(mem_heap_t*,ulint)"
"pars_order_by(sym_node_t*,pars_res_word_t*)" -> "__builtin_expect(long int,long int)"
"pars_order_by(sym_node_t*,pars_res_word_t*)" -> "ut_dbg_assertion_failed(const char*,const char*,ulint)"
"pars_insert_statement(sym_node_t*,que_node_t*,sel_node_t*)" -> "ins_node_create(ulint,dict_table_t*,mem_heap_t*)"
"pars_insert_statement(sym_node_t*,que_node_t*,sel_node_t*)" -> "que_node_list_get_len(que_node_t*)"
"pars_insert_statement(sym_node_t*,que_node_t*,sel_node_t*)" -> "dict_table_copy_types(dtuple_t*,const dict_table_t*)"
"pars_insert_statement(sym_node_t*,que_node_t*,sel_node_t*)" -> "dict_table_get_n_user_cols(const dict_table_t*)"
"pars_insert_statement(sym_node_t*,que_node_t*,sel_node_t*)" -> "pars_retrieve_table_def(sym_node_t*)"
"pars_insert_statement(sym_node_t*,que_node_t*,sel_node_t*)" -> "abort()"
"pars_insert_statement(sym_node_t*,que_node_t*,sel_node_t*)" -> "pars_resolve_exp_list_variables_and_types(sel_node_t*,que_node_t*)"
"pars_insert_statement(sym_node_t*,que_node_t*,sel_node_t*)" -> "__builtin_expect(long int,long int)"
"pars_insert_statement(sym_node_t*,que_node_t*,sel_node_t*)" -> "ins_node_set_new_row(ins_node_t*,dtuple_t*)"
"pars_insert_statement(sym_node_t*,que_node_t*,sel_node_t*)" -> "dict_table_get_n_cols(const dict_table_t*)"
"pars_insert_statement(sym_node_t*,que_node_t*,sel_node_t*)" -> "dtuple_create(mem_heap_t*,ulint)"
"pars_insert_statement(sym_node_t*,que_node_t*,sel_node_t*)" -> "ut_dbg_assertion_failed(const char*,const char*,ulint)"
"ins_node_create(ulint,dict_table_t*,mem_heap_t*)" -> "mem_heap_create_func(ulint,ulint)"
"ins_node_create(ulint,dict_table_t*,mem_heap_t*)" -> "mem_heap_alloc(mem_heap_t*,ulint)"
"yylex()" -> "sym_tab_add_null_lit(sym_tab_t*)"
"yylex()" -> "yy_load_buffer_state()"
"yylex()" -> "sym_tab_add_bound_lit(sym_tab_t*,const char*,ulint*)"
"yylex()" -> "sym_tab_add_bound_id(sym_tab_t*,const char*)"
"yylex()" -> "sym_tab_add_str_lit(sym_tab_t*,const unsigned char*,ulint)"
"yylex()" -> "yy_get_next_buffer()"
"yylex()" -> "yyensure_buffer_stack()"
"yylex()" -> "sym_tab_add_int_lit(sym_tab_t*,ulint)"
"yylex()" -> "fprintf(FILE*,const char*,...)"
"yylex()" -> "string_append(const char*,ulint)"
"yylex()" -> "atoi(const char*)"
"yylex()" -> "ut_dbg_assertion_failed(const char*,const char*,ulint)"
"yylex()" -> "yy_get_previous_state()"
"yylex()" -> "yy_try_NUL_trans(yy_state_type)"
"yylex()" -> "ut_strlen(const char*)"
"yylex()" -> "abort()"
"yylex()" -> "yy_fatal_error(const char*)"
"yylex()" -> "sym_tab_add_id(sym_tab_t*,unsigned char*,ulint)"
"yylex()" -> "yy_create_buffer(FILE*,int)"
"sym_tab_add_null_lit(sym_tab_t*)" -> "ut_list_append(List&,Type&,size_t) [with List = ut_list_base<sym_node_t>,Type = sym_node_t,size_t = long unsigned int]"
"sym_tab_add_null_lit(sym_tab_t*)" -> "dfield_set_null(dfield_t*)"
"sym_tab_add_null_lit(sym_tab_t*)" -> "mem_heap_alloc(mem_heap_t*,ulint)"
"sym_tab_add_bound_lit(sym_tab_t*,const char*,ulint*)" -> "dtype_set(dtype_t*,ulint,ulint,ulint)"
"sym_tab_add_bound_lit(sym_tab_t*,const char*,ulint*)" -> "pars_info_get_bound_lit(pars_info_t*,const char*)"
"sym_tab_add_bound_lit(sym_tab_t*,const char*,ulint*)" -> "mem_heap_alloc(mem_heap_t*,ulint)"
"sym_tab_add_bound_lit(sym_tab_t*,const char*,ulint*)" -> "__builtin_expect(long int,long int)"
"sym_tab_add_bound_lit(sym_tab_t*,const char*,ulint*)" -> "abort()"
"sym_tab_add_bound_lit(sym_tab_t*,const char*,ulint*)" -> "ut_list_append(List&,Type&,size_t) [with List = ut_list_base<sym_node_t>,Type = sym_node_t,size_t = long unsigned int]"
"sym_tab_add_bound_lit(sym_tab_t*,const char*,ulint*)" -> "dfield_set_data(dfield_t*,const void*,ulint)"
"sym_tab_add_bound_lit(sym_tab_t*,const char*,ulint*)" -> "ut_dbg_assertion_failed(const char*,const char*,ulint)"
"pars_info_get_bound_lit(pars_info_t*,const char*)" -> "pars_info_lookup_bound_lit(pars_info_t*,const char*)"
"sym_tab_add_bound_id(sym_tab_t*,const char*)" -> "mem_heap_strdup(mem_heap_t*,const char*)"
"sym_tab_add_bound_id(sym_tab_t*,const char*)" -> "ut_list_append(List&,Type&,size_t) [with List = ut_list_base<sym_node_t>,Type = sym_node_t,size_t = long unsigned int]"
"sym_tab_add_bound_id(sym_tab_t*,const char*)" -> "dfield_set_null(dfield_t*)"
"sym_tab_add_bound_id(sym_tab_t*,const char*)" -> "ut_dbg_assertion_failed(const char*,const char*,ulint)"
"sym_tab_add_bound_id(sym_tab_t*,const char*)" -> "pars_info_get_bound_id(pars_info_t*,const char*)"
"sym_tab_add_bound_id(sym_tab_t*,const char*)" -> "mem_heap_alloc(mem_heap_t*,ulint)"
"sym_tab_add_bound_id(sym_tab_t*,const char*)" -> "abort()"
"sym_tab_add_bound_id(sym_tab_t*,const char*)" -> "__builtin_expect(long int,long int)"
"sym_tab_add_bound_id(sym_tab_t*,const char*)" -> "strlen(const char*)"
"pars_info_get_bound_id(pars_info_t*,const char*)" -> "pars_info_lookup_bound_id(pars_info_t*,const char*)"
"yy_get_next_buffer()" -> "yyrealloc(void*,yy_size_t)"
"yy_get_next_buffer()" -> "yyrestart(FILE*)"
"yy_get_next_buffer()" -> "yy_fatal_error(const char*)"
"yy_get_next_buffer()" -> "pars_get_lex_chars(char*,int)"
"yyrealloc(void*,yy_size_t)" -> "ut_realloc(void*,ulint)"
"ut_realloc(void*,ulint)" -> "ut_memcpy(void*,const void*,ulint)"
"ut_realloc(void*,ulint)" -> "realloc(void*,size_t)"
"ut_realloc(void*,ulint)" -> "__builtin_expect(long int,long int)"
"ut_realloc(void*,ulint)" -> "abort()"
"ut_realloc(void*,ulint)" -> "ut_free(void*)"
"ut_realloc(void*,ulint)" -> "ut_dbg_assertion_failed(const char*,const char*,ulint)"
"ut_realloc(void*,ulint)" -> "ut_malloc_low(ulint,ulint)"
"yyrestart(FILE*)" -> "yy_init_buffer(YY_BUFFER_STATE,FILE*)"
"yyrestart(FILE*)" -> "yy_create_buffer(FILE*,int)"
"yyrestart(FILE*)" -> "yy_load_buffer_state()"
"yyrestart(FILE*)" -> "yyensure_buffer_stack()"
"yy_init_buffer(YY_BUFFER_STATE,FILE*)" -> "__errno_location()"
"yy_init_buffer(YY_BUFFER_STATE,FILE*)" -> "yy_flush_buffer(YY_BUFFER_STATE)"
"yy_flush_buffer(YY_BUFFER_STATE)" -> "yy_load_buffer_state()"
"yy_create_buffer(FILE*,int)" -> "yy_fatal_error(const char*)"
"yy_create_buffer(FILE*,int)" -> "yy_init_buffer(YY_BUFFER_STATE,FILE*)"
"yy_create_buffer(FILE*,int)" -> "yyalloc(yy_size_t)"
"yy_fatal_error(const char*)" -> "ut_dbg_assertion_failed(const char*,const char*,ulint)"
"yy_fatal_error(const char*)" -> "abort()"
"yy_fatal_error(const char*)" -> "fprintf(FILE*,const char*,...)"
"yyalloc(yy_size_t)" -> "ut_malloc_low(ulint,ulint)"
"yyensure_buffer_stack()" -> "memset(void*,int,size_t)"
"yyensure_buffer_stack()" -> "yyalloc(yy_size_t)"
"yyensure_buffer_stack()" -> "yyrealloc(void*,yy_size_t)"
"yyensure_buffer_stack()" -> "yy_fatal_error(const char*)"
"pars_get_lex_chars(char*,int)" -> "ut_memcpy(void*,const void*,ulint)"
"string_append(const char*,ulint)" -> "ut_malloc_low(ulint,ulint)"
"string_append(const char*,ulint)" -> "memcpy(void*,const void*,size_t)"
"string_append(const char*,ulint)" -> "ut_realloc(void*,ulint)"
"pars_if_statement(que_node_t*,que_node_t*,que_node_t*)" -> "pars_set_parent_in_list(que_node_t*,que_node_t*)"
"pars_if_statement(que_node_t*,que_node_t*,que_node_t*)" -> "que_node_get_type(que_node_t*)"
"pars_if_statement(que_node_t*,que_node_t*,que_node_t*)" -> "mem_heap_alloc(mem_heap_t*,ulint)"
"pars_if_statement(que_node_t*,que_node_t*,que_node_t*)" -> "que_node_get_next(que_node_t*)"
"pars_if_statement(que_node_t*,que_node_t*,que_node_t*)" -> "pars_resolve_exp_variables_and_types(sel_node_t*,que_node_t*)"
"pars_set_parent_in_list(que_node_t*,que_node_t*)" -> "que_node_get_next(que_node_t*)"
"pars_assignment_statement(sym_node_t*,que_node_t*)" -> "pars_resolve_exp_variables_and_types(sel_node_t*,que_node_t*)"
"pars_assignment_statement(sym_node_t*,que_node_t*)" -> "__builtin_expect(long int,long int)"
"pars_assignment_statement(sym_node_t*,que_node_t*)" -> "abort()"
"pars_assignment_statement(sym_node_t*,que_node_t*)" -> "mem_heap_alloc(mem_heap_t*,ulint)"
"pars_assignment_statement(sym_node_t*,que_node_t*)" -> "que_node_get_val(que_node_t*)"
"pars_assignment_statement(sym_node_t*,que_node_t*)" -> "dtype_get_mtype(const dtype_t*)"
"pars_assignment_statement(sym_node_t*,que_node_t*)" -> "ut_dbg_assertion_failed(const char*,const char*,ulint)"
"pars_procedure_call(que_node_t*,que_node_t*)" -> "pars_resolve_exp_list_variables_and_types(sel_node_t*,que_node_t*)"
"pars_procedure_call(que_node_t*,que_node_t*)" -> "pars_func(que_node_t*,que_node_t*)"
"pars_func(que_node_t*,que_node_t*)" -> "pars_func_low(int,que_node_t*)"
"pars_func_low(int,que_node_t*)" -> "dfield_set_data(dfield_t*,const void*,ulint)"
"pars_func_low(int,que_node_t*)" -> "ut_list_append(List&,Type&,size_t) [with List = ut_list_base<func_node_t>,Type = func_node_t,size_t = long unsigned int]"
"pars_func_low(int,que_node_t*)" -> "mem_heap_alloc(mem_heap_t*,ulint)"
"pars_func_low(int,que_node_t*)" -> "pars_func_get_class(int)"
"pars_procedure_definition(sym_node_t*,sym_node_t*,que_node_t*)" -> "que_thr_create(que_fork_t*,mem_heap_t*)"
"pars_procedure_definition(sym_node_t*,sym_node_t*,que_node_t*)" -> "mem_heap_alloc(mem_heap_t*,ulint)"
"pars_procedure_definition(sym_node_t*,sym_node_t*,que_node_t*)" -> "pars_set_parent_in_list(que_node_t*,que_node_t*)"
"pars_procedure_definition(sym_node_t*,sym_node_t*,que_node_t*)" -> "que_fork_create(que_t*,que_node_t*,ulint,mem_heap_t*)"
"pars_for_statement(sym_node_t*,que_node_t*,que_node_t*,que_node_t*)" -> "abort()"
"pars_for_statement(sym_node_t*,que_node_t*,que_node_t*,que_node_t*)" -> "ut_dbg_assertion_failed(const char*,const char*,ulint)"
"pars_for_statement(sym_node_t*,que_node_t*,que_node_t*,que_node_t*)" -> "__builtin_expect(long int,long int)"
"pars_for_statement(sym_node_t*,que_node_t*,que_node_t*,que_node_t*)" -> "mem_heap_alloc(mem_heap_t*,ulint)"
"pars_for_statement(sym_node_t*,que_node_t*,que_node_t*,que_node_t*)" -> "pars_set_parent_in_list(que_node_t*,que_node_t*)"
"pars_for_statement(sym_node_t*,que_node_t*,que_node_t*,que_node_t*)" -> "pars_resolve_exp_variables_and_types(sel_node_t*,que_node_t*)"
"pars_commit_statement()" -> "trx_commit_node_create(mem_heap_t*)"
"trx_commit_node_create(mem_heap_t*)" -> "mem_heap_alloc(mem_heap_t*,ulint)"
"pars_row_printf_statement(sel_node_t*)" -> "mem_heap_alloc(mem_heap_t*,ulint)"
"pars_create_table(sym_node_t*,sym_node_t*,sym_node_t*,sym_node_t*,void*)" -> "__builtin_expect(long int,long int)"
"pars_create_table(sym_node_t*,sym_node_t*,sym_node_t*,sym_node_t*,void*)" -> "dfield_get_len(const dfield_t*)"
"pars_create_table(sym_node_t*,sym_node_t*,sym_node_t*,sym_node_t*,void*)" -> "dict_mem_table_create(const char*,ulint,ulint,ulint,ulint)"
"pars_create_table(sym_node_t*,sym_node_t*,sym_node_t*,sym_node_t*,void*)" -> "ut_dbg_assertion_failed(const char*,const char*,ulint)"
"pars_create_table(sym_node_t*,sym_node_t*,sym_node_t*,sym_node_t*,void*)" -> "dict_mem_table_add_col(dict_table_t*,mem_heap_t*,const char*,ulint,ulint,ulint)"
"pars_create_table(sym_node_t*,sym_node_t*,sym_node_t*,sym_node_t*,void*)" -> "tab_create_graph_create(dict_table_t*,mem_heap_t*,bool)"
"pars_create_table(sym_node_t*,sym_node_t*,sym_node_t*,sym_node_t*,void*)" -> "que_node_get_next(que_node_t*)"
"pars_create_table(sym_node_t*,sym_node_t*,sym_node_t*,sym_node_t*,void*)" -> "mach_read_from_4(const unsigned char*)"
"pars_create_table(sym_node_t*,sym_node_t*,sym_node_t*,sym_node_t*,void*)" -> "que_node_list_get_len(que_node_t*)"
"pars_create_table(sym_node_t*,sym_node_t*,sym_node_t*,sym_node_t*,void*)" -> "que_node_get_val(que_node_t*)"
"pars_create_table(sym_node_t*,sym_node_t*,sym_node_t*,sym_node_t*,void*)" -> "abort()"
"tab_create_graph_create(dict_table_t*,mem_heap_t*,bool)" -> "mem_heap_alloc(mem_heap_t*,ulint)"
"tab_create_graph_create(dict_table_t*,mem_heap_t*,bool)" -> "mem_heap_create_func(ulint,ulint)"
"tab_create_graph_create(dict_table_t*,mem_heap_t*,bool)" -> "trx_commit_node_create(mem_heap_t*)"
"tab_create_graph_create(dict_table_t*,mem_heap_t*,bool)" -> "ins_node_create(ulint,dict_table_t*,mem_heap_t*)"
"pars_op(int,que_node_t*,que_node_t*)" -> "ut_dbg_assertion_failed(const char*,const char*,ulint)"
"pars_op(int,que_node_t*,que_node_t*)" -> "abort()"
"pars_op(int,que_node_t*,que_node_t*)" -> "pars_like_op(que_node_t*)"
"pars_op(int,que_node_t*,que_node_t*)" -> "que_node_list_add_last(que_node_t*,que_node_t*)"
"pars_op(int,que_node_t*,que_node_t*)" -> "__builtin_expect(long int,long int)"
"pars_op(int,que_node_t*,que_node_t*)" -> "pars_func_low(int,que_node_t*)"
"pars_op(int,que_node_t*,que_node_t*)" -> "que_node_get_type(que_node_t*)"
"pars_like_op(que_node_t*)" -> "que_node_get_val(que_node_t*)"
"pars_like_op(que_node_t*)" -> "dtype_get_mtype(const dtype_t*)"
"pars_like_op(que_node_t*)" -> "ut_dbg_assertion_failed(const char*,const char*,ulint)"
"pars_like_op(que_node_t*)" -> "strlen(const char*)"
"pars_like_op(que_node_t*)" -> "abort()"
"pars_like_op(que_node_t*)" -> "__builtin_expect(long int,long int)"
"pars_like_op(que_node_t*)" -> "pars_like_rebind(sym_node_t*,const unsigned char*,ulint)"
"pars_fetch_statement(sym_node_t*,sym_node_t*,sym_node_t*)" -> "pars_resolve_exp_list_variables_and_types(sel_node_t*,que_node_t*)"
"pars_fetch_statement(sym_node_t*,sym_node_t*,sym_node_t*)" -> "que_node_list_get_len(que_node_t*)"
"pars_fetch_statement(sym_node_t*,sym_node_t*,sym_node_t*)" -> "__builtin_expect(long int,long int)"
"pars_fetch_statement(sym_node_t*,sym_node_t*,sym_node_t*)" -> "ut_dbg_assertion_failed(const char*,const char*,ulint)"
"pars_fetch_statement(sym_node_t*,sym_node_t*,sym_node_t*)" -> "mem_heap_alloc(mem_heap_t*,ulint)"
"pars_fetch_statement(sym_node_t*,sym_node_t*,sym_node_t*)" -> "abort()"
"pars_fetch_statement(sym_node_t*,sym_node_t*,sym_node_t*)" -> "pars_resolve_exp_variables_and_types(sel_node_t*,que_node_t*)"
"pars_fetch_statement(sym_node_t*,sym_node_t*,sym_node_t*)" -> "pars_info_lookup_user_func(pars_info_t*,const char*)"
"pars_column_def(sym_node_t*,pars_res_word_t*,sym_node_t*,void*,void*)" -> "que_node_get_val(que_node_t*)"
"pars_column_def(sym_node_t*,pars_res_word_t*,sym_node_t*,void*,void*)" -> "pars_set_dfield_type(dfield_t*,pars_res_word_t*,ulint,ulint,ulint)"
"pars_column_def(sym_node_t*,pars_res_word_t*,sym_node_t*,void*,void*)" -> "eval_node_get_int_val(que_node_t*)"
"pars_while_statement(que_node_t*,que_node_t*)" -> "pars_resolve_exp_variables_and_types(sel_node_t*,que_node_t*)"
"pars_while_statement(que_node_t*,que_node_t*)" -> "mem_heap_alloc(mem_heap_t*,ulint)"
"pars_while_statement(que_node_t*,que_node_t*)" -> "pars_set_parent_in_list(que_node_t*,que_node_t*)"
"pars_create_index(pars_res_word_t*,pars_res_word_t*,sym_node_t*,sym_node_t*,sym_node_t*)" -> "que_node_get_next(que_node_t*)"
"pars_create_index(pars_res_word_t*,pars_res_word_t*,sym_node_t*,sym_node_t*,sym_node_t*)" -> "dict_mem_index_create(const char*,const char*,ulint,ulint,ulint)"
"pars_create_index(pars_res_word_t*,pars_res_word_t*,sym_node_t*,sym_node_t*,sym_node_t*)" -> "dict_mem_index_add_field(dict_index_t*,const char*,ulint)"
"pars_create_index(pars_res_word_t*,pars_res_word_t*,sym_node_t*,sym_node_t*,sym_node_t*)" -> "que_node_list_get_len(que_node_t*)"
"pars_create_index(pars_res_word_t*,pars_res_word_t*,sym_node_t*,sym_node_t*,sym_node_t*)" -> "ind_create_graph_create(dict_index_t*,mem_heap_t*,bool)"
"ind_create_graph_create(dict_index_t*,mem_heap_t*,bool)" -> "mem_heap_alloc(mem_heap_t*,ulint)"
"ind_create_graph_create(dict_index_t*,mem_heap_t*,bool)" -> "trx_commit_node_create(mem_heap_t*)"
"ind_create_graph_create(dict_index_t*,mem_heap_t*,bool)" -> "mem_heap_create_func(ulint,ulint)"
"ind_create_graph_create(dict_index_t*,mem_heap_t*,bool)" -> "ins_node_create(ulint,dict_table_t*,mem_heap_t*)"
"pars_elsif_element(que_node_t*,que_node_t*)" -> "pars_resolve_exp_variables_and_types(sel_node_t*,que_node_t*)"
"pars_elsif_element(que_node_t*,que_node_t*)" -> "mem_heap_alloc(mem_heap_t*,ulint)"
"pars_update_statement_start(ulint,sym_node_t*,col_assign_node_t*)" -> "upd_node_create(mem_heap_t*)"
"yyerror(const char*)" -> "__builtin_fwrite(const void*,size_t,size_t,FILE*)"
"yyerror(const char*)" -> "abort()"
"yyerror(const char*)" -> "ut_dbg_assertion_failed(const char*,const char*,ulint)"
"pars_exit_statement()" -> "mem_heap_alloc(mem_heap_t*,ulint)"
"sym_tab_create(mem_heap_t*)" -> "mem_heap_alloc(mem_heap_t*,ulint)"
"fts_add(fts_trx_table_t*,fts_trx_row_t*)" -> "ut_dbg_assertion_failed(const char*,const char*,ulint)"
"fts_add(fts_trx_table_t*,fts_trx_row_t*)" -> "fts_add_doc_by_id(fts_trx_table_t*,doc_id_t,ib_vector_t*)"
"fts_add(fts_trx_table_t*,fts_trx_row_t*)" -> "abort()"
"fts_add(fts_trx_table_t*,fts_trx_row_t*)" -> "pfs_mutex_exit_func(ib_mutex_t*)"
"fts_add(fts_trx_table_t*,fts_trx_row_t*)" -> "pfs_mutex_enter_func(ib_mutex_t*,const char*,ulint)"
"fts_add(fts_trx_table_t*,fts_trx_row_t*)" -> "__builtin_expect(long int,long int)"
"fts_add_doc_by_id(fts_trx_table_t*,doc_id_t,ib_vector_t*)" -> "mach_write_to_8(void*,ib_uint64_t)"
"fts_add_doc_by_id(fts_trx_table_t*,doc_id_t,ib_vector_t*)" -> "mtr_start(mtr_t*)"
"fts_add_doc_by_id(fts_trx_table_t*,doc_id_t,ib_vector_t*)" -> "btr_pcur_get_low_match(const btr_pcur_t*)"
"fts_add_doc_by_id(fts_trx_table_t*,doc_id_t,ib_vector_t*)" -> "fts_doc_init(fts_doc_t*)"
"fts_add_doc_by_id(fts_trx_table_t*,doc_id_t,ib_vector_t*)" -> "dict_table_get_index_on_name(dict_table_t*,const char*)"
"fts_add_doc_by_id(fts_trx_table_t*,doc_id_t,ib_vector_t*)" -> "btr_pcur_init(btr_pcur_t*)"
"fts_add_doc_by_id(fts_trx_table_t*,doc_id_t,ib_vector_t*)" -> "pfs_rw_lock_x_unlock_func(rw_lock_t*)"
"fts_add_doc_by_id(fts_trx_table_t*,doc_id_t,ib_vector_t*)" -> "fts_sync(fts_sync_t*)"
"fts_add_doc_by_id(fts_trx_table_t*,doc_id_t,ib_vector_t*)" -> "fts_init_index(dict_table_t*,ulint)"
"fts_add_doc_by_id(fts_trx_table_t*,doc_id_t,ib_vector_t*)" -> "row_build_row_ref_in_tuple(dtuple_t*,const rec_t*,const dict_index_t*,ulint*,trx_t*)"
"fts_add_doc_by_id(fts_trx_table_t*,doc_id_t,ib_vector_t*)" -> "dict_index_copy_types(dtuple_t*,const dict_index_t*,ulint)"
"fts_add_doc_by_id(fts_trx_table_t*,doc_id_t,ib_vector_t*)" -> "rec_get_deleted_flag(const rec_t*,ulint)"
"fts_add_doc_by_id(fts_trx_table_t*,doc_id_t,ib_vector_t*)" -> "rec_get_offsets_func(const rec_t*,const dict_index_t*,ulint*,ulint,mem_heap_t**)"
"fts_add_doc_by_id(fts_trx_table_t*,doc_id_t,ib_vector_t*)" -> "fts_doc_free(fts_doc_t*)"
"fts_add_doc_by_id(fts_trx_table_t*,doc_id_t,ib_vector_t*)" -> "mtr_commit(mtr_t*)"
"fts_add_doc_by_id(fts_trx_table_t*,doc_id_t,ib_vector_t*)" -> "fts_fetch_doc_from_rec(fts_get_doc_t*,dict_index_t*,btr_pcur_t*,ulint*,fts_doc_t*)"
"fts_add_doc_by_id(fts_trx_table_t*,doc_id_t,ib_vector_t*)" -> "mem_heap_free_func(mem_heap_t*,const char*,ulint)"
"fts_add_doc_by_id(fts_trx_table_t*,doc_id_t,ib_vector_t*)" -> "mem_heap_create_func(ulint,ulint)"
"fts_add_doc_by_id(fts_trx_table_t*,doc_id_t,ib_vector_t*)" -> "page_rec_is_infimum(const rec_t*)"
"fts_add_doc_by_id(fts_trx_table_t*,doc_id_t,ib_vector_t*)" -> "fts_cache_add_doc(fts_cache_t*,fts_index_cache_t*,doc_id_t,ib_rbt_t*)"
"fts_add_doc_by_id(fts_trx_table_t*,doc_id_t,ib_vector_t*)" -> "dtuple_create(mem_heap_t*,ulint)"
"fts_add_doc_by_id(fts_trx_table_t*,doc_id_t,ib_vector_t*)" -> "pfs_rw_lock_x_lock_func(rw_lock_t*,ulint,const char*,ulint)"
"fts_add_doc_by_id(fts_trx_table_t*,doc_id_t,ib_vector_t*)" -> "dict_index_get_n_unique(const dict_index_t*)"
"fts_add_doc_by_id(fts_trx_table_t*,doc_id_t,ib_vector_t*)" -> "dict_table_is_comp(const dict_table_t*)"
"fts_add_doc_by_id(fts_trx_table_t*,doc_id_t,ib_vector_t*)" -> "btr_pcur_open_with_no_init_func(dict_index_t*,const dtuple_t*,ulint,ulint,btr_pcur_t*,ulint,const char*,ulint,mtr_t*)"
"fts_add_doc_by_id(fts_trx_table_t*,doc_id_t,ib_vector_t*)" -> "btr_pcur_close(btr_pcur_t*)"
"fts_add_doc_by_id(fts_trx_table_t*,doc_id_t,ib_vector_t*)" -> "ib_vector_size(const ib_vector_t*)"
"fts_add_doc_by_id(fts_trx_table_t*,doc_id_t,ib_vector_t*)" -> "btr_pcur_restore_position_func(ulint,btr_pcur_t*,const char*,ulint,mtr_t*)"
"fts_add_doc_by_id(fts_trx_table_t*,doc_id_t,ib_vector_t*)" -> "ib_vector_get(ib_vector_t*,ulint)"
"fts_add_doc_by_id(fts_trx_table_t*,doc_id_t,ib_vector_t*)" -> "dfield_set_data(dfield_t*,const void*,ulint)"
"fts_add_doc_by_id(fts_trx_table_t*,doc_id_t,ib_vector_t*)" -> "btr_pcur_store_position(btr_pcur_t*,mtr_t*)"
"fts_doc_init(fts_doc_t*)" -> "mem_heap_create_func(ulint,ulint)"
"fts_doc_init(fts_doc_t*)" -> "memset(void*,int,size_t)"
"fts_doc_init(fts_doc_t*)" -> "ib_heap_allocator_create(mem_heap_t*)"
"fts_sync(fts_sync_t*)" -> "pfs_mutex_enter_func(ib_mutex_t*,const char*,ulint)"
"fts_sync(fts_sync_t*)" -> "ib_vector_size(const ib_vector_t*)"
"fts_sync(fts_sync_t*)" -> "pfs_mutex_exit_func(ib_mutex_t*)"
"fts_sync(fts_sync_t*)" -> "ib_vector_get(ib_vector_t*,ulint)"
"fts_sync(fts_sync_t*)" -> "pfs_rw_lock_x_lock_func(rw_lock_t*,ulint,const char*,ulint)"
"fts_sync(fts_sync_t*)" -> "fts_sync_index(fts_sync_t*,fts_index_cache_t*)"
"fts_sync(fts_sync_t*)" -> "fts_sync_begin(fts_sync_t*)"
"fts_sync(fts_sync_t*)" -> "fts_sync_commit(fts_sync_t*)"
"fts_sync(fts_sync_t*)" -> "fts_sync_rollback(fts_sync_t*)"
"fts_sync_index(fts_sync_t*,fts_index_cache_t*)" -> "ib_logf(ib_log_level_t,const char*,...)"
"fts_sync_index(fts_sync_t*,fts_index_cache_t*)" -> "fts_sync_write_words(trx_t*,fts_index_cache_t*)"
"fts_sync_write_words(trx_t*,fts_index_cache_t*)" -> "fprintf(FILE*,const char*,...)"
"fts_sync_write_words(trx_t*,fts_index_cache_t*)" -> "fts_select_index(const CHARSET_INFO*,const unsigned char*,ulint)"
"fts_sync_write_words(trx_t*,fts_index_cache_t*)" -> "rbt_remove_node(ib_rbt_t*,const ib_rbt_node_t*)"
"fts_sync_write_words(trx_t*,fts_index_cache_t*)" -> "ut_free(void*)"
"fts_sync_write_words(trx_t*,fts_index_cache_t*)" -> "rbt_first(const ib_rbt_t*)"
"fts_sync_write_words(trx_t*,fts_index_cache_t*)" -> "ib_vector_size(const ib_vector_t*)"
"fts_sync_write_words(trx_t*,fts_index_cache_t*)" -> "ut_strerr(dberr_t)"
"fts_sync_write_words(trx_t*,fts_index_cache_t*)" -> "fts_write_node(trx_t*,que_t**,fts_table_t*,fts_string_t*,fts_node_t*)"
"fts_sync_write_words(trx_t*,fts_index_cache_t*)" -> "ib_vector_get(ib_vector_t*,ulint)"
"fts_sync_write_words(trx_t*,fts_index_cache_t*)" -> "fts_get_suffix(ulint)"
"fts_sync_write_words(trx_t*,fts_index_cache_t*)" -> "printf(const char*,...)"
"fts_sync_write_words(trx_t*,fts_index_cache_t*)" -> "ut_print_timestamp(FILE*)"
"fts_select_index(const CHARSET_INFO*,const unsigned char*,ulint)" -> "innobase_strnxfrm(const CHARSET_INFO*,const uchar*,ulint)"
"innobase_strnxfrm(const CHARSET_INFO*,const uchar*,ulint)" -> "mach_read_from_2(const unsigned char*)"
"fts_write_node(trx_t*,que_t**,fts_table_t*,fts_string_t*,fts_node_t*)" -> "__builtin_expect(long int,long int)"
"fts_write_node(trx_t*,que_t**,fts_table_t*,fts_string_t*,fts_node_t*)" -> "pars_info_bind_literal(pars_info_t*,const char*,const void*,ulint,ulint,ulint)"
"fts_write_node(trx_t*,que_t**,fts_table_t*,fts_string_t*,fts_node_t*)" -> "fts_parse_sql(fts_table_t*,pars_info_t*,const char*)"
"fts_write_node(trx_t*,que_t**,fts_table_t*,fts_string_t*,fts_node_t*)" -> "mach_write_to_8(void*,ib_uint64_t)"
"fts_write_node(trx_t*,que_t**,fts_table_t*,fts_string_t*,fts_node_t*)" -> "pars_info_bind_varchar_literal(pars_info_t*,const char*,const unsigned char*,ulint)"
"fts_write_node(trx_t*,que_t**,fts_table_t*,fts_string_t*,fts_node_t*)" -> "fts_eval_sql(trx_t*,que_t*)"
"fts_write_node(trx_t*,que_t**,fts_table_t*,fts_string_t*,fts_node_t*)" -> "pars_info_bind_int4_literal(pars_info_t*,const char*,const ib_uint32_t*)"
"fts_write_node(trx_t*,que_t**,fts_table_t*,fts_string_t*,fts_node_t*)" -> "pars_info_create()"
"fts_write_node(trx_t*,que_t**,fts_table_t*,fts_string_t*,fts_node_t*)" -> "ut_dbg_assertion_failed(const char*,const char*,ulint)"
"fts_write_node(trx_t*,que_t**,fts_table_t*,fts_string_t*,fts_node_t*)" -> "pars_info_bind_int8_literal(pars_info_t*,const char*,const ib_uint64_t*)"
"fts_write_node(trx_t*,que_t**,fts_table_t*,fts_string_t*,fts_node_t*)" -> "ut_time()"
"fts_write_node(trx_t*,que_t**,fts_table_t*,fts_string_t*,fts_node_t*)" -> "mach_write_to_4(unsigned char*,ulint)"
"fts_write_node(trx_t*,que_t**,fts_table_t*,fts_string_t*,fts_node_t*)" -> "abort()"
"pars_info_bind_literal(pars_info_t*,const char*,const void*,ulint,ulint,ulint)" -> "pars_info_lookup_bound_lit(pars_info_t*,const char*)"
"pars_info_bind_literal(pars_info_t*,const char*,const void*,ulint,ulint,ulint)" -> "sym_tab_rebind_lit(sym_node_t*,const void*,ulint)"
"pars_info_bind_literal(pars_info_t*,const char*,const void*,ulint,ulint,ulint)" -> "pars_info_add_literal(pars_info_t*,const char*,const void*,ulint,ulint,ulint)"
"pars_info_bind_int4_literal(pars_info_t*,const char*,const ib_uint32_t*)" -> "pars_info_add_literal(pars_info_t*,const char*,const void*,ulint,ulint,ulint)"
"pars_info_bind_int4_literal(pars_info_t*,const char*,const ib_uint32_t*)" -> "sym_tab_rebind_lit(sym_node_t*,const void*,ulint)"
"pars_info_bind_int4_literal(pars_info_t*,const char*,const ib_uint32_t*)" -> "pars_info_lookup_bound_lit(pars_info_t*,const char*)"
"fts_sync_begin(fts_sync_t*)" -> "trx_allocate_for_background()"
"fts_sync_begin(fts_sync_t*)" -> "ib_logf(ib_log_level_t,const char*,...)"
"fts_sync_begin(fts_sync_t*)" -> "ut_time()"
"fts_sync_begin(fts_sync_t*)" -> "ib_vector_size(const ib_vector_t*)"
"fts_sync_commit(fts_sync_t*)" -> "fts_cache_init(fts_cache_t*)"
"fts_sync_commit(fts_sync_t*)" -> "ut_print_timestamp(FILE*)"
"fts_sync_commit(fts_sync_t*)" -> "trx_free_for_background(trx_t*)"
"fts_sync_commit(fts_sync_t*)" -> "ut_time()"
"fts_sync_commit(fts_sync_t*)" -> "pfs_rw_lock_x_unlock_func(rw_lock_t*)"
"fts_sync_commit(fts_sync_t*)" -> "fts_sql_commit(trx_t*)"
"fts_sync_commit(fts_sync_t*)" -> "fts_sync_add_deleted_cache(fts_sync_t*,ib_vector_t*)"
"fts_sync_commit(fts_sync_t*)" -> "ut_strerr(dberr_t)"
"fts_sync_commit(fts_sync_t*)" -> "fprintf(FILE*,const char*,...)"
"fts_sync_commit(fts_sync_t*)" -> "fts_cache_clear(fts_cache_t*)"
"fts_sync_commit(fts_sync_t*)" -> "ib_logf(ib_log_level_t,const char*,...)"
"fts_sync_commit(fts_sync_t*)" -> "fts_cmp_set_sync_doc_id(const dict_table_t*,doc_id_t,ulint,doc_id_t*)"
"fts_sync_commit(fts_sync_t*)" -> "fts_sql_rollback(trx_t*)"
"fts_sync_commit(fts_sync_t*)" -> "ib_vector_size(const ib_vector_t*)"
"fts_sync_add_deleted_cache(fts_sync_t*,ib_vector_t*)" -> "ib_vector_size(const ib_vector_t*)"
"fts_sync_add_deleted_cache(fts_sync_t*,ib_vector_t*)" -> "ut_dbg_assertion_failed(const char*,const char*,ulint)"
"fts_sync_add_deleted_cache(fts_sync_t*,ib_vector_t*)" -> "pars_info_create()"
"fts_sync_add_deleted_cache(fts_sync_t*,ib_vector_t*)" -> "que_graph_free(que_t*)"
"fts_sync_add_deleted_cache(fts_sync_t*,ib_vector_t*)" -> "ib_vector_sort(ib_vector_t*,ib_compare_t)"
"fts_sync_add_deleted_cache(fts_sync_t*,ib_vector_t*)" -> "pars_info_bind_int8_literal(pars_info_t*,const char*,const ib_uint64_t*)"
"fts_sync_add_deleted_cache(fts_sync_t*,ib_vector_t*)" -> "fts_eval_sql(trx_t*,que_t*)"
"fts_sync_add_deleted_cache(fts_sync_t*,ib_vector_t*)" -> "pfs_mutex_exit_func(ib_mutex_t*)"
"fts_sync_add_deleted_cache(fts_sync_t*,ib_vector_t*)" -> "ib_vector_get(ib_vector_t*,ulint)"
"fts_sync_add_deleted_cache(fts_sync_t*,ib_vector_t*)" -> "mach_write_to_8(void*,ib_uint64_t)"
"fts_sync_add_deleted_cache(fts_sync_t*,ib_vector_t*)" -> "pfs_mutex_enter_func(ib_mutex_t*,const char*,ulint)"
"fts_sync_add_deleted_cache(fts_sync_t*,ib_vector_t*)" -> "abort()"
"fts_sync_add_deleted_cache(fts_sync_t*,ib_vector_t*)" -> "fts_parse_sql(fts_table_t*,pars_info_t*,const char*)"
"fts_sync_add_deleted_cache(fts_sync_t*,ib_vector_t*)" -> "__builtin_expect(long int,long int)"
"ib_vector_sort(ib_vector_t*,ib_compare_t)" -> "qsort(void*,size_t,size_t,__compar_fn_t)"
"fts_sync_rollback(fts_sync_t*)" -> "trx_free_for_background(trx_t*)"
"fts_sync_rollback(fts_sync_t*)" -> "fts_sql_rollback(trx_t*)"
"fts_sync_rollback(fts_sync_t*)" -> "pfs_rw_lock_x_unlock_func(rw_lock_t*)"
"row_build_row_ref_in_tuple(dtuple_t*,const rec_t*,const dict_index_t*,ulint*,trx_t*)" -> "rec_get_nth_field_offs(const ulint*,ulint,ulint*)"
"row_build_row_ref_in_tuple(dtuple_t*,const rec_t*,const dict_index_t*,ulint*,trx_t*)" -> "mem_heap_free_func(mem_heap_t*,const char*,ulint)"
"row_build_row_ref_in_tuple(dtuple_t*,const rec_t*,const dict_index_t*,ulint*,trx_t*)" -> "rec_offs_set_n_alloc(ulint*,ulint)"
"row_build_row_ref_in_tuple(dtuple_t*,const rec_t*,const dict_index_t*,ulint*,trx_t*)" -> "__builtin_expect(long int,long int)"
"row_build_row_ref_in_tuple(dtuple_t*,const rec_t*,const dict_index_t*,ulint*,trx_t*)" -> "ut_print_name(FILE*,const trx_t*,ulint,const char*)"
"row_build_row_ref_in_tuple(dtuple_t*,const rec_t*,const dict_index_t*,ulint*,trx_t*)" -> "dict_index_get_nth_field_pos(const dict_index_t*,const dict_index_t*,ulint)"
"row_build_row_ref_in_tuple(dtuple_t*,const rec_t*,const dict_index_t*,ulint*,trx_t*)" -> "ut_dbg_assertion_failed(const char*,const char*,ulint)"
"row_build_row_ref_in_tuple(dtuple_t*,const rec_t*,const dict_index_t*,ulint*,trx_t*)" -> "dtype_get_at_most_n_mbchars(ulint,ulint,ulint,ulint,const char*)"
"row_build_row_ref_in_tuple(dtuple_t*,const rec_t*,const dict_index_t*,ulint*,trx_t*)" -> "dict_index_get_n_unique(const dict_index_t*)"
"row_build_row_ref_in_tuple(dtuple_t*,const rec_t*,const dict_index_t*,ulint*,trx_t*)" -> "abort()"
"row_build_row_ref_in_tuple(dtuple_t*,const rec_t*,const dict_index_t*,ulint*,trx_t*)" -> "dfield_set_data(dfield_t*,const void*,ulint)"
"row_build_row_ref_in_tuple(dtuple_t*,const rec_t*,const dict_index_t*,ulint*,trx_t*)" -> "dfield_set_len(dfield_t*,ulint)"
"row_build_row_ref_in_tuple(dtuple_t*,const rec_t*,const dict_index_t*,ulint*,trx_t*)" -> "rec_get_offsets_func(const rec_t*,const dict_index_t*,ulint*,ulint,mem_heap_t**)"
"row_build_row_ref_in_tuple(dtuple_t*,const rec_t*,const dict_index_t*,ulint*,trx_t*)" -> "__builtin_fwrite(const void*,size_t,size_t,FILE*)"
"row_build_row_ref_in_tuple(dtuple_t*,const rec_t*,const dict_index_t*,ulint*,trx_t*)" -> "dict_index_copy_types(dtuple_t*,const dict_index_t*,ulint)"
"fts_doc_free(fts_doc_t*)" -> "rbt_free(ib_rbt_t*)"
"fts_doc_free(fts_doc_t*)" -> "mem_heap_free_func(mem_heap_t*,const char*,ulint)"
"fts_fetch_doc_from_rec(fts_get_doc_t*,dict_index_t*,btr_pcur_t*,ulint*,fts_doc_t*)" -> "dtype_get_charset_coll(ulint)"
"fts_fetch_doc_from_rec(fts_get_doc_t*,dict_index_t*,btr_pcur_t*,ulint*,fts_doc_t*)" -> "dict_index_get_n_fields(const dict_index_t*)"
"fts_fetch_doc_from_rec(fts_get_doc_t*,dict_index_t*,btr_pcur_t*,ulint*,fts_doc_t*)" -> "innobase_get_fts_charset(int,uint)"
"fts_fetch_doc_from_rec(fts_get_doc_t*,dict_index_t*,btr_pcur_t*,ulint*,fts_doc_t*)" -> "dict_field_get_col(const dict_field_t*)"
"fts_fetch_doc_from_rec(fts_get_doc_t*,dict_index_t*,btr_pcur_t*,ulint*,fts_doc_t*)" -> "rec_get_nth_field_offs(const ulint*,ulint,ulint*)"
"fts_fetch_doc_from_rec(fts_get_doc_t*,dict_index_t*,btr_pcur_t*,ulint*,fts_doc_t*)" -> "rec_offs_nth_extern(const ulint*,ulint)"
"fts_fetch_doc_from_rec(fts_get_doc_t*,dict_index_t*,btr_pcur_t*,ulint*,fts_doc_t*)" -> "fts_tokenize_document_next(fts_doc_t*,ulint,fts_doc_t*)"
"fts_fetch_doc_from_rec(fts_get_doc_t*,dict_index_t*,btr_pcur_t*,ulint*,fts_doc_t*)" -> "dict_col_get_clust_pos(const dict_col_t*,const dict_index_t*)"
"fts_fetch_doc_from_rec(fts_get_doc_t*,dict_index_t*,btr_pcur_t*,ulint*,fts_doc_t*)" -> "btr_rec_copy_externally_stored_field(const rec_t*,const ulint*,ulint,ulint,ulint*,mem_heap_t*)"
"fts_fetch_doc_from_rec(fts_get_doc_t*,dict_index_t*,btr_pcur_t*,ulint*,fts_doc_t*)" -> "fts_tokenize_document(fts_doc_t*,fts_doc_t*)"
"fts_fetch_doc_from_rec(fts_get_doc_t*,dict_index_t*,btr_pcur_t*,ulint*,fts_doc_t*)" -> "dict_table_zip_size(const dict_table_t*)"
"fts_tokenize_document_next(fts_doc_t*,ulint,fts_doc_t*)" -> "ut_dbg_assertion_failed(const char*,const char*,ulint)"
"fts_tokenize_document_next(fts_doc_t*,ulint,fts_doc_t*)" -> "abort()"
"fts_tokenize_document_next(fts_doc_t*,ulint,fts_doc_t*)" -> "fts_process_token(fts_doc_t*,fts_doc_t*,ulint,ulint)"
"fts_tokenize_document_next(fts_doc_t*,ulint,fts_doc_t*)" -> "__builtin_expect(long int,long int)"
"fts_process_token(fts_doc_t*,fts_doc_t*,ulint,ulint)" -> "rbt_add_node(ib_rbt_t*,ib_rbt_bound_t*,const void*)"
"fts_process_token(fts_doc_t*,fts_doc_t*,ulint,ulint)" -> "mem_heap_alloc(mem_heap_t*,ulint)"
"fts_process_token(fts_doc_t*,fts_doc_t*,ulint,ulint)" -> "__builtin_expect(long int,long int)"
"fts_process_token(fts_doc_t*,fts_doc_t*,ulint,ulint)" -> "innobase_mysql_fts_get_token(CHARSET_INFO*,const unsigned char*,const unsigned char*,fts_string_t*,ulint*)"
"fts_process_token(fts_doc_t*,fts_doc_t*,ulint,ulint)" -> "rbt_search(const ib_rbt_t*,ib_rbt_bound_t*,const void*)"
"fts_process_token(fts_doc_t*,fts_doc_t*,ulint,ulint)" -> "ib_vector_push(ib_vector_t*,const void*)"
"fts_process_token(fts_doc_t*,fts_doc_t*,ulint,ulint)" -> "ut_dbg_assertion_failed(const char*,const char*,ulint)"
"fts_process_token(fts_doc_t*,fts_doc_t*,ulint,ulint)" -> "ib_vector_create(ib_alloc_t*,ulint,ulint)"
"fts_process_token(fts_doc_t*,fts_doc_t*,ulint,ulint)" -> "abort()"
"fts_process_token(fts_doc_t*,fts_doc_t*,ulint,ulint)" -> "innobase_fts_casedn_str(CHARSET_INFO*,char*,size_t,char*,size_t)"
"innobase_mysql_fts_get_token(CHARSET_INFO*,const unsigned char*,const unsigned char*,fts_string_t*,ulint*)" -> "__builtin_expect(long int,long int)"
"innobase_mysql_fts_get_token(CHARSET_INFO*,const unsigned char*,const unsigned char*,fts_string_t*,ulint*)" -> "ut_dbg_assertion_failed(const char*,const char*,ulint)"
"innobase_mysql_fts_get_token(CHARSET_INFO*,const unsigned char*,const unsigned char*,fts_string_t*,ulint*)" -> "abort()"
"innobase_fts_casedn_str(CHARSET_INFO*,char*,size_t,char*,size_t)" -> "strlen(const char*)"
"innobase_fts_casedn_str(CHARSET_INFO*,char*,size_t,char*,size_t)" -> "memcpy(void*,const void*,size_t)"
"fts_tokenize_document(fts_doc_t*,fts_doc_t*)" -> "ut_dbg_assertion_failed(const char*,const char*,ulint)"
"fts_tokenize_document(fts_doc_t*,fts_doc_t*)" -> "rbt_create_arg_cmp(size_t,ib_rbt_arg_compare,void*)"
"fts_tokenize_document(fts_doc_t*,fts_doc_t*)" -> "fts_process_token(fts_doc_t*,fts_doc_t*,ulint,ulint)"
"fts_tokenize_document(fts_doc_t*,fts_doc_t*)" -> "__builtin_expect(long int,long int)"
"fts_tokenize_document(fts_doc_t*,fts_doc_t*)" -> "abort()"
"fts_cache_add_doc(fts_cache_t*,fts_index_cache_t*,doc_id_t,ib_rbt_t*)" -> "ut_dbg_assertion_failed(const char*,const char*,ulint)"
"fts_cache_add_doc(fts_cache_t*,fts_index_cache_t*,doc_id_t,ib_rbt_t*)" -> "ib_vector_push(ib_vector_t*,const void*)"
"fts_cache_add_doc(fts_cache_t*,fts_index_cache_t*,doc_id_t,ib_rbt_t*)" -> "ib_vector_size(const ib_vector_t*)"
"fts_cache_add_doc(fts_cache_t*,fts_index_cache_t*,doc_id_t,ib_rbt_t*)" -> "memset(void*,int,size_t)"
"fts_cache_add_doc(fts_cache_t*,fts_index_cache_t*,doc_id_t,ib_rbt_t*)" -> "ib_vector_last(ib_vector_t*)"
"fts_cache_add_doc(fts_cache_t*,fts_index_cache_t*,doc_id_t,ib_rbt_t*)" -> "rbt_first(const ib_rbt_t*)"
"fts_cache_add_doc(fts_cache_t*,fts_index_cache_t*,doc_id_t,ib_rbt_t*)" -> "fts_cache_node_add_positions(fts_cache_t*,fts_node_t*,doc_id_t,ib_vector_t*)"
"fts_cache_add_doc(fts_cache_t*,fts_index_cache_t*,doc_id_t,ib_rbt_t*)" -> "rbt_remove_node(ib_rbt_t*,const ib_rbt_node_t*)"
"fts_cache_add_doc(fts_cache_t*,fts_index_cache_t*,doc_id_t,ib_rbt_t*)" -> "fts_tokenizer_word_get(fts_cache_t*,fts_index_cache_t*,fts_string_t*)"
"fts_cache_add_doc(fts_cache_t*,fts_index_cache_t*,doc_id_t,ib_rbt_t*)" -> "abort()"
"fts_cache_add_doc(fts_cache_t*,fts_index_cache_t*,doc_id_t,ib_rbt_t*)" -> "ut_free(void*)"
"fts_cache_add_doc(fts_cache_t*,fts_index_cache_t*,doc_id_t,ib_rbt_t*)" -> "__builtin_expect(long int,long int)"
"fts_cache_node_add_positions(fts_cache_t*,fts_node_t*,doc_id_t,ib_vector_t*)" -> "ut_malloc_low(ulint,ulint)"
"fts_cache_node_add_positions(fts_cache_t*,fts_node_t*,doc_id_t,ib_vector_t*)" -> "__builtin_expect(long int,long int)"
"fts_cache_node_add_positions(fts_cache_t*,fts_node_t*,doc_id_t,ib_vector_t*)" -> "ib_vector_size(const ib_vector_t*)"
"fts_cache_node_add_positions(fts_cache_t*,fts_node_t*,doc_id_t,ib_vector_t*)" -> "abort()"
"fts_cache_node_add_positions(fts_cache_t*,fts_node_t*,doc_id_t,ib_vector_t*)" -> "ut_free(void*)"
"fts_cache_node_add_positions(fts_cache_t*,fts_node_t*,doc_id_t,ib_vector_t*)" -> "memcpy(void*,const void*,size_t)"
"fts_cache_node_add_positions(fts_cache_t*,fts_node_t*,doc_id_t,ib_vector_t*)" -> "ut_dbg_assertion_failed(const char*,const char*,ulint)"
"fts_cache_node_add_positions(fts_cache_t*,fts_node_t*,doc_id_t,ib_vector_t*)" -> "ib_vector_get(ib_vector_t*,ulint)"
"fts_cache_node_add_positions(fts_cache_t*,fts_node_t*,doc_id_t,ib_vector_t*)" -> "fts_encode_int(ulint,unsigned char*)"
"fts_cache_node_add_positions(fts_cache_t*,fts_node_t*,doc_id_t,ib_vector_t*)" -> "fts_get_encoded_len(ulint)"
"fts_tokenizer_word_get(fts_cache_t*,fts_index_cache_t*,fts_string_t*)" -> "rbt_add_node(ib_rbt_t*,ib_rbt_bound_t*,const void*)"
"fts_tokenizer_word_get(fts_cache_t*,fts_index_cache_t*,fts_string_t*)" -> "rbt_search(const ib_rbt_t*,ib_rbt_bound_t*,const void*)"
"fts_tokenizer_word_get(fts_cache_t*,fts_index_cache_t*,fts_string_t*)" -> "fts_utf8_string_dup(fts_string_t*,const fts_string_t*,mem_heap_t*)"
"fts_tokenizer_word_get(fts_cache_t*,fts_index_cache_t*,fts_string_t*)" -> "ib_vector_create(ib_alloc_t*,ulint,ulint)"
"fts_modify(fts_trx_table_t*,fts_trx_row_t*)" -> "ut_dbg_assertion_failed(const char*,const char*,ulint)"
"fts_modify(fts_trx_table_t*,fts_trx_row_t*)" -> "abort()"
"fts_modify(fts_trx_table_t*,fts_trx_row_t*)" -> "fts_add(fts_trx_table_t*,fts_trx_row_t*)"
"fts_modify(fts_trx_table_t*,fts_trx_row_t*)" -> "fts_delete(fts_trx_table_t*,fts_trx_row_t*)"
"fts_modify(fts_trx_table_t*,fts_trx_row_t*)" -> "__builtin_expect(long int,long int)"
"dict_stats_deinit(dict_table_t*)" -> "abort()"
"dict_stats_deinit(dict_table_t*)" -> "__builtin_expect(long int,long int)"
"dict_stats_deinit(dict_table_t*)" -> "dict_table_stats_unlock(dict_table_t*,ulint)"
"dict_stats_deinit(dict_table_t*)" -> "dict_table_stats_lock(dict_table_t*,ulint)"
"dict_stats_deinit(dict_table_t*)" -> "ut_dbg_assertion_failed(const char*,const char*,ulint)"
"page_zip_fields_decode(const unsigned char*,const unsigned char*,ulint*)" -> "page_zip_fields_free(dict_index_t*)"
"page_zip_fields_decode(const unsigned char*,const unsigned char*,ulint*)" -> "dict_mem_table_add_col(dict_table_t*,mem_heap_t*,const char*,ulint,ulint,ulint)"
"page_zip_fields_decode(const unsigned char*,const unsigned char*,ulint*)" -> "dict_index_add_col(dict_index_t*,const dict_table_t*,dict_col_t*,ulint)"
"page_zip_fields_decode(const unsigned char*,const unsigned char*,ulint*)" -> "__builtin_expect(long int,long int)"
"page_zip_fields_decode(const unsigned char*,const unsigned char*,ulint*)" -> "dict_mem_index_create(const char*,const char*,ulint,ulint,ulint)"
"page_zip_fields_decode(const unsigned char*,const unsigned char*,ulint*)" -> "dict_mem_table_create(const char*,ulint,ulint,ulint,ulint)"
"page_zip_dir_add_slot(page_zip_des_t*,ulint)" -> "page_zip_get_size(const page_zip_des_t*)"
"page_zip_dir_add_slot(page_zip_des_t*,ulint)" -> "page_dir_get_n_heap(const ib_page_t*)"
"page_zip_dir_add_slot(page_zip_des_t*,ulint)" -> "memmove(void*,const void*,size_t)"
"page_zip_dir_add_slot(page_zip_des_t*,ulint)" -> "page_is_leaf(const ib_page_t*)"
"page_zip_parse_compress(unsigned char*,unsigned char*,ib_page_t*,page_zip_des_t*)" -> "__builtin_expect(long int,long int)"
"page_zip_parse_compress(unsigned char*,unsigned char*,ib_page_t*,page_zip_des_t*)" -> "memset(void*,int,size_t)"
"page_zip_parse_compress(unsigned char*,unsigned char*,ib_page_t*,page_zip_des_t*)" -> "mach_read_from_2(const unsigned char*)"
"page_zip_parse_compress(unsigned char*,unsigned char*,ib_page_t*,page_zip_des_t*)" -> "page_zip_get_size(const page_zip_des_t*)"
"page_zip_parse_compress(unsigned char*,unsigned char*,ib_page_t*,page_zip_des_t*)" -> "memcpy(void*,const void*,size_t)"
"page_zip_parse_compress(unsigned char*,unsigned char*,ib_page_t*,page_zip_des_t*)" -> "page_zip_decompress(page_zip_des_t*,ib_page_t*,ulint)"
"fil_op_log_parse_or_replay(unsigned char*,unsigned char*,ulint,ulint,ulint)" -> "ut_dbg_assertion_failed(const char*,const char*,ulint)"
"fil_op_log_parse_or_replay(unsigned char*,unsigned char*,ulint,ulint,ulint)" -> "mach_read_from_2(const unsigned char*)"
"fil_op_log_parse_or_replay(unsigned char*,unsigned char*,ulint,ulint,ulint)" -> "fil_get_space_id_for_table(const char*)"
"fil_op_log_parse_or_replay(unsigned char*,unsigned char*,ulint,ulint,ulint)" -> "fil_tablespace_exists_in_mem(ulint)"
"fil_op_log_parse_or_replay(unsigned char*,unsigned char*,ulint,ulint,ulint)" -> "fil_delete_tablespace(ulint,buf_remove_t)"
"fil_op_log_parse_or_replay(unsigned char*,unsigned char*,ulint,ulint,ulint)" -> "fil_create_directory_for_tablename(const char*)"
"fil_op_log_parse_or_replay(unsigned char*,unsigned char*,ulint,ulint,ulint)" -> "fil_rename_tablespace(const char*,ulint,const char*,const char*)"
"fil_op_log_parse_or_replay(unsigned char*,unsigned char*,ulint,ulint,ulint)" -> "__builtin_expect(long int,long int)"
"fil_op_log_parse_or_replay(unsigned char*,unsigned char*,ulint,ulint,ulint)" -> "mach_read_from_4(const unsigned char*)"
"fil_op_log_parse_or_replay(unsigned char*,unsigned char*,ulint,ulint,ulint)" -> "fil_create_new_single_table_tablespace(ulint,const char*,const char*,ulint,ulint,ulint)"
"fil_op_log_parse_or_replay(unsigned char*,unsigned char*,ulint,ulint,ulint)" -> "abort()"
"fil_get_space_id_for_table(const char*)" -> "pfs_mutex_exit_func(ib_mutex_t*)"
"fil_get_space_id_for_table(const char*)" -> "fil_space_get_by_name(const char*)"
"fil_get_space_id_for_table(const char*)" -> "pfs_mutex_enter_func(ib_mutex_t*,const char*,ulint)"
"fil_tablespace_exists_in_mem(ulint)" -> "pfs_mutex_exit_func(ib_mutex_t*)"
"fil_tablespace_exists_in_mem(ulint)" -> "fil_space_get_by_id(ulint)"
"fil_tablespace_exists_in_mem(ulint)" -> "pfs_mutex_enter_func(ib_mutex_t*,const char*,ulint)"
"fil_create_directory_for_tablename(const char*)" -> "memcpy(void*,const void*,size_t)"
"fil_create_directory_for_tablename(const char*)" -> "ut_dbg_assertion_failed(const char*,const char*,ulint)"
"fil_create_directory_for_tablename(const char*)" -> "__builtin_expect(long int,long int)"
"fil_create_directory_for_tablename(const char*)" -> "mem_free_func(void*,const char*,ulint)"
"fil_create_directory_for_tablename(const char*)" -> "strchr(const char*,int)"
"fil_create_directory_for_tablename(const char*)" -> "abort()"
"fil_create_directory_for_tablename(const char*)" -> "os_file_create_directory(const char*,ulint)"
"fil_create_directory_for_tablename(const char*)" -> "strlen(const char*)"
"fil_create_directory_for_tablename(const char*)" -> "srv_normalize_path_for_win(char*)"
"fil_create_directory_for_tablename(const char*)" -> "mem_alloc_func(ulint,ulint*)"
"btr_parse_page_reorganize(unsigned char*,unsigned char*,dict_index_t*,bool,buf_block_t*,mtr_t*)" -> "mach_read_from_1(const unsigned char*)"
"btr_parse_page_reorganize(unsigned char*,unsigned char*,dict_index_t*,bool,buf_block_t*,mtr_t*)" -> "ut_dbg_assertion_failed(const char*,const char*,ulint)"
"btr_parse_page_reorganize(unsigned char*,unsigned char*,dict_index_t*,bool,buf_block_t*,mtr_t*)" -> "abort()"
"btr_parse_page_reorganize(unsigned char*,unsigned char*,dict_index_t*,bool,buf_block_t*,mtr_t*)" -> "btr_page_reorganize_block(bool,ulint,buf_block_t*,dict_index_t*,mtr_t*)"
"btr_parse_page_reorganize(unsigned char*,unsigned char*,dict_index_t*,bool,buf_block_t*,mtr_t*)" -> "__builtin_expect(long int,long int)"
"page_parse_create(unsigned char*,unsigned char*,ulint,buf_block_t*,mtr_t*)" -> "page_create(buf_block_t*,mtr_t*,ulint)"
"page_zip_parse_write_header(unsigned char*,unsigned char*,ib_page_t*,page_zip_des_t*)" -> "__builtin_expect(long int,long int)"
"page_zip_parse_write_header(unsigned char*,unsigned char*,ib_page_t*,page_zip_des_t*)" -> "memcpy(void*,const void*,size_t)"
"page_zip_parse_compress_no_data(unsigned char*,unsigned char*,ib_page_t*,page_zip_des_t*,dict_index_t*)" -> "page_zip_compress(page_zip_des_t*,const ib_page_t*,dict_index_t*,ulint,mtr_t*)"
"page_zip_parse_compress_no_data(unsigned char*,unsigned char*,ib_page_t*,page_zip_des_t*,dict_index_t*)" -> "ut_dbg_assertion_failed(const char*,const char*,ulint)"
"page_zip_parse_compress_no_data(unsigned char*,unsigned char*,ib_page_t*,page_zip_des_t*,dict_index_t*)" -> "mach_read_from_1(const unsigned char*)"
"page_zip_parse_compress_no_data(unsigned char*,unsigned char*,ib_page_t*,page_zip_des_t*,dict_index_t*)" -> "abort()"
"btr_parse_set_min_rec_mark(unsigned char*,unsigned char*,ulint,ib_page_t*,mtr_t*)" -> "ut_dbg_assertion_failed(const char*,const char*,ulint)"
"btr_parse_set_min_rec_mark(unsigned char*,unsigned char*,ulint,ib_page_t*,mtr_t*)" -> "__builtin_expect(long int,long int)"
"btr_parse_set_min_rec_mark(unsigned char*,unsigned char*,ulint,ib_page_t*,mtr_t*)" -> "page_is_comp(const ib_page_t*)"
"btr_parse_set_min_rec_mark(unsigned char*,unsigned char*,ulint,ib_page_t*,mtr_t*)" -> "mach_read_from_2(const unsigned char*)"
"btr_parse_set_min_rec_mark(unsigned char*,unsigned char*,ulint,ib_page_t*,mtr_t*)" -> "abort()"
"btr_parse_set_min_rec_mark(unsigned char*,unsigned char*,ulint,ib_page_t*,mtr_t*)" -> "btr_set_min_rec_mark(rec_t*,mtr_t*)"
"fsp_parse_init_file_page(unsigned char*,unsigned char*,buf_block_t*)" -> "fsp_init_file_page_low(buf_block_t*)"
"trx_undo_parse_discard_latest(unsigned char*,unsigned char*,ib_page_t*,mtr_t*)" -> "trx_undo_discard_latest_update_undo(ib_page_t*,mtr_t*)"
"trx_undo_discard_latest_update_undo(ib_page_t*,mtr_t*)" -> "mach_read_from_2(const unsigned char*)"
"trx_undo_discard_latest_update_undo(ib_page_t*,mtr_t*)" -> "mach_write_to_2(unsigned char*,ulint)"
"trx_undo_discard_latest_update_undo(ib_page_t*,mtr_t*)" -> "trx_undo_discard_latest_log(ib_page_t*,mtr_t*)"
"trx_undo_discard_latest_log(ib_page_t*,mtr_t*)" -> "mlog_write_initial_log_record(const unsigned char*,unsigned char,mtr_t*)"
"trx_undo_parse_page_header(ulint,unsigned char*,unsigned char*,ib_page_t*,mtr_t*)" -> "trx_undo_header_create(ib_page_t*,trx_id_t,mtr_t*)"
"trx_undo_parse_page_header(ulint,unsigned char*,unsigned char*,ib_page_t*,mtr_t*)" -> "trx_undo_insert_header_reuse(ib_page_t*,trx_id_t,mtr_t*)"
"trx_undo_parse_page_header(ulint,unsigned char*,unsigned char*,ib_page_t*,mtr_t*)" -> "mach_ull_parse_compressed(unsigned char*,unsigned char*,ib_uint64_t*)"
"mach_ull_parse_compressed(unsigned char*,unsigned char*,ib_uint64_t*)" -> "mach_get_compressed_size(ulint)"
"mach_ull_parse_compressed(unsigned char*,unsigned char*,ib_uint64_t*)" -> "mach_read_compressed(const unsigned char*)"
"mach_ull_parse_compressed(unsigned char*,unsigned char*,ib_uint64_t*)" -> "mach_read_from_4(const unsigned char*)"
"trx_undo_parse_page_init(unsigned char*,unsigned char*,ib_page_t*,mtr_t*)" -> "trx_undo_page_init(ib_page_t*,ulint,mtr_t*)"
"trx_undo_parse_page_init(unsigned char*,unsigned char*,ib_page_t*,mtr_t*)" -> "mach_parse_compressed(unsigned char*,unsigned char*,ulint*)"
"page_cur_parse_delete_rec(unsigned char*,unsigned char*,buf_block_t*,dict_index_t*,mtr_t*)" -> "rec_get_offsets_func(const rec_t*,const dict_index_t*,ulint*,ulint,mem_heap_t**)"
"page_cur_parse_delete_rec(unsigned char*,unsigned char*,buf_block_t*,dict_index_t*,mtr_t*)" -> "page_cur_delete_rec(page_cur_t*,const dict_index_t*,const ulint*,mtr_t*)"
"page_cur_parse_delete_rec(unsigned char*,unsigned char*,buf_block_t*,dict_index_t*,mtr_t*)" -> "abort()"
"page_cur_parse_delete_rec(unsigned char*,unsigned char*,buf_block_t*,dict_index_t*,mtr_t*)" -> "rec_offs_set_n_alloc(ulint*,ulint)"
"page_cur_parse_delete_rec(unsigned char*,unsigned char*,buf_block_t*,dict_index_t*,mtr_t*)" -> "page_cur_position(const rec_t*,const buf_block_t*,page_cur_t*)"
"page_cur_parse_delete_rec(unsigned char*,unsigned char*,buf_block_t*,dict_index_t*,mtr_t*)" -> "mem_heap_free_func(mem_heap_t*,const char*,ulint)"
"page_cur_parse_delete_rec(unsigned char*,unsigned char*,buf_block_t*,dict_index_t*,mtr_t*)" -> "__builtin_expect(long int,long int)"
"page_cur_parse_delete_rec(unsigned char*,unsigned char*,buf_block_t*,dict_index_t*,mtr_t*)" -> "ut_dbg_assertion_failed(const char*,const char*,ulint)"
"page_cur_parse_delete_rec(unsigned char*,unsigned char*,buf_block_t*,dict_index_t*,mtr_t*)" -> "mach_read_from_2(const unsigned char*)"
"mlog_parse_string(unsigned char*,unsigned char*,unsigned char*,void*)" -> "fil_page_get_type(const unsigned char*)"
"mlog_parse_string(unsigned char*,unsigned char*,unsigned char*,void*)" -> "memcpy(void*,const void*,size_t)"
"mlog_parse_string(unsigned char*,unsigned char*,unsigned char*,void*)" -> "abort()"
"mlog_parse_string(unsigned char*,unsigned char*,unsigned char*,void*)" -> "ut_dbg_assertion_failed(const char*,const char*,ulint)"
"mlog_parse_string(unsigned char*,unsigned char*,unsigned char*,void*)" -> "mach_read_from_2(const unsigned char*)"
"mlog_parse_string(unsigned char*,unsigned char*,unsigned char*,void*)" -> "__builtin_expect(long int,long int)"
"mlog_parse_nbytes(ulint,unsigned char*,unsigned char*,unsigned char*,void*)" -> "mach_write_to_1(unsigned char*,ulint)"
"mlog_parse_nbytes(ulint,unsigned char*,unsigned char*,unsigned char*,void*)" -> "fil_page_get_type(const unsigned char*)"
"mlog_parse_nbytes(ulint,unsigned char*,unsigned char*,unsigned char*,void*)" -> "mach_write_to_8(void*,ib_uint64_t)"
"mlog_parse_nbytes(ulint,unsigned char*,unsigned char*,unsigned char*,void*)" -> "mach_read_from_2(const unsigned char*)"
"mlog_parse_nbytes(ulint,unsigned char*,unsigned char*,unsigned char*,void*)" -> "ut_dbg_assertion_failed(const char*,const char*,ulint)"
"mlog_parse_nbytes(ulint,unsigned char*,unsigned char*,unsigned char*,void*)" -> "__builtin_expect(long int,long int)"
"mlog_parse_nbytes(ulint,unsigned char*,unsigned char*,unsigned char*,void*)" -> "abort()"
"mlog_parse_nbytes(ulint,unsigned char*,unsigned char*,unsigned char*,void*)" -> "mach_parse_compressed(unsigned char*,unsigned char*,ulint*)"
"mlog_parse_nbytes(ulint,unsigned char*,unsigned char*,unsigned char*,void*)" -> "mach_ull_parse_compressed(unsigned char*,unsigned char*,ib_uint64_t*)"
"mlog_parse_nbytes(ulint,unsigned char*,unsigned char*,unsigned char*,void*)" -> "mach_write_to_4(unsigned char*,ulint)"
"mlog_parse_nbytes(ulint,unsigned char*,unsigned char*,unsigned char*,void*)" -> "mach_write_to_2(unsigned char*,ulint)"
"btr_cur_parse_del_mark_set_sec_rec(unsigned char*,unsigned char*,ib_page_t*,page_zip_des_t*)" -> "ut_dbg_assertion_failed(const char*,const char*,ulint)"
"btr_cur_parse_del_mark_set_sec_rec(unsigned char*,unsigned char*,ib_page_t*,page_zip_des_t*)" -> "abort()"
"btr_cur_parse_del_mark_set_sec_rec(unsigned char*,unsigned char*,ib_page_t*,page_zip_des_t*)" -> "mach_read_from_1(const unsigned char*)"
"btr_cur_parse_del_mark_set_sec_rec(unsigned char*,unsigned char*,ib_page_t*,page_zip_des_t*)" -> "__builtin_expect(long int,long int)"
"btr_cur_parse_del_mark_set_sec_rec(unsigned char*,unsigned char*,ib_page_t*,page_zip_des_t*)" -> "mach_read_from_2(const unsigned char*)"
"btr_cur_parse_del_mark_set_sec_rec(unsigned char*,unsigned char*,ib_page_t*,page_zip_des_t*)" -> "btr_rec_set_deleted_flag(rec_t*,page_zip_des_t*,ulint)"
"page_zip_parse_write_blob_ptr(unsigned char*,unsigned char*,ib_page_t*,page_zip_des_t*)" -> "__builtin_expect(long int,long int)"
"page_zip_parse_write_blob_ptr(unsigned char*,unsigned char*,ib_page_t*,page_zip_des_t*)" -> "mach_read_from_2(const unsigned char*)"
"page_zip_parse_write_blob_ptr(unsigned char*,unsigned char*,ib_page_t*,page_zip_des_t*)" -> "memcpy(void*,const void*,size_t)"
"page_zip_parse_write_blob_ptr(unsigned char*,unsigned char*,ib_page_t*,page_zip_des_t*)" -> "page_is_leaf(const ib_page_t*)"
"page_zip_parse_write_node_ptr(unsigned char*,unsigned char*,ib_page_t*,page_zip_des_t*)" -> "page_zip_dir_start_offs(const page_zip_des_t*,ulint)"
"page_zip_parse_write_node_ptr(unsigned char*,unsigned char*,ib_page_t*,page_zip_des_t*)" -> "mach_read_from_2(const unsigned char*)"
"page_zip_parse_write_node_ptr(unsigned char*,unsigned char*,ib_page_t*,page_zip_des_t*)" -> "page_is_leaf(const ib_page_t*)"
"page_zip_parse_write_node_ptr(unsigned char*,unsigned char*,ib_page_t*,page_zip_des_t*)" -> "__builtin_expect(long int,long int)"
"page_zip_parse_write_node_ptr(unsigned char*,unsigned char*,ib_page_t*,page_zip_des_t*)" -> "memcpy(void*,const void*,size_t)"
"page_zip_parse_write_node_ptr(unsigned char*,unsigned char*,ib_page_t*,page_zip_des_t*)" -> "page_dir_get_n_heap(const ib_page_t*)"
"page_zip_parse_write_node_ptr(unsigned char*,unsigned char*,ib_page_t*,page_zip_des_t*)" -> "page_zip_dir_elems(const page_zip_des_t*)"
"ibuf_parse_bitmap_init(unsigned char*,unsigned char*,buf_block_t*,mtr_t*)" -> "ibuf_bitmap_page_init(buf_block_t*,mtr_t*)"
"trx_undo_parse_erase_page_end(unsigned char*,unsigned char*,ib_page_t*,mtr_t*)" -> "trx_undo_erase_page_end(ib_page_t*,mtr_t*)"
"btr_cur_parse_update_in_place(unsigned char*,unsigned char*,ib_page_t*,page_zip_des_t*,dict_index_t*)" -> "mach_read_from_2(const unsigned char*)"
"btr_cur_parse_update_in_place(unsigned char*,unsigned char*,ib_page_t*,page_zip_des_t*,dict_index_t*)" -> "mem_heap_create_func(ulint,ulint)"
"btr_cur_parse_update_in_place(unsigned char*,unsigned char*,ib_page_t*,page_zip_des_t*,dict_index_t*)" -> "row_upd_index_parse(unsigned char*,unsigned char*,mem_heap_t*,upd_t**)"
"btr_cur_parse_update_in_place(unsigned char*,unsigned char*,ib_page_t*,page_zip_des_t*,dict_index_t*)" -> "rec_get_offsets_func(const rec_t*,const dict_index_t*,ulint*,ulint,mem_heap_t**)"
"btr_cur_parse_update_in_place(unsigned char*,unsigned char*,ib_page_t*,page_zip_des_t*,dict_index_t*)" -> "mem_heap_free_func(mem_heap_t*,const char*,ulint)"
"btr_cur_parse_update_in_place(unsigned char*,unsigned char*,ib_page_t*,page_zip_des_t*,dict_index_t*)" -> "abort()"
"btr_cur_parse_update_in_place(unsigned char*,unsigned char*,ib_page_t*,page_zip_des_t*,dict_index_t*)" -> "__builtin_expect(long int,long int)"
"btr_cur_parse_update_in_place(unsigned char*,unsigned char*,ib_page_t*,page_zip_des_t*,dict_index_t*)" -> "row_upd_parse_sys_vals(unsigned char*,unsigned char*,ulint*,trx_id_t*,roll_ptr_t*)"
"btr_cur_parse_update_in_place(unsigned char*,unsigned char*,ib_page_t*,page_zip_des_t*,dict_index_t*)" -> "dict_table_is_comp(const dict_table_t*)"
"btr_cur_parse_update_in_place(unsigned char*,unsigned char*,ib_page_t*,page_zip_des_t*,dict_index_t*)" -> "page_is_comp(const ib_page_t*)"
"btr_cur_parse_update_in_place(unsigned char*,unsigned char*,ib_page_t*,page_zip_des_t*,dict_index_t*)" -> "row_upd_rec_in_place(rec_t*,dict_index_t*,const ulint*,const upd_t*,page_zip_des_t*)"
"btr_cur_parse_update_in_place(unsigned char*,unsigned char*,ib_page_t*,page_zip_des_t*,dict_index_t*)" -> "row_upd_rec_sys_fields_in_recovery(rec_t*,page_zip_des_t*,const ulint*,ulint,trx_id_t,roll_ptr_t)"
"btr_cur_parse_update_in_place(unsigned char*,unsigned char*,ib_page_t*,page_zip_des_t*,dict_index_t*)" -> "ut_dbg_assertion_failed(const char*,const char*,ulint)"
"btr_cur_parse_update_in_place(unsigned char*,unsigned char*,ib_page_t*,page_zip_des_t*,dict_index_t*)" -> "mach_read_from_1(const unsigned char*)"
"row_upd_index_parse(unsigned char*,unsigned char*,mem_heap_t*,upd_t**)" -> "mem_heap_dup(mem_heap_t*,const void*,ulint)"
"row_upd_index_parse(unsigned char*,unsigned char*,mem_heap_t*,upd_t**)" -> "mach_parse_compressed(unsigned char*,unsigned char*,ulint*)"
"row_upd_index_parse(unsigned char*,unsigned char*,mem_heap_t*,upd_t**)" -> "dfield_set_null(dfield_t*)"
"row_upd_index_parse(unsigned char*,unsigned char*,mem_heap_t*,upd_t**)" -> "upd_create(ulint,mem_heap_t*)"
"row_upd_index_parse(unsigned char*,unsigned char*,mem_heap_t*,upd_t**)" -> "dfield_set_data(dfield_t*,const void*,ulint)"
"row_upd_index_parse(unsigned char*,unsigned char*,mem_heap_t*,upd_t**)" -> "mach_read_from_1(const unsigned char*)"
"row_upd_parse_sys_vals(unsigned char*,unsigned char*,ulint*,trx_id_t*,roll_ptr_t*)" -> "trx_read_roll_ptr(const unsigned char*)"
"row_upd_parse_sys_vals(unsigned char*,unsigned char*,ulint*,trx_id_t*,roll_ptr_t*)" -> "mach_parse_compressed(unsigned char*,unsigned char*,ulint*)"
"row_upd_parse_sys_vals(unsigned char*,unsigned char*,ulint*,trx_id_t*,roll_ptr_t*)" -> "mach_ull_parse_compressed(unsigned char*,unsigned char*,ib_uint64_t*)"
"row_upd_rec_sys_fields_in_recovery(rec_t*,page_zip_des_t*,const ulint*,ulint,trx_id_t,roll_ptr_t)" -> "trx_write_trx_id(unsigned char*,trx_id_t)"
"row_upd_rec_sys_fields_in_recovery(rec_t*,page_zip_des_t*,const ulint*,ulint,trx_id_t,roll_ptr_t)" -> "trx_write_roll_ptr(unsigned char*,roll_ptr_t)"
"row_upd_rec_sys_fields_in_recovery(rec_t*,page_zip_des_t*,const ulint*,ulint,trx_id_t,roll_ptr_t)" -> "rec_get_nth_field_offs(const ulint*,ulint,ulint*)"
"row_upd_rec_sys_fields_in_recovery(rec_t*,page_zip_des_t*,const ulint*,ulint,trx_id_t,roll_ptr_t)" -> "page_zip_write_trx_id_and_roll_ptr(page_zip_des_t*,unsigned char*,const ulint*,ulint,trx_id_t,roll_ptr_t)"
"mlog_parse_index(unsigned char*,const unsigned char*,ulint,dict_index_t**)" -> "dict_index_add_col(dict_index_t*,const dict_table_t*,dict_col_t*,ulint)"
"mlog_parse_index(unsigned char*,const unsigned char*,ulint,dict_index_t**)" -> "dict_mem_index_create(const char*,const char*,ulint,ulint,ulint)"
"mlog_parse_index(unsigned char*,const unsigned char*,ulint,dict_index_t**)" -> "dict_index_get_nth_col(const dict_index_t*,ulint)"
"mlog_parse_index(unsigned char*,const unsigned char*,ulint,dict_index_t**)" -> "dict_table_add_system_columns(dict_table_t*,mem_heap_t*)"
"mlog_parse_index(unsigned char*,const unsigned char*,ulint,dict_index_t**)" -> "mach_read_from_2(const unsigned char*)"
"mlog_parse_index(unsigned char*,const unsigned char*,ulint,dict_index_t**)" -> "abort()"
"mlog_parse_index(unsigned char*,const unsigned char*,ulint,dict_index_t**)" -> "__builtin_expect(long int,long int)"
"mlog_parse_index(unsigned char*,const unsigned char*,ulint,dict_index_t**)" -> "dict_mem_table_create(const char*,ulint,ulint,ulint,ulint)"
"mlog_parse_index(unsigned char*,const unsigned char*,ulint,dict_index_t**)" -> "dict_mem_table_add_col(dict_table_t*,mem_heap_t*,const char*,ulint,ulint,ulint)"
"mlog_parse_index(unsigned char*,const unsigned char*,ulint,dict_index_t**)" -> "ut_dbg_assertion_failed(const char*,const char*,ulint)"
"btr_cur_parse_del_mark_set_clust_rec(unsigned char*,unsigned char*,ib_page_t*,page_zip_des_t*,dict_index_t*)" -> "ut_dbg_assertion_failed(const char*,const char*,ulint)"
"btr_cur_parse_del_mark_set_clust_rec(unsigned char*,unsigned char*,ib_page_t*,page_zip_des_t*,dict_index_t*)" -> "mach_read_from_2(const unsigned char*)"
"btr_cur_parse_del_mark_set_clust_rec(unsigned char*,unsigned char*,ib_page_t*,page_zip_des_t*,dict_index_t*)" -> "btr_rec_set_deleted_flag(rec_t*,page_zip_des_t*,ulint)"
"btr_cur_parse_del_mark_set_clust_rec(unsigned char*,unsigned char*,ib_page_t*,page_zip_des_t*,dict_index_t*)" -> "rec_offs_set_n_alloc(ulint*,ulint)"
"btr_cur_parse_del_mark_set_clust_rec(unsigned char*,unsigned char*,ib_page_t*,page_zip_des_t*,dict_index_t*)" -> "mach_read_from_1(const unsigned char*)"
"btr_cur_parse_del_mark_set_clust_rec(unsigned char*,unsigned char*,ib_page_t*,page_zip_des_t*,dict_index_t*)" -> "rec_get_offsets_func(const rec_t*,const dict_index_t*,ulint*,ulint,mem_heap_t**)"
"btr_cur_parse_del_mark_set_clust_rec(unsigned char*,unsigned char*,ib_page_t*,page_zip_des_t*,dict_index_t*)" -> "row_upd_parse_sys_vals(unsigned char*,unsigned char*,ulint*,trx_id_t*,roll_ptr_t*)"
"btr_cur_parse_del_mark_set_clust_rec(unsigned char*,unsigned char*,ib_page_t*,page_zip_des_t*,dict_index_t*)" -> "abort()"
"btr_cur_parse_del_mark_set_clust_rec(unsigned char*,unsigned char*,ib_page_t*,page_zip_des_t*,dict_index_t*)" -> "mem_heap_free_func(mem_heap_t*,const char*,ulint)"
"btr_cur_parse_del_mark_set_clust_rec(unsigned char*,unsigned char*,ib_page_t*,page_zip_des_t*,dict_index_t*)" -> "row_upd_rec_sys_fields_in_recovery(rec_t*,page_zip_des_t*,const ulint*,ulint,trx_id_t,roll_ptr_t)"
"btr_cur_parse_del_mark_set_clust_rec(unsigned char*,unsigned char*,ib_page_t*,page_zip_des_t*,dict_index_t*)" -> "__builtin_expect(long int,long int)"
"page_parse_delete_rec_list(unsigned char,unsigned char*,unsigned char*,buf_block_t*,dict_index_t*,mtr_t*)" -> "mach_read_from_2(const unsigned char*)"
"page_parse_delete_rec_list(unsigned char,unsigned char*,unsigned char*,buf_block_t*,dict_index_t*,mtr_t*)" -> "page_delete_rec_list_start(rec_t*,buf_block_t*,dict_index_t*,mtr_t*)"
"page_parse_delete_rec_list(unsigned char,unsigned char*,unsigned char*,buf_block_t*,dict_index_t*,mtr_t*)" -> "page_delete_rec_list_end(rec_t*,buf_block_t*,dict_index_t*,ulint,ulint,mtr_t*)"
"trx_undo_parse_add_undo_rec(unsigned char*,unsigned char*,ib_page_t*)" -> "ut_memcpy(void*,const void*,ulint)"
"trx_undo_parse_add_undo_rec(unsigned char*,unsigned char*,ib_page_t*)" -> "mach_write_to_2(unsigned char*,ulint)"
"trx_undo_parse_add_undo_rec(unsigned char*,unsigned char*,ib_page_t*)" -> "mach_read_from_2(const unsigned char*)"
"buf_page_get_newest_modification(const buf_page_t*)" -> "buf_page_in_file(const buf_page_t*)"
"buf_page_get_newest_modification(const buf_page_t*)" -> "buf_page_get_mutex(const buf_page_t*)"
"buf_page_get_newest_modification(const buf_page_t*)" -> "pfs_mutex_enter_func(ib_mutex_t*,const char*,ulint)"
"buf_page_get_newest_modification(const buf_page_t*)" -> "pfs_mutex_exit_func(ib_mutex_t*)"
"recv_data_copy_to_buf(unsigned char*,recv_t*)" -> "ut_memcpy(void*,const void*,ulint)"
"buf_mark_space_corrupt(buf_page_t*)" -> "buf_LRU_free_one_page(buf_page_t*)"
"buf_mark_space_corrupt(buf_page_t*)" -> "dict_set_corrupted_by_space(ulint)"
"buf_mark_space_corrupt(buf_page_t*)" -> "pfs_mutex_enter_func(ib_mutex_t*,const char*,ulint)"
"buf_mark_space_corrupt(buf_page_t*)" -> "buf_pool_from_bpage(const buf_page_t*)"
"buf_mark_space_corrupt(buf_page_t*)" -> "buf_page_get_mutex(const buf_page_t*)"
"buf_mark_space_corrupt(buf_page_t*)" -> "buf_page_set_io_fix(buf_page_t*,buf_io_fix)"
"buf_mark_space_corrupt(buf_page_t*)" -> "buf_page_get_state(const buf_page_t*)"
"buf_mark_space_corrupt(buf_page_t*)" -> "pfs_mutex_exit_func(ib_mutex_t*)"
"buf_mark_space_corrupt(buf_page_t*)" -> "pfs_rw_lock_x_unlock_func(rw_lock_t*)"
"dict_set_corrupted_by_space(ulint)" -> "dict_find_table_by_space(ulint)"
"buf_zip_decompress(buf_block_t*,ulint)" -> "__builtin_expect(long int,long int)"
"buf_zip_decompress(buf_block_t*,ulint)" -> "mach_read_from_4(const unsigned char*)"
"buf_zip_decompress(buf_block_t*,ulint)" -> "ut_dbg_assertion_failed(const char*,const char*,ulint)"
"buf_zip_decompress(buf_block_t*,ulint)" -> "page_zip_get_size(const page_zip_des_t*)"
"buf_zip_decompress(buf_block_t*,ulint)" -> "buf_block_get_space(const buf_block_t*)"
"buf_zip_decompress(buf_block_t*,ulint)" -> "abort()"
"buf_zip_decompress(buf_block_t*,ulint)" -> "buf_block_get_zip_size(const buf_block_t*)"
"buf_zip_decompress(buf_block_t*,ulint)" -> "fil_page_get_type(const unsigned char*)"
"buf_zip_decompress(buf_block_t*,ulint)" -> "fprintf(FILE*,const char*,...)"
"buf_zip_decompress(buf_block_t*,ulint)" -> "page_zip_decompress(page_zip_des_t*,ib_page_t*,ulint)"
"buf_zip_decompress(buf_block_t*,ulint)" -> "memcpy(void*,const void*,size_t)"
"buf_zip_decompress(buf_block_t*,ulint)" -> "ut_print_timestamp(FILE*)"
"buf_zip_decompress(buf_block_t*,ulint)" -> "page_zip_calc_checksum(const void*,ulint,srv_checksum_algorithm_t)"
"buf_zip_decompress(buf_block_t*,ulint)" -> "page_zip_verify_checksum(const void*,ulint)"
"buf_page_monitor(const buf_page_t*,buf_io_fix)" -> "fil_page_get_type(const unsigned char*)"
"buf_page_monitor(const buf_page_t*,buf_io_fix)" -> "abort()"
"buf_page_monitor(const buf_page_t*,buf_io_fix)" -> "ut_dbg_assertion_failed(const char*,const char*,ulint)"
"buf_page_monitor(const buf_page_t*,buf_io_fix)" -> "__builtin_expect(long int,long int)"
"buf_page_monitor(const buf_page_t*,buf_io_fix)" -> "btr_page_get_level_low(const ib_page_t*)"
"buf_page_monitor(const buf_page_t*,buf_io_fix)" -> "btr_page_get_index_id(const ib_page_t*)"
"buf_flush_write_complete(buf_page_t*)" -> "os_event_set(os_event_t)"
"buf_flush_write_complete(buf_page_t*)" -> "buf_pool_from_bpage(const buf_page_t*)"
"buf_flush_write_complete(buf_page_t*)" -> "buf_dblwr_update(const buf_page_t*,buf_flush_t)"
"buf_flush_write_complete(buf_page_t*)" -> "buf_flush_remove(buf_page_t*)"
"buf_flush_write_complete(buf_page_t*)" -> "buf_page_get_flush_type(const buf_page_t*)"
"buf_dblwr_update(const buf_page_t*,buf_flush_t)" -> "abort()"
"buf_dblwr_update(const buf_page_t*,buf_flush_t)" -> "fil_flush_file_spaces(ulint)"
"buf_dblwr_update(const buf_page_t*,buf_flush_t)" -> "ut_dbg_assertion_failed(const char*,const char*,ulint)"
"buf_dblwr_update(const buf_page_t*,buf_flush_t)" -> "os_event_set(os_event_t)"
"buf_dblwr_update(const buf_page_t*,buf_flush_t)" -> "pfs_mutex_exit_func(ib_mutex_t*)"
"buf_dblwr_update(const buf_page_t*,buf_flush_t)" -> "__builtin_expect(long int,long int)"
"buf_dblwr_update(const buf_page_t*,buf_flush_t)" -> "pfs_mutex_enter_func(ib_mutex_t*,const char*,ulint)"
"buf_dblwr_add_to_batch(buf_page_t*)" -> "ut_dbg_assertion_failed(const char*,const char*,ulint)"
"buf_dblwr_add_to_batch(buf_page_t*)" -> "buf_page_get_zip_size(const buf_page_t*)"
"buf_dblwr_add_to_batch(buf_page_t*)" -> "memcpy(void*,const void*,size_t)"
"buf_dblwr_add_to_batch(buf_page_t*)" -> "pfs_mutex_enter_func(ib_mutex_t*,const char*,ulint)"
"buf_dblwr_add_to_batch(buf_page_t*)" -> "memset(void*,int,size_t)"
"buf_dblwr_add_to_batch(buf_page_t*)" -> "pfs_mutex_exit_func(ib_mutex_t*)"
"buf_dblwr_add_to_batch(buf_page_t*)" -> "os_event_reset(os_event_t)"
"buf_dblwr_add_to_batch(buf_page_t*)" -> "buf_page_in_file(const buf_page_t*)"
"buf_dblwr_add_to_batch(buf_page_t*)" -> "abort()"
"buf_dblwr_add_to_batch(buf_page_t*)" -> "buf_dblwr_flush_buffered_writes()"
"buf_dblwr_add_to_batch(buf_page_t*)" -> "os_event_wait_low(os_event_t,ib_int64_t)"
"buf_dblwr_add_to_batch(buf_page_t*)" -> "buf_page_get_state(const buf_page_t*)"
"buf_dblwr_add_to_batch(buf_page_t*)" -> "__builtin_expect(long int,long int)"
"buf_dblwr_write_single_page(buf_page_t*,bool)" -> "buf_dblwr_check_page_lsn(const ib_page_t*)"
"buf_dblwr_write_single_page(buf_page_t*,bool)" -> "memset(void*,int,size_t)"
"buf_dblwr_write_single_page(buf_page_t*,bool)" -> "buf_dblwr_write_block_to_datafile(const buf_page_t*,bool)"
"buf_dblwr_write_single_page(buf_page_t*,bool)" -> "os_event_wait_low(os_event_t,ib_int64_t)"
"buf_dblwr_write_single_page(buf_page_t*,bool)" -> "fil_io(ulint,bool,ulint,ulint,ulint,ulint,ulint,void*,void*)"
"buf_dblwr_write_single_page(buf_page_t*,bool)" -> "fil_flush(ulint)"
"buf_dblwr_write_single_page(buf_page_t*,bool)" -> "abort()"
"buf_dblwr_write_single_page(buf_page_t*,bool)" -> "buf_page_get_state(const buf_page_t*)"
"buf_dblwr_write_single_page(buf_page_t*,bool)" -> "Indexer>::inc() [with Type = long unsigned int,int N = 1,Indexer = single_indexer_t]"
"buf_dblwr_write_single_page(buf_page_t*,bool)" -> "__builtin_expect(long int,long int)"
"buf_dblwr_write_single_page(buf_page_t*,bool)" -> "buf_page_in_file(const buf_page_t*)"
"buf_dblwr_write_single_page(buf_page_t*,bool)" -> "pfs_mutex_enter_func(ib_mutex_t*,const char*,ulint)"
"buf_dblwr_write_single_page(buf_page_t*,bool)" -> "pfs_mutex_exit_func(ib_mutex_t*)"
"buf_dblwr_write_single_page(buf_page_t*,bool)" -> "ut_dbg_assertion_failed(const char*,const char*,ulint)"
"buf_dblwr_write_single_page(buf_page_t*,bool)" -> "buf_page_get_zip_size(const buf_page_t*)"
"buf_dblwr_write_single_page(buf_page_t*,bool)" -> "buf_dblwr_check_block(const buf_block_t*)"
"buf_dblwr_write_single_page(buf_page_t*,bool)" -> "memcpy(void*,const void*,size_t)"
"buf_dblwr_write_single_page(buf_page_t*,bool)" -> "os_event_reset(os_event_t)"
"mem_area_alloc(ulint*,mem_pool_t*)" -> "mem_pool_fill_free_list(ulint,mem_pool_t*)"
"mem_area_alloc(ulint*,mem_pool_t*)" -> "ut_malloc_low(ulint,ulint)"
"mem_area_alloc(ulint*,mem_pool_t*)" -> "pfs_mutex_exit_func(ib_mutex_t*)"
"mem_area_alloc(ulint*,mem_pool_t*)" -> "__builtin_expect(long int,long int)"
"mem_area_alloc(ulint*,mem_pool_t*)" -> "ut_2_log(ulint)"
"mem_area_alloc(ulint*,mem_pool_t*)" -> "fprintf(FILE*,const char*,...)"
"mem_area_alloc(ulint*,mem_pool_t*)" -> "abort()"
"mem_area_alloc(ulint*,mem_pool_t*)" -> "ut_list_remove(List&,Type&,size_t) [with List = ut_list_base<mem_area_t>,Type = mem_area_t,size_t = long unsigned int]"
"mem_area_alloc(ulint*,mem_pool_t*)" -> "ut_dbg_assertion_failed(const char*,const char*,ulint)"
"mem_area_alloc(ulint*,mem_pool_t*)" -> "ut_2_exp(ulint)"
"mem_area_alloc(ulint*,mem_pool_t*)" -> "mem_area_set_free(mem_area_t*,ulint)"
"mem_area_alloc(ulint*,mem_pool_t*)" -> "malloc(size_t)"
"mem_area_alloc(ulint*,mem_pool_t*)" -> "__builtin_fwrite(const void*,size_t,size_t,FILE*)"
"mem_area_alloc(ulint*,mem_pool_t*)" -> "mem_area_get_size(mem_area_t*)"
"mem_area_alloc(ulint*,mem_pool_t*)" -> "ut_max(ulint,ulint)"
"mem_area_alloc(ulint*,mem_pool_t*)" -> "mem_analyze_corruption(void*)"
"mem_area_alloc(ulint*,mem_pool_t*)" -> "mem_area_get_free(mem_area_t*)"
"mem_area_alloc(ulint*,mem_pool_t*)" -> "pfs_mutex_enter_func(ib_mutex_t*,const char*,ulint)"
"mem_pool_fill_free_list(ulint,mem_pool_t*)" -> "ut_list_remove(List&,Type&,size_t) [with List = ut_list_base<mem_area_t>,Type = mem_area_t,size_t = long unsigned int]"
"mem_pool_fill_free_list(ulint,mem_pool_t*)" -> "ut_list_prepend(List&,Type&,size_t) [with List = ut_list_base<mem_area_t>,Type = mem_area_t,size_t = long unsigned int]"
"mem_pool_fill_free_list(ulint,mem_pool_t*)" -> "mem_analyze_corruption(void*)"
"mem_pool_fill_free_list(ulint,mem_pool_t*)" -> "mem_pool_fill_free_list(ulint,mem_pool_t*)"
"mem_pool_fill_free_list(ulint,mem_pool_t*)" -> "ut_dbg_assertion_failed(const char*,const char*,ulint)"
"mem_pool_fill_free_list(ulint,mem_pool_t*)" -> "mem_area_set_size(mem_area_t*,ulint)"
"mem_pool_fill_free_list(ulint,mem_pool_t*)" -> "ut_print_timestamp(FILE*)"
"mem_pool_fill_free_list(ulint,mem_pool_t*)" -> "abort()"
"mem_pool_fill_free_list(ulint,mem_pool_t*)" -> "ut_2_exp(ulint)"
"mem_pool_fill_free_list(ulint,mem_pool_t*)" -> "__builtin_expect(long int,long int)"
"mem_pool_fill_free_list(ulint,mem_pool_t*)" -> "mem_area_set_free(mem_area_t*,ulint)"
"mem_pool_fill_free_list(ulint,mem_pool_t*)" -> "fprintf(FILE*,const char*,...)"
"ut_list_insert(List&,Type&,Type&,size_t) [with List = ut_list_base<mem_block_info_t>,Type = mem_block_info_t,size_t = long unsigned int]" -> "ut_elem_get_node(Type&,size_t) [with Type = mem_block_info_t,size_t = long unsigned int]"
"ut_list_prepend(List&,Type&,size_t) [with List = ut_list_base<dyn_block_t>,Type = dyn_block_t,size_t = long unsigned int]" -> "ut_elem_get_node(Type&,size_t) [with Type = dyn_block_t,size_t = long unsigned int]"
"ut_elem_get_node(Type&,size_t) [with Type = dyn_block_t,size_t = long unsigned int]" -> "__builtin_expect(long int,long int)"
"ut_elem_get_node(Type&,size_t) [with Type = dyn_block_t,size_t = long unsigned int]" -> "ut_dbg_assertion_failed(const char*,const char*,ulint)"
"ut_elem_get_node(Type&,size_t) [with Type = dyn_block_t,size_t = long unsigned int]" -> "abort()"
"ut_list_append(List&,Type&,size_t) [with List = ut_list_base<dyn_block_t>,Type = dyn_block_t,size_t = long unsigned int]" -> "ut_elem_get_node(Type&,size_t) [with Type = dyn_block_t,size_t = long unsigned int]"
"log_reserve_and_open(ulint)" -> "log_buffer_extend(ulint)"
"log_reserve_and_open(ulint)" -> "pfs_mutex_enter_func(ib_mutex_t*,const char*,ulint)"
"log_reserve_and_open(ulint)" -> "os_thread_sleep(ulint)"
"log_reserve_and_open(ulint)" -> "Indexer>::inc() [with Type = long unsigned int,int N = 1,Indexer = single_indexer_t]"
"log_reserve_and_open(ulint)" -> "log_buffer_flush_to_disk()"
"log_reserve_and_open(ulint)" -> "pfs_mutex_exit_func(ib_mutex_t*)"
"log_reserve_and_open(ulint)" -> "ib_logf(ib_log_level_t,const char*,...)"
"log_buffer_extend(ulint)" -> "log_buffer_flush_to_disk()"
"log_buffer_extend(ulint)" -> "pfs_mutex_enter_func(ib_mutex_t*,const char*,ulint)"
"log_buffer_extend(ulint)" -> "pfs_mutex_exit_func(ib_mutex_t*)"
"log_buffer_extend(ulint)" -> "ut_memcpy(void*,const void*,ulint)"
"log_buffer_extend(ulint)" -> "memset(void*,int,size_t)"
"log_buffer_extend(ulint)" -> "mem_free_func(void*,const char*,ulint)"
"log_buffer_extend(ulint)" -> "mem_alloc_func(ulint,ulint*)"
"log_buffer_extend(ulint)" -> "ut_align(const void*,ulint)"
"log_buffer_extend(ulint)" -> "ib_logf(ib_log_level_t,const char*,...)"
"log_buffer_flush_to_disk()" -> "log_write_up_to(lsn_t,ulint,ulint)"
"log_buffer_flush_to_disk()" -> "pfs_mutex_exit_func(ib_mutex_t*)"
"log_buffer_flush_to_disk()" -> "pfs_mutex_enter_func(ib_mutex_t*,const char*,ulint)"
"mtr_add_dirtied_pages_to_flush_list(mtr_t*)" -> "log_release()"
"mtr_add_dirtied_pages_to_flush_list(mtr_t*)" -> "pfs_mutex_exit_func(ib_mutex_t*)"
"mtr_add_dirtied_pages_to_flush_list(mtr_t*)" -> "mtr_memo_note_modifications(mtr_t*)"
"mtr_add_dirtied_pages_to_flush_list(mtr_t*)" -> "pfs_mutex_enter_func(ib_mutex_t*,const char*,ulint)"
"log_release()" -> "pfs_mutex_exit_func(ib_mutex_t*)"
"mtr_memo_note_modifications(mtr_t*)" -> "mtr_memo_slot_note_modification(mtr_t*,mtr_memo_slot_t*)"
"mtr_memo_note_modifications(mtr_t*)" -> "dyn_block_get_used(const dyn_block_t*)"
"mtr_memo_note_modifications(mtr_t*)" -> "dyn_block_get_data(const dyn_block_t*)"
"mtr_memo_slot_note_modification(mtr_t*,mtr_memo_slot_t*)" -> "buf_flush_note_modification(buf_block_t*,mtr_t*)"
"buf_flush_note_modification(buf_block_t*,mtr_t*)" -> "ut_dbg_assertion_failed(const char*,const char*,ulint)"
"buf_flush_note_modification(buf_block_t*,mtr_t*)" -> "__builtin_expect(long int,long int)"
"buf_flush_note_modification(buf_block_t*,mtr_t*)" -> "pfs_mutex_enter_func(ib_mutex_t*,const char*,ulint)"
"buf_flush_note_modification(buf_block_t*,mtr_t*)" -> "buf_pool_from_block(const buf_block_t*)"
"buf_flush_note_modification(buf_block_t*,mtr_t*)" -> "buf_flush_insert_into_flush_list(buf_pool_t*,buf_block_t*,lsn_t)"
"buf_flush_note_modification(buf_block_t*,mtr_t*)" -> "Indexer>::inc() [with Type = long unsigned int,int N = 1,Indexer = single_indexer_t]"
"buf_flush_note_modification(buf_block_t*,mtr_t*)" -> "pfs_mutex_exit_func(ib_mutex_t*)"
"buf_flush_note_modification(buf_block_t*,mtr_t*)" -> "abort()"
"buf_flush_insert_into_flush_list(buf_pool_t*,buf_block_t*,lsn_t)" -> "ut_list_prepend(List&,Type&,size_t) [with List = ut_list_base<buf_page_t>,Type = buf_page_t,size_t = long unsigned int]"
"buf_flush_insert_into_flush_list(buf_pool_t*,buf_block_t*,lsn_t)" -> "pfs_mutex_exit_func(ib_mutex_t*)"
"buf_flush_insert_into_flush_list(buf_pool_t*,buf_block_t*,lsn_t)" -> "incr_flush_list_size_in_bytes(buf_block_t*,buf_pool_t*)"
"buf_flush_insert_into_flush_list(buf_pool_t*,buf_block_t*,lsn_t)" -> "buf_flush_insert_sorted_into_flush_list(buf_pool_t*,buf_block_t*,lsn_t)"
"buf_flush_insert_into_flush_list(buf_pool_t*,buf_block_t*,lsn_t)" -> "__builtin_expect(long int,long int)"
"buf_flush_insert_into_flush_list(buf_pool_t*,buf_block_t*,lsn_t)" -> "pfs_mutex_enter_func(ib_mutex_t*,const char*,ulint)"
"log_close()" -> "log_block_get_first_rec_group(const unsigned char*)"
"log_close()" -> "fprintf(FILE*,const char*,...)"
"log_close()" -> "buf_pool_get_oldest_modification()"
"log_close()" -> "log_block_set_first_rec_group(unsigned char*,ulint)"
"log_close()" -> "log_block_get_data_len(const unsigned char*)"
"log_close()" -> "time(time_t*)"
"log_close()" -> "ut_align_down(const void*,ulint)"
"log_close()" -> "ut_print_timestamp(FILE*)"
"log_close()" -> "difftime(time_t,time_t)"
"log_block_get_first_rec_group(const unsigned char*)" -> "mach_read_from_2(const unsigned char*)"
"log_block_set_first_rec_group(unsigned char*,ulint)" -> "mach_write_to_2(unsigned char*,ulint)"
"log_block_get_data_len(const unsigned char*)" -> "mach_read_from_2(const unsigned char*)"
"log_write_low(unsigned char*,ulint)" -> "Indexer>::inc() [with Type = long unsigned int,int N = 1,Indexer = single_indexer_t]"
"log_write_low(unsigned char*,ulint)" -> "ut_memcpy(void*,const void*,ulint)"
"log_write_low(unsigned char*,ulint)" -> "log_block_init(unsigned char*,lsn_t)"
"log_write_low(unsigned char*,ulint)" -> "ut_align_down(const void*,ulint)"
"log_write_low(unsigned char*,ulint)" -> "log_block_set_data_len(unsigned char*,ulint)"
"log_write_low(unsigned char*,ulint)" -> "log_block_set_checkpoint_no(unsigned char*,ib_uint64_t)"
"log_block_init(unsigned char*,lsn_t)" -> "log_block_set_data_len(unsigned char*,ulint)"
"log_block_init(unsigned char*,lsn_t)" -> "log_block_set_hdr_no(unsigned char*,ulint)"
"log_block_init(unsigned char*,lsn_t)" -> "log_block_convert_lsn_to_no(lsn_t)"
"log_block_init(unsigned char*,lsn_t)" -> "log_block_set_first_rec_group(unsigned char*,ulint)"
"log_block_set_data_len(unsigned char*,ulint)" -> "mach_write_to_2(unsigned char*,ulint)"
"log_block_set_hdr_no(unsigned char*,ulint)" -> "mach_write_to_4(unsigned char*,ulint)"
"log_reserve_and_write_fast(const void*,ulint,lsn_t*)" -> "pfs_mutex_exit_func(ib_mutex_t*)"
"log_reserve_and_write_fast(const void*,ulint,lsn_t*)" -> "ut_align_down(const void*,ulint)"
"log_reserve_and_write_fast(const void*,ulint,lsn_t*)" -> "pfs_mutex_enter_func(ib_mutex_t*,const char*,ulint)"
"log_reserve_and_write_fast(const void*,ulint,lsn_t*)" -> "memcpy(void*,const void*,size_t)"
"log_reserve_and_write_fast(const void*,ulint,lsn_t*)" -> "log_block_set_data_len(unsigned char*,ulint)"
"mtr_memo_pop_all(mtr_t*)" -> "dyn_block_get_data(const dyn_block_t*)"
"mtr_memo_pop_all(mtr_t*)" -> "mtr_memo_slot_release_func(mtr_memo_slot_t*)"
"mtr_memo_pop_all(mtr_t*)" -> "dyn_block_get_used(const dyn_block_t*)"
"dyn_array_free(dyn_array_t*)" -> "mem_heap_free_func(mem_heap_t*,const char*,ulint)"
"fil_report_invalid_page_access(ulint,ulint,const char*,ulint,ulint,ulint)" -> "fprintf(FILE*,const char*,...)"
"buf_page_init_for_read(dberr_t*,ulint,ulint,ulint,ulint,ib_int64_t,ulint)" -> "hash_get_nth_cell(hash_table_t*,ulint)"
"buf_page_init_for_read(dberr_t*,ulint,ulint,ulint,ulint,ib_int64_t,ulint)" -> "page_zip_des_init(page_zip_des_t*)"
"buf_page_init_for_read(dberr_t*,ulint,ulint,ulint,ulint,ib_int64_t,ulint)" -> "buf_page_address_fold(ulint,ulint)"
"buf_page_init_for_read(dberr_t*,ulint,ulint,ulint,ulint,ib_int64_t,ulint)" -> "buf_pool_get(ulint,ulint)"
"buf_page_init_for_read(dberr_t*,ulint,ulint,ulint,ulint,ib_int64_t,ulint)" -> "ibuf_page_low(ulint,ulint,ulint,const char*,ulint,mtr_t*)"
"buf_page_init_for_read(dberr_t*,ulint,ulint,ulint,ulint,ib_int64_t,ulint)" -> "buf_LRU_block_free_non_file_page(buf_block_t*)"
"buf_page_init_for_read(dberr_t*,ulint,ulint,ulint,ulint,ib_int64_t,ulint)" -> "buf_buddy_free(buf_pool_t*,void*,ulint)"
"buf_page_init_for_read(dberr_t*,ulint,ulint,ulint,ulint,ib_int64_t,ulint)" -> "buf_page_set_io_fix(buf_page_t*,buf_io_fix)"
"buf_page_init_for_read(dberr_t*,ulint,ulint,ulint,ulint,ib_int64_t,ulint)" -> "hash_get_lock(hash_table_t*,ulint)"
"buf_page_init_for_read(dberr_t*,ulint,ulint,ulint,ulint,ib_int64_t,ulint)" -> "buf_LRU_get_free_block(buf_pool_t*)"
"buf_page_init_for_read(dberr_t*,ulint,ulint,ulint,ulint,ib_int64_t,ulint)" -> "__builtin_expect(long int,long int)"
"buf_page_init_for_read(dberr_t*,ulint,ulint,ulint,ulint,ib_int64_t,ulint)" -> "buf_page_alloc_descriptor()"
"buf_page_init_for_read(dberr_t*,ulint,ulint,ulint,ulint,ib_int64_t,ulint)" -> "buf_page_init(buf_pool_t*,ulint,ulint,ulint,ulint,buf_block_t*)"
"buf_page_init_for_read(dberr_t*,ulint,ulint,ulint,ulint,ib_int64_t,ulint)" -> "buf_pool_index(const buf_pool_t*)"
"buf_page_init_for_read(dberr_t*,ulint,ulint,ulint,ulint,ib_int64_t,ulint)" -> "__sync_add_and_fetch_4(volatile void*,unsigned int)"
"buf_page_init_for_read(dberr_t*,ulint,ulint,ulint,ulint,ib_int64_t,ulint)" -> "buf_pool_watch_is_sentinel(buf_pool_t*,const buf_page_t*)"
"buf_page_init_for_read(dberr_t*,ulint,ulint,ulint,ulint,ib_int64_t,ulint)" -> "ibuf_mtr_commit(mtr_t*)"
"buf_page_init_for_read(dberr_t*,ulint,ulint,ulint,ulint,ib_int64_t,ulint)" -> "buf_pool_watch_remove(buf_pool_t*,ulint,buf_page_t*)"
"buf_page_init_for_read(dberr_t*,ulint,ulint,ulint,ulint,ib_int64_t,ulint)" -> "pfs_rw_lock_x_lock_func(rw_lock_t*,ulint,const char*,ulint)"
"buf_page_init_for_read(dberr_t*,ulint,ulint,ulint,ulint,ib_int64_t,ulint)" -> "buf_page_init_low(buf_page_t*)"
"buf_page_init_for_read(dberr_t*,ulint,ulint,ulint,ulint,ib_int64_t,ulint)" -> "pfs_rw_lock_x_unlock_func(rw_lock_t*)"
"buf_page_init_for_read(dberr_t*,ulint,ulint,ulint,ulint,ib_int64_t,ulint)" -> "ibuf_mtr_start(mtr_t*)"
"buf_page_init_for_read(dberr_t*,ulint,ulint,ulint,ulint,ib_int64_t,ulint)" -> "fil_tablespace_deleted_or_being_deleted_in_mem(ulint,ib_int64_t)"
"buf_page_init_for_read(dberr_t*,ulint,ulint,ulint,ulint,ib_int64_t,ulint)" -> "recv_recovery_is_on()"
"buf_page_init_for_read(dberr_t*,ulint,ulint,ulint,ulint,ib_int64_t,ulint)" -> "pfs_mutex_exit_func(ib_mutex_t*)"
"buf_page_init_for_read(dberr_t*,ulint,ulint,ulint,ulint,ib_int64_t,ulint)" -> "buf_page_hash_get_low(buf_pool_t*,ulint,ulint,ulint)"
"buf_page_init_for_read(dberr_t*,ulint,ulint,ulint,ulint,ib_int64_t,ulint)" -> "buf_unzip_LRU_add_block(buf_block_t*,ulint)"
"buf_page_init_for_read(dberr_t*,ulint,ulint,ulint,ulint,ib_int64_t,ulint)" -> "pfs_mutex_enter_func(ib_mutex_t*,const char*,ulint)"
"buf_page_init_for_read(dberr_t*,ulint,ulint,ulint,ulint,ib_int64_t,ulint)" -> "abort()"
"buf_page_init_for_read(dberr_t*,ulint,ulint,ulint,ulint,ib_int64_t,ulint)" -> "buf_LRU_add_block(buf_page_t*,ulint)"
"buf_page_init_for_read(dberr_t*,ulint,ulint,ulint,ulint,ib_int64_t,ulint)" -> "page_zip_set_size(page_zip_des_t*,ulint)"
"buf_page_init_for_read(dberr_t*,ulint,ulint,ulint,ulint,ib_int64_t,ulint)" -> "buf_buddy_alloc(buf_pool_t*,ulint,ulint*)"
"buf_page_init_for_read(dberr_t*,ulint,ulint,ulint,ulint,ib_int64_t,ulint)" -> "ut_dbg_assertion_failed(const char*,const char*,ulint)"
"buf_page_init_for_read(dberr_t*,ulint,ulint,ulint,ulint,ib_int64_t,ulint)" -> "hash_calc_hash(ulint,hash_table_t*)"
"page_zip_des_init(page_zip_des_t*)" -> "memset(void*,int,size_t)"
"fil_tablespace_deleted_or_being_deleted_in_mem(ulint,ib_int64_t)" -> "fil_space_get_by_id(ulint)"
"fil_tablespace_deleted_or_being_deleted_in_mem(ulint,ib_int64_t)" -> "pfs_mutex_exit_func(ib_mutex_t*)"
"fil_tablespace_deleted_or_being_deleted_in_mem(ulint,ib_int64_t)" -> "pfs_mutex_enter_func(ib_mutex_t*,const char*,ulint)"
"buf_relocate(buf_page_t*,buf_page_t*)" -> "memcpy(void*,const void*,size_t)"
"buf_relocate(buf_page_t*,buf_page_t*)" -> "hash_get_nth_cell(hash_table_t*,ulint)"
"buf_relocate(buf_page_t*,buf_page_t*)" -> "ut_list_prepend(List&,Type&,size_t) [with List = ut_list_base<buf_page_t>,Type = buf_page_t,size_t = long unsigned int]"
"buf_relocate(buf_page_t*,buf_page_t*)" -> "abort()"
"buf_relocate(buf_page_t*,buf_page_t*)" -> "buf_pool_from_bpage(const buf_page_t*)"
"buf_relocate(buf_page_t*,buf_page_t*)" -> "buf_page_get_io_fix(const buf_page_t*)"
"buf_relocate(buf_page_t*,buf_page_t*)" -> "ut_dbg_assertion_failed(const char*,const char*,ulint)"
"buf_relocate(buf_page_t*,buf_page_t*)" -> "buf_page_address_fold(ulint,ulint)"
"buf_relocate(buf_page_t*,buf_page_t*)" -> "ut_list_insert(List&,Type&,Type&,size_t) [with List = ut_list_base<buf_page_t>,Type = buf_page_t,size_t = long unsigned int]"
"buf_relocate(buf_page_t*,buf_page_t*)" -> "hash_calc_hash(ulint,hash_table_t*)"
"buf_relocate(buf_page_t*,buf_page_t*)" -> "__builtin_expect(long int,long int)"
"buf_relocate(buf_page_t*,buf_page_t*)" -> "ut_list_remove(List&,Type&,size_t) [with List = ut_list_base<buf_page_t>,Type = buf_page_t,size_t = long unsigned int]"
"buf_wait_for_read(buf_block_t*)" -> "pfs_rw_lock_s_lock_func(rw_lock_t*,ulint,const char*,ulint)"
"buf_wait_for_read(buf_block_t*)" -> "pfs_mutex_exit_func(ib_mutex_t*)"
"buf_wait_for_read(buf_block_t*)" -> "buf_page_get_mutex(const buf_page_t*)"
"buf_wait_for_read(buf_block_t*)" -> "buf_block_get_io_fix(const buf_block_t*)"
"buf_wait_for_read(buf_block_t*)" -> "pfs_mutex_enter_func(ib_mutex_t*,const char*,ulint)"
"buf_wait_for_read(buf_block_t*)" -> "pfs_rw_lock_s_unlock_func(rw_lock_t*)"
"buf_block_get_io_fix(const buf_block_t*)" -> "buf_page_get_io_fix(const buf_page_t*)"
"dtuple_contains_null(const dtuple_t*)" -> "dfield_is_null(const dfield_t*)"
"dtuple_contains_null(const dtuple_t*)" -> "dtuple_get_n_fields(const dtuple_t*)"
"row_sel_build_prev_vers_for_mysql(read_view_t*,dict_index_t*,row_prebuilt_t*,const rec_t*,ulint**,mem_heap_t**,rec_t**,mtr_t*)" -> "mem_heap_empty(mem_heap_t*)"
"row_sel_build_prev_vers_for_mysql(read_view_t*,dict_index_t*,row_prebuilt_t*,const rec_t*,ulint**,mem_heap_t**,rec_t**,mtr_t*)" -> "mem_heap_create_func(ulint,ulint)"
"row_sel_build_prev_vers_for_mysql(read_view_t*,dict_index_t*,row_prebuilt_t*,const rec_t*,ulint**,mem_heap_t**,rec_t**,mtr_t*)" -> "row_vers_build_for_consistent_read(const rec_t*,mtr_t*,dict_index_t*,ulint**,read_view_t*,mem_heap_t**,mem_heap_t*,rec_t**)"
"row_sel_build_committed_vers_for_mysql(dict_index_t*,row_prebuilt_t*,const rec_t*,ulint**,mem_heap_t**,const rec_t**,mtr_t*)" -> "mem_heap_create_func(ulint,ulint)"
"row_sel_build_committed_vers_for_mysql(dict_index_t*,row_prebuilt_t*,const rec_t*,ulint**,mem_heap_t**,const rec_t**,mtr_t*)" -> "mem_heap_empty(mem_heap_t*)"
"row_sel_build_committed_vers_for_mysql(dict_index_t*,row_prebuilt_t*,const rec_t*,ulint**,mem_heap_t**,const rec_t**,mtr_t*)" -> "row_vers_build_for_semi_consistent_read(const rec_t*,mtr_t*,dict_index_t*,ulint**,mem_heap_t**,mem_heap_t*,const rec_t**)"
"row_sel_build_committed_vers_for_mysql(dict_index_t*,row_prebuilt_t*,const rec_t*,ulint**,mem_heap_t**,const rec_t**,mtr_t*)" -> "rec_offs_size(const ulint*)"
"row_vers_build_for_semi_consistent_read(const rec_t*,mtr_t*,dict_index_t*,ulint**,mem_heap_t**,mem_heap_t*,const rec_t**)" -> "trx_state_eq(const trx_t*,trx_state_t)"
"row_vers_build_for_semi_consistent_read(const rec_t*,mtr_t*,dict_index_t*,ulint**,mem_heap_t**,mem_heap_t*,const rec_t**)" -> "pfs_mutex_enter_func(ib_mutex_t*,const char*,ulint)"
"row_vers_build_for_semi_consistent_read(const rec_t*,mtr_t*,dict_index_t*,ulint**,mem_heap_t**,mem_heap_t*,const rec_t**)" -> "pfs_mutex_exit_func(ib_mutex_t*)"
"row_vers_build_for_semi_consistent_read(const rec_t*,mtr_t*,dict_index_t*,ulint**,mem_heap_t**,mem_heap_t*,const rec_t**)" -> "row_get_rec_trx_id(const rec_t*,const dict_index_t*,const ulint*)"
"row_vers_build_for_semi_consistent_read(const rec_t*,mtr_t*,dict_index_t*,ulint**,mem_heap_t**,mem_heap_t*,const rec_t**)" -> "mem_heap_free_func(mem_heap_t*,const char*,ulint)"
"row_vers_build_for_semi_consistent_read(const rec_t*,mtr_t*,dict_index_t*,ulint**,mem_heap_t**,mem_heap_t*,const rec_t**)" -> "trx_get_rw_trx_by_id(trx_id_t)"
"row_vers_build_for_semi_consistent_read(const rec_t*,mtr_t*,dict_index_t*,ulint**,mem_heap_t**,mem_heap_t*,const rec_t**)" -> "rec_get_offsets_func(const rec_t*,const dict_index_t*,ulint*,ulint,mem_heap_t**)"
"row_vers_build_for_semi_consistent_read(const rec_t*,mtr_t*,dict_index_t*,ulint**,mem_heap_t**,mem_heap_t*,const rec_t**)" -> "mem_heap_alloc(mem_heap_t*,ulint)"
"row_vers_build_for_semi_consistent_read(const rec_t*,mtr_t*,dict_index_t*,ulint**,mem_heap_t**,mem_heap_t*,const rec_t**)" -> "rec_copy(void*,const rec_t*,const ulint*)"
"row_vers_build_for_semi_consistent_read(const rec_t*,mtr_t*,dict_index_t*,ulint**,mem_heap_t**,mem_heap_t*,const rec_t**)" -> "trx_undo_prev_version_build(const rec_t*,mtr_t*,const rec_t*,dict_index_t*,ulint*,mem_heap_t*,rec_t**)"
"row_vers_build_for_semi_consistent_read(const rec_t*,mtr_t*,dict_index_t*,ulint**,mem_heap_t**,mem_heap_t*,const rec_t**)" -> "mem_heap_create_func(ulint,ulint)"
"row_vers_build_for_semi_consistent_read(const rec_t*,mtr_t*,dict_index_t*,ulint**,mem_heap_t**,mem_heap_t*,const rec_t**)" -> "rec_offs_size(const ulint*)"
"row_sel_store_row_id_to_prebuilt(row_prebuilt_t*,const rec_t*,const dict_index_t*,const ulint*)" -> "__builtin_expect(long int,long int)"
"row_sel_store_row_id_to_prebuilt(row_prebuilt_t*,const rec_t*,const dict_index_t*,const ulint*)" -> "rec_print_new(FILE*,const rec_t*,const ulint*)"
"row_sel_store_row_id_to_prebuilt(row_prebuilt_t*,const rec_t*,const dict_index_t*,const ulint*)" -> "ut_memcpy(void*,const void*,ulint)"
"row_sel_store_row_id_to_prebuilt(row_prebuilt_t*,const rec_t*,const dict_index_t*,const ulint*)" -> "rec_get_nth_field_offs(const ulint*,ulint,ulint*)"
"row_sel_store_row_id_to_prebuilt(row_prebuilt_t*,const rec_t*,const dict_index_t*,const ulint*)" -> "putc(int,FILE*)"
"row_sel_store_row_id_to_prebuilt(row_prebuilt_t*,const rec_t*,const dict_index_t*,const ulint*)" -> "dict_index_get_sys_col_pos(const dict_index_t*,ulint)"
"row_sel_store_row_id_to_prebuilt(row_prebuilt_t*,const rec_t*,const dict_index_t*,const ulint*)" -> "abort()"
"row_sel_store_row_id_to_prebuilt(row_prebuilt_t*,const rec_t*,const dict_index_t*,const ulint*)" -> "dict_index_name_print(FILE*,const trx_t*,const dict_index_t*)"
"row_sel_store_row_id_to_prebuilt(row_prebuilt_t*,const rec_t*,const dict_index_t*,const ulint*)" -> "ut_dbg_assertion_failed(const char*,const char*,ulint)"
"row_sel_store_row_id_to_prebuilt(row_prebuilt_t*,const rec_t*,const dict_index_t*,const ulint*)" -> "fprintf(FILE*,const char*,...)"
"lock_trx_handle_wait(trx_t*)" -> "pfs_mutex_enter_func(ib_mutex_t*,const char*,ulint)"
"lock_trx_handle_wait(trx_t*)" -> "pfs_mutex_exit_func(ib_mutex_t*)"
"lock_trx_handle_wait(trx_t*)" -> "lock_cancel_waiting_and_release(ib_lock_t*)"
"btr_index_rec_validate(const rec_t*,const dict_index_t*,ulint)" -> "__builtin_fwrite(const void*,size_t,size_t,FILE*)"
"btr_index_rec_validate(const rec_t*,const dict_index_t*,ulint)" -> "rec_get_n_fields_old(const rec_t*)"
"btr_index_rec_validate(const rec_t*,const dict_index_t*,ulint)" -> "mem_heap_free_func(mem_heap_t*,const char*,ulint)"
"btr_index_rec_validate(const rec_t*,const dict_index_t*,ulint)" -> "fprintf(FILE*,const char*,...)"
"btr_index_rec_validate(const rec_t*,const dict_index_t*,ulint)" -> "dict_col_get_fixed_size(const dict_col_t*,ulint)"
"btr_index_rec_validate(const rec_t*,const dict_index_t*,ulint)" -> "rec_print_old(FILE*,const rec_t*)"
"btr_index_rec_validate(const rec_t*,const dict_index_t*,ulint)" -> "page_is_comp(const ib_page_t*)"
"btr_index_rec_validate(const rec_t*,const dict_index_t*,ulint)" -> "rec_get_offsets_func(const rec_t*,const dict_index_t*,ulint*,ulint,mem_heap_t**)"
"btr_index_rec_validate(const rec_t*,const dict_index_t*,ulint)" -> "dict_table_is_comp(const dict_table_t*)"
"btr_index_rec_validate(const rec_t*,const dict_index_t*,ulint)" -> "rec_offs_set_n_alloc(ulint*,ulint)"
"btr_index_rec_validate(const rec_t*,const dict_index_t*,ulint)" -> "rec_get_nth_field_offs(const ulint*,ulint,ulint*)"
"btr_index_rec_validate(const rec_t*,const dict_index_t*,ulint)" -> "dict_index_get_nth_col(const dict_index_t*,ulint)"
"btr_index_rec_validate(const rec_t*,const dict_index_t*,ulint)" -> "page_align(const void*)"
"btr_index_rec_validate(const rec_t*,const dict_index_t*,ulint)" -> "buf_page_print(const unsigned char*,ulint,ulint)"
"btr_index_rec_validate(const rec_t*,const dict_index_t*,ulint)" -> "dict_index_get_n_fields(const dict_index_t*)"
"btr_index_rec_validate(const rec_t*,const dict_index_t*,ulint)" -> "btr_index_rec_validate_report(const ib_page_t*,const rec_t*,const dict_index_t*)"
"btr_index_rec_validate(const rec_t*,const dict_index_t*,ulint)" -> "dict_index_is_univ(const dict_index_t*)"
"btr_index_rec_validate(const rec_t*,const dict_index_t*,ulint)" -> "rec_print_new(FILE*,const rec_t*,const ulint*)"
"btr_index_rec_validate(const rec_t*,const dict_index_t*,ulint)" -> "_IO_putc(int,_IO_FILE*)"
"btr_index_rec_validate_report(const ib_page_t*,const rec_t*,const dict_index_t*)" -> "__builtin_fwrite(const void*,size_t,size_t,FILE*)"
"btr_index_rec_validate_report(const ib_page_t*,const rec_t*,const dict_index_t*)" -> "page_offset(const void*)"
"btr_index_rec_validate_report(const ib_page_t*,const rec_t*,const dict_index_t*)" -> "page_get_page_no(const ib_page_t*)"
"btr_index_rec_validate_report(const ib_page_t*,const rec_t*,const dict_index_t*)" -> "fprintf(FILE*,const char*,...)"
"btr_index_rec_validate_report(const ib_page_t*,const rec_t*,const dict_index_t*)" -> "dict_index_name_print(FILE*,const trx_t*,const dict_index_t*)"
"sel_restore_position_for_mysql(ulint*,ulint,btr_pcur_t*,ulint,mtr_t*)" -> "btr_pcur_is_on_user_rec(const btr_pcur_t*)"
"sel_restore_position_for_mysql(ulint*,ulint,btr_pcur_t*,ulint,mtr_t*)" -> "btr_pcur_move_to_prev(btr_pcur_t*,mtr_t*)"
"sel_restore_position_for_mysql(ulint*,ulint,btr_pcur_t*,ulint,mtr_t*)" -> "btr_pcur_restore_position_func(ulint,btr_pcur_t*,const char*,ulint,mtr_t*)"
"sel_restore_position_for_mysql(ulint*,ulint,btr_pcur_t*,ulint,mtr_t*)" -> "btr_pcur_move_to_next(btr_pcur_t*,mtr_t*)"
"row_search_idx_cond_check(unsigned char*,row_prebuilt_t*,const rec_t*,const ulint*)" -> "abort()"
"row_search_idx_cond_check(unsigned char*,row_prebuilt_t*,const rec_t*,const ulint*)" -> "__builtin_expect(long int,long int)"
"row_search_idx_cond_check(unsigned char*,row_prebuilt_t*,const rec_t*,const ulint*)" -> "ut_dbg_assertion_failed(const char*,const char*,ulint)"
"row_search_idx_cond_check(unsigned char*,row_prebuilt_t*,const rec_t*,const ulint*)" -> "dict_index_is_clust(const dict_index_t*)"
"row_search_idx_cond_check(unsigned char*,row_prebuilt_t*,const rec_t*,const ulint*)" -> "row_sel_store_mysql_rec(unsigned char*,row_prebuilt_t*,const rec_t*,ulint,const dict_index_t*,const ulint*)"
"row_search_idx_cond_check(unsigned char*,row_prebuilt_t*,const rec_t*,const ulint*)" -> "mem_heap_empty(mem_heap_t*)"
"row_search_idx_cond_check(unsigned char*,row_prebuilt_t*,const rec_t*,const ulint*)" -> "row_sel_store_mysql_field_func(unsigned char*,row_prebuilt_t*,const rec_t*,const ulint*,ulint,const mysql_row_templ_t*)"
"row_search_idx_cond_check(unsigned char*,row_prebuilt_t*,const rec_t*,const ulint*)" -> "innobase_index_cond(void*)"
"row_sel_store_mysql_rec(unsigned char*,row_prebuilt_t*,const rec_t*,ulint,const dict_index_t*,const ulint*)" -> "row_sel_store_mysql_field_func(unsigned char*,row_prebuilt_t*,const rec_t*,const ulint*,ulint,const mysql_row_templ_t*)"
"row_sel_store_mysql_rec(unsigned char*,row_prebuilt_t*,const rec_t*,ulint,const dict_index_t*,const ulint*)" -> "__builtin_expect(long int,long int)"
"row_sel_store_mysql_rec(unsigned char*,row_prebuilt_t*,const rec_t*,ulint,const dict_index_t*,const ulint*)" -> "mem_heap_free_func(mem_heap_t*,const char*,ulint)"
"row_sel_store_mysql_rec(unsigned char*,row_prebuilt_t*,const rec_t*,ulint,const dict_index_t*,const ulint*)" -> "dict_table_has_fts_index(dict_table_t*)"
"row_sel_store_mysql_rec(unsigned char*,row_prebuilt_t*,const rec_t*,ulint,const dict_index_t*,const ulint*)" -> "dict_index_is_clust(const dict_index_t*)"
"row_sel_store_mysql_rec(unsigned char*,row_prebuilt_t*,const rec_t*,ulint,const dict_index_t*,const ulint*)" -> "fts_get_doc_id_from_rec(dict_table_t*,const rec_t*,mem_heap_t*)"
"row_sel_store_mysql_field_func(unsigned char*,row_prebuilt_t*,const rec_t*,const ulint*,ulint,const mysql_row_templ_t*)" -> "mem_heap_dup(mem_heap_t*,const void*,ulint)"
"row_sel_store_mysql_field_func(unsigned char*,row_prebuilt_t*,const rec_t*,const ulint*,ulint,const mysql_row_templ_t*)" -> "rec_offs_nth_extern(const ulint*,ulint)"
"row_sel_store_mysql_field_func(unsigned char*,row_prebuilt_t*,const rec_t*,const ulint*,ulint,const mysql_row_templ_t*)" -> "__builtin_expect(long int,long int)"
"row_sel_store_mysql_field_func(unsigned char*,row_prebuilt_t*,const rec_t*,const ulint*,ulint,const mysql_row_templ_t*)" -> "row_sel_field_store_in_mysql_format_func(unsigned char*,const mysql_row_templ_t*,const unsigned char*,ulint)"
"row_sel_store_mysql_field_func(unsigned char*,row_prebuilt_t*,const rec_t*,const ulint*,ulint,const mysql_row_templ_t*)" -> "rec_get_nth_field_offs(const ulint*,ulint,ulint*)"
"row_sel_store_mysql_field_func(unsigned char*,row_prebuilt_t*,const rec_t*,const ulint*,ulint,const mysql_row_templ_t*)" -> "mem_heap_free_func(mem_heap_t*,const char*,ulint)"
"row_sel_store_mysql_field_func(unsigned char*,row_prebuilt_t*,const rec_t*,const ulint*,ulint,const mysql_row_templ_t*)" -> "ut_dbg_assertion_failed(const char*,const char*,ulint)"
"row_sel_store_mysql_field_func(unsigned char*,row_prebuilt_t*,const rec_t*,const ulint*,ulint,const mysql_row_templ_t*)" -> "dict_table_zip_size(const dict_table_t*)"
"row_sel_store_mysql_field_func(unsigned char*,row_prebuilt_t*,const rec_t*,const ulint*,ulint,const mysql_row_templ_t*)" -> "abort()"
"row_sel_store_mysql_field_func(unsigned char*,row_prebuilt_t*,const rec_t*,const ulint*,ulint,const mysql_row_templ_t*)" -> "memcpy(void*,const void*,size_t)"
"row_sel_store_mysql_field_func(unsigned char*,row_prebuilt_t*,const rec_t*,const ulint*,ulint,const mysql_row_templ_t*)" -> "mem_heap_create_func(ulint,ulint)"
"row_sel_store_mysql_field_func(unsigned char*,row_prebuilt_t*,const rec_t*,const ulint*,ulint,const mysql_row_templ_t*)" -> "btr_rec_copy_externally_stored_field(const rec_t*,const ulint*,ulint,ulint,ulint*,mem_heap_t*)"
"row_sel_field_store_in_mysql_format_func(unsigned char*,const mysql_row_templ_t*,const unsigned char*,ulint)" -> "memcpy(void*,const void*,size_t)"
"row_sel_field_store_in_mysql_format_func(unsigned char*,const mysql_row_templ_t*,const unsigned char*,ulint)" -> "memset(void*,int,size_t)"
"row_sel_field_store_in_mysql_format_func(unsigned char*,const mysql_row_templ_t*,const unsigned char*,ulint)" -> "__builtin_expect(long int,long int)"
"row_sel_field_store_in_mysql_format_func(unsigned char*,const mysql_row_templ_t*,const unsigned char*,ulint)" -> "ut_memcpy(void*,const void*,ulint)"
"row_sel_field_store_in_mysql_format_func(unsigned char*,const mysql_row_templ_t*,const unsigned char*,ulint)" -> "row_mysql_pad_col(ulint,unsigned char*,ulint)"
"row_sel_field_store_in_mysql_format_func(unsigned char*,const mysql_row_templ_t*,const unsigned char*,ulint)" -> "ut_dbg_assertion_failed(const char*,const char*,ulint)"
"row_sel_field_store_in_mysql_format_func(unsigned char*,const mysql_row_templ_t*,const unsigned char*,ulint)" -> "row_mysql_store_blob_ref(unsigned char*,ulint,const void*,ulint)"
"row_sel_field_store_in_mysql_format_func(unsigned char*,const mysql_row_templ_t*,const unsigned char*,ulint)" -> "abort()"
"row_sel_field_store_in_mysql_format_func(unsigned char*,const mysql_row_templ_t*,const unsigned char*,ulint)" -> "row_mysql_store_true_var_len(unsigned char*,ulint,ulint)"
"row_mysql_store_blob_ref(unsigned char*,ulint,const void*,ulint)" -> "abort()"
"row_mysql_store_blob_ref(unsigned char*,ulint,const void*,ulint)" -> "ut_dbg_assertion_failed(const char*,const char*,ulint)"
"row_mysql_store_blob_ref(unsigned char*,ulint,const void*,ulint)" -> "mach_write_to_n_little_endian(unsigned char*,ulint,ulint)"
"row_mysql_store_blob_ref(unsigned char*,ulint,const void*,ulint)" -> "memset(void*,int,size_t)"
"row_mysql_store_blob_ref(unsigned char*,ulint,const void*,ulint)" -> "__builtin_expect(long int,long int)"
"row_mysql_store_true_var_len(unsigned char*,ulint,ulint)" -> "__builtin_expect(long int,long int)"
"row_mysql_store_true_var_len(unsigned char*,ulint,ulint)" -> "mach_write_to_2_little_endian(unsigned char*,ulint)"
"row_mysql_store_true_var_len(unsigned char*,ulint,ulint)" -> "abort()"
"row_mysql_store_true_var_len(unsigned char*,ulint,ulint)" -> "ut_dbg_assertion_failed(const char*,const char*,ulint)"
"row_mysql_store_true_var_len(unsigned char*,ulint,ulint)" -> "mach_write_to_1(unsigned char*,ulint)"
"innobase_index_cond(void*)" -> "handler::compare_key_icp(const key_range*) const"
"handler::compare_key_icp(const key_range*) const" -> "key_cmp(KEY_PART_INFO*,const uchar*,uint)"
"key_cmp(KEY_PART_INFO*,const uchar*,uint)" -> "Field::is_null(my_ptrdiff_t) const"
"Field::is_null(my_ptrdiff_t) const" -> "Field::real_maybe_null() const"
"que_thr_stop_for_mysql_no_error(que_thr_t*,trx_t*)" -> "abort()"
"que_thr_stop_for_mysql_no_error(que_thr_t*,trx_t*)" -> "ut_dbg_assertion_failed(const char*,const char*,ulint)"
"que_thr_stop_for_mysql_no_error(que_thr_t*,trx_t*)" -> "mem_analyze_corruption(void*)"
"que_thr_stop_for_mysql_no_error(que_thr_t*,trx_t*)" -> "fprintf(FILE*,const char*,...)"
"row_sel_fetch_last_buf(row_prebuilt_t*)" -> "row_sel_prefetch_cache_init(row_prebuilt_t*)"
"row_sel_prefetch_cache_init(row_prebuilt_t*)" -> "mem_alloc_func(ulint,ulint*)"
"row_sel_prefetch_cache_init(row_prebuilt_t*)" -> "mach_write_to_4(unsigned char*,ulint)"
"row_sel_dequeue_cached_row_for_mysql(unsigned char*,row_prebuilt_t*)" -> "row_sel_copy_cached_field_for_mysql(unsigned char*,const unsigned char*,const mysql_row_templ_t*)"
"row_sel_dequeue_cached_row_for_mysql(unsigned char*,row_prebuilt_t*)" -> "ut_memcpy(void*,const void*,ulint)"
"row_sel_dequeue_cached_row_for_mysql(unsigned char*,row_prebuilt_t*)" -> "__builtin_expect(long int,long int)"
"row_sel_copy_cached_field_for_mysql(unsigned char*,const unsigned char*,const mysql_row_templ_t*)" -> "row_mysql_read_true_varchar(ulint*,const unsigned char*,ulint)"
"row_sel_copy_cached_field_for_mysql(unsigned char*,const unsigned char*,const mysql_row_templ_t*)" -> "ut_memcpy(void*,const void*,ulint)"
"row_mysql_read_true_varchar(ulint*,const unsigned char*,ulint)" -> "mach_read_from_1(const unsigned char*)"
"row_mysql_read_true_varchar(ulint*,const unsigned char*,ulint)" -> "__builtin_expect(long int,long int)"
"row_mysql_read_true_varchar(ulint*,const unsigned char*,ulint)" -> "abort()"
"row_mysql_read_true_varchar(ulint*,const unsigned char*,ulint)" -> "ut_dbg_assertion_failed(const char*,const char*,ulint)"
"row_mysql_read_true_varchar(ulint*,const unsigned char*,ulint)" -> "mach_read_from_2_little_endian(const unsigned char*)"
"row_sel_try_search_shortcut_for_mysql(const rec_t**,row_prebuilt_t*,ulint**,mem_heap_t**,mtr_t*)" -> "lock_clust_rec_cons_read_sees(const rec_t*,dict_index_t*,const ulint*,read_view_t*)"
"row_sel_try_search_shortcut_for_mysql(const rec_t**,row_prebuilt_t*,ulint**,mem_heap_t**,mtr_t*)" -> "btr_pcur_open_with_no_init_func(dict_index_t*,const dtuple_t*,ulint,ulint,btr_pcur_t*,ulint,const char*,ulint,mtr_t*)"
"row_sel_try_search_shortcut_for_mysql(const rec_t**,row_prebuilt_t*,ulint**,mem_heap_t**,mtr_t*)" -> "dict_table_is_comp(const dict_table_t*)"
"row_sel_try_search_shortcut_for_mysql(const rec_t**,row_prebuilt_t*,ulint**,mem_heap_t**,mtr_t*)" -> "page_rec_is_user_rec(const rec_t*)"
"row_sel_try_search_shortcut_for_mysql(const rec_t**,row_prebuilt_t*,ulint**,mem_heap_t**,mtr_t*)" -> "dtuple_get_n_fields(const dtuple_t*)"
"row_sel_try_search_shortcut_for_mysql(const rec_t**,row_prebuilt_t*,ulint**,mem_heap_t**,mtr_t*)" -> "rec_get_offsets_func(const rec_t*,const dict_index_t*,ulint*,ulint,mem_heap_t**)"
"row_sel_try_search_shortcut_for_mysql(const rec_t**,row_prebuilt_t*,ulint**,mem_heap_t**,mtr_t*)" -> "rec_get_deleted_flag(const rec_t*,ulint)"
"row_sel_try_search_shortcut_for_mysql(const rec_t**,row_prebuilt_t*,ulint**,mem_heap_t**,mtr_t*)" -> "btr_pcur_get_up_match(const btr_pcur_t*)"
"row_sel_get_clust_rec_for_mysql(row_prebuilt_t*,dict_index_t*,const rec_t*,que_thr_t*,const rec_t**,ulint**,mem_heap_t**,mtr_t*)" -> "page_rec_is_user_rec(const rec_t*)"
"row_sel_get_clust_rec_for_mysql(row_prebuilt_t*,dict_index_t*,const rec_t*,que_thr_t*,const rec_t**,ulint**,mem_heap_t**,mtr_t*)" -> "lock_clust_rec_cons_read_sees(const rec_t*,dict_index_t*,const ulint*,read_view_t*)"
"row_sel_get_clust_rec_for_mysql(row_prebuilt_t*,dict_index_t*,const rec_t*,que_thr_t*,const rec_t**,ulint**,mem_heap_t**,mtr_t*)" -> "putc(int,FILE*)"
"row_sel_get_clust_rec_for_mysql(row_prebuilt_t*,dict_index_t*,const rec_t*,que_thr_t*,const rec_t**,ulint**,mem_heap_t**,mtr_t*)" -> "row_sel_sec_rec_is_for_clust_rec(const rec_t*,dict_index_t*,const rec_t*,dict_index_t*)"
"row_sel_get_clust_rec_for_mysql(row_prebuilt_t*,dict_index_t*,const rec_t*,que_thr_t*,const rec_t**,ulint**,mem_heap_t**,mtr_t*)" -> "__builtin_fwrite(const void*,size_t,size_t,FILE*)"
"row_sel_get_clust_rec_for_mysql(row_prebuilt_t*,dict_index_t*,const rec_t*,que_thr_t*,const rec_t**,ulint**,mem_heap_t**,mtr_t*)" -> "trx_print(FILE*,const trx_t*,ulint)"
"row_sel_get_clust_rec_for_mysql(row_prebuilt_t*,dict_index_t*,const rec_t*,que_thr_t*,const rec_t**,ulint**,mem_heap_t**,mtr_t*)" -> "dict_index_name_print(FILE*,const trx_t*,const dict_index_t*)"
"row_sel_get_clust_rec_for_mysql(row_prebuilt_t*,dict_index_t*,const rec_t*,que_thr_t*,const rec_t**,ulint**,mem_heap_t**,mtr_t*)" -> "btr_pcur_store_position(btr_pcur_t*,mtr_t*)"
"row_sel_get_clust_rec_for_mysql(row_prebuilt_t*,dict_index_t*,const rec_t*,que_thr_t*,const rec_t**,ulint**,mem_heap_t**,mtr_t*)" -> "lock_clust_rec_read_check_and_lock(ulint,const buf_block_t*,const rec_t*,dict_index_t*,const ulint*,lock_mode,ulint,que_thr_t*)"
"row_sel_get_clust_rec_for_mysql(row_prebuilt_t*,dict_index_t*,const rec_t*,que_thr_t*,const rec_t**,ulint**,mem_heap_t**,mtr_t*)" -> "row_sel_build_prev_vers_for_mysql(read_view_t*,dict_index_t*,row_prebuilt_t*,const rec_t*,ulint**,mem_heap_t**,rec_t**,mtr_t*)"
"row_sel_get_clust_rec_for_mysql(row_prebuilt_t*,dict_index_t*,const rec_t*,que_thr_t*,const rec_t**,ulint**,mem_heap_t**,mtr_t*)" -> "btr_pcur_open_with_no_init_func(dict_index_t*,const dtuple_t*,ulint,ulint,btr_pcur_t*,ulint,const char*,ulint,mtr_t*)"
"row_sel_get_clust_rec_for_mysql(row_prebuilt_t*,dict_index_t*,const rec_t*,que_thr_t*,const rec_t**,ulint**,mem_heap_t**,mtr_t*)" -> "dict_table_is_comp(const dict_table_t*)"
"row_sel_get_clust_rec_for_mysql(row_prebuilt_t*,dict_index_t*,const rec_t*,que_thr_t*,const rec_t**,ulint**,mem_heap_t**,mtr_t*)" -> "thr_get_trx(que_thr_t*)"
"row_sel_get_clust_rec_for_mysql(row_prebuilt_t*,dict_index_t*,const rec_t*,que_thr_t*,const rec_t**,ulint**,mem_heap_t**,mtr_t*)" -> "dict_index_get_n_unique(const dict_index_t*)"
"row_sel_get_clust_rec_for_mysql(row_prebuilt_t*,dict_index_t*,const rec_t*,que_thr_t*,const rec_t**,ulint**,mem_heap_t**,mtr_t*)" -> "row_build_row_ref_in_tuple(dtuple_t*,const rec_t*,const dict_index_t*,ulint*,trx_t*)"
"row_sel_get_clust_rec_for_mysql(row_prebuilt_t*,dict_index_t*,const rec_t*,que_thr_t*,const rec_t**,ulint**,mem_heap_t**,mtr_t*)" -> "rec_get_deleted_flag(const rec_t*,ulint)"
"row_sel_get_clust_rec_for_mysql(row_prebuilt_t*,dict_index_t*,const rec_t*,que_thr_t*,const rec_t**,ulint**,mem_heap_t**,mtr_t*)" -> "ut_print_timestamp(FILE*)"
"row_sel_get_clust_rec_for_mysql(row_prebuilt_t*,dict_index_t*,const rec_t*,que_thr_t*,const rec_t**,ulint**,mem_heap_t**,mtr_t*)" -> "rec_print(FILE*,const rec_t*,const dict_index_t*)"
"row_sel_get_clust_rec_for_mysql(row_prebuilt_t*,dict_index_t*,const rec_t*,que_thr_t*,const rec_t**,ulint**,mem_heap_t**,mtr_t*)" -> "rec_get_offsets_func(const rec_t*,const dict_index_t*,ulint*,ulint,mem_heap_t**)"
"row_sel_get_clust_rec_for_mysql(row_prebuilt_t*,dict_index_t*,const rec_t*,que_thr_t*,const rec_t**,ulint**,mem_heap_t**,mtr_t*)" -> "btr_pcur_get_low_match(const btr_pcur_t*)"
"row_unlock_for_mysql(row_prebuilt_t*,ulint)" -> "__builtin_expect(long int,long int)"
"row_unlock_for_mysql(row_prebuilt_t*,ulint)" -> "__builtin_fwrite(const void*,size_t,size_t,FILE*)"
"row_unlock_for_mysql(row_prebuilt_t*,ulint)" -> "dict_index_is_clust(const dict_index_t*)"
"row_unlock_for_mysql(row_prebuilt_t*,ulint)" -> "trx_read_trx_id(const unsigned char*)"
"row_unlock_for_mysql(row_prebuilt_t*,ulint)" -> "mtr_commit(mtr_t*)"
"row_unlock_for_mysql(row_prebuilt_t*,ulint)" -> "mtr_start(mtr_t*)"
"row_unlock_for_mysql(row_prebuilt_t*,ulint)" -> "row_get_rec_trx_id(const rec_t*,const dict_index_t*,const ulint*)"
"row_unlock_for_mysql(row_prebuilt_t*,ulint)" -> "rec_offs_set_n_alloc(ulint*,ulint)"
"row_unlock_for_mysql(row_prebuilt_t*,ulint)" -> "mem_heap_free_func(mem_heap_t*,const char*,ulint)"
"row_unlock_for_mysql(row_prebuilt_t*,ulint)" -> "lock_rec_unlock(trx_t*,const buf_block_t*,const rec_t*,lock_mode)"
"row_unlock_for_mysql(row_prebuilt_t*,ulint)" -> "rec_get_offsets_func(const rec_t*,const dict_index_t*,ulint*,ulint,mem_heap_t**)"
"row_unlock_for_mysql(row_prebuilt_t*,ulint)" -> "btr_pcur_restore_position_func(ulint,btr_pcur_t*,const char*,ulint,mtr_t*)"
"lock_rec_unlock(trx_t*,const buf_block_t*,const rec_t*,lock_mode)" -> "__builtin_expect(long int,long int)"
"lock_rec_unlock(trx_t*,const buf_block_t*,const rec_t*,lock_mode)" -> "lock_grant(ib_lock_t*)"
"lock_rec_unlock(trx_t*,const buf_block_t*,const rec_t*,lock_mode)" -> "abort()"
"lock_rec_unlock(trx_t*,const buf_block_t*,const rec_t*,lock_mode)" -> "pfs_mutex_enter_func(ib_mutex_t*,const char*,ulint)"
"lock_rec_unlock(trx_t*,const buf_block_t*,const rec_t*,lock_mode)" -> "innobase_get_stmt(THD*,size_t*)"
"lock_rec_unlock(trx_t*,const buf_block_t*,const rec_t*,lock_mode)" -> "lock_get_mode(const ib_lock_t*)"
"lock_rec_unlock(trx_t*,const buf_block_t*,const rec_t*,lock_mode)" -> "lock_rec_get_first(const buf_block_t*,ulint)"
"lock_rec_unlock(trx_t*,const buf_block_t*,const rec_t*,lock_mode)" -> "lock_rec_reset_nth_bit(ib_lock_t*,ulint)"
"lock_rec_unlock(trx_t*,const buf_block_t*,const rec_t*,lock_mode)" -> "fprintf(FILE*,const char*,...)"
"lock_rec_unlock(trx_t*,const buf_block_t*,const rec_t*,lock_mode)" -> "ut_print_timestamp(FILE*)"
"lock_rec_unlock(trx_t*,const buf_block_t*,const rec_t*,lock_mode)" -> "ut_dbg_assertion_failed(const char*,const char*,ulint)"
"lock_rec_unlock(trx_t*,const buf_block_t*,const rec_t*,lock_mode)" -> "lock_get_wait(const ib_lock_t*)"
"lock_rec_unlock(trx_t*,const buf_block_t*,const rec_t*,lock_mode)" -> "lock_rec_get_next(ulint,ib_lock_t*)"
"lock_rec_unlock(trx_t*,const buf_block_t*,const rec_t*,lock_mode)" -> "page_rec_get_heap_no(const rec_t*)"
"lock_rec_unlock(trx_t*,const buf_block_t*,const rec_t*,lock_mode)" -> "pfs_mutex_exit_func(ib_mutex_t*)"
"lock_rec_unlock(trx_t*,const buf_block_t*,const rec_t*,lock_mode)" -> "lock_rec_has_to_wait_in_queue(const ib_lock_t*)"
"innobase_get_stmt(THD*,size_t*)" -> "thd_query_string(THD*)"
"btr_pcur_move_to_last_on_page(btr_pcur_t*,mtr_t*)" -> "page_cur_set_after_last(const buf_block_t*,page_cur_t*)"
"row_prebuild_sel_graph(row_prebuilt_t*)" -> "que_node_get_parent(que_node_t*)"
"row_prebuild_sel_graph(row_prebuilt_t*)" -> "pars_complete_graph_for_exec(que_node_t*,trx_t*,mem_heap_t*)"
"row_prebuild_sel_graph(row_prebuilt_t*)" -> "sel_node_create(mem_heap_t*)"
"cmp_dtuple_is_prefix_of_rec(const dtuple_t*,const rec_t*,const ulint*)" -> "cmp_dtuple_rec_with_match_low(const dtuple_t*,const rec_t*,const ulint*,ulint,ulint*,ulint*)"
"cmp_dtuple_is_prefix_of_rec(const dtuple_t*,const rec_t*,const ulint*)" -> "rec_offs_n_fields(const ulint*)"
"cmp_dtuple_is_prefix_of_rec(const dtuple_t*,const rec_t*,const ulint*)" -> "dtuple_get_n_fields(const dtuple_t*)"
"cmp_dtuple_is_prefix_of_rec(const dtuple_t*,const rec_t*,const ulint*)" -> "dfield_get_len(const dfield_t*)"
"cmp_dtuple_is_prefix_of_rec(const dtuple_t*,const rec_t*,const ulint*)" -> "dtuple_get_n_fields_cmp(const dtuple_t*)"
"row_sel_enqueue_cache_row_for_mysql(unsigned char*,row_prebuilt_t*)" -> "row_sel_fetch_last_buf(row_prebuilt_t*)"
"row_sel_enqueue_cache_row_for_mysql(unsigned char*,row_prebuilt_t*)" -> "ut_memcpy(void*,const void*,ulint)"
"thd_to_trx(THD*)" -> "thd_ha_data(const THD*,const handlerton*)"
"ha_innobase::build_template(bool)" -> "dict_index_is_clust(const dict_index_t*)"
"ha_innobase::build_template(bool)" -> "build_template_needs_field_in_icp(const dict_index_t*,const row_prebuilt_t*,bool,ulint)"
"ha_innobase::build_template(bool)" -> "dict_index_get_nth_col_pos(const dict_index_t*,ulint)"
"ha_innobase::build_template(bool)" -> "dict_index_get_nth_col_or_prefix_pos(const dict_index_t*,ulint,ulint)"
"ha_innobase::build_template(bool)" -> "dict_index_contains_col_or_prefix(const dict_index_t*,ulint)"
"ha_innobase::build_template(bool)" -> "mem_alloc_func(ulint,ulint*)"
"ha_innobase::build_template(bool)" -> "build_template_needs_field(ulint,ulint,ulint,ulint,dict_index_t*,const TABLE*,ulint)"
"ha_innobase::build_template(bool)" -> "build_template_field(row_prebuilt_t*,dict_index_t*,dict_index_t*,TABLE*,const Field*,ulint)"
"build_template_needs_field_in_icp(const dict_index_t*,const row_prebuilt_t*,bool,ulint)" -> "dict_index_contains_col_or_prefix(const dict_index_t*,ulint)"
"build_template_needs_field(ulint,ulint,ulint,ulint,dict_index_t*,const TABLE*,ulint)" -> "dict_table_col_in_clustered_key(const dict_table_t*,ulint)"
"build_template_needs_field(ulint,ulint,ulint,ulint,dict_index_t*,const TABLE*,ulint)" -> "bitmap_is_set(const MY_BITMAP*,uint)"
"dict_table_col_in_clustered_key(const dict_table_t*,ulint)" -> "dict_index_get_n_unique(const dict_index_t*)"
"build_template_field(row_prebuilt_t*,dict_index_t*,dict_index_t*,TABLE*,const Field*,ulint)" -> "abort()"
"build_template_field(row_prebuilt_t*,dict_index_t*,dict_index_t*,TABLE*,const Field*,ulint)" -> "dict_col_get_clust_pos(const dict_col_t*,const dict_index_t*)"
"build_template_field(row_prebuilt_t*,dict_index_t*,dict_index_t*,TABLE*,const Field*,ulint)" -> "get_field_offset(const TABLE*,const Field*)"
"build_template_field(row_prebuilt_t*,dict_index_t*,dict_index_t*,TABLE*,const Field*,ulint)" -> "dict_col_get_mbminlen(const dict_col_t*)"
"build_template_field(row_prebuilt_t*,dict_index_t*,dict_index_t*,TABLE*,const Field*,ulint)" -> "dict_index_is_clust(const dict_index_t*)"
"build_template_field(row_prebuilt_t*,dict_index_t*,dict_index_t*,TABLE*,const Field*,ulint)" -> "dtype_get_charset_coll(ulint)"
"build_template_field(row_prebuilt_t*,dict_index_t*,dict_index_t*,TABLE*,const Field*,ulint)" -> "ut_dbg_assertion_failed(const char*,const char*,ulint)"
"build_template_field(row_prebuilt_t*,dict_index_t*,dict_index_t*,TABLE*,const Field*,ulint)" -> "__builtin_expect(long int,long int)"
"build_template_field(row_prebuilt_t*,dict_index_t*,dict_index_t*,TABLE*,const Field*,ulint)" -> "dict_index_get_nth_col_pos(const dict_index_t*,ulint)"
"build_template_field(row_prebuilt_t*,dict_index_t*,dict_index_t*,TABLE*,const Field*,ulint)" -> "dict_col_get_mbmaxlen(const dict_col_t*)"
"build_template_field(row_prebuilt_t*,dict_index_t*,dict_index_t*,TABLE*,const Field*,ulint)" -> "Field::null_offset() const"
"build_template_field(row_prebuilt_t*,dict_index_t*,dict_index_t*,TABLE*,const Field*,ulint)" -> "Field::real_maybe_null() const"
"Field::null_offset() const" -> "Field::null_offset(const uchar*) const"
"innobase_srv_conc_enter_innodb(trx_t*)" -> "srv_conc_enter_innodb(trx_t*)"
"innobase_srv_conc_enter_innodb(trx_t*)" -> "thd_is_replication_slave_thread(THD*)"
"innobase_srv_conc_enter_innodb(trx_t*)" -> "srv_conc_get_active_threads()"
"innobase_srv_conc_enter_innodb(trx_t*)" -> "ut_time_us(ullint*)"
"innobase_srv_conc_enter_innodb(trx_t*)" -> "os_thread_sleep(ulint)"
"srv_conc_enter_innodb(trx_t*)" -> "srv_conc_enter_innodb_with_atomics(trx_t*)"
"srv_conc_enter_innodb_with_atomics(trx_t*)" -> "__builtin_expect(long int,long int)"
"srv_conc_enter_innodb_with_atomics(trx_t*)" -> "srv_enter_innodb_with_tickets(trx_t*)"
"srv_conc_enter_innodb_with_atomics(trx_t*)" -> "trx_search_latch_release_if_reserved(trx_t*)"
"srv_conc_enter_innodb_with_atomics(trx_t*)" -> "ut_dbg_assertion_failed(const char*,const char*,ulint)"
"srv_conc_enter_innodb_with_atomics(trx_t*)" -> "abort()"
"srv_conc_enter_innodb_with_atomics(trx_t*)" -> "thd_wait_begin(THD*,int)"
"srv_conc_enter_innodb_with_atomics(trx_t*)" -> "__sync_add_and_fetch_8(volatile void*,long unsigned int)"
"srv_conc_enter_innodb_with_atomics(trx_t*)" -> "thd_wait_end(THD*)"
"srv_conc_enter_innodb_with_atomics(trx_t*)" -> "os_thread_sleep(ulint)"
"srv_conc_enter_innodb_with_atomics(trx_t*)" -> "__sync_sub_and_fetch_8(volatile void*,long unsigned int)"
"trx_search_latch_release_if_reserved(trx_t*)" -> "pfs_rw_lock_s_unlock_func(rw_lock_t*)"
"row_sel_convert_mysql_key_to_innobase(dtuple_t*,unsigned char*,ulint,dict_index_t*,const unsigned char*,ulint,trx_t*)" -> "__builtin_fwrite(const void*,size_t,size_t,FILE*)"
"row_sel_convert_mysql_key_to_innobase(dtuple_t*,unsigned char*,ulint,dict_index_t*,const unsigned char*,ulint,trx_t*)" -> "ut_print_timestamp(FILE*)"
"row_sel_convert_mysql_key_to_innobase(dtuple_t*,unsigned char*,ulint,dict_index_t*,const unsigned char*,ulint,trx_t*)" -> "dict_index_name_print(FILE*,const trx_t*,const dict_index_t*)"
"row_sel_convert_mysql_key_to_innobase(dtuple_t*,unsigned char*,ulint,dict_index_t*,const unsigned char*,ulint,trx_t*)" -> "ut_dbg_assertion_failed(const char*,const char*,ulint)"
"row_sel_convert_mysql_key_to_innobase(dtuple_t*,unsigned char*,ulint,dict_index_t*,const unsigned char*,ulint,trx_t*)" -> "putc(int,FILE*)"
"row_sel_convert_mysql_key_to_innobase(dtuple_t*,unsigned char*,ulint,dict_index_t*,const unsigned char*,ulint,trx_t*)" -> "dfield_set_len(dfield_t*,ulint)"
"row_sel_convert_mysql_key_to_innobase(dtuple_t*,unsigned char*,ulint,dict_index_t*,const unsigned char*,ulint,trx_t*)" -> "row_mysql_store_col_in_innobase_format(dfield_t*,unsigned char*,ulint,const unsigned char*,ulint,ulint)"
"row_sel_convert_mysql_key_to_innobase(dtuple_t*,unsigned char*,ulint,dict_index_t*,const unsigned char*,ulint,trx_t*)" -> "abort()"
"row_sel_convert_mysql_key_to_innobase(dtuple_t*,unsigned char*,ulint,dict_index_t*,const unsigned char*,ulint,trx_t*)" -> "fprintf(FILE*,const char*,...)"
"row_sel_convert_mysql_key_to_innobase(dtuple_t*,unsigned char*,ulint,dict_index_t*,const unsigned char*,ulint,trx_t*)" -> "dtype_get_mysql_type(const dtype_t*)"
"row_sel_convert_mysql_key_to_innobase(dtuple_t*,unsigned char*,ulint,dict_index_t*,const unsigned char*,ulint,trx_t*)" -> "dfield_set_null(dfield_t*)"
"row_sel_convert_mysql_key_to_innobase(dtuple_t*,unsigned char*,ulint,dict_index_t*,const unsigned char*,ulint,trx_t*)" -> "dict_table_is_comp(const dict_table_t*)"
"row_sel_convert_mysql_key_to_innobase(dtuple_t*,unsigned char*,ulint,dict_index_t*,const unsigned char*,ulint,trx_t*)" -> "dfield_get_len(const dfield_t*)"
"row_sel_convert_mysql_key_to_innobase(dtuple_t*,unsigned char*,ulint,dict_index_t*,const unsigned char*,ulint,trx_t*)" -> "fflush(FILE*)"
"row_sel_convert_mysql_key_to_innobase(dtuple_t*,unsigned char*,ulint,dict_index_t*,const unsigned char*,ulint,trx_t*)" -> "ut_print_buf(FILE*,const void*,ulint)"
"row_sel_convert_mysql_key_to_innobase(dtuple_t*,unsigned char*,ulint,dict_index_t*,const unsigned char*,ulint,trx_t*)" -> "__builtin_expect(long int,long int)"
"row_sel_convert_mysql_key_to_innobase(dtuple_t*,unsigned char*,ulint,dict_index_t*,const unsigned char*,ulint,trx_t*)" -> "dtuple_set_n_fields(dtuple_t*,ulint)"
"row_sel_convert_mysql_key_to_innobase(dtuple_t*,unsigned char*,ulint,dict_index_t*,const unsigned char*,ulint,trx_t*)" -> "dfield_set_data(dfield_t*,const void*,ulint)"
"row_mysql_store_col_in_innobase_format(dfield_t*,unsigned char*,ulint,const unsigned char*,ulint,ulint)" -> "dtype_get_mbmaxlen(const dtype_t*)"
"row_mysql_store_col_in_innobase_format(dfield_t*,unsigned char*,ulint,const unsigned char*,ulint,ulint)" -> "__builtin_expect(long int,long int)"
"row_mysql_store_col_in_innobase_format(dfield_t*,unsigned char*,ulint,const unsigned char*,ulint,ulint)" -> "dtype_get_len(const dtype_t*)"
"row_mysql_store_col_in_innobase_format(dfield_t*,unsigned char*,ulint,const unsigned char*,ulint,ulint)" -> "row_mysql_read_blob_ref(ulint*,const unsigned char*,ulint)"
"row_mysql_store_col_in_innobase_format(dfield_t*,unsigned char*,ulint,const unsigned char*,ulint,ulint)" -> "abort()"
"row_mysql_store_col_in_innobase_format(dfield_t*,unsigned char*,ulint,const unsigned char*,ulint,ulint)" -> "dfield_set_data(dfield_t*,const void*,ulint)"
"row_mysql_store_col_in_innobase_format(dfield_t*,unsigned char*,ulint,const unsigned char*,ulint,ulint)" -> "ut_dbg_assertion_failed(const char*,const char*,ulint)"
"row_mysql_store_col_in_innobase_format(dfield_t*,unsigned char*,ulint,const unsigned char*,ulint,ulint)" -> "dtype_get_mysql_type(const dtype_t*)"
"row_mysql_store_col_in_innobase_format(dfield_t*,unsigned char*,ulint,const unsigned char*,ulint,ulint)" -> "dtype_get_mbminlen(const dtype_t*)"
"row_mysql_store_col_in_innobase_format(dfield_t*,unsigned char*,ulint,const unsigned char*,ulint,ulint)" -> "row_mysql_read_true_varchar(ulint*,const unsigned char*,ulint)"
"row_mysql_read_blob_ref(ulint*,const unsigned char*,ulint)" -> "mach_read_from_n_little_endian(const unsigned char*,ulint)"
"dtype_get_mbminlen(const dtype_t*)" -> "__builtin_expect(long int,long int)"
"ib_senderrf(THD*,ib_log_level_t,ib_uint32_t,...)" -> "__builtin_expect(long int,long int)"
"ib_senderrf(THD*,ib_log_level_t,ib_uint32_t,...)" -> "push_warning_printf(THD*,Sql_condition::enum_warning_level,uint,const char*,...)"
"ib_senderrf(THD*,ib_log_level_t,ib_uint32_t,...)" -> "vasprintf(char**,const char*,__va_list_tag*)"
"ib_senderrf(THD*,ib_log_level_t,ib_uint32_t,...)" -> "free(void*)"
"ib_senderrf(THD*,ib_log_level_t,ib_uint32_t,...)" -> "ut_dbg_assertion_failed(const char*,const char*,ulint)"
"ib_senderrf(THD*,ib_log_level_t,ib_uint32_t,...)" -> "my_printf_error(uint,const char*,myf,...)"
"ib_senderrf(THD*,ib_log_level_t,ib_uint32_t,...)" -> "__builtin_va_start(__va_list_tag*,...)"
"ib_senderrf(THD*,ib_log_level_t,ib_uint32_t,...)" -> "innobase_get_err_msg(int)"
"ib_senderrf(THD*,ib_log_level_t,ib_uint32_t,...)" -> "__builtin_va_end(__va_list_tag*)"
"ib_senderrf(THD*,ib_log_level_t,ib_uint32_t,...)" -> "abort()"
"innobase_get_err_msg(int)" -> "my_get_err_msg(int)"
"convert_search_mode_to_innobase(ha_rkey_function)" -> "my_error(int,myf,...)"
"innobase_srv_conc_exit_innodb(trx_t*)" -> "srv_conc_force_exit_innodb(trx_t*)"
"key_copy(uchar*,uchar*,KEY*,uint)" -> "std::min(const _Tp&,const _Tp&) [with _Tp = unsigned int]"
"open_proc_table_for_read(THD*,Open_tables_backup*)" -> "TABLE_LIST::init_one_table(const char*,size_t,const char*,size_t,const char*,thr_lock_type)"
"open_proc_table_for_read(THD*,Open_tables_backup*)" -> "Table_check_intact::check(TABLE*,const TABLE_FIELD_DEF*)"
"open_proc_table_for_read(THD*,Open_tables_backup*)" -> "close_system_tables(THD*,Open_tables_backup*)"
"open_proc_table_for_read(THD*,Open_tables_backup*)" -> "open_system_tables_for_read(THD*,TABLE_LIST*,Open_tables_backup*)"
"open_proc_table_for_read(THD*,Open_tables_backup*)" -> "my_error(int,myf,...)"
"open_proc_table_for_read(THD*,Open_tables_backup*)" -> "TABLE_LIST::TABLE_LIST()"
"Table_check_intact::check(TABLE*,const TABLE_FIELD_DEF*)" -> "strncmp(const char*,const char*,size_t)"
"Table_check_intact::check(TABLE*,const TABLE_FIELD_DEF*)" -> "String::c_ptr_safe()"
"Table_check_intact::check(TABLE*,const TABLE_FIELD_DEF*)" -> "String::length(uint32)"
"Table_check_intact::check(TABLE*,const TABLE_FIELD_DEF*)" -> "_current_thd()"
"Table_check_intact::check(TABLE*,const TABLE_FIELD_DEF*)" -> "strcmp(const char*,const char*)"
"Table_check_intact::check(TABLE*,const TABLE_FIELD_DEF*)" -> "String::String(char*,uint32,const CHARSET_INFO*)"
"open_system_tables_for_read(THD*,TABLE_LIST*,Open_tables_backup*)" -> "open_and_lock_tables(THD*,TABLE_LIST*,bool,uint)"
"open_system_tables_for_read(THD*,TABLE_LIST*,Open_tables_backup*)" -> "Query_tables_list::Query_tables_list()"
"open_system_tables_for_read(THD*,TABLE_LIST*,Open_tables_backup*)" -> "THD::restore_backup_open_tables_state(Open_tables_backup*)"
"open_system_tables_for_read(THD*,TABLE_LIST*,Open_tables_backup*)" -> "LEX::reset_n_backup_query_tables_list(Query_tables_list*)"
"open_system_tables_for_read(THD*,TABLE_LIST*,Open_tables_backup*)" -> "LEX::restore_backup_query_tables_list(Query_tables_list*)"
"open_system_tables_for_read(THD*,TABLE_LIST*,Open_tables_backup*)" -> "TABLE::use_all_columns()"
"open_system_tables_for_read(THD*,TABLE_LIST*,Open_tables_backup*)" -> "THD::reset_n_backup_open_tables_state(Open_tables_backup*)"
"open_and_lock_tables(THD*,TABLE_LIST*,bool,uint)" -> "DML_prelocking_strategy::DML_prelocking_strategy()"
"open_and_lock_tables(THD*,TABLE_LIST*,bool,uint)" -> "open_and_lock_tables(THD*,TABLE_LIST*,bool,uint,Prelocking_strategy*)"
"open_and_lock_tables(THD*,TABLE_LIST*,bool,uint,Prelocking_strategy*)" -> "MDL_context::mdl_savepoint()"
"open_and_lock_tables(THD*,TABLE_LIST*,bool,uint,Prelocking_strategy*)" -> "mysql_handle_derived(LEX*,bool (*)(THD*,LEX*,TABLE_LIST*))"
"open_and_lock_tables(THD*,TABLE_LIST*,bool,uint,Prelocking_strategy*)" -> "trans_rollback_stmt(THD*)"
"open_and_lock_tables(THD*,TABLE_LIST*,bool,uint,Prelocking_strategy*)" -> "open_tables(THD*,TABLE_LIST**,uint*,uint,Prelocking_strategy*)"
"open_and_lock_tables(THD*,TABLE_LIST*,bool,uint,Prelocking_strategy*)" -> "close_thread_tables(THD*)"
"open_and_lock_tables(THD*,TABLE_LIST*,bool,uint,Prelocking_strategy*)" -> "lock_tables(THD*,TABLE_LIST*,uint,uint)"
"open_and_lock_tables(THD*,TABLE_LIST*,bool,uint,Prelocking_strategy*)" -> "MDL_context::rollback_to_savepoint(const MDL_savepoint&)"
"trans_rollback_stmt(THD*)" -> "THD_TRANS::reset()"
"trans_rollback_stmt(THD*)" -> "ha_rollback_trans(THD*,bool)"
"trans_rollback_stmt(THD*)" -> "THD::st_transactions::merge_unsafe_rollback_flags()"
"trans_rollback_stmt(THD*)" -> "THD::in_active_multi_stmt_transaction() const"
"THD_TRANS::reset()" -> "THD_TRANS::reset_unsafe_rollback_flags()"
"THD::st_transactions::merge_unsafe_rollback_flags()" -> "THD_TRANS::get_unsafe_rollback_flags() const"
"THD::st_transactions::merge_unsafe_rollback_flags()" -> "THD_TRANS::add_unsafe_rollback_flags(unsigned int)"
"lock_tables(THD*,TABLE_LIST*,uint,uint)" -> "Query_tables_list::first_not_own_table()"
"lock_tables(THD*,TABLE_LIST*,uint,uint)" -> "THD::decide_logging_format(TABLE_LIST*)"
"lock_tables(THD*,TABLE_LIST*,uint,uint)" -> "Query_tables_list::requires_prelocking()"
"lock_tables(THD*,TABLE_LIST*,uint,uint)" -> "check_lock_and_start_stmt(THD*,Query_tables_list*,TABLE_LIST*)"
"lock_tables(THD*,TABLE_LIST*,uint,uint)" -> "has_write_table_auto_increment_not_first_in_pk(TABLE_LIST*)"
"lock_tables(THD*,TABLE_LIST*,uint,uint)" -> "mysql_lock_tables(THD*,TABLE**,uint,uint)"
"lock_tables(THD*,TABLE_LIST*,uint,uint)" -> "THD::get_command() const"
"lock_tables(THD*,TABLE_LIST*,uint,uint)" -> "has_write_table_with_auto_increment(TABLE_LIST*)"
"lock_tables(THD*,TABLE_LIST*,uint,uint)" -> "mysql_unlock_tables(THD*,MYSQL_LOCK*)"
"lock_tables(THD*,TABLE_LIST*,uint,uint)" -> "my_error(int,myf,...)"
"lock_tables(THD*,TABLE_LIST*,uint,uint)" -> "mark_real_tables_as_free_for_reuse(TABLE_LIST*)"
"lock_tables(THD*,TABLE_LIST*,uint,uint)" -> "Query_arena::alloc(size_t)"
"lock_tables(THD*,TABLE_LIST*,uint,uint)" -> "Query_tables_list::set_stmt_unsafe(Query_tables_list::enum_binlog_stmt_unsafe)"
"lock_tables(THD*,TABLE_LIST*,uint,uint)" -> "TABLE_LIST::placeholder()"
"lock_tables(THD*,TABLE_LIST*,uint,uint)" -> "THD::enter_locked_tables_mode(enum_locked_tables_mode)"
"lock_tables(THD*,TABLE_LIST*,uint,uint)" -> "has_write_table_with_auto_increment_and_select(TABLE_LIST*)"
"THD::decide_logging_format(TABLE_LIST*)" -> "Query_tables_list::is_stmt_row_injection() const"
"THD::decide_logging_format(TABLE_LIST*)" -> "THD::reset_binlog_local_stmt_filter()"
"THD::decide_logging_format(TABLE_LIST*)" -> "TABLE_LIST::placeholder()"
"THD::decide_logging_format(TABLE_LIST*)" -> "THD::clear_binlog_local_stmt_filter()"
"THD::decide_logging_format(TABLE_LIST*)" -> "_current_thd()"
"THD::decide_logging_format(TABLE_LIST*)" -> "String::c_ptr()"
"THD::decide_logging_format(TABLE_LIST*)" -> "Query_tables_list::is_stmt_unsafe() const"
"THD::decide_logging_format(TABLE_LIST*)" -> "THD::is_current_stmt_binlog_format_row() const"
"THD::decide_logging_format(TABLE_LIST*)" -> "trans_has_updated_trans_table(const THD*)"
"THD::decide_logging_format(TABLE_LIST*)" -> "Query_tables_list::stmt_accessed_table(Query_tables_list::enum_stmt_accessed_table)"
"THD::decide_logging_format(TABLE_LIST*)" -> "String::length() const"
"THD::decide_logging_format(TABLE_LIST*)" -> "my_error(int,myf,...)"
"THD::decide_logging_format(TABLE_LIST*)" -> "Query_tables_list::set_stmt_unsafe(Query_tables_list::enum_binlog_stmt_unsafe)"
"THD::decide_logging_format(TABLE_LIST*)" -> "handler::ha_table_flags() const"
"THD::decide_logging_format(TABLE_LIST*)" -> "String::String()"
"THD::decide_logging_format(TABLE_LIST*)" -> "MYSQL_LOG::is_open()"
"THD::decide_logging_format(TABLE_LIST*)" -> "Query_tables_list::set_stmt_accessed_table(Query_tables_list::enum_stmt_accessed_table)"
"THD::decide_logging_format(TABLE_LIST*)" -> "THD::in_multi_stmt_transaction_mode() const"
"THD::decide_logging_format(TABLE_LIST*)" -> "sqlcom_can_generate_row_events(const THD*)"
"THD::decide_logging_format(TABLE_LIST*)" -> "THD::add_to_binlog_accessed_dbs(const char*)"
"THD::decide_logging_format(TABLE_LIST*)" -> "push_warning_printf(THD*,Sql_condition::enum_warning_level,uint,const char*,...)"
"THD::decide_logging_format(TABLE_LIST*)" -> "THD::is_dml_gtid_compatible(bool,bool,bool) const"
"THD::decide_logging_format(TABLE_LIST*)" -> "handler::has_transactions()"
"THD::decide_logging_format(TABLE_LIST*)" -> "Rpl_filter::db_ok(const char*)"
"THD::decide_logging_format(TABLE_LIST*)" -> "String::append(const char*)"
"THD::decide_logging_format(TABLE_LIST*)" -> "String::is_empty() const"
"THD::decide_logging_format(TABLE_LIST*)" -> "Query_tables_list::get_stmt_unsafe_flags() const"
"THD::decide_logging_format(TABLE_LIST*)" -> "String::replace(uint32,uint32,const char*,uint32)"
"THD::decide_logging_format(TABLE_LIST*)" -> "THD::set_binlog_local_stmt_filter()"
"THD::decide_logging_format(TABLE_LIST*)" -> "Query_tables_list::is_mixed_stmt_unsafe(bool,bool,bool,uint)"
"THD::decide_logging_format(TABLE_LIST*)" -> "THD::set_current_stmt_binlog_format_row_if_mixed()"
"Query_tables_list::is_stmt_unsafe() const" -> "Query_tables_list::get_stmt_unsafe_flags() const"
"THD::add_to_binlog_accessed_dbs(const char*)" -> "List_iterator<T>::operator++(int) [with T = char]"
"THD::add_to_binlog_accessed_dbs(const char*)" -> "push_warning_printf(THD*,Sql_condition::enum_warning_level,uint,const char*,...)"
"THD::add_to_binlog_accessed_dbs(const char*)" -> "List<T>::push_back(T*,MEM_ROOT*) [with T = char,MEM_ROOT = st_mem_root]"
"THD::add_to_binlog_accessed_dbs(const char*)" -> "List_iterator<T>::ref() [with T = char]"
"THD::add_to_binlog_accessed_dbs(const char*)" -> "strdup_root(MEM_ROOT*,const char*)"
"THD::add_to_binlog_accessed_dbs(const char*)" -> "strcmp(const char*,const char*)"
"THD::add_to_binlog_accessed_dbs(const char*)" -> "_current_thd()"
"THD::add_to_binlog_accessed_dbs(const char*)" -> "List_iterator<T>::List_iterator(List<T>&) [with T = char]"
"THD::add_to_binlog_accessed_dbs(const char*)" -> "THD::get_binlog_accessed_db_names()"
"THD::add_to_binlog_accessed_dbs(const char*)" -> "List<T>::List() [with T = char]"
"List<T>::push_back(T*,MEM_ROOT*) [with T = char,MEM_ROOT = st_mem_root]" -> "base_list::push_back(void*,MEM_ROOT*)"
"List_iterator<T>::ref() [with T = char]" -> "base_list_iterator::ref()"
"THD::is_dml_gtid_compatible(bool,bool,bool) const" -> "trans_has_updated_trans_table(const THD*)"
"THD::is_dml_gtid_compatible(bool,bool,bool) const" -> "THD::is_current_stmt_binlog_format_row() const"
"THD::is_dml_gtid_compatible(bool,bool,bool) const" -> "my_error(int,myf,...)"
"handler::has_transactions()" -> "handler::ha_table_flags() const"
"Rpl_filter::db_ok(const char*)" -> "I_List_iterator<T>::I_List_iterator(I_List<T>&) [with T = i_string]"
"Rpl_filter::db_ok(const char*)" -> "base_ilist<T>::is_empty() const [with T = i_string]"
"Rpl_filter::db_ok(const char*)" -> "I_List_iterator<T>::operator++(int) [with T = i_string]"
"I_List_iterator<T>::I_List_iterator(I_List<T>&) [with T = i_string]" -> "base_ilist_iterator<T>::base_ilist_iterator(base_ilist<T>&) [with T = i_string]"
"I_List_iterator<T>::operator++(int) [with T = i_string]" -> "base_ilist_iterator<T>::next() [with T = i_string]"
"String::replace(uint32,uint32,const char*,uint32)" -> "memcpy(void*,const void*,size_t)"
"String::replace(uint32,uint32,const char*,uint32)" -> "memmove(void*,const void*,size_t)"
"String::replace(uint32,uint32,const char*,uint32)" -> "String::realloc(uint32)"
"String::replace(uint32,uint32,const char*,uint32)" -> "bmove_upp(uchar*,const uchar*,size_t)"
"THD::set_current_stmt_binlog_format_row_if_mixed()" -> "THD::set_current_stmt_binlog_format_row()"
"check_lock_and_start_stmt(THD*,Query_tables_list*,TABLE_LIST*)" -> "my_error(int,myf,...)"
"check_lock_and_start_stmt(THD*,Query_tables_list*,TABLE_LIST*)" -> "read_lock_type_for_table(THD*,Query_tables_list*,TABLE_LIST*,bool)"
"has_write_table_auto_increment_not_first_in_pk(TABLE_LIST*)" -> "TABLE_LIST::placeholder()"
"has_write_table_with_auto_increment(TABLE_LIST*)" -> "TABLE_LIST::placeholder()"
"mark_real_tables_as_free_for_reuse(TABLE_LIST*)" -> "TABLE_LIST::placeholder()"
"THD::enter_locked_tables_mode(enum_locked_tables_mode)" -> "MDL_context::set_explicit_duration_for_all_locks()"
"MDL_context::set_explicit_duration_for_all_locks()" -> "I>::remove(T*) [with T = MDL_ticket,B = I_P_List_adapter<MDL_ticket,&MDL_ticket::next_in_context,&MDL_ticket::prev_in_context>,C = I_P_List_null_counter,I = I_P_List_no_push_back<MDL_ticket>]"
"MDL_context::set_explicit_duration_for_all_locks()" -> "L>::I_P_List_iterator(const L&) [with T = MDL_ticket,L = I_P_List<MDL_ticket,I_P_List_adapter<MDL_ticket,&MDL_ticket::next_in_context,&MDL_ticket::prev_in_context> >]"
"MDL_context::set_explicit_duration_for_all_locks()" -> "I>::push_front(T*) [with T = MDL_ticket,B = I_P_List_adapter<MDL_ticket,&MDL_ticket::next_in_context,&MDL_ticket::prev_in_context>,C = I_P_List_null_counter,I = I_P_List_no_push_back<MDL_ticket>]"
"MDL_context::set_explicit_duration_for_all_locks()" -> "I>::swap(I_P_List<T,B,C>&) [with T = MDL_ticket,B = I_P_List_adapter<MDL_ticket,&MDL_ticket::next_in_context,&MDL_ticket::prev_in_context>,C = I_P_List_null_counter,I = I_P_List_no_push_back<MDL_ticket>]"
"MDL_context::set_explicit_duration_for_all_locks()" -> "L>::operator++(int) [with T = MDL_ticket,L = I_P_List<MDL_ticket,I_P_List_adapter<MDL_ticket,&MDL_ticket::next_in_context,&MDL_ticket::prev_in_context> >]"
"has_write_table_with_auto_increment_and_select(TABLE_LIST*)" -> "TABLE_LIST::placeholder()"
"has_write_table_with_auto_increment_and_select(TABLE_LIST*)" -> "has_write_table_with_auto_increment(TABLE_LIST*)"
"TABLE::use_all_columns()" -> "TABLE::column_bitmaps_set(MY_BITMAP*,MY_BITMAP*)"
"THD::reset_n_backup_open_tables_state(Open_tables_backup*)" -> "Open_tables_state::reset_open_tables_state()"
"THD::reset_n_backup_open_tables_state(Open_tables_backup*)" -> "Open_tables_state::set_open_tables_state(Open_tables_state*)"
"THD::reset_n_backup_open_tables_state(Open_tables_backup*)" -> "MDL_context::mdl_savepoint()"
"Open_tables_backup::Open_tables_backup()" -> "Open_tables_state::Open_tables_state()"
"Open_tables_backup::Open_tables_backup()" -> "MDL_savepoint::MDL_savepoint()"
"db_load_routine(THD*,enum_sp_type,sp_name*,sp_head**,sql_mode_t,const char*,const char*,const char*,st_sp_chistics&,const char*,longlong,longlong,Stored_program_creation_ctx*)" -> "Bad_db_error_handler::error_caught() const"
"db_load_routine(THD*,enum_sp_type,sp_name*,sp_head**,sql_mode_t,const char*,const char*,const char*,st_sp_chistics&,const char*,longlong,longlong,Stored_program_creation_ctx*)" -> "mysql_change_db(THD*,const LEX_STRING*,bool)"
"db_load_routine(THD*,enum_sp_type,sp_name*,sp_head**,sql_mode_t,const char*,const char*,const char*,st_sp_chistics&,const char*,longlong,longlong,Stored_program_creation_ctx*)" -> "parse_user(const char*,size_t,char*,size_t*,char*,size_t*)"
"db_load_routine(THD*,enum_sp_type,sp_name*,sp_head**,sql_mode_t,const char*,const char*,const char*,st_sp_chistics&,const char*,longlong,longlong,Stored_program_creation_ctx*)" -> "sp_head::set_info(longlong,longlong,st_sp_chistics*,sql_mode_t)"
"db_load_routine(THD*,enum_sp_type,sp_name*,sp_head**,sql_mode_t,const char*,const char*,const char*,st_sp_chistics&,const char*,longlong,longlong,Stored_program_creation_ctx*)" -> "create_string(THD*,String*,enum_sp_type,const char*,ulong,const char*,ulong,const char*,ulong,const char*,ulong,const char*,ulong,st_sp_chistics*,const LEX_STRING*,const LEX_STRING*,sql_mode_t)"
"db_load_routine(THD*,enum_sp_type,sp_name*,sp_head**,sql_mode_t,const char*,const char*,const char*,st_sp_chistics&,const char*,longlong,longlong,Stored_program_creation_ctx*)" -> "sp_head::optimize()"
"db_load_routine(THD*,enum_sp_type,sp_name*,sp_head**,sql_mode_t,const char*,const char*,const char*,st_sp_chistics&,const char*,longlong,longlong,Stored_program_creation_ctx*)" -> "THD::pop_internal_handler()"
"db_load_routine(THD*,enum_sp_type,sp_name*,sp_head**,sql_mode_t,const char*,const char*,const char*,st_sp_chistics&,const char*,longlong,longlong,Stored_program_creation_ctx*)" -> "mysql_opt_change_db(THD*,const LEX_STRING*,LEX_STRING*,bool,bool*)"
"db_load_routine(THD*,enum_sp_type,sp_name*,sp_head**,sql_mode_t,const char*,const char*,const char*,st_sp_chistics&,const char*,longlong,longlong,Stored_program_creation_ctx*)" -> "Bad_db_error_handler::Bad_db_error_handler()"
"db_load_routine(THD*,enum_sp_type,sp_name*,sp_head**,sql_mode_t,const char*,const char*,const char*,st_sp_chistics&,const char*,longlong,longlong,Stored_program_creation_ctx*)" -> "sp_head::set_definer(const LEX_STRING*,const LEX_STRING*)"
"db_load_routine(THD*,enum_sp_type,sp_name*,sp_head**,sql_mode_t,const char*,const char*,const char*,st_sp_chistics&,const char*,longlong,longlong,Stored_program_creation_ctx*)" -> "my_error(int,myf,...)"
"db_load_routine(THD*,enum_sp_type,sp_name*,sp_head**,sql_mode_t,const char*,const char*,const char*,st_sp_chistics&,const char*,longlong,longlong,Stored_program_creation_ctx*)" -> "sp_compile(THD*,String*,sql_mode_t,Stored_program_creation_ctx*)"
"db_load_routine(THD*,enum_sp_type,sp_name*,sp_head**,sql_mode_t,const char*,const char*,const char*,st_sp_chistics&,const char*,longlong,longlong,Stored_program_creation_ctx*)" -> "String::String()"
"db_load_routine(THD*,enum_sp_type,sp_name*,sp_head**,sql_mode_t,const char*,const char*,const char*,st_sp_chistics&,const char*,longlong,longlong,Stored_program_creation_ctx*)" -> "lex_end(LEX*)"
"db_load_routine(THD*,enum_sp_type,sp_name*,sp_head**,sql_mode_t,const char*,const char*,const char*,st_sp_chistics&,const char*,longlong,longlong,Stored_program_creation_ctx*)" -> "LEX::set_trg_event_type_for_tables()"
"db_load_routine(THD*,enum_sp_type,sp_name*,sp_head**,sql_mode_t,const char*,const char*,const char*,st_sp_chistics&,const char*,longlong,longlong,Stored_program_creation_ctx*)" -> "String::set_charset(const CHARSET_INFO*)"
"db_load_routine(THD*,enum_sp_type,sp_name*,sp_head**,sql_mode_t,const char*,const char*,const char*,st_sp_chistics&,const char*,longlong,longlong,Stored_program_creation_ctx*)" -> "sp_head::set_creation_ctx(Stored_program_creation_ctx*)"
"db_load_routine(THD*,enum_sp_type,sp_name*,sp_head**,sql_mode_t,const char*,const char*,const char*,st_sp_chistics&,const char*,longlong,longlong,Stored_program_creation_ctx*)" -> "strlen(const char*)"
"db_load_routine(THD*,enum_sp_type,sp_name*,sp_head**,sql_mode_t,const char*,const char*,const char*,st_sp_chistics&,const char*,longlong,longlong,Stored_program_creation_ctx*)" -> "THD::push_internal_handler(Internal_error_handler*)"
"db_load_routine(THD*,enum_sp_type,sp_name*,sp_head**,sql_mode_t,const char*,const char*,const char*,st_sp_chistics&,const char*,longlong,longlong,Stored_program_creation_ctx*)" -> "LEX::LEX()"
"db_load_routine(THD*,enum_sp_type,sp_name*,sp_head**,sql_mode_t,const char*,const char*,const char*,st_sp_chistics&,const char*,longlong,longlong,Stored_program_creation_ctx*)" -> "Default_object_creation_ctx::get_client_cs()"
"create_string(THD*,String*,enum_sp_type,const char*,ulong,const char*,ulong,const char*,ulong,const char*,ulong,const char*,ulong,st_sp_chistics*,const LEX_STRING*,const LEX_STRING*,sql_mode_t)" -> "append_identifier(THD*,String*,const char*,uint)"
"create_string(THD*,String*,enum_sp_type,const char*,ulong,const char*,ulong,const char*,ulong,const char*,ulong,const char*,ulong,st_sp_chistics*,const LEX_STRING*,const LEX_STRING*,sql_mode_t)" -> "String::append(char)"
"create_string(THD*,String*,enum_sp_type,const char*,ulong,const char*,ulong,const char*,ulong,const char*,ulong,const char*,ulong,st_sp_chistics*,const LEX_STRING*,const LEX_STRING*,sql_mode_t)" -> "append_definer(THD*,String*,const LEX_STRING*,const LEX_STRING*)"
"create_string(THD*,String*,enum_sp_type,const char*,ulong,const char*,ulong,const char*,ulong,const char*,ulong,const char*,ulong,st_sp_chistics*,const LEX_STRING*,const LEX_STRING*,sql_mode_t)" -> "append_unescaped(String*,const char*,uint)"
"create_string(THD*,String*,enum_sp_type,const char*,ulong,const char*,ulong,const char*,ulong,const char*,ulong,const char*,ulong,st_sp_chistics*,const LEX_STRING*,const LEX_STRING*,sql_mode_t)" -> "String::alloc(uint32)"
"create_string(THD*,String*,enum_sp_type,const char*,ulong,const char*,ulong,const char*,ulong,const char*,ulong,const char*,ulong,st_sp_chistics*,const LEX_STRING*,const LEX_STRING*,sql_mode_t)" -> "String::append(const char*,uint32)"
"append_definer(THD*,String*,const LEX_STRING*,const LEX_STRING*)" -> "append_identifier(THD*,String*,const char*,uint)"
"append_definer(THD*,String*,const LEX_STRING*,const LEX_STRING*)" -> "String::append(char)"
"append_definer(THD*,String*,const LEX_STRING*,const LEX_STRING*)" -> "String::append(const char*,uint32)"
"append_unescaped(String*,const char*,uint)" -> "String::append(char)"
"sp_head::optimize()" -> "List_iterator_fast<T>::List_iterator_fast(List<T>&) [with T = sp_branch_instr]"
"sp_head::optimize()" -> "sp_head::opt_mark()"
"sp_head::optimize()" -> "base_list::empty()"
"sp_head::optimize()" -> "List<T>::List() [with T = sp_branch_instr]"
"sp_head::optimize()" -> "List_iterator_fast<T>::operator++(int) [with T = sp_branch_instr]"
"sp_head::optimize()" -> "sp_instr::opt_is_marked() const"
"sp_head::optimize()" -> "sp_head::get_instr(uint)"
"sp_head::optimize()" -> "Dynamic_array<Elem>::elements(uint) [with Elem = sp_instr*,uint = unsigned int]"
"sp_head::optimize()" -> "Dynamic_array<Elem>::set(uint,const Elem&) [with Elem = sp_instr*,uint = unsigned int]"
"List_iterator_fast<T>::List_iterator_fast(List<T>&) [with T = sp_branch_instr]" -> "base_list_iterator::base_list_iterator(base_list&)"
"sp_head::opt_mark()" -> "sp_head::get_instr(uint)"
"sp_head::opt_mark()" -> "List<T>::List() [with T = sp_instr]"
"sp_head::opt_mark()" -> "List<T>::pop() [with T = sp_instr]"
"sp_head::opt_mark()" -> "List<T>::push_front(T*) [with T = sp_instr]"
"sp_head::opt_mark()" -> "sp_instr::opt_is_marked() const"
"sp_head::get_instr(uint)" -> "Dynamic_array<Elem>::at(int) [with Elem = sp_instr*]"
"sp_head::get_instr(uint)" -> "Dynamic_array<Elem>::elements() const [with Elem = sp_instr*]"
"List<T>::List() [with T = sp_instr]" -> "base_list::base_list()"
"List<T>::pop() [with T = sp_instr]" -> "base_list::pop()"
"List<T>::push_front(T*) [with T = sp_instr]" -> "base_list::push_front(void*)"
"List<T>::List() [with T = sp_branch_instr]" -> "base_list::base_list()"
"List_iterator_fast<T>::operator++(int) [with T = sp_branch_instr]" -> "base_list_iterator::next_fast()"
"Dynamic_array<Elem>::set(uint,const Elem&) [with Elem = sp_instr*,uint = unsigned int]" -> "set_dynamic(DYNAMIC_ARRAY*,const void*,uint)"
"Bad_db_error_handler::Bad_db_error_handler()" -> "Internal_error_handler::Internal_error_handler()"
"sp_compile(THD*,String*,sql_mode_t,Stored_program_creation_ctx*)" -> "Parser_state::Parser_state()"
"sp_compile(THD*,String*,sql_mode_t,Stored_program_creation_ctx*)" -> "parse_sql(THD*,Parser_state*,Object_creation_ctx*)"
"sp_compile(THD*,String*,sql_mode_t,Stored_program_creation_ctx*)" -> "String::length() const"
"sp_compile(THD*,String*,sql_mode_t,Stored_program_creation_ctx*)" -> "Silence_deprecated_warning::Silence_deprecated_warning()"
"sp_compile(THD*,String*,sql_mode_t,Stored_program_creation_ctx*)" -> "THD::pop_internal_handler()"
"sp_compile(THD*,String*,sql_mode_t,Stored_program_creation_ctx*)" -> "Parser_state::init(THD*,char*,unsigned int)"
"sp_compile(THD*,String*,sql_mode_t,Stored_program_creation_ctx*)" -> "lex_start(THD*)"
"sp_compile(THD*,String*,sql_mode_t,Stored_program_creation_ctx*)" -> "THD::push_internal_handler(Internal_error_handler*)"
"sp_compile(THD*,String*,sql_mode_t,Stored_program_creation_ctx*)" -> "String::c_ptr()"
"Silence_deprecated_warning::Silence_deprecated_warning()" -> "Internal_error_handler::Internal_error_handler()"
"sp_cache_insert(sp_cache**,sp_head*)" -> "sp_cache::sp_cache()"
"sp_cache_insert(sp_cache**,sp_head*)" -> "sp_head::set_sp_cache_version(ulong)"
"sp_cache_insert(sp_cache**,sp_head*)" -> "sp_cache::insert(sp_head*)"
"sp_cache::sp_cache()" -> "sp_cache::init()"
"sp_cache::init()" -> "_my_hash_init(HASH*,uint,CHARSET_INFO*,my_hash_function,ulong,size_t,size_t,my_hash_get_key,void (*)(void*),uint)"
"sp_cache::insert(sp_head*)" -> "my_hash_insert(HASH*,const uchar*)"
"sp_cache_lookup(sp_cache**,sp_name*)" -> "sp_cache::lookup(char*,uint)"
"sp_cache::lookup(char*,uint)" -> "my_hash_search(const HASH*,const uchar*,size_t)"
"close_tables_for_reopen(THD*,TABLE_LIST**,const MDL_savepoint&)" -> "sp_remove_not_own_routines(Query_tables_list*)"
"close_tables_for_reopen(THD*,TABLE_LIST**,const MDL_savepoint&)" -> "Query_tables_list::chop_off_not_own_tables()"
"close_tables_for_reopen(THD*,TABLE_LIST**,const MDL_savepoint&)" -> "TABLE_LIST::cleanup_items()"
"close_tables_for_reopen(THD*,TABLE_LIST**,const MDL_savepoint&)" -> "close_thread_tables(THD*)"
"close_tables_for_reopen(THD*,TABLE_LIST**,const MDL_savepoint&)" -> "Query_tables_list::first_not_own_table()"
"close_tables_for_reopen(THD*,TABLE_LIST**,const MDL_savepoint&)" -> "MDL_context::rollback_to_savepoint(const MDL_savepoint&)"
"sp_remove_not_own_routines(Query_tables_list*)" -> "my_hash_delete(HASH*,uchar*)"
"delete_precheck(THD*,TABLE_LIST*)" -> "check_one_table_access(THD*,ulong,TABLE_LIST*)"
"mysql_prepare_delete(THD*,TABLE_LIST*,Item**)" -> "st_select_lex::fix_prepare_information(THD*,Item**,Item**)"
"mysql_prepare_delete(THD*,TABLE_LIST*,Item**)" -> "setup_ftfuncs(SELECT_LEX*)"
"mysql_prepare_delete(THD*,TABLE_LIST*,Item**)" -> "setup_tables_and_check_access(THD*,Name_resolution_context*,List<TABLE_LIST>*,TABLE_LIST*,TABLE_LIST**,bool,ulong,ulong)"
"mysql_prepare_delete(THD*,TABLE_LIST*,Item**)" -> "update_non_unique_table_error(TABLE_LIST*,const char*,TABLE_LIST*)"
"mysql_prepare_delete(THD*,TABLE_LIST*,Item**)" -> "setup_conds(THD*,TABLE_LIST*,TABLE_LIST*,Item**)"
"mysql_prepare_delete(THD*,TABLE_LIST*,Item**)" -> "unique_table(THD*,TABLE_LIST*,TABLE_LIST*,bool)"
"mysql_prepare_delete(THD*,TABLE_LIST*,Item**)" -> "fix_inner_refs(THD*,List<Item>&,SELECT_LEX*,Ref_ptr_array,ORDER*)"
"mysql_prepare_delete(THD*,TABLE_LIST*,Item**)" -> "check_key_in_view(THD*,TABLE_LIST*)"
"mysql_prepare_delete(THD*,TABLE_LIST*,Item**)" -> "my_error(int,myf,...)"
"mysql_prepare_delete(THD*,TABLE_LIST*,Item**)" -> "List<T>::List() [with T = Item]"
"st_select_lex::fix_prepare_information(THD*,Item**,Item**)" -> "has_trivial_destructor>::reserve(size_t) [with Element_type = st_order*,bool has_trivial_destructor = true,size_t = long unsigned int]"
"st_select_lex::fix_prepare_information(THD*,Item**,Item**)" -> "Query_arena::alloc(size_t)"
"st_select_lex::fix_prepare_information(THD*,Item**,Item**)" -> "Query_arena::is_conventional() const"
"st_select_lex::fix_prepare_information(THD*,Item**,Item**)" -> "fix_prepare_info_in_table_list(THD*,TABLE_LIST*)"
"st_select_lex::fix_prepare_information(THD*,Item**,Item**)" -> "has_trivial_destructor>::push_back(const Element_type&) [with Element_type = st_order*,bool has_trivial_destructor = true]"
"st_select_lex::fix_prepare_information(THD*,Item**,Item**)" -> "has_trivial_destructor>::Mem_root_array(MEM_ROOT*) [with Element_type = st_order*,bool has_trivial_destructor = true,MEM_ROOT = st_mem_root]"
"has_trivial_destructor>::reserve(size_t) [with Element_type = st_order*,bool has_trivial_destructor = true,size_t = long unsigned int]" -> "has_trivial_destructor>::element_size() const [with Element_type = st_order*,bool has_trivial_destructor = true,size_t = long unsigned int]"
"has_trivial_destructor>::reserve(size_t) [with Element_type = st_order*,bool has_trivial_destructor = true,size_t = long unsigned int]" -> "alloc_root(MEM_ROOT*,size_t)"
"fix_prepare_info_in_table_list(THD*,TABLE_LIST*)" -> "TABLE_LIST::set_join_cond(Item*)"
"fix_prepare_info_in_table_list(THD*,TABLE_LIST*)" -> "TABLE_LIST::join_cond() const"
"fix_prepare_info_in_table_list(THD*,TABLE_LIST*)" -> "fix_prepare_info_in_table_list(THD*,TABLE_LIST*)"
"has_trivial_destructor>::push_back(const Element_type&) [with Element_type = st_order*,bool has_trivial_destructor = true]" -> "has_trivial_destructor>::reserve(size_t) [with Element_type = st_order*,bool has_trivial_destructor = true,size_t = long unsigned int]"
"setup_ftfuncs(SELECT_LEX*)" -> "List_iterator<T>::rewind() [with T = Item_func_match]"
"setup_ftfuncs(SELECT_LEX*)" -> "Item_func_match::fix_index()"
"setup_ftfuncs(SELECT_LEX*)" -> "List_iterator<T>::operator++(int) [with T = Item_func_match]"
"setup_ftfuncs(SELECT_LEX*)" -> "List_iterator<T>::List_iterator(List<T>&) [with T = Item_func_match]"
"List_iterator<T>::rewind() [with T = Item_func_match]" -> "base_list_iterator::rewind()"
"Item_func_match::fix_index()" -> "Item_func_match::allows_search_on_non_indexed_columns(TABLE*)"
"Item_func_match::fix_index()" -> "_current_thd()"
"Item_func_match::fix_index()" -> "my_message(uint,const char*,myf)"
"Item_func_match::fix_index()" -> "Bitmap<64u>::is_set(uint) const"
"Item_func_match::allows_search_on_non_indexed_columns(TABLE*)" -> "handler::ha_table_flags() const"
"List_iterator<T>::operator++(int) [with T = Item_func_match]" -> "base_list_iterator::next()"
"List_iterator<T>::List_iterator(List<T>&) [with T = Item_func_match]" -> "base_list_iterator::base_list_iterator(base_list&)"
"setup_tables_and_check_access(THD*,Name_resolution_context*,List<TABLE_LIST>*,TABLE_LIST*,TABLE_LIST**,bool,ulong,ulong)" -> "setup_tables(THD*,Name_resolution_context*,List<TABLE_LIST>*,TABLE_LIST*,TABLE_LIST**,bool)"
"setup_tables_and_check_access(THD*,Name_resolution_context*,List<TABLE_LIST>*,TABLE_LIST*,TABLE_LIST**,bool,ulong,ulong)" -> "check_single_table_access(THD*,ulong,TABLE_LIST*,bool)"
"setup_tables_and_check_access(THD*,Name_resolution_context*,List<TABLE_LIST>*,TABLE_LIST*,TABLE_LIST**,bool,ulong,ulong)" -> "TABLE_LIST::hide_view_error(THD*)"
"setup_tables(THD*,Name_resolution_context*,List<TABLE_LIST>*,TABLE_LIST*,TABLE_LIST**,bool)" -> "setup_natural_join_row_types(THD*,List<TABLE_LIST>*,Name_resolution_context*)"
"setup_tables(THD*,Name_resolution_context*,List<TABLE_LIST>*,TABLE_LIST*,TABLE_LIST**,bool)" -> "Prepared_stmt_arena_holder::Prepared_stmt_arena_holder(THD*,bool)"
"setup_tables(THD*,Name_resolution_context*,List<TABLE_LIST>*,TABLE_LIST*,TABLE_LIST**,bool)" -> "setup_table_map(TABLE*,TABLE_LIST*,uint)"
"setup_tables(THD*,Name_resolution_context*,List<TABLE_LIST>*,TABLE_LIST*,TABLE_LIST**,bool)" -> "TABLE_LIST::top_table()"
"setup_tables(THD*,Name_resolution_context*,List<TABLE_LIST>*,TABLE_LIST*,TABLE_LIST**,bool)" -> "TABLE_LIST::setup_underlying(THD*)"
"setup_tables(THD*,Name_resolution_context*,List<TABLE_LIST>*,TABLE_LIST*,TABLE_LIST**,bool)" -> "TABLE_LIST::process_index_hints(TABLE*)"
"setup_tables(THD*,Name_resolution_context*,List<TABLE_LIST>*,TABLE_LIST*,TABLE_LIST**,bool)" -> "my_error(int,myf,...)"
"setup_tables(THD*,Name_resolution_context*,List<TABLE_LIST>*,TABLE_LIST*,TABLE_LIST**,bool)" -> "make_leaves_list(TABLE_LIST**,TABLE_LIST*)"
"setup_natural_join_row_types(THD*,List<TABLE_LIST>*,Name_resolution_context*)" -> "List_iterator_fast<T>::operator++(int) [with T = TABLE_LIST]"
"setup_natural_join_row_types(THD*,List<TABLE_LIST>*,Name_resolution_context*)" -> "TABLE_LIST::first_leaf_for_name_resolution()"
"setup_natural_join_row_types(THD*,List<TABLE_LIST>*,Name_resolution_context*)" -> "store_top_level_join_columns(THD*,TABLE_LIST*,TABLE_LIST*,TABLE_LIST*)"
"setup_natural_join_row_types(THD*,List<TABLE_LIST>*,Name_resolution_context*)" -> "List_iterator_fast<T>::List_iterator_fast(List<T>&) [with T = TABLE_LIST]"
"store_top_level_join_columns(THD*,TABLE_LIST*,TABLE_LIST*,TABLE_LIST*)" -> "TABLE_LIST::join_cond() const"
"store_top_level_join_columns(THD*,TABLE_LIST*,TABLE_LIST*,TABLE_LIST*)" -> "Prepared_stmt_arena_holder::Prepared_stmt_arena_holder(THD*,bool)"
"store_top_level_join_columns(THD*,TABLE_LIST*,TABLE_LIST*,TABLE_LIST*)" -> "mark_common_columns(THD*,TABLE_LIST*,TABLE_LIST*,List<String>*,uint*)"
"store_top_level_join_columns(THD*,TABLE_LIST*,TABLE_LIST*,TABLE_LIST*)" -> "store_natural_using_join_columns(THD*,TABLE_LIST*,TABLE_LIST*,TABLE_LIST*,List<String>*,uint)"
"store_top_level_join_columns(THD*,TABLE_LIST*,TABLE_LIST*,TABLE_LIST*)" -> "store_top_level_join_columns(THD*,TABLE_LIST*,TABLE_LIST*,TABLE_LIST*)"
"store_top_level_join_columns(THD*,TABLE_LIST*,TABLE_LIST*,TABLE_LIST*)" -> "TABLE_LIST::set_join_cond(Item*)"
"store_top_level_join_columns(THD*,TABLE_LIST*,TABLE_LIST*,TABLE_LIST*)" -> "TABLE_LIST::last_leaf_for_name_resolution()"
"store_top_level_join_columns(THD*,TABLE_LIST*,TABLE_LIST*,TABLE_LIST*)" -> "Item_int::Item_int(longlong,uint)"
"store_top_level_join_columns(THD*,TABLE_LIST*,TABLE_LIST*,TABLE_LIST*)" -> "List_iterator_fast<T>::operator++(int) [with T = TABLE_LIST]"
"store_top_level_join_columns(THD*,TABLE_LIST*,TABLE_LIST*,TABLE_LIST*)" -> "List_iterator_fast<T>::List_iterator_fast(List<T>&) [with T = TABLE_LIST]"
"store_top_level_join_columns(THD*,TABLE_LIST*,TABLE_LIST*,TABLE_LIST*)" -> "TABLE_LIST::first_leaf_for_name_resolution()"
"Prepared_stmt_arena_holder::Prepared_stmt_arena_holder(THD*,bool)" -> "Query_arena::Query_arena()"
"Prepared_stmt_arena_holder::Prepared_stmt_arena_holder(THD*,bool)" -> "THD::set_n_backup_active_arena(Query_arena*,Query_arena*)"
"Prepared_stmt_arena_holder::Prepared_stmt_arena_holder(THD*,bool)" -> "Query_arena::is_conventional() const"
"mark_common_columns(THD*,TABLE_LIST*,TABLE_LIST*,List<String>*,uint*)" -> "set_new_item_local_context(THD*,Item_ident*,TABLE_LIST*)"
"mark_common_columns(THD*,TABLE_LIST*,TABLE_LIST*,List<String>*,uint*)" -> "Natural_join_column::field()"
"mark_common_columns(THD*,TABLE_LIST*,TABLE_LIST*,List<String>*,uint*)" -> "Item_func_eq::Item_func_eq(Item*,Item*)"
"mark_common_columns(THD*,TABLE_LIST*,TABLE_LIST*,List<String>*,uint*)" -> "Natural_join_column::name()"
"mark_common_columns(THD*,TABLE_LIST*,TABLE_LIST*,List<String>*,uint*)" -> "bitmap_set_bit(MY_BITMAP*,uint)"
"mark_common_columns(THD*,TABLE_LIST*,TABLE_LIST*,List<String>*,uint*)" -> "Field_iterator_table_ref::Field_iterator_table_ref()"
"mark_common_columns(THD*,TABLE_LIST*,TABLE_LIST*,List<String>*,uint*)" -> "add_join_on(TABLE_LIST*,Item*)"
"mark_common_columns(THD*,TABLE_LIST*,TABLE_LIST*,List<String>*,uint*)" -> "test_if_string_in_list(const char*,List<String>*)"
"mark_common_columns(THD*,TABLE_LIST*,TABLE_LIST*,List<String>*,uint*)" -> "Natural_join_column::create_item(THD*)"
"mark_common_columns(THD*,TABLE_LIST*,TABLE_LIST*,List<String>*,uint*)" -> "Bitmap<64u>::merge(const Bitmap<64u>&)"
"mark_common_columns(THD*,TABLE_LIST*,TABLE_LIST*,List<String>*,uint*)" -> "Field_iterator_table_ref::end_of_fields()"
"mark_common_columns(THD*,TABLE_LIST*,TABLE_LIST*,List<String>*,uint*)" -> "Field_iterator_table_ref::set(TABLE_LIST*)"
"mark_common_columns(THD*,TABLE_LIST*,TABLE_LIST*,List<String>*,uint*)" -> "Field_iterator_table_ref::next()"
"mark_common_columns(THD*,TABLE_LIST*,TABLE_LIST*,List<String>*,uint*)" -> "Bitmap<64u>::intersect(const Bitmap<64u>&)"
"mark_common_columns(THD*,TABLE_LIST*,TABLE_LIST*,List<String>*,uint*)" -> "Prepared_stmt_arena_holder::Prepared_stmt_arena_holder(THD*,bool)"
"mark_common_columns(THD*,TABLE_LIST*,TABLE_LIST*,List<String>*,uint*)" -> "Field_iterator_table_ref::get_or_create_column_ref(THD*,TABLE_LIST*)"
"mark_common_columns(THD*,TABLE_LIST*,TABLE_LIST*,List<String>*,uint*)" -> "my_error(int,myf,...)"
"set_new_item_local_context(THD*,Item_ident*,TABLE_LIST*)" -> "Name_resolution_context::Name_resolution_context()"
"set_new_item_local_context(THD*,Item_ident*,TABLE_LIST*)" -> "Name_resolution_context::init()"
"Field_iterator_table_ref::Field_iterator_table_ref()" -> "Field_iterator::Field_iterator()"
"Field_iterator_table_ref::Field_iterator_table_ref()" -> "Field_iterator_view::Field_iterator_view()"
"Field_iterator_table_ref::Field_iterator_table_ref()" -> "Field_iterator_natural_join::Field_iterator_natural_join()"
"Field_iterator_table_ref::Field_iterator_table_ref()" -> "Field_iterator_table::Field_iterator_table()"
"Field_iterator::Field_iterator()" -> "Sql_alloc::Sql_alloc()"
"Field_iterator_view::Field_iterator_view()" -> "Field_iterator::Field_iterator()"
"Field_iterator_natural_join::Field_iterator_natural_join()" -> "List_iterator_fast<T>::List_iterator_fast() [with T = Natural_join_column]"
"Field_iterator_natural_join::Field_iterator_natural_join()" -> "Field_iterator::Field_iterator()"
"List_iterator_fast<T>::List_iterator_fast() [with T = Natural_join_column]" -> "base_list_iterator::base_list_iterator()"
"Field_iterator_table::Field_iterator_table()" -> "Field_iterator::Field_iterator()"
"test_if_string_in_list(const char*,List<String>*)" -> "strlen(const char*)"
"test_if_string_in_list(const char*,List<String>*)" -> "String::ptr() const"
"test_if_string_in_list(const char*,List<String>*)" -> "String::length() const"
"test_if_string_in_list(const char*,List<String>*)" -> "List_iterator<T>::List_iterator(List<T>&) [with T = String]"
"test_if_string_in_list(const char*,List<String>*)" -> "List_iterator<T>::operator++(int) [with T = String]"
"Natural_join_column::create_item(THD*)" -> "create_view_field(THD*,TABLE_LIST*,Item**,const char*,Name_resolution_context*)"
"create_view_field(THD*,TABLE_LIST*,Item**,const char*,Name_resolution_context*)" -> "Item_direct_view_ref::Item_direct_view_ref(Name_resolution_context*,Item**,const char*,const char*,const char*)"
"Item_direct_view_ref::Item_direct_view_ref(Name_resolution_context*,Item**,const char*,const char*,const char*)" -> "Item_direct_ref::Item_direct_ref(Name_resolution_context*,Item**,const char*,const char*,bool)"
"Item_direct_ref::Item_direct_ref(Name_resolution_context*,Item**,const char*,const char*,bool)" -> "Item_ref::Item_ref(Name_resolution_context*,Item**,const char*,const char*,bool)"
"Item_ref::Item_ref(Name_resolution_context*,Item**,const char*,const char*,bool)" -> "Item_ident::Item_ident(Name_resolution_context*,const char*,const char*,const char*)"
"Item_ref::Item_ref(Name_resolution_context*,Item**,const char*,const char*,bool)" -> "Item_ref::set_properties()"
"Item_ref::set_properties()" -> "DTCollation::set(DTCollation&)"
"Field_iterator_table_ref::set(TABLE_LIST*)" -> "TABLE_LIST::first_leaf_for_name_resolution()"
"Field_iterator_table_ref::set(TABLE_LIST*)" -> "TABLE_LIST::last_leaf_for_name_resolution()"
"Field_iterator_table_ref::set(TABLE_LIST*)" -> "Field_iterator_table_ref::set_field_iterator()"
"Field_iterator_table_ref::next()" -> "Field_iterator_table_ref::set_field_iterator()"
"Field_iterator_table_ref::get_or_create_column_ref(THD*,TABLE_LIST*)" -> "Natural_join_column::Natural_join_column(Item_field*,TABLE_LIST*)"
"Field_iterator_table_ref::get_or_create_column_ref(THD*,TABLE_LIST*)" -> "List<T>::push_back(T*) [with T = Natural_join_column]"
"Field_iterator_table_ref::get_or_create_column_ref(THD*,TABLE_LIST*)" -> "Field_iterator_natural_join::column_ref()"
"Field_iterator_table_ref::get_or_create_column_ref(THD*,TABLE_LIST*)" -> "Item_field::Item_field(THD*,Name_resolution_context*,Field*)"
"Field_iterator_table_ref::get_or_create_column_ref(THD*,TABLE_LIST*)" -> "Field_iterator_view::field_translator()"
"Field_iterator_table_ref::get_or_create_column_ref(THD*,TABLE_LIST*)" -> "Field_iterator_table::field()"
"Field_iterator_table_ref::get_or_create_column_ref(THD*,TABLE_LIST*)" -> "Natural_join_column::Natural_join_column(Field_translator*,TABLE_LIST*)"
"Field_iterator_table_ref::get_or_create_column_ref(THD*,TABLE_LIST*)" -> "List<T>::List() [with T = Natural_join_column]"
"Natural_join_column::Natural_join_column(Item_field*,TABLE_LIST*)" -> "Sql_alloc::Sql_alloc()"
"List<T>::push_back(T*) [with T = Natural_join_column]" -> "base_list::push_back(void*)"
"Item_field::Item_field(THD*,Name_resolution_context*,Field*)" -> "Simple_cstring::set(const char*)"
"Item_field::Item_field(THD*,Name_resolution_context*,Field*)" -> "Query_arena::strdup(const char*)"
"Item_field::Item_field(THD*,Name_resolution_context*,Field*)" -> "Item_field::set_field(Field*)"
"Item_field::Item_field(THD*,Name_resolution_context*,Field*)" -> "Item_ident::Item_ident(Name_resolution_context*,const char*,const char*,const char*)"
"Query_arena::strdup(const char*)" -> "strdup_root(MEM_ROOT*,const char*)"
"Item_field::set_field(Field*)" -> "DTCollation::set(const CHARSET_INFO*,Derivation,uint)"
"Item_field::set_field(Field*)" -> "adjust_max_effective_column_length(Field*,uint32)"
"Item_field::set_field(Field*)" -> "Field::maybe_null() const"
"Item_field::set_field(Field*)" -> "Item::fix_char_length(uint32)"
"Field::maybe_null() const" -> "Field::real_maybe_null() const"
"Natural_join_column::Natural_join_column(Field_translator*,TABLE_LIST*)" -> "Sql_alloc::Sql_alloc()"
"List<T>::List() [with T = Natural_join_column]" -> "base_list::base_list()"
"store_natural_using_join_columns(THD*,TABLE_LIST*,TABLE_LIST*,TABLE_LIST*,List<String>*,uint)" -> "Field_iterator_table_ref::set(TABLE_LIST*)"
"store_natural_using_join_columns(THD*,TABLE_LIST*,TABLE_LIST*,TABLE_LIST*,List<String>*,uint)" -> "List_iterator_fast<T>::List_iterator_fast(List<T>&) [with T = Natural_join_column]"
"store_natural_using_join_columns(THD*,TABLE_LIST*,TABLE_LIST*,TABLE_LIST*,List<String>*,uint)" -> "Field_iterator_table_ref::next()"
"store_natural_using_join_columns(THD*,TABLE_LIST*,TABLE_LIST*,TABLE_LIST*,List<String>*,uint)" -> "List<T>::List() [with T = Natural_join_column]"
"store_natural_using_join_columns(THD*,TABLE_LIST*,TABLE_LIST*,TABLE_LIST*,List<String>*,uint)" -> "Field_iterator_table_ref::get_natural_column_ref()"
"store_natural_using_join_columns(THD*,TABLE_LIST*,TABLE_LIST*,TABLE_LIST*,List<String>*,uint)" -> "Field_iterator_table_ref::Field_iterator_table_ref()"
"store_natural_using_join_columns(THD*,TABLE_LIST*,TABLE_LIST*,TABLE_LIST*,List<String>*,uint)" -> "Prepared_stmt_arena_holder::Prepared_stmt_arena_holder(THD*,bool)"
"store_natural_using_join_columns(THD*,TABLE_LIST*,TABLE_LIST*,TABLE_LIST*,List<String>*,uint)" -> "_current_thd()"
"store_natural_using_join_columns(THD*,TABLE_LIST*,TABLE_LIST*,TABLE_LIST*,List<String>*,uint)" -> "List<T>::concat(List<T>*) [with T = Natural_join_column]"
"store_natural_using_join_columns(THD*,TABLE_LIST*,TABLE_LIST*,TABLE_LIST*,List<String>*,uint)" -> "List_iterator_fast<T>::operator++(int) [with T = Natural_join_column]"
"store_natural_using_join_columns(THD*,TABLE_LIST*,TABLE_LIST*,TABLE_LIST*,List<String>*,uint)" -> "String::c_ptr()"
"store_natural_using_join_columns(THD*,TABLE_LIST*,TABLE_LIST*,TABLE_LIST*,List<String>*,uint)" -> "my_error(int,myf,...)"
"store_natural_using_join_columns(THD*,TABLE_LIST*,TABLE_LIST*,TABLE_LIST*,List<String>*,uint)" -> "Natural_join_column::name()"
"store_natural_using_join_columns(THD*,TABLE_LIST*,TABLE_LIST*,TABLE_LIST*,List<String>*,uint)" -> "List_iterator_fast<T>::operator++(int) [with T = String]"
"store_natural_using_join_columns(THD*,TABLE_LIST*,TABLE_LIST*,TABLE_LIST*,List<String>*,uint)" -> "Field_iterator_table_ref::end_of_fields()"
"store_natural_using_join_columns(THD*,TABLE_LIST*,TABLE_LIST*,TABLE_LIST*,List<String>*,uint)" -> "List<T>::push_back(T*) [with T = Natural_join_column]"
"store_natural_using_join_columns(THD*,TABLE_LIST*,TABLE_LIST*,TABLE_LIST*,List<String>*,uint)" -> "List_iterator_fast<T>::List_iterator_fast(List<T>&) [with T = String]"
"List_iterator_fast<T>::List_iterator_fast(List<T>&) [with T = Natural_join_column]" -> "base_list_iterator::base_list_iterator(base_list&)"
"Field_iterator_table_ref::get_natural_column_ref()" -> "Field_iterator_natural_join::column_ref()"
"List<T>::concat(List<T>*) [with T = Natural_join_column]" -> "base_list::concat(base_list*)"
"base_list::concat(base_list*)" -> "base_list::is_empty() const"
"List_iterator_fast<T>::operator++(int) [with T = Natural_join_column]" -> "base_list_iterator::next_fast()"
"List_iterator_fast<T>::operator++(int) [with T = String]" -> "base_list_iterator::next_fast()"
"List_iterator_fast<T>::List_iterator_fast(List<T>&) [with T = String]" -> "base_list_iterator::base_list_iterator(base_list&)"
"Item_int::Item_int(longlong,uint)" -> "Item_num::Item_num()"
"setup_table_map(TABLE*,TABLE_LIST*,uint)" -> "Bitmap<64u>::clear_all()"
"TABLE_LIST::setup_underlying(THD*)" -> "TABLE_LIST::setup_underlying(THD*)"
"TABLE_LIST::setup_underlying(THD*)" -> "check_stack_overrun(THD*,long int,uchar*)"
"TABLE_LIST::setup_underlying(THD*)" -> "List_iterator_fast<T>::operator++(int) [with T = Item_func_match]"
"TABLE_LIST::setup_underlying(THD*)" -> "List_iterator_fast<T>::List_iterator_fast(List<T>&) [with T = Item]"
"TABLE_LIST::setup_underlying(THD*)" -> "Query_arena::alloc(size_t)"
"TABLE_LIST::setup_underlying(THD*)" -> "List<T>::push_front(T*) [with T = Item_func_match]"
"TABLE_LIST::setup_underlying(THD*)" -> "Simple_cstring::ptr() const"
"TABLE_LIST::setup_underlying(THD*)" -> "List_iterator_fast<T>::operator++(int) [with T = Item]"
"TABLE_LIST::setup_underlying(THD*)" -> "List_iterator_fast<T>::List_iterator_fast(List<T>&) [with T = Item_func_match]"
"List_iterator_fast<T>::operator++(int) [with T = Item_func_match]" -> "base_list_iterator::next_fast()"
"List<T>::push_front(T*) [with T = Item_func_match]" -> "base_list::push_front(void*)"
"List_iterator_fast<T>::List_iterator_fast(List<T>&) [with T = Item_func_match]" -> "base_list_iterator::base_list_iterator(base_list&)"
"TABLE_LIST::process_index_hints(TABLE*)" -> "List_iterator<T>::operator++(int) [with T = Index_hint]"
"TABLE_LIST::process_index_hints(TABLE*)" -> "Bitmap<64u>::subtract(const Bitmap<64u>&)"
"TABLE_LIST::process_index_hints(TABLE*)" -> "Bitmap<64u>::is_clear_all() const"
"TABLE_LIST::process_index_hints(TABLE*)" -> "List_iterator<T>::List_iterator(List<T>&) [with T = Index_hint]"
"TABLE_LIST::process_index_hints(TABLE*)" -> "Bitmap<64u>::intersect(const Bitmap<64u>&)"
"TABLE_LIST::process_index_hints(TABLE*)" -> "Bitmap<64u>::Bitmap()"
"TABLE_LIST::process_index_hints(TABLE*)" -> "my_error(int,myf,...)"
"TABLE_LIST::process_index_hints(TABLE*)" -> "Bitmap<64u>::merge(const Bitmap<64u>&)"
"TABLE_LIST::process_index_hints(TABLE*)" -> "find_type(const TYPELIB*,const char*,uint,bool)"
"TABLE_LIST::process_index_hints(TABLE*)" -> "Bitmap<64u>::set_bit(uint)"
"TABLE_LIST::process_index_hints(TABLE*)" -> "Bitmap<64u>::clear_all()"
"List_iterator<T>::operator++(int) [with T = Index_hint]" -> "base_list_iterator::next()"
"List_iterator<T>::List_iterator(List<T>&) [with T = Index_hint]" -> "base_list_iterator::base_list_iterator(base_list&)"
"make_leaves_list(TABLE_LIST**,TABLE_LIST*)" -> "make_leaves_list(TABLE_LIST**,TABLE_LIST*)"
"TABLE_LIST::hide_view_error(THD*)" -> "Diagnostics_area::sql_errno() const"
"TABLE_LIST::hide_view_error(THD*)" -> "THD::get_stmt_da()"
"TABLE_LIST::hide_view_error(THD*)" -> "my_error(int,myf,...)"
"TABLE_LIST::hide_view_error(THD*)" -> "TABLE_LIST::top_table()"
"TABLE_LIST::hide_view_error(THD*)" -> "THD::get_internal_handler()"
"TABLE_LIST::hide_view_error(THD*)" -> "THD::clear_error()"
"update_non_unique_table_error(TABLE_LIST*,const char*,TABLE_LIST*)" -> "TABLE_LIST::top_table()"
"update_non_unique_table_error(TABLE_LIST*,const char*,TABLE_LIST*)" -> "my_error(int,myf,...)"
"update_non_unique_table_error(TABLE_LIST*,const char*,TABLE_LIST*)" -> "strncmp(const char*,const char*,size_t)"
"setup_conds(THD*,TABLE_LIST*,TABLE_LIST*,Item**)" -> "LEX::which_check_option_applicable()"
"setup_conds(THD*,TABLE_LIST*,TABLE_LIST*,Item**)" -> "TABLE_LIST::join_cond_ref()"
"setup_conds(THD*,TABLE_LIST*,TABLE_LIST*,Item**)" -> "TABLE_LIST::prepare_check_option(THD*)"
"setup_conds(THD*,TABLE_LIST*,TABLE_LIST*,Item**)" -> "List<T>::head() [with T = TABLE_LIST]"
"setup_conds(THD*,TABLE_LIST*,TABLE_LIST*,Item**)" -> "THD::is_error() const"
"setup_conds(THD*,TABLE_LIST*,TABLE_LIST*,Item**)" -> "THD::change_item_tree(Item**,Item*)"
"setup_conds(THD*,TABLE_LIST*,TABLE_LIST*,Item**)" -> "TABLE_LIST::join_cond() const"
"setup_conds(THD*,TABLE_LIST*,TABLE_LIST*,Item**)" -> "TABLE_LIST::top_table()"
"setup_conds(THD*,TABLE_LIST*,TABLE_LIST*,Item**)" -> "TABLE_LIST::prepare_where(THD*,Item**,bool)"
"TABLE_LIST::prepare_check_option(THD*)" -> "TABLE_LIST::prep_check_option(THD*,uint8)"
"TABLE_LIST::prep_check_option(THD*,uint8)" -> "Prepared_stmt_arena_holder::Prepared_stmt_arena_holder(THD*,bool)"
"TABLE_LIST::prep_check_option(THD*,uint8)" -> "merge_on_conds(THD*,TABLE_LIST*,bool)"
"TABLE_LIST::prep_check_option(THD*,uint8)" -> "and_conds(Item*,Item*)"
"TABLE_LIST::prep_check_option(THD*,uint8)" -> "TABLE_LIST::prep_check_option(THD*,uint8)"
"merge_on_conds(THD*,TABLE_LIST*,bool)" -> "merge_on_conds(THD*,TABLE_LIST*,bool)"
"merge_on_conds(THD*,TABLE_LIST*,bool)" -> "List_iterator<T>::List_iterator(List<T>&) [with T = TABLE_LIST]"
"merge_on_conds(THD*,TABLE_LIST*,bool)" -> "List_iterator<T>::operator++(int) [with T = TABLE_LIST]"
"merge_on_conds(THD*,TABLE_LIST*,bool)" -> "TABLE_LIST::join_cond() const"
"merge_on_conds(THD*,TABLE_LIST*,bool)" -> "and_conds(Item*,Item*)"
"List_iterator<T>::List_iterator(List<T>&) [with T = TABLE_LIST]" -> "base_list_iterator::base_list_iterator(base_list&)"
"List_iterator<T>::operator++(int) [with T = TABLE_LIST]" -> "base_list_iterator::next()"
"and_conds(Item*,Item*)" -> "Item_cond_and::Item_cond_and(Item*,Item*)"
"THD::change_item_tree(Item**,Item*)" -> "THD::nocheck_register_item_tree_change(Item**,Item*,MEM_ROOT*)"
"THD::change_item_tree(Item**,Item*)" -> "Query_arena::is_conventional() const"
"THD::nocheck_register_item_tree_change(Item**,Item*,MEM_ROOT*)" -> "base_ilist<T>::push_front(T*) [with T = Item_change_record]"
"THD::nocheck_register_item_tree_change(Item**,Item*,MEM_ROOT*)" -> "Item_change_record::Item_change_record()"
"THD::nocheck_register_item_tree_change(Item**,Item*,MEM_ROOT*)" -> "alloc_root(MEM_ROOT*,size_t)"
"Item_change_record::Item_change_record()" -> "ilink<T>::ilink() [with T = Item_change_record]"
"TABLE_LIST::prepare_where(THD*,Item**,bool)" -> "TABLE_LIST::prep_where(THD*,Item**,bool)"
"TABLE_LIST::prep_where(THD*,Item**,bool)" -> "and_conds(Item*,Item*)"
"TABLE_LIST::prep_where(THD*,Item**,bool)" -> "TABLE_LIST::prep_where(THD*,Item**,bool)"
"TABLE_LIST::prep_where(THD*,Item**,bool)" -> "TABLE_LIST::join_cond() const"
"TABLE_LIST::prep_where(THD*,Item**,bool)" -> "TABLE_LIST::set_join_cond(Item*)"
"TABLE_LIST::prep_where(THD*,Item**,bool)" -> "Switch_resolve_place::Switch_resolve_place(st_select_lex::Resolve_place*,st_select_lex::Resolve_place,bool)"
"TABLE_LIST::prep_where(THD*,Item**,bool)" -> "Prepared_stmt_arena_holder::Prepared_stmt_arena_holder(THD*,bool)"
"unique_table(THD*,TABLE_LIST*,TABLE_LIST*,bool)" -> "find_dup_table(THD*,TABLE_LIST*,TABLE_LIST*,bool)"
"find_dup_table(THD*,TABLE_LIST*,TABLE_LIST*,bool)" -> "TABLE_LIST::find_underlying_table(TABLE*)"
"find_dup_table(THD*,TABLE_LIST*,TABLE_LIST*,bool)" -> "find_table_in_global_list(TABLE_LIST*,const char*,const char*)"
"find_dup_table(THD*,TABLE_LIST*,TABLE_LIST*,bool)" -> "strcmp(const char*,const char*)"
"TABLE_LIST::find_underlying_table(TABLE*)" -> "TABLE_LIST::find_underlying_table(TABLE*)"
"find_table_in_global_list(TABLE_LIST*,const char*,const char*)" -> "find_table_in_list(TABLE_LIST*,TABLE_LIST* TABLE_LIST::*,const char*,const char*)"
"find_table_in_list(TABLE_LIST*,TABLE_LIST* TABLE_LIST::*,const char*,const char*)" -> "strcmp(const char*,const char*)"
"fix_inner_refs(THD*,List<Item>&,SELECT_LEX*,Ref_ptr_array,ORDER*)" -> "Item_ref::Item_ref(Name_resolution_context*,Item**,const char*,const char*,bool)"
"fix_inner_refs(THD*,List<Item>&,SELECT_LEX*,Ref_ptr_array,ORDER*)" -> "Bounds_checked_array<Element_type>::is_null() const [with Element_type = Item*]"
"fix_inner_refs(THD*,List<Item>&,SELECT_LEX*,Ref_ptr_array,ORDER*)" -> "List_iterator<T>::List_iterator(List<T>&) [with T = Item_outer_ref]"
"fix_inner_refs(THD*,List<Item>&,SELECT_LEX*,Ref_ptr_array,ORDER*)" -> "Bounds_checked_array<Element_type>::operator[](size_t) [with Element_type = Item*,size_t = long unsigned int]"
"fix_inner_refs(THD*,List<Item>&,SELECT_LEX*,Ref_ptr_array,ORDER*)" -> "List_iterator<T>::operator++(int) [with T = Item_outer_ref]"
"fix_inner_refs(THD*,List<Item>&,SELECT_LEX*,Ref_ptr_array,ORDER*)" -> "List<T>::push_front(T*) [with T = Item]"
"fix_inner_refs(THD*,List<Item>&,SELECT_LEX*,Ref_ptr_array,ORDER*)" -> "Item_direct_ref::Item_direct_ref(Name_resolution_context*,Item**,const char*,const char*,bool)"
"List_iterator<T>::List_iterator(List<T>&) [with T = Item_outer_ref]" -> "base_list_iterator::base_list_iterator(base_list&)"
"List_iterator<T>::operator++(int) [with T = Item_outer_ref]" -> "base_list_iterator::next()"
"check_key_in_view(THD*,TABLE_LIST*)" -> "TABLE_LIST::top_table()"
"check_key_in_view(THD*,TABLE_LIST*)" -> "push_warning(THD*,Sql_condition::enum_warning_level,uint,const char*)"
"check_key_in_view(THD*,TABLE_LIST*)" -> "_current_thd()"
"mysql_test_create_view(Prepared_statement*)" -> "LEX::unlink_first_table(bool*)"
"mysql_test_create_view(Prepared_statement*)" -> "select_like_stmt_test(Prepared_statement*,int (*)(THD*),ulong)"
"mysql_test_create_view(Prepared_statement*)" -> "create_view_precheck(THD*,TABLE_LIST*,TABLE_LIST*,enum_view_create_mode)"
"mysql_test_create_view(Prepared_statement*)" -> "LEX::link_first_table_back(TABLE_LIST*,bool)"
"mysql_test_create_view(Prepared_statement*)" -> "open_normal_and_derived_tables(THD*,TABLE_LIST*,uint)"
"mysql_test_create_view(Prepared_statement*)" -> "open_temporary_tables(THD*,TABLE_LIST*)"
"LEX::unlink_first_table(bool*)" -> "LEX::first_lists_tables_same()"
"select_like_stmt_test(Prepared_statement*,int (*)(THD*),ulong)" -> "st_select_lex_unit::prepare(THD*,select_result*,ulong)"
"st_select_lex_unit::prepare(THD*,select_result*,ulong)" -> "Prepared_stmt_arena_holder::Prepared_stmt_arena_holder(THD*,bool)"
"st_select_lex_unit::prepare(THD*,select_result*,ulong)" -> "TABLE::fill_item_list(List<Item>*) const"
"st_select_lex_unit::prepare(THD*,select_result*,ulong)" -> "Item_type_holder::Item_type_holder(THD*,Item*)"
"st_select_lex_unit::prepare(THD*,select_result*,ulong)" -> "my_error(int,myf,...)"
"st_select_lex_unit::prepare(THD*,select_result*,ulong)" -> "SQL_I_List<T>::empty() [with T = TABLE_LIST]"
"st_select_lex_unit::prepare(THD*,select_result*,ulong)" -> "TABLE::reset_item_list(List<Item>*) const"
"st_select_lex_unit::prepare(THD*,select_result*,ulong)" -> "memset(void*,int,size_t)"
"st_select_lex_unit::prepare(THD*,select_result*,ulong)" -> "__builtin_memcpy(void*,const void*,long unsigned int)"
"st_select_lex_unit::prepare(THD*,select_result*,ulong)" -> "st_select_lex::next_select()"
"st_select_lex_unit::prepare(THD*,select_result*,ulong)" -> "st_select_lex_unit::init_prepare_fake_select_lex(THD*,bool)"
"st_select_lex_unit::prepare(THD*,select_result*,ulong)" -> "List<T>::push_back(T*) [with T = Item]"
"st_select_lex_unit::prepare(THD*,select_result*,ulong)" -> "List_iterator_fast<T>::List_iterator_fast(List<T>&) [with T = Item]"
"st_select_lex_unit::prepare(THD*,select_result*,ulong)" -> "st_select_lex_unit::is_union()"
"st_select_lex_unit::prepare(THD*,select_result*,ulong)" -> "JOIN::reset()"
"st_select_lex_unit::prepare(THD*,select_result*,ulong)" -> "st_select_lex_unit::first_select()"
"st_select_lex_unit::prepare(THD*,select_result*,ulong)" -> "_current_thd()"
"st_select_lex_unit::prepare(THD*,select_result*,ulong)" -> "select_union::select_union()"
"st_select_lex_unit::prepare(THD*,select_result*,ulong)" -> "JOIN::JOIN(THD*,List<Item>&,ulonglong,select_result*)"
"st_select_lex_unit::prepare(THD*,select_result*,ulong)" -> "JOIN::prepare(TABLE_LIST*,uint,Item*,uint,ORDER*,ORDER*,Item*,SELECT_LEX*,SELECT_LEX_UNIT*)"
"st_select_lex_unit::prepare(THD*,select_result*,ulong)" -> "List_iterator_fast<T>::operator++(int) [with T = Item]"
"st_select_lex_unit::prepare(THD*,select_result*,ulong)" -> "select_union::create_result_table(THD*,List<Item>*,bool,ulonglong,const char*,bool,bool)"
"st_select_lex_unit::prepare(THD*,select_result*,ulong)" -> "st_select_lex_unit::cleanup()"
"st_select_lex_unit::prepare(THD*,select_result*,ulong)" -> "Query_arena::is_stmt_prepare() const"
"st_select_lex_unit::prepare(THD*,select_result*,ulong)" -> "Item_type_holder::join_types(THD*,Item*)"
"st_select_lex_unit::prepare(THD*,select_result*,ulong)" -> "my_message(uint,const char*,myf)"
"st_select_lex_unit::prepare(THD*,select_result*,ulong)" -> "base_list::empty()"
"TABLE::fill_item_list(List<Item>*) const" -> "Item_field::Item_field(Field*)"
"TABLE::fill_item_list(List<Item>*) const" -> "List<T>::push_back(T*) [with T = Item]"
"Item_field::Item_field(Field*)" -> "Item_field::set_field(Field*)"
"Item_field::Item_field(Field*)" -> "Item_ident::Item_ident(Name_resolution_context*,const char*,const char*,const char*)"
"Item_type_holder::Item_type_holder(THD*,Item*)" -> "Item_type_holder::get_full_info(Item*)"
"Item_type_holder::Item_type_holder(THD*,Item*)" -> "Field::result_merge_type(enum_field_types)"
"Item_type_holder::Item_type_holder(THD*,Item*)" -> "Item::decimal_int_part() const"
"Item_type_holder::Item_type_holder(THD*,Item*)" -> "Item::Item(THD*,Item*)"
"Item_type_holder::Item_type_holder(THD*,Item*)" -> "Item_type_holder::get_real_type(Item*)"
"Item_type_holder::Item_type_holder(THD*,Item*)" -> "DTCollation::set(DTCollation&)"
"Item_type_holder::get_full_info(Item*)" -> "Item_sum::get_arg(uint)"
"Field::result_merge_type(enum_field_types)" -> "field_type2index(enum_field_types)"
"field_type2index(enum_field_types)" -> "real_type_to_type(enum_field_types)"
"Item::decimal_int_part() const" -> "my_decimal_int_part(uint,uint)"
"Item::Item(THD*,Item*)" -> "String::String(const String&)"
"Item_type_holder::get_real_type(Item*)" -> "Item_type_holder::get_real_type(Item*)"
"Item_type_holder::get_real_type(Item*)" -> "Item_sum::get_arg(uint)"
"TABLE::reset_item_list(List<Item>*) const" -> "List_iterator_fast<T>::List_iterator_fast(List<T>&) [with T = Item]"
"TABLE::reset_item_list(List<Item>*) const" -> "Item_field::reset_field(Field*)"
"TABLE::reset_item_list(List<Item>*) const" -> "List_iterator_fast<T>::operator++(int) [with T = Item]"
"Item_field::reset_field(Field*)" -> "Simple_cstring::set(const char*)"
"Item_field::reset_field(Field*)" -> "Item_field::set_field(Field*)"
"st_select_lex_unit::init_prepare_fake_select_lex(THD*,bool)" -> "JOIN::init(THD*,List<Item>&,ulonglong,select_result*)"
"st_select_lex_unit::init_prepare_fake_select_lex(THD*,bool)" -> "Bounds_checked_array<Element_type>::is_null() const [with Element_type = Item*]"
"st_select_lex_unit::init_prepare_fake_select_lex(THD*,bool)" -> "JOIN::JOIN(THD*,List<Item>&,ulonglong,select_result*)"
"st_select_lex_unit::init_prepare_fake_select_lex(THD*,bool)" -> "SQL_I_List<T>::empty() [with T = TABLE_LIST]"
"st_select_lex_unit::init_prepare_fake_select_lex(THD*,bool)" -> "SQL_I_List<T>::link_in_list(T*,T**) [with T = TABLE_LIST]"
"st_select_lex_unit::init_prepare_fake_select_lex(THD*,bool)" -> "__builtin_memcpy(void*,const void*,long unsigned int)"
"JOIN::init(THD*,List<Item>&,ulonglong,select_result*)" -> "__builtin_memcpy(void*,const void*,long unsigned int)"
"JOIN::init(THD*,List<Item>&,ulonglong,select_result*)" -> "TMP_TABLE_PARAM::init()"
"JOIN::init(THD*,List<Item>&,ulonglong,select_result*)" -> "has_trivial_destructor>::clear() [with Element_type = Key_use,bool has_trivial_destructor = true]"
"JOIN::init(THD*,List<Item>&,ulonglong,select_result*)" -> "Bounds_checked_array<Element_type>::reset() [with Element_type = Item*]"
"JOIN::JOIN(THD*,List<Item>&,ulonglong,select_result*)" -> "List<T>::List() [with T = Item]"
"JOIN::JOIN(THD*,List<Item>&,ulonglong,select_result*)" -> "JOIN::ORDER_with_src::ORDER_with_src()"
"JOIN::JOIN(THD*,List<Item>&,ulonglong,select_result*)" -> "st_rollup::st_rollup()"
"JOIN::JOIN(THD*,List<Item>&,ulonglong,select_result*)" -> "TMP_TABLE_PARAM::TMP_TABLE_PARAM()"
"JOIN::JOIN(THD*,List<Item>&,ulonglong,select_result*)" -> "List<T>::List() [with T = Cached_item]"
"JOIN::JOIN(THD*,List<Item>&,ulonglong,select_result*)" -> "JOIN::init(THD*,List<Item>&,ulonglong,select_result*)"
"JOIN::JOIN(THD*,List<Item>&,ulonglong,select_result*)" -> "List<T>::List() [with T = TABLE]"
"JOIN::JOIN(THD*,List<Item>&,ulonglong,select_result*)" -> "Bounds_checked_array<Element_type>::Bounds_checked_array() [with Element_type = Item*]"
"JOIN::JOIN(THD*,List<Item>&,ulonglong,select_result*)" -> "Sql_alloc::Sql_alloc()"
"JOIN::JOIN(THD*,List<Item>&,ulonglong,select_result*)" -> "Explain_format_flags::Explain_format_flags()"
"JOIN::JOIN(THD*,List<Item>&,ulonglong,select_result*)" -> "List<T>::List() [with T = Semijoin_mat_exec]"
"JOIN::JOIN(THD*,List<Item>&,ulonglong,select_result*)" -> "has_trivial_destructor>::Mem_root_array(MEM_ROOT*) [with Element_type = Key_use,bool has_trivial_destructor = true,MEM_ROOT = st_mem_root]"
"JOIN::JOIN(THD*,List<Item>&,ulonglong,select_result*)" -> "has_trivial_destructor>::Mem_root_array(MEM_ROOT*) [with Element_type = Item_exists_subselect*,bool has_trivial_destructor = true,MEM_ROOT = st_mem_root]"
"JOIN::ORDER_with_src::ORDER_with_src()" -> "JOIN::ORDER_with_src::clean()"
"st_rollup::st_rollup()" -> "Bounds_checked_array<Element_type>::Bounds_checked_array() [with Element_type = Item_null_result*]"
"TMP_TABLE_PARAM::TMP_TABLE_PARAM()" -> "List<T>::List() [with T = Item]"
"TMP_TABLE_PARAM::TMP_TABLE_PARAM()" -> "Sql_alloc::Sql_alloc()"
"List<T>::List() [with T = Cached_item]" -> "base_list::base_list()"
"List<T>::List() [with T = TABLE]" -> "base_list::base_list()"
"Explain_format_flags::Explain_format_flags()" -> "memset(void*,int,size_t)"
"List<T>::List() [with T = Semijoin_mat_exec]" -> "base_list::base_list()"
"JOIN::reset()" -> "JOIN::ORDER_with_src::operator ORDER*()"
"JOIN::reset()" -> "init_ftfuncs(THD*,SELECT_LEX*,bool)"
"JOIN::reset()" -> "filesort_free_buffers(TABLE*,bool)"
"JOIN::reset()" -> "TABLE::is_created() const"
"JOIN::reset()" -> "Bounds_checked_array<Element_type>::operator!=(const Bounds_checked_array<Element_type>&) const [with Element_type = Item*]"
"JOIN::reset()" -> "clear_sj_tmp_tables(JOIN*)"
"JOIN::reset()" -> "handler::ha_delete_all_rows()"
"JOIN::reset()" -> "free_io_cache(TABLE*)"
"JOIN::reset()" -> "Item::val_uint()"
"JOIN::reset()" -> "JOIN::set_items_ref_array(Ref_ptr_array)"
"init_ftfuncs(THD*,SELECT_LEX*,bool)" -> "List_iterator<T>::operator++(int) [with T = Item_func_match]"
"init_ftfuncs(THD*,SELECT_LEX*,bool)" -> "List_iterator<T>::List_iterator(List<T>&) [with T = Item_func_match]"
"init_ftfuncs(THD*,SELECT_LEX*,bool)" -> "THD::enter_stage(const PSI_stage_info*,PSI_stage_info*,const char*,const char*,unsigned int)"
"init_ftfuncs(THD*,SELECT_LEX*,bool)" -> "Item_func_match::init_search(bool)"
"Item_func_match::init_search(bool)" -> "Item_string::Item_string(const char*,uint,const CHARSET_INFO*,Derivation,uint)"
"Item_func_match::init_search(bool)" -> "List<T>::push_back(T*) [with T = Item]"
"Item_func_match::init_search(bool)" -> "List<T>::List() [with T = Item]"
"Item_func_match::init_search(bool)" -> "String::set(const char*,uint32,const CHARSET_INFO*)"
"Item_func_match::init_search(bool)" -> "String::length() const"
"Item_func_match::init_search(bool)" -> "Item_func_match::init_search(bool)"
"Item_func_match::init_search(bool)" -> "Item::quick_fix_field()"
"Item_func_match::init_search(bool)" -> "String::ptr() const"
"Item_func_match::init_search(bool)" -> "Item_func_concat_ws::Item_func_concat_ws(List<Item>&)"
"Item_func_match::init_search(bool)" -> "String::charset() const"
"Item_func_match::init_search(bool)" -> "String::copy(const char*,uint32,const CHARSET_INFO*,const CHARSET_INFO*,uint*)"
"Item_func_concat_ws::Item_func_concat_ws(List<Item>&)" -> "String::String()"
"Item_func_concat_ws::Item_func_concat_ws(List<Item>&)" -> "Item_str_func::Item_str_func(List<Item>&)"
"clear_sj_tmp_tables(JOIN*)" -> "handler::ha_delete_all_rows()"
"clear_sj_tmp_tables(JOIN*)" -> "List_iterator<T>::operator++(int) [with T = Semijoin_mat_exec]"
"clear_sj_tmp_tables(JOIN*)" -> "List_iterator<T>::List_iterator(List<T>&) [with T = Semijoin_mat_exec]"
"clear_sj_tmp_tables(JOIN*)" -> "List_iterator<T>::List_iterator(List<T>&) [with T = TABLE]"
"clear_sj_tmp_tables(JOIN*)" -> "List_iterator<T>::operator++(int) [with T = TABLE]"
"handler::ha_delete_all_rows()" -> "handler::mark_trx_read_write()"
"select_union::select_union()" -> "select_result_interceptor::select_result_interceptor()"
"select_union::select_union()" -> "TMP_TABLE_PARAM::TMP_TABLE_PARAM()"
"JOIN::prepare(TABLE_LIST*,uint,Item*,uint,ORDER*,ORDER*,Item*,SELECT_LEX*,SELECT_LEX_UNIT*)" -> "my_message(uint,const char*,myf)"
"JOIN::prepare(TABLE_LIST*,uint,Item*,uint,ORDER*,ORDER*,Item*,SELECT_LEX*,SELECT_LEX_UNIT*)" -> "JOIN::rollup_init()"
"JOIN::prepare(TABLE_LIST*,uint,Item*,uint,ORDER*,ORDER*,Item*,SELECT_LEX*,SELECT_LEX_UNIT*)" -> "TABLE_LIST::join_cond() const"
"JOIN::prepare(TABLE_LIST*,uint,Item*,uint,ORDER*,ORDER*,Item*,SELECT_LEX*,SELECT_LEX_UNIT*)" -> "JOIN::ORDER_with_src::operator=(JOIN::ORDER_with_src::null*)"
"JOIN::prepare(TABLE_LIST*,uint,Item*,uint,ORDER*,ORDER*,Item*,SELECT_LEX*,SELECT_LEX_UNIT*)" -> "setup_wild(THD*,TABLE_LIST*,List<Item>&,List<Item>*,uint)"
"JOIN::prepare(TABLE_LIST*,uint,Item*,uint,ORDER*,ORDER*,Item*,SELECT_LEX*,SELECT_LEX_UNIT*)" -> "st_select_lex::fix_prepare_information(THD*,Item**,Item**)"
"JOIN::prepare(TABLE_LIST*,uint,Item*,uint,ORDER*,ORDER*,Item*,SELECT_LEX*,SELECT_LEX_UNIT*)" -> "_current_thd()"
"JOIN::prepare(TABLE_LIST*,uint,Item*,uint,ORDER*,ORDER*,Item*,SELECT_LEX*,SELECT_LEX_UNIT*)" -> "st_select_lex::agg_func_used() const"
"JOIN::prepare(TABLE_LIST*,uint,Item*,uint,ORDER*,ORDER*,Item*,SELECT_LEX*,SELECT_LEX_UNIT*)" -> "prune_partitions(THD*,TABLE*,Item*)"
"JOIN::prepare(TABLE_LIST*,uint,Item*,uint,ORDER*,ORDER*,Item*,SELECT_LEX*,SELECT_LEX_UNIT*)" -> "THD::is_error() const"
"JOIN::prepare(TABLE_LIST*,uint,Item*,uint,ORDER*,ORDER*,Item*,SELECT_LEX*,SELECT_LEX_UNIT*)" -> "setup_fields(THD*,Ref_ptr_array,List<Item>&,enum_mark_columns,List<Item>*,bool)"
"JOIN::prepare(TABLE_LIST*,uint,Item*,uint,ORDER*,ORDER*,Item*,SELECT_LEX*,SELECT_LEX_UNIT*)" -> "setup_ftfuncs(SELECT_LEX*)"
"JOIN::prepare(TABLE_LIST*,uint,Item*,uint,ORDER*,ORDER*,Item*,SELECT_LEX*,SELECT_LEX_UNIT*)" -> "Item::split_sum_func2(THD*,Ref_ptr_array,List<Item>&,Item**,bool)"
"JOIN::prepare(TABLE_LIST*,uint,Item*,uint,ORDER*,ORDER*,Item*,SELECT_LEX*,SELECT_LEX_UNIT*)" -> "count_field_types(SELECT_LEX*,TMP_TABLE_PARAM*,List<Item>&,bool)"
"JOIN::prepare(TABLE_LIST*,uint,Item*,uint,ORDER*,ORDER*,Item*,SELECT_LEX*,SELECT_LEX_UNIT*)" -> "st_select_lex_unit::is_union()"
"JOIN::prepare(TABLE_LIST*,uint,Item*,uint,ORDER*,ORDER*,Item*,SELECT_LEX*,SELECT_LEX_UNIT*)" -> "st_select_lex::non_agg_field_used() const"
"JOIN::prepare(TABLE_LIST*,uint,Item*,uint,ORDER*,ORDER*,Item*,SELECT_LEX*,SELECT_LEX_UNIT*)" -> "Explain_format_flags::set(Explain_sort_clause,Explain_sort_property)"
"JOIN::prepare(TABLE_LIST*,uint,Item*,uint,ORDER*,ORDER*,Item*,SELECT_LEX*,SELECT_LEX_UNIT*)" -> "JOIN::Prepare_error_tracker::Prepare_error_tracker(THD*)"
"JOIN::prepare(TABLE_LIST*,uint,Item*,uint,ORDER*,ORDER*,Item*,SELECT_LEX*,SELECT_LEX_UNIT*)" -> "JOIN::ORDER_with_src::ORDER_with_src(ORDER*,Explain_sort_clause)"
"JOIN::prepare(TABLE_LIST*,uint,Item*,uint,ORDER*,ORDER*,Item*,SELECT_LEX*,SELECT_LEX_UNIT*)" -> "Opt_trace_object::Opt_trace_object(Opt_trace_context*,Opt_trace_context::feature_value)"
"JOIN::prepare(TABLE_LIST*,uint,Item*,uint,ORDER*,ORDER*,Item*,SELECT_LEX*,SELECT_LEX_UNIT*)" -> "st_select_lex::setup_ref_array(THD*,uint)"
"JOIN::prepare(TABLE_LIST*,uint,Item*,uint,ORDER*,ORDER*,Item*,SELECT_LEX*,SELECT_LEX_UNIT*)" -> "JOIN::alloc_func_list()"
"JOIN::prepare(TABLE_LIST*,uint,Item*,uint,ORDER*,ORDER*,Item*,SELECT_LEX*,SELECT_LEX_UNIT*)" -> "TABLE_LIST::uses_materialization() const"
"JOIN::prepare(TABLE_LIST*,uint,Item*,uint,ORDER*,ORDER*,Item*,SELECT_LEX*,SELECT_LEX_UNIT*)" -> "Opt_trace_object::Opt_trace_object(Opt_trace_context*,const char*,Opt_trace_context::feature_value)"
"JOIN::prepare(TABLE_LIST*,uint,Item*,uint,ORDER*,ORDER*,Item*,SELECT_LEX*,SELECT_LEX_UNIT*)" -> "List<T>::push_front(T*) [with T = Item]"
"JOIN::prepare(TABLE_LIST*,uint,Item*,uint,ORDER*,ORDER*,Item*,SELECT_LEX*,SELECT_LEX_UNIT*)" -> "JOIN::ORDER_with_src::operator ORDER*()"
"JOIN::prepare(TABLE_LIST*,uint,Item*,uint,ORDER*,ORDER*,Item*,SELECT_LEX*,SELECT_LEX_UNIT*)" -> "JOIN::ref_ptr_array_slice(size_t)"
"JOIN::prepare(TABLE_LIST*,uint,Item*,uint,ORDER*,ORDER*,Item*,SELECT_LEX*,SELECT_LEX_UNIT*)" -> "Field::maybe_null() const"
"JOIN::prepare(TABLE_LIST*,uint,Item*,uint,ORDER*,ORDER*,Item*,SELECT_LEX*,SELECT_LEX_UNIT*)" -> "Opt_trace_struct::add_select_number(uint)"
"JOIN::prepare(TABLE_LIST*,uint,Item*,uint,ORDER*,ORDER*,Item*,SELECT_LEX*,SELECT_LEX_UNIT*)" -> "setup_tables_and_check_access(THD*,Name_resolution_context*,List<TABLE_LIST>*,TABLE_LIST*,TABLE_LIST**,bool,ulong,ulong)"
"JOIN::prepare(TABLE_LIST*,uint,Item*,uint,ORDER*,ORDER*,Item*,SELECT_LEX*,SELECT_LEX_UNIT*)" -> "opt_trace_print_expanded_query(THD*,st_select_lex*,Opt_trace_object*)"
"JOIN::prepare(TABLE_LIST*,uint,Item*,uint,ORDER*,ORDER*,Item*,SELECT_LEX*,SELECT_LEX_UNIT*)" -> "Item_field::Item_field(THD*,Item_field*)"
"JOIN::prepare(TABLE_LIST*,uint,Item*,uint,ORDER*,ORDER*,Item*,SELECT_LEX*,SELECT_LEX_UNIT*)" -> "remove_redundant_subquery_clauses(st_select_lex*,int,int,List<Item>&,Ref_ptr_array)"
"JOIN::prepare(TABLE_LIST*,uint,Item*,uint,ORDER*,ORDER*,Item*,SELECT_LEX*,SELECT_LEX_UNIT*)" -> "Bounds_checked_array<Element_type>::operator[](size_t) [with Element_type = Item*,size_t = long unsigned int]"
"JOIN::prepare(TABLE_LIST*,uint,Item*,uint,ORDER*,ORDER*,Item*,SELECT_LEX*,SELECT_LEX_UNIT*)" -> "fix_inner_refs(THD*,List<Item>&,SELECT_LEX*,Ref_ptr_array,ORDER*)"
"JOIN::prepare(TABLE_LIST*,uint,Item*,uint,ORDER*,ORDER*,Item*,SELECT_LEX*,SELECT_LEX_UNIT*)" -> "resolve_subquery(THD*,JOIN*)"
"JOIN::prepare(TABLE_LIST*,uint,Item*,uint,ORDER*,ORDER*,Item*,SELECT_LEX*,SELECT_LEX_UNIT*)" -> "Opt_trace_array::Opt_trace_array(Opt_trace_context*,const char*,Opt_trace_context::feature_value)"
"JOIN::prepare(TABLE_LIST*,uint,Item*,uint,ORDER*,ORDER*,Item*,SELECT_LEX*,SELECT_LEX_UNIT*)" -> "setup_without_group(THD*,Ref_ptr_array,TABLE_LIST*,TABLE_LIST*,List<Item>&,List<Item>&,Item**,ORDER*,ORDER*,int*,int*)"
"JOIN::rollup_init()" -> "Bounds_checked_array<Element_type>::Bounds_checked_array(Element_type*,size_t) [with Element_type = Item*,size_t = long unsigned int]"
"JOIN::rollup_init()" -> "List<T>::push_back(T*) [with T = Item]"
"JOIN::rollup_init()" -> "List_iterator<T>::List_iterator(List<T>&) [with T = Item]"
"JOIN::rollup_init()" -> "Item_null_result::Item_null_result(enum_field_types,Item_result)"
"JOIN::rollup_init()" -> "base_list::empty()"
"JOIN::rollup_init()" -> "List_iterator<T>::operator++(int) [with T = Item]"
"JOIN::rollup_init()" -> "Bounds_checked_array<Element_type>::operator[](size_t) [with Element_type = Item_null_result*,size_t = long unsigned int]"
"JOIN::rollup_init()" -> "JOIN::ORDER_with_src::operator ORDER*()"
"JOIN::rollup_init()" -> "Query_arena::alloc(size_t)"
"JOIN::rollup_init()" -> "Bounds_checked_array<Element_type>::Bounds_checked_array(Element_type*,size_t) [with Element_type = Item_null_result*,size_t = long unsigned int]"
"JOIN::rollup_init()" -> "change_group_ref(THD*,Item_func*,ORDER*,bool*)"
"Item_null_result::Item_null_result(enum_field_types,Item_result)" -> "Item_null::Item_null()"
"change_group_ref(THD*,Item_func*,ORDER*,bool*)" -> "THD::change_item_tree(Item**,Item*)"
"change_group_ref(THD*,Item_func*,ORDER*,bool*)" -> "change_group_ref(THD*,Item_func*,ORDER*,bool*)"
"change_group_ref(THD*,Item_func*,ORDER*,bool*)" -> "Simple_cstring::ptr() const"
"change_group_ref(THD*,Item_func*,ORDER*,bool*)" -> "Item_ref::Item_ref(Name_resolution_context*,Item**,const char*,const char*,bool)"
"change_group_ref(THD*,Item_func*,ORDER*,bool*)" -> "Item_func::arguments() const"
"JOIN::ORDER_with_src::operator=(JOIN::ORDER_with_src::null*)" -> "JOIN::ORDER_with_src::clean()"
"setup_wild(THD*,TABLE_LIST*,List<Item>&,List<Item>*,uint)" -> "List_iterator<T>::List_iterator(List<T>&) [with T = Item]"
"setup_wild(THD*,TABLE_LIST*,List<Item>&,List<Item>*,uint)" -> "Item_int::Item_int(const Name_string&,longlong,uint)"
"setup_wild(THD*,TABLE_LIST*,List<Item>&,List<Item>*,uint)" -> "List_iterator<T>::replace(T*) [with T = Item]"
"setup_wild(THD*,TABLE_LIST*,List<Item>&,List<Item>*,uint)" -> "List_iterator<T>::operator++(int) [with T = Item]"
"setup_wild(THD*,TABLE_LIST*,List<Item>&,List<Item>*,uint)" -> "Name_string::Name_string(const char*,size_t)"
"setup_wild(THD*,TABLE_LIST*,List<Item>&,List<Item>*,uint)" -> "Prepared_stmt_arena_holder::Prepared_stmt_arena_holder(THD*,bool)"
"setup_wild(THD*,TABLE_LIST*,List<Item>&,List<Item>*,uint)" -> "__builtin_memcpy(void*,const void*,long unsigned int)"
"setup_wild(THD*,TABLE_LIST*,List<Item>&,List<Item>*,uint)" -> "insert_fields(THD*,Name_resolution_context*,const char*,const char*,List_iterator<Item>*,bool)"
"setup_wild(THD*,TABLE_LIST*,List<Item>&,List<Item>*,uint)" -> "Prepared_stmt_arena_holder::is_activated() const"
"List_iterator<T>::replace(T*) [with T = Item]" -> "base_list_iterator::replace(void*)"
"insert_fields(THD*,Name_resolution_context*,const char*,const char*,List_iterator<Item>*,bool)" -> "String::String(const char*,const CHARSET_INFO*)"
"insert_fields(THD*,Name_resolution_context*,const char*,const char*,List_iterator<Item>*,bool)" -> "strmake(char*,const char*,size_t)"
"insert_fields(THD*,Name_resolution_context*,const char*,const char*,List_iterator<Item>*,bool)" -> "String::append(const String&)"
"insert_fields(THD*,Name_resolution_context*,const char*,const char*,List_iterator<Item>*,bool)" -> "String::c_ptr_safe()"
"insert_fields(THD*,Name_resolution_context*,const char*,const char*,List_iterator<Item>*,bool)" -> "bitmap_set_bit(MY_BITMAP*,uint)"
"insert_fields(THD*,Name_resolution_context*,const char*,const char*,List_iterator<Item>*,bool)" -> "_current_thd()"
"insert_fields(THD*,Name_resolution_context*,const char*,const char*,List_iterator<Item>*,bool)" -> "Bitmap<64u>::merge(const Bitmap<64u>&)"
"insert_fields(THD*,Name_resolution_context*,const char*,const char*,List_iterator<Item>*,bool)" -> "my_error(int,myf,...)"
"insert_fields(THD*,Name_resolution_context*,const char*,const char*,List_iterator<Item>*,bool)" -> "Bitmap<64u>::intersect(const Bitmap<64u>&)"
"insert_fields(THD*,Name_resolution_context*,const char*,const char*,List_iterator<Item>*,bool)" -> "String::append(char)"
"insert_fields(THD*,Name_resolution_context*,const char*,const char*,List_iterator<Item>*,bool)" -> "Field_iterator_table_ref::Field_iterator_table_ref()"
"insert_fields(THD*,Name_resolution_context*,const char*,const char*,List_iterator<Item>*,bool)" -> "strcmp(const char*,const char*)"
"insert_fields(THD*,Name_resolution_context*,const char*,const char*,List_iterator<Item>*,bool)" -> "Field_iterator_table_ref::set(TABLE_LIST*)"
"insert_fields(THD*,Name_resolution_context*,const char*,const char*,List_iterator<Item>*,bool)" -> "List_iterator<T>::after(T*) [with T = Item]"
"insert_fields(THD*,Name_resolution_context*,const char*,const char*,List_iterator<Item>*,bool)" -> "Field_iterator_table_ref::field()"
"insert_fields(THD*,Name_resolution_context*,const char*,const char*,List_iterator<Item>*,bool)" -> "List_iterator<T>::replace(T*) [with T = Item]"
"insert_fields(THD*,Name_resolution_context*,const char*,const char*,List_iterator<Item>*,bool)" -> "Field_iterator_table_ref::end_of_fields()"
"insert_fields(THD*,Name_resolution_context*,const char*,const char*,List_iterator<Item>*,bool)" -> "String::String()"
"insert_fields(THD*,Name_resolution_context*,const char*,const char*,List_iterator<Item>*,bool)" -> "Field_iterator_table_ref::next()"
"insert_fields(THD*,Name_resolution_context*,const char*,const char*,List_iterator<Item>*,bool)" -> "my_message(uint,const char*,myf)"
"insert_fields(THD*,Name_resolution_context*,const char*,const char*,List_iterator<Item>*,bool)" -> "Field_iterator_table_ref::create_item(THD*)"
"insert_fields(THD*,Name_resolution_context*,const char*,const char*,List_iterator<Item>*,bool)" -> "Field_iterator_table_ref::get_natural_column_ref()"
"List_iterator<T>::after(T*) [with T = Item]" -> "base_list_iterator::after(void*)"
"base_list_iterator::after(void*)" -> "base_list::after(void*,list_node*)"
"base_list::after(void*,list_node*)" -> "list_node::list_node(void*,list_node*)"
"prune_partitions(THD*,TABLE*,Item*)" -> "List<T>::head() [with T = SEL_IMERGE]"
"prune_partitions(THD*,TABLE*,Item*)" -> "bitmap_is_clear_all(const MY_BITMAP*)"
"prune_partitions(THD*,TABLE*,Item*)" -> "partition_key_modified(TABLE*,const MY_BITMAP*)"
"prune_partitions(THD*,TABLE*,Item*)" -> "dbug_tmp_restore_column_maps(MY_BITMAP*,MY_BITMAP*,my_bitmap_map**)"
"prune_partitions(THD*,TABLE*,Item*)" -> "find_used_partitions(PART_PRUNE_PARAM*,SEL_ARG*)"
"prune_partitions(THD*,TABLE*,Item*)" -> "dbug_tmp_use_all_columns(TABLE*,my_bitmap_map**,MY_BITMAP*,MY_BITMAP*)"
"prune_partitions(THD*,TABLE*,Item*)" -> "bitmap_copy(MY_BITMAP*,const MY_BITMAP*)"
"prune_partitions(THD*,TABLE*,Item*)" -> "init_sql_alloc(MEM_ROOT*,uint,uint)"
"prune_partitions(THD*,TABLE*,Item*)" -> "get_mm_tree(RANGE_OPT_PARAM*,Item*)"
"prune_partitions(THD*,TABLE*,Item*)" -> "base_list::is_empty() const"
"prune_partitions(THD*,TABLE*,Item*)" -> "Query_tables_list::is_query_tables_locked()"
"prune_partitions(THD*,TABLE*,Item*)" -> "free_root(MEM_ROOT*,myf)"
"prune_partitions(THD*,TABLE*,Item*)" -> "create_partition_index_description(PART_PRUNE_PARAM*)"
"prune_partitions(THD*,TABLE*,Item*)" -> "find_used_partitions_imerge(PART_PRUNE_PARAM*,SEL_IMERGE*)"
"prune_partitions(THD*,TABLE*,Item*)" -> "memset(void*,int,size_t)"
"prune_partitions(THD*,TABLE*,Item*)" -> "init_all_partitions_iterator(partition_info*,PARTITION_ITERATOR*)"
"prune_partitions(THD*,TABLE*,Item*)" -> "find_used_partitions_imerge_list(PART_PRUNE_PARAM*,List<SEL_IMERGE>&)"
"prune_partitions(THD*,TABLE*,Item*)" -> "bitmap_intersect(MY_BITMAP*,const MY_BITMAP*)"
"prune_partitions(THD*,TABLE*,Item*)" -> "mark_all_partitions_as_used(partition_info*)"
"prune_partitions(THD*,TABLE*,Item*)" -> "TABLE_SHARE::db_type() const"
"List<T>::head() [with T = SEL_IMERGE]" -> "base_list::head()"
"partition_key_modified(TABLE*,const MY_BITMAP*)" -> "TABLE_SHARE::db_type() const"
"partition_key_modified(TABLE*,const MY_BITMAP*)" -> "bitmap_is_set(const MY_BITMAP*,uint)"
"find_used_partitions(PART_PRUNE_PARAM*,SEL_ARG*)" -> "check_stack_overrun(THD*,long int,uchar*)"
"find_used_partitions(PART_PRUNE_PARAM*,SEL_ARG*)" -> "bitmap_is_set(const MY_BITMAP*,uint)"
"find_used_partitions(PART_PRUNE_PARAM*,SEL_ARG*)" -> "SEL_ARG::store_min_key(KEY_PART*,uchar**,uint*,uint)"
"find_used_partitions(PART_PRUNE_PARAM*,SEL_ARG*)" -> "SEL_ARG::is_singlepoint() const"
"find_used_partitions(PART_PRUNE_PARAM*,SEL_ARG*)" -> "SEL_ARG::store_min(uint,uchar**,uint)"
"find_used_partitions(PART_PRUNE_PARAM*,SEL_ARG*)" -> "memcmp(const void*,const void*,size_t)"
"find_used_partitions(PART_PRUNE_PARAM*,SEL_ARG*)" -> "init_all_partitions_iterator(partition_info*,PARTITION_ITERATOR*)"
"find_used_partitions(PART_PRUNE_PARAM*,SEL_ARG*)" -> "SEL_ARG::store_max(uint,uchar**,uint)"
"find_used_partitions(PART_PRUNE_PARAM*,SEL_ARG*)" -> "SEL_ARG::store_max_key(KEY_PART*,uchar**,uint*,uint)"
"find_used_partitions(PART_PRUNE_PARAM*,SEL_ARG*)" -> "init_single_partition_iterator(uint32,PARTITION_ITERATOR*)"
"find_used_partitions(PART_PRUNE_PARAM*,SEL_ARG*)" -> "find_used_partitions(PART_PRUNE_PARAM*,SEL_ARG*)"
"find_used_partitions(PART_PRUNE_PARAM*,SEL_ARG*)" -> "memset(void*,int,size_t)"
"find_used_partitions(PART_PRUNE_PARAM*,SEL_ARG*)" -> "store_selargs_to_rec(PART_PRUNE_PARAM*,SEL_ARG**,int)"
"find_used_partitions(PART_PRUNE_PARAM*,SEL_ARG*)" -> "bitmap_set_bit(MY_BITMAP*,uint)"
"SEL_ARG::store_min_key(KEY_PART*,uchar**,uint*,uint)" -> "SEL_ARG::store_min_key(KEY_PART*,uchar**,uint*,uint)"
"SEL_ARG::store_min_key(KEY_PART*,uchar**,uint*,uint)" -> "SEL_ARG::store_min(uint,uchar**,uint)"
"SEL_ARG::store_min_key(KEY_PART*,uchar**,uint*,uint)" -> "SEL_ARG::first()"
"SEL_ARG::store_min(uint,uchar**,uint)" -> "memset(void*,int,size_t)"
"SEL_ARG::store_min(uint,uchar**,uint)" -> "memcpy(void*,const void*,size_t)"
"SEL_ARG::store_max(uint,uchar**,uint)" -> "memset(void*,int,size_t)"
"SEL_ARG::store_max(uint,uchar**,uint)" -> "memcpy(void*,const void*,size_t)"
"SEL_ARG::store_max_key(KEY_PART*,uchar**,uint*,uint)" -> "SEL_ARG::store_max_key(KEY_PART*,uchar**,uint*,uint)"
"SEL_ARG::store_max_key(KEY_PART*,uchar**,uint*,uint)" -> "SEL_ARG::store_max(uint,uchar**,uint)"
"SEL_ARG::store_max_key(KEY_PART*,uchar**,uint*,uint)" -> "SEL_ARG::last()"
"store_selargs_to_rec(PART_PRUNE_PARAM*,SEL_ARG**,int)" -> "store_key_image_to_rec(Field*,uchar*,uint)"
"store_key_image_to_rec(Field*,uchar*,uint)" -> "dbug_tmp_use_all_columns(TABLE*,MY_BITMAP*)"
"store_key_image_to_rec(Field*,uchar*,uint)" -> "Field::set_null(my_ptrdiff_t)"
"store_key_image_to_rec(Field*,uchar*,uint)" -> "dbug_tmp_restore_column_map(MY_BITMAP*,my_bitmap_map*)"
"store_key_image_to_rec(Field*,uchar*,uint)" -> "Field::real_maybe_null() const"
"store_key_image_to_rec(Field*,uchar*,uint)" -> "Field::set_notnull(my_ptrdiff_t)"
"Field::set_null(my_ptrdiff_t)" -> "Field::real_maybe_null() const"
"Field::set_notnull(my_ptrdiff_t)" -> "Field::real_maybe_null() const"
"get_mm_tree(RANGE_OPT_PARAM*,Item*)" -> "Item_equal_iterator::Item_equal_iterator(Item_equal&)"
"get_mm_tree(RANGE_OPT_PARAM*,Item*)" -> "dbug_print_tree(const char*,SEL_TREE*,const RANGE_OPT_PARAM*)"
"get_mm_tree(RANGE_OPT_PARAM*,Item*)" -> "SEL_TREE::SEL_TREE(SEL_TREE::Type)"
"get_mm_tree(RANGE_OPT_PARAM*,Item*)" -> "Item_cond::argument_list()"
"get_mm_tree(RANGE_OPT_PARAM*,Item*)" -> "Item_func::arguments() const"
"get_mm_tree(RANGE_OPT_PARAM*,Item*)" -> "RANGE_OPT_PARAM::statement_should_be_aborted() const"
"get_mm_tree(RANGE_OPT_PARAM*,Item*)" -> "tree_or(RANGE_OPT_PARAM*,SEL_TREE*,SEL_TREE*)"
"get_mm_tree(RANGE_OPT_PARAM*,Item*)" -> "Item_equal_iterator::operator++(int)"
"get_mm_tree(RANGE_OPT_PARAM*,Item*)" -> "get_mm_tree(RANGE_OPT_PARAM*,Item*)"
"get_mm_tree(RANGE_OPT_PARAM*,Item*)" -> "List_iterator<T>::operator++(int) [with T = Item]"
"get_mm_tree(RANGE_OPT_PARAM*,Item*)" -> "Item_equal::get_const()"
"get_mm_tree(RANGE_OPT_PARAM*,Item*)" -> "tree_and(RANGE_OPT_PARAM*,SEL_TREE*,SEL_TREE*)"
"get_mm_tree(RANGE_OPT_PARAM*,Item*)" -> "List_iterator<T>::List_iterator(List<T>&) [with T = Item]"
"get_mm_tree(RANGE_OPT_PARAM*,Item*)" -> "get_mm_parts(RANGE_OPT_PARAM*,Item_func*,Field*,Item_func::Functype,Item*,Item_result)"
"get_mm_tree(RANGE_OPT_PARAM*,Item*)" -> "get_full_func_mm_tree(RANGE_OPT_PARAM*,Item_func*,Item_field*,Item*,bool)"
"Item_equal_iterator::Item_equal_iterator(Item_equal&)" -> "List_iterator_fast<T>::List_iterator_fast(List<T>&) [with T = Item_field]"
"List_iterator_fast<T>::List_iterator_fast(List<T>&) [with T = Item_field]" -> "base_list_iterator::base_list_iterator(base_list&)"
"SEL_TREE::SEL_TREE(SEL_TREE::Type)" -> "List<T>::List() [with T = SEL_IMERGE]"
"SEL_TREE::SEL_TREE(SEL_TREE::Type)" -> "Bitmap<64u>::Bitmap()"
"SEL_TREE::SEL_TREE(SEL_TREE::Type)" -> "Sql_alloc::Sql_alloc()"
"List<T>::List() [with T = SEL_IMERGE]" -> "base_list::base_list()"
"RANGE_OPT_PARAM::statement_should_be_aborted() const" -> "THD::is_error() const"
"tree_or(RANGE_OPT_PARAM*,SEL_TREE*,SEL_TREE*)" -> "imerge_list_or_list(RANGE_OPT_PARAM*,List<SEL_IMERGE>*,List<SEL_IMERGE>*)"
"tree_or(RANGE_OPT_PARAM*,SEL_TREE*,SEL_TREE*)" -> "base_list::empty()"
"tree_or(RANGE_OPT_PARAM*,SEL_TREE*,SEL_TREE*)" -> "SEL_TREE::SEL_TREE(SEL_TREE::Type)"
"tree_or(RANGE_OPT_PARAM*,SEL_TREE*,SEL_TREE*)" -> "Bitmap<64u>::Bitmap()"
"tree_or(RANGE_OPT_PARAM*,SEL_TREE*,SEL_TREE*)" -> "sel_trees_can_be_ored(SEL_TREE*,SEL_TREE*,RANGE_OPT_PARAM*)"
"tree_or(RANGE_OPT_PARAM*,SEL_TREE*,SEL_TREE*)" -> "key_or(RANGE_OPT_PARAM*,SEL_ARG*,SEL_ARG*)"
"tree_or(RANGE_OPT_PARAM*,SEL_TREE*,SEL_TREE*)" -> "SEL_IMERGE::or_sel_tree(RANGE_OPT_PARAM*,SEL_TREE*)"
"tree_or(RANGE_OPT_PARAM*,SEL_TREE*,SEL_TREE*)" -> "imerge_list_or_tree(RANGE_OPT_PARAM*,List<SEL_IMERGE>*,SEL_TREE*)"
"tree_or(RANGE_OPT_PARAM*,SEL_TREE*,SEL_TREE*)" -> "SEL_IMERGE::SEL_IMERGE()"
"tree_or(RANGE_OPT_PARAM*,SEL_TREE*,SEL_TREE*)" -> "SEL_TREE::SEL_TREE()"
"tree_or(RANGE_OPT_PARAM*,SEL_TREE*,SEL_TREE*)" -> "base_list::is_empty() const"
"tree_or(RANGE_OPT_PARAM*,SEL_TREE*,SEL_TREE*)" -> "List<T>::push_back(T*) [with T = SEL_IMERGE]"
"tree_or(RANGE_OPT_PARAM*,SEL_TREE*,SEL_TREE*)" -> "remove_nonrange_trees(RANGE_OPT_PARAM*,SEL_TREE*)"
"tree_or(RANGE_OPT_PARAM*,SEL_TREE*,SEL_TREE*)" -> "Bitmap<64u>::set_bit(uint)"
"imerge_list_or_list(RANGE_OPT_PARAM*,List<SEL_IMERGE>*,List<SEL_IMERGE>*)" -> "List<T>::push_back(T*) [with T = SEL_IMERGE]"
"imerge_list_or_list(RANGE_OPT_PARAM*,List<SEL_IMERGE>*,List<SEL_IMERGE>*)" -> "SEL_IMERGE::or_sel_imerge_with_checks(RANGE_OPT_PARAM*,SEL_IMERGE*)"
"imerge_list_or_list(RANGE_OPT_PARAM*,List<SEL_IMERGE>*,List<SEL_IMERGE>*)" -> "List<T>::head() [with T = SEL_IMERGE]"
"imerge_list_or_list(RANGE_OPT_PARAM*,List<SEL_IMERGE>*,List<SEL_IMERGE>*)" -> "base_list::empty()"
"List<T>::push_back(T*) [with T = SEL_IMERGE]" -> "base_list::push_back(void*)"
"SEL_IMERGE::or_sel_imerge_with_checks(RANGE_OPT_PARAM*,SEL_IMERGE*)" -> "SEL_IMERGE::or_sel_tree_with_checks(RANGE_OPT_PARAM*,SEL_TREE*)"
"SEL_IMERGE::or_sel_tree_with_checks(RANGE_OPT_PARAM*,SEL_TREE*)" -> "SEL_IMERGE::or_sel_tree(RANGE_OPT_PARAM*,SEL_TREE*)"
"SEL_IMERGE::or_sel_tree_with_checks(RANGE_OPT_PARAM*,SEL_TREE*)" -> "sel_trees_can_be_ored(SEL_TREE*,SEL_TREE*,RANGE_OPT_PARAM*)"
"SEL_IMERGE::or_sel_tree_with_checks(RANGE_OPT_PARAM*,SEL_TREE*)" -> "tree_or(RANGE_OPT_PARAM*,SEL_TREE*,SEL_TREE*)"
"SEL_IMERGE::or_sel_tree(RANGE_OPT_PARAM*,SEL_TREE*)" -> "memcpy(void*,const void*,size_t)"
"SEL_IMERGE::or_sel_tree(RANGE_OPT_PARAM*,SEL_TREE*)" -> "alloc_root(MEM_ROOT*,size_t)"
"sel_trees_can_be_ored(SEL_TREE*,SEL_TREE*,RANGE_OPT_PARAM*)" -> "Bitmap<64u>::is_clear_all() const"
"sel_trees_can_be_ored(SEL_TREE*,SEL_TREE*,RANGE_OPT_PARAM*)" -> "Bitmap<64u>::intersect(const Bitmap<64u>&)"
"sel_trees_can_be_ored(SEL_TREE*,SEL_TREE*,RANGE_OPT_PARAM*)" -> "dbug_print_tree(const char*,SEL_TREE*,const RANGE_OPT_PARAM*)"
"sel_trees_can_be_ored(SEL_TREE*,SEL_TREE*,RANGE_OPT_PARAM*)" -> "Bitmap<64u>::is_set(uint) const"
"key_or(RANGE_OPT_PARAM*,SEL_ARG*,SEL_ARG*)" -> "SEL_ARG::first()"
"key_or(RANGE_OPT_PARAM*,SEL_ARG*,SEL_ARG*)" -> "SEL_ARG::clone_first(SEL_ARG*)"
"key_or(RANGE_OPT_PARAM*,SEL_ARG*,SEL_ARG*)" -> "SEL_ARG::increment_use_count(long int)"
"key_or(RANGE_OPT_PARAM*,SEL_ARG*,SEL_ARG*)" -> "SEL_ARG::copy_min_to_min(SEL_ARG*)"
"key_or(RANGE_OPT_PARAM*,SEL_ARG*,SEL_ARG*)" -> "SEL_ARG::copy_max_to_min(SEL_ARG*)"
"key_or(RANGE_OPT_PARAM*,SEL_ARG*,SEL_ARG*)" -> "SEL_ARG::copy_min_to_max(SEL_ARG*)"
"key_or(RANGE_OPT_PARAM*,SEL_ARG*,SEL_ARG*)" -> "SEL_ARG::cmp_max_to_max(const SEL_ARG*) const"
"key_or(RANGE_OPT_PARAM*,SEL_ARG*,SEL_ARG*)" -> "SEL_ARG::cmp_min_to_max(const SEL_ARG*) const"
"key_or(RANGE_OPT_PARAM*,SEL_ARG*,SEL_ARG*)" -> "SEL_ARG::make_root()"
"key_or(RANGE_OPT_PARAM*,SEL_ARG*,SEL_ARG*)" -> "SEL_ARG::SEL_ARG(SEL_ARG&)"
"key_or(RANGE_OPT_PARAM*,SEL_ARG*,SEL_ARG*)" -> "SEL_ARG::merge_flags(SEL_ARG*)"
"key_or(RANGE_OPT_PARAM*,SEL_ARG*,SEL_ARG*)" -> "SEL_ARG::cmp_min_to_min(const SEL_ARG*) const"
"key_or(RANGE_OPT_PARAM*,SEL_ARG*,SEL_ARG*)" -> "SEL_ARG::free_tree()"
"key_or(RANGE_OPT_PARAM*,SEL_ARG*,SEL_ARG*)" -> "SEL_ARG::clone_tree(RANGE_OPT_PARAM*)"
"key_or(RANGE_OPT_PARAM*,SEL_ARG*,SEL_ARG*)" -> "SEL_ARG::tree_delete(SEL_ARG*)"
"key_or(RANGE_OPT_PARAM*,SEL_ARG*,SEL_ARG*)" -> "SEL_ARG::SEL_ARG(SEL_ARG::Type)"
"key_or(RANGE_OPT_PARAM*,SEL_ARG*,SEL_ARG*)" -> "SEL_ARG::clone_last(SEL_ARG*)"
"key_or(RANGE_OPT_PARAM*,SEL_ARG*,SEL_ARG*)" -> "SEL_ARG::insert(SEL_ARG*)"
"key_or(RANGE_OPT_PARAM*,SEL_ARG*,SEL_ARG*)" -> "SEL_ARG::is_same(const SEL_ARG*) const"
"key_or(RANGE_OPT_PARAM*,SEL_ARG*,SEL_ARG*)" -> "SEL_ARG::find_range(SEL_ARG*)"
"key_or(RANGE_OPT_PARAM*,SEL_ARG*,SEL_ARG*)" -> "SEL_ARG::copy_min(SEL_ARG*)"
"key_or(RANGE_OPT_PARAM*,SEL_ARG*,SEL_ARG*)" -> "key_or(RANGE_OPT_PARAM*,SEL_ARG*,SEL_ARG*)"
"key_or(RANGE_OPT_PARAM*,SEL_ARG*,SEL_ARG*)" -> "SEL_ARG::cmp_max_to_min(const SEL_ARG*) const"
"key_or(RANGE_OPT_PARAM*,SEL_ARG*,SEL_ARG*)" -> "eq_tree(SEL_ARG*,SEL_ARG*)"
"key_or(RANGE_OPT_PARAM*,SEL_ARG*,SEL_ARG*)" -> "SEL_ARG::copy_max(SEL_ARG*)"
"SEL_ARG::clone_first(SEL_ARG*)" -> "SEL_ARG::SEL_ARG(Field*,uint8,uchar*,uchar*,uint8,uint8,uint8)"
"SEL_ARG::SEL_ARG(Field*,uint8,uchar*,uchar*,uint8,uint8,uint8)" -> "Field::real_maybe_null() const"
"SEL_ARG::SEL_ARG(Field*,uint8,uchar*,uchar*,uint8,uint8,uint8)" -> "Sql_alloc::Sql_alloc()"
"SEL_ARG::increment_use_count(long int)" -> "SEL_ARG::increment_use_count(long int)"
"SEL_ARG::increment_use_count(long int)" -> "SEL_ARG::first()"
"SEL_ARG::cmp_max_to_max(const SEL_ARG*) const" -> "sel_cmp(Field*,uchar*,uchar*,uint8,uint8)"
"sel_cmp(Field*,uchar*,uchar*,uint8,uint8)" -> "Field::real_maybe_null() const"
"SEL_ARG::cmp_min_to_max(const SEL_ARG*) const" -> "sel_cmp(Field*,uchar*,uchar*,uint8,uint8)"
"SEL_ARG::SEL_ARG(SEL_ARG&)" -> "Sql_alloc::Sql_alloc()"
"SEL_ARG::cmp_min_to_min(const SEL_ARG*) const" -> "sel_cmp(Field*,uchar*,uchar*,uint8,uint8)"
"SEL_ARG::free_tree()" -> "SEL_ARG::first()"
"SEL_ARG::free_tree()" -> "SEL_ARG::free_tree()"
"SEL_ARG::clone_tree(RANGE_OPT_PARAM*)" -> "SEL_ARG::clone(RANGE_OPT_PARAM*,SEL_ARG*,SEL_ARG**)"
"SEL_ARG::clone_tree(RANGE_OPT_PARAM*)" -> "SEL_ARG::SEL_ARG()"
"SEL_ARG::clone(RANGE_OPT_PARAM*,SEL_ARG*,SEL_ARG**)" -> "SEL_ARG::SEL_ARG(SEL_ARG::Type)"
"SEL_ARG::clone(RANGE_OPT_PARAM*,SEL_ARG*,SEL_ARG**)" -> "SEL_ARG::increment_use_count(long int)"
"SEL_ARG::clone(RANGE_OPT_PARAM*,SEL_ARG*,SEL_ARG**)" -> "SEL_ARG::clone(RANGE_OPT_PARAM*,SEL_ARG*,SEL_ARG**)"
"SEL_ARG::clone(RANGE_OPT_PARAM*,SEL_ARG*,SEL_ARG**)" -> "SEL_ARG::SEL_ARG(Field*,uint8,uchar*,uchar*,uint8,uint8,uint8)"
"SEL_ARG::SEL_ARG(SEL_ARG::Type)" -> "Sql_alloc::Sql_alloc()"
"SEL_ARG::SEL_ARG()" -> "Sql_alloc::Sql_alloc()"
"SEL_ARG::tree_delete(SEL_ARG*)" -> "SEL_ARG::increment_use_count(long int)"
"SEL_ARG::tree_delete(SEL_ARG*)" -> "rb_delete_fixup(SEL_ARG*,SEL_ARG*,SEL_ARG*)"
"SEL_ARG::tree_delete(SEL_ARG*)" -> "SEL_ARG::parent_ptr()"
"rb_delete_fixup(SEL_ARG*,SEL_ARG*,SEL_ARG*)" -> "left_rotate(SEL_ARG**,SEL_ARG*)"
"rb_delete_fixup(SEL_ARG*,SEL_ARG*,SEL_ARG*)" -> "right_rotate(SEL_ARG**,SEL_ARG*)"
"left_rotate(SEL_ARG**,SEL_ARG*)" -> "SEL_ARG::parent_ptr()"
"right_rotate(SEL_ARG**,SEL_ARG*)" -> "SEL_ARG::parent_ptr()"
"SEL_ARG::clone_last(SEL_ARG*)" -> "SEL_ARG::SEL_ARG(Field*,uint8,uchar*,uchar*,uint8,uint8,uint8)"
"SEL_ARG::insert(SEL_ARG*)" -> "SEL_ARG::cmp_min_to_min(const SEL_ARG*) const"
"SEL_ARG::insert(SEL_ARG*)" -> "SEL_ARG::rb_insert(SEL_ARG*)"
"SEL_ARG::rb_insert(SEL_ARG*)" -> "left_rotate(SEL_ARG**,SEL_ARG*)"
"SEL_ARG::rb_insert(SEL_ARG*)" -> "right_rotate(SEL_ARG**,SEL_ARG*)"
"SEL_ARG::is_same(const SEL_ARG*) const" -> "SEL_ARG::cmp_max_to_max(const SEL_ARG*) const"
"SEL_ARG::is_same(const SEL_ARG*) const" -> "SEL_ARG::cmp_min_to_min(const SEL_ARG*) const"
"SEL_ARG::find_range(SEL_ARG*)" -> "SEL_ARG::cmp_min_to_min(const SEL_ARG*) const"
"SEL_ARG::copy_min(SEL_ARG*)" -> "SEL_ARG::cmp_min_to_min(const SEL_ARG*) const"
"SEL_ARG::cmp_max_to_min(const SEL_ARG*) const" -> "sel_cmp(Field*,uchar*,uchar*,uint8,uint8)"
"eq_tree(SEL_ARG*,SEL_ARG*)" -> "SEL_ARG::is_same(const SEL_ARG*) const"
"eq_tree(SEL_ARG*,SEL_ARG*)" -> "eq_tree(SEL_ARG*,SEL_ARG*)"
"SEL_ARG::copy_max(SEL_ARG*)" -> "SEL_ARG::cmp_max_to_max(const SEL_ARG*) const"
"imerge_list_or_tree(RANGE_OPT_PARAM*,List<SEL_IMERGE>*,SEL_TREE*)" -> "SEL_TREE::SEL_TREE(SEL_TREE*,RANGE_OPT_PARAM*)"
"imerge_list_or_tree(RANGE_OPT_PARAM*,List<SEL_IMERGE>*,SEL_TREE*)" -> "List_iterator<T>::remove() [with T = SEL_IMERGE]"
"imerge_list_or_tree(RANGE_OPT_PARAM*,List<SEL_IMERGE>*,SEL_TREE*)" -> "List_iterator<T>::List_iterator(List<T>&) [with T = SEL_IMERGE]"
"imerge_list_or_tree(RANGE_OPT_PARAM*,List<SEL_IMERGE>*,SEL_TREE*)" -> "SEL_IMERGE::or_sel_tree_with_checks(RANGE_OPT_PARAM*,SEL_TREE*)"
"imerge_list_or_tree(RANGE_OPT_PARAM*,List<SEL_IMERGE>*,SEL_TREE*)" -> "Bitmap<64u>::is_clear_all() const"
"imerge_list_or_tree(RANGE_OPT_PARAM*,List<SEL_IMERGE>*,SEL_TREE*)" -> "base_list::is_empty() const"
"imerge_list_or_tree(RANGE_OPT_PARAM*,List<SEL_IMERGE>*,SEL_TREE*)" -> "List_iterator<T>::operator++(int) [with T = SEL_IMERGE]"
"SEL_TREE::SEL_TREE(SEL_TREE*,RANGE_OPT_PARAM*)" -> "Sql_alloc::Sql_alloc()"
"SEL_TREE::SEL_TREE(SEL_TREE*,RANGE_OPT_PARAM*)" -> "Bitmap<64u>::Bitmap()"
"SEL_TREE::SEL_TREE(SEL_TREE*,RANGE_OPT_PARAM*)" -> "List_iterator<T>::List_iterator(List<T>&) [with T = SEL_IMERGE]"
"SEL_TREE::SEL_TREE(SEL_TREE*,RANGE_OPT_PARAM*)" -> "List<T>::List() [with T = SEL_IMERGE]"
"SEL_TREE::SEL_TREE(SEL_TREE*,RANGE_OPT_PARAM*)" -> "base_list::empty()"
"SEL_TREE::SEL_TREE(SEL_TREE*,RANGE_OPT_PARAM*)" -> "SEL_IMERGE::SEL_IMERGE(SEL_IMERGE*,RANGE_OPT_PARAM*)"
"SEL_TREE::SEL_TREE(SEL_TREE*,RANGE_OPT_PARAM*)" -> "List_iterator<T>::operator++(int) [with T = SEL_IMERGE]"
"SEL_TREE::SEL_TREE(SEL_TREE*,RANGE_OPT_PARAM*)" -> "SEL_ARG::increment_use_count(long int)"
"SEL_TREE::SEL_TREE(SEL_TREE*,RANGE_OPT_PARAM*)" -> "List<T>::push_back(T*) [with T = SEL_IMERGE]"
"List_iterator<T>::List_iterator(List<T>&) [with T = SEL_IMERGE]" -> "base_list_iterator::base_list_iterator(base_list&)"
"SEL_IMERGE::SEL_IMERGE(SEL_IMERGE*,RANGE_OPT_PARAM*)" -> "Sql_alloc::Sql_alloc()"
"SEL_IMERGE::SEL_IMERGE(SEL_IMERGE*,RANGE_OPT_PARAM*)" -> "alloc_root(MEM_ROOT*,size_t)"
"SEL_IMERGE::SEL_IMERGE(SEL_IMERGE*,RANGE_OPT_PARAM*)" -> "SEL_TREE::SEL_TREE(SEL_TREE*,RANGE_OPT_PARAM*)"
"List_iterator<T>::operator++(int) [with T = SEL_IMERGE]" -> "base_list_iterator::next()"
"List_iterator<T>::remove() [with T = SEL_IMERGE]" -> "base_list_iterator::remove()"
"SEL_IMERGE::SEL_IMERGE()" -> "Sql_alloc::Sql_alloc()"
"SEL_TREE::SEL_TREE()" -> "Bitmap<64u>::Bitmap()"
"SEL_TREE::SEL_TREE()" -> "List<T>::List() [with T = SEL_IMERGE]"
"SEL_TREE::SEL_TREE()" -> "memset(void*,int,size_t)"
"SEL_TREE::SEL_TREE()" -> "Sql_alloc::Sql_alloc()"
"remove_nonrange_trees(RANGE_OPT_PARAM*,SEL_TREE*)" -> "Bitmap<64u>::clear_bit(uint)"
"Item_equal_iterator::operator++(int)" -> "List_iterator_fast<T>::operator++(int) [with T = Item_field]"
"List_iterator_fast<T>::operator++(int) [with T = Item_field]" -> "base_list_iterator::next_fast()"
"tree_and(RANGE_OPT_PARAM*,SEL_TREE*,SEL_TREE*)" -> "SEL_ARG::simple_key()"
"tree_and(RANGE_OPT_PARAM*,SEL_TREE*,SEL_TREE*)" -> "key_and(RANGE_OPT_PARAM*,SEL_ARG*,SEL_ARG*,uint)"
"tree_and(RANGE_OPT_PARAM*,SEL_TREE*,SEL_TREE*)" -> "Bitmap<64u>::Bitmap()"
"tree_and(RANGE_OPT_PARAM*,SEL_TREE*,SEL_TREE*)" -> "imerge_list_and_list(List<SEL_IMERGE>*,List<SEL_IMERGE>*)"
"tree_and(RANGE_OPT_PARAM*,SEL_TREE*,SEL_TREE*)" -> "Bitmap<64u>::set_bit(uint)"
"tree_and(RANGE_OPT_PARAM*,SEL_TREE*,SEL_TREE*)" -> "dbug_print_tree(const char*,SEL_TREE*,const RANGE_OPT_PARAM*)"
"key_and(RANGE_OPT_PARAM*,SEL_ARG*,SEL_ARG*,uint)" -> "key_and(RANGE_OPT_PARAM*,SEL_ARG*,SEL_ARG*,uint)"
"key_and(RANGE_OPT_PARAM*,SEL_ARG*,SEL_ARG*,uint)" -> "SEL_ARG::clone_and(SEL_ARG*)"
"key_and(RANGE_OPT_PARAM*,SEL_ARG*,SEL_ARG*,uint)" -> "SEL_ARG::free_tree()"
"key_and(RANGE_OPT_PARAM*,SEL_ARG*,SEL_ARG*,uint)" -> "SEL_ARG::first()"
"key_and(RANGE_OPT_PARAM*,SEL_ARG*,SEL_ARG*,uint)" -> "SEL_ARG::increment_use_count(long int)"
"key_and(RANGE_OPT_PARAM*,SEL_ARG*,SEL_ARG*,uint)" -> "and_all_keys(RANGE_OPT_PARAM*,SEL_ARG*,SEL_ARG*,uint)"
"key_and(RANGE_OPT_PARAM*,SEL_ARG*,SEL_ARG*,uint)" -> "get_range(SEL_ARG**,SEL_ARG**,SEL_ARG*)"
"key_and(RANGE_OPT_PARAM*,SEL_ARG*,SEL_ARG*,uint)" -> "SEL_ARG::clone_tree(RANGE_OPT_PARAM*)"
"key_and(RANGE_OPT_PARAM*,SEL_ARG*,SEL_ARG*,uint)" -> "SEL_ARG::cmp_max_to_max(const SEL_ARG*) const"
"key_and(RANGE_OPT_PARAM*,SEL_ARG*,SEL_ARG*,uint)" -> "SEL_ARG::insert(SEL_ARG*)"
"key_and(RANGE_OPT_PARAM*,SEL_ARG*,SEL_ARG*,uint)" -> "SEL_ARG::cmp_min_to_min(const SEL_ARG*) const"
"key_and(RANGE_OPT_PARAM*,SEL_ARG*,SEL_ARG*,uint)" -> "SEL_ARG::maybe_smaller()"
"SEL_ARG::clone_and(SEL_ARG*)" -> "SEL_ARG::SEL_ARG(Field*,uint8,uchar*,uchar*,uint8,uint8,uint8)"
"SEL_ARG::clone_and(SEL_ARG*)" -> "SEL_ARG::cmp_min_to_min(const SEL_ARG*) const"
"SEL_ARG::clone_and(SEL_ARG*)" -> "SEL_ARG::cmp_max_to_max(const SEL_ARG*) const"
"and_all_keys(RANGE_OPT_PARAM*,SEL_ARG*,SEL_ARG*,uint)" -> "SEL_ARG::first()"
"and_all_keys(RANGE_OPT_PARAM*,SEL_ARG*,SEL_ARG*,uint)" -> "SEL_ARG::tree_delete(SEL_ARG*)"
"and_all_keys(RANGE_OPT_PARAM*,SEL_ARG*,SEL_ARG*,uint)" -> "key_and(RANGE_OPT_PARAM*,SEL_ARG*,SEL_ARG*,uint)"
"and_all_keys(RANGE_OPT_PARAM*,SEL_ARG*,SEL_ARG*,uint)" -> "SEL_ARG::increment_use_count(long int)"
"get_range(SEL_ARG**,SEL_ARG**,SEL_ARG*)" -> "SEL_ARG::cmp_max_to_min(const SEL_ARG*) const"
"get_range(SEL_ARG**,SEL_ARG**,SEL_ARG*)" -> "SEL_ARG::cmp_min_to_max(const SEL_ARG*) const"
"get_range(SEL_ARG**,SEL_ARG**,SEL_ARG*)" -> "SEL_ARG::find_range(SEL_ARG*)"
"imerge_list_and_list(List<SEL_IMERGE>*,List<SEL_IMERGE>*)" -> "List<T>::concat(List<T>*) [with T = SEL_IMERGE]"
"List<T>::concat(List<T>*) [with T = SEL_IMERGE]" -> "base_list::concat(base_list*)"
"get_mm_parts(RANGE_OPT_PARAM*,Item_func*,Field*,Item_func::Functype,Item*,Item_result)" -> "sel_add(SEL_ARG*,SEL_ARG*)"
"get_mm_parts(RANGE_OPT_PARAM*,Item_func*,Field*,Item_func::Functype,Item*,Item_result)" -> "Bitmap<64u>::set_bit(uint)"
"get_mm_parts(RANGE_OPT_PARAM*,Item_func*,Field*,Item_func::Functype,Item*,Item_result)" -> "SEL_TREE::SEL_TREE()"
"get_mm_parts(RANGE_OPT_PARAM*,Item_func*,Field*,Item_func::Functype,Item*,Item_result)" -> "is_spatial_operator(Item_func::Functype)"
"get_mm_parts(RANGE_OPT_PARAM*,Item_func*,Field*,Item_func::Functype,Item*,Item_result)" -> "SEL_ARG::SEL_ARG(SEL_ARG::Type)"
"get_mm_parts(RANGE_OPT_PARAM*,Item_func*,Field*,Item_func::Functype,Item*,Item_result)" -> "Bitmap<64u>::is_clear_all() const"
"get_mm_parts(RANGE_OPT_PARAM*,Item_func*,Field*,Item_func::Functype,Item*,Item_result)" -> "get_mm_leaf(RANGE_OPT_PARAM*,Item*,Field*,KEY_PART*,Item_func::Functype,Item*)"
"get_mm_parts(RANGE_OPT_PARAM*,Item_func*,Field*,Item_func::Functype,Item*,Item_result)" -> "base_list::is_empty() const"
"get_mm_leaf(RANGE_OPT_PARAM*,Item*,Field*,KEY_PART*,Item_func::Functype,Item*)" -> "Opt_trace_struct::add_alnum(const char*,const char*)"
"get_mm_leaf(RANGE_OPT_PARAM*,Item*,Field*,KEY_PART*,Item_func::Functype,Item*)" -> "Opt_trace_object::Opt_trace_object(Opt_trace_context*,const char*,Opt_trace_context::feature_value)"
"get_mm_leaf(RANGE_OPT_PARAM*,Item*,Field*,KEY_PART*,Item_func::Functype,Item*)" -> "if_extended_explain_warn_index_not_applicable(const RANGE_OPT_PARAM*,uint,const Field*)"
"get_mm_leaf(RANGE_OPT_PARAM*,Item*,Field*,KEY_PART*,Item_func::Functype,Item*)" -> "Field::real_maybe_null() const"
"get_mm_leaf(RANGE_OPT_PARAM*,Item*,Field*,KEY_PART*,Item_func::Functype,Item*)" -> "Field::is_temporal() const"
"get_mm_leaf(RANGE_OPT_PARAM*,Item*,Field*,KEY_PART*,Item_func::Functype,Item*)" -> "String::copy(const String&)"
"get_mm_leaf(RANGE_OPT_PARAM*,Item*,Field*,KEY_PART*,Item_func::Functype,Item*)" -> "SEL_ARG::SEL_ARG(Field*,const uchar*,const uchar*)"
"get_mm_leaf(RANGE_OPT_PARAM*,Item*,Field*,KEY_PART*,Item_func::Functype,Item*)" -> "Field::is_real_null(my_ptrdiff_t) const"
"get_mm_leaf(RANGE_OPT_PARAM*,Item*,Field*,KEY_PART*,Item_func::Functype,Item*)" -> "String::length() const"
"get_mm_leaf(RANGE_OPT_PARAM*,Item*,Field*,KEY_PART*,Item_func::Functype,Item*)" -> "alloc_root(MEM_ROOT*,size_t)"
"get_mm_leaf(RANGE_OPT_PARAM*,Item*,Field*,KEY_PART*,Item_func::Functype,Item*)" -> "Item::is_temporal() const"
"get_mm_leaf(RANGE_OPT_PARAM*,Item*,Field*,KEY_PART*,Item_func::Functype,Item*)" -> "Opt_trace_object::Opt_trace_object(Opt_trace_context*,Opt_trace_context::feature_value)"
"get_mm_leaf(RANGE_OPT_PARAM*,Item*,Field*,KEY_PART*,Item_func::Functype,Item*)" -> "String::ptr() const"
"get_mm_leaf(RANGE_OPT_PARAM*,Item*,Field*,KEY_PART*,Item_func::Functype,Item*)" -> "field_time_cmp_date(const Field*,const Item*)"
"get_mm_leaf(RANGE_OPT_PARAM*,Item*,Field*,KEY_PART*,Item_func::Functype,Item*)" -> "save_value_and_handle_conversion(SEL_ARG**,Item*,Item_func::Functype,Field*,const char**,MEM_ROOT*)"
"get_mm_leaf(RANGE_OPT_PARAM*,Item*,Field*,KEY_PART*,Item_func::Functype,Item*)" -> "stored_field_cmp_to_item(THD*,Field*,Item*)"
"get_mm_leaf(RANGE_OPT_PARAM*,Item*,Field*,KEY_PART*,Item_func::Functype,Item*)" -> "String::String(char*,uint32,const CHARSET_INFO*)"
"get_mm_leaf(RANGE_OPT_PARAM*,Item*,Field*,KEY_PART*,Item_func::Functype,Item*)" -> "__builtin_expect(long int,long int)"
"if_extended_explain_warn_index_not_applicable(const RANGE_OPT_PARAM*,uint,const Field*)" -> "push_warning_printf(THD*,Sql_condition::enum_warning_level,uint,const char*,...)"
"if_extended_explain_warn_index_not_applicable(const RANGE_OPT_PARAM*,uint,const Field*)" -> "_current_thd()"
"Field::is_temporal() const" -> "is_temporal_type(enum_field_types)"
"String::copy(const String&)" -> "String::alloc(uint32)"
"String::copy(const String&)" -> "memmove(void*,const void*,size_t)"
"SEL_ARG::SEL_ARG(Field*,const uchar*,const uchar*)" -> "Field::real_maybe_null() const"
"SEL_ARG::SEL_ARG(Field*,const uchar*,const uchar*)" -> "Sql_alloc::Sql_alloc()"
"Field::is_real_null(my_ptrdiff_t) const" -> "Field::real_maybe_null() const"
"Item::is_temporal() const" -> "is_temporal_type(enum_field_types)"
"field_time_cmp_date(const Field*,const Item*)" -> "Field::is_temporal_with_date() const"
"field_time_cmp_date(const Field*,const Item*)" -> "Item::is_temporal_with_date() const"
"field_time_cmp_date(const Field*,const Item*)" -> "Field::is_temporal() const"
"Field::is_temporal_with_date() const" -> "is_temporal_type_with_date(enum_field_types)"
"Item::is_temporal_with_date() const" -> "is_temporal_type_with_date(enum_field_types)"
"save_value_and_handle_conversion(SEL_ARG**,Item*,Item_func::Functype,Field*,const char**,MEM_ROOT*)" -> "Item::save_in_field_no_warnings(Field*,bool)"
"save_value_and_handle_conversion(SEL_ARG**,Item*,Item_func::Functype,Field*,const char**,MEM_ROOT*)" -> "SEL_ARG::SEL_ARG(Field*,const uchar*,const uchar*)"
"Item::save_in_field_no_warnings(Field*,bool)" -> "dbug_tmp_use_all_columns(TABLE*,MY_BITMAP*)"
"Item::save_in_field_no_warnings(Field*,bool)" -> "dbug_tmp_restore_column_map(MY_BITMAP*,my_bitmap_map*)"
"stored_field_cmp_to_item(THD*,Field*,Item*)" -> "my_time_compare(MYSQL_TIME*,MYSQL_TIME*)"
"stored_field_cmp_to_item(THD*,Field*,Item*)" -> "Item::is_temporal() const"
"stored_field_cmp_to_item(THD*,Field*,Item*)" -> "sortcmp(const String*,const String*,const CHARSET_INFO*)"
"stored_field_cmp_to_item(THD*,Field*,Item*)" -> "Field::is_temporal_with_date() const"
"stored_field_cmp_to_item(THD*,Field*,Item*)" -> "item_cmp_type(Item_result,Item_result)"
"stored_field_cmp_to_item(THD*,Field*,Item*)" -> "my_decimal_cmp(const my_decimal*,const my_decimal*)"
"stored_field_cmp_to_item(THD*,Field*,Item*)" -> "String::String(char*,uint32,const CHARSET_INFO*)"
"stored_field_cmp_to_item(THD*,Field*,Item*)" -> "my_decimal::my_decimal()"
"stored_field_cmp_to_item(THD*,Field*,Item*)" -> "get_mysql_time_from_str(THD*,String*,timestamp_type,const char*,MYSQL_TIME*)"
"stored_field_cmp_to_item(THD*,Field*,Item*)" -> "field_type_to_timestamp_type(enum_field_types)"
"stored_field_cmp_to_item(THD*,Field*,Item*)" -> "Field::val_str(String*)"
"my_time_compare(MYSQL_TIME*,MYSQL_TIME*)" -> "TIME_to_ulonglong_datetime(const MYSQL_TIME*)"
"sortcmp(const String*,const String*,const CHARSET_INFO*)" -> "String::ptr() const"
"sortcmp(const String*,const String*,const CHARSET_INFO*)" -> "String::length() const"
"my_decimal_cmp(const my_decimal*,const my_decimal*)" -> "decimal_cmp(const decimal_t*,const decimal_t*)"
"decimal_cmp(const decimal_t*,const decimal_t*)" -> "do_sub(const decimal_t*,const decimal_t*,decimal_t*)"
"decimal_cmp(const decimal_t*,const decimal_t*)" -> "__builtin_expect(long int,long int)"
"do_sub(const decimal_t*,const decimal_t*,decimal_t*)" -> "__builtin_expect(long int,long int)"
"get_mysql_time_from_str(THD*,String*,timestamp_type,const char*,MYSQL_TIME*)" -> "ErrConvString::ErrConvString(String*)"
"get_mysql_time_from_str(THD*,String*,timestamp_type,const char*,MYSQL_TIME*)" -> "make_truncated_value_warning(THD*,Sql_condition::enum_warning_level,ErrConvString,timestamp_type,const char*)"
"get_mysql_time_from_str(THD*,String*,timestamp_type,const char*,MYSQL_TIME*)" -> "str_to_datetime(const String*,MYSQL_TIME*,uint,MYSQL_TIME_STATUS*)"
"make_truncated_value_warning(THD*,Sql_condition::enum_warning_level,ErrConvString,timestamp_type,const char*)" -> "_current_thd()"
"make_truncated_value_warning(THD*,Sql_condition::enum_warning_level,ErrConvString,timestamp_type,const char*)" -> "ErrConvString::ptr()"
"make_truncated_value_warning(THD*,Sql_condition::enum_warning_level,ErrConvString,timestamp_type,const char*)" -> "Diagnostics_area::current_row_for_warning() const"
"make_truncated_value_warning(THD*,Sql_condition::enum_warning_level,ErrConvString,timestamp_type,const char*)" -> "THD::get_stmt_da()"
"make_truncated_value_warning(THD*,Sql_condition::enum_warning_level,ErrConvString,timestamp_type,const char*)" -> "push_warning(THD*,Sql_condition::enum_warning_level,uint,const char*)"
"str_to_datetime(const String*,MYSQL_TIME*,uint,MYSQL_TIME_STATUS*)" -> "String::length() const"
"str_to_datetime(const String*,MYSQL_TIME*,uint,MYSQL_TIME_STATUS*)" -> "String::charset() const"
"str_to_datetime(const String*,MYSQL_TIME*,uint,MYSQL_TIME_STATUS*)" -> "String::ptr() const"
"str_to_datetime(const String*,MYSQL_TIME*,uint,MYSQL_TIME_STATUS*)" -> "str_to_datetime(const CHARSET_INFO*,const char*,uint,MYSQL_TIME*,uint,MYSQL_TIME_STATUS*)"
"get_full_func_mm_tree(RANGE_OPT_PARAM*,Item_func*,Item_field*,Item*,bool)" -> "Item_func::arguments() const"
"get_full_func_mm_tree(RANGE_OPT_PARAM*,Item_func*,Item_field*,Item*,bool)" -> "tree_and(RANGE_OPT_PARAM*,SEL_TREE*,SEL_TREE*)"
"get_full_func_mm_tree(RANGE_OPT_PARAM*,Item_func*,Item_field*,Item*,bool)" -> "Item_equal_iterator::Item_equal_iterator(Item_equal&)"
"get_full_func_mm_tree(RANGE_OPT_PARAM*,Item_func*,Item_field*,Item*,bool)" -> "get_func_mm_tree(RANGE_OPT_PARAM*,Item_func*,Field*,Item*,Item_result,bool)"
"get_full_func_mm_tree(RANGE_OPT_PARAM*,Item_func*,Item_field*,Item*,bool)" -> "Item_equal_iterator::operator++(int)"
"get_func_mm_tree(RANGE_OPT_PARAM*,Item_func*,Field*,Item*,Item_result,bool)" -> "Item_func::argument_count() const"
"get_func_mm_tree(RANGE_OPT_PARAM*,Item_func*,Field*,Item*,Item_result,bool)" -> "in_vector::compare_elems(uint,uint)"
"get_func_mm_tree(RANGE_OPT_PARAM*,Item_func*,Field*,Item*,Item_result,bool)" -> "tree_or(RANGE_OPT_PARAM*,SEL_TREE*,SEL_TREE*)"
"get_func_mm_tree(RANGE_OPT_PARAM*,Item_func*,Field*,Item*,Item_result,bool)" -> "get_ne_mm_tree(RANGE_OPT_PARAM*,Item_func*,Field*,Item*,Item*,Item_result)"
"get_func_mm_tree(RANGE_OPT_PARAM*,Item_func*,Field*,Item*,Item_result,bool)" -> "tree_and(RANGE_OPT_PARAM*,SEL_TREE*,SEL_TREE*)"
"get_func_mm_tree(RANGE_OPT_PARAM*,Item_func*,Field*,Item*,Item_result,bool)" -> "SEL_ARG::last()"
"get_func_mm_tree(RANGE_OPT_PARAM*,Item_func*,Field*,Item*,Item_result,bool)" -> "get_mm_parts(RANGE_OPT_PARAM*,Item_func*,Field*,Item_func::Functype,Item*,Item_result)"
"get_func_mm_tree(RANGE_OPT_PARAM*,Item_func*,Field*,Item*,Item_result,bool)" -> "Item_func::arguments() const"
"get_ne_mm_tree(RANGE_OPT_PARAM*,Item_func*,Field*,Item*,Item*,Item_result)" -> "tree_or(RANGE_OPT_PARAM*,SEL_TREE*,SEL_TREE*)"
"get_ne_mm_tree(RANGE_OPT_PARAM*,Item_func*,Field*,Item*,Item*,Item_result)" -> "get_mm_parts(RANGE_OPT_PARAM*,Item_func*,Field*,Item_func::Functype,Item*,Item_result)"
"create_partition_index_description(PART_PRUNE_PARAM*)" -> "fields_ok_for_partition_index(Field**)"
"create_partition_index_description(PART_PRUNE_PARAM*)" -> "get_partition_field_store_length(Field*)"
"create_partition_index_description(PART_PRUNE_PARAM*)" -> "partition_info::is_sub_partitioned()"
"create_partition_index_description(PART_PRUNE_PARAM*)" -> "bitmap_init(MY_BITMAP*,my_bitmap_map*,uint,my_bool)"
"create_partition_index_description(PART_PRUNE_PARAM*)" -> "alloc_root(MEM_ROOT*,size_t)"
"find_used_partitions_imerge(PART_PRUNE_PARAM*,SEL_IMERGE*)" -> "init_all_partitions_iterator(partition_info*,PARTITION_ITERATOR*)"
"find_used_partitions_imerge(PART_PRUNE_PARAM*,SEL_IMERGE*)" -> "find_used_partitions(PART_PRUNE_PARAM*,SEL_ARG*)"
"find_used_partitions_imerge_list(PART_PRUNE_PARAM*,List<SEL_IMERGE>&)" -> "find_used_partitions_imerge(PART_PRUNE_PARAM*,SEL_IMERGE*)"
"find_used_partitions_imerge_list(PART_PRUNE_PARAM*,List<SEL_IMERGE>&)" -> "memcpy(void*,const void*,size_t)"
"find_used_partitions_imerge_list(PART_PRUNE_PARAM*,List<SEL_IMERGE>&)" -> "alloc_root(MEM_ROOT*,size_t)"
"find_used_partitions_imerge_list(PART_PRUNE_PARAM*,List<SEL_IMERGE>&)" -> "bitmap_is_clear_all(const MY_BITMAP*)"
"find_used_partitions_imerge_list(PART_PRUNE_PARAM*,List<SEL_IMERGE>&)" -> "bitmap_set_prefix(MY_BITMAP*,uint)"
"find_used_partitions_imerge_list(PART_PRUNE_PARAM*,List<SEL_IMERGE>&)" -> "bitmap_intersect(MY_BITMAP*,const MY_BITMAP*)"
"find_used_partitions_imerge_list(PART_PRUNE_PARAM*,List<SEL_IMERGE>&)" -> "List<T>::head() [with T = SEL_IMERGE]"
"find_used_partitions_imerge_list(PART_PRUNE_PARAM*,List<SEL_IMERGE>&)" -> "bitmap_init(MY_BITMAP*,my_bitmap_map*,uint,my_bool)"
"find_used_partitions_imerge_list(PART_PRUNE_PARAM*,List<SEL_IMERGE>&)" -> "List_iterator<T>::List_iterator(List<T>&) [with T = SEL_IMERGE]"
"find_used_partitions_imerge_list(PART_PRUNE_PARAM*,List<SEL_IMERGE>&)" -> "memset(void*,int,size_t)"
"find_used_partitions_imerge_list(PART_PRUNE_PARAM*,List<SEL_IMERGE>&)" -> "List_iterator<T>::operator++(int) [with T = SEL_IMERGE]"
"mark_all_partitions_as_used(partition_info*)" -> "bitmap_copy(MY_BITMAP*,const MY_BITMAP*)"
"setup_fields(THD*,Ref_ptr_array,List<Item>&,enum_mark_columns,List<Item>*,bool)" -> "Item_func_set_user_var::set_entry(THD*,bool)"
"setup_fields(THD*,Ref_ptr_array,List<Item>&,enum_mark_columns,List<Item>*,bool)" -> "List_iterator<T>::operator++(int) [with T = Item]"
"setup_fields(THD*,Ref_ptr_array,List<Item>&,enum_mark_columns,List<Item>*,bool)" -> "memset(void*,int,size_t)"
"setup_fields(THD*,Ref_ptr_array,List<Item>&,enum_mark_columns,List<Item>*,bool)" -> "Bounds_checked_array<Element_type>::pop_front() [with Element_type = Item*]"
"setup_fields(THD*,Ref_ptr_array,List<Item>&,enum_mark_columns,List<Item>*,bool)" -> "List_iterator<T>::operator++(int) [with T = Item_func_set_user_var]"
"setup_fields(THD*,Ref_ptr_array,List<Item>&,enum_mark_columns,List<Item>*,bool)" -> "Bounds_checked_array<Element_type>::is_null() const [with Element_type = Item*]"
"setup_fields(THD*,Ref_ptr_array,List<Item>&,enum_mark_columns,List<Item>*,bool)" -> "List_iterator<T>::List_iterator(List<T>&) [with T = Item_func_set_user_var]"
"setup_fields(THD*,Ref_ptr_array,List<Item>&,enum_mark_columns,List<Item>*,bool)" -> "List_iterator<T>::List_iterator(List<T>&) [with T = Item]"
"setup_fields(THD*,Ref_ptr_array,List<Item>&,enum_mark_columns,List<Item>*,bool)" -> "Bounds_checked_array<Element_type>::array() const [with Element_type = Item*]"
"setup_fields(THD*,Ref_ptr_array,List<Item>&,enum_mark_columns,List<Item>*,bool)" -> "Bounds_checked_array<Element_type>::operator[](size_t) [with Element_type = Item*,size_t = long unsigned int]"
"setup_fields(THD*,Ref_ptr_array,List<Item>&,enum_mark_columns,List<Item>*,bool)" -> "THD::is_error() const"
"setup_fields(THD*,Ref_ptr_array,List<Item>&,enum_mark_columns,List<Item>*,bool)" -> "List_iterator<T>::ref() [with T = Item]"
"Item_func_set_user_var::set_entry(THD*,bool)" -> "get_variable(HASH*,const Name_string&,bool)"
"get_variable(HASH*,const Name_string&,bool)" -> "my_hash_search(const HASH*,const uchar*,size_t)"
"get_variable(HASH*,const Name_string&,bool)" -> "my_free(void*)"
"get_variable(HASH*,const Name_string&,bool)" -> "user_var_entry::create(const Name_string&)"
"get_variable(HASH*,const Name_string&,bool)" -> "Simple_cstring::length() const"
"get_variable(HASH*,const Name_string&,bool)" -> "my_hash_insert(HASH*,const uchar*)"
"get_variable(HASH*,const Name_string&,bool)" -> "Simple_cstring::ptr() const"
"user_var_entry::create(const Name_string&)" -> "my_malloc(size_t,myf)"
"user_var_entry::create(const Name_string&)" -> "user_var_entry::init(const Simple_cstring&)"
"user_var_entry::create(const Name_string&)" -> "Simple_cstring::length() const"
"user_var_entry::init(const Simple_cstring&)" -> "user_var_entry::set_type(Item_result)"
"user_var_entry::init(const Simple_cstring&)" -> "_current_thd()"
"user_var_entry::init(const Simple_cstring&)" -> "user_var_entry::copy_name(const Simple_cstring&)"
"user_var_entry::init(const Simple_cstring&)" -> "user_var_entry::reset_value()"
"user_var_entry::init(const Simple_cstring&)" -> "DTCollation::set(const CHARSET_INFO*,Derivation,uint)"
"user_var_entry::copy_name(const Simple_cstring&)" -> "Simple_cstring::length() const"
"user_var_entry::copy_name(const Simple_cstring&)" -> "Simple_cstring::strcpy(char*) const"
"user_var_entry::copy_name(const Simple_cstring&)" -> "user_var_entry::name_ptr() const"
"user_var_entry::copy_name(const Simple_cstring&)" -> "Name_string::Name_string(const char*,size_t)"
"Simple_cstring::strcpy(char*) const" -> "memcpy(void*,const void*,size_t)"
"user_var_entry::name_ptr() const" -> "user_var_entry::internal_buffer_ptr() const"
"List_iterator<T>::operator++(int) [with T = Item_func_set_user_var]" -> "base_list_iterator::next()"
"List_iterator<T>::List_iterator(List<T>&) [with T = Item_func_set_user_var]" -> "base_list_iterator::base_list_iterator(base_list&)"
"List_iterator<T>::ref() [with T = Item]" -> "base_list_iterator::ref()"
"Item::split_sum_func2(THD*,Ref_ptr_array,List<Item>&,Item**,bool)" -> "Bounds_checked_array<Element_type>::operator[](size_t) [with Element_type = Item*,size_t = long unsigned int]"
"Item::split_sum_func2(THD*,Ref_ptr_array,List<Item>&,Item**,bool)" -> "Simple_cstring::ptr() const"
"Item::split_sum_func2(THD*,Ref_ptr_array,List<Item>&,Item**,bool)" -> "List<T>::push_front(T*) [with T = Item]"
"Item::split_sum_func2(THD*,Ref_ptr_array,List<Item>&,Item**,bool)" -> "Item_aggregate_ref::Item_aggregate_ref(Name_resolution_context*,Item**,const char*,const char*)"
"Item::split_sum_func2(THD*,Ref_ptr_array,List<Item>&,Item**,bool)" -> "Item_sum::depended_from()"
"Item::split_sum_func2(THD*,Ref_ptr_array,List<Item>&,Item**,bool)" -> "THD::change_item_tree(Item**,Item*)"
"Item_aggregate_ref::Item_aggregate_ref(Name_resolution_context*,Item**,const char*,const char*)" -> "Item_ref::Item_ref(Name_resolution_context*,Item**,const char*,const char*,bool)"
"count_field_types(SELECT_LEX*,TMP_TABLE_PARAM*,List<Item>&,bool)" -> "List_iterator<T>::operator++(int) [with T = Item]"
"count_field_types(SELECT_LEX*,TMP_TABLE_PARAM*,List<Item>&,bool)" -> "List_iterator<T>::List_iterator(List<T>&) [with T = Item]"
"count_field_types(SELECT_LEX*,TMP_TABLE_PARAM*,List<Item>&,bool)" -> "Item_sum::get_arg(uint)"
"count_field_types(SELECT_LEX*,TMP_TABLE_PARAM*,List<Item>&,bool)" -> "Item_sum::depended_from()"
"count_field_types(SELECT_LEX*,TMP_TABLE_PARAM*,List<Item>&,bool)" -> "Item_sum::get_arg_count() const"
"st_select_lex::setup_ref_array(THD*,uint)" -> "Bounds_checked_array<Element_type>::Bounds_checked_array(Element_type*,size_t) [with Element_type = Item*,size_t = long unsigned int]"
"st_select_lex::setup_ref_array(THD*,uint)" -> "Query_arena::alloc(size_t)"
"st_select_lex::setup_ref_array(THD*,uint)" -> "Bounds_checked_array<Element_type>::is_null() const [with Element_type = Item*]"
"st_select_lex::setup_ref_array(THD*,uint)" -> "Bounds_checked_array<Element_type>::resize(size_t) [with Element_type = Item*,size_t = long unsigned int]"
"st_select_lex::setup_ref_array(THD*,uint)" -> "Bounds_checked_array<Element_type>::size() const [with Element_type = Item*,size_t = long unsigned int]"
"JOIN::alloc_func_list()" -> "JOIN::ORDER_with_src::operator ORDER*()"
"JOIN::alloc_func_list()" -> "Query_arena::calloc(size_t)"
"JOIN::ref_ptr_array_slice(size_t)" -> "Bounds_checked_array<Element_type>::size() const [with Element_type = Item*,size_t = long unsigned int]"
"JOIN::ref_ptr_array_slice(size_t)" -> "Bounds_checked_array<Element_type>::operator[](size_t) [with Element_type = Item*,size_t = long unsigned int]"
"JOIN::ref_ptr_array_slice(size_t)" -> "Bounds_checked_array<Element_type>::Bounds_checked_array(Element_type*,size_t) [with Element_type = Item*,size_t = long unsigned int]"
"Opt_trace_struct::add_select_number(uint)" -> "Opt_trace_struct::add(const char*,uint)"
"Opt_trace_struct::add_select_number(uint)" -> "__builtin_expect(long int,long int)"
"Opt_trace_struct::add_select_number(uint)" -> "Opt_trace_struct::add_alnum(const char*,const char*)"
"opt_trace_print_expanded_query(THD*,st_select_lex*,Opt_trace_object*)" -> "String::ptr() const"
"opt_trace_print_expanded_query(THD*,st_select_lex*,Opt_trace_object*)" -> "Opt_trace_context::support_I_S() const"
"opt_trace_print_expanded_query(THD*,st_select_lex*,Opt_trace_object*)" -> "String::String(char*,uint32,const CHARSET_INFO*)"
"opt_trace_print_expanded_query(THD*,st_select_lex*,Opt_trace_object*)" -> "String::length(uint32)"
"opt_trace_print_expanded_query(THD*,st_select_lex*,Opt_trace_object*)" -> "__builtin_expect(long int,long int)"
"opt_trace_print_expanded_query(THD*,st_select_lex*,Opt_trace_object*)" -> "String::length() const"
"opt_trace_print_expanded_query(THD*,st_select_lex*,Opt_trace_object*)" -> "Opt_trace_struct::add_utf8(const char*,const char*,size_t)"
"opt_trace_print_expanded_query(THD*,st_select_lex*,Opt_trace_object*)" -> "st_select_lex::print(THD*,String*,enum_query_type)"
"Opt_trace_context::support_I_S() const" -> "Opt_trace_stmt::support_I_S() const"
"st_select_lex::print(THD*,String*,enum_query_type)" -> "String::append(char)"
"st_select_lex::print(THD*,String*,enum_query_type)" -> "String::append(const char*,uint32)"
"st_select_lex::print(THD*,String*,enum_query_type)" -> "__builtin_expect(long int,long int)"
"st_select_lex::print(THD*,String*,enum_query_type)" -> "st_select_lex::print_order(String*,ORDER*,enum_query_type)"
"st_select_lex::print(THD*,String*,enum_query_type)" -> "List_iterator_fast<T>::operator++(int) [with T = Item]"
"st_select_lex::print(THD*,String*,enum_query_type)" -> "print_join(THD*,String*,List<TABLE_LIST>*,enum_query_type)"
"st_select_lex::print(THD*,String*,enum_query_type)" -> "Item_name_string::is_autogenerated() const"
"st_select_lex::print(THD*,String*,enum_query_type)" -> "st_select_lex::print_limit(THD*,String*,enum_query_type)"
"st_select_lex::print(THD*,String*,enum_query_type)" -> "List_iterator_fast<T>::List_iterator_fast(List<T>&) [with T = Item]"
"st_select_lex::print(THD*,String*,enum_query_type)" -> "Item::print_item_w_name(String*,enum_query_type)"
"st_select_lex::print(THD*,String*,enum_query_type)" -> "String::append_ulonglong(ulonglong)"
"st_select_lex::print(THD*,String*,enum_query_type)" -> "String::append(const char*)"
"st_select_lex::print(THD*,String*,enum_query_type)" -> "THD::is_error() const"
"st_select_lex::print(THD*,String*,enum_query_type)" -> "_current_thd()"
"st_select_lex::print_order(String*,ORDER*,enum_query_type)" -> "Item::print_for_order(String*,enum_query_type,bool)"
"st_select_lex::print_order(String*,ORDER*,enum_query_type)" -> "my_snprintf(char*,size_t,const char*,...)"
"st_select_lex::print_order(String*,ORDER*,enum_query_type)" -> "String::append(const char*,uint32)"
"st_select_lex::print_order(String*,ORDER*,enum_query_type)" -> "String::append(char)"
"Item::print_for_order(String*,enum_query_type,bool)" -> "append_identifier(THD*,String*,Simple_cstring)"
"Item::print_for_order(String*,enum_query_type,bool)" -> "_current_thd()"
"append_identifier(THD*,String*,Simple_cstring)" -> "append_identifier(THD*,String*,const char*,uint)"
"append_identifier(THD*,String*,Simple_cstring)" -> "Simple_cstring::length() const"
"append_identifier(THD*,String*,Simple_cstring)" -> "Simple_cstring::ptr() const"
"print_join(THD*,String*,List<TABLE_LIST>*,enum_query_type)" -> "Query_arena::alloc(size_t)"
"print_join(THD*,String*,List<TABLE_LIST>*,enum_query_type)" -> "List_iterator_fast<T>::List_iterator_fast(List<T>&) [with T = TABLE_LIST]"
"print_join(THD*,String*,List<TABLE_LIST>*,enum_query_type)" -> "String::append(const char*,uint32)"
"print_join(THD*,String*,List<TABLE_LIST>*,enum_query_type)" -> "print_table_array(THD*,String*,TABLE_LIST**,TABLE_LIST**,enum_query_type)"
"print_join(THD*,String*,List<TABLE_LIST>*,enum_query_type)" -> "List_iterator_fast<T>::operator++(int) [with T = TABLE_LIST]"
"print_join(THD*,String*,List<TABLE_LIST>*,enum_query_type)" -> "List_iterator_fast<T>::rewind() [with T = TABLE_LIST]"
"print_table_array(THD*,String*,TABLE_LIST**,TABLE_LIST**,enum_query_type)" -> "TABLE_LIST::print(THD*,String*,enum_query_type)"
"print_table_array(THD*,String*,TABLE_LIST**,TABLE_LIST**,enum_query_type)" -> "String::append(const char*,uint32)"
"print_table_array(THD*,String*,TABLE_LIST**,TABLE_LIST**,enum_query_type)" -> "String::append(char)"
"print_table_array(THD*,String*,TABLE_LIST**,TABLE_LIST**,enum_query_type)" -> "TABLE_LIST::join_cond() const"
"TABLE_LIST::print(THD*,String*,enum_query_type)" -> "List_iterator<T>::List_iterator(List<T>&) [with T = Index_hint]"
"TABLE_LIST::print(THD*,String*,enum_query_type)" -> "strlen(const char*)"
"TABLE_LIST::print(THD*,String*,enum_query_type)" -> "List_iterator<T>::operator++(int) [with T = String]"
"TABLE_LIST::print(THD*,String*,enum_query_type)" -> "String::append(const char*,uint32)"
"TABLE_LIST::print(THD*,String*,enum_query_type)" -> "__builtin_strcpy(char*,const char*)"
"TABLE_LIST::print(THD*,String*,enum_query_type)" -> "append_identifier(THD*,String*,const char*,uint)"
"TABLE_LIST::print(THD*,String*,enum_query_type)" -> "st_select_lex_unit::print(String*,enum_query_type)"
"TABLE_LIST::print(THD*,String*,enum_query_type)" -> "String::append(char)"
"TABLE_LIST::print(THD*,String*,enum_query_type)" -> "String::length() const"
"TABLE_LIST::print(THD*,String*,enum_query_type)" -> "List_iterator<T>::List_iterator(List<T>&) [with T = String]"
"TABLE_LIST::print(THD*,String*,enum_query_type)" -> "List_iterator<T>::operator++(int) [with T = Index_hint]"
"TABLE_LIST::print(THD*,String*,enum_query_type)" -> "Index_hint::print(THD*,String*)"
"TABLE_LIST::print(THD*,String*,enum_query_type)" -> "db_is_default_db(const char*,size_t,const THD*)"
"TABLE_LIST::print(THD*,String*,enum_query_type)" -> "String::c_ptr()"
"TABLE_LIST::print(THD*,String*,enum_query_type)" -> "print_join(THD*,String*,List<TABLE_LIST>*,enum_query_type)"
"st_select_lex_unit::print(String*,enum_query_type)" -> "st_select_lex::print_limit(THD*,String*,enum_query_type)"
"st_select_lex_unit::print(String*,enum_query_type)" -> "st_select_lex_unit::first_select()"
"st_select_lex_unit::print(String*,enum_query_type)" -> "String::append(const char*,uint32)"
"st_select_lex_unit::print(String*,enum_query_type)" -> "st_select_lex::next_select()"
"st_select_lex_unit::print(String*,enum_query_type)" -> "String::append(char)"
"st_select_lex_unit::print(String*,enum_query_type)" -> "st_select_lex::print_order(String*,ORDER*,enum_query_type)"
"st_select_lex_unit::print(String*,enum_query_type)" -> "st_select_lex::print(THD*,String*,enum_query_type)"
"st_select_lex::print_limit(THD*,String*,enum_query_type)" -> "String::append(const char*,uint32)"
"st_select_lex::print_limit(THD*,String*,enum_query_type)" -> "String::append(char)"
"Index_hint::print(THD*,String*)" -> "strlen(const char*)"
"Index_hint::print(THD*,String*)" -> "String::append(char)"
"Index_hint::print(THD*,String*)" -> "String::append(const char*)"
"Index_hint::print(THD*,String*)" -> "append_identifier(THD*,String*,const char*,uint)"
"Index_hint::print(THD*,String*)" -> "String::append(const char*,uint32)"
"db_is_default_db(const char*,size_t,const THD*)" -> "memcmp(const void*,const void*,size_t)"
"Item::print_item_w_name(String*,enum_query_type)" -> "Simple_cstring::is_set() const"
"Item::print_item_w_name(String*,enum_query_type)" -> "append_identifier(THD*,String*,Simple_cstring)"
"Item::print_item_w_name(String*,enum_query_type)" -> "String::append(const char*,uint32)"
"Item::print_item_w_name(String*,enum_query_type)" -> "_current_thd()"
"Item_field::Item_field(THD*,Item_field*)" -> "Item_ident::Item_ident(THD*,Item_ident*)"
"Item_field::Item_field(THD*,Item_field*)" -> "DTCollation::set(Derivation)"
"Item_ident::Item_ident(THD*,Item_ident*)" -> "Item::Item(THD*,Item*)"
"remove_redundant_subquery_clauses(st_select_lex*,int,int,List<Item>&,Ref_ptr_array)" -> "Bounds_checked_array<Element_type>::operator[](size_t) [with Element_type = Item*,size_t = long unsigned int]"
"remove_redundant_subquery_clauses(st_select_lex*,int,int,List<Item>&,Ref_ptr_array)" -> "Opt_trace_array::Opt_trace_array(Opt_trace_context*,const char*,Opt_trace_context::feature_value)"
"remove_redundant_subquery_clauses(st_select_lex*,int,int,List<Item>&,Ref_ptr_array)" -> "Opt_trace_struct::add_alnum(const char*)"
"remove_redundant_subquery_clauses(st_select_lex*,int,int,List<Item>&,Ref_ptr_array)" -> "JOIN::ORDER_with_src::operator=(JOIN::ORDER_with_src::null*)"
"remove_redundant_subquery_clauses(st_select_lex*,int,int,List<Item>&,Ref_ptr_array)" -> "Opt_trace_context::is_started() const"
"remove_redundant_subquery_clauses(st_select_lex*,int,int,List<Item>&,Ref_ptr_array)" -> "SQL_I_List<T>::empty() [with T = st_order]"
"remove_redundant_subquery_clauses(st_select_lex*,int,int,List<Item>&,Ref_ptr_array)" -> "Opt_trace_object::Opt_trace_object(Opt_trace_context*,Opt_trace_context::feature_value)"
"remove_redundant_subquery_clauses(st_select_lex*,int,int,List<Item>&,Ref_ptr_array)" -> "__builtin_expect(long int,long int)"
"remove_redundant_subquery_clauses(st_select_lex*,int,int,List<Item>&,Ref_ptr_array)" -> "List<T>::pop() [with T = Item]"
"Opt_trace_array::Opt_trace_array(Opt_trace_context*,const char*,Opt_trace_context::feature_value)" -> "Opt_trace_struct::Opt_trace_struct(Opt_trace_context*,bool,const char*,Opt_trace_context::feature_value)"
"List<T>::pop() [with T = Item]" -> "base_list::pop()"
"resolve_subquery(THD*,JOIN*)" -> "st_select_lex_unit::first_select()"
"resolve_subquery(THD*,JOIN*)" -> "Opt_trace_struct::add(const char*,bool)"
"resolve_subquery(THD*,JOIN*)" -> "THD::optimizer_switch_flag(ulonglong) const"
"resolve_subquery(THD*,JOIN*)" -> "Opt_trace_object::Opt_trace_object(Opt_trace_context*,Opt_trace_context::feature_value)"
"resolve_subquery(THD*,JOIN*)" -> "Opt_trace_struct::add_select_number(uint)"
"resolve_subquery(THD*,JOIN*)" -> "Opt_trace_object::Opt_trace_object(Opt_trace_context*,const char*,Opt_trace_context::feature_value)"
"resolve_subquery(THD*,JOIN*)" -> "st_select_lex::is_part_of_union()"
"resolve_subquery(THD*,JOIN*)" -> "has_trivial_destructor>::push_back(const Element_type&) [with Element_type = Item_exists_subselect*,bool has_trivial_destructor = true]"
"resolve_subquery(THD*,JOIN*)" -> "my_error(int,myf,...)"
"resolve_subquery(THD*,JOIN*)" -> "Opt_trace_struct::add_alnum(const char*,const char*)"
"st_select_lex::is_part_of_union()" -> "st_select_lex_unit::is_union()"
"has_trivial_destructor>::push_back(const Element_type&) [with Element_type = Item_exists_subselect*,bool has_trivial_destructor = true]" -> "has_trivial_destructor>::reserve(size_t) [with Element_type = Item_exists_subselect*,bool has_trivial_destructor = true,size_t = long unsigned int]"
"has_trivial_destructor>::reserve(size_t) [with Element_type = Item_exists_subselect*,bool has_trivial_destructor = true,size_t = long unsigned int]" -> "alloc_root(MEM_ROOT*,size_t)"
"has_trivial_destructor>::reserve(size_t) [with Element_type = Item_exists_subselect*,bool has_trivial_destructor = true,size_t = long unsigned int]" -> "has_trivial_destructor>::element_size() const [with Element_type = Item_exists_subselect*,bool has_trivial_destructor = true,size_t = long unsigned int]"
"setup_without_group(THD*,Ref_ptr_array,TABLE_LIST*,TABLE_LIST*,List<Item>&,List<Item>&,Item**,ORDER*,ORDER*,int*,int*)" -> "setup_order(THD*,Ref_ptr_array,TABLE_LIST*,List<Item>&,List<Item>&,ORDER*)"
"setup_without_group(THD*,Ref_ptr_array,TABLE_LIST*,TABLE_LIST*,List<Item>&,List<Item>&,Item**,ORDER*,ORDER*,int*,int*)" -> "st_select_lex::non_agg_field_used() const"
"setup_without_group(THD*,Ref_ptr_array,TABLE_LIST*,TABLE_LIST*,List<Item>&,List<Item>&,Item**,ORDER*,ORDER*,int*,int*)" -> "setup_group(THD*,Ref_ptr_array,TABLE_LIST*,List<Item>&,List<Item>&,ORDER*)"
"setup_without_group(THD*,Ref_ptr_array,TABLE_LIST*,TABLE_LIST*,List<Item>&,List<Item>&,Item**,ORDER*,ORDER*,int*,int*)" -> "setup_conds(THD*,TABLE_LIST*,TABLE_LIST*,Item**)"
"setup_without_group(THD*,Ref_ptr_array,TABLE_LIST*,TABLE_LIST*,List<Item>&,List<Item>&,Item**,ORDER*,ORDER*,int*,int*)" -> "st_select_lex::set_non_agg_field_used(bool)"
"setup_without_group(THD*,Ref_ptr_array,TABLE_LIST*,TABLE_LIST*,List<Item>&,List<Item>&,Item**,ORDER*,ORDER*,int*,int*)" -> "match_exprs_for_only_full_group_by(THD*,List<Item>&,int,int,int,ORDER*)"
"setup_order(THD*,Ref_ptr_array,TABLE_LIST*,List<Item>&,List<Item>&,ORDER*)" -> "find_order_in_list(THD*,Ref_ptr_array,TABLE_LIST*,ORDER*,List<Item>&,List<Item>&,bool)"
"find_order_in_list(THD*,Ref_ptr_array,TABLE_LIST*,ORDER*,List<Item>&,List<Item>&,bool)" -> "_current_thd()"
"find_order_in_list(THD*,Ref_ptr_array,TABLE_LIST*,ORDER*,List<Item>&,List<Item>&,bool)" -> "List<T>::push_front(T*) [with T = Item]"
"find_order_in_list(THD*,Ref_ptr_array,TABLE_LIST*,ORDER*,List<Item>&,List<Item>&,bool)" -> "Bounds_checked_array<Element_type>::operator[](size_t) [with Element_type = Item*,size_t = long unsigned int]"
"find_order_in_list(THD*,Ref_ptr_array,TABLE_LIST*,ORDER*,List<Item>&,List<Item>&,bool)" -> "find_item_in_list(Item*,List<Item>&,uint*,find_item_error_report_type,enum_resolution_type*)"
"find_order_in_list(THD*,Ref_ptr_array,TABLE_LIST*,ORDER*,List<Item>&,List<Item>&,bool)" -> "find_field_in_tables(THD*,Item_ident*,TABLE_LIST*,TABLE_LIST*,Item**,find_item_error_report_type,bool,bool)"
"find_order_in_list(THD*,Ref_ptr_array,TABLE_LIST*,ORDER*,List<Item>&,List<Item>&,bool)" -> "my_error(int,myf,...)"
"find_order_in_list(THD*,Ref_ptr_array,TABLE_LIST*,ORDER*,List<Item>&,List<Item>&,bool)" -> "push_warning_printf(THD*,Sql_condition::enum_warning_level,uint,const char*,...)"
"find_item_in_list(Item*,List<Item>&,uint*,find_item_error_report_type,enum_resolution_type*)" -> "strcmp(const char*,const char*)"
"find_item_in_list(Item*,List<Item>&,uint*,find_item_error_report_type,enum_resolution_type*)" -> "List_iterator<T>::List_iterator(List<T>&) [with T = Item]"
"find_item_in_list(Item*,List<Item>&,uint*,find_item_error_report_type,enum_resolution_type*)" -> "List_iterator<T>::ref() [with T = Item]"
"find_item_in_list(Item*,List<Item>&,uint*,find_item_error_report_type,enum_resolution_type*)" -> "_current_thd()"
"find_item_in_list(Item*,List<Item>&,uint*,find_item_error_report_type,enum_resolution_type*)" -> "my_error(int,myf,...)"
"find_item_in_list(Item*,List<Item>&,uint*,find_item_error_report_type,enum_resolution_type*)" -> "Name_string::eq_safe(Name_string) const"
"find_item_in_list(Item*,List<Item>&,uint*,find_item_error_report_type,enum_resolution_type*)" -> "Name_string::eq_safe(const char*) const"
"find_item_in_list(Item*,List<Item>&,uint*,find_item_error_report_type,enum_resolution_type*)" -> "List_iterator<T>::operator++(int) [with T = Item]"
"find_item_in_list(Item*,List<Item>&,uint*,find_item_error_report_type,enum_resolution_type*)" -> "Simple_cstring::is_set() const"
"Name_string::eq_safe(Name_string) const" -> "Name_string::eq(Name_string) const"
"Name_string::eq_safe(Name_string) const" -> "Simple_cstring::is_set() const"
"Name_string::eq(Name_string) const" -> "Name_string::eq(const char*) const"
"Name_string::eq(Name_string) const" -> "Simple_cstring::ptr() const"
"Name_string::eq(const char*) const" -> "Simple_cstring::ptr() const"
"Name_string::eq_safe(const char*) const" -> "Name_string::eq(const char*) const"
"Name_string::eq_safe(const char*) const" -> "Simple_cstring::is_set() const"
"find_field_in_tables(THD*,Item_ident*,TABLE_LIST*,TABLE_LIST*,Item**,find_item_error_report_type,bool,bool)" -> "strxnmov(char*,size_t,const char*,...)"
"find_field_in_tables(THD*,Item_ident*,TABLE_LIST*,TABLE_LIST*,Item**,find_item_error_report_type,bool,bool)" -> "mark_select_range_as_dependent(THD*,st_select_lex*,st_select_lex*,Field*,Item*,Item_ident*)"
"find_field_in_tables(THD*,Item_ident*,TABLE_LIST*,TABLE_LIST*,Item**,find_item_error_report_type,bool,bool)" -> "my_error(int,myf,...)"
"find_field_in_tables(THD*,Item_ident*,TABLE_LIST*,TABLE_LIST*,Item**,find_item_error_report_type,bool,bool)" -> "strlen(const char*)"
"find_field_in_tables(THD*,Item_ident*,TABLE_LIST*,TABLE_LIST*,Item**,find_item_error_report_type,bool,bool)" -> "find_field_in_table(THD*,TABLE*,const char*,uint,bool,uint*)"
"find_field_in_tables(THD*,Item_ident*,TABLE_LIST*,TABLE_LIST*,Item**,find_item_error_report_type,bool,bool)" -> "find_field_in_table_ref(THD*,TABLE_LIST*,const char*,uint,const char*,const char*,const char*,Item**,bool,bool,uint*,bool,TABLE_LIST**)"
"find_field_in_tables(THD*,Item_ident*,TABLE_LIST*,TABLE_LIST*,Item**,find_item_error_report_type,bool,bool)" -> "Field::init(TABLE*)"
"find_field_in_tables(THD*,Item_ident*,TABLE_LIST*,TABLE_LIST*,Item**,find_item_error_report_type,bool,bool)" -> "Field_null::Field_null(uchar*,uint32,Field::utype,const char*,const CHARSET_INFO*)"
"find_field_in_tables(THD*,Item_ident*,TABLE_LIST*,TABLE_LIST*,Item**,find_item_error_report_type,bool,bool)" -> "Simple_cstring::ptr() const"
"find_field_in_tables(THD*,Item_ident*,TABLE_LIST*,TABLE_LIST*,Item**,find_item_error_report_type,bool,bool)" -> "THD::clear_error()"
"find_field_in_tables(THD*,Item_ident*,TABLE_LIST*,TABLE_LIST*,Item**,find_item_error_report_type,bool,bool)" -> "strmake(char*,const char*,size_t)"
"find_field_in_table_ref(THD*,TABLE_LIST*,const char*,uint,const char*,const char*,const char*,Item**,bool,bool,uint*,bool,TABLE_LIST**)" -> "find_field_in_natural_join(THD*,TABLE_LIST*,const char*,uint,Item**,bool,TABLE_LIST**)"
"find_field_in_table_ref(THD*,TABLE_LIST*,const char*,uint,const char*,const char*,const char*,Item**,bool,bool,uint*,bool,TABLE_LIST**)" -> "List_iterator<T>::operator++(int) [with T = TABLE_LIST]"
"find_field_in_table_ref(THD*,TABLE_LIST*,const char*,uint,const char*,const char*,const char*,Item**,bool,bool,uint*,bool,TABLE_LIST**)" -> "find_field_in_table(THD*,TABLE*,const char*,uint,bool,uint*)"
"find_field_in_table_ref(THD*,TABLE_LIST*,const char*,uint,const char*,const char*,const char*,Item**,bool,bool,uint*,bool,TABLE_LIST**)" -> "find_field_in_table_ref(THD*,TABLE_LIST*,const char*,uint,const char*,const char*,const char*,Item**,bool,bool,uint*,bool,TABLE_LIST**)"
"find_field_in_table_ref(THD*,TABLE_LIST*,const char*,uint,const char*,const char*,const char*,Item**,bool,bool,uint*,bool,TABLE_LIST**)" -> "bitmap_set_bit(MY_BITMAP*,uint)"
"find_field_in_table_ref(THD*,TABLE_LIST*,const char*,uint,const char*,const char*,const char*,Item**,bool,bool,uint*,bool,TABLE_LIST**)" -> "List_iterator<T>::List_iterator(List<T>&) [with T = TABLE_LIST]"
"find_field_in_table_ref(THD*,TABLE_LIST*,const char*,uint,const char*,const char*,const char*,Item**,bool,bool,uint*,bool,TABLE_LIST**)" -> "strcmp(const char*,const char*)"
"find_field_in_table_ref(THD*,TABLE_LIST*,const char*,uint,const char*,const char*,const char*,Item**,bool,bool,uint*,bool,TABLE_LIST**)" -> "find_field_in_view(THD*,TABLE_LIST*,const char*,uint,const char*,Item**,bool)"
"find_field_in_natural_join(THD*,TABLE_LIST*,const char*,uint,Item**,bool,TABLE_LIST**)" -> "Natural_join_column::name()"
"find_field_in_natural_join(THD*,TABLE_LIST*,const char*,uint,Item**,bool,TABLE_LIST**)" -> "Natural_join_column::create_item(THD*)"
"find_field_in_natural_join(THD*,TABLE_LIST*,const char*,uint,Item**,bool,TABLE_LIST**)" -> "THD::change_item_tree(Item**,Item*)"
"find_field_in_natural_join(THD*,TABLE_LIST*,const char*,uint,Item**,bool,TABLE_LIST**)" -> "Item_name_string::is_autogenerated() const"
"find_field_in_natural_join(THD*,TABLE_LIST*,const char*,uint,Item**,bool,TABLE_LIST**)" -> "List_iterator_fast<T>::List_iterator_fast(List<T>&) [with T = Natural_join_column]"
"find_field_in_natural_join(THD*,TABLE_LIST*,const char*,uint,Item**,bool,TABLE_LIST**)" -> "__builtin_memcpy(void*,const void*,long unsigned int)"
"find_field_in_natural_join(THD*,TABLE_LIST*,const char*,uint,Item**,bool,TABLE_LIST**)" -> "my_error(int,myf,...)"
"find_field_in_natural_join(THD*,TABLE_LIST*,const char*,uint,Item**,bool,TABLE_LIST**)" -> "Prepared_stmt_arena_holder::Prepared_stmt_arena_holder(THD*,bool)"
"find_field_in_natural_join(THD*,TABLE_LIST*,const char*,uint,Item**,bool,TABLE_LIST**)" -> "update_field_dependencies(THD*,Field*,TABLE*)"
"find_field_in_natural_join(THD*,TABLE_LIST*,const char*,uint,Item**,bool,TABLE_LIST**)" -> "List_iterator_fast<T>::operator++(int) [with T = Natural_join_column]"
"find_field_in_view(THD*,TABLE_LIST*,const char*,uint,const char*,Item**,bool)" -> "Prepared_stmt_arena_holder::Prepared_stmt_arena_holder(THD*,bool)"
"find_field_in_view(THD*,TABLE_LIST*,const char*,uint,const char*,Item**,bool)" -> "Field_iterator_view::Field_iterator_view()"
"find_field_in_view(THD*,TABLE_LIST*,const char*,uint,const char*,Item**,bool)" -> "THD::change_item_tree(Item**,Item*)"
"find_field_in_view(THD*,TABLE_LIST*,const char*,uint,const char*,Item**,bool)" -> "Field_iterator_view::create_item(THD*)"
"find_field_in_view(THD*,TABLE_LIST*,const char*,uint,const char*,Item**,bool)" -> "Field_iterator_view::set(TABLE_LIST*)"
"find_field_in_view(THD*,TABLE_LIST*,const char*,uint,const char*,Item**,bool)" -> "Item_name_string::is_autogenerated() const"
"find_field_in_view(THD*,TABLE_LIST*,const char*,uint,const char*,Item**,bool)" -> "Field_iterator_view::name()"
"find_field_in_view(THD*,TABLE_LIST*,const char*,uint,const char*,Item**,bool)" -> "Query_arena::is_stmt_prepare_or_first_stmt_execute() const"
"find_field_in_view(THD*,TABLE_LIST*,const char*,uint,const char*,Item**,bool)" -> "__builtin_memcpy(void*,const void*,long unsigned int)"
"find_field_in_view(THD*,TABLE_LIST*,const char*,uint,const char*,Item**,bool)" -> "Field_iterator_view::next()"
"find_field_in_view(THD*,TABLE_LIST*,const char*,uint,const char*,Item**,bool)" -> "Field_iterator_view::end_of_fields()"
"Field_iterator_view::create_item(THD*)" -> "create_view_field(THD*,TABLE_LIST*,Item**,const char*,Name_resolution_context*)"
"setup_group(THD*,Ref_ptr_array,TABLE_LIST*,List<Item>&,List<Item>&,ORDER*)" -> "my_error(int,myf,...)"
"setup_group(THD*,Ref_ptr_array,TABLE_LIST*,List<Item>&,List<Item>&,ORDER*)" -> "find_order_in_list(THD*,Ref_ptr_array,TABLE_LIST*,ORDER*,List<Item>&,List<Item>&,bool)"
"match_exprs_for_only_full_group_by(THD*,List<Item>&,int,int,int,ORDER*)" -> "List_iterator<T>::List_iterator(List<T>&) [with T = Item]"
"match_exprs_for_only_full_group_by(THD*,List<Item>&,int,int,int,ORDER*)" -> "List_iterator<T>::operator++(int) [with T = Item_field]"
"match_exprs_for_only_full_group_by(THD*,List<Item>&,int,int,int,ORDER*)" -> "List_iterator<T>::operator++(int) [with T = Item]"
"match_exprs_for_only_full_group_by(THD*,List<Item>&,int,int,int,ORDER*)" -> "my_error(int,myf,...)"
"match_exprs_for_only_full_group_by(THD*,List<Item>&,int,int,int,ORDER*)" -> "List_iterator<T>::List_iterator(List<T>&) [with T = Item_field]"
"List_iterator<T>::operator++(int) [with T = Item_field]" -> "base_list_iterator::next()"
"List_iterator<T>::List_iterator(List<T>&) [with T = Item_field]" -> "base_list_iterator::base_list_iterator(base_list&)"
"select_union::create_result_table(THD*,List<Item>*,bool,ulonglong,const char*,bool,bool)" -> "create_tmp_table(THD*,TMP_TABLE_PARAM*,List<Item>&,ORDER*,bool,bool,ulonglong,ha_rows,const char*)"
"select_union::create_result_table(THD*,List<Item>*,bool,ulonglong,const char*,bool,bool)" -> "TMP_TABLE_PARAM::init()"
"create_tmp_table(THD*,TMP_TABLE_PARAM*,List<Item>&,ORDER*,bool,bool,ulonglong,ha_rows,const char*)" -> "Copy_field::Copy_field()"
"create_tmp_table(THD*,TMP_TABLE_PARAM*,List<Item>&,ORDER*,bool,bool,ulonglong,ha_rows,const char*)" -> "TABLE_SHARE::db_type() const"
"create_tmp_table(THD*,TMP_TABLE_PARAM*,List<Item>&,ORDER*,bool,bool,ulonglong,ha_rows,const char*)" -> "get_new_handler(TABLE_SHARE*,MEM_ROOT*,handlerton*)"
"create_tmp_table(THD*,TMP_TABLE_PARAM*,List<Item>&,ORDER*,bool,bool,ulonglong,ha_rows,const char*)" -> "create_tmp_field_for_schema(THD*,Item*,TABLE*)"
"create_tmp_table(THD*,TMP_TABLE_PARAM*,List<Item>&,ORDER*,bool,bool,ulonglong,ha_rows,const char*)" -> "Copy_field::set(Field*,Field*,bool)"
"create_tmp_table(THD*,TMP_TABLE_PARAM*,List<Item>&,ORDER*,bool,bool,ulonglong,ha_rows,const char*)" -> "bitmap_lock_set_next(MY_BITMAP*)"
"create_tmp_table(THD*,TMP_TABLE_PARAM*,List<Item>&,ORDER*,bool,bool,ulonglong,ha_rows,const char*)" -> "Field::init(TABLE*)"
"create_tmp_table(THD*,TMP_TABLE_PARAM*,List<Item>&,ORDER*,bool,bool,ulonglong,ha_rows,const char*)" -> "List_iterator_fast<T>::operator++(int) [with T = Item]"
"create_tmp_table(THD*,TMP_TABLE_PARAM*,List<Item>&,ORDER*,bool,bool,ulonglong,ha_rows,const char*)" -> "bitmap_lock_clear_bit(MY_BITMAP*,uint)"
"create_tmp_table(THD*,TMP_TABLE_PARAM*,List<Item>&,ORDER*,bool,bool,ulonglong,ha_rows,const char*)" -> "Item_sum::get_arg_count() const"
"create_tmp_table(THD*,TMP_TABLE_PARAM*,List<Item>&,ORDER*,bool,bool,ulonglong,ha_rows,const char*)" -> "Item_sum::set_arg(uint,THD*,Item*)"
"create_tmp_table(THD*,TMP_TABLE_PARAM*,List<Item>&,ORDER*,bool,bool,ulonglong,ha_rows,const char*)" -> "my_tmpdir(MY_TMPDIR*)"
"create_tmp_table(THD*,TMP_TABLE_PARAM*,List<Item>&,ORDER*,bool,bool,ulonglong,ha_rows,const char*)" -> "std::min(const _Tp&,const _Tp&) [with _Tp = long long unsigned int]"
"create_tmp_table(THD*,TMP_TABLE_PARAM*,List<Item>&,ORDER*,bool,bool,ulonglong,ha_rows,const char*)" -> "__builtin_strcpy(char*,const char*)"
"create_tmp_table(THD*,TMP_TABLE_PARAM*,List<Item>&,ORDER*,bool,bool,ulonglong,ha_rows,const char*)" -> "multi_alloc_root(MEM_ROOT*,...)"
"create_tmp_table(THD*,TMP_TABLE_PARAM*,List<Item>&,ORDER*,bool,bool,ulonglong,ha_rows,const char*)" -> "handler::max_key_parts() const"
"create_tmp_table(THD*,TMP_TABLE_PARAM*,List<Item>&,ORDER*,bool,bool,ulonglong,ha_rows,const char*)" -> "Field::set_notnull(my_ptrdiff_t)"
"create_tmp_table(THD*,TMP_TABLE_PARAM*,List<Item>&,ORDER*,bool,bool,ulonglong,ha_rows,const char*)" -> "Field::move_field(uchar*,uchar*,uchar)"
"create_tmp_table(THD*,TMP_TABLE_PARAM*,List<Item>&,ORDER*,bool,bool,ulonglong,ha_rows,const char*)" -> "memset(void*,int,size_t)"
"create_tmp_table(THD*,TMP_TABLE_PARAM*,List<Item>&,ORDER*,bool,bool,ulonglong,ha_rows,const char*)" -> "Item_sum::get_arg(uint)"
"create_tmp_table(THD*,TMP_TABLE_PARAM*,List<Item>&,ORDER*,bool,bool,ulonglong,ha_rows,const char*)" -> "strlen(const char*)"
"create_tmp_table(THD*,TMP_TABLE_PARAM*,List<Item>&,ORDER*,bool,bool,ulonglong,ha_rows,const char*)" -> "ha_lock_engine(THD*,const handlerton*)"
"create_tmp_table(THD*,TMP_TABLE_PARAM*,List<Item>&,ORDER*,bool,bool,ulonglong,ha_rows,const char*)" -> "free_tmp_table(THD*,TABLE*)"
"create_tmp_table(THD*,TMP_TABLE_PARAM*,List<Item>&,ORDER*,bool,bool,ulonglong,ha_rows,const char*)" -> "KEY_PART_INFO::init_from_field(Field*)"
"create_tmp_table(THD*,TMP_TABLE_PARAM*,List<Item>&,ORDER*,bool,bool,ulonglong,ha_rows,const char*)" -> "Bitmap<64u>::init()"
"create_tmp_table(THD*,TMP_TABLE_PARAM*,List<Item>&,ORDER*,bool,bool,ulonglong,ha_rows,const char*)" -> "handler::max_key_length() const"
"create_tmp_table(THD*,TMP_TABLE_PARAM*,List<Item>&,ORDER*,bool,bool,ulonglong,ha_rows,const char*)" -> "Field_string::Field_string(uchar*,uint32,uchar*,uchar,Field::utype,const char*,const CHARSET_INFO*)"
"create_tmp_table(THD*,TMP_TABLE_PARAM*,List<Item>&,ORDER*,bool,bool,ulonglong,ha_rows,const char*)" -> "create_tmp_field(THD*,TABLE*,Item*,Item::Type,Item***,Field**,Field**,bool,bool,bool,bool)"
"create_tmp_table(THD*,TMP_TABLE_PARAM*,List<Item>&,ORDER*,bool,bool,ulonglong,ha_rows,const char*)" -> "setup_tmp_table_column_bitmaps(TABLE*,uchar*)"
"create_tmp_table(THD*,TMP_TABLE_PARAM*,List<Item>&,ORDER*,bool,bool,ulonglong,ha_rows,const char*)" -> "fn_format(char*,const char*,const char*,const char*,uint)"
"create_tmp_table(THD*,TMP_TABLE_PARAM*,List<Item>&,ORDER*,bool,bool,ulonglong,ha_rows,const char*)" -> "Field::is_real_null(my_ptrdiff_t) const"
"create_tmp_table(THD*,TMP_TABLE_PARAM*,List<Item>&,ORDER*,bool,bool,ulonglong,ha_rows,const char*)" -> "init_tmp_table_share(THD*,TABLE_SHARE*,const char*,uint,const char*,const char*)"
"create_tmp_table(THD*,TMP_TABLE_PARAM*,List<Item>&,ORDER*,bool,bool,ulonglong,ha_rows,const char*)" -> "Item_field::Item_field(Field*)"
"create_tmp_table(THD*,TMP_TABLE_PARAM*,List<Item>&,ORDER*,bool,bool,ulonglong,ha_rows,const char*)" -> "free_root(MEM_ROOT*,myf)"
"create_tmp_table(THD*,TMP_TABLE_PARAM*,List<Item>&,ORDER*,bool,bool,ulonglong,ha_rows,const char*)" -> "Field::new_key_field(MEM_ROOT*,TABLE*,uchar*)"
"create_tmp_table(THD*,TMP_TABLE_PARAM*,List<Item>&,ORDER*,bool,bool,ulonglong,ha_rows,const char*)" -> "Item_copy::get_item()"
"create_tmp_table(THD*,TMP_TABLE_PARAM*,List<Item>&,ORDER*,bool,bool,ulonglong,ha_rows,const char*)" -> "List_iterator_fast<T>::List_iterator_fast(List<T>&) [with T = Item]"
"create_tmp_table(THD*,TMP_TABLE_PARAM*,List<Item>&,ORDER*,bool,bool,ulonglong,ha_rows,const char*)" -> "sprintf(char*,const char*,...)"
"create_tmp_table(THD*,TMP_TABLE_PARAM*,List<Item>&,ORDER*,bool,bool,ulonglong,ha_rows,const char*)" -> "memcpy(void*,const void*,size_t)"
"create_tmp_table(THD*,TMP_TABLE_PARAM*,List<Item>&,ORDER*,bool,bool,ulonglong,ha_rows,const char*)" -> "Field_bit::set_bit_ptr(uchar*,uchar)"
"create_tmp_table(THD*,TMP_TABLE_PARAM*,List<Item>&,ORDER*,bool,bool,ulonglong,ha_rows,const char*)" -> "init_sql_alloc(MEM_ROOT*,uint,uint)"
"create_tmp_table(THD*,TMP_TABLE_PARAM*,List<Item>&,ORDER*,bool,bool,ulonglong,ha_rows,const char*)" -> "THD::inc_status_created_tmp_tables()"
"create_tmp_table(THD*,TMP_TABLE_PARAM*,List<Item>&,ORDER*,bool,bool,ulonglong,ha_rows,const char*)" -> "alloc_root(MEM_ROOT*,size_t)"
"create_tmp_table(THD*,TMP_TABLE_PARAM*,List<Item>&,ORDER*,bool,bool,ulonglong,ha_rows,const char*)" -> "Field::set_null(my_ptrdiff_t)"
"create_tmp_table(THD*,TMP_TABLE_PARAM*,List<Item>&,ORDER*,bool,bool,ulonglong,ha_rows,const char*)" -> "instantiate_tmp_table(TABLE*,KEY*,MI_COLUMNDEF*,MI_COLUMNDEF**,ulonglong,my_bool,Opt_trace_context*)"
"Copy_field::Copy_field()" -> "Sql_alloc::Sql_alloc()"
"Copy_field::Copy_field()" -> "String::String()"
"create_tmp_field_for_schema(THD*,Item*,TABLE*)" -> "Field_varstring::Field_varstring(uint32,bool,const char*,TABLE_SHARE*,const CHARSET_INFO*)"
"create_tmp_field_for_schema(THD*,Item*,TABLE*)" -> "Simple_cstring::ptr() const"
"create_tmp_field_for_schema(THD*,Item*,TABLE*)" -> "Field::init(TABLE*)"
"create_tmp_field_for_schema(THD*,Item*,TABLE*)" -> "Item::tmp_table_field_from_field_type(TABLE*,bool)"
"create_tmp_field_for_schema(THD*,Item*,TABLE*)" -> "Field_blob::Field_blob(uint32,bool,const char*,const CHARSET_INFO*)"
"Field_varstring::Field_varstring(uint32,bool,const char*,TABLE_SHARE*,const CHARSET_INFO*)" -> "Field_longstr::Field_longstr(uchar*,uint32,uchar*,uchar,Field::utype,const char*,const CHARSET_INFO*)"
"Item::tmp_table_field_from_field_type(TABLE*,bool)" -> "Field_newdate::Field_newdate(bool,const char*)"
"Item::tmp_table_field_from_field_type(TABLE*,bool)" -> "Field::init(TABLE*)"
"Item::tmp_table_field_from_field_type(TABLE*,bool)" -> "Field_blob::Field_blob(uint32,bool,const char*,const CHARSET_INFO*,bool)"
"Item::tmp_table_field_from_field_type(TABLE*,bool)" -> "Field_timef::Field_timef(bool,const char*,uint8)"
"Item::tmp_table_field_from_field_type(TABLE*,bool)" -> "Field_short::Field_short(uchar*,uint32,uchar*,uchar,Field::utype,const char*,bool,bool)"
"Item::tmp_table_field_from_field_type(TABLE*,bool)" -> "Field_year::Field_year(uchar*,uint32,uchar*,uchar,Field::utype,const char*)"
"Item::tmp_table_field_from_field_type(TABLE*,bool)" -> "Field_timestampf::Field_timestampf(bool,const char*,uint8)"
"Item::tmp_table_field_from_field_type(TABLE*,bool)" -> "Field_medium::Field_medium(uchar*,uint32,uchar*,uchar,Field::utype,const char*,bool,bool)"
"Item::tmp_table_field_from_field_type(TABLE*,bool)" -> "Simple_cstring::ptr() const"
"Item::tmp_table_field_from_field_type(TABLE*,bool)" -> "Field_datetimef::Field_datetimef(bool,const char*,uint8)"
"Item::tmp_table_field_from_field_type(TABLE*,bool)" -> "Field_bit_as_char::Field_bit_as_char(uchar*,uint32,uchar*,uchar,Field::utype,const char*)"
"Item::tmp_table_field_from_field_type(TABLE*,bool)" -> "Field_long::Field_long(uchar*,uint32,uchar*,uchar,Field::utype,const char*,bool,bool)"
"Item::tmp_table_field_from_field_type(TABLE*,bool)" -> "Field_new_decimal::create_from_item(Item*)"
"Item::tmp_table_field_from_field_type(TABLE*,bool)" -> "Field_blob::Field_blob(uint32,bool,const char*,const CHARSET_INFO*)"
"Item::tmp_table_field_from_field_type(TABLE*,bool)" -> "Field_string::Field_string(uint32,bool,const char*,const CHARSET_INFO*)"
"Item::tmp_table_field_from_field_type(TABLE*,bool)" -> "Field_tiny::Field_tiny(uchar*,uint32,uchar*,uchar,Field::utype,const char*,bool,bool)"
"Item::tmp_table_field_from_field_type(TABLE*,bool)" -> "Field_geom::Field_geom(uint32,bool,const char*,TABLE_SHARE*,Field::geometry_type)"
"Item::tmp_table_field_from_field_type(TABLE*,bool)" -> "Field_double::Field_double(uchar*,uint32,uchar*,uchar,Field::utype,const char*,uint8,bool,bool)"
"Item::tmp_table_field_from_field_type(TABLE*,bool)" -> "Field_longlong::Field_longlong(uchar*,uint32,uchar*,uchar,Field::utype,const char*,bool,bool)"
"Item::tmp_table_field_from_field_type(TABLE*,bool)" -> "Field_float::Field_float(uchar*,uint32,uchar*,uchar,Field::utype,const char*,uint8,bool,bool)"
"Field_newdate::Field_newdate(bool,const char*)" -> "Field_temporal_with_date::Field_temporal_with_date(uchar*,uchar*,uchar,Field::utype,const char*,uint8,uint8)"
"Field_blob::Field_blob(uint32,bool,const char*,const CHARSET_INFO*,bool)" -> "String::String()"
"Field_blob::Field_blob(uint32,bool,const char*,const CHARSET_INFO*,bool)" -> "Field_longstr::Field_longstr(uchar*,uint32,uchar*,uchar,Field::utype,const char*,const CHARSET_INFO*)"
"Field_timef::Field_timef(bool,const char*,uint8)" -> "Field_time_common::Field_time_common(uchar*,uchar*,uchar,Field::utype,const char*,uint8)"
"Field_timestampf::Field_timestampf(bool,const char*,uint8)" -> "Field_temporal_with_date_and_timef::Field_temporal_with_date_and_timef(uchar*,uchar*,uchar,Field::utype,const char*,uint8)"
"Field_datetimef::Field_datetimef(bool,const char*,uint8)" -> "Field_temporal_with_date_and_timef::Field_temporal_with_date_and_timef(uchar*,uchar*,uchar,Field::utype,const char*,uint8)"
"Field_new_decimal::create_from_item(Item*)" -> "Simple_cstring::ptr() const"
"Field_new_decimal::create_from_item(Item*)" -> "Item::max_char_length() const"
"Field_new_decimal::create_from_item(Item*)" -> "my_decimal_precision_to_length(uint,uint8,bool)"
"Field_new_decimal::create_from_item(Item*)" -> "std::min(const _Tp&,const _Tp&) [with _Tp = int]"
"Field_new_decimal::create_from_item(Item*)" -> "Field_new_decimal::Field_new_decimal(uint32,bool,const char*,uint8,bool)"
"Field_new_decimal::create_from_item(Item*)" -> "std::max(const _Tp&,const _Tp&) [with _Tp = int]"
"Field_new_decimal::Field_new_decimal(uint32,bool,const char*,uint8,bool)" -> "Field_num::Field_num(uchar*,uint32,uchar*,uchar,Field::utype,const char*,uint8,bool,bool)"
"Field_new_decimal::Field_new_decimal(uint32,bool,const char*,uint8,bool)" -> "my_decimal_get_binary_size(uint,uint)"
"Field_new_decimal::Field_new_decimal(uint32,bool,const char*,uint8,bool)" -> "my_decimal_length_to_precision(uint,uint,bool)"
"Field_blob::Field_blob(uint32,bool,const char*,const CHARSET_INFO*)" -> "Field_longstr::Field_longstr(uchar*,uint32,uchar*,uchar,Field::utype,const char*,const CHARSET_INFO*)"
"Field_blob::Field_blob(uint32,bool,const char*,const CHARSET_INFO*)" -> "String::String()"
"Field_string::Field_string(uint32,bool,const char*,const CHARSET_INFO*)" -> "Field_longstr::Field_longstr(uchar*,uint32,uchar*,uchar,Field::utype,const char*,const CHARSET_INFO*)"
"Field_geom::Field_geom(uint32,bool,const char*,TABLE_SHARE*,Field::geometry_type)" -> "Field_blob::Field_blob(uint32,bool,const char*,const CHARSET_INFO*)"
"Copy_field::set(Field*,Field*,bool)" -> "(* Copy_field::get_copy_func(Field*,Field*))(Copy_field*)"
"Copy_field::set(Field*,Field*,bool)" -> "Field::real_maybe_null() const"
"Copy_field::set(Field*,Field*,bool)" -> "Field::maybe_null() const"
"(* Copy_field::get_copy_func(Field*,Field*))(Copy_field*)" -> "Field::is_temporal() const"
"Item_sum::set_arg(uint,THD*,Item*)" -> "THD::change_item_tree(Item**,Item*)"
"handler::max_key_parts() const" -> "std::min(const _Tp&,const _Tp&) [with _Tp = unsigned int]"
"KEY_PART_INFO::init_from_field(Field*)" -> "Field::offset(uchar*)"
"KEY_PART_INFO::init_from_field(Field*)" -> "Field::null_offset() const"
"KEY_PART_INFO::init_from_field(Field*)" -> "Field::real_maybe_null() const"
"KEY_PART_INFO::init_from_field(Field*)" -> "KEY_PART_INFO::init_flags()"
"handler::max_key_length() const" -> "std::min(const _Tp&,const _Tp&) [with _Tp = unsigned int]"
"create_tmp_field(THD*,TABLE*,Item*,Item::Type,Item***,Field**,Field**,bool,bool,bool,bool)" -> "create_tmp_field_from_item(THD*,Item*,TABLE*,Item***,bool)"
"create_tmp_field(THD*,TABLE*,Item*,Item::Type,Item***,Field**,Field**,bool,bool,bool,bool)" -> "my_error(int,myf,...)"
"create_tmp_field(THD*,TABLE*,Item*,Item::Type,Item***,Field**,Field**,bool,bool,bool,bool)" -> "Field::maybe_null() const"
"create_tmp_field(THD*,TABLE*,Item*,Item::Type,Item***,Field**,Field**,bool,bool,bool,bool)" -> "Item_func_sp::get_sp_result_field()"
"create_tmp_field(THD*,TABLE*,Item*,Item::Type,Item***,Field**,Field**,bool,bool,bool,bool)" -> "Item_type_holder::make_field_by_type(TABLE*)"
"create_tmp_field(THD*,TABLE*,Item*,Item::Type,Item***,Field**,Field**,bool,bool,bool,bool)" -> "Simple_cstring::ptr() const"
"create_tmp_field(THD*,TABLE*,Item*,Item::Type,Item***,Field**,Field**,bool,bool,bool,bool)" -> "create_tmp_field_from_field(THD*,Field*,const char*,TABLE*,Item_field*)"
"create_tmp_field_from_item(THD*,Item*,TABLE*,Item***,bool)" -> "Field::init(TABLE*)"
"create_tmp_field_from_item(THD*,Item*,TABLE*,Item***,bool)" -> "Field_long::Field_long(uint32,bool,const char*,bool)"
"create_tmp_field_from_item(THD*,Item*,TABLE*,Item***,bool)" -> "Item::is_temporal() const"
"create_tmp_field_from_item(THD*,Item*,TABLE*,Item***,bool)" -> "Field_new_decimal::create_from_item(Item*)"
"create_tmp_field_from_item(THD*,Item*,TABLE*,Item***,bool)" -> "Field_longlong::Field_longlong(uint32,bool,const char*,bool)"
"create_tmp_field_from_item(THD*,Item*,TABLE*,Item***,bool)" -> "Simple_cstring::ptr() const"
"create_tmp_field_from_item(THD*,Item*,TABLE*,Item***,bool)" -> "Item::tmp_table_field_from_field_type(TABLE*,bool)"
"create_tmp_field_from_item(THD*,Item*,TABLE*,Item***,bool)" -> "Field_double::Field_double(uint32,bool,const char*,uint8,my_bool)"
"Field_long::Field_long(uint32,bool,const char*,bool)" -> "Field_num::Field_num(uchar*,uint32,uchar*,uchar,Field::utype,const char*,uint8,bool,bool)"
"Field_longlong::Field_longlong(uint32,bool,const char*,bool)" -> "Field_num::Field_num(uchar*,uint32,uchar*,uchar,Field::utype,const char*,uint8,bool,bool)"
"Field_double::Field_double(uint32,bool,const char*,uint8,my_bool)" -> "Field_real::Field_real(uchar*,uint32,uchar*,uchar,Field::utype,const char*,uint8,bool,bool)"
"Item_type_holder::make_field_by_type(TABLE*)" -> "get_set_pack_length(int)"
"Item_type_holder::make_field_by_type(TABLE*)" -> "Field::init(TABLE*)"
"Item_type_holder::make_field_by_type(TABLE*)" -> "Item::tmp_table_field_from_field_type(TABLE*,bool)"
"Item_type_holder::make_field_by_type(TABLE*)" -> "Simple_cstring::ptr() const"
"Item_type_holder::make_field_by_type(TABLE*)" -> "get_enum_pack_length(int)"
"Item_type_holder::make_field_by_type(TABLE*)" -> "Field_set::Field_set(uchar*,uint32,uchar*,uchar,Field::utype,const char*,uint32,TYPELIB*,const CHARSET_INFO*)"
"Item_type_holder::make_field_by_type(TABLE*)" -> "Field_enum::Field_enum(uchar*,uint32,uchar*,uchar,Field::utype,const char*,uint,TYPELIB*,const CHARSET_INFO*)"
"create_tmp_field_from_field(THD*,Field*,const char*,TABLE*,Item_field*)" -> "Field::init(TABLE*)"
"create_tmp_field_from_field(THD*,Field*,const char*,TABLE*,Item_field*)" -> "Field::maybe_null() const"
"setup_tmp_table_column_bitmaps(TABLE*,uchar*)" -> "TABLE::default_column_bitmaps()"
"setup_tmp_table_column_bitmaps(TABLE*,uchar*)" -> "bitmap_init(MY_BITMAP*,my_bitmap_map*,uint,my_bool)"
"setup_tmp_table_column_bitmaps(TABLE*,uchar*)" -> "memset(void*,int,size_t)"
"instantiate_tmp_table(TABLE*,KEY*,MI_COLUMNDEF*,MI_COLUMNDEF**,ulonglong,my_bool,Opt_trace_context*)" -> "memset(void*,int,size_t)"
"instantiate_tmp_table(TABLE*,KEY*,MI_COLUMNDEF*,MI_COLUMNDEF**,ulonglong,my_bool,Opt_trace_context*)" -> "TABLE_SHARE::db_type() const"
"instantiate_tmp_table(TABLE*,KEY*,MI_COLUMNDEF*,MI_COLUMNDEF**,ulonglong,my_bool,Opt_trace_context*)" -> "Opt_trace_object::Opt_trace_object(Opt_trace_context*,Opt_trace_context::feature_value)"
"instantiate_tmp_table(TABLE*,KEY*,MI_COLUMNDEF*,MI_COLUMNDEF**,ulonglong,my_bool,Opt_trace_context*)" -> "create_myisam_tmp_table(TABLE*,KEY*,MI_COLUMNDEF*,MI_COLUMNDEF**,ulonglong,my_bool)"
"instantiate_tmp_table(TABLE*,KEY*,MI_COLUMNDEF*,MI_COLUMNDEF**,ulonglong,my_bool,Opt_trace_context*)" -> "open_tmp_table(TABLE*)"
"instantiate_tmp_table(TABLE*,KEY*,MI_COLUMNDEF*,MI_COLUMNDEF**,ulonglong,my_bool,Opt_trace_context*)" -> "__builtin_expect(long int,long int)"
"instantiate_tmp_table(TABLE*,KEY*,MI_COLUMNDEF*,MI_COLUMNDEF**,ulonglong,my_bool,Opt_trace_context*)" -> "memcpy(void*,const void*,size_t)"
"instantiate_tmp_table(TABLE*,KEY*,MI_COLUMNDEF*,MI_COLUMNDEF**,ulonglong,my_bool,Opt_trace_context*)" -> "Opt_trace_context::is_started() const"
"instantiate_tmp_table(TABLE*,KEY*,MI_COLUMNDEF*,MI_COLUMNDEF**,ulonglong,my_bool,Opt_trace_context*)" -> "trace_tmp_table(Opt_trace_context*,const TABLE*)"
"instantiate_tmp_table(TABLE*,KEY*,MI_COLUMNDEF*,MI_COLUMNDEF**,ulonglong,my_bool,Opt_trace_context*)" -> "Opt_trace_object::Opt_trace_object(Opt_trace_context*,const char*,Opt_trace_context::feature_value)"
"create_myisam_tmp_table(TABLE*,KEY*,MI_COLUMNDEF*,MI_COLUMNDEF**,ulonglong,my_bool)" -> "handler::max_key_length() const"
"create_myisam_tmp_table(TABLE*,KEY*,MI_COLUMNDEF*,MI_COLUMNDEF**,ulonglong,my_bool)" -> "alloc_root(MEM_ROOT*,size_t)"
"create_myisam_tmp_table(TABLE*,KEY*,MI_COLUMNDEF*,MI_COLUMNDEF**,ulonglong,my_bool)" -> "THD::inc_status_created_tmp_disk_tables()"
"create_myisam_tmp_table(TABLE*,KEY*,MI_COLUMNDEF*,MI_COLUMNDEF**,ulonglong,my_bool)" -> "handler::max_key_parts() const"
"create_myisam_tmp_table(TABLE*,KEY*,MI_COLUMNDEF*,MI_COLUMNDEF**,ulonglong,my_bool)" -> "memset(void*,int,size_t)"
"create_myisam_tmp_table(TABLE*,KEY*,MI_COLUMNDEF*,MI_COLUMNDEF**,ulonglong,my_bool)" -> "mi_create(const char*,uint,MI_KEYDEF*,uint,MI_COLUMNDEF*,uint,MI_UNIQUEDEF*,MI_CREATE_INFO*,uint)"
"create_myisam_tmp_table(TABLE*,KEY*,MI_COLUMNDEF*,MI_COLUMNDEF**,ulonglong,my_bool)" -> "Field::null_offset() const"
"open_tmp_table(TABLE*)" -> "TABLE::set_created()"
"open_tmp_table(TABLE*)" -> "handler::ha_open(TABLE*,const char*,int,int)"
"trace_tmp_table(Opt_trace_context*,const TABLE*)" -> "Opt_trace_object::Opt_trace_object(Opt_trace_context*,const char*,Opt_trace_context::feature_value)"
"trace_tmp_table(Opt_trace_context*,const TABLE*)" -> "Opt_trace_struct::add(const char*,ulonglong)"
"trace_tmp_table(Opt_trace_context*,const TABLE*)" -> "TABLE_SHARE::db_type() const"
"trace_tmp_table(Opt_trace_context*,const TABLE*)" -> "Opt_trace_struct::add_utf8_table(const TABLE*)"
"trace_tmp_table(Opt_trace_context*,const TABLE*)" -> "Opt_trace_struct::add(const char*,ulong)"
"trace_tmp_table(Opt_trace_context*,const TABLE*)" -> "Opt_trace_struct::add_alnum(const char*,const char*)"
"trace_tmp_table(Opt_trace_context*,const TABLE*)" -> "Opt_trace_struct::add(const char*,uint)"
"trace_tmp_table(Opt_trace_context*,const TABLE*)" -> "Opt_trace_struct::add(const char*,bool)"
"Opt_trace_struct::add(const char*,ulonglong)" -> "__builtin_expect(long int,long int)"
"Opt_trace_struct::add(const char*,ulonglong)" -> "Opt_trace_struct::do_add(const char*,ulonglong)"
"Opt_trace_struct::add_utf8_table(const TABLE*)" -> "Opt_trace_struct::do_add_utf8_table(const TABLE*)"
"Opt_trace_struct::add_utf8_table(const TABLE*)" -> "__builtin_expect(long int,long int)"
"Opt_trace_struct::do_add_utf8_table(const TABLE*)" -> "Opt_trace_struct::do_add(const char*,const char*,size_t,bool)"
"Opt_trace_struct::do_add_utf8_table(const TABLE*)" -> "TABLE_LIST::print(THD*,String*,enum_query_type)"
"Opt_trace_struct::do_add_utf8_table(const TABLE*)" -> "String::ptr() const"
"Opt_trace_struct::do_add_utf8_table(const TABLE*)" -> "StringBuffer<buff_sz>::StringBuffer() [with long unsigned int buff_sz = 32ul]"
"Opt_trace_struct::do_add_utf8_table(const TABLE*)" -> "String::length() const"
"StringBuffer<buff_sz>::StringBuffer() [with long unsigned int buff_sz = 32ul]" -> "String::String(char*,uint32,const CHARSET_INFO*)"
"StringBuffer<buff_sz>::StringBuffer() [with long unsigned int buff_sz = 32ul]" -> "String::length(uint32)"
"Opt_trace_struct::add(const char*,ulong)" -> "Opt_trace_struct::do_add(const char*,ulonglong)"
"Opt_trace_struct::add(const char*,ulong)" -> "__builtin_expect(long int,long int)"
"Item_type_holder::join_types(THD*,Item*)" -> "std::min(const _Tp&,const _Tp&) [with _Tp = int]"
"Item_type_holder::join_types(THD*,Item*)" -> "DTCollation::aggregate(DTCollation&,uint)"
"Item_type_holder::join_types(THD*,Item*)" -> "std::max(const _Tp&,const _Tp&) [with _Tp = unsigned int]"
"Item_type_holder::join_types(THD*,Item*)" -> "Item::decimal_int_part() const"
"Item_type_holder::join_types(THD*,Item*)" -> "my_decimal_precision_to_length_no_truncation(uint,uint8,bool)"
"Item_type_holder::join_types(THD*,Item*)" -> "Item_type_holder::display_length(Item*)"
"Item_type_holder::join_types(THD*,Item*)" -> "Item_type_holder::get_real_type(Item*)"
"Item_type_holder::join_types(THD*,Item*)" -> "DTCollation::derivation_name() const"
"Item_type_holder::join_types(THD*,Item*)" -> "my_error(int,myf,...)"
"Item_type_holder::join_types(THD*,Item*)" -> "Field::field_type_merge(enum_field_types,enum_field_types)"
"Item_type_holder::join_types(THD*,Item*)" -> "std::max(const _Tp&,const _Tp&) [with _Tp = int]"
"Item_type_holder::join_types(THD*,Item*)" -> "std::max(const _Tp&,const _Tp&) [with _Tp = unsigned char]"
"Item_type_holder::join_types(THD*,Item*)" -> "Field::result_merge_type(enum_field_types)"
"Item_type_holder::join_types(THD*,Item*)" -> "std::min(const _Tp&,const _Tp&) [with _Tp = unsigned int]"
"Item_type_holder::join_types(THD*,Item*)" -> "Item_type_holder::get_full_info(Item*)"
"DTCollation::aggregate(DTCollation&,uint)" -> "get_charset_by_csname(const char*,uint,myf)"
"DTCollation::aggregate(DTCollation&,uint)" -> "DTCollation::set(DTCollation&)"
"DTCollation::aggregate(DTCollation&,uint)" -> "my_charset_same(const CHARSET_INFO*,const CHARSET_INFO*)"
"DTCollation::aggregate(DTCollation&,uint)" -> "left_is_superset(DTCollation*,DTCollation*)"
"DTCollation::aggregate(DTCollation&,uint)" -> "DTCollation::set(const CHARSET_INFO*,Derivation)"
"DTCollation::aggregate(DTCollation&,uint)" -> "DTCollation::set(const CHARSET_INFO*,Derivation,uint)"
"Item_type_holder::display_length(Item*)" -> "Item_field::max_disp_length()"
"Field::field_type_merge(enum_field_types,enum_field_types)" -> "field_type2index(enum_field_types)"
"mysql_test_call_fields(Prepared_statement*,TABLE_LIST*,List<Item>*)" -> "List_iterator<T>::operator++(int) [with T = Item]"
"mysql_test_call_fields(Prepared_statement*,TABLE_LIST*,List<Item>*)" -> "List_iterator<T>::List_iterator(List<T>&) [with T = Item]"
"mysql_test_call_fields(Prepared_statement*,TABLE_LIST*,List<Item>*)" -> "check_table_access(THD*,ulong,TABLE_LIST*,bool,uint,bool)"
"mysql_test_call_fields(Prepared_statement*,TABLE_LIST*,List<Item>*)" -> "List_iterator<T>::ref() [with T = Item]"
"mysql_test_call_fields(Prepared_statement*,TABLE_LIST*,List<Item>*)" -> "open_normal_and_derived_tables(THD*,TABLE_LIST*,uint)"
"mysql_ha_rm_tables(THD*,TABLE_LIST*)" -> "my_hash_delete(HASH*,uchar*)"
"mysql_ha_rm_tables(THD*,TABLE_LIST*)" -> "mysql_ha_close_table(THD*,TABLE_LIST*)"
"mysql_ha_rm_tables(THD*,TABLE_LIST*)" -> "MDL_context::set_needs_thr_lock_abort(bool)"
"mysql_ha_rm_tables(THD*,TABLE_LIST*)" -> "mysql_ha_find(THD*,TABLE_LIST*)"
"mysql_test_create_table(Prepared_statement*)" -> "LEX::unlink_first_table(bool*)"
"mysql_test_create_table(Prepared_statement*)" -> "select_like_stmt_test(Prepared_statement*,int (*)(THD*),ulong)"
"mysql_test_create_table(Prepared_statement*)" -> "open_normal_and_derived_tables(THD*,TABLE_LIST*,uint)"
"mysql_test_create_table(Prepared_statement*)" -> "create_table_precheck(THD*,TABLE_LIST*,TABLE_LIST*)"
"mysql_test_create_table(Prepared_statement*)" -> "LEX::link_first_table_back(TABLE_LIST*,bool)"
"create_table_precheck(THD*,TABLE_LIST*,TABLE_LIST*)" -> "check_access(THD*,ulong,const char*,ulong*,GRANT_INTERNAL_INFO*,bool,bool)"
"create_table_precheck(THD*,TABLE_LIST*,TABLE_LIST*)" -> "check_table_access(THD*,ulong,TABLE_LIST*,bool,uint,bool)"
"mysql_test_insert_select(Prepared_statement*,TABLE_LIST*)" -> "insert_precheck(THD*,TABLE_LIST*)"
"mysql_test_insert_select(Prepared_statement*,TABLE_LIST*)" -> "select_like_stmt_test_with_open(Prepared_statement*,TABLE_LIST*,int (*)(THD*),ulong)"
"insert_precheck(THD*,TABLE_LIST*)" -> "my_message(uint,const char*,myf)"
"insert_precheck(THD*,TABLE_LIST*)" -> "check_one_table_access(THD*,ulong,TABLE_LIST*)"
"insert_precheck(THD*,TABLE_LIST*)" -> "_current_thd()"
"select_like_stmt_test_with_open(Prepared_statement*,TABLE_LIST*,int (*)(THD*),ulong)" -> "select_like_stmt_test(Prepared_statement*,int (*)(THD*),ulong)"
"select_like_stmt_test_with_open(Prepared_statement*,TABLE_LIST*,int (*)(THD*),ulong)" -> "open_normal_and_derived_tables(THD*,TABLE_LIST*,uint)"
"mysql_test_do_fields(Prepared_statement*,TABLE_LIST*,List<Item>*)" -> "setup_fields(THD*,Ref_ptr_array,List<Item>&,enum_mark_columns,List<Item>*,bool)"
"mysql_test_do_fields(Prepared_statement*,TABLE_LIST*,List<Item>*)" -> "Bounds_checked_array<Element_type>::Bounds_checked_array() [with Element_type = Item*]"
"mysql_test_do_fields(Prepared_statement*,TABLE_LIST*,List<Item>*)" -> "check_table_access(THD*,ulong,TABLE_LIST*,bool,uint,bool)"
"mysql_test_do_fields(Prepared_statement*,TABLE_LIST*,List<Item>*)" -> "open_normal_and_derived_tables(THD*,TABLE_LIST*,uint)"
"mysql_test_multidelete(Prepared_statement*,TABLE_LIST*)" -> "Item_null::Item_null()"
"mysql_test_multidelete(Prepared_statement*,TABLE_LIST*)" -> "multi_delete_precheck(THD*,TABLE_LIST*)"
"mysql_test_multidelete(Prepared_statement*,TABLE_LIST*)" -> "select_like_stmt_test_with_open(Prepared_statement*,TABLE_LIST*,int (*)(THD*),ulong)"
"mysql_test_multidelete(Prepared_statement*,TABLE_LIST*)" -> "my_error(int,myf,...)"
"mysql_test_multidelete(Prepared_statement*,TABLE_LIST*)" -> "add_item_to_list(THD*,Item*)"
"multi_delete_precheck(THD*,TABLE_LIST*)" -> "my_message(uint,const char*,myf)"
"multi_delete_precheck(THD*,TABLE_LIST*)" -> "check_table_access(THD*,ulong,TABLE_LIST*,bool,uint,bool)"
"multi_delete_precheck(THD*,TABLE_LIST*)" -> "_current_thd()"
"send_prep_stmt(Prepared_statement*,uint)" -> "THD::clear_error()"
"send_prep_stmt(Prepared_statement*,uint)" -> "Diagnostics_area::disable_status()"
"send_prep_stmt(Prepared_statement*,uint)" -> "THD::get_stmt_da()"
"mysql_test_update(Prepared_statement*,TABLE_LIST*)" -> "setup_fields(THD*,Ref_ptr_array,List<Item>&,enum_mark_columns,List<Item>*,bool)"
"mysql_test_update(Prepared_statement*,TABLE_LIST*)" -> "open_normal_and_derived_tables(THD*,TABLE_LIST*,uint)"
"mysql_test_update(Prepared_statement*,TABLE_LIST*)" -> "update_precheck(THD*,TABLE_LIST*)"
"mysql_test_update(Prepared_statement*,TABLE_LIST*)" -> "my_error(int,myf,...)"
"mysql_test_update(Prepared_statement*,TABLE_LIST*)" -> "mysql_prepare_update(THD*,TABLE_LIST*,Item**,uint,ORDER*)"
"mysql_test_update(Prepared_statement*,TABLE_LIST*)" -> "Bounds_checked_array<Element_type>::Bounds_checked_array() [with Element_type = Item*]"
"update_precheck(THD*,TABLE_LIST*)" -> "_current_thd()"
"update_precheck(THD*,TABLE_LIST*)" -> "check_one_table_access(THD*,ulong,TABLE_LIST*)"
"update_precheck(THD*,TABLE_LIST*)" -> "my_message(uint,const char*,myf)"
"mysql_prepare_update(THD*,TABLE_LIST*,Item**,uint,ORDER*)" -> "setup_order(THD*,Ref_ptr_array,TABLE_LIST*,List<Item>&,List<Item>&,ORDER*)"
"mysql_prepare_update(THD*,TABLE_LIST*,Item**,uint,ORDER*)" -> "setup_conds(THD*,TABLE_LIST*,TABLE_LIST*,Item**)"
"mysql_prepare_update(THD*,TABLE_LIST*,Item**,uint,ORDER*)" -> "setup_ftfuncs(SELECT_LEX*)"
"mysql_prepare_update(THD*,TABLE_LIST*,Item**,uint,ORDER*)" -> "unique_table(THD*,TABLE_LIST*,TABLE_LIST*,bool)"
"mysql_prepare_update(THD*,TABLE_LIST*,Item**,uint,ORDER*)" -> "update_non_unique_table_error(TABLE_LIST*,const char*,TABLE_LIST*)"
"mysql_prepare_update(THD*,TABLE_LIST*,Item**,uint,ORDER*)" -> "setup_tables_and_check_access(THD*,Name_resolution_context*,List<TABLE_LIST>*,TABLE_LIST*,TABLE_LIST**,bool,ulong,ulong)"
"mysql_prepare_update(THD*,TABLE_LIST*,Item**,uint,ORDER*)" -> "st_select_lex::fix_prepare_information(THD*,Item**,Item**)"
"mysql_prepare_update(THD*,TABLE_LIST*,Item**,uint,ORDER*)" -> "st_select_lex::setup_ref_array(THD*,uint)"
"mysql_prepare_update(THD*,TABLE_LIST*,Item**,uint,ORDER*)" -> "List<T>::List() [with T = Item]"
"mysql_test_insert(Prepared_statement*,TABLE_LIST*,List<Item>&,List<List<Item> >&,List<Item>&,List<Item>&,enum_duplicates)" -> "open_normal_and_derived_tables(THD*,TABLE_LIST*,uint)"
"mysql_test_insert(Prepared_statement*,TABLE_LIST*,List<Item>&,List<List<Item> >&,List<Item>&,List<Item>&,enum_duplicates)" -> "insert_precheck(THD*,TABLE_LIST*)"
"mysql_test_insert(Prepared_statement*,TABLE_LIST*,List<Item>&,List<List<Item> >&,List<Item>&,List<Item>&,enum_duplicates)" -> "setup_fields(THD*,Ref_ptr_array,List<Item>&,enum_mark_columns,List<Item>*,bool)"
"mysql_test_insert(Prepared_statement*,TABLE_LIST*,List<Item>&,List<List<Item> >&,List<Item>&,List<Item>&,enum_duplicates)" -> "my_error(int,myf,...)"
"mysql_test_insert(Prepared_statement*,TABLE_LIST*,List<Item>&,List<List<Item> >&,List<Item>&,List<Item>&,enum_duplicates)" -> "List_iterator_fast<T>::rewind() [with T = List<Item>]"
"mysql_test_insert(Prepared_statement*,TABLE_LIST*,List<Item>&,List<List<Item> >&,List<Item>&,List<Item>&,enum_duplicates)" -> "mysql_prepare_insert(THD*,TABLE_LIST*,TABLE*,List<Item>&,List_item*,List<Item>&,List<Item>&,enum_duplicates,Item**,bool,bool,bool)"
"mysql_test_insert(Prepared_statement*,TABLE_LIST*,List<Item>&,List<List<Item> >&,List<Item>&,List<Item>&,enum_duplicates)" -> "List_iterator_fast<T>::operator++(int) [with T = List<Item>]"
"mysql_test_insert(Prepared_statement*,TABLE_LIST*,List<Item>&,List<List<Item> >&,List<Item>&,List<Item>&,enum_duplicates)" -> "handler::ha_table_flags() const"
"mysql_test_insert(Prepared_statement*,TABLE_LIST*,List<Item>&,List<List<Item> >&,List<Item>&,List<Item>&,enum_duplicates)" -> "Bounds_checked_array<Element_type>::Bounds_checked_array() [with Element_type = Item*]"
"mysql_test_insert(Prepared_statement*,TABLE_LIST*,List<Item>&,List<List<Item> >&,List<Item>&,List<Item>&,enum_duplicates)" -> "open_temporary_tables(THD*,TABLE_LIST*)"
"mysql_test_insert(Prepared_statement*,TABLE_LIST*,List<Item>&,List<List<Item> >&,List<Item>&,List<Item>&,enum_duplicates)" -> "List_iterator_fast<T>::List_iterator_fast(List<T>&) [with T = List<Item>]"
"List_iterator_fast<T>::rewind() [with T = List<Item>]" -> "base_list_iterator::rewind()"
"mysql_prepare_insert(THD*,TABLE_LIST*,TABLE*,List<Item>&,List_item*,List<Item>&,List<Item>&,enum_duplicates,Item**,bool,bool,bool)" -> "check_that_all_fields_are_given_values(THD*,TABLE*,TABLE_LIST*)"
"mysql_prepare_insert(THD*,TABLE_LIST*,TABLE*,List<Item>&,List_item*,List<Item>&,List<Item>&,enum_duplicates,Item**,bool,bool,bool)" -> "prepare_for_positional_update(TABLE*,TABLE_LIST*)"
"mysql_prepare_insert(THD*,TABLE_LIST*,TABLE*,List<Item>&,List_item*,List<Item>&,List<Item>&,enum_duplicates,Item**,bool,bool,bool)" -> "st_select_lex::next_select()"
"mysql_prepare_insert(THD*,TABLE_LIST*,TABLE*,List<Item>&,List_item*,List<Item>&,List<Item>&,enum_duplicates,Item**,bool,bool,bool)" -> "mysql_prepare_insert_check_table(THD*,TABLE_LIST*,List<Item>&,bool)"
"mysql_prepare_insert(THD*,TABLE_LIST*,TABLE*,List<Item>&,List_item*,List<Item>&,List<Item>&,enum_duplicates,Item**,bool,bool,bool)" -> "Name_resolution_context::resolve_in_table_list_only(TABLE_LIST*)"
"mysql_prepare_insert(THD*,TABLE_LIST*,TABLE*,List<Item>&,List_item*,List<Item>&,List<Item>&,enum_duplicates,Item**,bool,bool,bool)" -> "st_select_lex::first_inner_unit()"
"mysql_prepare_insert(THD*,TABLE_LIST*,TABLE*,List<Item>&,List_item*,List<Item>&,List<Item>&,enum_duplicates,Item**,bool,bool,bool)" -> "check_update_fields(THD*,TABLE_LIST*,List<Item>&,List<Item>&,bool,table_map*)"
"mysql_prepare_insert(THD*,TABLE_LIST*,TABLE*,List<Item>&,List_item*,List<Item>&,List<Item>&,enum_duplicates,Item**,bool,bool,bool)" -> "setup_fields(THD*,Ref_ptr_array,List<Item>&,enum_mark_columns,List<Item>*,bool)"
"mysql_prepare_insert(THD*,TABLE_LIST*,TABLE*,List<Item>&,List_item*,List<Item>&,List<Item>&,enum_duplicates,Item**,bool,bool,bool)" -> "st_select_lex_unit::first_select()"
"mysql_prepare_insert(THD*,TABLE_LIST*,TABLE*,List<Item>&,List_item*,List<Item>&,List<Item>&,enum_duplicates,Item**,bool,bool,bool)" -> "update_non_unique_table_error(TABLE_LIST*,const char*,TABLE_LIST*)"
"mysql_prepare_insert(THD*,TABLE_LIST*,TABLE*,List<Item>&,List_item*,List<Item>&,List<Item>&,enum_duplicates,Item**,bool,bool,bool)" -> "TABLE_LIST::set_insert_values(MEM_ROOT*)"
"mysql_prepare_insert(THD*,TABLE_LIST*,TABLE*,List<Item>&,List_item*,List<Item>&,List<Item>&,enum_duplicates,Item**,bool,bool,bool)" -> "Name_resolution_context_state::Name_resolution_context_state()"
"mysql_prepare_insert(THD*,TABLE_LIST*,TABLE*,List<Item>&,List_item*,List<Item>&,List<Item>&,enum_duplicates,Item**,bool,bool,bool)" -> "Name_resolution_context_state::save_state(Name_resolution_context*,TABLE_LIST*)"
"mysql_prepare_insert(THD*,TABLE_LIST*,TABLE*,List<Item>&,List_item*,List<Item>&,List<Item>&,enum_duplicates,Item**,bool,bool,bool)" -> "Bounds_checked_array<Element_type>::Bounds_checked_array() [with Element_type = Item*]"
"mysql_prepare_insert(THD*,TABLE_LIST*,TABLE*,List<Item>&,List_item*,List<Item>&,List<Item>&,enum_duplicates,Item**,bool,bool,bool)" -> "check_insert_fields(THD*,TABLE_LIST*,List<Item>&,List<Item>&,bool,bool,table_map*)"
"mysql_prepare_insert(THD*,TABLE_LIST*,TABLE*,List<Item>&,List_item*,List<Item>&,List<Item>&,enum_duplicates,Item**,bool,bool,bool)" -> "unique_table(THD*,TABLE_LIST*,TABLE_LIST*,bool)"
"mysql_prepare_insert(THD*,TABLE_LIST*,TABLE*,List<Item>&,List_item*,List<Item>&,List<Item>&,enum_duplicates,Item**,bool,bool,bool)" -> "st_select_lex::fix_prepare_information(THD*,Item**,Item**)"
"mysql_prepare_insert(THD*,TABLE_LIST*,TABLE*,List<Item>&,List_item*,List<Item>&,List<Item>&,enum_duplicates,Item**,bool,bool,bool)" -> "st_select_lex_unit::next_unit()"
"mysql_prepare_insert(THD*,TABLE_LIST*,TABLE*,List<Item>&,List_item*,List<Item>&,List<Item>&,enum_duplicates,Item**,bool,bool,bool)" -> "Name_resolution_context_state::restore_state(Name_resolution_context*,TABLE_LIST*)"
"check_that_all_fields_are_given_values(THD*,TABLE*,TABLE_LIST*)" -> "TABLE_LIST::top_table()"
"check_that_all_fields_are_given_values(THD*,TABLE*,TABLE_LIST*)" -> "bitmap_is_set(const MY_BITMAP*,uint)"
"check_that_all_fields_are_given_values(THD*,TABLE*,TABLE_LIST*)" -> "_current_thd()"
"check_that_all_fields_are_given_values(THD*,TABLE*,TABLE_LIST*)" -> "push_warning_printf(THD*,Sql_condition::enum_warning_level,uint,const char*,...)"
"prepare_for_positional_update(TABLE*,TABLE_LIST*)" -> "List_iterator<T>::List_iterator(List<T>&) [with T = TABLE_LIST]"
"prepare_for_positional_update(TABLE*,TABLE_LIST*)" -> "List_iterator<T>::operator++(int) [with T = TABLE_LIST]"
"prepare_for_positional_update(TABLE*,TABLE_LIST*)" -> "prepare_for_positional_update(TABLE*,TABLE_LIST*)"
"prepare_for_positional_update(TABLE*,TABLE_LIST*)" -> "TABLE::prepare_for_position()"
"TABLE::prepare_for_position()" -> "handler::ha_table_flags() const"
"TABLE::prepare_for_position()" -> "TABLE::mark_columns_used_by_index_no_reset(uint,MY_BITMAP*)"
"TABLE::mark_columns_used_by_index_no_reset(uint,MY_BITMAP*)" -> "bitmap_set_bit(MY_BITMAP*,uint)"
"mysql_prepare_insert_check_table(THD*,TABLE_LIST*,List<Item>&,bool)" -> "setup_tables_and_check_access(THD*,Name_resolution_context*,List<TABLE_LIST>*,TABLE_LIST*,TABLE_LIST**,bool,ulong,ulong)"
"mysql_prepare_insert_check_table(THD*,TABLE_LIST*,List<Item>&,bool)" -> "insert_view_fields(THD*,List<Item>*,TABLE_LIST*)"
"mysql_prepare_insert_check_table(THD*,TABLE_LIST*,List<Item>&,bool)" -> "my_error(int,myf,...)"
"insert_view_fields(THD*,List<Item>*,TABLE_LIST*)" -> "List<T>::push_back(T*) [with T = Item]"
"insert_view_fields(THD*,List<Item>*,TABLE_LIST*)" -> "my_error(int,myf,...)"
"check_update_fields(THD*,TABLE_LIST*,List<Item>&,List<Item>&,bool,table_map*)" -> "Bounds_checked_array<Element_type>::Bounds_checked_array() [with Element_type = Item*]"
"check_update_fields(THD*,TABLE_LIST*,List<Item>&,List<Item>&,bool,table_map*)" -> "check_view_single_update(List<Item>&,List<Item>*,TABLE_LIST*,table_map*)"
"check_update_fields(THD*,TABLE_LIST*,List<Item>&,List<Item>&,bool,table_map*)" -> "setup_fields(THD*,Ref_ptr_array,List<Item>&,enum_mark_columns,List<Item>*,bool)"
"check_view_single_update(List<Item>&,List<Item>*,TABLE_LIST*,table_map*)" -> "List_iterator_fast<T>::List_iterator_fast(List<T>&) [with T = Item]"
"check_view_single_update(List<Item>&,List<Item>*,TABLE_LIST*,table_map*)" -> "TABLE_LIST::check_single_table(TABLE_LIST**,table_map,TABLE_LIST*)"
"check_view_single_update(List<Item>&,List<Item>*,TABLE_LIST*,table_map*)" -> "List_iterator_fast<T>::operator++(int) [with T = Item]"
"check_view_single_update(List<Item>&,List<Item>*,TABLE_LIST*,table_map*)" -> "List_iterator_fast<T>::init(List<T>&) [with T = Item]"
"check_view_single_update(List<Item>&,List<Item>*,TABLE_LIST*,table_map*)" -> "my_error(int,myf,...)"
"TABLE_LIST::check_single_table(TABLE_LIST**,table_map,TABLE_LIST*)" -> "TABLE_LIST::check_single_table(TABLE_LIST**,table_map,TABLE_LIST*)"
"List_iterator_fast<T>::init(List<T>&) [with T = Item]" -> "base_list_iterator::init(base_list&)"
"TABLE_LIST::set_insert_values(MEM_ROOT*)" -> "alloc_root(MEM_ROOT*,size_t)"
"TABLE_LIST::set_insert_values(MEM_ROOT*)" -> "TABLE_LIST::set_insert_values(MEM_ROOT*)"
"check_insert_fields(THD*,TABLE_LIST*,List<Item>&,List<Item>&,bool,bool,table_map*)" -> "check_view_insertability(THD*,TABLE_LIST*)"
"check_insert_fields(THD*,TABLE_LIST*,List<Item>&,List<Item>&,bool,bool,table_map*)" -> "my_error(int,myf,...)"
"check_insert_fields(THD*,TABLE_LIST*,List<Item>&,List<Item>&,bool,bool,table_map*)" -> "Name_resolution_context_state::Name_resolution_context_state()"
"check_insert_fields(THD*,TABLE_LIST*,List<Item>&,List<Item>&,bool,bool,table_map*)" -> "Name_resolution_context_state::restore_state(Name_resolution_context*,TABLE_LIST*)"
"check_insert_fields(THD*,TABLE_LIST*,List<Item>&,List<Item>&,bool,bool,table_map*)" -> "setup_fields(THD*,Ref_ptr_array,List<Item>&,enum_mark_columns,List<Item>*,bool)"
"check_insert_fields(THD*,TABLE_LIST*,List<Item>&,List<Item>&,bool,bool,table_map*)" -> "Name_resolution_context::resolve_in_table_list_only(TABLE_LIST*)"
"check_insert_fields(THD*,TABLE_LIST*,List<Item>&,List<Item>&,bool,bool,table_map*)" -> "Name_resolution_context_state::save_state(Name_resolution_context*,TABLE_LIST*)"
"check_insert_fields(THD*,TABLE_LIST*,List<Item>&,List<Item>&,bool,bool,table_map*)" -> "check_key_in_view(THD*,TABLE_LIST*)"
"check_insert_fields(THD*,TABLE_LIST*,List<Item>&,List<Item>&,bool,bool,table_map*)" -> "memset(void*,int,size_t)"
"check_insert_fields(THD*,TABLE_LIST*,List<Item>&,List<Item>&,bool,bool,table_map*)" -> "check_view_single_update(List<Item>&,List<Item>*,TABLE_LIST*,table_map*)"
"check_insert_fields(THD*,TABLE_LIST*,List<Item>&,List<Item>&,bool,bool,table_map*)" -> "Bounds_checked_array<Element_type>::Bounds_checked_array() [with Element_type = Item*]"
"check_view_insertability(THD*,TABLE_LIST*)" -> "Query_arena::alloc(size_t)"
"check_view_insertability(THD*,TABLE_LIST*)" -> "bitmap_fast_test_and_set(MY_BITMAP*,uint)"
"check_view_insertability(THD*,TABLE_LIST*)" -> "memset(void*,int,size_t)"
"check_view_insertability(THD*,TABLE_LIST*)" -> "bitmap_init(MY_BITMAP*,my_bitmap_map*,uint,my_bool)"
"List_iterator_fast<T>::operator++(int) [with T = List<Item>]" -> "base_list_iterator::next_fast()"
"List_iterator_fast<T>::List_iterator_fast(List<T>&) [with T = List<Item>]" -> "base_list_iterator::base_list_iterator(base_list&)"
"mysql_test_select(Prepared_statement*,TABLE_LIST*)" -> "open_normal_and_derived_tables(THD*,TABLE_LIST*,uint)"
"mysql_test_select(Prepared_statement*,TABLE_LIST*)" -> "my_error(int,myf,...)"
"mysql_test_select(Prepared_statement*,TABLE_LIST*)" -> "Prepared_statement::is_sql_prepare() const"
"mysql_test_select(Prepared_statement*,TABLE_LIST*)" -> "select_analyse::select_analyse(select_result*,const Proc_analyse_params*)"
"mysql_test_select(Prepared_statement*,TABLE_LIST*)" -> "select_precheck(THD*,LEX*,TABLE_LIST*,TABLE_LIST*)"
"mysql_test_select(Prepared_statement*,TABLE_LIST*)" -> "send_prep_stmt(Prepared_statement*,uint)"
"mysql_test_select(Prepared_statement*,TABLE_LIST*)" -> "select_send::select_send()"
"mysql_test_select(Prepared_statement*,TABLE_LIST*)" -> "st_select_lex_unit::prepare(THD*,select_result*,ulong)"
"select_analyse::select_analyse(select_result*,const Proc_analyse_params*)" -> "List<T>::List() [with T = Item]"
"select_analyse::select_analyse(select_result*,const Proc_analyse_params*)" -> "select_send::select_send()"
"select_send::select_send()" -> "select_result::select_result()"
"select_precheck(THD*,LEX*,TABLE_LIST*,TABLE_LIST*)" -> "check_access(THD*,ulong,const char*,ulong*,GRANT_INTERNAL_INFO*,bool,bool)"
"select_precheck(THD*,LEX*,TABLE_LIST*,TABLE_LIST*)" -> "check_show_access(THD*,TABLE_LIST*)"
"select_precheck(THD*,LEX*,TABLE_LIST*,TABLE_LIST*)" -> "check_table_access(THD*,ulong,TABLE_LIST*,bool,uint,bool)"
"mysql_test_multiupdate(Prepared_statement*,TABLE_LIST*,bool)" -> "select_like_stmt_test(Prepared_statement*,int (*)(THD*),ulong)"
"mysql_test_multiupdate(Prepared_statement*,TABLE_LIST*,bool)" -> "multi_update_precheck(THD*,TABLE_LIST*)"
"multi_update_precheck(THD*,TABLE_LIST*)" -> "_current_thd()"
"multi_update_precheck(THD*,TABLE_LIST*)" -> "my_error(int,myf,...)"
"multi_update_precheck(THD*,TABLE_LIST*)" -> "check_access(THD*,ulong,const char*,ulong*,GRANT_INTERNAL_INFO*,bool,bool)"
"multi_update_precheck(THD*,TABLE_LIST*)" -> "my_message(uint,const char*,myf)"
"mysql_test_set_fields(Prepared_statement*,TABLE_LIST*,List<set_var_base>*)" -> "List_iterator_fast<T>::operator++(int) [with T = set_var_base]"
"mysql_test_set_fields(Prepared_statement*,TABLE_LIST*,List<set_var_base>*)" -> "List_iterator_fast<T>::List_iterator_fast(List<T>&) [with T = set_var_base]"
"mysql_test_set_fields(Prepared_statement*,TABLE_LIST*,List<set_var_base>*)" -> "open_normal_and_derived_tables(THD*,TABLE_LIST*,uint)"
"mysql_test_set_fields(Prepared_statement*,TABLE_LIST*,List<set_var_base>*)" -> "check_table_access(THD*,ulong,TABLE_LIST*,bool,uint,bool)"
"Opt_trace_start::Opt_trace_start(THD*,TABLE_LIST*,enum_sql_command,List<set_var_base>*,const char*,size_t,sp_printable*,const CHARSET_INFO*)" -> "String::set_charset(const CHARSET_INFO*)"
"Opt_trace_start::Opt_trace_start(THD*,TABLE_LIST*,enum_sql_command,List<set_var_base>*,const char*,size_t,sp_printable*,const CHARSET_INFO*)" -> "String::String()"
"Opt_trace_start::Opt_trace_start(THD*,TABLE_LIST*,enum_sql_command,List<set_var_base>*,const char*,size_t,sp_printable*,const CHARSET_INFO*)" -> "anonymous}::list_has_optimizer_trace_table(const TABLE_LIST*)"
"Opt_trace_start::Opt_trace_start(THD*,TABLE_LIST*,enum_sql_command,List<set_var_base>*,const char*,size_t,sp_printable*,const CHARSET_INFO*)" -> "anonymous}::sql_command_can_be_traced(enum_sql_command)"
"Opt_trace_start::Opt_trace_start(THD*,TABLE_LIST*,enum_sql_command,List<set_var_base>*,const char*,size_t,sp_printable*,const CHARSET_INFO*)" -> "String::ptr() const"
"Opt_trace_start::Opt_trace_start(THD*,TABLE_LIST*,enum_sql_command,List<set_var_base>*,const char*,size_t,sp_printable*,const CHARSET_INFO*)" -> "__builtin_expect(long int,long int)"
"Opt_trace_start::Opt_trace_start(THD*,TABLE_LIST*,enum_sql_command,List<set_var_base>*,const char*,size_t,sp_printable*,const CHARSET_INFO*)" -> "Opt_trace_context::set_query(const char*,size_t,const CHARSET_INFO*)"
"Opt_trace_start::Opt_trace_start(THD*,TABLE_LIST*,enum_sql_command,List<set_var_base>*,const char*,size_t,sp_printable*,const CHARSET_INFO*)" -> "Opt_trace_context::start(bool,bool,bool,bool,long int,long int,ulong,ulonglong)"
"Opt_trace_start::Opt_trace_start(THD*,TABLE_LIST*,enum_sql_command,List<set_var_base>*,const char*,size_t,sp_printable*,const CHARSET_INFO*)" -> "Opt_trace_context::is_started() const"
"Opt_trace_start::Opt_trace_start(THD*,TABLE_LIST*,enum_sql_command,List<set_var_base>*,const char*,size_t,sp_printable*,const CHARSET_INFO*)" -> "String::length() const"
"Opt_trace_start::Opt_trace_start(THD*,TABLE_LIST*,enum_sql_command,List<set_var_base>*,const char*,size_t,sp_printable*,const CHARSET_INFO*)" -> "anonymous}::sets_var_optimizer_trace(enum_sql_command,List<set_var_base>*)"
"Opt_trace_start::Opt_trace_start(THD*,TABLE_LIST*,enum_sql_command,List<set_var_base>*,const char*,size_t,sp_printable*,const CHARSET_INFO*)" -> "anonymous}::opt_trace_disable_if_no_tables_access(THD*,TABLE_LIST*)"
"anonymous}::list_has_optimizer_trace_table(const TABLE_LIST*)" -> "strcmp(const char*,const char*)"
"Opt_trace_context::set_query(const char*,size_t,const CHARSET_INFO*)" -> "Opt_trace_stmt::set_query(const char*,size_t,const CHARSET_INFO*)"
"Opt_trace_stmt::set_query(const char*,size_t,const CHARSET_INFO*)" -> "random_name_to_avoid_gcc_bug_29365::Buffer::alloced_length() const"
"Opt_trace_stmt::set_query(const char*,size_t,const CHARSET_INFO*)" -> "random_name_to_avoid_gcc_bug_29365::Buffer::set_charset(const CHARSET_INFO*)"
"Opt_trace_stmt::set_query(const char*,size_t,const CHARSET_INFO*)" -> "Opt_trace_stmt::support_I_S() const"
"Opt_trace_stmt::set_query(const char*,size_t,const CHARSET_INFO*)" -> "random_name_to_avoid_gcc_bug_29365::Buffer::get_allowed_mem_size() const"
"Opt_trace_stmt::set_query(const char*,size_t,const CHARSET_INFO*)" -> "random_name_to_avoid_gcc_bug_29365::Buffer::set_allowed_mem_size(size_t)"
"Opt_trace_stmt::set_query(const char*,size_t,const CHARSET_INFO*)" -> "random_name_to_avoid_gcc_bug_29365::Buffer::append(const char*,size_t)"
"random_name_to_avoid_gcc_bug_29365::Buffer::set_charset(const CHARSET_INFO*)" -> "String::set_charset(const CHARSET_INFO*)"
"Opt_trace_context::start(bool,bool,bool,bool,long int,long int,ulong,ulonglong)" -> "Opt_trace_context::allowed_mem_size_for_current_stmt() const"
"Opt_trace_context::start(bool,bool,bool,bool,long int,long int,ulong,ulonglong)" -> "Opt_trace_context::purge_stmts(bool)"
"Opt_trace_context::start(bool,bool,bool,bool,long int,long int,ulong,ulonglong)" -> "Opt_trace_stmt::set_allowed_mem_size(size_t)"
"Opt_trace_context::start(bool,bool,bool,bool,long int,long int,ulong,ulonglong)" -> "Opt_trace_stmt::disable_I_S()"
"Opt_trace_context::start(bool,bool,bool,bool,long int,long int,ulong,ulonglong)" -> "Dynamic_array<Elem>::append(const Elem&) [with Elem = Opt_trace_stmt*]"
"Opt_trace_context::start(bool,bool,bool,bool,long int,long int,ulong,ulonglong)" -> "new_nothrow_w_my_error() [with T = Opt_trace_context::Opt_trace_context_impl]"
"Opt_trace_context::start(bool,bool,bool,bool,long int,long int,ulong,ulonglong)" -> "__builtin_expect(long int,long int)"
"Opt_trace_context::start(bool,bool,bool,bool,long int,long int,ulong,ulonglong)" -> "new_nothrow_w_my_error(Arg) [with T = Opt_trace_stmt,Arg = Opt_trace_context*]"
"Opt_trace_context::allowed_mem_size_for_current_stmt() const" -> "Opt_trace_stmt::alloced_length() const"
"Opt_trace_context::allowed_mem_size_for_current_stmt() const" -> "Dynamic_array<Elem>::elements() const [with Elem = Opt_trace_stmt*]"
"Opt_trace_context::allowed_mem_size_for_current_stmt() const" -> "Dynamic_array<Elem>::at(int) [with Elem = Opt_trace_stmt*]"
"Opt_trace_stmt::alloced_length() const" -> "random_name_to_avoid_gcc_bug_29365::Buffer::alloced_length() const"
"Opt_trace_context::purge_stmts(bool)" -> "Opt_trace_stmt::has_ended() const"
"Opt_trace_context::purge_stmts(bool)" -> "Dynamic_array<Elem>::at(int) [with Elem = Opt_trace_stmt*]"
"Opt_trace_context::purge_stmts(bool)" -> "Dynamic_array<Elem>::append(const Elem&) [with Elem = Opt_trace_stmt*]"
"Opt_trace_context::purge_stmts(bool)" -> "Dynamic_array<Elem>::elements() const [with Elem = Opt_trace_stmt*]"
"Opt_trace_context::purge_stmts(bool)" -> "Dynamic_array<Elem>::del(uint) [with Elem = Opt_trace_stmt*,uint = unsigned int]"
"Opt_trace_context::purge_stmts(bool)" -> "__builtin_expect(long int,long int)"
"Dynamic_array<Elem>::append(const Elem&) [with Elem = Opt_trace_stmt*]" -> "insert_dynamic(DYNAMIC_ARRAY*,const void*)"
"Dynamic_array<Elem>::del(uint) [with Elem = Opt_trace_stmt*,uint = unsigned int]" -> "delete_dynamic_element(DYNAMIC_ARRAY*,uint)"
"Opt_trace_stmt::set_allowed_mem_size(size_t)" -> "random_name_to_avoid_gcc_bug_29365::Buffer::set_allowed_mem_size(size_t)"
"new_nothrow_w_my_error() [with T = Opt_trace_context::Opt_trace_context_impl]" -> "Opt_trace_context::Opt_trace_context_impl::Opt_trace_context_impl()"
"new_nothrow_w_my_error() [with T = Opt_trace_context::Opt_trace_context_impl]" -> "my_error(int,myf,...)"
"new_nothrow_w_my_error() [with T = Opt_trace_context::Opt_trace_context_impl]" -> "__builtin_expect(long int,long int)"
"Opt_trace_context::Opt_trace_context_impl::Opt_trace_context_impl()" -> "Dynamic_array<Elem>::Dynamic_array(uint,uint) [with Elem = Opt_trace_stmt*,uint = unsigned int]"
"Dynamic_array<Elem>::Dynamic_array(uint,uint) [with Elem = Opt_trace_stmt*,uint = unsigned int]" -> "Dynamic_array<Elem>::init(uint,uint) [with Elem = Opt_trace_stmt*,uint = unsigned int]"
"Dynamic_array<Elem>::init(uint,uint) [with Elem = Opt_trace_stmt*,uint = unsigned int]" -> "init_dynamic_array2(DYNAMIC_ARRAY*,uint,void*,uint,uint)"
"new_nothrow_w_my_error(Arg) [with T = Opt_trace_stmt,Arg = Opt_trace_context*]" -> "my_error(int,myf,...)"
"new_nothrow_w_my_error(Arg) [with T = Opt_trace_stmt,Arg = Opt_trace_context*]" -> "__builtin_expect(long int,long int)"
"new_nothrow_w_my_error(Arg) [with T = Opt_trace_stmt,Arg = Opt_trace_context*]" -> "Opt_trace_stmt::Opt_trace_stmt(Opt_trace_context*)"
"Opt_trace_stmt::Opt_trace_stmt(Opt_trace_context*)" -> "random_name_to_avoid_gcc_bug_29365::Buffer::set_charset(const CHARSET_INFO*)"
"Opt_trace_stmt::Opt_trace_stmt(Opt_trace_context*)" -> "random_name_to_avoid_gcc_bug_29365::Buffer::Buffer()"
"Opt_trace_stmt::Opt_trace_stmt(Opt_trace_context*)" -> "Dynamic_array<Elem>::Dynamic_array(uint,uint) [with Elem = Opt_trace_struct*,uint = unsigned int]"
"random_name_to_avoid_gcc_bug_29365::Buffer::Buffer()" -> "String::String()"
"Dynamic_array<Elem>::Dynamic_array(uint,uint) [with Elem = Opt_trace_struct*,uint = unsigned int]" -> "Dynamic_array<Elem>::init(uint,uint) [with Elem = Opt_trace_struct*,uint = unsigned int]"
"Dynamic_array<Elem>::init(uint,uint) [with Elem = Opt_trace_struct*,uint = unsigned int]" -> "init_dynamic_array2(DYNAMIC_ARRAY*,uint,void*,uint,uint)"
"anonymous}::sets_var_optimizer_trace(enum_sql_command,List<set_var_base>*)" -> "List_iterator_fast<T>::operator++(int) [with T = set_var_base]"
"anonymous}::sets_var_optimizer_trace(enum_sql_command,List<set_var_base>*)" -> "List_iterator_fast<T>::List_iterator_fast(List<T>&) [with T = set_var_base]"
"Statement::Statement()" -> "String::String()"
"Statement::Statement()" -> "CSET_STRING::CSET_STRING()"
"Statement::Statement()" -> "Query_arena::Query_arena()"
"sp_cache_enforce_limit(sp_cache*,ulong)" -> "sp_cache::enforce_limit(ulong)"
"sp_cache::enforce_limit(ulong)" -> "my_hash_reset(HASH*)"
"Statement_map::insert(THD*,Statement*)" -> "my_hash_delete(HASH*,uchar*)"
"Statement_map::insert(THD*,Statement*)" -> "my_error(int,myf,...)"
"Statement_map::insert(THD*,Statement*)" -> "my_hash_insert(HASH*,const uchar*)"
"Statement_map::insert(THD*,Statement*)" -> "inline_mysql_mutex_unlock(mysql_mutex_t*)"
"Statement_map::insert(THD*,Statement*)" -> "inline_mysql_mutex_lock(mysql_mutex_t*)"
"Prepared_statement::Prepared_statement(THD*)" -> "init_sql_alloc(MEM_ROOT*,uint,uint)"
"Prepared_statement::Prepared_statement(THD*)" -> "Select_fetch_protocol_binary::Select_fetch_protocol_binary(THD*)"
"Prepared_statement::Prepared_statement(THD*)" -> "Statement::Statement(LEX*,MEM_ROOT*,Query_arena::enum_state,ulong)"
"Select_fetch_protocol_binary::Select_fetch_protocol_binary(THD*)" -> "select_send::select_send()"
"Select_fetch_protocol_binary::Select_fetch_protocol_binary(THD*)" -> "Protocol_binary::Protocol_binary(THD*)"
"Protocol_binary::Protocol_binary(THD*)" -> "Protocol::Protocol(THD*)"
"Protocol::Protocol(THD*)" -> "Protocol::init(THD*)"
"trans_commit_implicit(THD*)" -> "ha_commit_trans(THD*,bool,bool)"
"trans_commit_implicit(THD*)" -> "THD::in_multi_stmt_transaction_mode() const"
"trans_commit_implicit(THD*)" -> "THD_TRANS::reset_unsafe_rollback_flags()"
"ha_commit_trans(THD*,bool,bool)" -> "Statement_map::close_transient_cursors()"
"ha_commit_trans(THD*,bool,bool)" -> "my_error(int,myf,...)"
"ha_commit_trans(THD*,bool,bool)" -> "MDL_request::MDL_request()"
"ha_commit_trans(THD*,bool,bool)" -> "ha_rollback_trans(THD*,bool)"
"ha_commit_trans(THD*,bool,bool)" -> "MDL_request::init(MDL_key::enum_mdl_namespace,const char*,const char*,enum_mdl_type,enum_mdl_duration)"
"ha_commit_trans(THD*,bool,bool)" -> "MDL_context::release_lock(MDL_ticket*)"
"ha_commit_trans(THD*,bool,bool)" -> "ha_check_and_coalesce_trx_read_only(THD*,Ha_trx_info*,bool)"
"ha_commit_trans(THD*,bool,bool)" -> "THD::st_transactions::cleanup()"
"ha_commit_trans(THD*,bool,bool)" -> "MDL_context::acquire_lock(MDL_request*,ulong)"
"ha_check_and_coalesce_trx_read_only(THD*,Ha_trx_info*,bool)" -> "Ha_trx_info::coalesce_trx_with(const Ha_trx_info*)"
"ha_check_and_coalesce_trx_read_only(THD*,Ha_trx_info*,bool)" -> "Ha_trx_info::is_trx_read_write() const"
"ha_check_and_coalesce_trx_read_only(THD*,Ha_trx_info*,bool)" -> "Ha_trx_info::is_started() const"
"ha_check_and_coalesce_trx_read_only(THD*,Ha_trx_info*,bool)" -> "Ha_trx_info::next() const"
"ha_check_and_coalesce_trx_read_only(THD*,Ha_trx_info*,bool)" -> "Ha_trx_info::ht() const"
"Ha_trx_info::coalesce_trx_with(const Ha_trx_info*)" -> "Ha_trx_info::set_trx_read_write()"
"Ha_trx_info::coalesce_trx_with(const Ha_trx_info*)" -> "Ha_trx_info::is_trx_read_write() const"
"mysql_parse(THD*,char*,uint,Parser_state*)" -> "THD::end_statement()"
"mysql_parse(THD*,char*,uint,Parser_state*)" -> "__builtin_expect(long int,long int)"
"mysql_parse(THD*,char*,uint,Parser_state*)" -> "stmt_causes_implicit_commit(const THD*,uint)"
"mysql_parse(THD*,char*,uint,Parser_state*)" -> "THD::cleanup_after_query()"
"mysql_parse(THD*,char*,uint,Parser_state*)" -> "general_log_write(THD*,enum_server_command,const char*,uint)"
"mysql_parse(THD*,char*,uint,Parser_state*)" -> "THD::is_error() const"
"mysql_parse(THD*,char*,uint,Parser_state*)" -> "String::c_ptr_safe()"
"mysql_parse(THD*,char*,uint,Parser_state*)" -> "THD::charset()"
"mysql_parse(THD*,char*,uint,Parser_state*)" -> "mysql_execute_command(THD*)"
"mysql_parse(THD*,char*,uint,Parser_state*)" -> "mysql_rewrite_query(THD*)"
"mysql_parse(THD*,char*,uint,Parser_state*)" -> "parse_sql(THD*,Parser_state*,Object_creation_ctx*)"
"mysql_parse(THD*,char*,uint,Parser_state*)" -> "Query_cache::send_result_to_client(THD*,char*,uint)"
"mysql_parse(THD*,char*,uint,Parser_state*)" -> "Statement::query() const"
"mysql_parse(THD*,char*,uint,Parser_state*)" -> "THD::enter_stage(const PSI_stage_info*,PSI_stage_info*,const char*,const char*,unsigned int)"
"mysql_parse(THD*,char*,uint,Parser_state*)" -> "lex_start(THD*)"
"mysql_parse(THD*,char*,uint,Parser_state*)" -> "my_error(int,myf,...)"
"mysql_parse(THD*,char*,uint,Parser_state*)" -> "gtid_empty_group_log_and_cleanup(THD*)"
"mysql_parse(THD*,char*,uint,Parser_state*)" -> "String::length() const"
"mysql_parse(THD*,char*,uint,Parser_state*)" -> "Statement::set_query_inner(char*,uint32,const CHARSET_INFO*)"
"mysql_parse(THD*,char*,uint,Parser_state*)" -> "Query_cache::abort(Query_cache_tls*)"
"mysql_parse(THD*,char*,uint,Parser_state*)" -> "mysql_reset_thd_for_next_command(THD*)"
"mysql_parse(THD*,char*,uint,Parser_state*)" -> "Statement::query_length() const"
"mysql_parse(THD*,char*,uint,Parser_state*)" -> "sp_cache_enforce_limit(sp_cache*,ulong)"
"mysql_parse(THD*,char*,uint,Parser_state*)" -> "LEX::set_trg_event_type_for_tables()"
"THD::end_statement()" -> "lex_end(LEX*)"
"general_log_write(THD*,enum_server_command,const char*,uint)" -> "LOGGER::general_log_write(THD*,enum_server_command,const char*,uint)"
"general_log_write(THD*,enum_server_command,const char*,uint)" -> "LOGGER::log_command(THD*,enum_server_command)"
"mysql_execute_command(THD*)" -> "drop_server(THD*,LEX_SERVER_OPTIONS*,bool)"
"mysql_execute_command(THD*)" -> "Open_tables_state::get_reprepare_observer() const"
"mysql_execute_command(THD*)" -> "open_normal_and_derived_tables(THD*,TABLE_LIST*,uint)"
"mysql_execute_command(THD*)" -> "TRACE_FUNCTION_END()"
"mysql_execute_command(THD*)" -> "_current_thd()"
"mysql_execute_command(THD*)" -> "mysql_sql_stmt_close(THD*)"
"mysql_execute_command(THD*)" -> "sql_kill(THD*,ulong,bool)"
"mysql_execute_command(THD*)" -> "check_and_convert_db_name(LEX_STRING*,bool)"
"mysql_execute_command(THD*)" -> "check_some_access(THD*,ulong,TABLE_LIST*)"
"mysql_execute_command(THD*)" -> "open_temporary_tables(THD*,TABLE_LIST*)"
"mysql_execute_command(THD*)" -> "Reprepare_observer::report_error(THD*)"
"mysql_execute_command(THD*)" -> "append_file_to_dir(THD*,const char**,const char*)"
"mysql_execute_command(THD*)" -> "List<T>::head() [with T = Item]"
"mysql_execute_command(THD*)" -> "THD::is_error() const"
"mysql_execute_command(THD*)" -> "write_bin_log(THD*,bool,const char*,ulong,bool)"
"mysql_execute_command(THD*)" -> "mysql_load(THD*,sql_exchange*,TABLE_LIST*,List<Item>&,List<Item>&,List<Item>&,enum_duplicates,bool,bool)"
"mysql_execute_command(THD*)" -> "MDL_context::release_statement_locks()"
"mysql_execute_command(THD*)" -> "trans_rollback(THD*)"
"mysql_execute_command(THD*)" -> "mysql_assign_to_keycache(THD*,TABLE_LIST*,LEX_STRING*)"
"mysql_execute_command(THD*)" -> "mysql_rm_table(THD*,TABLE_LIST*,my_bool,my_bool)"
"mysql_execute_command(THD*)" -> "trans_xa_prepare(THD*)"
"mysql_execute_command(THD*)" -> "Query_arena::strmake(const char*,size_t)"
"mysql_execute_command(THD*)" -> "trans_xa_rollback(THD*)"
"mysql_execute_command(THD*)" -> "mysql_multi_delete_prepare(THD*,uint*)"
"mysql_execute_command(THD*)" -> "Statement::query_length() const"
"mysql_execute_command(THD*)" -> "explain_multi_table_modification(THD*,select_result_interceptor*)"
"mysql_execute_command(THD*)" -> "find_udf(const char*,uint,bool)"
"mysql_execute_command(THD*)" -> "mysql_do(THD*,List<Item>&)"
"mysql_execute_command(THD*)" -> "Diagnostics_area::set_overwrite_status(bool)"
"mysql_execute_command(THD*)" -> "PROFILING::discard_current_query()"
"mysql_execute_command(THD*)" -> "handle_select(THD*,select_result*,ulong)"
"mysql_execute_command(THD*)" -> "gtid_pre_statement_checks(const THD*)"
"mysql_execute_command(THD*)" -> "inline_mysql_mutex_unlock(mysql_mutex_t*)"
"mysql_execute_command(THD*)" -> "mysqld_show_warnings(THD*,ulong)"
"mysql_execute_command(THD*)" -> "select_create::select_create(TABLE_LIST*,HA_CREATE_INFO*,Alter_info*,List<Item>&,enum_duplicates,bool,TABLE_LIST*)"
"mysql_execute_command(THD*)" -> "Query_tables_list::set_stmt_unsafe(Query_tables_list::enum_binlog_stmt_unsafe)"
"mysql_execute_command(THD*)" -> "my_ok(THD*,ulonglong,ulonglong,const char*)"
"mysql_execute_command(THD*)" -> "Statement::query() const"
"mysql_execute_command(THD*)" -> "MYSQL_LOG::is_open()"
"mysql_execute_command(THD*)" -> "strlen(const char*)"
"mysql_execute_command(THD*)" -> "check_table_access(THD*,ulong,TABLE_LIST*,bool,uint,bool)"
"mysql_execute_command(THD*)" -> "push_warning(THD*,Sql_condition::enum_warning_level,uint,const char*)"
"mysql_execute_command(THD*)" -> "trans_rollback_implicit(THD*)"
"mysql_execute_command(THD*)" -> "mysql_change_db(THD*,const LEX_STRING*,bool)"
"mysql_execute_command(THD*)" -> "add_diff_to_status(STATUS_VAR*,STATUS_VAR*,STATUS_VAR*)"
"mysql_execute_command(THD*)" -> "mysqld_show_privileges(THD*)"
"mysql_execute_command(THD*)" -> "sp_create_routine(THD*,sp_head*)"
"mysql_execute_command(THD*)" -> "sp_process_definer(THD*)"
"mysql_execute_command(THD*)" -> "mysqld_show_create(THD*,TABLE_LIST*)"
"mysql_execute_command(THD*)" -> "Global_read_lock::is_acquired() const"
"mysql_execute_command(THD*)" -> "sql_set_variables(THD*,List<set_var_base>*)"
"mysql_execute_command(THD*)" -> "select_insert::select_insert(TABLE_LIST*,TABLE*,List<Item>*,List<Item>*,List<Item>*,List<Item>*,enum_duplicates,bool)"
"mysql_execute_command(THD*)" -> "check_global_access(THD*,ulong)"
"mysql_execute_command(THD*)" -> "mysql_create_or_drop_trigger(THD*,TABLE_LIST*,bool)"
"mysql_execute_command(THD*)" -> "open_and_lock_tables(THD*,TABLE_LIST*,bool,uint)"
"mysql_execute_command(THD*)" -> "mysql_uninstall_plugin(THD*,const LEX_STRING*)"
"mysql_execute_command(THD*)" -> "update_precheck(THD*,TABLE_LIST*)"
"mysql_execute_command(THD*)" -> "insert_precheck(THD*,TABLE_LIST*)"
"mysql_execute_command(THD*)" -> "List_iterator_fast<T>::List_iterator_fast(List<T>&) [with T = Item]"
"mysql_execute_command(THD*)" -> "multi_update_precheck(THD*,TABLE_LIST*)"
"mysql_execute_command(THD*)" -> "delete_precheck(THD*,TABLE_LIST*)"
"mysql_execute_command(THD*)" -> "some_non_temp_table_to_be_updated(THD*,TABLE_LIST*)"
"mysql_execute_command(THD*)" -> "trans_rollback_stmt(THD*)"
"mysql_execute_command(THD*)" -> "lock_tables_precheck(THD*,TABLE_LIST*)"
"mysql_execute_command(THD*)" -> "mysql_select(THD*,TABLE_LIST*,uint,List<Item>&,Item*,SQL_I_List<st_order>*,SQL_I_List<st_order>*,Item*,ulonglong,select_result*,SELECT_LEX_UNIT*,SELECT_LEX*)"
"mysql_execute_command(THD*)" -> "sp_head::execute_procedure(THD*,List<Item>*)"
"mysql_execute_command(THD*)" -> "Diagnostics_area::set_warning_info_read_only(bool)"
"mysql_execute_command(THD*)" -> "st_select_lex_unit::cleanup()"
"mysql_execute_command(THD*)" -> "ha_default_temp_handlerton(THD*)"
"mysql_execute_command(THD*)" -> "mysql_rm_db(THD*,char*,bool,bool)"
"mysql_execute_command(THD*)" -> "memset(void*,int,size_t)"
"mysql_execute_command(THD*)" -> "mysql_create_table(THD*,TABLE_LIST*,HA_CREATE_INFO*,Alter_info*)"
"mysql_execute_command(THD*)" -> "MYSQL_BIN_LOG::is_query_in_union(THD*,query_id_t)"
"mysql_execute_command(THD*)" -> "mysql_multi_update(THD*,TABLE_LIST*,List<Item>*,List<Item>*,Item*,ulonglong,enum_duplicates,bool,SELECT_LEX_UNIT*,SELECT_LEX*,multi_update**)"
"mysql_execute_command(THD*)" -> "THD::enter_stage(const PSI_stage_info*,PSI_stage_info*,const char*,const char*,unsigned int)"
"mysql_execute_command(THD*)" -> "Query_cache::invalidate_locked_for_write(TABLE_LIST*)"
"mysql_execute_command(THD*)" -> "Name_resolution_context::resolve_in_table_list_only(TABLE_LIST*)"
"mysql_execute_command(THD*)" -> "Locked_tables_list::unlock_locked_tables(THD*)"
"mysql_execute_command(THD*)" -> "trans_savepoint(THD*,LEX_STRING)"
"mysql_execute_command(THD*)" -> "create_table_precheck(THD*,TABLE_LIST*,TABLE_LIST*)"
"mysql_execute_command(THD*)" -> "base_list::empty()"
"mysql_execute_command(THD*)" -> "TRACE_END(int)"
"mysql_execute_command(THD*)" -> "mysqld_list_processes(THD*,const char*,bool)"
"mysql_execute_command(THD*)" -> "my_message(uint,const char*,myf)"
"mysql_execute_command(THD*)" -> "Opt_trace_object::Opt_trace_object(Opt_trace_context*,Opt_trace_context::feature_value)"
"mysql_execute_command(THD*)" -> "multi_delete::multi_delete(TABLE_LIST*,uint)"
"mysql_execute_command(THD*)" -> "Opt_trace_start::Opt_trace_start(THD*,TABLE_LIST*,enum_sql_command,List<set_var_base>*,const char*,size_t,sp_printable*,const CHARSET_INFO*)"
"mysql_execute_command(THD*)" -> "multi_delete_precheck(THD*,TABLE_LIST*)"
"mysql_execute_command(THD*)" -> "partition_info::get_clone()"
"mysql_execute_command(THD*)" -> "select_precheck(THD*,LEX*,TABLE_LIST*,TABLE_LIST*)"
"mysql_execute_command(THD*)" -> "Alter_info::Alter_info(const Alter_info&,MEM_ROOT*)"
"mysql_execute_command(THD*)" -> "sp_find_routine(THD*,enum_sp_type,sp_name*,sp_cache**,bool)"
"mysql_execute_command(THD*)" -> "THD::send_kill_message() const"
"mysql_execute_command(THD*)" -> "sp_show_create_routine(THD*,enum_sp_type,sp_name*)"
"mysql_execute_command(THD*)" -> "Query_cache::invalidate(THD*,TABLE_LIST*,my_bool)"
"mysql_execute_command(THD*)" -> "mysql_preload_keys(THD*,TABLE_LIST*)"
"mysql_execute_command(THD*)" -> "mysql_insert(THD*,TABLE_LIST*,List<Item>&,List<List<Item> >&,List<Item>&,List<Item>&,enum_duplicates,bool)"
"mysql_execute_command(THD*)" -> "THD::get_row_count_func() const"
"mysql_execute_command(THD*)" -> "trans_begin(THD*,uint)"
"mysql_execute_command(THD*)" -> "inline_mysql_mutex_lock(mysql_mutex_t*)"
"mysql_execute_command(THD*)" -> "LEX::link_first_table_back(TABLE_LIST*,bool)"
"mysql_execute_command(THD*)" -> "__builtin_expect(long int,long int)"
"mysql_execute_command(THD*)" -> "mysql_ha_rm_tables(THD*,TABLE_LIST*)"
"mysql_execute_command(THD*)" -> "reload_acl_and_cache(THD*,long unsigned int,TABLE_LIST*,int*)"
"mysql_execute_command(THD*)" -> "PROFILING::show_profiles()"
"mysql_execute_command(THD*)" -> "LEX::is_broken() const"
"mysql_execute_command(THD*)" -> "trans_rollback_to_savepoint(THD*,LEX_STRING)"
"mysql_execute_command(THD*)" -> "TABLE_LIST::TABLE_LIST()"
"mysql_execute_command(THD*)" -> "mysql_drop_function(THD*,const LEX_STRING*)"
"mysql_execute_command(THD*)" -> "mysql_create_view(THD*,TABLE_LIST*,enum_view_create_mode)"
"mysql_execute_command(THD*)" -> "mysql_checksum_table(THD*,TABLE_LIST*,HA_CHECK_OPT*)"
"mysql_execute_command(THD*)" -> "mysql_sql_stmt_execute(THD*)"
"mysql_execute_command(THD*)" -> "TABLE_LIST::operator=(const TABLE_LIST&)"
"mysql_execute_command(THD*)" -> "mysql_xa_recover(THD*)"
"mysql_execute_command(THD*)" -> "trans_release_savepoint(THD*,LEX_STRING)"
"mysql_execute_command(THD*)" -> "mysql_alter_table(THD*,char*,char*,HA_CREATE_INFO*,TABLE_LIST*,Alter_info*,uint,ORDER*,bool)"
"mysql_execute_command(THD*)" -> "my_error(int,myf,...)"
"mysql_execute_command(THD*)" -> "sp_drop_routine(THD*,enum_sp_type,sp_name*)"
"mysql_execute_command(THD*)" -> "stmt_causes_implicit_commit(const THD*,uint)"
"mysql_execute_command(THD*)" -> "deny_updates_if_read_only_option(THD*,TABLE_LIST*)"
"mysql_execute_command(THD*)" -> "mysql_delete(THD*,TABLE_LIST*,Item*,SQL_I_List<st_order>*,ha_rows,ulonglong)"
"mysql_execute_command(THD*)" -> "LEX::first_lists_tables_same()"
"mysql_execute_command(THD*)" -> "trans_commit_stmt(THD*)"
"mysql_execute_command(THD*)" -> "push_warning_printf(THD*,Sql_condition::enum_warning_level,uint,const char*,...)"
"mysql_execute_command(THD*)" -> "Diagnostics_area::opt_clear_warning_info(ulonglong)"
"mysql_execute_command(THD*)" -> "mysql_create_function(THD*,udf_func*)"
"mysql_execute_command(THD*)" -> "st_ha_create_information::st_ha_create_information(const st_ha_create_information&)"
"mysql_execute_command(THD*)" -> "THD::killed_errno() const"
"mysql_execute_command(THD*)" -> "mysql_multi_update_prepare(THD*)"
"mysql_execute_command(THD*)" -> "ha_show_status(THD*,handlerton*,ha_stat_type)"
"mysql_execute_command(THD*)" -> "ha_default_handlerton(THD*)"
"mysql_execute_command(THD*)" -> "sp_update_routine(THD*,enum_sp_type,sp_name*,st_sp_chistics*)"
"mysql_execute_command(THD*)" -> "mysql_alter_db(THD*,const char*,HA_CREATE_INFO*)"
"mysql_execute_command(THD*)" -> "mysql_install_plugin(THD*,const LEX_STRING*,const LEX_STRING*)"
"mysql_execute_command(THD*)" -> "THD::in_multi_stmt_transaction_mode() const"
"mysql_execute_command(THD*)" -> "mysql_alter_tablespace(THD*,st_alter_tablespace*)"
"mysql_execute_command(THD*)" -> "TRACE_FUNCTION_START()"
"mysql_execute_command(THD*)" -> "mysql_insert_select_prepare(THD*)"
"mysql_execute_command(THD*)" -> "TRACE_START()"
"mysql_execute_command(THD*)" -> "trans_commit_implicit(THD*)"
"mysql_execute_command(THD*)" -> "create_server(THD*,LEX_SERVER_OPTIONS*)"
"mysql_execute_command(THD*)" -> "trans_check_state(THD*)"
"mysql_execute_command(THD*)" -> "THD::get_stmt_da()"
"mysql_execute_command(THD*)" -> "reset_one_shot_variables(THD*)"
"mysql_execute_command(THD*)" -> "check_routine_access(THD*,ulong,char*,char*,bool,bool)"
"mysql_execute_command(THD*)" -> "alter_server(THD*,LEX_SERVER_OPTIONS*)"
"mysql_execute_command(THD*)" -> "execute_sqlcom_select(THD*,TABLE_LIST*)"
"mysql_execute_command(THD*)" -> "mysql_create_like_table(THD*,TABLE_LIST*,TABLE_LIST*,HA_CREATE_INFO*)"
"mysql_execute_command(THD*)" -> "mysql_create_db(THD*,char*,HA_CREATE_INFO*,bool)"
"mysql_execute_command(THD*)" -> "show_create_trigger(THD*,const sp_name*)"
"mysql_execute_command(THD*)" -> "Opt_trace_array::Opt_trace_array(Opt_trace_context*,const char*,Opt_trace_context::feature_value)"
"mysql_execute_command(THD*)" -> "mysql_update(THD*,TABLE_LIST*,List<Item>&,List<Item>&,Item*,uint,ORDER*,ha_rows,enum_duplicates,bool,ha_rows*,ha_rows*)"
"mysql_execute_command(THD*)" -> "st_select_lex_unit::set_limit(st_select_lex*)"
"mysql_execute_command(THD*)" -> "mysqld_show_create_db(THD*,char*,HA_CREATE_INFO*)"
"mysql_execute_command(THD*)" -> "trans_xa_commit(THD*)"
"mysql_execute_command(THD*)" -> "add_item_to_list(THD*,Item*)"
"mysql_execute_command(THD*)" -> "mysql_rename_tables(THD*,TABLE_LIST*,bool)"
"mysql_execute_command(THD*)" -> "check_access(THD*,ulong,const char*,ulong*,GRANT_INTERNAL_INFO*,bool,bool)"
"mysql_execute_command(THD*)" -> "trans_commit(THD*)"
"mysql_execute_command(THD*)" -> "mysqld_help(THD*,const char*)"
"mysql_execute_command(THD*)" -> "flush_tables_with_read_lock(THD*,TABLE_LIST*)"
"mysql_execute_command(THD*)" -> "trans_xa_end(THD*)"
"mysql_execute_command(THD*)" -> "Global_read_lock::unlock_global_read_lock(THD*)"
"mysql_execute_command(THD*)" -> "mysql_upgrade_db(THD*,LEX_STRING*)"
"mysql_execute_command(THD*)" -> "mysql_sql_stmt_prepare(THD*)"
"mysql_execute_command(THD*)" -> "LEX::table_or_sp_used()"
"mysql_execute_command(THD*)" -> "mysql_drop_view(THD*,TABLE_LIST*,enum_drop_mode)"
"mysql_execute_command(THD*)" -> "List_iterator_fast<T>::operator++(int) [with T = Item]"
"mysql_execute_command(THD*)" -> "close_thread_tables(THD*)"
"mysql_execute_command(THD*)" -> "trans_xa_start(THD*)"
"mysql_execute_command(THD*)" -> "MDL_context::release_transactional_locks()"
"mysql_execute_command(THD*)" -> "Item_null::Item_null()"
"mysql_execute_command(THD*)" -> "check_db_dir_existence(const char*)"
"mysql_execute_command(THD*)" -> "LEX::unlink_first_table(bool*)"
"mysql_execute_command(THD*)" -> "st_ha_create_information::st_ha_create_information()"
"mysql_execute_command(THD*)" -> "sp_head::is_not_allowed_in_function(const char*)"
"mysql_execute_command(THD*)" -> "lock_tables_open_and_lock_tables(THD*,TABLE_LIST*)"
"mysql_execute_command(THD*)" -> "sp_head::name(uint*) const"
"mysql_execute_command(THD*)" -> "check_one_table_access(THD*,ulong,TABLE_LIST*)"
"mysql_execute_command(THD*)" -> "flush_tables_for_export(THD*,TABLE_LIST*)"
"drop_server(THD*,LEX_SERVER_OPTIONS*,bool)" -> "close_mysql_tables(THD*)"
"drop_server(THD*,LEX_SERVER_OPTIONS*,bool)" -> "delete_server_record_in_cache(LEX_SERVER_OPTIONS*,bool)"
"drop_server(THD*,LEX_SERVER_OPTIONS*,bool)" -> "inline_mysql_rwlock_wrlock(mysql_rwlock_t*)"
"drop_server(THD*,LEX_SERVER_OPTIONS*,bool)" -> "TABLE_LIST::init_one_table(const char*,size_t,const char*,size_t,const char*,thr_lock_type)"
"drop_server(THD*,LEX_SERVER_OPTIONS*,bool)" -> "TABLE_LIST::TABLE_LIST()"
"drop_server(THD*,LEX_SERVER_OPTIONS*,bool)" -> "open_ltable(THD*,TABLE_LIST*,thr_lock_type,uint)"
"drop_server(THD*,LEX_SERVER_OPTIONS*,bool)" -> "inline_mysql_rwlock_unlock(mysql_rwlock_t*)"
"drop_server(THD*,LEX_SERVER_OPTIONS*,bool)" -> "push_warning_printf(THD*,Sql_condition::enum_warning_level,uint,const char*,...)"
"drop_server(THD*,LEX_SERVER_OPTIONS*,bool)" -> "close_cached_connection_tables(THD*,LEX_STRING*)"
"drop_server(THD*,LEX_SERVER_OPTIONS*,bool)" -> "delete_server_record(TABLE*,char*,size_t,bool)"
"close_mysql_tables(THD*)" -> "close_thread_tables(THD*)"
"close_mysql_tables(THD*)" -> "MDL_context::release_transactional_locks()"
"delete_server_record_in_cache(LEX_SERVER_OPTIONS*,bool)" -> "my_error(int,myf,...)"
"delete_server_record_in_cache(LEX_SERVER_OPTIONS*,bool)" -> "my_hash_search(const HASH*,const uchar*,size_t)"
"delete_server_record_in_cache(LEX_SERVER_OPTIONS*,bool)" -> "my_hash_delete(HASH*,uchar*)"
"open_ltable(THD*,TABLE_LIST*,thr_lock_type,uint)" -> "trans_rollback_stmt(THD*)"
"open_ltable(THD*,TABLE_LIST*,thr_lock_type,uint)" -> "my_error(int,myf,...)"
"open_ltable(THD*,TABLE_LIST*,thr_lock_type,uint)" -> "open_table(THD*,TABLE_LIST*,Open_table_context*)"
"open_ltable(THD*,TABLE_LIST*,thr_lock_type,uint)" -> "THD::enter_stage(const PSI_stage_info*,PSI_stage_info*,const char*,const char*,unsigned int)"
"open_ltable(THD*,TABLE_LIST*,thr_lock_type,uint)" -> "Open_table_context::recover_from_failed_open()"
"open_ltable(THD*,TABLE_LIST*,thr_lock_type,uint)" -> "Open_table_context::start_of_statement_svp() const"
"open_ltable(THD*,TABLE_LIST*,thr_lock_type,uint)" -> "Open_table_context::Open_table_context(THD*,uint)"
"open_ltable(THD*,TABLE_LIST*,thr_lock_type,uint)" -> "Open_table_context::can_recover_from_failed_open() const"
"open_ltable(THD*,TABLE_LIST*,thr_lock_type,uint)" -> "mysql_lock_tables(THD*,TABLE**,uint,uint)"
"open_ltable(THD*,TABLE_LIST*,thr_lock_type,uint)" -> "check_lock_and_start_stmt(THD*,Query_tables_list*,TABLE_LIST*)"
"open_ltable(THD*,TABLE_LIST*,thr_lock_type,uint)" -> "MDL_context::rollback_to_savepoint(const MDL_savepoint&)"
"open_ltable(THD*,TABLE_LIST*,thr_lock_type,uint)" -> "close_thread_tables(THD*)"
"close_cached_connection_tables(THD*,LEX_STRING*)" -> "inline_mysql_mutex_unlock(mysql_mutex_t*)"
"close_cached_connection_tables(THD*,LEX_STRING*)" -> "close_cached_tables(THD*,TABLE_LIST*,bool,ulong)"
"close_cached_connection_tables(THD*,LEX_STRING*)" -> "inline_mysql_mutex_lock(mysql_mutex_t*)"
"close_cached_connection_tables(THD*,LEX_STRING*)" -> "strncasecmp(const char*,const char*,size_t)"
"close_cached_connection_tables(THD*,LEX_STRING*)" -> "memset(void*,int,size_t)"
"close_cached_connection_tables(THD*,LEX_STRING*)" -> "my_hash_element(HASH*,ulong)"
"close_cached_connection_tables(THD*,LEX_STRING*)" -> "TABLE_LIST::TABLE_LIST()"
"close_cached_connection_tables(THD*,LEX_STRING*)" -> "memdup_root(MEM_ROOT*,const void*,size_t)"
"delete_server_record(TABLE*,char*,size_t,bool)" -> "TABLE::use_all_columns()"
"delete_server_record(TABLE*,char*,size_t,bool)" -> "handler::ha_index_read_idx_map(uchar*,uint,const uchar*,key_part_map,ha_rkey_function)"
"delete_server_record(TABLE*,char*,size_t,bool)" -> "my_error(int,myf,...)"
"delete_server_record(TABLE*,char*,size_t,bool)" -> "handler::ha_delete_row(const uchar*)"
"handler::ha_delete_row(const uchar*)" -> "binlog_log_row(TABLE*,const uchar*,const uchar*,bool (*)(THD*,TABLE*,bool,const uchar*,const uchar*))"
"handler::ha_delete_row(const uchar*)" -> "__builtin_expect(long int,long int)"
"handler::ha_delete_row(const uchar*)" -> "handler::mark_trx_read_write()"
"binlog_log_row(TABLE*,const uchar*,const uchar*,bool (*)(THD*,TABLE*,bool,const uchar*,const uchar*))" -> "__builtin_expect(long int,long int)"
"binlog_log_row(TABLE*,const uchar*,const uchar*,bool (*)(THD*,TABLE*,bool,const uchar*,const uchar*))" -> "handler::has_transactions()"
"binlog_log_row(TABLE*,const uchar*,const uchar*,bool (*)(THD*,TABLE*,bool,const uchar*,const uchar*))" -> "write_locked_table_maps(THD*)"
"binlog_log_row(TABLE*,const uchar*,const uchar*,bool (*)(THD*,TABLE*,bool,const uchar*,const uchar*))" -> "check_table_binlog_row_based(THD*,TABLE*)"
"write_locked_table_maps(THD*)" -> "handler::has_transactions()"
"write_locked_table_maps(THD*)" -> "THD::get_binlog_table_maps() const"
"write_locked_table_maps(THD*)" -> "THD::binlog_write_table_map(TABLE*,bool,bool)"
"write_locked_table_maps(THD*)" -> "check_table_binlog_row_based(THD*,TABLE*)"
"write_locked_table_maps(THD*)" -> "__builtin_expect(long int,long int)"
"THD::binlog_write_table_map(TABLE*,bool,bool)" -> "binlog_start_trans_and_stmt(THD*,Log_event*)"
"THD::binlog_write_table_map(TABLE*,bool,bool)" -> "binlog_cache_data::write_event(THD*,Log_event*)"
"THD::binlog_write_table_map(TABLE*,bool,bool)" -> "Rows_query_log_event::Rows_query_log_event(THD*,const char*,ulong)"
"THD::binlog_write_table_map(TABLE*,bool,bool)" -> "thd_get_cache_mngr(const THD*)"
"THD::binlog_write_table_map(TABLE*,bool,bool)" -> "Statement::query() const"
"THD::binlog_write_table_map(TABLE*,bool,bool)" -> "Statement::query_length() const"
"THD::binlog_write_table_map(TABLE*,bool,bool)" -> "Table_map_log_event::Table_map_log_event(THD*,TABLE*,const Table_id&,bool)"
"THD::binlog_write_table_map(TABLE*,bool,bool)" -> "binlog_cache_mngr::get_binlog_cache_data(bool)"
"Rows_query_log_event::Rows_query_log_event(THD*,const char*,ulong)" -> "Ignorable_log_event::Ignorable_log_event(THD*)"
"Rows_query_log_event::Rows_query_log_event(THD*,const char*,ulong)" -> "my_snprintf(char*,size_t,const char*,...)"
"Rows_query_log_event::Rows_query_log_event(THD*,const char*,ulong)" -> "my_malloc(size_t,myf)"
"Ignorable_log_event::Ignorable_log_event(THD*)" -> "Log_event::Log_event(THD*,uint16,Log_event::enum_event_cache_type,Log_event::enum_event_logging_type)"
"Table_map_log_event::Table_map_log_event(THD*,TABLE*,const Table_id&,bool)" -> "memset(void*,int,size_t)"
"Table_map_log_event::Table_map_log_event(THD*,TABLE*,const Table_id&,bool)" -> "Table_map_log_event::save_field_metadata()"
"Table_map_log_event::Table_map_log_event(THD*,TABLE*,const Table_id&,bool)" -> "net_store_length(uchar*,ulonglong)"
"Table_map_log_event::Table_map_log_event(THD*,TABLE*,const Table_id&,bool)" -> "List<T>::head() [with T = char]"
"Table_map_log_event::Table_map_log_event(THD*,TABLE*,const Table_id&,bool)" -> "my_malloc(size_t,myf)"
"Table_map_log_event::Table_map_log_event(THD*,TABLE*,const Table_id&,bool)" -> "Log_event::Log_event(THD*,uint16,Log_event::enum_event_cache_type,Log_event::enum_event_logging_type)"
"Table_map_log_event::Table_map_log_event(THD*,TABLE*,const Table_id&,bool)" -> "my_multi_malloc(myf,...)"
"Table_map_log_event::Table_map_log_event(THD*,TABLE*,const Table_id&,bool)" -> "Field::maybe_null() const"
"Table_map_log_event::Table_map_log_event(THD*,TABLE*,const Table_id&,bool)" -> "THD::get_binlog_accessed_db_names()"
"List<T>::head() [with T = char]" -> "base_list::head()"
"check_table_binlog_row_based(THD*,TABLE*)" -> "MYSQL_LOG::is_open()"
"check_table_binlog_row_based(THD*,TABLE*)" -> "Rpl_filter::db_ok(const char*)"
"check_table_binlog_row_based(THD*,TABLE*)" -> "THD::is_current_stmt_binlog_format_row() const"
"TRACE_FUNCTION_END()" -> "TraceTool::add_record(int,long int)"
"TRACE_FUNCTION_END()" -> "TraceTool::difftime(timespec,timespec)"
"TRACE_FUNCTION_END()" -> "TraceTool::get_instance()"
"TRACE_FUNCTION_END()" -> "clock_gettime(clockid_t,timespec*)"
"TraceTool::add_record(int,long int)" -> "_Alloc>::operator[](std::vector<_Tp,_Alloc>::size_type) [with _Tp = long int,_Alloc = std::allocator<long int>,std::vector<_Tp,_Alloc>::reference = long int&,std::vector<_Tp,_Alloc>::size_type = long unsigned int]"
"TraceTool::add_record(int,long int)" -> "_Alloc>::operator[](std::vector<_Tp,_Alloc>::size_type) [with _Tp = std::vector<long int>,_Alloc = std::allocator<std::vector<long int> >,std::vector<_Tp,_Alloc>::reference = std::vector<long int>&,std::vector<_Tp,_Alloc>::size_type = long unsigned int]"
"mysql_sql_stmt_close(THD*)" -> "my_ok(THD*,ulonglong,ulonglong,const char*)"
"mysql_sql_stmt_close(THD*)" -> "Statement_map::find_by_name(LEX_STRING*)"
"mysql_sql_stmt_close(THD*)" -> "Prepared_statement::deallocate()"
"mysql_sql_stmt_close(THD*)" -> "Prepared_statement::is_in_use()"
"mysql_sql_stmt_close(THD*)" -> "my_error(int,myf,...)"
"Statement_map::find_by_name(LEX_STRING*)" -> "my_hash_search(const HASH*,const uchar*,size_t)"
"append_file_to_dir(THD*,const char**,const char*)" -> "Query_arena::alloc(size_t)"
"append_file_to_dir(THD*,const char**,const char*)" -> "strxmov(char*,const char*,...)"
"append_file_to_dir(THD*,const char**,const char*)" -> "__builtin_strcpy(char*,const char*)"
"append_file_to_dir(THD*,const char**,const char*)" -> "strlen(const char*)"
"append_file_to_dir(THD*,const char**,const char*)" -> "my_error(int,myf,...)"
"append_file_to_dir(THD*,const char**,const char*)" -> "convert_dirname(char*,const char*,const char*)"
"append_file_to_dir(THD*,const char**,const char*)" -> "test_if_hard_path(const char*)"
"List<T>::head() [with T = Item]" -> "base_list::head()"
"write_bin_log(THD*,bool,const char*,ulong,bool)" -> "query_error_code(THD*,bool)"
"write_bin_log(THD*,bool,const char*,ulong,bool)" -> "THD::binlog_query(THD::enum_binlog_query_type,const char*,ulong,bool,bool,bool,int)"
"write_bin_log(THD*,bool,const char*,ulong,bool)" -> "THD::clear_error()"
"write_bin_log(THD*,bool,const char*,ulong,bool)" -> "MYSQL_LOG::is_open()"
"mysql_load(THD*,sql_exchange*,TABLE_LIST*,List<Item>&,List<Item>&,List<Item>&,enum_duplicates,bool,bool)" -> "String::is_ascii() const"
"mysql_load(THD*,sql_exchange*,TABLE_LIST*,List<Item>&,List<Item>&,List<Item>&,enum_duplicates,bool,bool)" -> "TABLE_LIST::prepare_check_option(THD*)"
"mysql_load(THD*,sql_exchange*,TABLE_LIST*,List<Item>&,List<Item>&,List<Item>&,enum_duplicates,bool,bool)" -> "my_stat(const char*,stat*,myf)"
"mysql_load(THD*,sql_exchange*,TABLE_LIST*,List<Item>&,List<Item>&,List<Item>&,enum_duplicates,bool,bool)" -> "handler::ha_start_bulk_insert(ha_rows)"
"mysql_load(THD*,sql_exchange*,TABLE_LIST*,List<Item>&,List<Item>&,List<Item>&,enum_duplicates,bool,bool)" -> "Item_field::Item_field(Field*)"
"mysql_load(THD*,sql_exchange*,TABLE_LIST*,List<Item>&,List<Item>&,List<Item>&,enum_duplicates,bool,bool)" -> "is_secure_file_path(char*)"
"mysql_load(THD*,sql_exchange*,TABLE_LIST*,List<Item>&,List<Item>&,List<Item>&,enum_duplicates,bool,bool)" -> "THD::get_stmt_da()"
"mysql_load(THD*,sql_exchange*,TABLE_LIST*,List<Item>&,List<Item>&,List<Item>&,enum_duplicates,bool,bool)" -> "Table_triggers_list::has_delete_triggers()"
"mysql_load(THD*,sql_exchange*,TABLE_LIST*,List<Item>&,List<Item>&,List<Item>&,enum_duplicates,bool,bool)" -> "free_blobs(TABLE*)"
"mysql_load(THD*,sql_exchange*,TABLE_LIST*,List<Item>&,List<Item>&,List<Item>&,enum_duplicates,bool,bool)" -> "my_message(uint,const char*,myf)"
"mysql_load(THD*,sql_exchange*,TABLE_LIST*,List<Item>&,List<Item>&,List<Item>&,enum_duplicates,bool,bool)" -> "setup_fields(THD*,Ref_ptr_array,List<Item>&,enum_mark_columns,List<Item>*,bool)"
"mysql_load(THD*,sql_exchange*,TABLE_LIST*,List<Item>&,List<Item>&,List<Item>&,enum_duplicates,bool,bool)" -> "inline_mysql_file_open(const char*,int,myf)"
"mysql_load(THD*,sql_exchange*,TABLE_LIST*,List<Item>&,List<Item>&,List<Item>&,enum_duplicates,bool,bool)" -> "fn_format(char*,const char*,const char*,const char*,uint)"
"mysql_load(THD*,sql_exchange*,TABLE_LIST*,List<Item>&,List<Item>&,List<Item>&,enum_duplicates,bool,bool)" -> "List<T>::push_back(T*) [with T = Item]"
"mysql_load(THD*,sql_exchange*,TABLE_LIST*,List<Item>&,List<Item>&,List<Item>&,enum_duplicates,bool,bool)" -> "READ_INFO::next_line()"
"mysql_load(THD*,sql_exchange*,TABLE_LIST*,List<Item>&,List<Item>&,List<Item>&,enum_duplicates,bool,bool)" -> "Diagnostics_area::current_statement_warn_count() const"
"mysql_load(THD*,sql_exchange*,TABLE_LIST*,List<Item>&,List<Item>&,List<Item>&,enum_duplicates,bool,bool)" -> "memset(void*,int,size_t)"
"mysql_load(THD*,sql_exchange*,TABLE_LIST*,List<Item>&,List<Item>&,List<Item>&,enum_duplicates,bool,bool)" -> "my_ok(THD*,ulonglong,ulonglong,const char*)"
"mysql_load(THD*,sql_exchange*,TABLE_LIST*,List<Item>&,List<Item>&,List<Item>&,enum_duplicates,bool,bool)" -> "my_snprintf(char*,size_t,const char*,...)"
"mysql_load(THD*,sql_exchange*,TABLE_LIST*,List<Item>&,List<Item>&,List<Item>&,enum_duplicates,bool,bool)" -> "List_iterator_fast<T>::operator++(int) [with T = Item]"
"mysql_load(THD*,sql_exchange*,TABLE_LIST*,List<Item>&,List<Item>&,List<Item>&,enum_duplicates,bool,bool)" -> "TABLE_LIST::prepare_where(THD*,Item**,bool)"
"mysql_load(THD*,sql_exchange*,TABLE_LIST*,List<Item>&,List<Item>&,List<Item>&,enum_duplicates,bool,bool)" -> "THD::is_strict_mode() const"
"mysql_load(THD*,sql_exchange*,TABLE_LIST*,List<Item>&,List<Item>&,List<Item>&,enum_duplicates,bool,bool)" -> "read_sep_field(THD*,COPY_INFO&,TABLE_LIST*,List<Item>&,List<Item>&,List<Item>&,READ_INFO&,const String&,ulong,bool)"
"mysql_load(THD*,sql_exchange*,TABLE_LIST*,List<Item>&,List<Item>&,List<Item>&,enum_duplicates,bool,bool)" -> "setup_tables_and_check_access(THD*,Name_resolution_context*,List<TABLE_LIST>*,TABLE_LIST*,TABLE_LIST**,bool,ulong,ulong)"
"mysql_load(THD*,sql_exchange*,TABLE_LIST*,List<Item>&,List<Item>&,List<Item>&,enum_duplicates,bool,bool)" -> "check_key_in_view(THD*,TABLE_LIST*)"
"mysql_load(THD*,sql_exchange*,TABLE_LIST*,List<Item>&,List<Item>&,List<Item>&,enum_duplicates,bool,bool)" -> "prepare_triggers_for_insert_stmt(TABLE*)"
"mysql_load(THD*,sql_exchange*,TABLE_LIST*,List<Item>&,List<Item>&,List<Item>&,enum_duplicates,bool,bool)" -> "Query_cache::invalidate(THD*,TABLE_LIST*,my_bool)"
"mysql_load(THD*,sql_exchange*,TABLE_LIST*,List<Item>&,List<Item>&,List<Item>&,enum_duplicates,bool,bool)" -> "open_and_lock_tables(THD*,TABLE_LIST*,bool,uint)"
"mysql_load(THD*,sql_exchange*,TABLE_LIST*,List<Item>&,List<Item>&,List<Item>&,enum_duplicates,bool,bool)" -> "READ_INFO::skip_data_till_eof()"
"mysql_load(THD*,sql_exchange*,TABLE_LIST*,List<Item>&,List<Item>&,List<Item>&,enum_duplicates,bool,bool)" -> "read_xml_field(THD*,COPY_INFO&,TABLE_LIST*,List<Item>&,List<Item>&,List<Item>&,READ_INFO&,ulong,bool)"
"mysql_load(THD*,sql_exchange*,TABLE_LIST*,List<Item>&,List<Item>&,List<Item>&,enum_duplicates,bool,bool)" -> "handler::ha_end_bulk_insert()"
"mysql_load(THD*,sql_exchange*,TABLE_LIST*,List<Item>&,List<Item>&,List<Item>&,enum_duplicates,bool,bool)" -> "THD::set_current_stmt_binlog_format_row_if_mixed()"
"mysql_load(THD*,sql_exchange*,TABLE_LIST*,List<Item>&,List<Item>&,List<Item>&,enum_duplicates,bool,bool)" -> "read_fixed_length(THD*,COPY_INFO&,TABLE_LIST*,List<Item>&,List<Item>&,List<Item>&,READ_INFO&,ulong,bool)"
"mysql_load(THD*,sql_exchange*,TABLE_LIST*,List<Item>&,List<Item>&,List<Item>&,enum_duplicates,bool,bool)" -> "handler::has_transactions()"
"mysql_load(THD*,sql_exchange*,TABLE_LIST*,List<Item>&,List<Item>&,List<Item>&,enum_duplicates,bool,bool)" -> "READ_INFO::READ_INFO(File,uint,const CHARSET_INFO*,const String&,const String&,const String&,const String&,int,bool,bool)"
"mysql_load(THD*,sql_exchange*,TABLE_LIST*,List<Item>&,List<Item>&,List<Item>&,enum_duplicates,bool,bool)" -> "String::operator[](uint32) const"
"mysql_load(THD*,sql_exchange*,TABLE_LIST*,List<Item>&,List<Item>&,List<Item>&,enum_duplicates,bool,bool)" -> "inline_mysql_file_close(File,myf)"
"mysql_load(THD*,sql_exchange*,TABLE_LIST*,List<Item>&,List<Item>&,List<Item>&,enum_duplicates,bool,bool)" -> "check_that_all_fields_are_given_values(THD*,TABLE*,TABLE_LIST*)"
"mysql_load(THD*,sql_exchange*,TABLE_LIST*,List<Item>&,List<Item>&,List<Item>&,enum_duplicates,bool,bool)" -> "handler::ha_release_auto_increment()"
"mysql_load(THD*,sql_exchange*,TABLE_LIST*,List<Item>&,List<Item>&,List<Item>&,enum_duplicates,bool,bool)" -> "sql_exchange::escaped_given()"
"mysql_load(THD*,sql_exchange*,TABLE_LIST*,List<Item>&,List<Item>&,List<Item>&,enum_duplicates,bool,bool)" -> "unique_table(THD*,TABLE_LIST*,TABLE_LIST*,bool)"
"mysql_load(THD*,sql_exchange*,TABLE_LIST*,List<Item>&,List<Item>&,List<Item>&,enum_duplicates,bool,bool)" -> "my_error(int,myf,...)"
"mysql_load(THD*,sql_exchange*,TABLE_LIST*,List<Item>&,List<Item>&,List<Item>&,enum_duplicates,bool,bool)" -> "dirname_length(const char*)"
"mysql_load(THD*,sql_exchange*,TABLE_LIST*,List<Item>&,List<Item>&,List<Item>&,enum_duplicates,bool,bool)" -> "String::length() const"
"mysql_load(THD*,sql_exchange*,TABLE_LIST*,List<Item>&,List<Item>&,List<Item>&,enum_duplicates,bool,bool)" -> "_current_thd()"
"mysql_load(THD*,sql_exchange*,TABLE_LIST*,List<Item>&,List<Item>&,List<Item>&,enum_duplicates,bool,bool)" -> "COPY_INFO::add_function_default_columns(TABLE*,MY_BITMAP*)"
"mysql_load(THD*,sql_exchange*,TABLE_LIST*,List<Item>&,List<Item>&,List<Item>&,enum_duplicates,bool,bool)" -> "COPY_INFO::COPY_INFO(COPY_INFO::operation_type,List<Item>*,List<Item>*,bool,enum_duplicates,bool,int)"
"mysql_load(THD*,sql_exchange*,TABLE_LIST*,List<Item>&,List<Item>&,List<Item>&,enum_duplicates,bool,bool)" -> "Bounds_checked_array<Element_type>::Bounds_checked_array() [with Element_type = Item*]"
"mysql_load(THD*,sql_exchange*,TABLE_LIST*,List<Item>&,List<Item>&,List<Item>&,enum_duplicates,bool,bool)" -> "strxnmov(char*,size_t,const char*,...)"
"mysql_load(THD*,sql_exchange*,TABLE_LIST*,List<Item>&,List<Item>&,List<Item>&,enum_duplicates,bool,bool)" -> "_my_thread_var()"
"mysql_load(THD*,sql_exchange*,TABLE_LIST*,List<Item>&,List<Item>&,List<Item>&,enum_duplicates,bool,bool)" -> "List_iterator_fast<T>::List_iterator_fast(List<T>&) [with T = Item]"
"mysql_load(THD*,sql_exchange*,TABLE_LIST*,List<Item>&,List<Item>&,List<Item>&,enum_duplicates,bool,bool)" -> "push_warning(THD*,Sql_condition::enum_warning_level,uint,const char*)"
"String::is_ascii() const" -> "String::length() const"
"String::is_ascii() const" -> "String::charset() const"
"String::is_ascii() const" -> "String::ptr() const"
"is_secure_file_path(char*)" -> "dirname_length(const char*)"
"is_secure_file_path(char*)" -> "my_realpath(char*,const char*,myf)"
"is_secure_file_path(char*)" -> "strlen(const char*)"
"is_secure_file_path(char*)" -> "strncmp(const char*,const char*,size_t)"
"is_secure_file_path(char*)" -> "memcpy(void*,const void*,size_t)"
"is_secure_file_path(char*)" -> "convert_dirname(char*,const char*,const char*)"
"READ_INFO::next_line()" -> "READ_INFO::terminator(const uchar*,uint)"
"READ_INFO::next_line()" -> "_my_b_get(IO_CACHE*)"
"READ_INFO::terminator(const uchar*,uint)" -> "_my_b_get(IO_CACHE*)"
"read_sep_field(THD*,COPY_INFO&,TABLE_LIST*,List<Item>&,List<Item>&,List<Item>&,READ_INFO&,const String&,ulong,bool)" -> "Item_user_var_as_out_param::set_value(const char*,uint,const CHARSET_INFO*)"
"read_sep_field(THD*,COPY_INFO&,TABLE_LIST*,List<Item>&,List<Item>&,List<Item>&,READ_INFO&,const String&,ulong,bool)" -> "_current_thd()"
"read_sep_field(THD*,COPY_INFO&,TABLE_LIST*,List<Item>&,List<Item>&,List<Item>&,READ_INFO&,const String&,ulong,bool)" -> "validate_default_values_of_unset_fields(THD*,TABLE*)"
"read_sep_field(THD*,COPY_INFO&,TABLE_LIST*,List<Item>&,List<Item>&,List<Item>&,READ_INFO&,const String&,ulong,bool)" -> "String::length() const"
"read_sep_field(THD*,COPY_INFO&,TABLE_LIST*,List<Item>&,List<Item>&,List<Item>&,READ_INFO&,const String&,ulong,bool)" -> "List_iterator_fast<T>::rewind() [with T = Item]"
"read_sep_field(THD*,COPY_INFO&,TABLE_LIST*,List<Item>&,List<Item>&,List<Item>&,READ_INFO&,const String&,ulong,bool)" -> "Diagnostics_area::current_row_for_warning() const"
"read_sep_field(THD*,COPY_INFO&,TABLE_LIST*,List<Item>&,List<Item>&,List<Item>&,READ_INFO&,const String&,ulong,bool)" -> "List_iterator_fast<T>::List_iterator_fast(List<T>&) [with T = Item]"
"read_sep_field(THD*,COPY_INFO&,TABLE_LIST*,List<Item>&,List<Item>&,List<Item>&,READ_INFO&,const String&,ulong,bool)" -> "push_warning_printf(THD*,Sql_condition::enum_warning_level,uint,const char*,...)"
"read_sep_field(THD*,COPY_INFO&,TABLE_LIST*,List<Item>&,List<Item>&,List<Item>&,READ_INFO&,const String&,ulong,bool)" -> "my_error(int,myf,...)"
"read_sep_field(THD*,COPY_INFO&,TABLE_LIST*,List<Item>&,List<Item>&,List<Item>&,READ_INFO&,const String&,ulong,bool)" -> "List<T>::head() [with T = Item]"
"read_sep_field(THD*,COPY_INFO&,TABLE_LIST*,List<Item>&,List<Item>&,List<Item>&,READ_INFO&,const String&,ulong,bool)" -> "Item_user_var_as_out_param::set_null_value(const CHARSET_INFO*)"
"read_sep_field(THD*,COPY_INFO&,TABLE_LIST*,List<Item>&,List<Item>&,List<Item>&,READ_INFO&,const String&,ulong,bool)" -> "Diagnostics_area::inc_current_row_for_warning()"
"read_sep_field(THD*,COPY_INFO&,TABLE_LIST*,List<Item>&,List<Item>&,List<Item>&,READ_INFO&,const String&,ulong,bool)" -> "fill_record_n_invoke_before_triggers(THD*,List<Item>&,List<Item>&,bool,Table_triggers_list*,trg_event_type)"
"read_sep_field(THD*,COPY_INFO&,TABLE_LIST*,List<Item>&,List<Item>&,List<Item>&,READ_INFO&,const String&,ulong,bool)" -> "READ_INFO::read_field()"
"read_sep_field(THD*,COPY_INFO&,TABLE_LIST*,List<Item>&,List<Item>&,List<Item>&,READ_INFO&,const String&,ulong,bool)" -> "THD::get_stmt_da()"
"read_sep_field(THD*,COPY_INFO&,TABLE_LIST*,List<Item>&,List<Item>&,List<Item>&,READ_INFO&,const String&,ulong,bool)" -> "write_record(THD*,TABLE*,COPY_INFO*,COPY_INFO*)"
"read_sep_field(THD*,COPY_INFO&,TABLE_LIST*,List<Item>&,List<Item>&,List<Item>&,READ_INFO&,const String&,ulong,bool)" -> "TABLE_LIST::view_check_option(THD*,bool) const"
"read_sep_field(THD*,COPY_INFO&,TABLE_LIST*,List<Item>&,List<Item>&,List<Item>&,READ_INFO&,const String&,ulong,bool)" -> "READ_INFO::next_line()"
"read_sep_field(THD*,COPY_INFO&,TABLE_LIST*,List<Item>&,List<Item>&,List<Item>&,READ_INFO&,const String&,ulong,bool)" -> "List_iterator_fast<T>::operator++(int) [with T = Item]"
"read_sep_field(THD*,COPY_INFO&,TABLE_LIST*,List<Item>&,List<Item>&,List<Item>&,READ_INFO&,const String&,ulong,bool)" -> "Field::set_warning(Sql_condition::enum_warning_level,unsigned int,int) const"
"read_sep_field(THD*,COPY_INFO&,TABLE_LIST*,List<Item>&,List<Item>&,List<Item>&,READ_INFO&,const String&,ulong,bool)" -> "Field::set_null(my_ptrdiff_t)"
"read_sep_field(THD*,COPY_INFO&,TABLE_LIST*,List<Item>&,List<Item>&,List<Item>&,READ_INFO&,const String&,ulong,bool)" -> "Item_func_now_local::store_in(Field*)"
"read_sep_field(THD*,COPY_INFO&,TABLE_LIST*,List<Item>&,List<Item>&,List<Item>&,READ_INFO&,const String&,ulong,bool)" -> "Field::set_notnull(my_ptrdiff_t)"
"read_sep_field(THD*,COPY_INFO&,TABLE_LIST*,List<Item>&,List<Item>&,List<Item>&,READ_INFO&,const String&,ulong,bool)" -> "memcpy(void*,const void*,size_t)"
"read_sep_field(THD*,COPY_INFO&,TABLE_LIST*,List<Item>&,List<Item>&,List<Item>&,READ_INFO&,const String&,ulong,bool)" -> "THD::is_error() const"
"read_sep_field(THD*,COPY_INFO&,TABLE_LIST*,List<Item>&,List<Item>&,List<Item>&,READ_INFO&,const String&,ulong,bool)" -> "memcmp(const void*,const void*,size_t)"
"read_sep_field(THD*,COPY_INFO&,TABLE_LIST*,List<Item>&,List<Item>&,List<Item>&,READ_INFO&,const String&,ulong,bool)" -> "Field::maybe_null() const"
"read_sep_field(THD*,COPY_INFO&,TABLE_LIST*,List<Item>&,List<Item>&,List<Item>&,READ_INFO&,const String&,ulong,bool)" -> "THD::send_kill_message() const"
"Item_user_var_as_out_param::set_value(const char*,uint,const CHARSET_INFO*)" -> "user_var_entry::store(void*,uint,Item_result,const CHARSET_INFO*,Derivation,bool)"
"user_var_entry::store(void*,uint,Item_result,const CHARSET_INFO*,Derivation,bool)" -> "user_var_entry::store(void*,uint,Item_result)"
"user_var_entry::store(void*,uint,Item_result,const CHARSET_INFO*,Derivation,bool)" -> "DTCollation::set(const CHARSET_INFO*,Derivation)"
"user_var_entry::store(void*,uint,Item_result)" -> "memmove(void*,const void*,size_t)"
"user_var_entry::store(void*,uint,Item_result)" -> "user_var_entry::realloc(uint)"
"user_var_entry::store(void*,uint,Item_result)" -> "my_decimal::fix_buffer_pointer()"
"user_var_entry::realloc(uint)" -> "user_var_entry::internal_buffer_ptr() const"
"user_var_entry::realloc(uint)" -> "my_realloc(void*,size_t,myf)"
"user_var_entry::realloc(uint)" -> "user_var_entry::free_value()"
"user_var_entry::free_value()" -> "user_var_entry::alloced()"
"user_var_entry::free_value()" -> "my_free(void*)"
"user_var_entry::alloced()" -> "user_var_entry::internal_buffer_ptr() const"
"validate_default_values_of_unset_fields(THD*,TABLE*)" -> "bitmap_is_set(const MY_BITMAP*,uint)"
"validate_default_values_of_unset_fields(THD*,TABLE*)" -> "THD::is_error() const"
"List_iterator_fast<T>::rewind() [with T = Item]" -> "base_list_iterator::rewind()"
"Item_user_var_as_out_param::set_null_value(const CHARSET_INFO*)" -> "user_var_entry::set_null_value(Item_result)"
"user_var_entry::set_null_value(Item_result)" -> "user_var_entry::set_type(Item_result)"
"user_var_entry::set_null_value(Item_result)" -> "user_var_entry::free_value()"
"user_var_entry::set_null_value(Item_result)" -> "user_var_entry::reset_value()"
"Diagnostics_area::inc_current_row_for_warning()" -> "Diagnostics_area::get_warning_info()"
"Diagnostics_area::inc_current_row_for_warning()" -> "Warning_info::inc_current_row_for_warning()"
"fill_record_n_invoke_before_triggers(THD*,List<Item>&,List<Item>&,bool,Table_triggers_list*,trg_event_type)" -> "fill_record(THD*,List<Item>&,List<Item>&,bool,MY_BITMAP*)"
"fill_record_n_invoke_before_triggers(THD*,List<Item>&,List<Item>&,bool,Table_triggers_list*,trg_event_type)" -> "Table_triggers_list::process_triggers(THD*,trg_event_type,trg_action_time_type,bool)"
"fill_record(THD*,List<Item>&,List<Item>&,bool,MY_BITMAP*)" -> "bitmap_is_set(const MY_BITMAP*,uint)"
"fill_record(THD*,List<Item>&,List<Item>&,bool,MY_BITMAP*)" -> "THD::is_error() const"
"fill_record(THD*,List<Item>&,List<Item>&,bool,MY_BITMAP*)" -> "my_error(int,myf,...)"
"fill_record(THD*,List<Item>&,List<Item>&,bool,MY_BITMAP*)" -> "Simple_cstring::ptr() const"
"fill_record(THD*,List<Item>&,List<Item>&,bool,MY_BITMAP*)" -> "List_iterator_fast<T>::List_iterator_fast(List<T>&) [with T = Item]"
"fill_record(THD*,List<Item>&,List<Item>&,bool,MY_BITMAP*)" -> "_current_thd()"
"fill_record(THD*,List<Item>&,List<Item>&,bool,MY_BITMAP*)" -> "List_iterator_fast<T>::operator++(int) [with T = Item]"
"fill_record(THD*,List<Item>&,List<Item>&,bool,MY_BITMAP*)" -> "List_iterator_fast<T>::rewind() [with T = Item]"
"fill_record(THD*,List<Item>&,List<Item>&,bool,MY_BITMAP*)" -> "my_message(uint,const char*,myf)"
"Table_triggers_list::process_triggers(THD*,trg_event_type,trg_action_time_type,bool)" -> "Sub_statement_state::Sub_statement_state()"
"Table_triggers_list::process_triggers(THD*,trg_event_type,trg_action_time_type,bool)" -> "sp_head::execute_trigger(THD*,const LEX_STRING*,const LEX_STRING*,GRANT_INFO*)"
"Table_triggers_list::process_triggers(THD*,trg_event_type,trg_action_time_type,bool)" -> "THD::restore_sub_statement_state(Sub_statement_state*)"
"Table_triggers_list::process_triggers(THD*,trg_event_type,trg_action_time_type,bool)" -> "THD::reset_sub_statement_state(Sub_statement_state*,uint)"
"Table_triggers_list::process_triggers(THD*,trg_event_type,trg_action_time_type,bool)" -> "Table_triggers_list::check_for_broken_triggers()"
"Sub_statement_state::Sub_statement_state()" -> "Discrete_interval::Discrete_interval()"
"Sub_statement_state::Sub_statement_state()" -> "Discrete_intervals_list::Discrete_intervals_list()"
"sp_head::execute_trigger(THD*,const LEX_STRING*,const LEX_STRING*,GRANT_INFO*)" -> "free_root(MEM_ROOT*,myf)"
"sp_head::execute_trigger(THD*,const LEX_STRING*,const LEX_STRING*,GRANT_INFO*)" -> "THD::send_kill_message() const"
"sp_head::execute_trigger(THD*,const LEX_STRING*,const LEX_STRING*,GRANT_INFO*)" -> "init_sql_alloc(MEM_ROOT*,uint,uint)"
"sp_head::execute_trigger(THD*,const LEX_STRING*,const LEX_STRING*,GRANT_INFO*)" -> "sp_rcontext::create(THD*,const sp_pcontext*,Field*)"
"sp_head::execute_trigger(THD*,const LEX_STRING*,const LEX_STRING*,GRANT_INFO*)" -> "THD::set_n_backup_active_arena(Query_arena*,Query_arena*)"
"sp_head::execute_trigger(THD*,const LEX_STRING*,const LEX_STRING*,GRANT_INFO*)" -> "Query_arena::Query_arena()"
"sp_head::execute_trigger(THD*,const LEX_STRING*,const LEX_STRING*,GRANT_INFO*)" -> "Query_arena::free_items()"
"sp_head::execute_trigger(THD*,const LEX_STRING*,const LEX_STRING*,GRANT_INFO*)" -> "THD::restore_active_arena(Query_arena*,Query_arena*)"
"sp_head::execute_trigger(THD*,const LEX_STRING*,const LEX_STRING*,GRANT_INFO*)" -> "Query_arena::Query_arena(MEM_ROOT*,Query_arena::enum_state)"
"sp_head::execute_trigger(THD*,const LEX_STRING*,const LEX_STRING*,GRANT_INFO*)" -> "sp_head::execute(THD*,bool)"
"sp_rcontext::create(THD*,const sp_pcontext*,Field*)" -> "sp_rcontext::sp_rcontext(const sp_pcontext*,Field*,bool)"
"sp_rcontext::create(THD*,const sp_pcontext*,Field*)" -> "sp_rcontext::init_var_table(THD*)"
"sp_rcontext::create(THD*,const sp_pcontext*,Field*)" -> "sp_rcontext::alloc_arrays(THD*)"
"sp_rcontext::create(THD*,const sp_pcontext*,Field*)" -> "sp_rcontext::init_var_items(THD*)"
"sp_rcontext::sp_rcontext(const sp_pcontext*,Field*,bool)" -> "Sql_alloc::Sql_alloc()"
"sp_rcontext::sp_rcontext(const sp_pcontext*,Field*,bool)" -> "Bounds_checked_array<Element_type>::Bounds_checked_array() [with Element_type = Item_cache*]"
"sp_rcontext::sp_rcontext(const sp_pcontext*,Field*,bool)" -> "Bounds_checked_array<Element_type>::Bounds_checked_array() [with Element_type = sp_cursor*]"
"sp_rcontext::sp_rcontext(const sp_pcontext*,Field*,bool)" -> "Dynamic_array<Elem>::Dynamic_array(uint,uint) [with Elem = sp_rcontext::Handler_call_frame*,uint = unsigned int]"
"sp_rcontext::sp_rcontext(const sp_pcontext*,Field*,bool)" -> "Dynamic_array<Elem>::Dynamic_array(uint,uint) [with Elem = sp_rcontext::sp_handler_entry*,uint = unsigned int]"
"sp_rcontext::sp_rcontext(const sp_pcontext*,Field*,bool)" -> "Bounds_checked_array<Element_type>::Bounds_checked_array() [with Element_type = Item*]"
"Dynamic_array<Elem>::Dynamic_array(uint,uint) [with Elem = sp_rcontext::Handler_call_frame*,uint = unsigned int]" -> "Dynamic_array<Elem>::init(uint,uint) [with Elem = sp_rcontext::Handler_call_frame*,uint = unsigned int]"
"Dynamic_array<Elem>::init(uint,uint) [with Elem = sp_rcontext::Handler_call_frame*,uint = unsigned int]" -> "init_dynamic_array2(DYNAMIC_ARRAY*,uint,void*,uint,uint)"
"Dynamic_array<Elem>::Dynamic_array(uint,uint) [with Elem = sp_rcontext::sp_handler_entry*,uint = unsigned int]" -> "Dynamic_array<Elem>::init(uint,uint) [with Elem = sp_rcontext::sp_handler_entry*,uint = unsigned int]"
"Dynamic_array<Elem>::init(uint,uint) [with Elem = sp_rcontext::sp_handler_entry*,uint = unsigned int]" -> "init_dynamic_array2(DYNAMIC_ARRAY*,uint,void*,uint,uint)"
"sp_rcontext::init_var_table(THD*)" -> "sp_pcontext::retrieve_field_definitions(List<Create_field>*) const"
"sp_rcontext::init_var_table(THD*)" -> "sp_pcontext::max_var_index() const"
"sp_rcontext::init_var_table(THD*)" -> "List<T>::List() [with T = Create_field]"
"sp_rcontext::init_var_table(THD*)" -> "create_virtual_tmp_table(THD*,List<Create_field>&,MEM_ROOT*)"
"sp_pcontext::retrieve_field_definitions(List<Create_field>*) const" -> "Dynamic_array<Elem>::elements() const [with Elem = sp_pcontext*]"
"sp_pcontext::retrieve_field_definitions(List<Create_field>*) const" -> "Dynamic_array<Elem>::elements() const [with Elem = sp_variable*]"
"sp_pcontext::retrieve_field_definitions(List<Create_field>*) const" -> "sp_pcontext::retrieve_field_definitions(List<Create_field>*) const"
"sp_pcontext::retrieve_field_definitions(List<Create_field>*) const" -> "Dynamic_array<Elem>::at(int) const [with Elem = sp_variable*]"
"sp_pcontext::retrieve_field_definitions(List<Create_field>*) const" -> "List<T>::push_back(T*) [with T = Create_field]"
"sp_pcontext::retrieve_field_definitions(List<Create_field>*) const" -> "Dynamic_array<Elem>::at(int) const [with Elem = sp_pcontext*]"
"create_virtual_tmp_table(THD*,List<Create_field>&,MEM_ROOT*)" -> "setup_tmp_table_column_bitmaps(TABLE*,uchar*)"
"create_virtual_tmp_table(THD*,List<Create_field>&,MEM_ROOT*)" -> "alloc_root(MEM_ROOT*,size_t)"
"create_virtual_tmp_table(THD*,List<Create_field>&,MEM_ROOT*)" -> "memset(void*,int,size_t)"
"create_virtual_tmp_table(THD*,List<Create_field>&,MEM_ROOT*)" -> "Field::init(TABLE*)"
"create_virtual_tmp_table(THD*,List<Create_field>&,MEM_ROOT*)" -> "Field::move_field(uchar*)"
"create_virtual_tmp_table(THD*,List<Create_field>&,MEM_ROOT*)" -> "Field_bit::set_bit_ptr(uchar*,uchar)"
"create_virtual_tmp_table(THD*,List<Create_field>&,MEM_ROOT*)" -> "make_field(TABLE_SHARE*,uchar*,uint32,uchar*,uchar,uint,enum_field_types,const CHARSET_INFO*,Field::geometry_type,Field::utype,TYPELIB*,const char*,MEM_ROOT*)"
"create_virtual_tmp_table(THD*,List<Create_field>&,MEM_ROOT*)" -> "multi_alloc_root(MEM_ROOT*,...)"
"create_virtual_tmp_table(THD*,List<Create_field>&,MEM_ROOT*)" -> "List_iterator_fast<T>::operator++(int) [with T = Create_field]"
"create_virtual_tmp_table(THD*,List<Create_field>&,MEM_ROOT*)" -> "Field::move_field(uchar*,uchar*,uchar)"
"create_virtual_tmp_table(THD*,List<Create_field>&,MEM_ROOT*)" -> "List_iterator_fast<T>::List_iterator_fast(List<T>&) [with T = Create_field]"
"List_iterator_fast<T>::operator++(int) [with T = Create_field]" -> "base_list_iterator::next_fast()"
"List_iterator_fast<T>::List_iterator_fast(List<T>&) [with T = Create_field]" -> "base_list_iterator::base_list_iterator(base_list&)"
"sp_rcontext::alloc_arrays(THD*)" -> "sp_pcontext::max_cursor_index() const"
"sp_rcontext::alloc_arrays(THD*)" -> "Bounds_checked_array<Element_type>::reset(Element_type*,size_t) [with Element_type = sp_cursor*,size_t = long unsigned int]"
"sp_rcontext::alloc_arrays(THD*)" -> "Bounds_checked_array<Element_type>::array() const [with Element_type = Item_cache*]"
"sp_rcontext::alloc_arrays(THD*)" -> "Bounds_checked_array<Element_type>::array() const [with Element_type = sp_cursor*]"
"sp_rcontext::alloc_arrays(THD*)" -> "Bounds_checked_array<Element_type>::reset(Element_type*,size_t) [with Element_type = Item_cache*,size_t = long unsigned int]"
"sp_rcontext::alloc_arrays(THD*)" -> "Query_arena::calloc(size_t)"
"sp_rcontext::alloc_arrays(THD*)" -> "sp_pcontext::get_num_case_exprs() const"
"sp_rcontext::alloc_arrays(THD*)" -> "Query_arena::alloc(size_t)"
"sp_rcontext::init_var_items(THD*)" -> "Query_arena::alloc(size_t)"
"sp_rcontext::init_var_items(THD*)" -> "Item_field::Item_field(Field*)"
"sp_rcontext::init_var_items(THD*)" -> "Bounds_checked_array<Element_type>::array() const [with Element_type = Item*]"
"sp_rcontext::init_var_items(THD*)" -> "Bounds_checked_array<Element_type>::reset(Element_type*,size_t) [with Element_type = Item*,size_t = long unsigned int]"
"sp_rcontext::init_var_items(THD*)" -> "sp_pcontext::max_var_index() const"
"sp_rcontext::init_var_items(THD*)" -> "Bounds_checked_array<Element_type>::operator[](size_t) [with Element_type = Item*,size_t = long unsigned int]"
"sp_head::execute(THD*,bool)" -> "Diagnostics_area::copy_sql_conditions_from_wi(THD*,const Warning_info*)"
"sp_head::execute(THD*,bool)" -> "sp_head::get_instr(uint)"
"sp_head::execute(THD*,bool)" -> "opt_trace_disable_if_no_security_context_access(THD*)"
"sp_head::execute(THD*,bool)" -> "mysql_opt_change_db(THD*,const LEX_STRING*,LEX_STRING*,bool,bool*)"
"sp_head::execute(THD*,bool)" -> "mysql_change_db(THD*,const LEX_STRING*,bool)"
"sp_head::execute(THD*,bool)" -> "sp_rcontext::pop_all_cursors()"
"sp_head::execute(THD*,bool)" -> "Object_creation_ctx::restore_env(THD*,Object_creation_ctx*)"
"sp_head::execute(THD*,bool)" -> "THD::get_stmt_da()"
"sp_head::execute(THD*,bool)" -> "THD::set_n_backup_active_arena(Query_arena*,Query_arena*)"
"sp_head::execute(THD*,bool)" -> "Query_arena::Query_arena()"
"sp_head::execute(THD*,bool)" -> "Diagnostics_area::copy_sql_conditions_to_wi(THD*,Warning_info*) const"
"sp_head::execute(THD*,bool)" -> "I_List<T>::move_elements_to(I_List<T>*) [with T = Item_change_record]"
"sp_head::execute(THD*,bool)" -> "PROFILING::discard_current_query()"
"sp_head::execute(THD*,bool)" -> "String::swap(String&)"
"sp_head::execute(THD*,bool)" -> "sp_rcontext::handle_sql_condition(THD*,uint*,const sp_instr*)"
"sp_head::execute(THD*,bool)" -> "check_stack_overrun(THD*,long int,uchar*)"
"sp_head::execute(THD*,bool)" -> "THD::set_query_id(query_id_t)"
"sp_head::execute(THD*,bool)" -> "Diagnostics_area::warning_info_id() const"
"sp_head::execute(THD*,bool)" -> "Warning_info::Warning_info(ulonglong,bool)"
"sp_head::execute(THD*,bool)" -> "THD::killed_errno() const"
"sp_head::execute(THD*,bool)" -> "Query_arena::Query_arena(MEM_ROOT*,Query_arena::enum_state)"
"sp_head::execute(THD*,bool)" -> "Object_creation_ctx::set_n_backup(THD*)"
"sp_head::execute(THD*,bool)" -> "Open_tables_state::pop_reprepare_observer()"
"sp_head::execute(THD*,bool)" -> "init_sql_alloc(MEM_ROOT*,uint,uint)"
"sp_head::execute(THD*,bool)" -> "PROFILING::start_new_query(const char*)"
"sp_head::execute(THD*,bool)" -> "PROFILING::finish_current_query()"
"sp_head::execute(THD*,bool)" -> "free_root(MEM_ROOT*,myf)"
"sp_head::execute(THD*,bool)" -> "Diagnostics_area::warning_info_changed(const Warning_info*) const"
"sp_head::execute(THD*,bool)" -> "String::String()"
"sp_head::execute(THD*,bool)" -> "Diagnostics_area::opt_clear_warning_info(ulonglong)"
"sp_head::execute(THD*,bool)" -> "Open_tables_state::push_reprepare_observer(Reprepare_observer*)"
"sp_head::execute(THD*,bool)" -> "Diagnostics_area::remove_marked_sql_conditions()"
"sp_head::execute(THD*,bool)" -> "Diagnostics_area::push_warning_info(Warning_info*)"
"sp_head::execute(THD*,bool)" -> "THD::cleanup_after_query()"
"sp_head::execute(THD*,bool)" -> "Diagnostics_area::reset_for_next_command()"
"sp_head::execute(THD*,bool)" -> "cleanup_items(Item*)"
"sp_head::execute(THD*,bool)" -> "Diagnostics_area::pop_warning_info()"
"sp_head::execute(THD*,bool)" -> "I_List<Item_change_record>::I_List()"
"sp_head::execute(THD*,bool)" -> "reset_start_time_for_sp(THD*)"
"sp_head::execute(THD*,bool)" -> "THD::restore_active_arena(Query_arena*,Query_arena*)"
"Diagnostics_area::copy_sql_conditions_from_wi(THD*,const Warning_info*)" -> "Diagnostics_area::get_warning_info()"
"Diagnostics_area::copy_sql_conditions_from_wi(THD*,const Warning_info*)" -> "Warning_info::append_warning_info(THD*,const Warning_info*)"
"Warning_info::append_warning_info(THD*,const Warning_info*)" -> "Warning_info::set_error_condition(const Sql_condition*)"
"Warning_info::append_warning_info(THD*,const Warning_info*)" -> "Warning_info::get_error_condition() const"
"Warning_info::append_warning_info(THD*,const Warning_info*)" -> "Warning_info::push_warning(THD*,const Sql_condition*)"
"Warning_info::append_warning_info(THD*,const Warning_info*)" -> "Warning_info::mark_condition_for_removal(Sql_condition*)"
"Warning_info::append_warning_info(THD*,const Warning_info*)" -> "L>::I_P_List_iterator(const L&) [with T = const Sql_condition,L = I_P_List<Sql_condition,I_P_List_adapter<Sql_condition,&Sql_condition::next_in_wi,&Sql_condition::prev_in_wi>,I_P_List_counter,I_P_List_fast_push_back<Sql_condition> >]"
"Warning_info::append_warning_info(THD*,const Warning_info*)" -> "L>::operator++(int) [with T = const Sql_condition,L = I_P_List<Sql_condition,I_P_List_adapter<Sql_condition,&Sql_condition::next_in_wi,&Sql_condition::prev_in_wi>,I_P_List_counter,I_P_List_fast_push_back<Sql_condition> >]"
"Warning_info::append_warning_info(THD*,const Warning_info*)" -> "Warning_info::is_marked_for_removal(const Sql_condition*) const"
"Warning_info::push_warning(THD*,const Sql_condition*)" -> "Sql_condition::get_sql_errno() const"
"Warning_info::push_warning(THD*,const Sql_condition*)" -> "Warning_info::push_warning(THD*,uint,const char*,Sql_condition::enum_warning_level,const char*)"
"Warning_info::push_warning(THD*,const Sql_condition*)" -> "Sql_condition::get_sqlstate() const"
"Warning_info::push_warning(THD*,const Sql_condition*)" -> "Sql_condition::copy_opt_attributes(const Sql_condition*)"
"Warning_info::push_warning(THD*,const Sql_condition*)" -> "Sql_condition::get_level() const"
"Warning_info::push_warning(THD*,const Sql_condition*)" -> "Sql_condition::get_message_text() const"
"Sql_condition::copy_opt_attributes(const Sql_condition*)" -> "copy_string(MEM_ROOT*,String*,const String*)"
"copy_string(MEM_ROOT*,String*,const String*)" -> "alloc_root(MEM_ROOT*,size_t)"
"copy_string(MEM_ROOT*,String*,const String*)" -> "String::charset() const"
"copy_string(MEM_ROOT*,String*,const String*)" -> "memcpy(void*,const void*,size_t)"
"copy_string(MEM_ROOT*,String*,const String*)" -> "String::set(char*,uint32,const CHARSET_INFO*)"
"copy_string(MEM_ROOT*,String*,const String*)" -> "String::length() const"
"copy_string(MEM_ROOT*,String*,const String*)" -> "String::ptr() const"
"copy_string(MEM_ROOT*,String*,const String*)" -> "String::length(uint32)"
"Sql_condition::get_message_text() const" -> "String::ptr() const"
"Warning_info::mark_condition_for_removal(Sql_condition*)" -> "List<T>::push_back(T*,MEM_ROOT*) [with T = Sql_condition,MEM_ROOT = st_mem_root]"
"List<T>::push_back(T*,MEM_ROOT*) [with T = Sql_condition,MEM_ROOT = st_mem_root]" -> "base_list::push_back(void*,MEM_ROOT*)"
"L>::operator++(int) [with T = const Sql_condition,L = I_P_List<Sql_condition,I_P_List_adapter<Sql_condition,&Sql_condition::next_in_wi,&Sql_condition::prev_in_wi>,I_P_List_counter,I_P_List_fast_push_back<Sql_condition> >]" -> "prev>::next_ptr(const T*) [with T = Sql_condition,T* T::* next = &Sql_condition::next_in_wi,T** T::* prev = &Sql_condition::prev_in_wi]"
"Warning_info::is_marked_for_removal(const Sql_condition*) const" -> "List_iterator_fast<T>::List_iterator_fast(List<T>&) [with T = Sql_condition]"
"Warning_info::is_marked_for_removal(const Sql_condition*) const" -> "List_iterator_fast<T>::operator++(int) [with T = Sql_condition]"
"List_iterator_fast<T>::List_iterator_fast(List<T>&) [with T = Sql_condition]" -> "base_list_iterator::base_list_iterator(base_list&)"
"List_iterator_fast<T>::operator++(int) [with T = Sql_condition]" -> "base_list_iterator::next_fast()"
"sp_rcontext::pop_all_cursors()" -> "sp_rcontext::pop_cursors(uint)"
"sp_rcontext::pop_cursors(uint)" -> "Bounds_checked_array<Element_type>::operator[](size_t) [with Element_type = sp_cursor*,size_t = long unsigned int]"
"Diagnostics_area::copy_sql_conditions_to_wi(THD*,Warning_info*) const" -> "Warning_info::append_warning_info(THD*,const Warning_info*)"
"Diagnostics_area::copy_sql_conditions_to_wi(THD*,Warning_info*) const" -> "Diagnostics_area::get_warning_info() const"
"I_List<T>::move_elements_to(I_List<T>*) [with T = Item_change_record]" -> "base_ilist<T>::move_elements_to(base_ilist<T>*) [with T = Item_change_record,base_ilist<T> = base_ilist<Item_change_record>]"
"base_ilist<T>::move_elements_to(base_ilist<T>*) [with T = Item_change_record,base_ilist<T> = base_ilist<Item_change_record>]" -> "base_ilist<T>::empty() [with T = Item_change_record]"
"base_ilist<T>::move_elements_to(base_ilist<T>*) [with T = Item_change_record,base_ilist<T> = base_ilist<Item_change_record>]" -> "ilink<Item_change_record>::operator=(const ilink<Item_change_record>&)"
"sp_rcontext::handle_sql_condition(THD*,uint*,const sp_instr*)" -> "Dynamic_array<Elem>::at(int) [with Elem = sp_rcontext::sp_handler_entry*]"
"sp_rcontext::handle_sql_condition(THD*,uint*,const sp_instr*)" -> "THD::clear_error()"
"sp_rcontext::handle_sql_condition(THD*,uint*,const sp_instr*)" -> "Sql_condition::get_sql_errno() const"
"sp_rcontext::handle_sql_condition(THD*,uint*,const sp_instr*)" -> "Sql_condition::get_level() const"
"sp_rcontext::handle_sql_condition(THD*,uint*,const sp_instr*)" -> "L>::operator++(int) [with T = const Sql_condition,L = I_P_List<Sql_condition,I_P_List_adapter<Sql_condition,&Sql_condition::next_in_wi,&Sql_condition::prev_in_wi>,I_P_List_counter,I_P_List_fast_push_back<Sql_condition> >]"
"sp_rcontext::handle_sql_condition(THD*,uint*,const sp_instr*)" -> "THD::get_stmt_da()"
"sp_rcontext::handle_sql_condition(THD*,uint*,const sp_instr*)" -> "Dynamic_array<Elem>::append(const Elem&) [with Elem = sp_rcontext::Handler_call_frame*]"
"sp_rcontext::handle_sql_condition(THD*,uint*,const sp_instr*)" -> "Dynamic_array<Elem>::elements() const [with Elem = sp_rcontext::sp_handler_entry*]"
"sp_rcontext::handle_sql_condition(THD*,uint*,const sp_instr*)" -> "Diagnostics_area::current_statement_warn_count() const"
"sp_rcontext::handle_sql_condition(THD*,uint*,const sp_instr*)" -> "Diagnostics_area::get_sqlstate() const"
"sp_rcontext::handle_sql_condition(THD*,uint*,const sp_instr*)" -> "THD::is_error() const"
"sp_rcontext::handle_sql_condition(THD*,uint*,const sp_instr*)" -> "Diagnostics_area::sql_errno() const"
"sp_rcontext::handle_sql_condition(THD*,uint*,const sp_instr*)" -> "Diagnostics_area::message() const"
"sp_rcontext::handle_sql_condition(THD*,uint*,const sp_instr*)" -> "sp_pcontext::find_handler(const char*,uint,Sql_condition::enum_warning_level) const"
"sp_rcontext::handle_sql_condition(THD*,uint*,const sp_instr*)" -> "Diagnostics_area::mark_sql_conditions_for_removal()"
"sp_rcontext::handle_sql_condition(THD*,uint*,const sp_instr*)" -> "sp_rcontext::Handler_call_frame::Handler_call_frame(const sp_handler*,uint,const char*,Sql_condition::enum_warning_level,const char*,uint)"
"sp_rcontext::handle_sql_condition(THD*,uint*,const sp_instr*)" -> "Diagnostics_area::get_error_condition() const"
"sp_rcontext::handle_sql_condition(THD*,uint*,const sp_instr*)" -> "Diagnostics_area::sql_conditions() const"
"sp_rcontext::handle_sql_condition(THD*,uint*,const sp_instr*)" -> "sql_alloc_error_handler()"
"sp_rcontext::handle_sql_condition(THD*,uint*,const sp_instr*)" -> "Sql_condition::get_sqlstate() const"
"sp_rcontext::handle_sql_condition(THD*,uint*,const sp_instr*)" -> "sp_instr::get_parsing_ctx() const"
"sp_rcontext::handle_sql_condition(THD*,uint*,const sp_instr*)" -> "Sql_condition::get_message_text() const"
"Dynamic_array<Elem>::append(const Elem&) [with Elem = sp_rcontext::Handler_call_frame*]" -> "insert_dynamic(DYNAMIC_ARRAY*,const void*)"
"sp_pcontext::find_handler(const char*,uint,Sql_condition::enum_warning_level) const" -> "is_sqlstate_exception(const char*)"
"sp_pcontext::find_handler(const char*,uint,Sql_condition::enum_warning_level) const" -> "is_sqlstate_not_found(const char*)"
"sp_pcontext::find_handler(const char*,uint,Sql_condition::enum_warning_level) const" -> "sp_pcontext::find_handler(const char*,uint,Sql_condition::enum_warning_level) const"
"sp_pcontext::find_handler(const char*,uint,Sql_condition::enum_warning_level) const" -> "strcmp(const char*,const char*)"
"sp_pcontext::find_handler(const char*,uint,Sql_condition::enum_warning_level) const" -> "Dynamic_array<Elem>::elements() const [with Elem = sp_handler*]"
"sp_pcontext::find_handler(const char*,uint,Sql_condition::enum_warning_level) const" -> "is_sqlstate_warning(const char*)"
"sp_pcontext::find_handler(const char*,uint,Sql_condition::enum_warning_level) const" -> "Dynamic_array<Elem>::at(int) const [with Elem = sp_handler*]"
"sp_pcontext::find_handler(const char*,uint,Sql_condition::enum_warning_level) const" -> "List_iterator_fast<T>::operator++(int) [with T = sp_condition_value]"
"sp_pcontext::find_handler(const char*,uint,Sql_condition::enum_warning_level) const" -> "List_iterator_fast<T>::List_iterator_fast(List<T>&) [with T = sp_condition_value]"
"Diagnostics_area::mark_sql_conditions_for_removal()" -> "Warning_info::mark_sql_conditions_for_removal()"
"Diagnostics_area::mark_sql_conditions_for_removal()" -> "Diagnostics_area::get_warning_info()"
"Warning_info::mark_sql_conditions_for_removal()" -> "Warning_info::mark_condition_for_removal(Sql_condition*)"
"Warning_info::mark_sql_conditions_for_removal()" -> "L>::operator++(int) [with T = Sql_condition,L = I_P_List<Sql_condition,I_P_List_adapter<Sql_condition,&Sql_condition::next_in_wi,&Sql_condition::prev_in_wi>,I_P_List_counter,I_P_List_fast_push_back<Sql_condition> >]"
"Warning_info::mark_sql_conditions_for_removal()" -> "L>::I_P_List_iterator(const L&) [with T = Sql_condition,L = I_P_List<Sql_condition,I_P_List_adapter<Sql_condition,&Sql_condition::next_in_wi,&Sql_condition::prev_in_wi>,I_P_List_counter,I_P_List_fast_push_back<Sql_condition> >]"
"L>::operator++(int) [with T = Sql_condition,L = I_P_List<Sql_condition,I_P_List_adapter<Sql_condition,&Sql_condition::next_in_wi,&Sql_condition::prev_in_wi>,I_P_List_counter,I_P_List_fast_push_back<Sql_condition> >]" -> "prev>::next_ptr(T*) [with T = Sql_condition,T* T::* next = &Sql_condition::next_in_wi,T** T::* prev = &Sql_condition::prev_in_wi]"
"sp_rcontext::Handler_call_frame::Handler_call_frame(const sp_handler*,uint,const char*,Sql_condition::enum_warning_level,const char*,uint)" -> "sp_rcontext::Sql_condition_info::Sql_condition_info(uint,const char*,Sql_condition::enum_warning_level,const char*)"
"sp_rcontext::Sql_condition_info::Sql_condition_info(uint,const char*,Sql_condition::enum_warning_level,const char*)" -> "strncpy(char*,const char*,size_t)"
"sp_rcontext::Sql_condition_info::Sql_condition_info(uint,const char*,Sql_condition::enum_warning_level,const char*)" -> "memcpy(void*,const void*,size_t)"
"Diagnostics_area::get_error_condition() const" -> "Warning_info::get_error_condition() const"
"Diagnostics_area::get_error_condition() const" -> "Diagnostics_area::get_warning_info() const"
"Diagnostics_area::sql_conditions() const" -> "Diagnostics_area::get_warning_info() const"
"Diagnostics_area::sql_conditions() const" -> "L>::I_P_List_iterator(const L&) [with T = const Sql_condition,L = I_P_List<Sql_condition,I_P_List_adapter<Sql_condition,&Sql_condition::next_in_wi,&Sql_condition::prev_in_wi>,I_P_List_counter,I_P_List_fast_push_back<Sql_condition> >]"
"sql_alloc_error_handler()" -> "_current_thd()"
"sql_alloc_error_handler()" -> "THD::is_error() const"
"sql_alloc_error_handler()" -> "Diagnostics_area::set_error_status(uint)"
"sql_alloc_error_handler()" -> "THD::get_stmt_da()"
"sql_alloc_error_handler()" -> "sql_print_error(const char*,...)"
"Diagnostics_area::warning_info_id() const" -> "Warning_info::id() const"
"Diagnostics_area::warning_info_id() const" -> "Diagnostics_area::get_warning_info() const"
"Open_tables_state::pop_reprepare_observer()" -> "Dynamic_array<Elem>::pop() [with Elem = Reprepare_observer*]"
"Dynamic_array<Elem>::pop() [with Elem = Reprepare_observer*]" -> "pop_dynamic(DYNAMIC_ARRAY*)"
"Diagnostics_area::warning_info_changed(const Warning_info*) const" -> "Diagnostics_area::get_warning_info() const"
"Diagnostics_area::warning_info_changed(const Warning_info*) const" -> "Warning_info::id() const"
"Diagnostics_area::remove_marked_sql_conditions()" -> "Diagnostics_area::get_warning_info()"
"Diagnostics_area::remove_marked_sql_conditions()" -> "Warning_info::remove_marked_sql_conditions()"
"Warning_info::remove_marked_sql_conditions()" -> "List_iterator_fast<T>::List_iterator_fast(List<T>&) [with T = Sql_condition]"
"Warning_info::remove_marked_sql_conditions()" -> "Sql_condition::get_level() const"
"Warning_info::remove_marked_sql_conditions()" -> "I>::remove(T*) [with T = Sql_condition,B = I_P_List_adapter<Sql_condition,&Sql_condition::next_in_wi,&Sql_condition::prev_in_wi>,C = I_P_List_counter,I = I_P_List_fast_push_back<Sql_condition>]"
"Warning_info::remove_marked_sql_conditions()" -> "base_list::empty()"
"Warning_info::remove_marked_sql_conditions()" -> "List_iterator_fast<T>::operator++(int) [with T = Sql_condition]"
"I>::remove(T*) [with T = Sql_condition,B = I_P_List_adapter<Sql_condition,&Sql_condition::next_in_wi,&Sql_condition::prev_in_wi>,C = I_P_List_counter,I = I_P_List_fast_push_back<Sql_condition>]" -> "prev>::prev_ptr(T*) [with T = Sql_condition,T* T::* next = &Sql_condition::next_in_wi,T** T::* prev = &Sql_condition::prev_in_wi]"
"I>::remove(T*) [with T = Sql_condition,B = I_P_List_adapter<Sql_condition,&Sql_condition::next_in_wi,&Sql_condition::prev_in_wi>,C = I_P_List_counter,I = I_P_List_fast_push_back<Sql_condition>]" -> "prev>::next_ptr(T*) [with T = Sql_condition,T* T::* next = &Sql_condition::next_in_wi,T** T::* prev = &Sql_condition::prev_in_wi]"
"I>::remove(T*) [with T = Sql_condition,B = I_P_List_adapter<Sql_condition,&Sql_condition::next_in_wi,&Sql_condition::prev_in_wi>,C = I_P_List_counter,I = I_P_List_fast_push_back<Sql_condition>]" -> "I_P_List_counter::dec()"
"I>::remove(T*) [with T = Sql_condition,B = I_P_List_adapter<Sql_condition,&Sql_condition::next_in_wi,&Sql_condition::prev_in_wi>,C = I_P_List_counter,I = I_P_List_fast_push_back<Sql_condition>]" -> "I_P_List_fast_push_back<T>::set_last(T**) [with T = Sql_condition]"
"Diagnostics_area::pop_warning_info()" -> "I>::remove(T*) [with T = Warning_info,B = I_P_List_adapter<Warning_info,&Warning_info::m_next_in_da,&Warning_info::m_prev_in_da>,C = I_P_List_counter,I = I_P_List_fast_push_back<Warning_info>]"
"Diagnostics_area::pop_warning_info()" -> "I>::front() [with T = Warning_info,B = I_P_List_adapter<Warning_info,&Warning_info::m_next_in_da,&Warning_info::m_prev_in_da>,C = I_P_List_counter,I = I_P_List_fast_push_back<Warning_info>]"
"I>::remove(T*) [with T = Warning_info,B = I_P_List_adapter<Warning_info,&Warning_info::m_next_in_da,&Warning_info::m_prev_in_da>,C = I_P_List_counter,I = I_P_List_fast_push_back<Warning_info>]" -> "prev>::next_ptr(T*) [with T = Warning_info,T* T::* next = &Warning_info::m_next_in_da,T** T::* prev = &Warning_info::m_prev_in_da]"
"I>::remove(T*) [with T = Warning_info,B = I_P_List_adapter<Warning_info,&Warning_info::m_next_in_da,&Warning_info::m_prev_in_da>,C = I_P_List_counter,I = I_P_List_fast_push_back<Warning_info>]" -> "I_P_List_counter::dec()"
"I>::remove(T*) [with T = Warning_info,B = I_P_List_adapter<Warning_info,&Warning_info::m_next_in_da,&Warning_info::m_prev_in_da>,C = I_P_List_counter,I = I_P_List_fast_push_back<Warning_info>]" -> "prev>::prev_ptr(T*) [with T = Warning_info,T* T::* next = &Warning_info::m_next_in_da,T** T::* prev = &Warning_info::m_prev_in_da]"
"I>::remove(T*) [with T = Warning_info,B = I_P_List_adapter<Warning_info,&Warning_info::m_next_in_da,&Warning_info::m_prev_in_da>,C = I_P_List_counter,I = I_P_List_fast_push_back<Warning_info>]" -> "I_P_List_fast_push_back<T>::set_last(T**) [with T = Warning_info]"
"reset_start_time_for_sp(THD*)" -> "my_micro_time_to_timeval(ulonglong,timeval*)"
"reset_start_time_for_sp(THD*)" -> "my_micro_time()"
"THD::restore_sub_statement_state(Sub_statement_state*)" -> "ha_release_savepoint(THD*,SAVEPOINT*)"
"THD::restore_sub_statement_state(Sub_statement_state*)" -> "THD::set_sent_row_count(ha_rows)"
"THD::restore_sub_statement_state(Sub_statement_state*)" -> "is_update_query(enum_sql_command)"
"THD::restore_sub_statement_state(Sub_statement_state*)" -> "MYSQL_BIN_LOG::stop_union_events(THD*)"
"THD::restore_sub_statement_state(Sub_statement_state*)" -> "THD::is_current_stmt_binlog_format_row() const"
"THD::restore_sub_statement_state(Sub_statement_state*)" -> "THD::inc_examined_row_count(ha_rows)"
"ha_release_savepoint(THD*,SAVEPOINT*)" -> "Ha_trx_info::next() const"
"ha_release_savepoint(THD*,SAVEPOINT*)" -> "Ha_trx_info::ht() const"
"ha_release_savepoint(THD*,SAVEPOINT*)" -> "my_error(int,myf,...)"
"THD::reset_sub_statement_state(Sub_statement_state*,uint)" -> "MYSQL_BIN_LOG::start_union_events(THD*,query_id_t)"
"THD::reset_sub_statement_state(Sub_statement_state*,uint)" -> "is_update_query(enum_sql_command)"
"THD::reset_sub_statement_state(Sub_statement_state*,uint)" -> "Query_tables_list::requires_prelocking()"
"THD::reset_sub_statement_state(Sub_statement_state*,uint)" -> "THD::is_current_stmt_binlog_format_row() const"
"Table_triggers_list::check_for_broken_triggers()" -> "my_message(uint,const char*,myf)"
"READ_INFO::read_field()" -> "READ_INFO::find_start_of_fields()"
"READ_INFO::read_field()" -> "_my_b_get(IO_CACHE*)"
"READ_INFO::read_field()" -> "READ_INFO::terminator(const uchar*,uint)"
"READ_INFO::read_field()" -> "READ_INFO::unescape(char)"
"READ_INFO::read_field()" -> "my_realloc(void*,size_t,myf)"
"READ_INFO::find_start_of_fields()" -> "_my_b_get(IO_CACHE*)"
"write_record(THD*,TABLE*,COPY_INFO*,COPY_INFO*)" -> "memcpy(void*,const void*,size_t)"
"write_record(THD*,TABLE*,COPY_INFO*,COPY_INFO*)" -> "handler::ha_update_row(const uchar*,uchar*)"
"write_record(THD*,TABLE*,COPY_INFO*,COPY_INFO*)" -> "Discrete_interval::in_range(ulonglong) const"
"write_record(THD*,TABLE*,COPY_INFO*,COPY_INFO*)" -> "COPY_INFO::get_ignore_errors() const"
"write_record(THD*,TABLE*,COPY_INFO*,COPY_INFO*)" -> "Table_triggers_list::process_triggers(THD*,trg_event_type,trg_action_time_type,bool)"
"write_record(THD*,TABLE*,COPY_INFO*,COPY_INFO*)" -> "handler::get_dup_key(int)"
"write_record(THD*,TABLE*,COPY_INFO*,COPY_INFO*)" -> "compare_records(const TABLE*)"
"write_record(THD*,TABLE*,COPY_INFO*,COPY_INFO*)" -> "Table_triggers_list::has_delete_triggers()"
"write_record(THD*,TABLE*,COPY_INFO*,COPY_INFO*)" -> "records_are_comparable(const TABLE*)"
"write_record(THD*,TABLE*,COPY_INFO*,COPY_INFO*)" -> "key_copy(uchar*,uchar*,KEY*,uint)"
"write_record(THD*,TABLE*,COPY_INFO*,COPY_INFO*)" -> "handler::ha_table_flags() const"
"write_record(THD*,TABLE*,COPY_INFO*,COPY_INFO*)" -> "TABLE_LIST::view_check_option(THD*,bool) const"
"write_record(THD*,TABLE*,COPY_INFO*,COPY_INFO*)" -> "handler::has_transactions()"
"write_record(THD*,TABLE*,COPY_INFO*,COPY_INFO*)" -> "__builtin_alloca(long unsigned int)"
"write_record(THD*,TABLE*,COPY_INFO*,COPY_INFO*)" -> "my_free(void*)"
"write_record(THD*,TABLE*,COPY_INFO*,COPY_INFO*)" -> "THD_TRANS::mark_modified_non_trans_table()"
"write_record(THD*,TABLE*,COPY_INFO*,COPY_INFO*)" -> "handler::restore_auto_increment(ulonglong)"
"write_record(THD*,TABLE*,COPY_INFO*,COPY_INFO*)" -> "my_malloc(size_t,myf)"
"write_record(THD*,TABLE*,COPY_INFO*,COPY_INFO*)" -> "_my_thread_var()"
"write_record(THD*,TABLE*,COPY_INFO*,COPY_INFO*)" -> "THD::record_first_successful_insert_id_in_cur_stmt(ulonglong)"
"write_record(THD*,TABLE*,COPY_INFO*,COPY_INFO*)" -> "handler::ha_index_read_idx_map(uchar*,uint,const uchar*,key_part_map,ha_rkey_function)"
"write_record(THD*,TABLE*,COPY_INFO*,COPY_INFO*)" -> "TABLE::column_bitmaps_set(MY_BITMAP*,MY_BITMAP*)"
"write_record(THD*,TABLE*,COPY_INFO*,COPY_INFO*)" -> "handler::ha_write_row(uchar*)"
"write_record(THD*,TABLE*,COPY_INFO*,COPY_INFO*)" -> "TABLE::use_all_columns()"
"write_record(THD*,TABLE*,COPY_INFO*,COPY_INFO*)" -> "handler::ha_delete_row(const uchar*)"
"write_record(THD*,TABLE*,COPY_INFO*,COPY_INFO*)" -> "last_uniq_key(TABLE*,uint)"
"write_record(THD*,TABLE*,COPY_INFO*,COPY_INFO*)" -> "COPY_INFO::get_changed_columns() const"
"write_record(THD*,TABLE*,COPY_INFO*,COPY_INFO*)" -> "my_error(int,myf,...)"
"write_record(THD*,TABLE*,COPY_INFO*,COPY_INFO*)" -> "COPY_INFO::get_duplicate_handling() const"
"write_record(THD*,TABLE*,COPY_INFO*,COPY_INFO*)" -> "fill_record_n_invoke_before_triggers(THD*,List<Item>&,List<Item>&,bool,Table_triggers_list*,trg_event_type)"
"write_record(THD*,TABLE*,COPY_INFO*,COPY_INFO*)" -> "handler::ha_rnd_pos(uchar*,uchar*)"
"ha_innobase::update_row(const uchar*,uchar*)" -> "innobase_srv_conc_exit_innodb(trx_t*)"
"ha_innobase::update_row(const uchar*,uchar*)" -> "calc_row_difference(upd_t*,uchar*,uchar*,TABLE*,uchar*,ulint,row_prebuilt_t*,THD*)"
"ha_innobase::update_row(const uchar*,uchar*)" -> "innobase_get_int_col_max_value(const Field*)"
"ha_innobase::update_row(const uchar*,uchar*)" -> "ut_dbg_assertion_failed(const char*,const char*,ulint)"
"ha_innobase::update_row(const uchar*,uchar*)" -> "innobase_srv_conc_enter_innodb(trx_t*)"
"ha_innobase::update_row(const uchar*,uchar*)" -> "innobase_active_small()"
"ha_innobase::update_row(const uchar*,uchar*)" -> "my_malloc(size_t,myf)"
"ha_innobase::update_row(const uchar*,uchar*)" -> "handler::ha_thd() const"
"ha_innobase::update_row(const uchar*,uchar*)" -> "thd_to_trx(THD*)"
"ha_innobase::update_row(const uchar*,uchar*)" -> "__builtin_expect(long int,long int)"
"ha_innobase::update_row(const uchar*,uchar*)" -> "convert_error_code_to_mysql(dberr_t,ulint,THD*)"
"ha_innobase::update_row(const uchar*,uchar*)" -> "abort()"
"ha_innobase::update_row(const uchar*,uchar*)" -> "handler::ha_statistic_increment(ulonglong system_status_var::*) const"
"ha_innobase::update_row(const uchar*,uchar*)" -> "row_update_for_mysql(unsigned char*,row_prebuilt_t*)"
"ha_innobase::update_row(const uchar*,uchar*)" -> "innobase_next_autoinc(ulonglong,ulonglong,ulonglong,ulonglong,ulonglong)"
"ha_innobase::update_row(const uchar*,uchar*)" -> "ha_innobase::innobase_set_max_autoinc(ulonglong)"
"ha_innobase::update_row(const uchar*,uchar*)" -> "trx_is_started(trx_t*)"
"ha_innobase::update_row(const uchar*,uchar*)" -> "row_get_prebuilt_update_vector(row_prebuilt_t*)"
"ha_innobase::update_row(const uchar*,uchar*)" -> "ib_senderrf(THD*,ib_log_level_t,ib_uint32_t,...)"
"ha_innobase::update_row(const uchar*,uchar*)" -> "my_error(int,myf,...)"
"ha_innobase::update_row(const uchar*,uchar*)" -> "thd_sql_command(const THD*)"
"calc_row_difference(upd_t*,uchar*,uchar*,TABLE*,uchar*,ulint,row_prebuilt_t*,THD*)" -> "Field::real_maybe_null() const"
"calc_row_difference(upd_t*,uchar*,uchar*,TABLE*,uchar*,ulint,row_prebuilt_t*,THD*)" -> "__builtin_expect(long int,long int)"
"calc_row_difference(upd_t*,uchar*,uchar*,TABLE*,uchar*,ulint,row_prebuilt_t*,THD*)" -> "thd_to_trx(THD*)"
"calc_row_difference(upd_t*,uchar*,uchar*,TABLE*,uchar*,ulint,row_prebuilt_t*,THD*)" -> "abort()"
"calc_row_difference(upd_t*,uchar*,uchar*,TABLE*,uchar*,ulint,row_prebuilt_t*,THD*)" -> "mach_read_from_n_little_endian(const unsigned char*,ulint)"
"calc_row_difference(upd_t*,uchar*,uchar*,TABLE*,uchar*,ulint,row_prebuilt_t*,THD*)" -> "dfield_copy(dfield_t*,const dfield_t*)"
"calc_row_difference(upd_t*,uchar*,uchar*,TABLE*,uchar*,ulint,row_prebuilt_t*,THD*)" -> "__builtin_fwrite(const void*,size_t,size_t,FILE*)"
"calc_row_difference(upd_t*,uchar*,uchar*,TABLE*,uchar*,ulint,row_prebuilt_t*,THD*)" -> "get_field_offset(const TABLE*,const Field*)"
"calc_row_difference(upd_t*,uchar*,uchar*,TABLE*,uchar*,ulint,row_prebuilt_t*,THD*)" -> "fts_update_doc_id(dict_table_t*,upd_field_t*,doc_id_t*)"
"calc_row_difference(upd_t*,uchar*,uchar*,TABLE*,uchar*,ulint,row_prebuilt_t*,THD*)" -> "row_mysql_store_col_in_innobase_format(dfield_t*,unsigned char*,ulint,const unsigned char*,ulint,ulint)"
"calc_row_difference(upd_t*,uchar*,uchar*,TABLE*,uchar*,ulint,row_prebuilt_t*,THD*)" -> "ut_print_name(FILE*,const trx_t*,ulint,const char*)"
"calc_row_difference(upd_t*,uchar*,uchar*,TABLE*,uchar*,ulint,row_prebuilt_t*,THD*)" -> "ut_dbg_assertion_failed(const char*,const char*,ulint)"
"calc_row_difference(upd_t*,uchar*,uchar*,TABLE*,uchar*,ulint,row_prebuilt_t*,THD*)" -> "fprintf(FILE*,const char*,...)"
"calc_row_difference(upd_t*,uchar*,uchar*,TABLE*,uchar*,ulint,row_prebuilt_t*,THD*)" -> "row_mysql_read_true_varchar(ulint*,const unsigned char*,ulint)"
"calc_row_difference(upd_t*,uchar*,uchar*,TABLE*,uchar*,ulint,row_prebuilt_t*,THD*)" -> "Field::is_null_in_record(const uchar*) const"
"calc_row_difference(upd_t*,uchar*,uchar*,TABLE*,uchar*,ulint,row_prebuilt_t*,THD*)" -> "row_upd_changes_doc_id(dict_table_t*,upd_field_t*)"
"calc_row_difference(upd_t*,uchar*,uchar*,TABLE*,uchar*,ulint,row_prebuilt_t*,THD*)" -> "dfield_set_null(dfield_t*)"
"calc_row_difference(upd_t*,uchar*,uchar*,TABLE*,uchar*,ulint,row_prebuilt_t*,THD*)" -> "memcmp(const void*,const void*,size_t)"
"calc_row_difference(upd_t*,uchar*,uchar*,TABLE*,uchar*,ulint,row_prebuilt_t*,THD*)" -> "ut_print_timestamp(FILE*)"
"calc_row_difference(upd_t*,uchar*,uchar*,TABLE*,uchar*,ulint,row_prebuilt_t*,THD*)" -> "putc(int,FILE*)"
"calc_row_difference(upd_t*,uchar*,uchar*,TABLE*,uchar*,ulint,row_prebuilt_t*,THD*)" -> "dict_col_get_clust_pos(const dict_col_t*,const dict_index_t*)"
"calc_row_difference(upd_t*,uchar*,uchar*,TABLE*,uchar*,ulint,row_prebuilt_t*,THD*)" -> "row_upd_changes_fts_column(dict_table_t*,upd_field_t*)"
"calc_row_difference(upd_t*,uchar*,uchar*,TABLE*,uchar*,ulint,row_prebuilt_t*,THD*)" -> "innobase_strcasecmp(const char*,const char*)"
"calc_row_difference(upd_t*,uchar*,uchar*,TABLE*,uchar*,ulint,row_prebuilt_t*,THD*)" -> "row_mysql_read_blob_ref(ulint*,const unsigned char*,ulint)"
"calc_row_difference(upd_t*,uchar*,uchar*,TABLE*,uchar*,ulint,row_prebuilt_t*,THD*)" -> "dict_col_copy_type(const dict_col_t*,dtype_t*)"
"calc_row_difference(upd_t*,uchar*,uchar*,TABLE*,uchar*,ulint,row_prebuilt_t*,THD*)" -> "dict_table_is_comp(const dict_table_t*)"
"Field::is_null_in_record(const uchar*) const" -> "Field::null_offset() const"
"Field::is_null_in_record(const uchar*) const" -> "Field::real_maybe_null() const"
"row_upd_changes_doc_id(dict_table_t*,upd_field_t*)" -> "dict_index_get_nth_col_no(const dict_index_t*,ulint)"
"row_upd_changes_fts_column(dict_table_t*,upd_field_t*)" -> "dict_table_is_fts_column(ib_vector_t*,ulint)"
"row_upd_changes_fts_column(dict_table_t*,upd_field_t*)" -> "dict_index_get_nth_col_no(const dict_index_t*,ulint)"
"innobase_get_int_col_max_value(const Field*)" -> "ut_dbg_assertion_failed(const char*,const char*,ulint)"
"innobase_get_int_col_max_value(const Field*)" -> "abort()"
"innobase_active_small()" -> "srv_active_wake_master_thread()"
"row_update_for_mysql(unsigned char*,row_prebuilt_t*)" -> "que_thr_stop_for_mysql_no_error(que_thr_t*,trx_t*)"
"row_update_for_mysql(unsigned char*,row_prebuilt_t*)" -> "fprintf(FILE*,const char*,...)"
"row_update_for_mysql(unsigned char*,row_prebuilt_t*)" -> "row_mysql_unfreeze_data_dictionary(trx_t*)"
"row_update_for_mysql(unsigned char*,row_prebuilt_t*)" -> "dict_table_n_rows_dec(dict_table_t*)"
"row_update_for_mysql(unsigned char*,row_prebuilt_t*)" -> "Indexer>::add(size_t,Type) [with Type = long unsigned int,int N = 64,Indexer = thread_id_indexer_t,size_t = long unsigned int]"
"row_update_for_mysql(unsigned char*,row_prebuilt_t*)" -> "__builtin_fwrite(const void*,size_t,size_t,FILE*)"
"row_update_for_mysql(unsigned char*,row_prebuilt_t*)" -> "btr_pcur_copy_stored_position(btr_pcur_t*,btr_pcur_t*)"
"row_update_for_mysql(unsigned char*,row_prebuilt_t*)" -> "que_thr_stop_for_mysql(que_thr_t*)"
"row_update_for_mysql(unsigned char*,row_prebuilt_t*)" -> "trx_savept_take(trx_t*)"
"row_update_for_mysql(unsigned char*,row_prebuilt_t*)" -> "row_fts_update_or_delete(row_prebuilt_t*)"
"row_update_for_mysql(unsigned char*,row_prebuilt_t*)" -> "row_mysql_freeze_data_dictionary_func(trx_t*,const char*,ulint)"
"row_update_for_mysql(unsigned char*,row_prebuilt_t*)" -> "mem_analyze_corruption(void*)"
"row_update_for_mysql(unsigned char*,row_prebuilt_t*)" -> "row_mysql_delay_if_needed()"
"row_update_for_mysql(unsigned char*,row_prebuilt_t*)" -> "dict_table_is_referenced_by_foreign_key(const dict_table_t*)"
"row_update_for_mysql(unsigned char*,row_prebuilt_t*)" -> "__builtin_expect(long int,long int)"
"row_update_for_mysql(unsigned char*,row_prebuilt_t*)" -> "abort()"
"row_update_for_mysql(unsigned char*,row_prebuilt_t*)" -> "ut_dbg_assertion_failed(const char*,const char*,ulint)"
"row_update_for_mysql(unsigned char*,row_prebuilt_t*)" -> "dict_table_has_fts_index(dict_table_t*)"
"row_update_for_mysql(unsigned char*,row_prebuilt_t*)" -> "ut_print_name(FILE*,const trx_t*,ulint,const char*)"
"row_update_for_mysql(unsigned char*,row_prebuilt_t*)" -> "putc(int,FILE*)"
"row_update_for_mysql(unsigned char*,row_prebuilt_t*)" -> "que_fork_get_first_thr(que_fork_t*)"
"row_update_for_mysql(unsigned char*,row_prebuilt_t*)" -> "row_update_statistics_if_needed(dict_table_t*)"
"row_update_for_mysql(unsigned char*,row_prebuilt_t*)" -> "row_mysql_handle_errors(dberr_t*,trx_t*,que_thr_t*,trx_savept_t*)"
"row_update_for_mysql(unsigned char*,row_prebuilt_t*)" -> "que_thr_move_to_run_state_for_mysql(que_thr_t*,trx_t*)"
"row_update_for_mysql(unsigned char*,row_prebuilt_t*)" -> "ut_print_timestamp(FILE*)"
"row_update_for_mysql(unsigned char*,row_prebuilt_t*)" -> "trx_start_if_not_started_xa_low(trx_t*)"
"row_update_for_mysql(unsigned char*,row_prebuilt_t*)" -> "row_upd_step(que_thr_t*)"
"row_update_for_mysql(unsigned char*,row_prebuilt_t*)" -> "init_fts_doc_id_for_ref(dict_table_t*,ulint*)"
"row_fts_update_or_delete(row_prebuilt_t*)" -> "abort()"
"row_fts_update_or_delete(row_prebuilt_t*)" -> "__builtin_expect(long int,long int)"
"row_fts_update_or_delete(row_prebuilt_t*)" -> "dict_table_has_fts_index(dict_table_t*)"
"row_fts_update_or_delete(row_prebuilt_t*)" -> "fts_trx_add_op(trx_t*,dict_table_t*,doc_id_t,fts_row_state,ib_vector_t*)"
"row_fts_update_or_delete(row_prebuilt_t*)" -> "__builtin_fwrite(const void*,size_t,size_t,FILE*)"
"row_fts_update_or_delete(row_prebuilt_t*)" -> "mach_read_from_8(const unsigned char*)"
"row_fts_update_or_delete(row_prebuilt_t*)" -> "row_fts_do_update(trx_t*,dict_table_t*,doc_id_t,doc_id_t)"
"row_fts_update_or_delete(row_prebuilt_t*)" -> "ut_dbg_assertion_failed(const char*,const char*,ulint)"
"row_fts_do_update(trx_t*,dict_table_t*,doc_id_t,doc_id_t)" -> "fts_trx_add_op(trx_t*,dict_table_t*,doc_id_t,fts_row_state,ib_vector_t*)"
"row_mysql_delay_if_needed()" -> "os_thread_sleep(ulint)"
"dict_table_is_referenced_by_foreign_key(const dict_table_t*)" -> "_Alloc>::empty() const [with _Key = dict_foreign_t*,_Compare = dict_foreign_compare,_Alloc = std::allocator<dict_foreign_t*>]"
"init_fts_doc_id_for_ref(dict_table_t*,ulint*)" -> "_Alloc>::empty() const [with _Key = dict_foreign_t*,_Compare = dict_foreign_compare,_Alloc = std::allocator<dict_foreign_t*>]"
"init_fts_doc_id_for_ref(dict_table_t*,ulint*)" -> "std::_Rb_tree_const_iterator<_Tp>::operator*() const [with _Tp = dict_foreign_t*,std::_Rb_tree_const_iterator<_Tp>::reference = dict_foreign_t* const&]"
"init_fts_doc_id_for_ref(dict_table_t*,ulint*)" -> "_Alloc>::end() const [with _Key = dict_foreign_t*,_Compare = dict_foreign_compare,_Alloc = std::allocator<dict_foreign_t*>,std::set<_Key,_Compare,_Alloc>::iterator = std::_Rb_tree_const_iterator<dict_foreign_t*>]"
"init_fts_doc_id_for_ref(dict_table_t*,ulint*)" -> "std::_Rb_tree_const_iterator<_Tp>::operator++() [with _Tp = dict_foreign_t*,std::_Rb_tree_const_iterator<_Tp>::_Self = std::_Rb_tree_const_iterator<dict_foreign_t*>]"
"init_fts_doc_id_for_ref(dict_table_t*,ulint*)" -> "init_fts_doc_id_for_ref(dict_table_t*,ulint*)"
"init_fts_doc_id_for_ref(dict_table_t*,ulint*)" -> "std::_Rb_tree_const_iterator<_Tp>::operator!=(const _Self&) const [with _Tp = dict_foreign_t*,std::_Rb_tree_const_iterator<_Tp>::_Self = std::_Rb_tree_const_iterator<dict_foreign_t*>]"
"init_fts_doc_id_for_ref(dict_table_t*,ulint*)" -> "fts_init_doc_id(const dict_table_t*)"
"init_fts_doc_id_for_ref(dict_table_t*,ulint*)" -> "_Alloc>::begin() const [with _Key = dict_foreign_t*,_Compare = dict_foreign_compare,_Alloc = std::allocator<dict_foreign_t*>,std::set<_Key,_Compare,_Alloc>::iterator = std::_Rb_tree_const_iterator<dict_foreign_t*>]"
"innobase_next_autoinc(ulonglong,ulonglong,ulonglong,ulonglong,ulonglong)" -> "ut_dbg_assertion_failed(const char*,const char*,ulint)"
"innobase_next_autoinc(ulonglong,ulonglong,ulonglong,ulonglong,ulonglong)" -> "__builtin_expect(long int,long int)"
"innobase_next_autoinc(ulonglong,ulonglong,ulonglong,ulonglong,ulonglong)" -> "abort()"
"ha_innobase::innobase_set_max_autoinc(ulonglong)" -> "dict_table_autoinc_unlock(dict_table_t*)"
"ha_innobase::innobase_set_max_autoinc(ulonglong)" -> "ha_innobase::innobase_lock_autoinc()"
"ha_innobase::innobase_set_max_autoinc(ulonglong)" -> "dict_table_autoinc_update_if_greater(dict_table_t*,ib_uint64_t)"
"dict_table_autoinc_unlock(dict_table_t*)" -> "pfs_mutex_exit_func(ib_mutex_t*)"
"ha_innobase::innobase_lock_autoinc()" -> "ut_dbg_assertion_failed(const char*,const char*,ulint)"
"ha_innobase::innobase_lock_autoinc()" -> "dict_table_autoinc_unlock(dict_table_t*)"
"ha_innobase::innobase_lock_autoinc()" -> "row_lock_table_autoinc_for_mysql(row_prebuilt_t*)"
"ha_innobase::innobase_lock_autoinc()" -> "dict_table_autoinc_lock(dict_table_t*)"
"ha_innobase::innobase_lock_autoinc()" -> "thd_sql_command(const THD*)"
"ha_innobase::innobase_lock_autoinc()" -> "abort()"
"row_lock_table_autoinc_for_mysql(row_prebuilt_t*)" -> "lock_table(ulint,dict_table_t*,lock_mode,que_thr_t*)"
"row_lock_table_autoinc_for_mysql(row_prebuilt_t*)" -> "que_thr_move_to_run_state_for_mysql(que_thr_t*,trx_t*)"
"row_lock_table_autoinc_for_mysql(row_prebuilt_t*)" -> "que_thr_stop_for_mysql(que_thr_t*)"
"row_lock_table_autoinc_for_mysql(row_prebuilt_t*)" -> "que_thr_stop_for_mysql_no_error(que_thr_t*,trx_t*)"
"row_lock_table_autoinc_for_mysql(row_prebuilt_t*)" -> "trx_start_if_not_started_xa_low(trx_t*)"
"row_lock_table_autoinc_for_mysql(row_prebuilt_t*)" -> "row_mysql_handle_errors(dberr_t*,trx_t*,que_thr_t*,trx_savept_t*)"
"row_lock_table_autoinc_for_mysql(row_prebuilt_t*)" -> "que_fork_get_first_thr(que_fork_t*)"
"row_lock_table_autoinc_for_mysql(row_prebuilt_t*)" -> "row_get_prebuilt_insert_row(row_prebuilt_t*)"
"row_get_prebuilt_insert_row(row_prebuilt_t*)" -> "pars_complete_graph_for_exec(que_node_t*,trx_t*,mem_heap_t*)"
"row_get_prebuilt_insert_row(row_prebuilt_t*)" -> "dict_table_copy_types(dtuple_t*,const dict_table_t*)"
"row_get_prebuilt_insert_row(row_prebuilt_t*)" -> "dict_table_get_n_cols(const dict_table_t*)"
"row_get_prebuilt_insert_row(row_prebuilt_t*)" -> "mem_heap_alloc(mem_heap_t*,ulint)"
"row_get_prebuilt_insert_row(row_prebuilt_t*)" -> "ins_node_create(ulint,dict_table_t*,mem_heap_t*)"
"row_get_prebuilt_insert_row(row_prebuilt_t*)" -> "dtuple_create(mem_heap_t*,ulint)"
"row_get_prebuilt_insert_row(row_prebuilt_t*)" -> "ins_node_set_new_row(ins_node_t*,dtuple_t*)"
"row_get_prebuilt_insert_row(row_prebuilt_t*)" -> "que_graph_free_recursive(que_node_t*)"
"row_get_prebuilt_insert_row(row_prebuilt_t*)" -> "que_node_get_parent(que_node_t*)"
"dict_table_autoinc_lock(dict_table_t*)" -> "pfs_mutex_enter_func(ib_mutex_t*,const char*,ulint)"
"row_get_prebuilt_update_vector(row_prebuilt_t*)" -> "row_create_update_node_for_mysql(dict_table_t*,mem_heap_t*)"
"row_get_prebuilt_update_vector(row_prebuilt_t*)" -> "pars_complete_graph_for_exec(que_node_t*,trx_t*,mem_heap_t*)"
"row_get_prebuilt_update_vector(row_prebuilt_t*)" -> "que_node_get_parent(que_node_t*)"
"compare_records(const TABLE*)" -> "handler::ha_table_flags() const"
"compare_records(const TABLE*)" -> "Field::null_offset() const"
"compare_records(const TABLE*)" -> "bitmap_is_set(const MY_BITMAP*,uint)"
"compare_records(const TABLE*)" -> "memcmp(const void*,const void*,size_t)"
"compare_records(const TABLE*)" -> "Field::real_maybe_null() const"
"records_are_comparable(const TABLE*)" -> "bitmap_is_subset(const MY_BITMAP*,const MY_BITMAP*)"
"records_are_comparable(const TABLE*)" -> "handler::ha_table_flags() const"
"TABLE_LIST::view_check_option(THD*,bool) const" -> "my_error(int,myf,...)"
"TABLE_LIST::view_check_option(THD*,bool) const" -> "push_warning_printf(THD*,Sql_condition::enum_warning_level,uint,const char*,...)"
"TABLE_LIST::view_check_option(THD*,bool) const" -> "TABLE_LIST::top_table() const"
"TABLE_LIST::view_check_option(THD*,bool) const" -> "_current_thd()"
"ha_innobase::write_row(uchar*)" -> "innobase_next_autoinc(ulonglong,ulonglong,ulonglong,ulonglong,ulonglong)"
"ha_innobase::write_row(uchar*)" -> "__builtin_expect(long int,long int)"
"ha_innobase::write_row(uchar*)" -> "trx_is_started(trx_t*)"
"ha_innobase::write_row(uchar*)" -> "ut_dbg_assertion_failed(const char*,const char*,ulint)"
"ha_innobase::write_row(uchar*)" -> "handler::ha_thd() const"
"ha_innobase::write_row(uchar*)" -> "convert_error_code_to_mysql(dberr_t,ulint,THD*)"
"ha_innobase::write_row(uchar*)" -> "innobase_srv_conc_enter_innodb(trx_t*)"
"ha_innobase::write_row(uchar*)" -> "innobase_srv_conc_exit_innodb(trx_t*)"
"ha_innobase::write_row(uchar*)" -> "handler::ha_statistic_increment(ulonglong system_status_var::*) const"
"ha_innobase::write_row(uchar*)" -> "abort()"
"ha_innobase::write_row(uchar*)" -> "row_lock_table_for_mysql(row_prebuilt_t*,dict_table_t*,ulint)"
"ha_innobase::write_row(uchar*)" -> "thd_to_trx(THD*)"
"ha_innobase::write_row(uchar*)" -> "ha_innobase::build_template(bool)"
"ha_innobase::write_row(uchar*)" -> "row_insert_for_mysql(unsigned char*,row_prebuilt_t*)"
"ha_innobase::write_row(uchar*)" -> "putc(int,FILE*)"
"ha_innobase::write_row(uchar*)" -> "my_error(int,myf,...)"
"ha_innobase::write_row(uchar*)" -> "innobase_active_small()"
"ha_innobase::write_row(uchar*)" -> "ib_senderrf(THD*,ib_log_level_t,ib_uint32_t,...)"
"ha_innobase::write_row(uchar*)" -> "__builtin_fwrite(const void*,size_t,size_t,FILE*)"
"ha_innobase::write_row(uchar*)" -> "lock_is_table_exclusive(const dict_table_t*,const trx_t*)"
"ha_innobase::write_row(uchar*)" -> "thd_sql_command(const THD*)"
"ha_innobase::write_row(uchar*)" -> "trx_register_for_2pc(trx_t*)"
"ha_innobase::write_row(uchar*)" -> "innobase_get_int_col_max_value(const Field*)"
"ha_innobase::write_row(uchar*)" -> "handler::update_auto_increment()"
"ha_innobase::write_row(uchar*)" -> "sql_print_error(const char*,...)"
"ha_innobase::write_row(uchar*)" -> "lock_get_src_table(trx_t*,dict_table_t*,lock_mode*)"
"ha_innobase::write_row(uchar*)" -> "ut_print_buf(FILE*,const void*,ulint)"
"ha_innobase::write_row(uchar*)" -> "ha_innobase::innobase_set_max_autoinc(ulonglong)"
"ha_innobase::write_row(uchar*)" -> "innobase_commit(handlerton*,THD*,bool)"
"row_lock_table_for_mysql(row_prebuilt_t*,dict_table_t*,ulint)" -> "row_prebuild_sel_graph(row_prebuilt_t*)"
"row_lock_table_for_mysql(row_prebuilt_t*,dict_table_t*,ulint)" -> "que_thr_stop_for_mysql(que_thr_t*)"
"row_lock_table_for_mysql(row_prebuilt_t*,dict_table_t*,ulint)" -> "trx_start_if_not_started_xa_low(trx_t*)"
"row_lock_table_for_mysql(row_prebuilt_t*,dict_table_t*,ulint)" -> "que_thr_move_to_run_state_for_mysql(que_thr_t*,trx_t*)"
"row_lock_table_for_mysql(row_prebuilt_t*,dict_table_t*,ulint)" -> "lock_table(ulint,dict_table_t*,lock_mode,que_thr_t*)"
"row_lock_table_for_mysql(row_prebuilt_t*,dict_table_t*,ulint)" -> "que_thr_stop_for_mysql_no_error(que_thr_t*,trx_t*)"
"row_lock_table_for_mysql(row_prebuilt_t*,dict_table_t*,ulint)" -> "row_mysql_handle_errors(dberr_t*,trx_t*,que_thr_t*,trx_savept_t*)"
"row_lock_table_for_mysql(row_prebuilt_t*,dict_table_t*,ulint)" -> "que_fork_get_first_thr(que_fork_t*)"
"row_insert_for_mysql(unsigned char*,row_prebuilt_t*)" -> "row_mysql_handle_errors(dberr_t*,trx_t*,que_thr_t*,trx_savept_t*)"
"row_insert_for_mysql(unsigned char*,row_prebuilt_t*)" -> "que_thr_stop_for_mysql_no_error(que_thr_t*,trx_t*)"
"row_insert_for_mysql(unsigned char*,row_prebuilt_t*)" -> "row_get_prebuilt_insert_row(row_prebuilt_t*)"
"row_insert_for_mysql(unsigned char*,row_prebuilt_t*)" -> "fts_get_doc_id_from_row(dict_table_t*,dtuple_t*)"
"row_insert_for_mysql(unsigned char*,row_prebuilt_t*)" -> "ib_logf(ib_log_level_t,const char*,...)"
"row_insert_for_mysql(unsigned char*,row_prebuilt_t*)" -> "trx_savept_take(trx_t*)"
"row_insert_for_mysql(unsigned char*,row_prebuilt_t*)" -> "row_update_statistics_if_needed(dict_table_t*)"
"row_insert_for_mysql(unsigned char*,row_prebuilt_t*)" -> "row_mysql_delay_if_needed()"
"row_insert_for_mysql(unsigned char*,row_prebuilt_t*)" -> "fprintf(FILE*,const char*,...)"
"row_insert_for_mysql(unsigned char*,row_prebuilt_t*)" -> "dict_table_n_rows_inc(dict_table_t*)"
"row_insert_for_mysql(unsigned char*,row_prebuilt_t*)" -> "Indexer>::add(size_t,Type) [with Type = long unsigned int,int N = 64,Indexer = thread_id_indexer_t,size_t = long unsigned int]"
"row_insert_for_mysql(unsigned char*,row_prebuilt_t*)" -> "row_ins_step(que_thr_t*)"
"row_insert_for_mysql(unsigned char*,row_prebuilt_t*)" -> "ut_print_name(FILE*,const trx_t*,ulint,const char*)"
"row_insert_for_mysql(unsigned char*,row_prebuilt_t*)" -> "row_mysql_convert_row_to_innobase(dtuple_t*,row_prebuilt_t*,unsigned char*)"
"row_insert_for_mysql(unsigned char*,row_prebuilt_t*)" -> "que_thr_stop_for_mysql(que_thr_t*)"
"row_insert_for_mysql(unsigned char*,row_prebuilt_t*)" -> "dict_table_has_fts_index(dict_table_t*)"
"row_insert_for_mysql(unsigned char*,row_prebuilt_t*)" -> "fts_trx_add_op(trx_t*,dict_table_t*,doc_id_t,fts_row_state,ib_vector_t*)"
"row_insert_for_mysql(unsigned char*,row_prebuilt_t*)" -> "ut_dbg_assertion_failed(const char*,const char*,ulint)"
"row_insert_for_mysql(unsigned char*,row_prebuilt_t*)" -> "__builtin_fwrite(const void*,size_t,size_t,FILE*)"
"row_insert_for_mysql(unsigned char*,row_prebuilt_t*)" -> "putc(int,FILE*)"
"row_insert_for_mysql(unsigned char*,row_prebuilt_t*)" -> "dict_table_is_discarded(const dict_table_t*)"
"row_insert_for_mysql(unsigned char*,row_prebuilt_t*)" -> "trx_start_if_not_started_xa_low(trx_t*)"
"row_insert_for_mysql(unsigned char*,row_prebuilt_t*)" -> "abort()"
"row_insert_for_mysql(unsigned char*,row_prebuilt_t*)" -> "mem_analyze_corruption(void*)"
"row_insert_for_mysql(unsigned char*,row_prebuilt_t*)" -> "que_thr_move_to_run_state_for_mysql(que_thr_t*,trx_t*)"
"row_insert_for_mysql(unsigned char*,row_prebuilt_t*)" -> "que_fork_get_first_thr(que_fork_t*)"
"fts_get_doc_id_from_row(dict_table_t*,dtuple_t*)" -> "__builtin_expect(long int,long int)"
"fts_get_doc_id_from_row(dict_table_t*,dtuple_t*)" -> "ut_dbg_assertion_failed(const char*,const char*,ulint)"
"fts_get_doc_id_from_row(dict_table_t*,dtuple_t*)" -> "dfield_get_len(const dfield_t*)"
"fts_get_doc_id_from_row(dict_table_t*,dtuple_t*)" -> "mach_read_from_8(const unsigned char*)"
"fts_get_doc_id_from_row(dict_table_t*,dtuple_t*)" -> "abort()"
"row_mysql_convert_row_to_innobase(dtuple_t*,row_prebuilt_t*,unsigned char*)" -> "dict_table_is_comp(const dict_table_t*)"
"row_mysql_convert_row_to_innobase(dtuple_t*,row_prebuilt_t*,unsigned char*)" -> "dfield_set_null(dfield_t*)"
"row_mysql_convert_row_to_innobase(dtuple_t*,row_prebuilt_t*,unsigned char*)" -> "row_mysql_store_col_in_innobase_format(dfield_t*,unsigned char*,ulint,const unsigned char*,ulint,ulint)"
"row_mysql_convert_row_to_innobase(dtuple_t*,row_prebuilt_t*,unsigned char*)" -> "__builtin_expect(long int,long int)"
"row_mysql_convert_row_to_innobase(dtuple_t*,row_prebuilt_t*,unsigned char*)" -> "abort()"
"row_mysql_convert_row_to_innobase(dtuple_t*,row_prebuilt_t*,unsigned char*)" -> "ut_dbg_assertion_failed(const char*,const char*,ulint)"
"row_mysql_convert_row_to_innobase(dtuple_t*,row_prebuilt_t*,unsigned char*)" -> "fts_create_doc_id(dict_table_t*,dtuple_t*,mem_heap_t*)"
"fts_create_doc_id(dict_table_t*,dtuple_t*,mem_heap_t*)" -> "fts_get_next_doc_id(const dict_table_t*,doc_id_t*)"
"fts_create_doc_id(dict_table_t*,dtuple_t*,mem_heap_t*)" -> "ut_dbg_assertion_failed(const char*,const char*,ulint)"
"fts_create_doc_id(dict_table_t*,dtuple_t*,mem_heap_t*)" -> "__builtin_expect(long int,long int)"
"fts_create_doc_id(dict_table_t*,dtuple_t*,mem_heap_t*)" -> "abort()"
"fts_create_doc_id(dict_table_t*,dtuple_t*,mem_heap_t*)" -> "dfield_set_data(dfield_t*,const void*,ulint)"
"fts_create_doc_id(dict_table_t*,dtuple_t*,mem_heap_t*)" -> "mem_heap_alloc(mem_heap_t*,ulint)"
"fts_create_doc_id(dict_table_t*,dtuple_t*,mem_heap_t*)" -> "mach_write_to_8(void*,ib_uint64_t)"
"lock_is_table_exclusive(const dict_table_t*,const trx_t*)" -> "lock_get_type_low(const ib_lock_t*)"
"lock_is_table_exclusive(const dict_table_t*,const trx_t*)" -> "pfs_mutex_enter_func(ib_mutex_t*,const char*,ulint)"
"lock_is_table_exclusive(const dict_table_t*,const trx_t*)" -> "pfs_mutex_exit_func(ib_mutex_t*)"
"lock_is_table_exclusive(const dict_table_t*,const trx_t*)" -> "lock_get_mode(const ib_lock_t*)"
"handler::update_auto_increment()" -> "Discrete_interval::maximum() const"
"handler::update_auto_increment()" -> "Discrete_intervals_list::append(ulonglong,ulonglong,ulonglong)"
"handler::update_auto_increment()" -> "__builtin_expect(long int,long int)"
"handler::update_auto_increment()" -> "handler::adjust_next_insert_id_after_explicit_value(ulonglong)"
"handler::update_auto_increment()" -> "Discrete_interval::values() const"
"handler::update_auto_increment()" -> "THD::is_current_stmt_binlog_format_row() const"
"handler::update_auto_increment()" -> "prev_insert_id(ulonglong,system_variables*)"
"handler::update_auto_increment()" -> "Discrete_interval::minimum() const"
"handler::update_auto_increment()" -> "MYSQL_LOG::is_open()"
"handler::update_auto_increment()" -> "handler::set_next_insert_id(ulonglong)"
"handler::update_auto_increment()" -> "Discrete_intervals_list::get_next()"
"handler::update_auto_increment()" -> "compute_next_insert_id(ulonglong,system_variables*)"
"handler::update_auto_increment()" -> "Discrete_interval::replace(ulonglong,ulonglong,ulonglong)"
"Discrete_intervals_list::append(ulonglong,ulonglong,ulonglong)" -> "Discrete_interval::merge_if_contiguous(ulonglong,ulonglong,ulonglong)"
"Discrete_intervals_list::append(ulonglong,ulonglong,ulonglong)" -> "Discrete_interval::replace(ulonglong,ulonglong,ulonglong)"
"Discrete_intervals_list::append(ulonglong,ulonglong,ulonglong)" -> "Discrete_intervals_list::append(Discrete_interval*)"
"Discrete_intervals_list::append(Discrete_interval*)" -> "__builtin_expect(long int,long int)"
"handler::adjust_next_insert_id_after_explicit_value(ulonglong)" -> "handler::set_next_insert_id(ulonglong)"
"handler::adjust_next_insert_id_after_explicit_value(ulonglong)" -> "compute_next_insert_id(ulonglong,system_variables*)"
"compute_next_insert_id(ulonglong,system_variables*)" -> "__builtin_expect(long int,long int)"
"prev_insert_id(ulonglong,system_variables*)" -> "__builtin_expect(long int,long int)"
"lock_get_src_table(trx_t*,dict_table_t*,lock_mode*)" -> "lock_get_mode(const ib_lock_t*)"
"lock_get_src_table(trx_t*,dict_table_t*,lock_mode*)" -> "pfs_mutex_exit_func(ib_mutex_t*)"
"lock_get_src_table(trx_t*,dict_table_t*,lock_mode*)" -> "pfs_mutex_enter_func(ib_mutex_t*,const char*,ulint)"
"lock_get_src_table(trx_t*,dict_table_t*,lock_mode*)" -> "lock_get_type_low(const ib_lock_t*)"
"innobase_commit(handlerton*,THD*,bool)" -> "trx_search_latch_release_if_reserved(trx_t*)"
"innobase_commit(handlerton*,THD*,bool)" -> "trx_deregister_from_2pc(trx_t*)"
"innobase_commit(handlerton*,THD*,bool)" -> "trx_mark_sql_stat_end(trx_t*)"
"innobase_commit(handlerton*,THD*,bool)" -> "trx_is_started(trx_t*)"
"innobase_commit(handlerton*,THD*,bool)" -> "inline_mysql_cond_signal(mysql_cond_t*)"
"innobase_commit(handlerton*,THD*,bool)" -> "inline_mysql_cond_wait(mysql_cond_t*,mysql_mutex_t*,const char*,uint)"
"innobase_commit(handlerton*,THD*,bool)" -> "trx_commit_complete_for_mysql(trx_t*)"
"innobase_commit(handlerton*,THD*,bool)" -> "innobase_srv_conc_force_exit_innodb(trx_t*)"
"innobase_commit(handlerton*,THD*,bool)" -> "thd_binlog_pos(const THD*,const char**,long long unsigned int*)"
"innobase_commit(handlerton*,THD*,bool)" -> "lock_unlock_table_autoinc(trx_t*)"
"innobase_commit(handlerton*,THD*,bool)" -> "check_trx_exists(THD*)"
"innobase_commit(handlerton*,THD*,bool)" -> "inline_mysql_mutex_lock(mysql_mutex_t*,const char*,uint)"
"innobase_commit(handlerton*,THD*,bool)" -> "trx_is_registered_for_2pc(const trx_t*)"
"innobase_commit(handlerton*,THD*,bool)" -> "sql_print_error(const char*,...)"
"innobase_commit(handlerton*,THD*,bool)" -> "inline_mysql_mutex_unlock(mysql_mutex_t*)"
"innobase_commit(handlerton*,THD*,bool)" -> "innobase_commit_low(trx_t*)"
"innobase_commit(handlerton*,THD*,bool)" -> "thd_test_options(const THD*,long long int)"
"trx_mark_sql_stat_end(trx_t*)" -> "abort()"
"trx_mark_sql_stat_end(trx_t*)" -> "ut_dbg_assertion_failed(const char*,const char*,ulint)"
"trx_mark_sql_stat_end(trx_t*)" -> "fts_savepoint_laststmt_refresh(trx_t*)"
"trx_mark_sql_stat_end(trx_t*)" -> "__builtin_expect(long int,long int)"
"fts_savepoint_laststmt_refresh(trx_t*)" -> "ib_vector_pop(ib_vector_t*)"
"fts_savepoint_laststmt_refresh(trx_t*)" -> "fts_savepoint_create(ib_vector_t*,const char*,mem_heap_t*)"
"fts_savepoint_laststmt_refresh(trx_t*)" -> "fts_savepoint_free(fts_savepoint_t*)"
"trx_commit_complete_for_mysql(trx_t*)" -> "trx_flush_log_if_needed(lsn_t,trx_t*)"
"trx_commit_complete_for_mysql(trx_t*)" -> "__builtin_expect(long int,long int)"
"trx_commit_complete_for_mysql(trx_t*)" -> "thd_requested_durability(const THD*)"
"trx_commit_complete_for_mysql(trx_t*)" -> "ut_dbg_assertion_failed(const char*,const char*,ulint)"
"trx_commit_complete_for_mysql(trx_t*)" -> "abort()"
"innobase_srv_conc_force_exit_innodb(trx_t*)" -> "srv_conc_force_exit_innodb(trx_t*)"
"thd_binlog_pos(const THD*,const char**,long long unsigned int*)" -> "THD::get_trans_pos(const char**,my_off_t*) const"
"lock_unlock_table_autoinc(trx_t*)" -> "lock_release_autoinc_locks(trx_t*)"
"lock_unlock_table_autoinc(trx_t*)" -> "pfs_mutex_enter_func(ib_mutex_t*,const char*,ulint)"
"lock_unlock_table_autoinc(trx_t*)" -> "lock_trx_holds_autoinc_locks(const trx_t*)"
"lock_unlock_table_autoinc(trx_t*)" -> "pfs_mutex_exit_func(ib_mutex_t*)"
"lock_trx_holds_autoinc_locks(const trx_t*)" -> "ut_dbg_assertion_failed(const char*,const char*,ulint)"
"lock_trx_holds_autoinc_locks(const trx_t*)" -> "__builtin_expect(long int,long int)"
"lock_trx_holds_autoinc_locks(const trx_t*)" -> "abort()"
"lock_trx_holds_autoinc_locks(const trx_t*)" -> "ib_vector_is_empty(const ib_vector_t*)"
"check_trx_exists(THD*)" -> "mem_analyze_corruption(void*)"
"check_trx_exists(THD*)" -> "innobase_trx_init(THD*,trx_t*)"
"check_trx_exists(THD*)" -> "ut_dbg_assertion_failed(const char*,const char*,ulint)"
"check_trx_exists(THD*)" -> "abort()"
"check_trx_exists(THD*)" -> "innobase_trx_allocate(THD*)"
"check_trx_exists(THD*)" -> "thd_to_trx(THD*)"
"check_trx_exists(THD*)" -> "__builtin_expect(long int,long int)"
"innobase_trx_init(THD*,trx_t*)" -> "thd_test_options(const THD*,long long int)"
"innobase_trx_allocate(THD*)" -> "innobase_trx_init(THD*,trx_t*)"
"innobase_trx_allocate(THD*)" -> "trx_allocate_for_mysql()"
"trx_allocate_for_mysql()" -> "pfs_mutex_enter_func(ib_mutex_t*,const char*,ulint)"
"trx_allocate_for_mysql()" -> "pfs_mutex_exit_func(ib_mutex_t*)"
"trx_allocate_for_mysql()" -> "trx_allocate_for_background()"
"trx_allocate_for_mysql()" -> "ut_list_prepend(List&,Type&,size_t) [with List = ut_list_base<trx_t>,Type = trx_t,size_t = long unsigned int]"
"innobase_commit_low(trx_t*)" -> "trx_commit_for_mysql(trx_t*)"
"innobase_commit_low(trx_t*)" -> "trx_is_started(trx_t*)"
"last_uniq_key(TABLE*,uint)" -> "handler::ha_table_flags() const"
"Item_func_now_local::store_in(Field*)" -> "THD::query_start_timeval_trunc(uint)"
"Item_func_now_local::store_in(Field*)" -> "Field::set_notnull(my_ptrdiff_t)"
"Item_func_now_local::store_in(Field*)" -> "_current_thd()"
"THD::query_start_timeval_trunc(uint)" -> "my_timeval_trunc(timeval*,uint)"
"my_timeval_trunc(timeval*,uint)" -> "my_time_fraction_remainder(long int,uint)"
"prepare_triggers_for_insert_stmt(TABLE*)" -> "TABLE::mark_columns_needed_for_insert()"
"prepare_triggers_for_insert_stmt(TABLE*)" -> "Table_triggers_list::has_triggers(trg_event_type,trg_action_time_type)"
"TABLE::mark_columns_needed_for_insert()" -> "Table_triggers_list::mark_fields_used(trg_event_type)"
"TABLE::mark_columns_needed_for_insert()" -> "TABLE::mark_columns_per_binlog_row_image()"
"TABLE::mark_columns_needed_for_insert()" -> "TABLE::mark_auto_increment_column()"
"Table_triggers_list::mark_fields_used(trg_event_type)" -> "bitmap_set_bit(MY_BITMAP*,uint)"
"TABLE::mark_columns_per_binlog_row_image()" -> "memset(void*,int,size_t)"
"TABLE::mark_columns_per_binlog_row_image()" -> "MYSQL_LOG::is_open()"
"TABLE::mark_columns_per_binlog_row_image()" -> "THD::is_current_stmt_binlog_format_row() const"
"TABLE::mark_columns_per_binlog_row_image()" -> "TABLE_SHARE::db_type() const"
"TABLE::mark_columns_per_binlog_row_image()" -> "_current_thd()"
"TABLE::mark_columns_per_binlog_row_image()" -> "ha_check_storage_engine_flag(const handlerton*,uint32)"
"TABLE::mark_columns_per_binlog_row_image()" -> "TABLE::mark_columns_used_by_index_no_reset(uint,MY_BITMAP*)"
"TABLE::mark_columns_per_binlog_row_image()" -> "bitmap_set_bit(MY_BITMAP*,uint)"
"TABLE::mark_auto_increment_column()" -> "bitmap_set_bit(MY_BITMAP*,uint)"
"TABLE::mark_auto_increment_column()" -> "TABLE::mark_columns_used_by_index_no_reset(uint,MY_BITMAP*)"
"Query_cache::invalidate(THD*,TABLE_LIST*,my_bool)" -> "Query_cache::is_disabled()"
"Query_cache::invalidate(THD*,TABLE_LIST*,my_bool)" -> "Query_cache::invalidate_table(THD*,TABLE_LIST*)"
"Query_cache::invalidate(THD*,TABLE_LIST*,my_bool)" -> "THD::add_changed_table(TABLE*)"
"Query_cache::invalidate(THD*,TABLE_LIST*,my_bool)" -> "THD::in_multi_stmt_transaction_mode() const"
"Query_cache::invalidate_table(THD*,TABLE_LIST*)" -> "get_table_def_key(const TABLE_LIST*,const char**)"
"Query_cache::invalidate_table(THD*,TABLE_LIST*)" -> "Query_cache::invalidate_table(THD*,uchar*,uint32)"
"Query_cache::invalidate_table(THD*,TABLE_LIST*)" -> "Query_cache::invalidate_table(THD*,TABLE*)"
"Query_cache::invalidate_table(THD*,TABLE*)" -> "Query_cache::invalidate_table(THD*,uchar*,uint32)"
"THD::add_changed_table(TABLE*)" -> "THD::add_changed_table(const char*,long int)"
"READ_INFO::skip_data_till_eof()" -> "_my_b_get(IO_CACHE*)"
"read_xml_field(THD*,COPY_INFO&,TABLE_LIST*,List<Item>&,List<Item>&,List<Item>&,READ_INFO&,ulong,bool)" -> "List_iterator_fast<T>::List_iterator_fast(List<T>&) [with T = XML_TAG]"
"read_xml_field(THD*,COPY_INFO&,TABLE_LIST*,List<Item>&,List<Item>&,List<Item>&,READ_INFO&,ulong,bool)" -> "String::length() const"
"read_xml_field(THD*,COPY_INFO&,TABLE_LIST*,List<Item>&,List<Item>&,List<Item>&,READ_INFO&,ulong,bool)" -> "Field::set_notnull(my_ptrdiff_t)"
"read_xml_field(THD*,COPY_INFO&,TABLE_LIST*,List<Item>&,List<Item>&,List<Item>&,READ_INFO&,ulong,bool)" -> "String::c_ptr()"
"read_xml_field(THD*,COPY_INFO&,TABLE_LIST*,List<Item>&,List<Item>&,List<Item>&,READ_INFO&,ulong,bool)" -> "List_iterator_fast<T>::operator++(int) [with T = XML_TAG]"
"read_xml_field(THD*,COPY_INFO&,TABLE_LIST*,List<Item>&,List<Item>&,List<Item>&,READ_INFO&,ulong,bool)" -> "push_warning_printf(THD*,Sql_condition::enum_warning_level,uint,const char*,...)"
"read_xml_field(THD*,COPY_INFO&,TABLE_LIST*,List<Item>&,List<Item>&,List<Item>&,READ_INFO&,ulong,bool)" -> "List_iterator_fast<T>::operator++(int) [with T = Item]"
"read_xml_field(THD*,COPY_INFO&,TABLE_LIST*,List<Item>&,List<Item>&,List<Item>&,READ_INFO&,ulong,bool)" -> "Diagnostics_area::current_row_for_warning() const"
"read_xml_field(THD*,COPY_INFO&,TABLE_LIST*,List<Item>&,List<Item>&,List<Item>&,READ_INFO&,ulong,bool)" -> "String::ptr() const"
"read_xml_field(THD*,COPY_INFO&,TABLE_LIST*,List<Item>&,List<Item>&,List<Item>&,READ_INFO&,ulong,bool)" -> "Item_user_var_as_out_param::set_value(const char*,uint,const CHARSET_INFO*)"
"read_xml_field(THD*,COPY_INFO&,TABLE_LIST*,List<Item>&,List<Item>&,List<Item>&,READ_INFO&,ulong,bool)" -> "Field::set_null(my_ptrdiff_t)"
"read_xml_field(THD*,COPY_INFO&,TABLE_LIST*,List<Item>&,List<Item>&,List<Item>&,READ_INFO&,ulong,bool)" -> "fill_record_n_invoke_before_triggers(THD*,List<Item>&,List<Item>&,bool,Table_triggers_list*,trg_event_type)"
"read_xml_field(THD*,COPY_INFO&,TABLE_LIST*,List<Item>&,List<Item>&,List<Item>&,READ_INFO&,ulong,bool)" -> "strcmp(const char*,const char*)"
"read_xml_field(THD*,COPY_INFO&,TABLE_LIST*,List<Item>&,List<Item>&,List<Item>&,READ_INFO&,ulong,bool)" -> "memcpy(void*,const void*,size_t)"
"read_xml_field(THD*,COPY_INFO&,TABLE_LIST*,List<Item>&,List<Item>&,List<Item>&,READ_INFO&,ulong,bool)" -> "THD::is_error() const"
"read_xml_field(THD*,COPY_INFO&,TABLE_LIST*,List<Item>&,List<Item>&,List<Item>&,READ_INFO&,ulong,bool)" -> "write_record(THD*,TABLE*,COPY_INFO*,COPY_INFO*)"
"read_xml_field(THD*,COPY_INFO&,TABLE_LIST*,List<Item>&,List<Item>&,List<Item>&,READ_INFO&,ulong,bool)" -> "TABLE_LIST::view_check_option(THD*,bool) const"
"read_xml_field(THD*,COPY_INFO&,TABLE_LIST*,List<Item>&,List<Item>&,List<Item>&,READ_INFO&,ulong,bool)" -> "Diagnostics_area::inc_current_row_for_warning()"
"read_xml_field(THD*,COPY_INFO&,TABLE_LIST*,List<Item>&,List<Item>&,List<Item>&,READ_INFO&,ulong,bool)" -> "READ_INFO::next_line()"
"read_xml_field(THD*,COPY_INFO&,TABLE_LIST*,List<Item>&,List<Item>&,List<Item>&,READ_INFO&,ulong,bool)" -> "validate_default_values_of_unset_fields(THD*,TABLE*)"
"read_xml_field(THD*,COPY_INFO&,TABLE_LIST*,List<Item>&,List<Item>&,List<Item>&,READ_INFO&,ulong,bool)" -> "List_iterator_fast<T>::rewind() [with T = Item]"
"read_xml_field(THD*,COPY_INFO&,TABLE_LIST*,List<Item>&,List<Item>&,List<Item>&,READ_INFO&,ulong,bool)" -> "List_iterator_fast<T>::List_iterator_fast(List<T>&) [with T = Item]"
"read_xml_field(THD*,COPY_INFO&,TABLE_LIST*,List<Item>&,List<Item>&,List<Item>&,READ_INFO&,ulong,bool)" -> "Simple_cstring::ptr() const"
"read_xml_field(THD*,COPY_INFO&,TABLE_LIST*,List<Item>&,List<Item>&,List<Item>&,READ_INFO&,ulong,bool)" -> "Field::set_warning(Sql_condition::enum_warning_level,unsigned int,int) const"
"read_xml_field(THD*,COPY_INFO&,TABLE_LIST*,List<Item>&,List<Item>&,List<Item>&,READ_INFO&,ulong,bool)" -> "THD::get_stmt_da()"
"read_xml_field(THD*,COPY_INFO&,TABLE_LIST*,List<Item>&,List<Item>&,List<Item>&,READ_INFO&,ulong,bool)" -> "_current_thd()"
"read_xml_field(THD*,COPY_INFO&,TABLE_LIST*,List<Item>&,List<Item>&,List<Item>&,READ_INFO&,ulong,bool)" -> "Item_user_var_as_out_param::set_null_value(const CHARSET_INFO*)"
"read_xml_field(THD*,COPY_INFO&,TABLE_LIST*,List<Item>&,List<Item>&,List<Item>&,READ_INFO&,ulong,bool)" -> "List_iterator_fast<T>::rewind() [with T = XML_TAG]"
"read_xml_field(THD*,COPY_INFO&,TABLE_LIST*,List<Item>&,List<Item>&,List<Item>&,READ_INFO&,ulong,bool)" -> "READ_INFO::read_xml()"
"read_xml_field(THD*,COPY_INFO&,TABLE_LIST*,List<Item>&,List<Item>&,List<Item>&,READ_INFO&,ulong,bool)" -> "THD::send_kill_message() const"
"read_xml_field(THD*,COPY_INFO&,TABLE_LIST*,List<Item>&,List<Item>&,List<Item>&,READ_INFO&,ulong,bool)" -> "Item_func_now_local::store_in(Field*)"
"read_xml_field(THD*,COPY_INFO&,TABLE_LIST*,List<Item>&,List<Item>&,List<Item>&,READ_INFO&,ulong,bool)" -> "Field::maybe_null() const"
"read_xml_field(THD*,COPY_INFO&,TABLE_LIST*,List<Item>&,List<Item>&,List<Item>&,READ_INFO&,ulong,bool)" -> "List<T>::head() [with T = Item]"
"List_iterator_fast<T>::List_iterator_fast(List<T>&) [with T = XML_TAG]" -> "base_list_iterator::base_list_iterator(base_list&)"
"List_iterator_fast<T>::operator++(int) [with T = XML_TAG]" -> "base_list_iterator::next_fast()"
"List_iterator_fast<T>::rewind() [with T = XML_TAG]" -> "base_list_iterator::rewind()"
"READ_INFO::read_xml()" -> "_my_b_get(IO_CACHE*)"
"READ_INFO::read_xml()" -> "READ_INFO::read_value(int,String*)"
"READ_INFO::read_xml()" -> "String::length() const"
"READ_INFO::read_xml()" -> "XML_TAG::XML_TAG(int,String,String)"
"READ_INFO::read_xml()" -> "String::String(const String&)"
"READ_INFO::read_xml()" -> "my_tospace(int)"
"READ_INFO::read_xml()" -> "String::String()"
"READ_INFO::read_xml()" -> "String::append(char)"
"READ_INFO::read_xml()" -> "READ_INFO::clear_level(int)"
"READ_INFO::read_xml()" -> "List<T>::push_front(T*) [with T = XML_TAG]"
"READ_INFO::read_xml()" -> "memcmp(const void*,const void*,size_t)"
"READ_INFO::read_xml()" -> "String::length(uint32)"
"READ_INFO::read_xml()" -> "String::ptr() const"
"READ_INFO::read_xml()" -> "String::c_ptr_safe()"
"READ_INFO::read_value(int,String*)" -> "String::String()"
"READ_INFO::read_value(int,String*)" -> "my_tospace(int)"
"READ_INFO::read_value(int,String*)" -> "String::length() const"
"READ_INFO::read_value(int,String*)" -> "String::ptr() const"
"READ_INFO::read_value(int,String*)" -> "my_xml_entity_to_char(const char*,uint)"
"READ_INFO::read_value(int,String*)" -> "_my_b_get(IO_CACHE*)"
"READ_INFO::read_value(int,String*)" -> "String::append(char)"
"READ_INFO::read_value(int,String*)" -> "String::length(uint32)"
"READ_INFO::read_value(int,String*)" -> "String::append(const String&)"
"my_xml_entity_to_char(const char*,uint)" -> "memcmp(const void*,const void*,size_t)"
"XML_TAG::XML_TAG(int,String,String)" -> "String::String()"
"XML_TAG::XML_TAG(int,String,String)" -> "String::append(const String&)"
"READ_INFO::clear_level(int)" -> "List_iterator<T>::List_iterator(List<T>&) [with T = XML_TAG]"
"READ_INFO::clear_level(int)" -> "List_iterator<T>::remove() [with T = XML_TAG]"
"READ_INFO::clear_level(int)" -> "List_iterator<T>::rewind() [with T = XML_TAG]"
"READ_INFO::clear_level(int)" -> "List_iterator<T>::operator++(int) [with T = XML_TAG]"
"List_iterator<T>::List_iterator(List<T>&) [with T = XML_TAG]" -> "base_list_iterator::base_list_iterator(base_list&)"
"List_iterator<T>::remove() [with T = XML_TAG]" -> "base_list_iterator::remove()"
"List_iterator<T>::rewind() [with T = XML_TAG]" -> "base_list_iterator::rewind()"
"List_iterator<T>::operator++(int) [with T = XML_TAG]" -> "base_list_iterator::next()"
"List<T>::push_front(T*) [with T = XML_TAG]" -> "base_list::push_front(void*)"
"read_fixed_length(THD*,COPY_INFO&,TABLE_LIST*,List<Item>&,List<Item>&,List<Item>&,READ_INFO&,ulong,bool)" -> "List_iterator_fast<T>::rewind() [with T = Item]"
"read_fixed_length(THD*,COPY_INFO&,TABLE_LIST*,List<Item>&,List<Item>&,List<Item>&,READ_INFO&,ulong,bool)" -> "List_iterator_fast<T>::List_iterator_fast(List<T>&) [with T = Item]"
"read_fixed_length(THD*,COPY_INFO&,TABLE_LIST*,List<Item>&,List<Item>&,List<Item>&,READ_INFO&,ulong,bool)" -> "write_record(THD*,TABLE*,COPY_INFO*,COPY_INFO*)"
"read_fixed_length(THD*,COPY_INFO&,TABLE_LIST*,List<Item>&,List<Item>&,List<Item>&,READ_INFO&,ulong,bool)" -> "Field::set_notnull(my_ptrdiff_t)"
"read_fixed_length(THD*,COPY_INFO&,TABLE_LIST*,List<Item>&,List<Item>&,List<Item>&,READ_INFO&,ulong,bool)" -> "validate_default_values_of_unset_fields(THD*,TABLE*)"
"read_fixed_length(THD*,COPY_INFO&,TABLE_LIST*,List<Item>&,List<Item>&,List<Item>&,READ_INFO&,ulong,bool)" -> "memcpy(void*,const void*,size_t)"
"read_fixed_length(THD*,COPY_INFO&,TABLE_LIST*,List<Item>&,List<Item>&,List<Item>&,READ_INFO&,ulong,bool)" -> "THD::get_stmt_da()"
"read_fixed_length(THD*,COPY_INFO&,TABLE_LIST*,List<Item>&,List<Item>&,List<Item>&,READ_INFO&,ulong,bool)" -> "TABLE_LIST::view_check_option(THD*,bool) const"
"read_fixed_length(THD*,COPY_INFO&,TABLE_LIST*,List<Item>&,List<Item>&,List<Item>&,READ_INFO&,ulong,bool)" -> "_current_thd()"
"read_fixed_length(THD*,COPY_INFO&,TABLE_LIST*,List<Item>&,List<Item>&,List<Item>&,READ_INFO&,ulong,bool)" -> "List_iterator_fast<T>::operator++(int) [with T = Item]"
"read_fixed_length(THD*,COPY_INFO&,TABLE_LIST*,List<Item>&,List<Item>&,List<Item>&,READ_INFO&,ulong,bool)" -> "Diagnostics_area::current_row_for_warning() const"
"read_fixed_length(THD*,COPY_INFO&,TABLE_LIST*,List<Item>&,List<Item>&,List<Item>&,READ_INFO&,ulong,bool)" -> "Field::maybe_null() const"
"read_fixed_length(THD*,COPY_INFO&,TABLE_LIST*,List<Item>&,List<Item>&,List<Item>&,READ_INFO&,ulong,bool)" -> "READ_INFO::read_fixed_length()"
"read_fixed_length(THD*,COPY_INFO&,TABLE_LIST*,List<Item>&,List<Item>&,List<Item>&,READ_INFO&,ulong,bool)" -> "Item_func_now_local::store_in(Field*)"
"read_fixed_length(THD*,COPY_INFO&,TABLE_LIST*,List<Item>&,List<Item>&,List<Item>&,READ_INFO&,ulong,bool)" -> "push_warning_printf(THD*,Sql_condition::enum_warning_level,uint,const char*,...)"
"read_fixed_length(THD*,COPY_INFO&,TABLE_LIST*,List<Item>&,List<Item>&,List<Item>&,READ_INFO&,ulong,bool)" -> "THD::send_kill_message() const"
"read_fixed_length(THD*,COPY_INFO&,TABLE_LIST*,List<Item>&,List<Item>&,List<Item>&,READ_INFO&,ulong,bool)" -> "fill_record_n_invoke_before_triggers(THD*,List<Item>&,List<Item>&,bool,Table_triggers_list*,trg_event_type)"
"read_fixed_length(THD*,COPY_INFO&,TABLE_LIST*,List<Item>&,List<Item>&,List<Item>&,READ_INFO&,ulong,bool)" -> "Diagnostics_area::inc_current_row_for_warning()"
"read_fixed_length(THD*,COPY_INFO&,TABLE_LIST*,List<Item>&,List<Item>&,List<Item>&,READ_INFO&,ulong,bool)" -> "READ_INFO::next_line()"
"READ_INFO::read_fixed_length()" -> "READ_INFO::unescape(char)"
"READ_INFO::read_fixed_length()" -> "READ_INFO::terminator(const uchar*,uint)"
"READ_INFO::read_fixed_length()" -> "_my_b_get(IO_CACHE*)"
"READ_INFO::read_fixed_length()" -> "READ_INFO::find_start_of_fields()"
"READ_INFO::READ_INFO(File,uint,const CHARSET_INFO*,const String&,const String&,const String&,const String&,int,bool,bool)" -> "my_free(void*)"
"READ_INFO::READ_INFO(File,uint,const CHARSET_INFO*,const String&,const String&,const String&,const String&,int,bool,bool)" -> "init_io_cache(IO_CACHE*,File,size_t,cache_type,my_off_t,pbool,myf)"
"READ_INFO::READ_INFO(File,uint,const CHARSET_INFO*,const String&,const String&,const String&,const String&,int,bool,bool)" -> "String::length() const"
"READ_INFO::READ_INFO(File,uint,const CHARSET_INFO*,const String&,const String&,const String&,const String&,int,bool,bool)" -> "String::ptr() const"
"READ_INFO::READ_INFO(File,uint,const CHARSET_INFO*,const String&,const String&,const String&,const String&,int,bool,bool)" -> "std::max(const _Tp&,const _Tp&) [with _Tp = unsigned int]"
"READ_INFO::READ_INFO(File,uint,const CHARSET_INFO*,const String&,const String&,const String&,const String&,int,bool,bool)" -> "String::operator[](uint32) const"
"READ_INFO::READ_INFO(File,uint,const CHARSET_INFO*,const String&,const String&,const String&,const String&,int,bool,bool)" -> "List<T>::List() [with T = XML_TAG]"
"READ_INFO::READ_INFO(File,uint,const CHARSET_INFO*,const String&,const String&,const String&,const String&,int,bool,bool)" -> "memcmp(const void*,const void*,size_t)"
"READ_INFO::READ_INFO(File,uint,const CHARSET_INFO*,const String&,const String&,const String&,const String&,int,bool,bool)" -> "my_malloc(size_t,myf)"
"READ_INFO::READ_INFO(File,uint,const CHARSET_INFO*,const String&,const String&,const String&,const String&,int,bool,bool)" -> "sql_alloc(size_t)"
"List<T>::List() [with T = XML_TAG]" -> "base_list::base_list()"
"handler::ha_release_auto_increment()" -> "Discrete_intervals_list::empty()"
"handler::ha_release_auto_increment()" -> "Discrete_interval::replace(ulonglong,ulonglong,ulonglong)"
"COPY_INFO::add_function_default_columns(TABLE*,MY_BITMAP*)" -> "COPY_INFO::get_function_default_columns(TABLE*)"
"COPY_INFO::add_function_default_columns(TABLE*,MY_BITMAP*)" -> "bitmap_union(MY_BITMAP*,const MY_BITMAP*)"
"COPY_INFO::get_function_default_columns(TABLE*)" -> "bitmap_set_bit(MY_BITMAP*,uint)"
"COPY_INFO::get_function_default_columns(TABLE*)" -> "bitmap_is_clear_all(const MY_BITMAP*)"
"COPY_INFO::get_function_default_columns(TABLE*)" -> "Field::has_insert_default_function() const"
"COPY_INFO::get_function_default_columns(TABLE*)" -> "List_iterator<T>::operator++(int) [with T = Item]"
"COPY_INFO::get_function_default_columns(TABLE*)" -> "Field::has_update_default_function() const"
"COPY_INFO::get_function_default_columns(TABLE*)" -> "allocate_column_bitmap(TABLE*,MY_BITMAP**)"
"COPY_INFO::get_function_default_columns(TABLE*)" -> "List_iterator<T>::List_iterator(List<T>&) [with T = Item]"
"allocate_column_bitmap(TABLE*,MY_BITMAP**)" -> "bitmap_init(MY_BITMAP*,my_bitmap_map*,uint,my_bool)"
"allocate_column_bitmap(TABLE*,MY_BITMAP**)" -> "multi_alloc_root(MEM_ROOT*,...)"
"COPY_INFO::COPY_INFO(COPY_INFO::operation_type,List<Item>*,List<Item>*,bool,enum_duplicates,bool,int)" -> "COPY_INFO::Statistics::Statistics()"
"COPY_INFO::COPY_INFO(COPY_INFO::operation_type,List<Item>*,List<Item>*,bool,enum_duplicates,bool,int)" -> "Sql_alloc::Sql_alloc()"
"MDL_context::release_statement_locks()" -> "MDL_context::release_locks_stored_before(enum_mdl_duration,MDL_ticket*)"
"mysql_assign_to_keycache(THD*,TABLE_LIST*,LEX_STRING*)" -> "get_key_cache(LEX_STRING*)"
"mysql_assign_to_keycache(THD*,TABLE_LIST*,LEX_STRING*)" -> "st_ha_check_opt::init()"
"mysql_assign_to_keycache(THD*,TABLE_LIST*,LEX_STRING*)" -> "my_error(int,myf,...)"
"mysql_assign_to_keycache(THD*,TABLE_LIST*,LEX_STRING*)" -> "mysql_admin_table(THD*,TABLE_LIST*,HA_CHECK_OPT*,const char*,thr_lock_type,bool,bool,uint,int (*)(THD*,TABLE_LIST*,HA_CHECK_OPT*),int (handler::*)(THD*,HA_CHECK_OPT*),int (*)(THD*,TABLE_LIST*))"
"mysql_assign_to_keycache(THD*,TABLE_LIST*,LEX_STRING*)" -> "inline_mysql_mutex_unlock(mysql_mutex_t*)"
"mysql_assign_to_keycache(THD*,TABLE_LIST*,LEX_STRING*)" -> "st_ha_check_opt::st_ha_check_opt()"
"mysql_assign_to_keycache(THD*,TABLE_LIST*,LEX_STRING*)" -> "inline_mysql_mutex_lock(mysql_mutex_t*)"
"get_key_cache(LEX_STRING*)" -> "find_named(I_List<NAMED_ILINK>*,const char*,uint,NAMED_ILINK**)"
"find_named(I_List<NAMED_ILINK>*,const char*,uint,NAMED_ILINK**)" -> "NAMED_ILINK::cmp(const char*,uint)"
"find_named(I_List<NAMED_ILINK>*,const char*,uint,NAMED_ILINK**)" -> "I_List_iterator<T>::I_List_iterator(I_List<T>&) [with T = NAMED_ILINK]"
"find_named(I_List<NAMED_ILINK>*,const char*,uint,NAMED_ILINK**)" -> "I_List_iterator<T>::operator++(int) [with T = NAMED_ILINK]"
"NAMED_ILINK::cmp(const char*,uint)" -> "memcmp(const void*,const void*,size_t)"
"mysql_admin_table(THD*,TABLE_LIST*,HA_CHECK_OPT*,const char*,thr_lock_type,bool,bool,uint,int (*)(THD*,TABLE_LIST*,HA_CHECK_OPT*),int (handler::*)(THD*,HA_CHECK_OPT*),int (*)(THD*,TABLE_LIST*))" -> "sql_print_error(const char*,...)"
"mysql_admin_table(THD*,TABLE_LIST*,HA_CHECK_OPT*,const char*,thr_lock_type,bool,bool,uint,int (*)(THD*,TABLE_LIST*,HA_CHECK_OPT*),int (handler::*)(THD*,HA_CHECK_OPT*),int (*)(THD*,TABLE_LIST*))" -> "Protocol::store(const char*,const CHARSET_INFO*)"
"mysql_admin_table(THD*,TABLE_LIST*,HA_CHECK_OPT*,const char*,thr_lock_type,bool,bool,uint,int (*)(THD*,TABLE_LIST*,HA_CHECK_OPT*),int (handler::*)(THD*,HA_CHECK_OPT*),int (*)(THD*,TABLE_LIST*))" -> "trans_commit(THD*)"
"mysql_admin_table(THD*,TABLE_LIST*,HA_CHECK_OPT*,const char*,thr_lock_type,bool,bool,uint,int (*)(THD*,TABLE_LIST*,HA_CHECK_OPT*),int (handler::*)(THD*,HA_CHECK_OPT*),int (*)(THD*,TABLE_LIST*))" -> "Diagnostics_area::is_warning_info_empty() const"
"mysql_admin_table(THD*,TABLE_LIST*,HA_CHECK_OPT*,const char*,thr_lock_type,bool,bool,uint,int (*)(THD*,TABLE_LIST*,HA_CHECK_OPT*),int (handler::*)(THD*,HA_CHECK_OPT*),int (*)(THD*,TABLE_LIST*))" -> "String::c_ptr()"
"mysql_admin_table(THD*,TABLE_LIST*,HA_CHECK_OPT*,const char*,thr_lock_type,bool,bool,uint,int (*)(THD*,TABLE_LIST*,HA_CHECK_OPT*),int (handler::*)(THD*,HA_CHECK_OPT*),int (*)(THD*,TABLE_LIST*))" -> "close_thread_tables(THD*)"
"mysql_admin_table(THD*,TABLE_LIST*,HA_CHECK_OPT*,const char*,thr_lock_type,bool,bool,uint,int (*)(THD*,TABLE_LIST*,HA_CHECK_OPT*),int (handler::*)(THD*,HA_CHECK_OPT*),int (*)(THD*,TABLE_LIST*))" -> "Diagnostics_area::is_error() const"
"mysql_admin_table(THD*,TABLE_LIST*,HA_CHECK_OPT*,const char*,thr_lock_type,bool,bool,uint,int (*)(THD*,TABLE_LIST*,HA_CHECK_OPT*),int (handler::*)(THD*,HA_CHECK_OPT*),int (*)(THD*,TABLE_LIST*))" -> "Query_cache::invalidate(THD*,TABLE_LIST*,my_bool)"
"mysql_admin_table(THD*,TABLE_LIST*,HA_CHECK_OPT*,const char*,thr_lock_type,bool,bool,uint,int (*)(THD*,TABLE_LIST*,HA_CHECK_OPT*),int (handler::*)(THD*,HA_CHECK_OPT*),int (*)(THD*,TABLE_LIST*))" -> "Warning_info::Warning_info(ulonglong,bool)"
"mysql_admin_table(THD*,TABLE_LIST*,HA_CHECK_OPT*,const char*,thr_lock_type,bool,bool,uint,int (*)(THD*,TABLE_LIST*,HA_CHECK_OPT*),int (handler::*)(THD*,HA_CHECK_OPT*),int (*)(THD*,TABLE_LIST*))" -> "Diagnostics_area::clear_warning_info(ulonglong)"
"mysql_admin_table(THD*,TABLE_LIST*,HA_CHECK_OPT*,const char*,thr_lock_type,bool,bool,uint,int (*)(THD*,TABLE_LIST*,HA_CHECK_OPT*),int (handler::*)(THD*,HA_CHECK_OPT*),int (*)(THD*,TABLE_LIST*))" -> "LEX::cleanup_after_one_table_open()"
"mysql_admin_table(THD*,TABLE_LIST*,HA_CHECK_OPT*,const char*,thr_lock_type,bool,bool,uint,int (*)(THD*,TABLE_LIST*,HA_CHECK_OPT*),int (handler::*)(THD*,HA_CHECK_OPT*),int (*)(THD*,TABLE_LIST*))" -> "handler::ha_check_for_upgrade(HA_CHECK_OPT*)"
"mysql_admin_table(THD*,TABLE_LIST*,HA_CHECK_OPT*,const char*,thr_lock_type,bool,bool,uint,int (*)(THD*,TABLE_LIST*,HA_CHECK_OPT*),int (handler::*)(THD*,HA_CHECK_OPT*),int (*)(THD*,TABLE_LIST*))" -> "Diagnostics_area::message() const"
"mysql_admin_table(THD*,TABLE_LIST*,HA_CHECK_OPT*,const char*,thr_lock_type,bool,bool,uint,int (*)(THD*,TABLE_LIST*,HA_CHECK_OPT*),int (handler::*)(THD*,HA_CHECK_OPT*),int (*)(THD*,TABLE_LIST*))" -> "Diagnostics_area::sql_errno() const"
"mysql_admin_table(THD*,TABLE_LIST*,HA_CHECK_OPT*,const char*,thr_lock_type,bool,bool,uint,int (*)(THD*,TABLE_LIST*,HA_CHECK_OPT*),int (handler::*)(THD*,HA_CHECK_OPT*),int (*)(THD*,TABLE_LIST*))" -> "String::String()"
"mysql_admin_table(THD*,TABLE_LIST*,HA_CHECK_OPT*,const char*,thr_lock_type,bool,bool,uint,int (*)(THD*,TABLE_LIST*,HA_CHECK_OPT*),int (handler::*)(THD*,HA_CHECK_OPT*),int (*)(THD*,TABLE_LIST*))" -> "set_part_state(Alter_info*,partition_info*,partition_state)"
"mysql_admin_table(THD*,TABLE_LIST*,HA_CHECK_OPT*,const char*,thr_lock_type,bool,bool,uint,int (*)(THD*,TABLE_LIST*,HA_CHECK_OPT*),int (handler::*)(THD*,HA_CHECK_OPT*),int (*)(THD*,TABLE_LIST*))" -> "handler::ha_table_flags() const"
"mysql_admin_table(THD*,TABLE_LIST*,HA_CHECK_OPT*,const char*,thr_lock_type,bool,bool,uint,int (*)(THD*,TABLE_LIST*,HA_CHECK_OPT*),int (handler::*)(THD*,HA_CHECK_OPT*),int (*)(THD*,TABLE_LIST*))" -> "String::String(const char*,const CHARSET_INFO*)"
"mysql_admin_table(THD*,TABLE_LIST*,HA_CHECK_OPT*,const char*,thr_lock_type,bool,bool,uint,int (*)(THD*,TABLE_LIST*,HA_CHECK_OPT*),int (handler::*)(THD*,HA_CHECK_OPT*),int (*)(THD*,TABLE_LIST*))" -> "mysql_recreate_table(THD*,TABLE_LIST*,bool)"
"mysql_admin_table(THD*,TABLE_LIST*,HA_CHECK_OPT*,const char*,thr_lock_type,bool,bool,uint,int (*)(THD*,TABLE_LIST*,HA_CHECK_OPT*),int (handler::*)(THD*,HA_CHECK_OPT*),int (*)(THD*,TABLE_LIST*))" -> "handler::check_old_types()"
"mysql_admin_table(THD*,TABLE_LIST*,HA_CHECK_OPT*,const char*,thr_lock_type,bool,bool,uint,int (*)(THD*,TABLE_LIST*,HA_CHECK_OPT*),int (handler::*)(THD*,HA_CHECK_OPT*),int (*)(THD*,TABLE_LIST*))" -> "THD::is_error() const"
"mysql_admin_table(THD*,TABLE_LIST*,HA_CHECK_OPT*,const char*,thr_lock_type,bool,bool,uint,int (*)(THD*,TABLE_LIST*,HA_CHECK_OPT*),int (handler::*)(THD*,HA_CHECK_OPT*),int (*)(THD*,TABLE_LIST*))" -> "MDL_request::set_type(enum_mdl_type)"
"mysql_admin_table(THD*,TABLE_LIST*,HA_CHECK_OPT*,const char*,thr_lock_type,bool,bool,uint,int (*)(THD*,TABLE_LIST*,HA_CHECK_OPT*),int (handler::*)(THD*,HA_CHECK_OPT*),int (*)(THD*,TABLE_LIST*))" -> "Diagnostics_area::pop_warning_info()"
"mysql_admin_table(THD*,TABLE_LIST*,HA_CHECK_OPT*,const char*,thr_lock_type,bool,bool,uint,int (*)(THD*,TABLE_LIST*,HA_CHECK_OPT*),int (handler::*)(THD*,HA_CHECK_OPT*),int (*)(THD*,TABLE_LIST*))" -> "Diagnostics_area::push_warning_info(Warning_info*)"
"mysql_admin_table(THD*,TABLE_LIST*,HA_CHECK_OPT*,const char*,thr_lock_type,bool,bool,uint,int (*)(THD*,TABLE_LIST*,HA_CHECK_OPT*),int (handler::*)(THD*,HA_CHECK_OPT*),int (*)(THD*,TABLE_LIST*))" -> "view_checksum(THD*,TABLE_LIST*)"
"mysql_admin_table(THD*,TABLE_LIST*,HA_CHECK_OPT*,const char*,thr_lock_type,bool,bool,uint,int (*)(THD*,TABLE_LIST*,HA_CHECK_OPT*),int (handler::*)(THD*,HA_CHECK_OPT*),int (*)(THD*,TABLE_LIST*))" -> "Query_cache::invalidate(THD*,TABLE*,my_bool)"
"mysql_admin_table(THD*,TABLE_LIST*,HA_CHECK_OPT*,const char*,thr_lock_type,bool,bool,uint,int (*)(THD*,TABLE_LIST*,HA_CHECK_OPT*),int (handler::*)(THD*,HA_CHECK_OPT*),int (*)(THD*,TABLE_LIST*))" -> "THD::get_stmt_da()"
"mysql_admin_table(THD*,TABLE_LIST*,HA_CHECK_OPT*,const char*,thr_lock_type,bool,bool,uint,int (*)(THD*,TABLE_LIST*,HA_CHECK_OPT*),int (handler::*)(THD*,HA_CHECK_OPT*),int (*)(THD*,TABLE_LIST*))" -> "Diagnostics_area::sql_conditions() const"
"mysql_admin_table(THD*,TABLE_LIST*,HA_CHECK_OPT*,const char*,thr_lock_type,bool,bool,uint,int (*)(THD*,TABLE_LIST*,HA_CHECK_OPT*),int (handler::*)(THD*,HA_CHECK_OPT*),int (*)(THD*,TABLE_LIST*))" -> "strlen(const char*)"
"mysql_admin_table(THD*,TABLE_LIST*,HA_CHECK_OPT*,const char*,thr_lock_type,bool,bool,uint,int (*)(THD*,TABLE_LIST*,HA_CHECK_OPT*),int (handler::*)(THD*,HA_CHECK_OPT*),int (*)(THD*,TABLE_LIST*))" -> "Sql_condition::get_message_text() const"
"mysql_admin_table(THD*,TABLE_LIST*,HA_CHECK_OPT*,const char*,thr_lock_type,bool,bool,uint,int (*)(THD*,TABLE_LIST*,HA_CHECK_OPT*),int (handler::*)(THD*,HA_CHECK_OPT*),int (*)(THD*,TABLE_LIST*))" -> "THD::clear_error()"
"mysql_admin_table(THD*,TABLE_LIST*,HA_CHECK_OPT*,const char*,thr_lock_type,bool,bool,uint,int (*)(THD*,TABLE_LIST*,HA_CHECK_OPT*),int (handler::*)(THD*,HA_CHECK_OPT*),int (*)(THD*,TABLE_LIST*))" -> "my_snprintf(char*,size_t,const char*,...)"
"mysql_admin_table(THD*,TABLE_LIST*,HA_CHECK_OPT*,const char*,thr_lock_type,bool,bool,uint,int (*)(THD*,TABLE_LIST*,HA_CHECK_OPT*),int (handler::*)(THD*,HA_CHECK_OPT*),int (*)(THD*,TABLE_LIST*))" -> "open_temporary_tables(THD*,TABLE_LIST*)"
"mysql_admin_table(THD*,TABLE_LIST*,HA_CHECK_OPT*,const char*,thr_lock_type,bool,bool,uint,int (*)(THD*,TABLE_LIST*,HA_CHECK_OPT*),int (handler::*)(THD*,HA_CHECK_OPT*),int (*)(THD*,TABLE_LIST*))" -> "trans_commit_stmt(THD*)"
"mysql_admin_table(THD*,TABLE_LIST*,HA_CHECK_OPT*,const char*,thr_lock_type,bool,bool,uint,int (*)(THD*,TABLE_LIST*,HA_CHECK_OPT*),int (handler::*)(THD*,HA_CHECK_OPT*),int (*)(THD*,TABLE_LIST*))" -> "trans_commit_implicit(THD*)"
"mysql_admin_table(THD*,TABLE_LIST*,HA_CHECK_OPT*,const char*,thr_lock_type,bool,bool,uint,int (*)(THD*,TABLE_LIST*,HA_CHECK_OPT*),int (handler::*)(THD*,HA_CHECK_OPT*),int (*)(THD*,TABLE_LIST*))" -> "handler::ha_analyze(THD*,HA_CHECK_OPT*)"
"mysql_admin_table(THD*,TABLE_LIST*,HA_CHECK_OPT*,const char*,thr_lock_type,bool,bool,uint,int (*)(THD*,TABLE_LIST*,HA_CHECK_OPT*),int (handler::*)(THD*,HA_CHECK_OPT*),int (*)(THD*,TABLE_LIST*))" -> "wait_while_table_is_used(THD*,TABLE*,ha_extra_function)"
"mysql_admin_table(THD*,TABLE_LIST*,HA_CHECK_OPT*,const char*,thr_lock_type,bool,bool,uint,int (*)(THD*,TABLE_LIST*,HA_CHECK_OPT*),int (handler::*)(THD*,HA_CHECK_OPT*),int (*)(THD*,TABLE_LIST*))" -> "String::append(char)"
"mysql_admin_table(THD*,TABLE_LIST*,HA_CHECK_OPT*,const char*,thr_lock_type,bool,bool,uint,int (*)(THD*,TABLE_LIST*,HA_CHECK_OPT*),int (handler::*)(THD*,HA_CHECK_OPT*),int (*)(THD*,TABLE_LIST*))" -> "my_eof(THD*)"
"mysql_admin_table(THD*,TABLE_LIST*,HA_CHECK_OPT*,const char*,thr_lock_type,bool,bool,uint,int (*)(THD*,TABLE_LIST*,HA_CHECK_OPT*),int (handler::*)(THD*,HA_CHECK_OPT*),int (*)(THD*,TABLE_LIST*))" -> "Sql_condition::get_level() const"
"mysql_admin_table(THD*,TABLE_LIST*,HA_CHECK_OPT*,const char*,thr_lock_type,bool,bool,uint,int (*)(THD*,TABLE_LIST*,HA_CHECK_OPT*),int (handler::*)(THD*,HA_CHECK_OPT*),int (*)(THD*,TABLE_LIST*))" -> "List<T>::push_back(T*) [with T = Item]"
"mysql_admin_table(THD*,TABLE_LIST*,HA_CHECK_OPT*,const char*,thr_lock_type,bool,bool,uint,int (*)(THD*,TABLE_LIST*,HA_CHECK_OPT*),int (handler::*)(THD*,HA_CHECK_OPT*),int (*)(THD*,TABLE_LIST*))" -> "trans_rollback_implicit(THD*)"
"mysql_admin_table(THD*,TABLE_LIST*,HA_CHECK_OPT*,const char*,thr_lock_type,bool,bool,uint,int (*)(THD*,TABLE_LIST*,HA_CHECK_OPT*),int (handler::*)(THD*,HA_CHECK_OPT*),int (*)(THD*,TABLE_LIST*))" -> "String::append(const String&)"
"mysql_admin_table(THD*,TABLE_LIST*,HA_CHECK_OPT*,const char*,thr_lock_type,bool,bool,uint,int (*)(THD*,TABLE_LIST*,HA_CHECK_OPT*),int (handler::*)(THD*,HA_CHECK_OPT*),int (*)(THD*,TABLE_LIST*))" -> "Diagnostics_area::reset_diagnostics_area()"
"mysql_admin_table(THD*,TABLE_LIST*,HA_CHECK_OPT*,const char*,thr_lock_type,bool,bool,uint,int (*)(THD*,TABLE_LIST*,HA_CHECK_OPT*),int (handler::*)(THD*,HA_CHECK_OPT*),int (*)(THD*,TABLE_LIST*))" -> "Query_tables_list::reset_query_tables_list(bool)"
"mysql_admin_table(THD*,TABLE_LIST*,HA_CHECK_OPT*,const char*,thr_lock_type,bool,bool,uint,int (*)(THD*,TABLE_LIST*,HA_CHECK_OPT*),int (handler::*)(THD*,HA_CHECK_OPT*),int (*)(THD*,TABLE_LIST*))" -> "table_not_corrupt_error(uint)"
"mysql_admin_table(THD*,TABLE_LIST*,HA_CHECK_OPT*,const char*,thr_lock_type,bool,bool,uint,int (*)(THD*,TABLE_LIST*,HA_CHECK_OPT*),int (handler::*)(THD*,HA_CHECK_OPT*),int (*)(THD*,TABLE_LIST*))" -> "_current_thd()"
"mysql_admin_table(THD*,TABLE_LIST*,HA_CHECK_OPT*,const char*,thr_lock_type,bool,bool,uint,int (*)(THD*,TABLE_LIST*,HA_CHECK_OPT*),int (handler::*)(THD*,HA_CHECK_OPT*),int (*)(THD*,TABLE_LIST*))" -> "push_warning(THD*,Sql_condition::enum_warning_level,uint,const char*)"
"mysql_admin_table(THD*,TABLE_LIST*,HA_CHECK_OPT*,const char*,thr_lock_type,bool,bool,uint,int (*)(THD*,TABLE_LIST*,HA_CHECK_OPT*),int (handler::*)(THD*,HA_CHECK_OPT*),int (*)(THD*,TABLE_LIST*))" -> "strxmov(char*,const char*,...)"
"mysql_admin_table(THD*,TABLE_LIST*,HA_CHECK_OPT*,const char*,thr_lock_type,bool,bool,uint,int (*)(THD*,TABLE_LIST*,HA_CHECK_OPT*),int (handler::*)(THD*,HA_CHECK_OPT*),int (*)(THD*,TABLE_LIST*))" -> "open_and_lock_tables(THD*,TABLE_LIST*,bool,uint)"
"mysql_admin_table(THD*,TABLE_LIST*,HA_CHECK_OPT*,const char*,thr_lock_type,bool,bool,uint,int (*)(THD*,TABLE_LIST*,HA_CHECK_OPT*),int (handler::*)(THD*,HA_CHECK_OPT*),int (*)(THD*,TABLE_LIST*))" -> "my_error(int,myf,...)"
"mysql_admin_table(THD*,TABLE_LIST*,HA_CHECK_OPT*,const char*,thr_lock_type,bool,bool,uint,int (*)(THD*,TABLE_LIST*,HA_CHECK_OPT*),int (handler::*)(THD*,HA_CHECK_OPT*),int (*)(THD*,TABLE_LIST*))" -> "L>::operator++(int) [with T = const Sql_condition,L = I_P_List<Sql_condition,I_P_List_adapter<Sql_condition,&Sql_condition::next_in_wi,&Sql_condition::prev_in_wi>,I_P_List_counter,I_P_List_fast_push_back<Sql_condition> >]"
"mysql_admin_table(THD*,TABLE_LIST*,HA_CHECK_OPT*,const char*,thr_lock_type,bool,bool,uint,int (*)(THD*,TABLE_LIST*,HA_CHECK_OPT*),int (handler::*)(THD*,HA_CHECK_OPT*),int (*)(THD*,TABLE_LIST*))" -> "Diagnostics_area::is_ok() const"
"mysql_admin_table(THD*,TABLE_LIST*,HA_CHECK_OPT*,const char*,thr_lock_type,bool,bool,uint,int (*)(THD*,TABLE_LIST*,HA_CHECK_OPT*),int (handler::*)(THD*,HA_CHECK_OPT*),int (*)(THD*,TABLE_LIST*))" -> "List<T>::List() [with T = Item]"
"mysql_admin_table(THD*,TABLE_LIST*,HA_CHECK_OPT*,const char*,thr_lock_type,bool,bool,uint,int (*)(THD*,TABLE_LIST*,HA_CHECK_OPT*),int (handler::*)(THD*,HA_CHECK_OPT*),int (*)(THD*,TABLE_LIST*))" -> "THD::vio_ok() const"
"mysql_admin_table(THD*,TABLE_LIST*,HA_CHECK_OPT*,const char*,thr_lock_type,bool,bool,uint,int (*)(THD*,TABLE_LIST*,HA_CHECK_OPT*),int (handler::*)(THD*,HA_CHECK_OPT*),int (*)(THD*,TABLE_LIST*))" -> "tdc_remove_table(THD*,enum_tdc_remove_table_type,const char*,const char*,bool)"
"mysql_admin_table(THD*,TABLE_LIST*,HA_CHECK_OPT*,const char*,thr_lock_type,bool,bool,uint,int (*)(THD*,TABLE_LIST*,HA_CHECK_OPT*),int (handler::*)(THD*,HA_CHECK_OPT*),int (*)(THD*,TABLE_LIST*))" -> "trans_rollback(THD*)"
"mysql_admin_table(THD*,TABLE_LIST*,HA_CHECK_OPT*,const char*,thr_lock_type,bool,bool,uint,int (*)(THD*,TABLE_LIST*,HA_CHECK_OPT*),int (handler::*)(THD*,HA_CHECK_OPT*),int (*)(THD*,TABLE_LIST*))" -> "open_n_lock_single_table(THD*,TABLE_LIST*,thr_lock_type,uint)"
"mysql_admin_table(THD*,TABLE_LIST*,HA_CHECK_OPT*,const char*,thr_lock_type,bool,bool,uint,int (*)(THD*,TABLE_LIST*,HA_CHECK_OPT*),int (handler::*)(THD*,HA_CHECK_OPT*),int (*)(THD*,TABLE_LIST*))" -> "MDL_context::release_transactional_locks()"
"mysql_admin_table(THD*,TABLE_LIST*,HA_CHECK_OPT*,const char*,thr_lock_type,bool,bool,uint,int (*)(THD*,TABLE_LIST*,HA_CHECK_OPT*),int (handler::*)(THD*,HA_CHECK_OPT*),int (*)(THD*,TABLE_LIST*))" -> "trans_rollback_stmt(THD*)"
"mysql_admin_table(THD*,TABLE_LIST*,HA_CHECK_OPT*,const char*,thr_lock_type,bool,bool,uint,int (*)(THD*,TABLE_LIST*,HA_CHECK_OPT*),int (handler::*)(THD*,HA_CHECK_OPT*),int (*)(THD*,TABLE_LIST*))" -> "Item_empty_string::Item_empty_string(const char*,uint,const CHARSET_INFO*)"
"Protocol::store(const char*,const CHARSET_INFO*)" -> "strlen(const char*)"
"trans_commit(THD*)" -> "THD_TRANS::reset_unsafe_rollback_flags()"
"trans_commit(THD*)" -> "trans_check_state(THD*)"
"trans_commit(THD*)" -> "ha_commit_trans(THD*,bool,bool)"
"Diagnostics_area::is_warning_info_empty() const" -> "Warning_info::is_empty() const"
"Diagnostics_area::is_warning_info_empty() const" -> "Diagnostics_area::get_warning_info() const"
"Warning_info::is_empty() const" -> "I>::is_empty() const [with T = Sql_condition,B = I_P_List_adapter<Sql_condition,&Sql_condition::next_in_wi,&Sql_condition::prev_in_wi>,C = I_P_List_counter,I = I_P_List_fast_push_back<Sql_condition>]"
"LEX::cleanup_after_one_table_open()" -> "st_select_lex_unit::next_unit()"
"LEX::cleanup_after_one_table_open()" -> "st_select_lex::first_inner_unit()"
"LEX::cleanup_after_one_table_open()" -> "st_select_lex_unit::cleanup()"
"LEX::cleanup_after_one_table_open()" -> "st_select_lex::cut_subtree()"
"handler::ha_check_for_upgrade(HA_CHECK_OPT*)" -> "handler::check_collation_compatibility()"
"set_part_state(Alter_info*,partition_info*,partition_state)" -> "is_name_in_list(char*,List<char>)"
"set_part_state(Alter_info*,partition_info*,partition_state)" -> "List_iterator<T>::operator++(int) [with T = partition_element]"
"set_part_state(Alter_info*,partition_info*,partition_state)" -> "List_iterator<T>::rewind() [with T = partition_element]"
"set_part_state(Alter_info*,partition_info*,partition_state)" -> "List<T>::List(const List<T>&) [with T = char]"
"set_part_state(Alter_info*,partition_info*,partition_state)" -> "List_iterator<T>::List_iterator(List<T>&) [with T = partition_element]"
"is_name_in_list(char*,List<char>)" -> "List_iterator<T>::List_iterator(List<T>&) [with T = char]"
"is_name_in_list(char*,List<char>)" -> "List_iterator<T>::operator++(int) [with T = char]"
"List<T>::List(const List<T>&) [with T = char]" -> "base_list::base_list(const base_list&)"
"mysql_recreate_table(THD*,TABLE_LIST*,bool)" -> "st_ha_create_information::st_ha_create_information()"
"mysql_recreate_table(THD*,TABLE_LIST*,bool)" -> "Alter_info::Alter_info()"
"mysql_recreate_table(THD*,TABLE_LIST*,bool)" -> "MDL_request::set_type(enum_mdl_type)"
"mysql_recreate_table(THD*,TABLE_LIST*,bool)" -> "mysql_alter_table(THD*,char*,char*,HA_CREATE_INFO*,TABLE_LIST*,Alter_info*,uint,ORDER*,bool)"
"mysql_recreate_table(THD*,TABLE_LIST*,bool)" -> "memset(void*,int,size_t)"
"mysql_alter_table(THD*,char*,char*,HA_CREATE_INFO*,TABLE_LIST*,Alter_info*,uint,ORDER*,bool)" -> "set_column_defaults(TABLE*,List<Create_field>&)"
"mysql_alter_table(THD*,char*,char*,HA_CREATE_INFO*,TABLE_LIST*,Alter_info*,uint,ORDER*,bool)" -> "Diagnostics_area::current_row_for_warning() const"
"mysql_alter_table(THD*,char*,char*,HA_CREATE_INFO*,TABLE_LIST*,Alter_info*,uint,ORDER*,bool)" -> "check_engine(THD*,const char*,const char*,HA_CREATE_INFO*)"
"mysql_alter_table(THD*,char*,char*,HA_CREATE_INFO*,TABLE_LIST*,Alter_info*,uint,ORDER*,bool)" -> "mysql_prepare_alter_table(THD*,TABLE*,HA_CREATE_INFO*,Alter_info*,Alter_table_ctx*)"
"mysql_alter_table(THD*,char*,char*,HA_CREATE_INFO*,TABLE_LIST*,Alter_info*,uint,ORDER*,bool)" -> "Alter_table_ctx::Alter_table_ctx(THD*,TABLE_LIST*,uint,char*,char*)"
"mysql_alter_table(THD*,char*,char*,HA_CREATE_INFO*,TABLE_LIST*,Alter_info*,uint,ORDER*,bool)" -> "TABLE_LIST::init_one_table(const char*,size_t,const char*,size_t,const char*,thr_lock_type)"
"mysql_alter_table(THD*,char*,char*,HA_CREATE_INFO*,TABLE_LIST*,Alter_info*,uint,ORDER*,bool)" -> "Statement::query_length() const"
"mysql_alter_table(THD*,char*,char*,HA_CREATE_INFO*,TABLE_LIST*,Alter_info*,uint,ORDER*,bool)" -> "Locked_tables_list::reopen_tables(THD*)"
"mysql_alter_table(THD*,char*,char*,HA_CREATE_INFO*,TABLE_LIST*,Alter_info*,uint,ORDER*,bool)" -> "THD::is_current_stmt_binlog_format_row() const"
"mysql_alter_table(THD*,char*,char*,HA_CREATE_INFO*,TABLE_LIST*,Alter_info*,uint,ORDER*,bool)" -> "ha_check_storage_engine_flag(const handlerton*,uint32)"
"mysql_alter_table(THD*,char*,char*,HA_CREATE_INFO*,TABLE_LIST*,Alter_info*,uint,ORDER*,bool)" -> "_current_thd()"
"mysql_alter_table(THD*,char*,char*,HA_CREATE_INFO*,TABLE_LIST*,Alter_info*,uint,ORDER*,bool)" -> "mysql_inplace_alter_table(THD*,TABLE_LIST*,TABLE*,TABLE*,Alter_inplace_info*,enum_alter_inplace_result,MDL_request*,Alter_table_ctx*)"
"mysql_alter_table(THD*,char*,char*,HA_CREATE_INFO*,TABLE_LIST*,Alter_info*,uint,ORDER*,bool)" -> "copy_data_between_tables(TABLE*,TABLE*,List<Create_field>&,bool,uint,ORDER*,ha_rows*,ha_rows*,Alter_info::enum_enable_or_disable,Alter_table_ctx*)"
"mysql_alter_table(THD*,char*,char*,HA_CREATE_INFO*,TABLE_LIST*,Alter_info*,uint,ORDER*,bool)" -> "Alter_table_ctx::get_new_path() const"
"mysql_alter_table(THD*,char*,char*,HA_CREATE_INFO*,TABLE_LIST*,Alter_info*,uint,ORDER*,bool)" -> "TABLE::use_all_columns()"
"mysql_alter_table(THD*,char*,char*,HA_CREATE_INFO*,TABLE_LIST*,Alter_info*,uint,ORDER*,bool)" -> "prep_alter_part_table(THD*,TABLE*,Alter_info*,HA_CREATE_INFO*,Alter_table_ctx*,bool*,bool*)"
"mysql_alter_table(THD*,char*,char*,HA_CREATE_INFO*,TABLE_LIST*,Alter_info*,uint,ORDER*,bool)" -> "set_table_default_charset(THD*,HA_CREATE_INFO*,char*)"
"mysql_alter_table(THD*,char*,char*,HA_CREATE_INFO*,TABLE_LIST*,Alter_info*,uint,ORDER*,bool)" -> "mysql_lock_remove(THD*,MYSQL_LOCK*,TABLE*)"
"mysql_alter_table(THD*,char*,char*,HA_CREATE_INFO*,TABLE_LIST*,Alter_info*,uint,ORDER*,bool)" -> "quick_rm_table(THD*,handlerton*,const char*,const char*,uint)"
"mysql_alter_table(THD*,char*,char*,HA_CREATE_INFO*,TABLE_LIST*,Alter_info*,uint,ORDER*,bool)" -> "my_error(int,myf,...)"
"mysql_alter_table(THD*,char*,char*,HA_CREATE_INFO*,TABLE_LIST*,Alter_info*,uint,ORDER*,bool)" -> "TABLE_LIST::TABLE_LIST()"
"mysql_alter_table(THD*,char*,char*,HA_CREATE_INFO*,TABLE_LIST*,Alter_info*,uint,ORDER*,bool)" -> "simple_rename_or_index_change(THD*,TABLE_LIST*,Alter_info::enum_enable_or_disable,Alter_table_ctx*)"
"mysql_alter_table(THD*,char*,char*,HA_CREATE_INFO*,TABLE_LIST*,Alter_info*,uint,ORDER*,bool)" -> "Alter_table_ctx::is_table_renamed() const"
"mysql_alter_table(THD*,char*,char*,HA_CREATE_INFO*,TABLE_LIST*,Alter_info*,uint,ORDER*,bool)" -> "Statement::query() const"
"mysql_alter_table(THD*,char*,char*,HA_CREATE_INFO*,TABLE_LIST*,Alter_info*,uint,ORDER*,bool)" -> "I>::push_front(T*) [with T = MDL_request,B = I_P_List_adapter<MDL_request,&MDL_request::next_in_list,&MDL_request::prev_in_list>,C = I_P_List_counter,I = I_P_List_no_push_back<MDL_request>]"
"mysql_alter_table(THD*,char*,char*,HA_CREATE_INFO*,TABLE_LIST*,Alter_info*,uint,ORDER*,bool)" -> "open_table_uncached(THD*,const char*,const char*,const char*,bool,bool)"
"mysql_alter_table(THD*,char*,char*,HA_CREATE_INFO*,TABLE_LIST*,Alter_info*,uint,ORDER*,bool)" -> "MDL_context::acquire_locks(MDL_request_list*,ulong)"
"mysql_alter_table(THD*,char*,char*,HA_CREATE_INFO*,TABLE_LIST*,Alter_info*,uint,ORDER*,bool)" -> "MDL_request::init(MDL_key::enum_mdl_namespace,const char*,const char*,enum_mdl_type,enum_mdl_duration)"
"mysql_alter_table(THD*,char*,char*,HA_CREATE_INFO*,TABLE_LIST*,Alter_info*,uint,ORDER*,bool)" -> "THD::add_to_binlog_accessed_dbs(const char*)"
"mysql_alter_table(THD*,char*,char*,HA_CREATE_INFO*,TABLE_LIST*,Alter_info*,uint,ORDER*,bool)" -> "Alter_table_prelocking_strategy::Alter_table_prelocking_strategy()"
"mysql_alter_table(THD*,char*,char*,HA_CREATE_INFO*,TABLE_LIST*,Alter_info*,uint,ORDER*,bool)" -> "trans_commit_stmt(THD*)"
"mysql_alter_table(THD*,char*,char*,HA_CREATE_INFO*,TABLE_LIST*,Alter_info*,uint,ORDER*,bool)" -> "THD::is_strict_mode() const"
"mysql_alter_table(THD*,char*,char*,HA_CREATE_INFO*,TABLE_LIST*,Alter_info*,uint,ORDER*,bool)" -> "write_bin_log(THD*,bool,const char*,ulong,bool)"
"mysql_alter_table(THD*,char*,char*,HA_CREATE_INFO*,TABLE_LIST*,Alter_info*,uint,ORDER*,bool)" -> "MDL_request::MDL_request()"
"mysql_alter_table(THD*,char*,char*,HA_CREATE_INFO*,TABLE_LIST*,Alter_info*,uint,ORDER*,bool)" -> "Alter_inplace_info::Alter_inplace_info(HA_CREATE_INFO*,Alter_info*,KEY*,uint,partition_info*,bool)"
"mysql_alter_table(THD*,char*,char*,HA_CREATE_INFO*,TABLE_LIST*,Alter_info*,uint,ORDER*,bool)" -> "create_table_impl(THD*,const char*,const char*,const char*,HA_CREATE_INFO*,Alter_info*,bool,uint,bool,bool*,KEY**,uint*)"
"mysql_alter_table(THD*,char*,char*,HA_CREATE_INFO*,TABLE_LIST*,Alter_info*,uint,ORDER*,bool)" -> "fn_same(char*,const char*,int)"
"mysql_alter_table(THD*,char*,char*,HA_CREATE_INFO*,TABLE_LIST*,Alter_info*,uint,ORDER*,bool)" -> "ErrConvString::ErrConvString(const char*,uint)"
"mysql_alter_table(THD*,char*,char*,HA_CREATE_INFO*,TABLE_LIST*,Alter_info*,uint,ORDER*,bool)" -> "ha_flush_logs(handlerton*)"
"mysql_alter_table(THD*,char*,char*,HA_CREATE_INFO*,TABLE_LIST*,Alter_info*,uint,ORDER*,bool)" -> "make_truncated_value_warning(THD*,Sql_condition::enum_warning_level,ErrConvString,timestamp_type,const char*)"
"mysql_alter_table(THD*,char*,char*,HA_CREATE_INFO*,TABLE_LIST*,Alter_info*,uint,ORDER*,bool)" -> "find_temporary_table(THD*,const char*,const char*)"
"mysql_alter_table(THD*,char*,char*,HA_CREATE_INFO*,TABLE_LIST*,Alter_info*,uint,ORDER*,bool)" -> "__builtin_strcpy(char*,const char*)"
"mysql_alter_table(THD*,char*,char*,HA_CREATE_INFO*,TABLE_LIST*,Alter_info*,uint,ORDER*,bool)" -> "THD::get_stmt_da()"
"mysql_alter_table(THD*,char*,char*,HA_CREATE_INFO*,TABLE_LIST*,Alter_info*,uint,ORDER*,bool)" -> "mysql_unlock_tables(THD*,MYSQL_LOCK*)"
"mysql_alter_table(THD*,char*,char*,HA_CREATE_INFO*,TABLE_LIST*,Alter_info*,uint,ORDER*,bool)" -> "LOGGER::is_log_table_enabled(uint)"
"mysql_alter_table(THD*,char*,char*,HA_CREATE_INFO*,TABLE_LIST*,Alter_info*,uint,ORDER*,bool)" -> "fk_prepare_copy_alter_table(THD*,TABLE*,Alter_info*,Alter_table_ctx*)"
"mysql_alter_table(THD*,char*,char*,HA_CREATE_INFO*,TABLE_LIST*,Alter_info*,uint,ORDER*,bool)" -> "rename_temporary_table(THD*,TABLE*,const char*,const char*)"
"mysql_alter_table(THD*,char*,char*,HA_CREATE_INFO*,TABLE_LIST*,Alter_info*,uint,ORDER*,bool)" -> "wait_while_table_is_used(THD*,TABLE*,ha_extra_function)"
"mysql_alter_table(THD*,char*,char*,HA_CREATE_INFO*,TABLE_LIST*,Alter_info*,uint,ORDER*,bool)" -> "lock_tables(THD*,TABLE_LIST*,uint,uint)"
"mysql_alter_table(THD*,char*,char*,HA_CREATE_INFO*,TABLE_LIST*,Alter_info*,uint,ORDER*,bool)" -> "MDL_context::upgrade_shared_lock(MDL_ticket*,enum_mdl_type,ulong)"
"mysql_alter_table(THD*,char*,char*,HA_CREATE_INFO*,TABLE_LIST*,Alter_info*,uint,ORDER*,bool)" -> "close_temporary_table(THD*,TABLE*,bool,bool)"
"mysql_alter_table(THD*,char*,char*,HA_CREATE_INFO*,TABLE_LIST*,Alter_info*,uint,ORDER*,bool)" -> "Alter_table_ctx::get_tmp_path() const"
"mysql_alter_table(THD*,char*,char*,HA_CREATE_INFO*,TABLE_LIST*,Alter_info*,uint,ORDER*,bool)" -> "upgrade_old_temporal_types(THD*,Alter_info*)"
"mysql_alter_table(THD*,char*,char*,HA_CREATE_INFO*,TABLE_LIST*,Alter_info*,uint,ORDER*,bool)" -> "THD::enter_stage(const PSI_stage_info*,PSI_stage_info*,const char*,const char*,unsigned int)"
"mysql_alter_table(THD*,char*,char*,HA_CREATE_INFO*,TABLE_LIST*,Alter_info*,uint,ORDER*,bool)" -> "Query_cache::invalidate(THD*,TABLE_LIST*,my_bool)"
"mysql_alter_table(THD*,char*,char*,HA_CREATE_INFO*,TABLE_LIST*,Alter_info*,uint,ORDER*,bool)" -> "mysql_rename_table(handlerton*,const char*,const char*,const char*,const char*,uint)"
"mysql_alter_table(THD*,char*,char*,HA_CREATE_INFO*,TABLE_LIST*,Alter_info*,uint,ORDER*,bool)" -> "fill_alter_inplace_info(THD*,TABLE*,bool,Alter_inplace_info*)"
"mysql_alter_table(THD*,char*,char*,HA_CREATE_INFO*,TABLE_LIST*,Alter_info*,uint,ORDER*,bool)" -> "I>::I_P_List() [with T = MDL_request,B = I_P_List_adapter<MDL_request,&MDL_request::next_in_list,&MDL_request::prev_in_list>,C = I_P_List_counter,I = I_P_List_no_push_back<MDL_request>]"
"mysql_alter_table(THD*,char*,char*,HA_CREATE_INFO*,TABLE_LIST*,Alter_info*,uint,ORDER*,bool)" -> "handler::ha_table_flags() const"
"mysql_alter_table(THD*,char*,char*,HA_CREATE_INFO*,TABLE_LIST*,Alter_info*,uint,ORDER*,bool)" -> "ha_create_table(THD*,const char*,const char*,const char*,HA_CREATE_INFO*,bool,bool)"
"mysql_alter_table(THD*,char*,char*,HA_CREATE_INFO*,TABLE_LIST*,Alter_info*,uint,ORDER*,bool)" -> "Alter_table_ctx::get_new_filename() const"
"mysql_alter_table(THD*,char*,char*,HA_CREATE_INFO*,TABLE_LIST*,Alter_info*,uint,ORDER*,bool)" -> "Table_triggers_list::change_table_name(THD*,const char*,const char*,const char*,const char*,const char*)"
"mysql_alter_table(THD*,char*,char*,HA_CREATE_INFO*,TABLE_LIST*,Alter_info*,uint,ORDER*,bool)" -> "TABLE_SHARE::db_type() const"
"mysql_alter_table(THD*,char*,char*,HA_CREATE_INFO*,TABLE_LIST*,Alter_info*,uint,ORDER*,bool)" -> "close_all_tables_for_name(THD*,TABLE_SHARE*,bool,TABLE*)"
"mysql_alter_table(THD*,char*,char*,HA_CREATE_INFO*,TABLE_LIST*,Alter_info*,uint,ORDER*,bool)" -> "open_tables(THD*,TABLE_LIST**,uint*,uint,Prelocking_strategy*)"
"mysql_alter_table(THD*,char*,char*,HA_CREATE_INFO*,TABLE_LIST*,Alter_info*,uint,ORDER*,bool)" -> "update_altered_table(const Alter_inplace_info&,TABLE*)"
"mysql_alter_table(THD*,char*,char*,HA_CREATE_INFO*,TABLE_LIST*,Alter_info*,uint,ORDER*,bool)" -> "promote_first_timestamp_column(List<Create_field>*)"
"mysql_alter_table(THD*,char*,char*,HA_CREATE_INFO*,TABLE_LIST*,Alter_info*,uint,ORDER*,bool)" -> "my_ok(THD*,ulonglong,ulonglong,const char*)"
"mysql_alter_table(THD*,char*,char*,HA_CREATE_INFO*,TABLE_LIST*,Alter_info*,uint,ORDER*,bool)" -> "intern_close_table(TABLE*)"
"mysql_alter_table(THD*,char*,char*,HA_CREATE_INFO*,TABLE_LIST*,Alter_info*,uint,ORDER*,bool)" -> "is_inplace_alter_impossible(TABLE*,HA_CREATE_INFO*,const Alter_info*)"
"mysql_alter_table(THD*,char*,char*,HA_CREATE_INFO*,TABLE_LIST*,Alter_info*,uint,ORDER*,bool)" -> "fast_alter_partition_table(THD*,TABLE*,Alter_info*,HA_CREATE_INFO*,TABLE_LIST*,char*,const char*)"
"mysql_alter_table(THD*,char*,char*,HA_CREATE_INFO*,TABLE_LIST*,Alter_info*,uint,ORDER*,bool)" -> "Alter_inplace_info::report_unsupported_error(const char*,const char*)"
"mysql_alter_table(THD*,char*,char*,HA_CREATE_INFO*,TABLE_LIST*,Alter_info*,uint,ORDER*,bool)" -> "check_if_log_table(size_t,const char*,size_t,const char*,bool)"
"mysql_alter_table(THD*,char*,char*,HA_CREATE_INFO*,TABLE_LIST*,Alter_info*,uint,ORDER*,bool)" -> "Diagnostics_area::current_statement_warn_count() const"
"mysql_alter_table(THD*,char*,char*,HA_CREATE_INFO*,TABLE_LIST*,Alter_info*,uint,ORDER*,bool)" -> "Alter_table_ctx::is_database_changed() const"
"mysql_alter_table(THD*,char*,char*,HA_CREATE_INFO*,TABLE_LIST*,Alter_info*,uint,ORDER*,bool)" -> "access(const char*,int)"
"mysql_alter_table(THD*,char*,char*,HA_CREATE_INFO*,TABLE_LIST*,Alter_info*,uint,ORDER*,bool)" -> "alter_table_manage_keys(TABLE*,int,Alter_info::enum_enable_or_disable)"
"mysql_alter_table(THD*,char*,char*,HA_CREATE_INFO*,TABLE_LIST*,Alter_info*,uint,ORDER*,bool)" -> "TABLE::column_bitmaps_set_no_signal(MY_BITMAP*,MY_BITMAP*)"
"mysql_alter_table(THD*,char*,char*,HA_CREATE_INFO*,TABLE_LIST*,Alter_info*,uint,ORDER*,bool)" -> "sql_print_warning(const char*,...)"
"mysql_alter_table(THD*,char*,char*,HA_CREATE_INFO*,TABLE_LIST*,Alter_info*,uint,ORDER*,bool)" -> "Locked_tables_list::unlink_all_closed_tables(THD*,MYSQL_LOCK*,size_t)"
"mysql_alter_table(THD*,char*,char*,HA_CREATE_INFO*,TABLE_LIST*,Alter_info*,uint,ORDER*,bool)" -> "trans_commit_implicit(THD*)"
"mysql_alter_table(THD*,char*,char*,HA_CREATE_INFO*,TABLE_LIST*,Alter_info*,uint,ORDER*,bool)" -> "open_temporary_table(THD*,TABLE_LIST*)"
"mysql_alter_table(THD*,char*,char*,HA_CREATE_INFO*,TABLE_LIST*,Alter_info*,uint,ORDER*,bool)" -> "my_snprintf(char*,size_t,const char*,...)"
"mysql_alter_table(THD*,char*,char*,HA_CREATE_INFO*,TABLE_LIST*,Alter_info*,uint,ORDER*,bool)" -> "MDL_ticket::downgrade_lock(enum_mdl_type)"
"mysql_alter_table(THD*,char*,char*,HA_CREATE_INFO*,TABLE_LIST*,Alter_info*,uint,ORDER*,bool)" -> "strlen(const char*)"
"mysql_alter_table(THD*,char*,char*,HA_CREATE_INFO*,TABLE_LIST*,Alter_info*,uint,ORDER*,bool)" -> "MDL_context::release_all_locks_for_name(MDL_ticket*)"
"set_column_defaults(TABLE*,List<Create_field>&)" -> "List_iterator<T>::operator++(int) [with T = Create_field]"
"set_column_defaults(TABLE*,List<Create_field>&)" -> "memcpy(void*,const void*,size_t)"
"set_column_defaults(TABLE*,List<Create_field>&)" -> "Field::evaluate_insert_default_function()"
"set_column_defaults(TABLE*,List<Create_field>&)" -> "List_iterator<T>::List_iterator(List<T>&) [with T = Create_field]"
"List_iterator<T>::operator++(int) [with T = Create_field]" -> "base_list_iterator::next()"
"Field::evaluate_insert_default_function()" -> "Field::has_insert_default_function() const"
"Field::evaluate_insert_default_function()" -> "Item_func_now_local::store_in(Field*)"
"List_iterator<T>::List_iterator(List<T>&) [with T = Create_field]" -> "base_list_iterator::base_list_iterator(base_list&)"
"check_engine(THD*,const char*,const char*,HA_CREATE_INFO*)" -> "_current_thd()"
"check_engine(THD*,const char*,const char*,HA_CREATE_INFO*)" -> "ha_check_if_supported_system_table(handlerton*,const char*,const char*)"
"check_engine(THD*,const char*,const char*,HA_CREATE_INFO*)" -> "ha_legacy_type(const handlerton*)"
"check_engine(THD*,const char*,const char*,HA_CREATE_INFO*)" -> "ha_checktype(THD*,legacy_db_type,bool,bool)"
"check_engine(THD*,const char*,const char*,HA_CREATE_INFO*)" -> "my_error(int,myf,...)"
"check_engine(THD*,const char*,const char*,HA_CREATE_INFO*)" -> "ha_resolve_storage_engine_name(const handlerton*)"
"check_engine(THD*,const char*,const char*,HA_CREATE_INFO*)" -> "ha_check_storage_engine_flag(const handlerton*,uint32)"
"check_engine(THD*,const char*,const char*,HA_CREATE_INFO*)" -> "push_warning_printf(THD*,Sql_condition::enum_warning_level,uint,const char*,...)"
"ha_check_if_supported_system_table(handlerton*,const char*,const char*)" -> "plugin_foreach_with_mask(THD*,my_bool (*)(THD*,plugin_ref,void*),int,uint,void*)"
"ha_check_if_supported_system_table(handlerton*,const char*,const char*)" -> "strcmp(const char*,const char*)"
"mysql_prepare_alter_table(THD*,TABLE*,HA_CREATE_INFO*,Alter_info*,Alter_table_ctx*)" -> "memcpy(void*,const void*,size_t)"
"mysql_prepare_alter_table(THD*,TABLE*,HA_CREATE_INFO*,Alter_info*,Alter_table_ctx*)" -> "List_iterator<T>::after(T*) [with T = Create_field]"
"mysql_prepare_alter_table(THD*,TABLE*,HA_CREATE_INFO*,Alter_info*,Alter_table_ctx*)" -> "List<T>::head() [with T = Alter_drop]"
"mysql_prepare_alter_table(THD*,TABLE*,HA_CREATE_INFO*,Alter_info*,Alter_table_ctx*)" -> "_current_thd()"
"mysql_prepare_alter_table(THD*,TABLE*,HA_CREATE_INFO*,Alter_info*,Alter_table_ctx*)" -> "List_iterator<T>::operator++(int) [with T = Alter_drop]"
"mysql_prepare_alter_table(THD*,TABLE*,HA_CREATE_INFO*,Alter_info*,Alter_table_ctx*)" -> "List_iterator<T>::remove() [with T = Alter_column]"
"mysql_prepare_alter_table(THD*,TABLE*,HA_CREATE_INFO*,Alter_info*,Alter_table_ctx*)" -> "List_iterator<T>::operator++(int) [with T = Alter_column]"
"mysql_prepare_alter_table(THD*,TABLE*,HA_CREATE_INFO*,Alter_info*,Alter_table_ctx*)" -> "memset(void*,int,size_t)"
"mysql_prepare_alter_table(THD*,TABLE*,HA_CREATE_INFO*,Alter_info*,Alter_table_ctx*)" -> "Field::type_can_have_key_part(enum_field_types)"
"mysql_prepare_alter_table(THD*,TABLE*,HA_CREATE_INFO*,Alter_info*,Alter_table_ctx*)" -> "List<T>::head() [with T = Alter_column]"
"mysql_prepare_alter_table(THD*,TABLE*,HA_CREATE_INFO*,Alter_info*,Alter_table_ctx*)" -> "Key::Key(Key::Keytype,const char*,size_t,KEY_CREATE_INFO*,bool,List<Key_part_spec>&)"
"mysql_prepare_alter_table(THD*,TABLE*,HA_CREATE_INFO*,Alter_info*,Alter_table_ctx*)" -> "List<T>::List() [with T = Key_part_spec]"
"mysql_prepare_alter_table(THD*,TABLE*,HA_CREATE_INFO*,Alter_info*,Alter_table_ctx*)" -> "List_iterator<T>::List_iterator(List<T>&) [with T = Alter_column]"
"mysql_prepare_alter_table(THD*,TABLE*,HA_CREATE_INFO*,Alter_info*,Alter_table_ctx*)" -> "List<T>::push_back(T*) [with T = Create_field]"
"mysql_prepare_alter_table(THD*,TABLE*,HA_CREATE_INFO*,Alter_info*,Alter_table_ctx*)" -> "List_iterator<T>::rewind() [with T = Create_field]"
"mysql_prepare_alter_table(THD*,TABLE*,HA_CREATE_INFO*,Alter_info*,Alter_table_ctx*)" -> "Key_part_spec::Key_part_spec(const char*,size_t,uint)"
"mysql_prepare_alter_table(THD*,TABLE*,HA_CREATE_INFO*,Alter_info*,Alter_table_ctx*)" -> "List<T>::push_front(T*) [with T = Create_field]"
"mysql_prepare_alter_table(THD*,TABLE*,HA_CREATE_INFO*,Alter_info*,Alter_table_ctx*)" -> "base_list::swap(base_list&)"
"mysql_prepare_alter_table(THD*,TABLE*,HA_CREATE_INFO*,Alter_info*,Alter_table_ctx*)" -> "List_iterator<T>::List_iterator(List<T>&) [with T = Create_field]"
"mysql_prepare_alter_table(THD*,TABLE*,HA_CREATE_INFO*,Alter_info*,Alter_table_ctx*)" -> "strlen(const char*)"
"mysql_prepare_alter_table(THD*,TABLE*,HA_CREATE_INFO*,Alter_info*,Alter_table_ctx*)" -> "List<T>::push_back(T*) [with T = Key]"
"mysql_prepare_alter_table(THD*,TABLE*,HA_CREATE_INFO*,Alter_info*,Alter_table_ctx*)" -> "List<T>::List() [with T = Create_field]"
"mysql_prepare_alter_table(THD*,TABLE*,HA_CREATE_INFO*,Alter_info*,Alter_table_ctx*)" -> "List<T>::push_back(T*) [with T = Key_part_spec]"
"mysql_prepare_alter_table(THD*,TABLE*,HA_CREATE_INFO*,Alter_info*,Alter_table_ctx*)" -> "List_iterator<T>::rewind() [with T = Alter_drop]"
"mysql_prepare_alter_table(THD*,TABLE*,HA_CREATE_INFO*,Alter_info*,Alter_table_ctx*)" -> "my_message(uint,const char*,myf)"
"mysql_prepare_alter_table(THD*,TABLE*,HA_CREATE_INFO*,Alter_info*,Alter_table_ctx*)" -> "my_error(int,myf,...)"
"mysql_prepare_alter_table(THD*,TABLE*,HA_CREATE_INFO*,Alter_info*,Alter_table_ctx*)" -> "blob_length_by_type(enum_field_types)"
"mysql_prepare_alter_table(THD*,TABLE*,HA_CREATE_INFO*,Alter_info*,Alter_table_ctx*)" -> "base_list::empty()"
"mysql_prepare_alter_table(THD*,TABLE*,HA_CREATE_INFO*,Alter_info*,Alter_table_ctx*)" -> "List_iterator<T>::rewind() [with T = Alter_column]"
"mysql_prepare_alter_table(THD*,TABLE*,HA_CREATE_INFO*,Alter_info*,Alter_table_ctx*)" -> "List<T>::List() [with T = Key]"
"mysql_prepare_alter_table(THD*,TABLE*,HA_CREATE_INFO*,Alter_info*,Alter_table_ctx*)" -> "List_iterator<T>::List_iterator(List<T>&) [with T = Key]"
"mysql_prepare_alter_table(THD*,TABLE*,HA_CREATE_INFO*,Alter_info*,Alter_table_ctx*)" -> "List_iterator<T>::operator++(int) [with T = Create_field]"
"mysql_prepare_alter_table(THD*,TABLE*,HA_CREATE_INFO*,Alter_info*,Alter_table_ctx*)" -> "List_iterator<T>::operator++(int) [with T = Key]"
"mysql_prepare_alter_table(THD*,TABLE*,HA_CREATE_INFO*,Alter_info*,Alter_table_ctx*)" -> "List_iterator<T>::remove() [with T = Alter_drop]"
"mysql_prepare_alter_table(THD*,TABLE*,HA_CREATE_INFO*,Alter_info*,Alter_table_ctx*)" -> "List_iterator<T>::remove() [with T = Create_field]"
"mysql_prepare_alter_table(THD*,TABLE*,HA_CREATE_INFO*,Alter_info*,Alter_table_ctx*)" -> "List_iterator<T>::List_iterator(List<T>&) [with T = Alter_drop]"
"mysql_prepare_alter_table(THD*,TABLE*,HA_CREATE_INFO*,Alter_info*,Alter_table_ctx*)" -> "Create_field::Create_field(Field*,Field*)"
"List_iterator<T>::after(T*) [with T = Create_field]" -> "base_list_iterator::after(void*)"
"List<T>::head() [with T = Alter_drop]" -> "base_list::head()"
"List_iterator<T>::operator++(int) [with T = Alter_drop]" -> "base_list_iterator::next()"
"List_iterator<T>::remove() [with T = Alter_column]" -> "base_list_iterator::remove()"
"List_iterator<T>::operator++(int) [with T = Alter_column]" -> "base_list_iterator::next()"
"List<T>::head() [with T = Alter_column]" -> "base_list::head()"
"Key::Key(Key::Keytype,const char*,size_t,KEY_CREATE_INFO*,bool,List<Key_part_spec>&)" -> "List<T>::List(const List<T>&) [with T = Key_part_spec]"
"Key::Key(Key::Keytype,const char*,size_t,KEY_CREATE_INFO*,bool,List<Key_part_spec>&)" -> "Sql_alloc::Sql_alloc()"
"List_iterator<T>::List_iterator(List<T>&) [with T = Alter_column]" -> "base_list_iterator::base_list_iterator(base_list&)"
"List_iterator<T>::rewind() [with T = Create_field]" -> "base_list_iterator::rewind()"
"Key_part_spec::Key_part_spec(const char*,size_t,uint)" -> "Sql_alloc::Sql_alloc()"
"List<T>::push_front(T*) [with T = Create_field]" -> "base_list::push_front(void*)"
"List_iterator<T>::rewind() [with T = Alter_drop]" -> "base_list_iterator::rewind()"
"List_iterator<T>::rewind() [with T = Alter_column]" -> "base_list_iterator::rewind()"
"List_iterator<T>::List_iterator(List<T>&) [with T = Key]" -> "base_list_iterator::base_list_iterator(base_list&)"
"List_iterator<T>::operator++(int) [with T = Key]" -> "base_list_iterator::next()"
"List_iterator<T>::remove() [with T = Alter_drop]" -> "base_list_iterator::remove()"
"List_iterator<T>::remove() [with T = Create_field]" -> "base_list_iterator::remove()"
"List_iterator<T>::List_iterator(List<T>&) [with T = Alter_drop]" -> "base_list_iterator::base_list_iterator(base_list&)"
"Create_field::Create_field(Field*,Field*)" -> "real_type_with_now_as_default(enum_field_types)"
"Create_field::Create_field(Field*,Field*)" -> "Field::is_real_null(my_ptrdiff_t) const"
"Create_field::Create_field(Field*,Field*)" -> "String::ptr() const"
"Create_field::Create_field(Field*,Field*)" -> "Field::val_str(String*)"
"Create_field::Create_field(Field*,Field*)" -> "String::length() const"
"Create_field::Create_field(Field*,Field*)" -> "String::String(char*,uint32,const CHARSET_INFO*)"
"Create_field::Create_field(Field*,Field*)" -> "List<T>::List() [with T = String]"
"Create_field::Create_field(Field*,Field*)" -> "push_warning_printf(THD*,Sql_condition::enum_warning_level,uint,const char*,...)"
"Create_field::Create_field(Field*,Field*)" -> "Item_string::Item_string(const char*,uint,const CHARSET_INFO*,Derivation,uint)"
"Create_field::Create_field(Field*,Field*)" -> "Field::has_insert_default_function() const"
"Create_field::Create_field(Field*,Field*)" -> "Field::has_update_default_function() const"
"Create_field::Create_field(Field*,Field*)" -> "_current_thd()"
"Create_field::Create_field(Field*,Field*)" -> "sql_strmake(const char*,size_t)"
"Create_field::Create_field(Field*,Field*)" -> "Sql_alloc::Sql_alloc()"
"Alter_table_ctx::Alter_table_ctx(THD*,TABLE_LIST*,uint,char*,char*)" -> "__builtin_strcpy(char*,const char*)"
"Alter_table_ctx::Alter_table_ctx(THD*,TABLE_LIST*,uint,char*,char*)" -> "Alter_table_ctx::is_database_changed() const"
"Alter_table_ctx::Alter_table_ctx(THD*,TABLE_LIST*,uint,char*,char*)" -> "build_tmptable_filename(THD*,char*,size_t)"
"Alter_table_ctx::Alter_table_ctx(THD*,TABLE_LIST*,uint,char*,char*)" -> "my_snprintf(char*,size_t,const char*,...)"
"Alter_table_ctx::Alter_table_ctx(THD*,TABLE_LIST*,uint,char*,char*)" -> "build_table_filename(char*,size_t,const char*,const char*,const char*,uint)"
"build_tmptable_filename(THD*,char*,size_t)" -> "strnmov(char*,const char*,size_t)"
"build_tmptable_filename(THD*,char*,size_t)" -> "my_snprintf(char*,size_t,const char*,...)"
"build_tmptable_filename(THD*,char*,size_t)" -> "unpack_filename(char*,const char*)"
"build_tmptable_filename(THD*,char*,size_t)" -> "my_tmpdir(MY_TMPDIR*)"
"mysql_inplace_alter_table(THD*,TABLE_LIST*,TABLE*,TABLE*,Alter_inplace_info*,enum_alter_inplace_result,MDL_request*,Alter_table_ctx*)" -> "Locked_tables_list::reopen_tables(THD*)"
"mysql_inplace_alter_table(THD*,TABLE_LIST*,TABLE*,TABLE*,Alter_inplace_info*,enum_alter_inplace_result,MDL_request*,Alter_table_ctx*)" -> "mysql_rename_table(handlerton*,const char*,const char*,const char*,const char*,uint)"
"mysql_inplace_alter_table(THD*,TABLE_LIST*,TABLE*,TABLE*,Alter_inplace_info*,enum_alter_inplace_result,MDL_request*,Alter_table_ctx*)" -> "handler::ha_inplace_alter_table(TABLE*,Alter_inplace_info*)"
"mysql_inplace_alter_table(THD*,TABLE_LIST*,TABLE*,TABLE*,Alter_inplace_info*,enum_alter_inplace_result,MDL_request*,Alter_table_ctx*)" -> "MDL_context::upgrade_shared_lock(MDL_ticket*,enum_mdl_type,ulong)"
"mysql_inplace_alter_table(THD*,TABLE_LIST*,TABLE*,TABLE*,Alter_inplace_info*,enum_alter_inplace_result,MDL_request*,Alter_table_ctx*)" -> "tdc_remove_table(THD*,enum_tdc_remove_table_type,const char*,const char*,bool)"
"mysql_inplace_alter_table(THD*,TABLE_LIST*,TABLE*,TABLE*,Alter_inplace_info*,enum_alter_inplace_result,MDL_request*,Alter_table_ctx*)" -> "handler::ha_commit_inplace_alter_table(TABLE*,Alter_inplace_info*,bool)"
"mysql_inplace_alter_table(THD*,TABLE_LIST*,TABLE*,TABLE*,Alter_inplace_info*,enum_alter_inplace_result,MDL_request*,Alter_table_ctx*)" -> "close_temporary_table(THD*,TABLE*,bool,bool)"
"mysql_inplace_alter_table(THD*,TABLE_LIST*,TABLE*,TABLE*,Alter_inplace_info*,enum_alter_inplace_result,MDL_request*,Alter_table_ctx*)" -> "close_thread_table(THD*,TABLE**)"
"mysql_inplace_alter_table(THD*,TABLE_LIST*,TABLE*,TABLE*,Alter_inplace_info*,enum_alter_inplace_result,MDL_request*,Alter_table_ctx*)" -> "Locked_tables_list::unlink_all_closed_tables(THD*,MYSQL_LOCK*,size_t)"
"mysql_inplace_alter_table(THD*,TABLE_LIST*,TABLE*,TABLE*,Alter_inplace_info*,enum_alter_inplace_result,MDL_request*,Alter_table_ctx*)" -> "Alter_table_ctx::is_table_renamed() const"
"mysql_inplace_alter_table(THD*,TABLE_LIST*,TABLE*,TABLE*,Alter_inplace_info*,enum_alter_inplace_result,MDL_request*,Alter_table_ctx*)" -> "wait_while_table_is_used(THD*,TABLE*,ha_extra_function)"
"mysql_inplace_alter_table(THD*,TABLE_LIST*,TABLE*,TABLE*,Alter_inplace_info*,enum_alter_inplace_result,MDL_request*,Alter_table_ctx*)" -> "TABLE_SHARE::db_type() const"
"mysql_inplace_alter_table(THD*,TABLE_LIST*,TABLE*,TABLE*,Alter_inplace_info*,enum_alter_inplace_result,MDL_request*,Alter_table_ctx*)" -> "lock_tables(THD*,TABLE_LIST*,uint,uint)"
"mysql_inplace_alter_table(THD*,TABLE_LIST*,TABLE*,TABLE*,Alter_inplace_info*,enum_alter_inplace_result,MDL_request*,Alter_table_ctx*)" -> "Open_table_context::Open_table_context(THD*,uint)"
"mysql_inplace_alter_table(THD*,TABLE_LIST*,TABLE*,TABLE*,Alter_inplace_info*,enum_alter_inplace_result,MDL_request*,Alter_table_ctx*)" -> "handler::ha_prepare_inplace_alter_table(TABLE*,Alter_inplace_info*)"
"mysql_inplace_alter_table(THD*,TABLE_LIST*,TABLE*,TABLE*,Alter_inplace_info*,enum_alter_inplace_result,MDL_request*,Alter_table_ctx*)" -> "MDL_ticket::downgrade_lock(enum_mdl_type)"
"mysql_inplace_alter_table(THD*,TABLE_LIST*,TABLE*,TABLE*,Alter_inplace_info*,enum_alter_inplace_result,MDL_request*,Alter_table_ctx*)" -> "Table_triggers_list::change_table_name(THD*,const char*,const char*,const char*,const char*,const char*)"
"mysql_inplace_alter_table(THD*,TABLE_LIST*,TABLE*,TABLE*,Alter_inplace_info*,enum_alter_inplace_result,MDL_request*,Alter_table_ctx*)" -> "close_all_tables_for_name(THD*,TABLE_SHARE*,bool,TABLE*)"
"mysql_inplace_alter_table(THD*,TABLE_LIST*,TABLE*,TABLE*,Alter_inplace_info*,enum_alter_inplace_result,MDL_request*,Alter_table_ctx*)" -> "open_table(THD*,TABLE_LIST*,Open_table_context*)"
"mysql_inplace_alter_table(THD*,TABLE_LIST*,TABLE*,TABLE*,Alter_inplace_info*,enum_alter_inplace_result,MDL_request*,Alter_table_ctx*)" -> "THD::enter_stage(const PSI_stage_info*,PSI_stage_info*,const char*,const char*,unsigned int)"
"mysql_inplace_alter_table(THD*,TABLE_LIST*,TABLE*,TABLE*,Alter_inplace_info*,enum_alter_inplace_result,MDL_request*,Alter_table_ctx*)" -> "quick_rm_table(THD*,handlerton*,const char*,const char*,uint)"
"mysql_inplace_alter_table(THD*,TABLE_LIST*,TABLE*,TABLE*,Alter_inplace_info*,enum_alter_inplace_result,MDL_request*,Alter_table_ctx*)" -> "handler::ha_notify_table_changed()"
"mysql_rename_table(handlerton*,const char*,const char*,const char*,const char*,uint)" -> "handler::ha_create_handler_files(const char*,const char*,int,HA_CREATE_INFO*)"
"mysql_rename_table(handlerton*,const char*,const char*,const char*,const char*,uint)" -> "__builtin_strcpy(char*,const char*)"
"mysql_rename_table(handlerton*,const char*,const char*,const char*,const char*,uint)" -> "my_error(int,myf,...)"
"mysql_rename_table(handlerton*,const char*,const char*,const char*,const char*,uint)" -> "rename_file_ext(const char*,const char*,const char*)"
"mysql_rename_table(handlerton*,const char*,const char*,const char*,const char*,uint)" -> "build_table_filename(char*,size_t,const char*,const char*,const char*,uint)"
"mysql_rename_table(handlerton*,const char*,const char*,const char*,const char*,uint)" -> "get_new_handler(TABLE_SHARE*,MEM_ROOT*,handlerton*)"
"mysql_rename_table(handlerton*,const char*,const char*,const char*,const char*,uint)" -> "_current_thd()"
"mysql_rename_table(handlerton*,const char*,const char*,const char*,const char*,uint)" -> "build_table_filename(char*,size_t,const char*,const char*,const char*,uint,bool*)"
"mysql_rename_table(handlerton*,const char*,const char*,const char*,const char*,uint)" -> "my_strerror(char*,size_t,int)"
"mysql_rename_table(handlerton*,const char*,const char*,const char*,const char*,uint)" -> "handler::ha_rename_table(const char*,const char*)"
"mysql_rename_table(handlerton*,const char*,const char*,const char*,const char*,uint)" -> "handler::ha_table_flags() const"
"mysql_rename_table(handlerton*,const char*,const char*,const char*,const char*,uint)" -> "_my_thread_var()"
"handler::ha_create_handler_files(const char*,const char*,int,HA_CREATE_INFO*)" -> "handler::mark_trx_read_write()"
"rename_file_ext(const char*,const char*,const char*)" -> "strxmov(char*,const char*,...)"
"rename_file_ext(const char*,const char*,const char*)" -> "inline_mysql_file_rename(const char*,const char*,myf)"
"inline_mysql_file_rename(const char*,const char*,myf)" -> "my_rename(const char*,const char*,myf)"
"handler::ha_rename_table(const char*,const char*)" -> "handler::mark_trx_read_write()"
"close_temporary_table(THD*,TABLE*,bool,bool)" -> "modify_slave_open_temp_tables(THD*,int)"
"close_temporary_table(THD*,TABLE*,bool,bool)" -> "close_temporary(TABLE*,bool,bool)"
"Alter_table_ctx::is_table_renamed() const" -> "Alter_table_ctx::is_database_changed() const"
"handler::ha_prepare_inplace_alter_table(TABLE*,Alter_inplace_info*)" -> "handler::mark_trx_read_write()"
"Table_triggers_list::change_table_name(THD*,const char*,const char*,const char*,const char*,const char*)" -> "Table_triggers_list::change_table_name_in_trignames(const char*,const char*,LEX_STRING*,LEX_STRING*)"
"Table_triggers_list::change_table_name(THD*,const char*,const char*,const char*,const char*,const char*)" -> "Table_triggers_list::change_table_name_in_triggers(THD*,const char*,const char*,LEX_STRING*,LEX_STRING*)"
"Table_triggers_list::change_table_name(THD*,const char*,const char*,const char*,const char*,const char*)" -> "init_sql_alloc(MEM_ROOT*,uint,uint)"
"Table_triggers_list::change_table_name(THD*,const char*,const char*,const char*,const char*,const char*)" -> "free_root(MEM_ROOT*,myf)"
"Table_triggers_list::change_table_name(THD*,const char*,const char*,const char*,const char*,const char*)" -> "memset(void*,int,size_t)"
"Table_triggers_list::change_table_name(THD*,const char*,const char*,const char*,const char*,const char*)" -> "my_error(int,myf,...)"
"Table_triggers_list::change_table_name(THD*,const char*,const char*,const char*,const char*,const char*)" -> "Table_triggers_list::check_n_load(THD*,const char*,const char*,TABLE*,bool)"
"Table_triggers_list::change_table_name(THD*,const char*,const char*,const char*,const char*,const char*)" -> "check_n_cut_mysql50_prefix(const char*,char*,uint)"
"Table_triggers_list::change_table_name(THD*,const char*,const char*,const char*,const char*,const char*)" -> "TABLE::TABLE()"
"Table_triggers_list::change_table_name(THD*,const char*,const char*,const char*,const char*,const char*)" -> "Table_triggers_list::check_for_broken_triggers()"
"Table_triggers_list::change_table_name(THD*,const char*,const char*,const char*,const char*,const char*)" -> "strlen(const char*)"
"Table_triggers_list::change_table_name_in_trignames(const char*,const char*,LEX_STRING*,LEX_STRING*)" -> "rm_trigname_file(char*,const char*,const char*)"
"Table_triggers_list::change_table_name_in_trignames(const char*,const char*,LEX_STRING*,LEX_STRING*)" -> "build_table_filename(char*,size_t,const char*,const char*,const char*,uint)"
"Table_triggers_list::change_table_name_in_trignames(const char*,const char*,LEX_STRING*,LEX_STRING*)" -> "List_iterator_fast<T>::operator++(int) [with T = st_mysql_lex_string]"
"Table_triggers_list::change_table_name_in_trignames(const char*,const char*,LEX_STRING*,LEX_STRING*)" -> "List_iterator_fast<T>::List_iterator_fast(List<T>&) [with T = st_mysql_lex_string]"
"Table_triggers_list::change_table_name_in_trignames(const char*,const char*,LEX_STRING*,LEX_STRING*)" -> "sql_create_definition_file(const LEX_STRING*,const LEX_STRING*,const LEX_STRING*,uchar*,File_option*)"
"rm_trigname_file(char*,const char*,const char*)" -> "build_table_filename(char*,size_t,const char*,const char*,const char*,uint)"
"rm_trigname_file(char*,const char*,const char*)" -> "inline_mysql_file_delete(const char*,myf)"
"sql_create_definition_file(const LEX_STRING*,const LEX_STRING*,const LEX_STRING*,uchar*,File_option*)" -> "inline_mysql_file_close(File,myf)"
"sql_create_definition_file(const LEX_STRING*,const LEX_STRING*,const LEX_STRING*,uchar*,File_option*)" -> "end_io_cache(IO_CACHE*)"
"sql_create_definition_file(const LEX_STRING*,const LEX_STRING*,const LEX_STRING*,uchar*,File_option*)" -> "my_b_append(IO_CACHE*,const uchar*,size_t)"
"sql_create_definition_file(const LEX_STRING*,const LEX_STRING*,const LEX_STRING*,uchar*,File_option*)" -> "inline_mysql_file_create(const char*,int,int,myf)"
"sql_create_definition_file(const LEX_STRING*,const LEX_STRING*,const LEX_STRING*,uchar*,File_option*)" -> "init_io_cache(IO_CACHE*,File,size_t,cache_type,my_off_t,pbool,myf)"
"sql_create_definition_file(const LEX_STRING*,const LEX_STRING*,const LEX_STRING*,uchar*,File_option*)" -> "fn_format(char*,const char*,const char*,const char*,uint)"
"sql_create_definition_file(const LEX_STRING*,const LEX_STRING*,const LEX_STRING*,uchar*,File_option*)" -> "write_parameter(IO_CACHE*,uchar*,File_option*)"
"sql_create_definition_file(const LEX_STRING*,const LEX_STRING*,const LEX_STRING*,uchar*,File_option*)" -> "strxnmov(char*,size_t,const char*,...)"
"sql_create_definition_file(const LEX_STRING*,const LEX_STRING*,const LEX_STRING*,uchar*,File_option*)" -> "strlen(const char*)"
"sql_create_definition_file(const LEX_STRING*,const LEX_STRING*,const LEX_STRING*,uchar*,File_option*)" -> "inline_mysql_file_rename(const char*,const char*,myf)"
"sql_create_definition_file(const LEX_STRING*,const LEX_STRING*,const LEX_STRING*,uchar*,File_option*)" -> "memcpy(void*,const void*,size_t)"
"sql_create_definition_file(const LEX_STRING*,const LEX_STRING*,const LEX_STRING*,uchar*,File_option*)" -> "inline_mysql_file_sync(File,myf)"
"write_parameter(IO_CACHE*,uchar*,File_option*)" -> "String::set(ulonglong,const CHARSET_INFO*)"
"write_parameter(IO_CACHE*,uchar*,File_option*)" -> "get_date(char*,int,time_t)"
"write_parameter(IO_CACHE*,uchar*,File_option*)" -> "my_time(myf)"
"write_parameter(IO_CACHE*,uchar*,File_option*)" -> "List_iterator_fast<T>::List_iterator_fast(List<T>&) [with T = st_mysql_lex_string]"
"write_parameter(IO_CACHE*,uchar*,File_option*)" -> "my_b_append(IO_CACHE*,const uchar*,size_t)"
"write_parameter(IO_CACHE*,uchar*,File_option*)" -> "List_iterator_fast<T>::List_iterator_fast(List<T>&) [with T = long long unsigned int]"
"write_parameter(IO_CACHE*,uchar*,File_option*)" -> "String::String(char*,uint32,const CHARSET_INFO*)"
"write_parameter(IO_CACHE*,uchar*,File_option*)" -> "write_escaped_string(IO_CACHE*,LEX_STRING*)"
"write_parameter(IO_CACHE*,uchar*,File_option*)" -> "List_iterator_fast<T>::operator++(int) [with T = st_mysql_lex_string]"
"write_parameter(IO_CACHE*,uchar*,File_option*)" -> "String::ptr() const"
"write_parameter(IO_CACHE*,uchar*,File_option*)" -> "String::length() const"
"write_parameter(IO_CACHE*,uchar*,File_option*)" -> "List_iterator_fast<T>::operator++(int) [with T = long long unsigned int]"
"String::set(ulonglong,const CHARSET_INFO*)" -> "String::alloc(uint32)"
"String::set(ulonglong,const CHARSET_INFO*)" -> "String::set_int(longlong,bool,const CHARSET_INFO*)"
"write_escaped_string(IO_CACHE*,LEX_STRING*)" -> "my_b_append(IO_CACHE*,const uchar*,size_t)"
"Table_triggers_list::change_table_name_in_triggers(THD*,const char*,const char*,LEX_STRING*,LEX_STRING*)" -> "List_iterator_fast<T>::operator++(int) [with T = long long unsigned int]"
"Table_triggers_list::change_table_name_in_triggers(THD*,const char*,const char*,LEX_STRING*,LEX_STRING*)" -> "String::String()"
"Table_triggers_list::change_table_name_in_triggers(THD*,const char*,const char*,LEX_STRING*,LEX_STRING*)" -> "List_iterator_fast<T>::operator++(int) [with T = st_mysql_lex_string]"
"Table_triggers_list::change_table_name_in_triggers(THD*,const char*,const char*,LEX_STRING*,LEX_STRING*)" -> "append_identifier(THD*,String*,const char*,uint)"
"Table_triggers_list::change_table_name_in_triggers(THD*,const char*,const char*,LEX_STRING*,LEX_STRING*)" -> "memdup_root(MEM_ROOT*,const void*,size_t)"
"Table_triggers_list::change_table_name_in_triggers(THD*,const char*,const char*,LEX_STRING*,LEX_STRING*)" -> "rm_trigger_file(char*,const char*,const char*)"
"Table_triggers_list::change_table_name_in_triggers(THD*,const char*,const char*,LEX_STRING*,LEX_STRING*)" -> "String::append(const char*,uint32)"
"Table_triggers_list::change_table_name_in_triggers(THD*,const char*,const char*,LEX_STRING*,LEX_STRING*)" -> "String::length(uint32)"
"Table_triggers_list::change_table_name_in_triggers(THD*,const char*,const char*,LEX_STRING*,LEX_STRING*)" -> "List_iterator_fast<T>::List_iterator_fast(List<T>&) [with T = long long unsigned int]"
"Table_triggers_list::change_table_name_in_triggers(THD*,const char*,const char*,LEX_STRING*,LEX_STRING*)" -> "save_trigger_file(Table_triggers_list*,const char*,const char*)"
"Table_triggers_list::change_table_name_in_triggers(THD*,const char*,const char*,LEX_STRING*,LEX_STRING*)" -> "List_iterator_fast<T>::List_iterator_fast(List<T>&) [with T = st_mysql_lex_string]"
"Table_triggers_list::change_table_name_in_triggers(THD*,const char*,const char*,LEX_STRING*,LEX_STRING*)" -> "String::ptr() const"
"Table_triggers_list::change_table_name_in_triggers(THD*,const char*,const char*,LEX_STRING*,LEX_STRING*)" -> "String::length() const"
"rm_trigger_file(char*,const char*,const char*)" -> "build_table_filename(char*,size_t,const char*,const char*,const char*,uint)"
"rm_trigger_file(char*,const char*,const char*)" -> "inline_mysql_file_delete(const char*,myf)"
"save_trigger_file(Table_triggers_list*,const char*,const char*)" -> "sql_create_definition_file(const LEX_STRING*,const LEX_STRING*,const LEX_STRING*,uchar*,File_option*)"
"save_trigger_file(Table_triggers_list*,const char*,const char*)" -> "build_table_filename(char*,size_t,const char*,const char*,const char*,uint)"
"quick_rm_table(THD*,handlerton*,const char*,const char*,uint)" -> "build_table_filename(char*,size_t,const char*,const char*,const char*,uint)"
"quick_rm_table(THD*,handlerton*,const char*,const char*,uint)" -> "get_new_handler(TABLE_SHARE*,MEM_ROOT*,handlerton*)"
"quick_rm_table(THD*,handlerton*,const char*,const char*,uint)" -> "_current_thd()"
"quick_rm_table(THD*,handlerton*,const char*,const char*,uint)" -> "handler::ha_create_handler_files(const char*,const char*,int,HA_CREATE_INFO*)"
"quick_rm_table(THD*,handlerton*,const char*,const char*,uint)" -> "ha_delete_table(THD*,handlerton*,const char*,const char*,const char*,bool)"
"quick_rm_table(THD*,handlerton*,const char*,const char*,uint)" -> "inline_mysql_file_delete(const char*,myf)"
"ha_delete_table(THD*,handlerton*,const char*,const char*,const char*,bool)" -> "Ha_delete_table_error_handler::Ha_delete_table_error_handler()"
"ha_delete_table(THD*,handlerton*,const char*,const char*,const char*,bool)" -> "THD::push_internal_handler(Internal_error_handler*)"
"ha_delete_table(THD*,handlerton*,const char*,const char*,const char*,bool)" -> "THD::pop_internal_handler()"
"ha_delete_table(THD*,handlerton*,const char*,const char*,const char*,bool)" -> "TABLE_SHARE::TABLE_SHARE()"
"ha_delete_table(THD*,handlerton*,const char*,const char*,const char*,bool)" -> "memset(void*,int,size_t)"
"ha_delete_table(THD*,handlerton*,const char*,const char*,const char*,bool)" -> "handler::ha_delete_table(const char*)"
"ha_delete_table(THD*,handlerton*,const char*,const char*,const char*,bool)" -> "strlen(const char*)"
"ha_delete_table(THD*,handlerton*,const char*,const char*,const char*,bool)" -> "get_new_handler(TABLE_SHARE*,MEM_ROOT*,handlerton*)"
"ha_delete_table(THD*,handlerton*,const char*,const char*,const char*,bool)" -> "push_warning(THD*,Sql_condition::enum_warning_level,uint,const char*)"
"ha_delete_table(THD*,handlerton*,const char*,const char*,const char*,bool)" -> "TABLE::TABLE()"
"ha_delete_table(THD*,handlerton*,const char*,const char*,const char*,bool)" -> "get_canonical_filename(handler*,const char*,char*)"
"Ha_delete_table_error_handler::Ha_delete_table_error_handler()" -> "Internal_error_handler::Internal_error_handler()"
"copy_data_between_tables(TABLE*,TABLE*,List<Create_field>&,bool,uint,ORDER*,ha_rows*,ha_rows*,Alter_info::enum_enable_or_disable,Alter_table_ctx*)" -> "set_column_defaults(TABLE*,List<Create_field>&)"
"copy_data_between_tables(TABLE*,TABLE*,List<Create_field>&,bool,uint,ORDER*,ha_rows*,ha_rows*,Alter_info::enum_enable_or_disable,Alter_table_ctx*)" -> "setup_order(THD*,Ref_ptr_array,TABLE_LIST*,List<Item>&,List<Item>&,ORDER*)"
"copy_data_between_tables(TABLE*,TABLE*,List<Create_field>&,bool,uint,ORDER*,ha_rows*,ha_rows*,Alter_info::enum_enable_or_disable,Alter_table_ctx*)" -> "print_keydup_error(TABLE*,KEY*,const char*,myf)"
"copy_data_between_tables(TABLE*,TABLE*,List<Create_field>&,bool,uint,ORDER*,ha_rows*,ha_rows*,Alter_info::enum_enable_or_disable,Alter_table_ctx*)" -> "handler::ha_release_auto_increment()"
"copy_data_between_tables(TABLE*,TABLE*,List<Create_field>&,bool,uint,ORDER*,ha_rows*,ha_rows*,Alter_info::enum_enable_or_disable,Alter_table_ctx*)" -> "List_iterator<T>::operator++(int) [with T = Create_field]"
"copy_data_between_tables(TABLE*,TABLE*,List<Create_field>&,bool,uint,ORDER*,ha_rows*,ha_rows*,Alter_info::enum_enable_or_disable,Alter_table_ctx*)" -> "mysql_trans_commit_alter_copy_data(THD*)"
"copy_data_between_tables(TABLE*,TABLE*,List<Create_field>&,bool,uint,ORDER*,ha_rows*,ha_rows*,Alter_info::enum_enable_or_disable,Alter_table_ctx*)" -> "my_snprintf(char*,size_t,const char*,...)"
"copy_data_between_tables(TABLE*,TABLE*,List<Create_field>&,bool,uint,ORDER*,ha_rows*,ha_rows*,Alter_info::enum_enable_or_disable,Alter_table_ctx*)" -> "Diagnostics_area::inc_current_row_for_warning()"
"copy_data_between_tables(TABLE*,TABLE*,List<Create_field>&,bool,uint,ORDER*,ha_rows*,ha_rows*,Alter_info::enum_enable_or_disable,Alter_table_ctx*)" -> "THD::get_stmt_da()"
"copy_data_between_tables(TABLE*,TABLE*,List<Create_field>&,bool,uint,ORDER*,ha_rows*,ha_rows*,Alter_info::enum_enable_or_disable,Alter_table_ctx*)" -> "filesort(THD*,TABLE*,Filesort*,bool,ha_rows*,ha_rows*)"
"copy_data_between_tables(TABLE*,TABLE*,List<Create_field>&,bool,uint,ORDER*,ha_rows*,ha_rows*,Alter_info::enum_enable_or_disable,Alter_table_ctx*)" -> "List_iterator<T>::List_iterator(List<T>&) [with T = Create_field]"
"copy_data_between_tables(TABLE*,TABLE*,List<Create_field>&,bool,uint,ORDER*,ha_rows*,ha_rows*,Alter_info::enum_enable_or_disable,Alter_table_ctx*)" -> "_my_thread_var()"
"copy_data_between_tables(TABLE*,TABLE*,List<Create_field>&,bool,uint,ORDER*,ha_rows*,ha_rows*,Alter_info::enum_enable_or_disable,Alter_table_ctx*)" -> "end_read_record(READ_RECORD*)"
"copy_data_between_tables(TABLE*,TABLE*,List<Create_field>&,bool,uint,ORDER*,ha_rows*,ha_rows*,Alter_info::enum_enable_or_disable,Alter_table_ctx*)" -> "Copy_field::Copy_field()"
"copy_data_between_tables(TABLE*,TABLE*,List<Create_field>&,bool,uint,ORDER*,ha_rows*,ha_rows*,Alter_info::enum_enable_or_disable,Alter_table_ctx*)" -> "st_select_lex::setup_ref_array(THD*,uint)"
"copy_data_between_tables(TABLE*,TABLE*,List<Create_field>&,bool,uint,ORDER*,ha_rows*,ha_rows*,Alter_info::enum_enable_or_disable,Alter_table_ctx*)" -> "my_malloc(size_t,myf)"
"copy_data_between_tables(TABLE*,TABLE*,List<Create_field>&,bool,uint,ORDER*,ha_rows*,ha_rows*,Alter_info::enum_enable_or_disable,Alter_table_ctx*)" -> "THD::is_strict_mode() const"
"copy_data_between_tables(TABLE*,TABLE*,List<Create_field>&,bool,uint,ORDER*,ha_rows*,ha_rows*,Alter_info::enum_enable_or_disable,Alter_table_ctx*)" -> "push_warning(THD*,Sql_condition::enum_warning_level,uint,const char*)"
"copy_data_between_tables(TABLE*,TABLE*,List<Create_field>&,bool,uint,ORDER*,ha_rows*,ha_rows*,Alter_info::enum_enable_or_disable,Alter_table_ctx*)" -> "mysql_trans_prepare_alter_copy_data(THD*)"
"copy_data_between_tables(TABLE*,TABLE*,List<Create_field>&,bool,uint,ORDER*,ha_rows*,ha_rows*,Alter_info::enum_enable_or_disable,Alter_table_ctx*)" -> "READ_RECORD::READ_RECORD()"
"copy_data_between_tables(TABLE*,TABLE*,List<Create_field>&,bool,uint,ORDER*,ha_rows*,ha_rows*,Alter_info::enum_enable_or_disable,Alter_table_ctx*)" -> "handler::ha_start_bulk_insert(ha_rows)"
"copy_data_between_tables(TABLE*,TABLE*,List<Create_field>&,bool,uint,ORDER*,ha_rows*,ha_rows*,Alter_info::enum_enable_or_disable,Alter_table_ctx*)" -> "handler::ha_external_lock(THD*,int)"
"copy_data_between_tables(TABLE*,TABLE*,List<Create_field>&,bool,uint,ORDER*,ha_rows*,ha_rows*,Alter_info::enum_enable_or_disable,Alter_table_ctx*)" -> "Filesort::Filesort(ORDER*,ha_rows,SQL_SELECT*)"
"copy_data_between_tables(TABLE*,TABLE*,List<Create_field>&,bool,uint,ORDER*,ha_rows*,ha_rows*,Alter_info::enum_enable_or_disable,Alter_table_ctx*)" -> "handler::ha_end_bulk_insert()"
"copy_data_between_tables(TABLE*,TABLE*,List<Create_field>&,bool,uint,ORDER*,ha_rows*,ha_rows*,Alter_info::enum_enable_or_disable,Alter_table_ctx*)" -> "TABLE_LIST::TABLE_LIST()"
"copy_data_between_tables(TABLE*,TABLE*,List<Create_field>&,bool,uint,ORDER*,ha_rows*,ha_rows*,Alter_info::enum_enable_or_disable,Alter_table_ctx*)" -> "TABLE::use_all_columns()"
"copy_data_between_tables(TABLE*,TABLE*,List<Create_field>&,bool,uint,ORDER*,ha_rows*,ha_rows*,Alter_info::enum_enable_or_disable,Alter_table_ctx*)" -> "memset(void*,int,size_t)"
"copy_data_between_tables(TABLE*,TABLE*,List<Create_field>&,bool,uint,ORDER*,ha_rows*,ha_rows*,Alter_info::enum_enable_or_disable,Alter_table_ctx*)" -> "_current_thd()"
"copy_data_between_tables(TABLE*,TABLE*,List<Create_field>&,bool,uint,ORDER*,ha_rows*,ha_rows*,Alter_info::enum_enable_or_disable,Alter_table_ctx*)" -> "Diagnostics_area::reset_current_row_for_warning()"
"copy_data_between_tables(TABLE*,TABLE*,List<Create_field>&,bool,uint,ORDER*,ha_rows*,ha_rows*,Alter_info::enum_enable_or_disable,Alter_table_ctx*)" -> "my_error(int,myf,...)"
"copy_data_between_tables(TABLE*,TABLE*,List<Create_field>&,bool,uint,ORDER*,ha_rows*,ha_rows*,Alter_info::enum_enable_or_disable,Alter_table_ctx*)" -> "handler::get_dup_key(int)"
"copy_data_between_tables(TABLE*,TABLE*,List<Create_field>&,bool,uint,ORDER*,ha_rows*,ha_rows*,Alter_info::enum_enable_or_disable,Alter_table_ctx*)" -> "List<T>::List() [with T = Item]"
"copy_data_between_tables(TABLE*,TABLE*,List<Create_field>&,bool,uint,ORDER*,ha_rows*,ha_rows*,Alter_info::enum_enable_or_disable,Alter_table_ctx*)" -> "THD::send_kill_message() const"
"copy_data_between_tables(TABLE*,TABLE*,List<Create_field>&,bool,uint,ORDER*,ha_rows*,ha_rows*,Alter_info::enum_enable_or_disable,Alter_table_ctx*)" -> "Copy_field::set(Field*,Field*,bool)"
"copy_data_between_tables(TABLE*,TABLE*,List<Create_field>&,bool,uint,ORDER*,ha_rows*,ha_rows*,Alter_info::enum_enable_or_disable,Alter_table_ctx*)" -> "free_io_cache(TABLE*)"
"copy_data_between_tables(TABLE*,TABLE*,List<Create_field>&,bool,uint,ORDER*,ha_rows*,ha_rows*,Alter_info::enum_enable_or_disable,Alter_table_ctx*)" -> "init_read_record(READ_RECORD*,THD*,TABLE*,SQL_SELECT*,int,bool,bool)"
"copy_data_between_tables(TABLE*,TABLE*,List<Create_field>&,bool,uint,ORDER*,ha_rows*,ha_rows*,Alter_info::enum_enable_or_disable,Alter_table_ctx*)" -> "handler::ha_write_row(uchar*)"
"copy_data_between_tables(TABLE*,TABLE*,List<Create_field>&,bool,uint,ORDER*,ha_rows*,ha_rows*,Alter_info::enum_enable_or_disable,Alter_table_ctx*)" -> "handler::restore_auto_increment(ulonglong)"
"copy_data_between_tables(TABLE*,TABLE*,List<Create_field>&,bool,uint,ORDER*,ha_rows*,ha_rows*,Alter_info::enum_enable_or_disable,Alter_table_ctx*)" -> "alter_table_manage_keys(TABLE*,int,Alter_info::enum_enable_or_disable)"
"print_keydup_error(TABLE*,KEY*,const char*,myf)" -> "String::String(char*,uint32,const CHARSET_INFO*)"
"print_keydup_error(TABLE*,KEY*,const char*,myf)" -> "my_printf_error(uint,const char*,myf,...)"
"print_keydup_error(TABLE*,KEY*,const char*,myf)" -> "strlen(const char*)"
"print_keydup_error(TABLE*,KEY*,const char*,myf)" -> "String::copy(const char*,uint32,const CHARSET_INFO*)"
"print_keydup_error(TABLE*,KEY*,const char*,myf)" -> "String::c_ptr_safe()"
"print_keydup_error(TABLE*,KEY*,const char*,myf)" -> "String::length(uint32)"
"print_keydup_error(TABLE*,KEY*,const char*,myf)" -> "key_unpack(String*,TABLE*,KEY*)"
"print_keydup_error(TABLE*,KEY*,const char*,myf)" -> "String::c_ptr()"
"print_keydup_error(TABLE*,KEY*,const char*,myf)" -> "String::append(const char*,uint32)"
"print_keydup_error(TABLE*,KEY*,const char*,myf)" -> "String::length() const"
"key_unpack(String*,TABLE*,KEY*)" -> "String::append(const char*,uint32)"
"key_unpack(String*,TABLE*,KEY*)" -> "dbug_tmp_restore_column_map(MY_BITMAP*,my_bitmap_map*)"
"key_unpack(String*,TABLE*,KEY*)" -> "field_unpack(String*,Field*,const uchar*,uint,bool)"
"key_unpack(String*,TABLE*,KEY*)" -> "String::length() const"
"key_unpack(String*,TABLE*,KEY*)" -> "String::append(char)"
"key_unpack(String*,TABLE*,KEY*)" -> "dbug_tmp_use_all_columns(TABLE*,MY_BITMAP*)"
"key_unpack(String*,TABLE*,KEY*)" -> "String::length(uint32)"
"field_unpack(String*,Field*,const uchar*,uint,bool)" -> "String::length() const"
"field_unpack(String*,Field*,const uchar*,uint,bool)" -> "std::min(const _Tp&,const _Tp&) [with _Tp = unsigned int]"
"field_unpack(String*,Field*,const uchar*,uint,bool)" -> "String::String()"
"field_unpack(String*,Field*,const uchar*,uint,bool)" -> "ErrConvString::ptr()"
"field_unpack(String*,Field*,const uchar*,uint,bool)" -> "ErrConvString::ErrConvString(String*)"
"field_unpack(String*,Field*,const uchar*,uint,bool)" -> "Field::val_str(String*)"
"field_unpack(String*,Field*,const uchar*,uint,bool)" -> "String::append(const char*)"
"field_unpack(String*,Field*,const uchar*,uint,bool)" -> "String::append(const char*,uint32)"
"field_unpack(String*,Field*,const uchar*,uint,bool)" -> "String::ptr() const"
"field_unpack(String*,Field*,const uchar*,uint,bool)" -> "Field::is_null(my_ptrdiff_t) const"
"field_unpack(String*,Field*,const uchar*,uint,bool)" -> "String::length(uint32)"
"mysql_trans_commit_alter_copy_data(THD*)" -> "ha_enable_transaction(THD*,bool)"
"mysql_trans_commit_alter_copy_data(THD*)" -> "trans_commit_implicit(THD*)"
"mysql_trans_commit_alter_copy_data(THD*)" -> "trans_commit_stmt(THD*)"
"ha_enable_transaction(THD*,bool)" -> "trans_commit_implicit(THD*)"
"ha_enable_transaction(THD*,bool)" -> "ha_commit_trans(THD*,bool,bool)"
"trans_commit_stmt(THD*)" -> "ha_commit_trans(THD*,bool,bool)"
"trans_commit_stmt(THD*)" -> "THD_TRANS::reset()"
"trans_commit_stmt(THD*)" -> "THD::st_transactions::merge_unsafe_rollback_flags()"
"trans_commit_stmt(THD*)" -> "THD::in_active_multi_stmt_transaction() const"
"filesort(THD*,TABLE*,Filesort*,bool,ha_rows*,ha_rows*)" -> "my_b_flush_io_cache(IO_CACHE*,int)"
"filesort(THD*,TABLE*,Filesort*,bool,ha_rows*,ha_rows*)" -> "_current_thd()"
"filesort(THD*,TABLE*,Filesort*,bool,ha_rows*,ha_rows*)" -> "ha_release_temporary_latches(THD*)"
"filesort(THD*,TABLE*,Filesort*,bool,ha_rows*,ha_rows*)" -> "Opt_trace_array::Opt_trace_array(Opt_trace_context*,const char*,Opt_trace_context::feature_value)"
"filesort(THD*,TABLE*,Filesort*,bool,ha_rows*,ha_rows*)" -> "Filesort_info::free_sort_buffer()"
"filesort(THD*,TABLE*,Filesort*,bool,ha_rows*,ha_rows*)" -> "my_free(void*)"
"filesort(THD*,TABLE*,Filesort*,bool,ha_rows*,ha_rows*)" -> "THD::inc_status_sort_range()"
"filesort(THD*,TABLE*,Filesort*,bool,ha_rows*,ha_rows*)" -> "check_if_pq_applicable(Opt_trace_context*,Sort_param*,Filesort_info*,TABLE*,ha_rows,ulong)"
"filesort(THD*,TABLE*,Filesort*,bool,ha_rows*,ha_rows*)" -> "std::max(const _Tp&,const _Tp&) [with _Tp = long unsigned int]"
"filesort(THD*,TABLE*,Filesort*,bool,ha_rows*,ha_rows*)" -> "Opt_trace_struct::add_alnum(const char*,const char*)"
"filesort(THD*,TABLE*,Filesort*,bool,ha_rows*,ha_rows*)" -> "std::min(const _Tp&,const _Tp&) [with _Tp = long long unsigned int]"
"filesort(THD*,TABLE*,Filesort*,bool,ha_rows*,ha_rows*)" -> "Opt_trace_struct::add(const char*,uint)"
"filesort(THD*,TABLE*,Filesort*,bool,ha_rows*,ha_rows*)" -> "save_index(Sort_param*,uint,Filesort_info*)"
"filesort(THD*,TABLE*,Filesort*,bool,ha_rows*,ha_rows*)" -> "Key_type>::Bounded_queue() [with Element_type = unsigned char,Key_type = unsigned char]"
"filesort(THD*,TABLE*,Filesort*,bool,ha_rows*,ha_rows*)" -> "Item_subselect::is_uncacheable() const"
"filesort(THD*,TABLE*,Filesort*,bool,ha_rows*,ha_rows*)" -> "free_io_cache(TABLE*)"
"filesort(THD*,TABLE*,Filesort*,bool,ha_rows*,ha_rows*)" -> "my_error(int,myf,...)"
"filesort(THD*,TABLE*,Filesort*,bool,ha_rows*,ha_rows*)" -> "Statement::query() const"
"filesort(THD*,TABLE*,Filesort*,bool,ha_rows*,ha_rows*)" -> "Diagnostics_area::message() const"
"filesort(THD*,TABLE*,Filesort*,bool,ha_rows*,ha_rows*)" -> "open_cached_file(IO_CACHE*,const char*,const char*,size_t,myf)"
"filesort(THD*,TABLE*,Filesort*,bool,ha_rows*,ha_rows*)" -> "sql_print_warning(const char*,...)"
"filesort(THD*,TABLE*,Filesort*,bool,ha_rows*,ha_rows*)" -> "sortlength(THD*,SORT_FIELD*,uint,bool*)"
"filesort(THD*,TABLE*,Filesort*,bool,ha_rows*,ha_rows*)" -> "Opt_trace_struct::add(const char*,ulonglong)"
"filesort(THD*,TABLE*,Filesort*,bool,ha_rows*,ha_rows*)" -> "Key_type>::init(ha_rows,bool,Bounded_queue<Element_type,Key_type>::compare_function,size_t,Bounded_queue<Element_type,Key_type>::keymaker_function,Sort_param*,Key_type**) [with Element_type = unsigned char,Key_type = unsigned char,ha_rows = long long unsigned int,Bounded_queue<Element_type,Key_type>::compare_function = int (*)(long unsigned int*,unsigned char**,unsigned char**),size_t = long unsigned int,Bounded_queue<Element_type,Key_type>::keymaker_function = void (*)(Sort_param*,unsigned char*,unsigned char*)]"
"filesort(THD*,TABLE*,Filesort*,bool,ha_rows*,ha_rows*)" -> "read_buffpek_from_file(IO_CACHE*,uint,uchar*)"
"filesort(THD*,TABLE*,Filesort*,bool,ha_rows*,ha_rows*)" -> "my_tmpdir(MY_TMPDIR*)"
"filesort(THD*,TABLE*,Filesort*,bool,ha_rows*,ha_rows*)" -> "THD::inc_status_sort_rows(ha_rows)"
"filesort(THD*,TABLE*,Filesort*,bool,ha_rows*,ha_rows*)" -> "my_printf_error(uint,const char*,myf,...)"
"filesort(THD*,TABLE*,Filesort*,bool,ha_rows*,ha_rows*)" -> "Filesort_info::get_sort_keys()"
"filesort(THD*,TABLE*,Filesort*,bool,ha_rows*,ha_rows*)" -> "Filesort_info::init_record_pointers()"
"filesort(THD*,TABLE*,Filesort*,bool,ha_rows*,ha_rows*)" -> "Filesort_info::operator=(const Filesort_info&)"
"filesort(THD*,TABLE*,Filesort*,bool,ha_rows*,ha_rows*)" -> "Opt_trace_struct::add(const char*,ulong)"
"filesort(THD*,TABLE*,Filesort*,bool,ha_rows*,ha_rows*)" -> "THD::get_stmt_da()"
"filesort(THD*,TABLE*,Filesort*,bool,ha_rows*,ha_rows*)" -> "Sort_param::Sort_param()"
"filesort(THD*,TABLE*,Filesort*,bool,ha_rows*,ha_rows*)" -> "merge_many_buff(Sort_param*,uchar*,BUFFPEK*,uint*,IO_CACHE*)"
"filesort(THD*,TABLE*,Filesort*,bool,ha_rows*,ha_rows*)" -> "Sort_param::init_for_filesort(uint,TABLE*,ulong,ha_rows,bool)"
"filesort(THD*,TABLE*,Filesort*,bool,ha_rows*,ha_rows*)" -> "Filesort_info::sort_buffer_size() const"
"filesort(THD*,TABLE*,Filesort*,bool,ha_rows*,ha_rows*)" -> "reinit_io_cache(IO_CACHE*,cache_type,my_off_t,pbool,pbool)"
"filesort(THD*,TABLE*,Filesort*,bool,ha_rows*,ha_rows*)" -> "find_all_keys(Sort_param*,SQL_SELECT*,Filesort_info*,IO_CACHE*,IO_CACHE*,Bounded_queue<unsigned char,unsigned char>*,ha_rows*)"
"filesort(THD*,TABLE*,Filesort*,bool,ha_rows*,ha_rows*)" -> "close_cached_file(IO_CACHE*)"
"filesort(THD*,TABLE*,Filesort*,bool,ha_rows*,ha_rows*)" -> "trace_filesort_information(Opt_trace_context*,const SORT_FIELD*,uint)"
"filesort(THD*,TABLE*,Filesort*,bool,ha_rows*,ha_rows*)" -> "Filesort::make_sortorder()"
"filesort(THD*,TABLE*,Filesort*,bool,ha_rows*,ha_rows*)" -> "my_malloc(size_t,myf)"
"filesort(THD*,TABLE*,Filesort*,bool,ha_rows*,ha_rows*)" -> "Filesort_info::alloc_sort_buffer(uint,uint)"
"filesort(THD*,TABLE*,Filesort*,bool,ha_rows*,ha_rows*)" -> "THD::inc_status_sort_scan()"
"filesort(THD*,TABLE*,Filesort*,bool,ha_rows*,ha_rows*)" -> "Opt_trace_object::Opt_trace_object(Opt_trace_context*,Opt_trace_context::feature_value)"
"filesort(THD*,TABLE*,Filesort*,bool,ha_rows*,ha_rows*)" -> "Key_type>::is_initialized() const [with Element_type = unsigned char,Key_type = unsigned char]"
"filesort(THD*,TABLE*,Filesort*,bool,ha_rows*,ha_rows*)" -> "THD::killed_errno() const"
"filesort(THD*,TABLE*,Filesort*,bool,ha_rows*,ha_rows*)" -> "merge_index(Sort_param*,uchar*,BUFFPEK*,uint,IO_CACHE*,IO_CACHE*)"
"filesort(THD*,TABLE*,Filesort*,bool,ha_rows*,ha_rows*)" -> "Opt_trace_object::Opt_trace_object(Opt_trace_context*,const char*,Opt_trace_context::feature_value)"
"check_if_pq_applicable(Opt_trace_context*,Sort_param*,Filesort_info*,TABLE*,ha_rows,ulong)" -> "Opt_trace_struct::add(const char*,double)"
"check_if_pq_applicable(Opt_trace_context*,Sort_param*,Filesort_info*,TABLE*,ha_rows,ulong)" -> "Opt_trace_struct::add(const char*,bool)"
"check_if_pq_applicable(Opt_trace_context*,Sort_param*,Filesort_info*,TABLE*,ha_rows,ulong)" -> "get_merge_many_buffs_cost_fast(ha_rows,ha_rows,uint)"
"check_if_pq_applicable(Opt_trace_context*,Sort_param*,Filesort_info*,TABLE*,ha_rows,ulong)" -> "Opt_trace_struct::add(const char*,ulonglong)"
"check_if_pq_applicable(Opt_trace_context*,Sort_param*,Filesort_info*,TABLE*,ha_rows,ulong)" -> "Filesort_info::alloc_sort_buffer(uint,uint)"
"check_if_pq_applicable(Opt_trace_context*,Sort_param*,Filesort_info*,TABLE*,ha_rows,ulong)" -> "Opt_trace_struct::add(const char*,uint)"
"check_if_pq_applicable(Opt_trace_context*,Sort_param*,Filesort_info*,TABLE*,ha_rows,ulong)" -> "my_free(void*)"
"check_if_pq_applicable(Opt_trace_context*,Sort_param*,Filesort_info*,TABLE*,ha_rows,ulong)" -> "Opt_trace_struct::add(const char*,ulong)"
"check_if_pq_applicable(Opt_trace_context*,Sort_param*,Filesort_info*,TABLE*,ha_rows,ulong)" -> "log(double)"
"check_if_pq_applicable(Opt_trace_context*,Sort_param*,Filesort_info*,TABLE*,ha_rows,ulong)" -> "Opt_trace_struct::add_alnum(const char*,const char*)"
"check_if_pq_applicable(Opt_trace_context*,Sort_param*,Filesort_info*,TABLE*,ha_rows,ulong)" -> "Opt_trace_object::Opt_trace_object(Opt_trace_context*,const char*,Opt_trace_context::feature_value)"
"check_if_pq_applicable(Opt_trace_context*,Sort_param*,Filesort_info*,TABLE*,ha_rows,ulong)" -> "Filesort_info::get_sort_keys()"
"Opt_trace_struct::add(const char*,double)" -> "__builtin_expect(long int,long int)"
"Opt_trace_struct::add(const char*,double)" -> "Opt_trace_struct::do_add(const char*,double)"
"Opt_trace_struct::do_add(const char*,double)" -> "Opt_trace_stmt::add(const char*,const char*,size_t,bool,bool)"
"Opt_trace_struct::do_add(const char*,double)" -> "strlen(const char*)"
"Opt_trace_struct::do_add(const char*,double)" -> "my_snprintf(char*,size_t,const char*,...)"
"get_merge_many_buffs_cost_fast(ha_rows,ha_rows,uint)" -> "log(double)"
"get_merge_many_buffs_cost_fast(ha_rows,ha_rows,uint)" -> "anonymous}::get_merge_cost(ha_rows,ha_rows,uint)"
"anonymous}::get_merge_cost(ha_rows,ha_rows,uint)" -> "log(double)"
"Filesort_info::alloc_sort_buffer(uint,uint)" -> "Filesort_buffer::alloc_sort_buffer(uint,uint)"
"Filesort_buffer::alloc_sort_buffer(uint,uint)" -> "Bounds_checked_array<Element_type>::size() const [with Element_type = unsigned char*,size_t = long unsigned int]"
"Filesort_buffer::alloc_sort_buffer(uint,uint)" -> "Filesort_buffer::free_sort_buffer()"
"Filesort_buffer::alloc_sort_buffer(uint,uint)" -> "Bounds_checked_array<Element_type>::array() const [with Element_type = unsigned char*]"
"Filesort_buffer::alloc_sort_buffer(uint,uint)" -> "Bounds_checked_array<Element_type>::Bounds_checked_array(Element_type*,size_t) [with Element_type = unsigned char*,size_t = long unsigned int]"
"Filesort_buffer::alloc_sort_buffer(uint,uint)" -> "my_malloc(size_t,myf)"
"Filesort_buffer::alloc_sort_buffer(uint,uint)" -> "Bounds_checked_array<Element_type>::is_null() const [with Element_type = unsigned char*]"
"Filesort_info::get_sort_keys()" -> "Filesort_buffer::get_sort_keys()"
"Filesort_buffer::get_sort_keys()" -> "Bounds_checked_array<Element_type>::array() const [with Element_type = unsigned char*]"
"save_index(Sort_param*,uint,Filesort_info*)" -> "my_malloc(size_t,myf)"
"save_index(Sort_param*,uint,Filesort_info*)" -> "Filesort_info::get_sort_keys()"
"save_index(Sort_param*,uint,Filesort_info*)" -> "memcpy(void*,const void*,size_t)"
"save_index(Sort_param*,uint,Filesort_info*)" -> "Filesort_info::sort_buffer(Sort_param*,uint)"
"Filesort_info::sort_buffer(Sort_param*,uint)" -> "Filesort_buffer::sort_buffer(const Sort_param*,uint)"
"Filesort_buffer::sort_buffer(const Sort_param*,uint)" -> "radixsort_is_appliccable(uint,size_t)"
"Filesort_buffer::sort_buffer(const Sort_param*,uint)" -> "anonymous}::try_reserve(std::pair<_Tp*,long int>*,ptrdiff_t) [with type = unsigned char*,size_t = long unsigned int,ptrdiff_t = long int]"
"Filesort_buffer::sort_buffer(const Sort_param*,uint)" -> "std::stable_sort(_RAIter,_RAIter,_Compare) [with _RAIter = unsigned char**,_Compare = {anonymous}::Mem_compare]"
"Filesort_buffer::sort_buffer(const Sort_param*,uint)" -> "(* get_ptr_compare(size_t))(const void*,const void*,const void*)"
"Filesort_buffer::sort_buffer(const Sort_param*,uint)" -> "radixsort_for_str_ptr(uchar**,uint,size_t,uchar**)"
"Filesort_buffer::sort_buffer(const Sort_param*,uint)" -> "my_qsort2(void*,size_t,size_t,qsort2_cmp,const void*)"
"Filesort_buffer::sort_buffer(const Sort_param*,uint)" -> "Filesort_buffer::get_sort_keys()"
"Filesort_buffer::sort_buffer(const Sort_param*,uint)" -> "_T2>::pair() [with _T1 = unsigned char**,_T2 = long int]"
"Filesort_buffer::sort_buffer(const Sort_param*,uint)" -> "{anonymous}::Mem_compare::Mem_compare(size_t)"
"Filesort_buffer::sort_buffer(const Sort_param*,uint)" -> "std::return_temporary_buffer(_Tp*) [with _Tp = unsigned char*]"
"anonymous}::try_reserve(std::pair<_Tp*,long int>*,ptrdiff_t) [with type = unsigned char*,size_t = long unsigned int,ptrdiff_t = long int]" -> "std::return_temporary_buffer(_Tp*) [with _Tp = unsigned char*]"
"anonymous}::try_reserve(std::pair<_Tp*,long int>*,ptrdiff_t) [with type = unsigned char*,size_t = long unsigned int,ptrdiff_t = long int]" -> "std::get_temporary_buffer(std::ptrdiff_t) [with _Tp = unsigned char*,std::ptrdiff_t = long int]"
"std::get_temporary_buffer(std::ptrdiff_t) [with _Tp = unsigned char*,std::ptrdiff_t = long int]" -> "_T2>::pair(const _T1&,const _T2&) [with _T1 = unsigned char**,_T2 = long int]"
"std::stable_sort(_RAIter,_RAIter,_Compare) [with _RAIter = unsigned char**,_Compare = {anonymous}::Mem_compare]" -> "_Tp>::size() const [with _ForwardIterator = unsigned char**,_Tp = unsigned char*,std::_Temporary_buffer<_ForwardIterator,_Tp>::size_type = long int]"
"std::stable_sort(_RAIter,_RAIter,_Compare) [with _RAIter = unsigned char**,_Compare = {anonymous}::Mem_compare]" -> "_Tp>::begin() [with _ForwardIterator = unsigned char**,_Tp = unsigned char*,std::_Temporary_buffer<_ForwardIterator,_Tp>::iterator = unsigned char**,std::_Temporary_buffer<_ForwardIterator,_Tp>::value_type = unsigned char*]"
"std::stable_sort(_RAIter,_RAIter,_Compare) [with _RAIter = unsigned char**,_Compare = {anonymous}::Mem_compare]" -> "std::__stable_sort_adaptive(_RandomAccessIterator,_RandomAccessIterator,_Pointer,_Distance,_Compare) [with _RandomAccessIterator = unsigned char**,_Pointer = unsigned char**,_Distance = long int,_Compare = {anonymous}::Mem_compare]"
"std::stable_sort(_RAIter,_RAIter,_Compare) [with _RAIter = unsigned char**,_Compare = {anonymous}::Mem_compare]" -> "std::__inplace_stable_sort(_RandomAccessIterator,_RandomAccessIterator,_Compare) [with _RandomAccessIterator = unsigned char**,_Compare = {anonymous}::Mem_compare]"
"std::stable_sort(_RAIter,_RAIter,_Compare) [with _RAIter = unsigned char**,_Compare = {anonymous}::Mem_compare]" -> "_Tp>::_Temporary_buffer(_ForwardIterator,_ForwardIterator) [with _ForwardIterator = unsigned char**,_Tp = unsigned char*]"
"std::__stable_sort_adaptive(_RandomAccessIterator,_RandomAccessIterator,_Pointer,_Distance,_Compare) [with _RandomAccessIterator = unsigned char**,_Pointer = unsigned char**,_Distance = long int,_Compare = {anonymous}::Mem_compare]" -> "std::__merge_sort_with_buffer(_RandomAccessIterator,_RandomAccessIterator,_Pointer,_Compare) [with _RandomAccessIterator = unsigned char**,_Pointer = unsigned char**,_Compare = {anonymous}::Mem_compare]"
"std::__stable_sort_adaptive(_RandomAccessIterator,_RandomAccessIterator,_Pointer,_Distance,_Compare) [with _RandomAccessIterator = unsigned char**,_Pointer = unsigned char**,_Distance = long int,_Compare = {anonymous}::Mem_compare]" -> "std::__merge_adaptive(_BidirectionalIterator,_BidirectionalIterator,_BidirectionalIterator,_Distance,_Distance,_Pointer,_Distance,_Compare) [with _BidirectionalIterator = unsigned char**,_Distance = long int,_Pointer = unsigned char**,_Compare = {anonymous}::Mem_compare]"
"std::__stable_sort_adaptive(_RandomAccessIterator,_RandomAccessIterator,_Pointer,_Distance,_Compare) [with _RandomAccessIterator = unsigned char**,_Pointer = unsigned char**,_Distance = long int,_Compare = {anonymous}::Mem_compare]" -> "std::__stable_sort_adaptive(_RandomAccessIterator,_RandomAccessIterator,_Pointer,_Distance,_Compare) [with _RandomAccessIterator = unsigned char**,_Pointer = unsigned char**,_Distance = long int,_Compare = {anonymous}::Mem_compare]"
"std::__merge_sort_with_buffer(_RandomAccessIterator,_RandomAccessIterator,_Pointer,_Compare) [with _RandomAccessIterator = unsigned char**,_Pointer = unsigned char**,_Compare = {anonymous}::Mem_compare]" -> "std::__chunk_insertion_sort(_RandomAccessIterator,_RandomAccessIterator,_Distance,_Compare) [with _RandomAccessIterator = unsigned char**,_Distance = long int,_Compare = {anonymous}::Mem_compare]"
"std::__merge_sort_with_buffer(_RandomAccessIterator,_RandomAccessIterator,_Pointer,_Compare) [with _RandomAccessIterator = unsigned char**,_Pointer = unsigned char**,_Compare = {anonymous}::Mem_compare]" -> "std::__merge_sort_loop(_RandomAccessIterator1,_RandomAccessIterator1,_RandomAccessIterator2,_Distance,_Compare) [with _RandomAccessIterator1 = unsigned char**,_RandomAccessIterator2 = unsigned char**,_Distance = long int,_Compare = {anonymous}::Mem_compare]"
"std::__chunk_insertion_sort(_RandomAccessIterator,_RandomAccessIterator,_Distance,_Compare) [with _RandomAccessIterator = unsigned char**,_Distance = long int,_Compare = {anonymous}::Mem_compare]" -> "std::__insertion_sort(_RandomAccessIterator,_RandomAccessIterator,_Compare) [with _RandomAccessIterator = unsigned char**,_Compare = {anonymous}::Mem_compare]"
"std::__insertion_sort(_RandomAccessIterator,_RandomAccessIterator,_Compare) [with _RandomAccessIterator = unsigned char**,_Compare = {anonymous}::Mem_compare]" -> "anonymous}::Mem_compare::operator()(const uchar*,const uchar*) const"
"std::__insertion_sort(_RandomAccessIterator,_RandomAccessIterator,_Compare) [with _RandomAccessIterator = unsigned char**,_Compare = {anonymous}::Mem_compare]" -> "std::__unguarded_linear_insert(_RandomAccessIterator,_Compare) [with _RandomAccessIterator = unsigned char**,_Compare = {anonymous}::Mem_compare]"
"std::__insertion_sort(_RandomAccessIterator,_RandomAccessIterator,_Compare) [with _RandomAccessIterator = unsigned char**,_Compare = {anonymous}::Mem_compare]" -> "std::copy_backward(_BI1,_BI1,_BI2) [with _BI1 = unsigned char**,_BI2 = unsigned char**]"
"anonymous}::Mem_compare::operator()(const uchar*,const uchar*) const" -> "anonymous}::my_mem_compare(const uchar*,const uchar*,size_t)"
"std::__unguarded_linear_insert(_RandomAccessIterator,_Compare) [with _RandomAccessIterator = unsigned char**,_Compare = {anonymous}::Mem_compare]" -> "anonymous}::Mem_compare::operator()(const uchar*,const uchar*) const"
"std::copy_backward(_BI1,_BI1,_BI2) [with _BI1 = unsigned char**,_BI2 = unsigned char**]" -> "std::__miter_base(_Iterator) [with _Iterator = unsigned char**,typename std::_Miter_base<_Iterator>::iterator_type = unsigned char**]"
"std::copy_backward(_BI1,_BI1,_BI2) [with _BI1 = unsigned char**,_BI2 = unsigned char**]" -> "std::__copy_move_backward_a2(_BI1,_BI1,_BI2) [with bool _IsMove = false,_BI1 = unsigned char**,_BI2 = unsigned char**]"
"std::__miter_base(_Iterator) [with _Iterator = unsigned char**,typename std::_Miter_base<_Iterator>::iterator_type = unsigned char**]" -> "_HasBase>::_S_base(_Iterator) [with _Iterator = unsigned char**,bool _HasBase = false,std::_Iter_base<_Iterator,_HasBase>::iterator_type = unsigned char**]"
"std::__copy_move_backward_a2(_BI1,_BI1,_BI2) [with bool _IsMove = false,_BI1 = unsigned char**,_BI2 = unsigned char**]" -> "std::__niter_base(_Iterator) [with _Iterator = unsigned char**,typename std::_Niter_base<_Iterator>::iterator_type = unsigned char**]"
"std::__copy_move_backward_a2(_BI1,_BI1,_BI2) [with bool _IsMove = false,_BI1 = unsigned char**,_BI2 = unsigned char**]" -> "std::__copy_move_backward_a(_BI1,_BI1,_BI2) [with bool _IsMove = false,_BI1 = unsigned char**,_BI2 = unsigned char**]"
"std::__niter_base(_Iterator) [with _Iterator = unsigned char**,typename std::_Niter_base<_Iterator>::iterator_type = unsigned char**]" -> "_HasBase>::_S_base(_Iterator) [with _Iterator = unsigned char**,bool _HasBase = false,std::_Iter_base<_Iterator,_HasBase>::iterator_type = unsigned char**]"
"std::__copy_move_backward_a(_BI1,_BI1,_BI2) [with bool _IsMove = false,_BI1 = unsigned char**,_BI2 = unsigned char**]" -> "std::random_access_iterator_tag>::__copy_move_b(const _Tp*,const _Tp*,_Tp*) [with _Tp = unsigned char*,bool _IsMove = false]"
"std::random_access_iterator_tag>::__copy_move_b(const _Tp*,const _Tp*,_Tp*) [with _Tp = unsigned char*,bool _IsMove = false]" -> "__builtin_memmove(void*,const void*,long unsigned int)"
"std::__merge_sort_loop(_RandomAccessIterator1,_RandomAccessIterator1,_RandomAccessIterator2,_Distance,_Compare) [with _RandomAccessIterator1 = unsigned char**,_RandomAccessIterator2 = unsigned char**,_Distance = long int,_Compare = {anonymous}::Mem_compare]" -> "std::min(const _Tp&,const _Tp&) [with _Tp = long int]"
"std::__merge_sort_loop(_RandomAccessIterator1,_RandomAccessIterator1,_RandomAccessIterator2,_Distance,_Compare) [with _RandomAccessIterator1 = unsigned char**,_RandomAccessIterator2 = unsigned char**,_Distance = long int,_Compare = {anonymous}::Mem_compare]" -> "std::__move_merge(_InputIterator1,_InputIterator1,_InputIterator2,_InputIterator2,_OutputIterator,_Compare) [with _InputIterator1 = unsigned char**,_InputIterator2 = unsigned char**,_OutputIterator = unsigned char**,_Compare = {anonymous}::Mem_compare]"
"std::__move_merge(_InputIterator1,_InputIterator1,_InputIterator2,_InputIterator2,_OutputIterator,_Compare) [with _InputIterator1 = unsigned char**,_InputIterator2 = unsigned char**,_OutputIterator = unsigned char**,_Compare = {anonymous}::Mem_compare]" -> "anonymous}::Mem_compare::operator()(const uchar*,const uchar*) const"
"std::__move_merge(_InputIterator1,_InputIterator1,_InputIterator2,_InputIterator2,_OutputIterator,_Compare) [with _InputIterator1 = unsigned char**,_InputIterator2 = unsigned char**,_OutputIterator = unsigned char**,_Compare = {anonymous}::Mem_compare]" -> "std::copy(_II,_II,_OI) [with _II = unsigned char**,_OI = unsigned char**]"
"std::copy(_II,_II,_OI) [with _II = unsigned char**,_OI = unsigned char**]" -> "std::__miter_base(_Iterator) [with _Iterator = unsigned char**,typename std::_Miter_base<_Iterator>::iterator_type = unsigned char**]"
"std::copy(_II,_II,_OI) [with _II = unsigned char**,_OI = unsigned char**]" -> "std::__copy_move_a2(_II,_II,_OI) [with bool _IsMove = false,_II = unsigned char**,_OI = unsigned char**]"
"std::__copy_move_a2(_II,_II,_OI) [with bool _IsMove = false,_II = unsigned char**,_OI = unsigned char**]" -> "std::__niter_base(_Iterator) [with _Iterator = unsigned char**,typename std::_Niter_base<_Iterator>::iterator_type = unsigned char**]"
"std::__copy_move_a2(_II,_II,_OI) [with bool _IsMove = false,_II = unsigned char**,_OI = unsigned char**]" -> "std::__copy_move_a(_II,_II,_OI) [with bool _IsMove = false,_II = unsigned char**,_OI = unsigned char**]"
"std::__copy_move_a(_II,_II,_OI) [with bool _IsMove = false,_II = unsigned char**,_OI = unsigned char**]" -> "std::random_access_iterator_tag>::__copy_m(const _Tp*,const _Tp*,_Tp*) [with _Tp = unsigned char*,bool _IsMove = false]"
"std::random_access_iterator_tag>::__copy_m(const _Tp*,const _Tp*,_Tp*) [with _Tp = unsigned char*,bool _IsMove = false]" -> "__builtin_memmove(void*,const void*,long unsigned int)"
"std::__merge_adaptive(_BidirectionalIterator,_BidirectionalIterator,_BidirectionalIterator,_Distance,_Distance,_Pointer,_Distance,_Compare) [with _BidirectionalIterator = unsigned char**,_Distance = long int,_Pointer = unsigned char**,_Compare = {anonymous}::Mem_compare]" -> "std::__move_merge_adaptive_backward(_BidirectionalIterator1,_BidirectionalIterator1,_BidirectionalIterator2,_BidirectionalIterator2,_BidirectionalIterator3,_Compare) [with _BidirectionalIterator1 = unsigned char**,_BidirectionalIterator2 = unsigned char**,_BidirectionalIterator3 = unsigned char**,_Compare = {anonymous}::Mem_compare]"
"std::__merge_adaptive(_BidirectionalIterator,_BidirectionalIterator,_BidirectionalIterator,_Distance,_Distance,_Pointer,_Distance,_Compare) [with _BidirectionalIterator = unsigned char**,_Distance = long int,_Pointer = unsigned char**,_Compare = {anonymous}::Mem_compare]" -> "std::copy(_II,_II,_OI) [with _II = unsigned char**,_OI = unsigned char**]"
"std::__merge_adaptive(_BidirectionalIterator,_BidirectionalIterator,_BidirectionalIterator,_Distance,_Distance,_Pointer,_Distance,_Compare) [with _BidirectionalIterator = unsigned char**,_Distance = long int,_Pointer = unsigned char**,_Compare = {anonymous}::Mem_compare]" -> "std::lower_bound(_FIter,_FIter,const _Tp&,_Compare) [with _FIter = unsigned char**,_Tp = unsigned char*,_Compare = {anonymous}::Mem_compare]"
"std::__merge_adaptive(_BidirectionalIterator,_BidirectionalIterator,_BidirectionalIterator,_Distance,_Distance,_Pointer,_Distance,_Compare) [with _BidirectionalIterator = unsigned char**,_Distance = long int,_Pointer = unsigned char**,_Compare = {anonymous}::Mem_compare]" -> "std::upper_bound(_FIter,_FIter,const _Tp&,_Compare) [with _FIter = unsigned char**,_Tp = unsigned char*,_Compare = {anonymous}::Mem_compare]"
"std::__merge_adaptive(_BidirectionalIterator,_BidirectionalIterator,_BidirectionalIterator,_Distance,_Distance,_Pointer,_Distance,_Compare) [with _BidirectionalIterator = unsigned char**,_Distance = long int,_Pointer = unsigned char**,_Compare = {anonymous}::Mem_compare]" -> "std::advance(_InputIterator&,_Distance) [with _InputIterator = unsigned char**,_Distance = long int]"
"std::__merge_adaptive(_BidirectionalIterator,_BidirectionalIterator,_BidirectionalIterator,_Distance,_Distance,_Pointer,_Distance,_Compare) [with _BidirectionalIterator = unsigned char**,_Distance = long int,_Pointer = unsigned char**,_Compare = {anonymous}::Mem_compare]" -> "std::__rotate_adaptive(_BidirectionalIterator1,_BidirectionalIterator1,_BidirectionalIterator1,_Distance,_Distance,_BidirectionalIterator2,_Distance) [with _BidirectionalIterator1 = unsigned char**,_BidirectionalIterator2 = unsigned char**,_Distance = long int]"
"std::__merge_adaptive(_BidirectionalIterator,_BidirectionalIterator,_BidirectionalIterator,_Distance,_Distance,_Pointer,_Distance,_Compare) [with _BidirectionalIterator = unsigned char**,_Distance = long int,_Pointer = unsigned char**,_Compare = {anonymous}::Mem_compare]" -> "std::__move_merge_adaptive(_InputIterator1,_InputIterator1,_InputIterator2,_InputIterator2,_OutputIterator,_Compare) [with _InputIterator1 = unsigned char**,_InputIterator2 = unsigned char**,_OutputIterator = unsigned char**,_Compare = {anonymous}::Mem_compare]"
"std::__merge_adaptive(_BidirectionalIterator,_BidirectionalIterator,_BidirectionalIterator,_Distance,_Distance,_Pointer,_Distance,_Compare) [with _BidirectionalIterator = unsigned char**,_Distance = long int,_Pointer = unsigned char**,_Compare = {anonymous}::Mem_compare]" -> "std::distance(_InputIterator,_InputIterator) [with _InputIterator = unsigned char**,typename std::iterator_traits<_Iterator>::difference_type = long int]"
"std::__merge_adaptive(_BidirectionalIterator,_BidirectionalIterator,_BidirectionalIterator,_Distance,_Distance,_Pointer,_Distance,_Compare) [with _BidirectionalIterator = unsigned char**,_Distance = long int,_Pointer = unsigned char**,_Compare = {anonymous}::Mem_compare]" -> "std::__merge_adaptive(_BidirectionalIterator,_BidirectionalIterator,_BidirectionalIterator,_Distance,_Distance,_Pointer,_Distance,_Compare) [with _BidirectionalIterator = unsigned char**,_Distance = long int,_Pointer = unsigned char**,_Compare = {anonymous}::Mem_compare]"
"std::__move_merge_adaptive_backward(_BidirectionalIterator1,_BidirectionalIterator1,_BidirectionalIterator2,_BidirectionalIterator2,_BidirectionalIterator3,_Compare) [with _BidirectionalIterator1 = unsigned char**,_BidirectionalIterator2 = unsigned char**,_BidirectionalIterator3 = unsigned char**,_Compare = {anonymous}::Mem_compare]" -> "anonymous}::Mem_compare::operator()(const uchar*,const uchar*) const"
"std::__move_merge_adaptive_backward(_BidirectionalIterator1,_BidirectionalIterator1,_BidirectionalIterator2,_BidirectionalIterator2,_BidirectionalIterator3,_Compare) [with _BidirectionalIterator1 = unsigned char**,_BidirectionalIterator2 = unsigned char**,_BidirectionalIterator3 = unsigned char**,_Compare = {anonymous}::Mem_compare]" -> "std::copy_backward(_BI1,_BI1,_BI2) [with _BI1 = unsigned char**,_BI2 = unsigned char**]"
"std::lower_bound(_FIter,_FIter,const _Tp&,_Compare) [with _FIter = unsigned char**,_Tp = unsigned char*,_Compare = {anonymous}::Mem_compare]" -> "std::advance(_InputIterator&,_Distance) [with _InputIterator = unsigned char**,_Distance = long int]"
"std::lower_bound(_FIter,_FIter,const _Tp&,_Compare) [with _FIter = unsigned char**,_Tp = unsigned char*,_Compare = {anonymous}::Mem_compare]" -> "anonymous}::Mem_compare::operator()(const uchar*,const uchar*) const"
"std::lower_bound(_FIter,_FIter,const _Tp&,_Compare) [with _FIter = unsigned char**,_Tp = unsigned char*,_Compare = {anonymous}::Mem_compare]" -> "std::distance(_InputIterator,_InputIterator) [with _InputIterator = unsigned char**,typename std::iterator_traits<_Iterator>::difference_type = long int]"
"std::advance(_InputIterator&,_Distance) [with _InputIterator = unsigned char**,_Distance = long int]" -> "std::__advance(_RandomAccessIterator&,_Distance,std::random_access_iterator_tag) [with _RandomAccessIterator = unsigned char**,_Distance = long int]"
"std::advance(_InputIterator&,_Distance) [with _InputIterator = unsigned char**,_Distance = long int]" -> "std::__iterator_category(const _Iter&) [with _Iter = unsigned char**,typename std::iterator_traits<_Iterator>::iterator_category = std::random_access_iterator_tag]"
"std::distance(_InputIterator,_InputIterator) [with _InputIterator = unsigned char**,typename std::iterator_traits<_Iterator>::difference_type = long int]" -> "std::__iterator_category(const _Iter&) [with _Iter = unsigned char**,typename std::iterator_traits<_Iterator>::iterator_category = std::random_access_iterator_tag]"
"std::distance(_InputIterator,_InputIterator) [with _InputIterator = unsigned char**,typename std::iterator_traits<_Iterator>::difference_type = long int]" -> "std::__distance(_RandomAccessIterator,_RandomAccessIterator,std::random_access_iterator_tag) [with _RandomAccessIterator = unsigned char**,typename std::iterator_traits<_Iterator>::difference_type = long int]"
"std::upper_bound(_FIter,_FIter,const _Tp&,_Compare) [with _FIter = unsigned char**,_Tp = unsigned char*,_Compare = {anonymous}::Mem_compare]" -> "std::advance(_InputIterator&,_Distance) [with _InputIterator = unsigned char**,_Distance = long int]"
"std::upper_bound(_FIter,_FIter,const _Tp&,_Compare) [with _FIter = unsigned char**,_Tp = unsigned char*,_Compare = {anonymous}::Mem_compare]" -> "std::distance(_InputIterator,_InputIterator) [with _InputIterator = unsigned char**,typename std::iterator_traits<_Iterator>::difference_type = long int]"
"std::upper_bound(_FIter,_FIter,const _Tp&,_Compare) [with _FIter = unsigned char**,_Tp = unsigned char*,_Compare = {anonymous}::Mem_compare]" -> "anonymous}::Mem_compare::operator()(const uchar*,const uchar*) const"
"std::__rotate_adaptive(_BidirectionalIterator1,_BidirectionalIterator1,_BidirectionalIterator1,_Distance,_Distance,_BidirectionalIterator2,_Distance) [with _BidirectionalIterator1 = unsigned char**,_BidirectionalIterator2 = unsigned char**,_Distance = long int]" -> "std::distance(_InputIterator,_InputIterator) [with _InputIterator = unsigned char**,typename std::iterator_traits<_Iterator>::difference_type = long int]"
"std::__rotate_adaptive(_BidirectionalIterator1,_BidirectionalIterator1,_BidirectionalIterator1,_Distance,_Distance,_BidirectionalIterator2,_Distance) [with _BidirectionalIterator1 = unsigned char**,_BidirectionalIterator2 = unsigned char**,_Distance = long int]" -> "std::advance(_InputIterator&,_Distance) [with _InputIterator = unsigned char**,_Distance = long int]"
"std::__rotate_adaptive(_BidirectionalIterator1,_BidirectionalIterator1,_BidirectionalIterator1,_Distance,_Distance,_BidirectionalIterator2,_Distance) [with _BidirectionalIterator1 = unsigned char**,_BidirectionalIterator2 = unsigned char**,_Distance = long int]" -> "std::rotate(_FIter,_FIter,_FIter) [with _FIter = unsigned char**]"
"std::__rotate_adaptive(_BidirectionalIterator1,_BidirectionalIterator1,_BidirectionalIterator1,_Distance,_Distance,_BidirectionalIterator2,_Distance) [with _BidirectionalIterator1 = unsigned char**,_BidirectionalIterator2 = unsigned char**,_Distance = long int]" -> "std::copy(_II,_II,_OI) [with _II = unsigned char**,_OI = unsigned char**]"
"std::__rotate_adaptive(_BidirectionalIterator1,_BidirectionalIterator1,_BidirectionalIterator1,_Distance,_Distance,_BidirectionalIterator2,_Distance) [with _BidirectionalIterator1 = unsigned char**,_BidirectionalIterator2 = unsigned char**,_Distance = long int]" -> "std::copy_backward(_BI1,_BI1,_BI2) [with _BI1 = unsigned char**,_BI2 = unsigned char**]"
"std::rotate(_FIter,_FIter,_FIter) [with _FIter = unsigned char**]" -> "std::__rotate(_RandomAccessIterator,_RandomAccessIterator,_RandomAccessIterator,std::random_access_iterator_tag) [with _RandomAccessIterator = unsigned char**]"
"std::__rotate(_RandomAccessIterator,_RandomAccessIterator,_RandomAccessIterator,std::random_access_iterator_tag) [with _RandomAccessIterator = unsigned char**]" -> "std::swap(_Tp&,_Tp&) [with _Tp = long int]"
"std::__rotate(_RandomAccessIterator,_RandomAccessIterator,_RandomAccessIterator,std::random_access_iterator_tag) [with _RandomAccessIterator = unsigned char**]" -> "std::copy_backward(_BI1,_BI1,_BI2) [with _BI1 = unsigned char**,_BI2 = unsigned char**]"
"std::__rotate(_RandomAccessIterator,_RandomAccessIterator,_RandomAccessIterator,std::random_access_iterator_tag) [with _RandomAccessIterator = unsigned char**]" -> "std::swap_ranges(_ForwardIterator1,_ForwardIterator1,_ForwardIterator2) [with _ForwardIterator1 = unsigned char**,_ForwardIterator2 = unsigned char**]"
"std::__rotate(_RandomAccessIterator,_RandomAccessIterator,_RandomAccessIterator,std::random_access_iterator_tag) [with _RandomAccessIterator = unsigned char**]" -> "std::iter_swap(_ForwardIterator1,_ForwardIterator2) [with _ForwardIterator1 = unsigned char**,_ForwardIterator2 = unsigned char**]"
"std::__rotate(_RandomAccessIterator,_RandomAccessIterator,_RandomAccessIterator,std::random_access_iterator_tag) [with _RandomAccessIterator = unsigned char**]" -> "std::copy(_II,_II,_OI) [with _II = unsigned char**,_OI = unsigned char**]"
"std::swap_ranges(_ForwardIterator1,_ForwardIterator1,_ForwardIterator2) [with _ForwardIterator1 = unsigned char**,_ForwardIterator2 = unsigned char**]" -> "std::iter_swap(_ForwardIterator1,_ForwardIterator2) [with _ForwardIterator1 = unsigned char**,_ForwardIterator2 = unsigned char**]"
"std::iter_swap(_ForwardIterator1,_ForwardIterator2) [with _ForwardIterator1 = unsigned char**,_ForwardIterator2 = unsigned char**]" -> "std::__iter_swap<true>::iter_swap(_ForwardIterator1,_ForwardIterator2) [with _ForwardIterator1 = unsigned char**,_ForwardIterator2 = unsigned char**]"
"std::__iter_swap<true>::iter_swap(_ForwardIterator1,_ForwardIterator2) [with _ForwardIterator1 = unsigned char**,_ForwardIterator2 = unsigned char**]" -> "std::swap(_Tp&,_Tp&) [with _Tp = unsigned char*]"
"std::__move_merge_adaptive(_InputIterator1,_InputIterator1,_InputIterator2,_InputIterator2,_OutputIterator,_Compare) [with _InputIterator1 = unsigned char**,_InputIterator2 = unsigned char**,_OutputIterator = unsigned char**,_Compare = {anonymous}::Mem_compare]" -> "anonymous}::Mem_compare::operator()(const uchar*,const uchar*) const"
"std::__move_merge_adaptive(_InputIterator1,_InputIterator1,_InputIterator2,_InputIterator2,_OutputIterator,_Compare) [with _InputIterator1 = unsigned char**,_InputIterator2 = unsigned char**,_OutputIterator = unsigned char**,_Compare = {anonymous}::Mem_compare]" -> "std::copy(_II,_II,_OI) [with _II = unsigned char**,_OI = unsigned char**]"
"std::__inplace_stable_sort(_RandomAccessIterator,_RandomAccessIterator,_Compare) [with _RandomAccessIterator = unsigned char**,_Compare = {anonymous}::Mem_compare]" -> "std::__inplace_stable_sort(_RandomAccessIterator,_RandomAccessIterator,_Compare) [with _RandomAccessIterator = unsigned char**,_Compare = {anonymous}::Mem_compare]"
"std::__inplace_stable_sort(_RandomAccessIterator,_RandomAccessIterator,_Compare) [with _RandomAccessIterator = unsigned char**,_Compare = {anonymous}::Mem_compare]" -> "std::__insertion_sort(_RandomAccessIterator,_RandomAccessIterator,_Compare) [with _RandomAccessIterator = unsigned char**,_Compare = {anonymous}::Mem_compare]"
"std::__inplace_stable_sort(_RandomAccessIterator,_RandomAccessIterator,_Compare) [with _RandomAccessIterator = unsigned char**,_Compare = {anonymous}::Mem_compare]" -> "std::__merge_without_buffer(_BidirectionalIterator,_BidirectionalIterator,_BidirectionalIterator,_Distance,_Distance,_Compare) [with _BidirectionalIterator = unsigned char**,_Distance = long int,_Compare = {anonymous}::Mem_compare]"
"std::__merge_without_buffer(_BidirectionalIterator,_BidirectionalIterator,_BidirectionalIterator,_Distance,_Distance,_Compare) [with _BidirectionalIterator = unsigned char**,_Distance = long int,_Compare = {anonymous}::Mem_compare]" -> "std::lower_bound(_FIter,_FIter,const _Tp&,_Compare) [with _FIter = unsigned char**,_Tp = unsigned char*,_Compare = {anonymous}::Mem_compare]"
"std::__merge_without_buffer(_BidirectionalIterator,_BidirectionalIterator,_BidirectionalIterator,_Distance,_Distance,_Compare) [with _BidirectionalIterator = unsigned char**,_Distance = long int,_Compare = {anonymous}::Mem_compare]" -> "anonymous}::Mem_compare::operator()(const uchar*,const uchar*) const"
"std::__merge_without_buffer(_BidirectionalIterator,_BidirectionalIterator,_BidirectionalIterator,_Distance,_Distance,_Compare) [with _BidirectionalIterator = unsigned char**,_Distance = long int,_Compare = {anonymous}::Mem_compare]" -> "std::rotate(_FIter,_FIter,_FIter) [with _FIter = unsigned char**]"
"std::__merge_without_buffer(_BidirectionalIterator,_BidirectionalIterator,_BidirectionalIterator,_Distance,_Distance,_Compare) [with _BidirectionalIterator = unsigned char**,_Distance = long int,_Compare = {anonymous}::Mem_compare]" -> "std::iter_swap(_ForwardIterator1,_ForwardIterator2) [with _ForwardIterator1 = unsigned char**,_ForwardIterator2 = unsigned char**]"
"std::__merge_without_buffer(_BidirectionalIterator,_BidirectionalIterator,_BidirectionalIterator,_Distance,_Distance,_Compare) [with _BidirectionalIterator = unsigned char**,_Distance = long int,_Compare = {anonymous}::Mem_compare]" -> "std::distance(_InputIterator,_InputIterator) [with _InputIterator = unsigned char**,typename std::iterator_traits<_Iterator>::difference_type = long int]"
"std::__merge_without_buffer(_BidirectionalIterator,_BidirectionalIterator,_BidirectionalIterator,_Distance,_Distance,_Compare) [with _BidirectionalIterator = unsigned char**,_Distance = long int,_Compare = {anonymous}::Mem_compare]" -> "std::__merge_without_buffer(_BidirectionalIterator,_BidirectionalIterator,_BidirectionalIterator,_Distance,_Distance,_Compare) [with _BidirectionalIterator = unsigned char**,_Distance = long int,_Compare = {anonymous}::Mem_compare]"
"std::__merge_without_buffer(_BidirectionalIterator,_BidirectionalIterator,_BidirectionalIterator,_Distance,_Distance,_Compare) [with _BidirectionalIterator = unsigned char**,_Distance = long int,_Compare = {anonymous}::Mem_compare]" -> "std::upper_bound(_FIter,_FIter,const _Tp&,_Compare) [with _FIter = unsigned char**,_Tp = unsigned char*,_Compare = {anonymous}::Mem_compare]"
"std::__merge_without_buffer(_BidirectionalIterator,_BidirectionalIterator,_BidirectionalIterator,_Distance,_Distance,_Compare) [with _BidirectionalIterator = unsigned char**,_Distance = long int,_Compare = {anonymous}::Mem_compare]" -> "std::advance(_InputIterator&,_Distance) [with _InputIterator = unsigned char**,_Distance = long int]"
"_Tp>::_Temporary_buffer(_ForwardIterator,_ForwardIterator) [with _ForwardIterator = unsigned char**,_Tp = unsigned char*]" -> "std::distance(_InputIterator,_InputIterator) [with _InputIterator = unsigned char**,typename std::iterator_traits<_Iterator>::difference_type = long int]"
"_Tp>::_Temporary_buffer(_ForwardIterator,_ForwardIterator) [with _ForwardIterator = unsigned char**,_Tp = unsigned char*]" -> "__cxa_rethrow()"
"_Tp>::_Temporary_buffer(_ForwardIterator,_ForwardIterator) [with _ForwardIterator = unsigned char**,_Tp = unsigned char*]" -> "__builtin_eh_pointer(int)"
"_Tp>::_Temporary_buffer(_ForwardIterator,_ForwardIterator) [with _ForwardIterator = unsigned char**,_Tp = unsigned char*]" -> "std::__uninitialized_construct_buf(_ForwardIterator,_ForwardIterator,_Tp&) [with _ForwardIterator = unsigned char**,_Tp = unsigned char*]"
"_Tp>::_Temporary_buffer(_ForwardIterator,_ForwardIterator) [with _ForwardIterator = unsigned char**,_Tp = unsigned char*]" -> "__cxa_end_catch()"
"_Tp>::_Temporary_buffer(_ForwardIterator,_ForwardIterator) [with _ForwardIterator = unsigned char**,_Tp = unsigned char*]" -> "std::return_temporary_buffer(_Tp*) [with _Tp = unsigned char*]"
"_Tp>::_Temporary_buffer(_ForwardIterator,_ForwardIterator) [with _ForwardIterator = unsigned char**,_Tp = unsigned char*]" -> "std::get_temporary_buffer(std::ptrdiff_t) [with _Tp = unsigned char*,std::ptrdiff_t = long int]"
"_Tp>::_Temporary_buffer(_ForwardIterator,_ForwardIterator) [with _ForwardIterator = unsigned char**,_Tp = unsigned char*]" -> "__cxa_begin_catch(void*)"
"std::__uninitialized_construct_buf(_ForwardIterator,_ForwardIterator,_Tp&) [with _ForwardIterator = unsigned char**,_Tp = unsigned char*]" -> "std::__uninitialized_construct_buf_dispatch<true>::__ucr(_ForwardIterator,_ForwardIterator,_Tp&) [with _ForwardIterator = unsigned char**,_Tp = unsigned char*]"
"Key_type>::Bounded_queue() [with Element_type = unsigned char,Key_type = unsigned char]" -> "memset(void*,int,size_t)"
"sortlength(THD*,SORT_FIELD*,uint,bool*)" -> "Field::maybe_null() const"
"sortlength(THD*,SORT_FIELD*,uint,bool*)" -> "Item::is_temporal() const"
"sortlength(THD*,SORT_FIELD*,uint,bool*)" -> "Field::is_temporal() const"
"sortlength(THD*,SORT_FIELD*,uint,bool*)" -> "suffix_length(ulong)"
"sortlength(THD*,SORT_FIELD*,uint,bool*)" -> "my_decimal_get_binary_size(uint,uint)"
"Key_type>::init(ha_rows,bool,Bounded_queue<Element_type,Key_type>::compare_function,size_t,Bounded_queue<Element_type,Key_type>::keymaker_function,Sort_param*,Key_type**) [with Element_type = unsigned char,Key_type = unsigned char,ha_rows = long long unsigned int,Bounded_queue<Element_type,Key_type>::compare_function = int (*)(long unsigned int*,unsigned char**,unsigned char**),size_t = long unsigned int,Bounded_queue<Element_type,Key_type>::keymaker_function = void (*)(Sort_param*,unsigned char*,unsigned char*)]" -> "init_queue(QUEUE*,uint,uint,pbool,queue_compare,void*)"
"Key_type>::init(ha_rows,bool,Bounded_queue<Element_type,Key_type>::compare_function,size_t,Bounded_queue<Element_type,Key_type>::keymaker_function,Sort_param*,Key_type**) [with Element_type = unsigned char,Key_type = unsigned char,ha_rows = long long unsigned int,Bounded_queue<Element_type,Key_type>::compare_function = int (*)(long unsigned int*,unsigned char**,unsigned char**),size_t = long unsigned int,Bounded_queue<Element_type,Key_type>::keymaker_function = void (*)(Sort_param*,unsigned char*,unsigned char*)]" -> "(* get_ptr_compare(size_t))(const void*,const void*,const void*)"
"read_buffpek_from_file(IO_CACHE*,uint,uchar*)" -> "my_free(void*)"
"read_buffpek_from_file(IO_CACHE*,uint,uchar*)" -> "reinit_io_cache(IO_CACHE*,cache_type,my_off_t,pbool,pbool)"
"read_buffpek_from_file(IO_CACHE*,uint,uchar*)" -> "my_malloc(size_t,myf)"
"read_buffpek_from_file(IO_CACHE*,uint,uchar*)" -> "memcpy(void*,const void*,size_t)"
"Filesort_info::init_record_pointers()" -> "Filesort_buffer::init_record_pointers()"
"Filesort_buffer::init_record_pointers()" -> "Bounds_checked_array<Element_type>::size() const [with Element_type = unsigned char*,size_t = long unsigned int]"
"Filesort_buffer::init_record_pointers()" -> "Filesort_buffer::get_record_buffer(uint)"
"Filesort_buffer::get_record_buffer(uint)" -> "Bounds_checked_array<Element_type>::operator[](size_t) [with Element_type = unsigned char*,size_t = long unsigned int]"
"Filesort_info::operator=(const Filesort_info&)" -> "Filesort_buffer::operator=(const Filesort_buffer&)"
"Sort_param::Sort_param()" -> "memset(void*,int,size_t)"
"merge_many_buff(Sort_param*,uchar*,BUFFPEK*,uint*,IO_CACHE*)" -> "setup_io_cache(IO_CACHE*)"
"merge_many_buff(Sort_param*,uchar*,BUFFPEK*,uint*,IO_CACHE*)" -> "merge_buffers(Sort_param*,IO_CACHE*,IO_CACHE*,uchar*,BUFFPEK*,BUFFPEK*,BUFFPEK*,int)"
"merge_many_buff(Sort_param*,uchar*,BUFFPEK*,uint*,IO_CACHE*)" -> "open_cached_file(IO_CACHE*,const char*,const char*,size_t,myf)"
"merge_many_buff(Sort_param*,uchar*,BUFFPEK*,uint*,IO_CACHE*)" -> "reinit_io_cache(IO_CACHE*,cache_type,my_off_t,pbool,pbool)"
"merge_many_buff(Sort_param*,uchar*,BUFFPEK*,uint*,IO_CACHE*)" -> "my_tmpdir(MY_TMPDIR*)"
"merge_many_buff(Sort_param*,uchar*,BUFFPEK*,uint*,IO_CACHE*)" -> "my_b_flush_io_cache(IO_CACHE*,int)"
"merge_many_buff(Sort_param*,uchar*,BUFFPEK*,uint*,IO_CACHE*)" -> "close_cached_file(IO_CACHE*)"
"merge_buffers(Sort_param*,IO_CACHE*,IO_CACHE*,uchar*,BUFFPEK*,BUFFPEK*,BUFFPEK*,int)" -> "std::min(const _Tp&,const _Tp&) [with _Tp = long long unsigned int]"
"merge_buffers(Sort_param*,IO_CACHE*,IO_CACHE*,uchar*,BUFFPEK*,BUFFPEK*,BUFFPEK*,int)" -> "_downheap(QUEUE*,uint)"
"merge_buffers(Sort_param*,IO_CACHE*,IO_CACHE*,uchar*,BUFFPEK*,BUFFPEK*,BUFFPEK*,int)" -> "memcpy(void*,const void*,size_t)"
"merge_buffers(Sort_param*,IO_CACHE*,IO_CACHE*,uchar*,BUFFPEK*,BUFFPEK*,BUFFPEK*,int)" -> "reuse_freed_buff(QUEUE*,BUFFPEK*,uint)"
"merge_buffers(Sort_param*,IO_CACHE*,IO_CACHE*,uchar*,BUFFPEK*,BUFFPEK*,BUFFPEK*,int)" -> "THD::inc_status_sort_merge_passes()"
"merge_buffers(Sort_param*,IO_CACHE*,IO_CACHE*,uchar*,BUFFPEK*,BUFFPEK*,BUFFPEK*,int)" -> "(* get_ptr_compare(size_t))(const void*,const void*,const void*)"
"merge_buffers(Sort_param*,IO_CACHE*,IO_CACHE*,uchar*,BUFFPEK*,BUFFPEK*,BUFFPEK*,int)" -> "delete_queue(QUEUE*)"
"merge_buffers(Sort_param*,IO_CACHE*,IO_CACHE*,uchar*,BUFFPEK*,BUFFPEK*,BUFFPEK*,int)" -> "queue_remove(QUEUE*,uint)"
"merge_buffers(Sort_param*,IO_CACHE*,IO_CACHE*,uchar*,BUFFPEK*,BUFFPEK*,BUFFPEK*,int)" -> "_current_thd()"
"merge_buffers(Sort_param*,IO_CACHE*,IO_CACHE*,uchar*,BUFFPEK*,BUFFPEK*,BUFFPEK*,int)" -> "queue_insert(QUEUE*,uchar*)"
"merge_buffers(Sort_param*,IO_CACHE*,IO_CACHE*,uchar*,BUFFPEK*,BUFFPEK*,BUFFPEK*,int)" -> "init_queue(QUEUE*,uint,uint,pbool,queue_compare,void*)"
"merge_buffers(Sort_param*,IO_CACHE*,IO_CACHE*,uchar*,BUFFPEK*,BUFFPEK*,BUFFPEK*,int)" -> "read_to_buffer(IO_CACHE*,BUFFPEK*,uint)"
"read_to_buffer(IO_CACHE*,BUFFPEK*,uint)" -> "std::min(const _Tp&,const _Tp&) [with _Tp = long long unsigned int]"
"read_to_buffer(IO_CACHE*,BUFFPEK*,uint)" -> "inline_mysql_file_pread(File,uchar*,size_t,my_off_t,myf)"
"Sort_param::init_for_filesort(uint,TABLE*,ulong,ha_rows,bool)" -> "handler::ha_table_flags() const"
"Sort_param::init_for_filesort(uint,TABLE*,ulong,ha_rows,bool)" -> "get_addon_fields(ulong,Field**,uint,uint*)"
"get_addon_fields(ulong,Field**,uint,uint*)" -> "bitmap_is_set(const MY_BITMAP*,uint)"
"get_addon_fields(ulong,Field**,uint,uint*)" -> "my_malloc(size_t,myf)"
"get_addon_fields(ulong,Field**,uint,uint*)" -> "Field::maybe_null() const"
"Filesort_info::sort_buffer_size() const" -> "Filesort_buffer::sort_buffer_size() const"
"Filesort_buffer::sort_buffer_size() const" -> "Bounds_checked_array<Element_type>::size() const [with Element_type = unsigned char*,size_t = long unsigned int]"
"find_all_keys(Sort_param*,SQL_SELECT*,Filesort_info*,IO_CACHE*,IO_CACHE*,Bounded_queue<unsigned char,unsigned char>*,ha_rows*)" -> "my_store_ptr(uchar*,size_t,my_off_t)"
"find_all_keys(Sort_param*,SQL_SELECT*,Filesort_info*,IO_CACHE*,IO_CACHE*,Bounded_queue<unsigned char,unsigned char>*,ha_rows*)" -> "handler::ha_rnd_init(bool)"
"find_all_keys(Sort_param*,SQL_SELECT*,Filesort_info*,IO_CACHE*,IO_CACHE*,Bounded_queue<unsigned char,unsigned char>*,ha_rows*)" -> "memset(void*,int,size_t)"
"find_all_keys(Sort_param*,SQL_SELECT*,Filesort_info*,IO_CACHE*,IO_CACHE*,Bounded_queue<unsigned char,unsigned char>*,ha_rows*)" -> "handler::ha_rnd_next(uchar*)"
"find_all_keys(Sort_param*,SQL_SELECT*,Filesort_info*,IO_CACHE*,IO_CACHE*,Bounded_queue<unsigned char,unsigned char>*,ha_rows*)" -> "Key_type>::push(Element_type*) [with Element_type = unsigned char,Key_type = unsigned char]"
"find_all_keys(Sort_param*,SQL_SELECT*,Filesort_info*,IO_CACHE*,IO_CACHE*,Bounded_queue<unsigned char,unsigned char>*,ha_rows*)" -> "make_sortkey(Sort_param*,uchar*,uchar*)"
"find_all_keys(Sort_param*,SQL_SELECT*,Filesort_info*,IO_CACHE*,IO_CACHE*,Bounded_queue<unsigned char,unsigned char>*,ha_rows*)" -> "write_keys(Sort_param*,Filesort_info*,uint,IO_CACHE*,IO_CACHE*)"
"find_all_keys(Sort_param*,SQL_SELECT*,Filesort_info*,IO_CACHE*,IO_CACHE*,Bounded_queue<unsigned char,unsigned char>*,ha_rows*)" -> "handler::ha_table_flags() const"
"find_all_keys(Sort_param*,SQL_SELECT*,Filesort_info*,IO_CACHE*,IO_CACHE*,Bounded_queue<unsigned char,unsigned char>*,ha_rows*)" -> "THD::is_error() const"
"find_all_keys(Sort_param*,SQL_SELECT*,Filesort_info*,IO_CACHE*,IO_CACHE*,Bounded_queue<unsigned char,unsigned char>*,ha_rows*)" -> "Filesort_info::get_record_buffer(uint)"
"find_all_keys(Sort_param*,SQL_SELECT*,Filesort_info*,IO_CACHE*,IO_CACHE*,Bounded_queue<unsigned char,unsigned char>*,ha_rows*)" -> "_current_thd()"
"find_all_keys(Sort_param*,SQL_SELECT*,Filesort_info*,IO_CACHE*,IO_CACHE*,Bounded_queue<unsigned char,unsigned char>*,ha_rows*)" -> "SQL_SELECT::skip_record(THD*,bool*)"
"find_all_keys(Sort_param*,SQL_SELECT*,Filesort_info*,IO_CACHE*,IO_CACHE*,Bounded_queue<unsigned char,unsigned char>*,ha_rows*)" -> "Key_type>::num_elements() const [with Element_type = unsigned char,Key_type = unsigned char,uint = unsigned int]"
"find_all_keys(Sort_param*,SQL_SELECT*,Filesort_info*,IO_CACHE*,IO_CACHE*,Bounded_queue<unsigned char,unsigned char>*,ha_rows*)" -> "register_used_fields(Sort_param*)"
"find_all_keys(Sort_param*,SQL_SELECT*,Filesort_info*,IO_CACHE*,IO_CACHE*,Bounded_queue<unsigned char,unsigned char>*,ha_rows*)" -> "handler::ha_rnd_end()"
"find_all_keys(Sort_param*,SQL_SELECT*,Filesort_info*,IO_CACHE*,IO_CACHE*,Bounded_queue<unsigned char,unsigned char>*,ha_rows*)" -> "TABLE::column_bitmaps_set(MY_BITMAP*,MY_BITMAP*)"
"Key_type>::push(Element_type*) [with Element_type = unsigned char,Key_type = unsigned char]" -> "_downheap(QUEUE*,uint)"
"Key_type>::push(Element_type*) [with Element_type = unsigned char,Key_type = unsigned char]" -> "queue_insert(QUEUE*,uchar*)"
"make_sortkey(Sort_param*,uchar*,uchar*)" -> "String::ptr() const"
"make_sortkey(Sort_param*,uchar*,uchar*)" -> "store_length(uchar*,uint,uint)"
"make_sortkey(Sort_param*,uchar*,uchar*)" -> "change_double_for_sort(double,uchar*)"
"make_sortkey(Sort_param*,uchar*,uchar*)" -> "my_decimal2binary(uint,const my_decimal*,uchar*,int,int)"
"make_sortkey(Sort_param*,uchar*,uchar*)" -> "Item::max_char_length() const"
"make_sortkey(Sort_param*,uchar*,uchar*)" -> "memset(void*,int,size_t)"
"make_sortkey(Sort_param*,uchar*,uchar*)" -> "String::String(char*,uint32,const CHARSET_INFO*)"
"make_sortkey(Sort_param*,uchar*,uchar*)" -> "Field::maybe_null() const"
"make_sortkey(Sort_param*,uchar*,uchar*)" -> "copy_native_longlong(uchar*,int,longlong,bool)"
"make_sortkey(Sort_param*,uchar*,uchar*)" -> "String::length() const"
"make_sortkey(Sort_param*,uchar*,uchar*)" -> "Item::is_temporal_with_date() const"
"make_sortkey(Sort_param*,uchar*,uchar*)" -> "memcpy(void*,const void*,size_t)"
"make_sortkey(Sort_param*,uchar*,uchar*)" -> "Field::pack(uchar*,const uchar*)"
"make_sortkey(Sort_param*,uchar*,uchar*)" -> "Field::is_null(my_ptrdiff_t) const"
"make_sortkey(Sort_param*,uchar*,uchar*)" -> "my_decimal::my_decimal()"
"change_double_for_sort(double,uchar*)" -> "memset(void*,int,size_t)"
"my_decimal2binary(uint,const my_decimal*,uchar*,int,int)" -> "my_decimal2decimal(const my_decimal*,my_decimal*)"
"my_decimal2binary(uint,const my_decimal*,uchar*,int,int)" -> "check_result(uint,int)"
"my_decimal2binary(uint,const my_decimal*,uchar*,int,int)" -> "my_decimal::my_decimal()"
"my_decimal2binary(uint,const my_decimal*,uchar*,int,int)" -> "decimal_actual_fraction(decimal_t*)"
"my_decimal2binary(uint,const my_decimal*,uchar*,int,int)" -> "decimal_round(const decimal_t*,decimal_t*,int,decimal_round_mode)"
"my_decimal2binary(uint,const my_decimal*,uchar*,int,int)" -> "decimal2bin(decimal_t*,uchar*,int,int)"
"my_decimal2decimal(const my_decimal*,my_decimal*)" -> "my_decimal::operator=(const my_decimal&)"
"my_decimal::operator=(const my_decimal&)" -> "my_decimal::fix_buffer_pointer()"
"decimal2bin(decimal_t*,uchar*,int,int)" -> "remove_leading_zeroes(const decimal_t*,int*)"
"decimal2bin(decimal_t*,uchar*,int,int)" -> "__builtin_expect(long int,long int)"
"copy_native_longlong(uchar*,int,longlong,bool)" -> "copy_integer(uchar*,int,const uchar*,int,bool) [with bool Is_big_endian = false,uchar = unsigned char]"
"write_keys(Sort_param*,Filesort_info*,uint,IO_CACHE*,IO_CACHE*)" -> "open_cached_file(IO_CACHE*,const char*,const char*,size_t,myf)"
"write_keys(Sort_param*,Filesort_info*,uint,IO_CACHE*,IO_CACHE*)" -> "Filesort_info::get_sort_keys()"
"write_keys(Sort_param*,Filesort_info*,uint,IO_CACHE*,IO_CACHE*)" -> "my_tmpdir(MY_TMPDIR*)"
"write_keys(Sort_param*,Filesort_info*,uint,IO_CACHE*,IO_CACHE*)" -> "memcpy(void*,const void*,size_t)"
"write_keys(Sort_param*,Filesort_info*,uint,IO_CACHE*,IO_CACHE*)" -> "Filesort_info::sort_buffer(Sort_param*,uint)"
"Filesort_info::get_record_buffer(uint)" -> "Filesort_buffer::get_record_buffer(uint)"
"SQL_SELECT::skip_record(THD*,bool*)" -> "THD::is_error() const"
"register_used_fields(Sort_param*)" -> "bitmap_set_bit(MY_BITMAP*,uint)"
"register_used_fields(Sort_param*)" -> "TABLE::prepare_for_position()"
"trace_filesort_information(Opt_trace_context*,const SORT_FIELD*,uint)" -> "Opt_trace_object::Opt_trace_object(Opt_trace_context*,Opt_trace_context::feature_value)"
"trace_filesort_information(Opt_trace_context*,const SORT_FIELD*,uint)" -> "Opt_trace_array::Opt_trace_array(Opt_trace_context*,const char*,Opt_trace_context::feature_value)"
"trace_filesort_information(Opt_trace_context*,const SORT_FIELD*,uint)" -> "Opt_trace_struct::add_utf8_table(const TABLE*)"
"trace_filesort_information(Opt_trace_context*,const SORT_FIELD*,uint)" -> "Opt_trace_context::is_started() const"
"trace_filesort_information(Opt_trace_context*,const SORT_FIELD*,uint)" -> "Opt_trace_struct::add(const char*,Item*)"
"trace_filesort_information(Opt_trace_context*,const SORT_FIELD*,uint)" -> "Opt_trace_struct::add_alnum(const char*,const char*)"
"Opt_trace_struct::add(const char*,Item*)" -> "Opt_trace_struct::do_add(const char*,Item*)"
"Opt_trace_struct::add(const char*,Item*)" -> "__builtin_expect(long int,long int)"
"Opt_trace_struct::do_add(const char*,Item*)" -> "Opt_trace_struct::do_add(const char*,const char*,size_t,bool)"
"Opt_trace_struct::do_add(const char*,Item*)" -> "String::String(char*,uint32,const CHARSET_INFO*)"
"Opt_trace_struct::do_add(const char*,Item*)" -> "String::ptr() const"
"Opt_trace_struct::do_add(const char*,Item*)" -> "String::length(uint32)"
"Opt_trace_struct::do_add(const char*,Item*)" -> "Opt_trace_struct::do_add_null(const char*)"
"Opt_trace_struct::do_add(const char*,Item*)" -> "String::length() const"
"Opt_trace_struct::do_add_null(const char*)" -> "Opt_trace_stmt::add(const char*,const char*,size_t,bool,bool)"
"Filesort::make_sortorder()" -> "sql_alloc(size_t)"
"Filesort::make_sortorder()" -> "Item_copy::get_item()"
"merge_index(Sort_param*,uchar*,BUFFPEK*,uint,IO_CACHE*,IO_CACHE*)" -> "merge_buffers(Sort_param*,IO_CACHE*,IO_CACHE*,uchar*,BUFFPEK*,BUFFPEK*,BUFFPEK*,int)"
"mysql_trans_prepare_alter_copy_data(THD*)" -> "ha_enable_transaction(THD*,bool)"
"Filesort::Filesort(ORDER*,ha_rows,SQL_SELECT*)" -> "Sql_alloc::Sql_alloc()"
"Diagnostics_area::reset_current_row_for_warning()" -> "Warning_info::reset_current_row_for_warning()"
"Diagnostics_area::reset_current_row_for_warning()" -> "Diagnostics_area::get_warning_info()"
"init_read_record(READ_RECORD*,THD*,TABLE*,SQL_SELECT*,int,bool,bool)" -> "init_rr_cache(THD*,READ_RECORD*)"
"init_read_record(READ_RECORD*,THD*,TABLE*,SQL_SELECT*,int,bool,bool)" -> "handler::ha_rnd_init(bool)"
"init_read_record(READ_RECORD*,THD*,TABLE*,SQL_SELECT*,int,bool,bool)" -> "memcpy(void*,const void*,size_t)"
"init_read_record(READ_RECORD*,THD*,TABLE*,SQL_SELECT*,int,bool,bool)" -> "THD::optimizer_switch_flag(ulonglong) const"
"init_read_record(READ_RECORD*,THD*,TABLE*,SQL_SELECT*,int,bool,bool)" -> "reinit_io_cache(IO_CACHE*,cache_type,my_off_t,pbool,pbool)"
"init_read_record(READ_RECORD*,THD*,TABLE*,SQL_SELECT*,int,bool,bool)" -> "handler::ha_table_flags() const"
"init_read_record(READ_RECORD*,THD*,TABLE*,SQL_SELECT*,int,bool,bool)" -> "memset(void*,int,size_t)"
"init_rr_cache(THD*,READ_RECORD*)" -> "my_malloc(size_t,myf)"
"alter_table_manage_keys(TABLE*,int,Alter_info::enum_enable_or_disable)" -> "handler::ha_disable_indexes(uint)"
"alter_table_manage_keys(TABLE*,int,Alter_info::enum_enable_or_disable)" -> "_current_thd()"
"alter_table_manage_keys(TABLE*,int,Alter_info::enum_enable_or_disable)" -> "push_warning_printf(THD*,Sql_condition::enum_warning_level,uint,const char*,...)"
"alter_table_manage_keys(TABLE*,int,Alter_info::enum_enable_or_disable)" -> "handler::ha_enable_indexes(uint)"
"handler::ha_disable_indexes(uint)" -> "handler::mark_trx_read_write()"
"handler::ha_enable_indexes(uint)" -> "handler::mark_trx_read_write()"
"prep_alter_part_table(THD*,TABLE*,Alter_info*,HA_CREATE_INFO*,Alter_table_ctx*,bool*,bool*)" -> "partition_info::has_same_partitioning(partition_info*)"
"prep_alter_part_table(THD*,TABLE*,Alter_info*,HA_CREATE_INFO*,Alter_table_ctx*,bool*,bool*)" -> "List_iterator<T>::after(T*) [with T = partition_element]"
"prep_alter_part_table(THD*,TABLE*,Alter_info*,HA_CREATE_INFO*,Alter_table_ctx*,bool*,bool*)" -> "List_iterator<T>::List_iterator(List<T>&) [with T = partition_element]"
"prep_alter_part_table(THD*,TABLE*,Alter_info*,HA_CREATE_INFO*,Alter_table_ctx*,bool*,bool*)" -> "partition_info::fix_parser_data(THD*)"
"prep_alter_part_table(THD*,TABLE*,Alter_info*,HA_CREATE_INFO*,Alter_table_ctx*,bool*,bool*)" -> "partition_info::compare_column_values(const void*,const void*)"
"prep_alter_part_table(THD*,TABLE*,Alter_info*,HA_CREATE_INFO*,Alter_table_ctx*,bool*,bool*)" -> "List_iterator<T>::operator++(int) [with T = partition_element]"
"prep_alter_part_table(THD*,TABLE*,Alter_info*,HA_CREATE_INFO*,Alter_table_ctx*,bool*,bool*)" -> "is_name_in_list(char*,List<char>)"
"prep_alter_part_table(THD*,TABLE*,Alter_info*,HA_CREATE_INFO*,Alter_table_ctx*,bool*,bool*)" -> "List_iterator<T>::replace(T*) [with T = partition_element]"
"prep_alter_part_table(THD*,TABLE*,Alter_info*,HA_CREATE_INFO*,Alter_table_ctx*,bool*,bool*)" -> "partition_info::set_up_defaults_for_partitioning(handler*,HA_CREATE_INFO*,uint)"
"prep_alter_part_table(THD*,TABLE*,Alter_info*,HA_CREATE_INFO*,Alter_table_ctx*,bool*,bool*)" -> "set_part_state(Alter_info*,partition_info*,partition_state)"
"prep_alter_part_table(THD*,TABLE*,Alter_info*,HA_CREATE_INFO*,Alter_table_ctx*,bool*,bool*)" -> "partition_info::get_clone()"
"prep_alter_part_table(THD*,TABLE*,Alter_info*,HA_CREATE_INFO*,Alter_table_ctx*,bool*,bool*)" -> "List_iterator<T>::operator++(int) [with T = p_elem_val]"
"prep_alter_part_table(THD*,TABLE*,Alter_info*,HA_CREATE_INFO*,Alter_table_ctx*,bool*,bool*)" -> "mem_alloc_error(size_t)"
"prep_alter_part_table(THD*,TABLE*,Alter_info*,HA_CREATE_INFO*,Alter_table_ctx*,bool*,bool*)" -> "partition_info::is_sub_partitioned()"
"prep_alter_part_table(THD*,TABLE*,Alter_info*,HA_CREATE_INFO*,Alter_table_ctx*,bool*,bool*)" -> "my_error(int,myf,...)"
"prep_alter_part_table(THD*,TABLE*,Alter_info*,HA_CREATE_INFO*,Alter_table_ctx*,bool*,bool*)" -> "std::max(const _Tp&,const _Tp&) [with _Tp = unsigned int]"
"prep_alter_part_table(THD*,TABLE*,Alter_info*,HA_CREATE_INFO*,Alter_table_ctx*,bool*,bool*)" -> "check_native_partitioned(HA_CREATE_INFO*,bool*,partition_info*,THD*)"
"prep_alter_part_table(THD*,TABLE*,Alter_info*,HA_CREATE_INFO*,Alter_table_ctx*,bool*,bool*)" -> "partition_info::check_partition_info(THD*,handlerton**,handler*,HA_CREATE_INFO*,bool)"
"prep_alter_part_table(THD*,TABLE*,Alter_info*,HA_CREATE_INFO*,Alter_table_ctx*,bool*,bool*)" -> "List<T>::push_back(T*) [with T = partition_element]"
"prep_alter_part_table(THD*,TABLE*,Alter_info*,HA_CREATE_INFO*,Alter_table_ctx*,bool*,bool*)" -> "set_engine_all_partitions(partition_info*,handlerton*)"
"prep_alter_part_table(THD*,TABLE*,Alter_info*,HA_CREATE_INFO*,Alter_table_ctx*,bool*,bool*)" -> "List_iterator<T>::remove() [with T = partition_element]"
"prep_alter_part_table(THD*,TABLE*,Alter_info*,HA_CREATE_INFO*,Alter_table_ctx*,bool*,bool*)" -> "List<T>::List(const List<T>&) [with T = char]"
"prep_alter_part_table(THD*,TABLE*,Alter_info*,HA_CREATE_INFO*,Alter_table_ctx*,bool*,bool*)" -> "List_iterator<T>::List_iterator(List<T>&) [with T = p_elem_val]"
"prep_alter_part_table(THD*,TABLE*,Alter_info*,HA_CREATE_INFO*,Alter_table_ctx*,bool*,bool*)" -> "TABLE_SHARE::db_type() const"
"partition_info::has_same_partitioning(partition_info*)" -> "List_iterator<T>::operator++(int) [with T = partition_element]"
"partition_info::has_same_partitioning(partition_info*)" -> "strcmp(const char*,const char*)"
"partition_info::has_same_partitioning(partition_info*)" -> "partition_info::is_sub_partitioned()"
"partition_info::has_same_partitioning(partition_info*)" -> "List_iterator<T>::List_iterator(List<T>&) [with T = char]"
"partition_info::has_same_partitioning(partition_info*)" -> "List_iterator<T>::operator++(int) [with T = char]"
"partition_info::has_same_partitioning(partition_info*)" -> "List_iterator<T>::List_iterator(List<T>&) [with T = p_elem_val]"
"partition_info::has_same_partitioning(partition_info*)" -> "strcmp_null(const char*,const char*)"
"partition_info::has_same_partitioning(partition_info*)" -> "List_iterator<T>::List_iterator(List<T>&) [with T = partition_element]"
"partition_info::has_same_partitioning(partition_info*)" -> "List_iterator<T>::operator++(int) [with T = p_elem_val]"
"strcmp_null(const char*,const char*)" -> "strcmp(const char*,const char*)"
"List_iterator<T>::after(T*) [with T = partition_element]" -> "base_list_iterator::after(void*)"
"List_iterator<T>::replace(T*) [with T = partition_element]" -> "base_list_iterator::replace(void*)"
"partition_info::get_clone()" -> "List_iterator<T>::List_iterator(List<T>&) [with T = partition_element]"
"partition_info::get_clone()" -> "memset(void*,int,size_t)"
"partition_info::get_clone()" -> "partition_element::partition_element()"
"partition_info::get_clone()" -> "List_iterator<T>::operator++(int) [with T = partition_element]"
"partition_info::get_clone()" -> "partition_info::partition_info()"
"partition_info::get_clone()" -> "memcpy(void*,const void*,size_t)"
"partition_info::get_clone()" -> "List<T>::push_back(T*) [with T = partition_element]"
"partition_info::get_clone()" -> "mem_alloc_error(size_t)"
"partition_info::get_clone()" -> "base_list::empty()"
"check_native_partitioned(HA_CREATE_INFO*,bool*,partition_info*,THD*)" -> "partition_info::check_engine_mix(handlerton*,bool)"
"check_native_partitioned(HA_CREATE_INFO*,bool*,partition_info*,THD*)" -> "my_error(int,myf,...)"
"partition_info::check_engine_mix(handlerton*,bool)" -> "my_error(int,myf,...)"
"partition_info::check_engine_mix(handlerton*,bool)" -> "List_iterator<T>::List_iterator(List<T>&) [with T = partition_element]"
"partition_info::check_engine_mix(handlerton*,bool)" -> "check_engine_condition(partition_element*,bool,handlerton**,bool*)"
"partition_info::check_engine_mix(handlerton*,bool)" -> "List_iterator<T>::operator++(int) [with T = partition_element]"
"partition_info::check_engine_mix(handlerton*,bool)" -> "partition_info::is_sub_partitioned()"
"partition_info::check_partition_info(THD*,handlerton**,handler*,HA_CREATE_INFO*,bool)" -> "partition_info::find_duplicate_field()"
"partition_info::check_partition_info(THD*,handlerton**,handler*,HA_CREATE_INFO*,bool)" -> "strlen(const char*)"
"partition_info::check_partition_info(THD*,handlerton**,handler*,HA_CREATE_INFO*,bool)" -> "__builtin_expect(long int,long int)"
"partition_info::check_partition_info(THD*,handlerton**,handler*,HA_CREATE_INFO*,bool)" -> "partition_info::set_up_defaults_for_partitioning(handler*,HA_CREATE_INFO*,uint)"
"partition_info::check_partition_info(THD*,handlerton**,handler*,HA_CREATE_INFO*,bool)" -> "partition_info::fix_parser_data(THD*)"
"partition_info::check_partition_info(THD*,handlerton**,handler*,HA_CREATE_INFO*,bool)" -> "partition_info::check_range_constants(THD*)"
"partition_info::check_partition_info(THD*,handlerton**,handler*,HA_CREATE_INFO*,bool)" -> "partition_info::is_sub_partitioned()"
"partition_info::check_partition_info(THD*,handlerton**,handler*,HA_CREATE_INFO*,bool)" -> "List_iterator<T>::operator++(int) [with T = partition_element]"
"partition_info::check_partition_info(THD*,handlerton**,handler*,HA_CREATE_INFO*,bool)" -> "partition_info::check_list_constants(THD*)"
"partition_info::check_partition_info(THD*,handlerton**,handler*,HA_CREATE_INFO*,bool)" -> "check_table_name(const char*,size_t,bool)"
"partition_info::check_partition_info(THD*,handlerton**,handler*,HA_CREATE_INFO*,bool)" -> "partition_info::get_tot_partitions()"
"partition_info::check_partition_info(THD*,handlerton**,handler*,HA_CREATE_INFO*,bool)" -> "warn_if_dir_in_part_elem(THD*,partition_element*)"
"partition_info::check_partition_info(THD*,handlerton**,handler*,HA_CREATE_INFO*,bool)" -> "partition_info::find_duplicate_name()"
"partition_info::check_partition_info(THD*,handlerton**,handler*,HA_CREATE_INFO*,bool)" -> "my_error(int,myf,...)"
"partition_info::check_partition_info(THD*,handlerton**,handler*,HA_CREATE_INFO*,bool)" -> "List_iterator<T>::List_iterator(List<T>&) [with T = partition_element]"
"partition_info::check_partition_info(THD*,handlerton**,handler*,HA_CREATE_INFO*,bool)" -> "partition_info::check_engine_mix(handlerton*,bool)"
"partition_info::find_duplicate_field()" -> "List_iterator<T>::operator++(int) [with T = char]"
"partition_info::find_duplicate_field()" -> "List_iterator<T>::List_iterator(List<T>&) [with T = char]"
"partition_info::get_tot_partitions()" -> "partition_info::is_sub_partitioned()"
"warn_if_dir_in_part_elem(THD*,partition_element*)" -> "push_warning_printf(THD*,Sql_condition::enum_warning_level,uint,const char*,...)"
"warn_if_dir_in_part_elem(THD*,partition_element*)" -> "_current_thd()"
"partition_info::find_duplicate_name()" -> "List_iterator<T>::List_iterator(List<T>&) [with T = partition_element]"
"partition_info::find_duplicate_name()" -> "base_list::is_empty() const"
"partition_info::find_duplicate_name()" -> "my_hash_insert(HASH*,const uchar*)"
"partition_info::find_duplicate_name()" -> "_my_hash_init(HASH*,uint,CHARSET_INFO*,my_hash_function,ulong,size_t,size_t,my_hash_get_key,void (*)(void*),uint)"
"partition_info::find_duplicate_name()" -> "partition_info::is_sub_partitioned()"
"partition_info::find_duplicate_name()" -> "List_iterator<T>::operator++(int) [with T = partition_element]"
"partition_info::find_duplicate_name()" -> "my_hash_free(HASH*)"
"set_engine_all_partitions(partition_info*,handlerton*)" -> "partition_info::is_sub_partitioned()"
"set_engine_all_partitions(partition_info*,handlerton*)" -> "List_iterator<T>::operator++(int) [with T = partition_element]"
"set_engine_all_partitions(partition_info*,handlerton*)" -> "List_iterator<T>::List_iterator(List<T>&) [with T = partition_element]"
"List_iterator<T>::remove() [with T = partition_element]" -> "base_list_iterator::remove()"
"set_table_default_charset(THD*,HA_CREATE_INFO*,char*)" -> "st_ha_create_information::st_ha_create_information()"
"set_table_default_charset(THD*,HA_CREATE_INFO*,char*)" -> "load_db_opt_by_name(THD*,const char*,HA_CREATE_INFO*)"
"simple_rename_or_index_change(THD*,TABLE_LIST*,Alter_info::enum_enable_or_disable,Alter_table_ctx*)" -> "MDL_ticket::downgrade_lock(enum_mdl_type)"
"simple_rename_or_index_change(THD*,TABLE_LIST*,Alter_info::enum_enable_or_disable,Alter_table_ctx*)" -> "Query_cache::invalidate(THD*,TABLE_LIST*,my_bool)"
"simple_rename_or_index_change(THD*,TABLE_LIST*,Alter_info::enum_enable_or_disable,Alter_table_ctx*)" -> "push_warning_printf(THD*,Sql_condition::enum_warning_level,uint,const char*,...)"
"simple_rename_or_index_change(THD*,TABLE_LIST*,Alter_info::enum_enable_or_disable,Alter_table_ctx*)" -> "Statement::query() const"
"simple_rename_or_index_change(THD*,TABLE_LIST*,Alter_info::enum_enable_or_disable,Alter_table_ctx*)" -> "handler::ha_disable_indexes(uint)"
"simple_rename_or_index_change(THD*,TABLE_LIST*,Alter_info::enum_enable_or_disable,Alter_table_ctx*)" -> "mysql_rename_table(handlerton*,const char*,const char*,const char*,const char*,uint)"
"simple_rename_or_index_change(THD*,TABLE_LIST*,Alter_info::enum_enable_or_disable,Alter_table_ctx*)" -> "my_ok(THD*,ulonglong,ulonglong,const char*)"
"simple_rename_or_index_change(THD*,TABLE_LIST*,Alter_info::enum_enable_or_disable,Alter_table_ctx*)" -> "Table_triggers_list::change_table_name(THD*,const char*,const char*,const char*,const char*,const char*)"
"simple_rename_or_index_change(THD*,TABLE_LIST*,Alter_info::enum_enable_or_disable,Alter_table_ctx*)" -> "THD::enter_stage(const PSI_stage_info*,PSI_stage_info*,const char*,const char*,unsigned int)"
"simple_rename_or_index_change(THD*,TABLE_LIST*,Alter_info::enum_enable_or_disable,Alter_table_ctx*)" -> "MDL_context::release_all_locks_for_name(MDL_ticket*)"
"simple_rename_or_index_change(THD*,TABLE_LIST*,Alter_info::enum_enable_or_disable,Alter_table_ctx*)" -> "Statement::query_length() const"
"simple_rename_or_index_change(THD*,TABLE_LIST*,Alter_info::enum_enable_or_disable,Alter_table_ctx*)" -> "close_all_tables_for_name(THD*,TABLE_SHARE*,bool,TABLE*)"
"simple_rename_or_index_change(THD*,TABLE_LIST*,Alter_info::enum_enable_or_disable,Alter_table_ctx*)" -> "handler::ha_enable_indexes(uint)"
"simple_rename_or_index_change(THD*,TABLE_LIST*,Alter_info::enum_enable_or_disable,Alter_table_ctx*)" -> "write_bin_log(THD*,bool,const char*,ulong,bool)"
"simple_rename_or_index_change(THD*,TABLE_LIST*,Alter_info::enum_enable_or_disable,Alter_table_ctx*)" -> "lock_tables(THD*,TABLE_LIST*,uint,uint)"
"simple_rename_or_index_change(THD*,TABLE_LIST*,Alter_info::enum_enable_or_disable,Alter_table_ctx*)" -> "_current_thd()"
"simple_rename_or_index_change(THD*,TABLE_LIST*,Alter_info::enum_enable_or_disable,Alter_table_ctx*)" -> "TABLE_SHARE::db_type() const"
"simple_rename_or_index_change(THD*,TABLE_LIST*,Alter_info::enum_enable_or_disable,Alter_table_ctx*)" -> "wait_while_table_is_used(THD*,TABLE*,ha_extra_function)"
"simple_rename_or_index_change(THD*,TABLE_LIST*,Alter_info::enum_enable_or_disable,Alter_table_ctx*)" -> "Alter_table_ctx::is_table_renamed() const"
"MDL_context::release_all_locks_for_name(MDL_ticket*)" -> "MDL_context::release_lock(enum_mdl_duration,MDL_ticket*)"
"MDL_context::release_all_locks_for_name(MDL_ticket*)" -> "L>::operator++(int) [with T = MDL_ticket,L = I_P_List<MDL_ticket,I_P_List_adapter<MDL_ticket,&MDL_ticket::next_in_context,&MDL_ticket::prev_in_context> >]"
"MDL_context::release_all_locks_for_name(MDL_ticket*)" -> "L>::I_P_List_iterator(const L&) [with T = MDL_ticket,L = I_P_List<MDL_ticket,I_P_List_adapter<MDL_ticket,&MDL_ticket::next_in_context,&MDL_ticket::prev_in_context> >]"
"open_table_uncached(THD*,const char*,const char*,const char*,bool,bool)" -> "modify_slave_open_temp_tables(THD*,int)"
"open_table_uncached(THD*,const char*,const char*,const char*,bool,bool)" -> "create_table_def_key(THD*,char*,const char*,const char*,bool)"
"open_table_uncached(THD*,const char*,const char*,const char*,bool,bool)" -> "TABLE::set_created()"
"open_table_uncached(THD*,const char*,const char*,const char*,bool,bool)" -> "my_free(void*)"
"open_table_uncached(THD*,const char*,const char*,const char*,bool,bool)" -> "memcpy(void*,const void*,size_t)"
"open_table_uncached(THD*,const char*,const char*,const char*,bool,bool)" -> "open_table_def(THD*,TABLE_SHARE*,uint)"
"open_table_uncached(THD*,const char*,const char*,const char*,bool,bool)" -> "init_tmp_table_share(THD*,TABLE_SHARE*,const char*,uint,const char*,const char*)"
"open_table_uncached(THD*,const char*,const char*,const char*,bool,bool)" -> "handler::has_transactions()"
"open_table_uncached(THD*,const char*,const char*,const char*,bool,bool)" -> "strend(const char*)"
"open_table_uncached(THD*,const char*,const char*,const char*,bool,bool)" -> "free_table_share(TABLE_SHARE*)"
"open_table_uncached(THD*,const char*,const char*,const char*,bool,bool)" -> "open_table_from_share(THD*,TABLE_SHARE*,const char*,uint,uint,uint,TABLE*,bool)"
"open_table_uncached(THD*,const char*,const char*,const char*,bool,bool)" -> "my_malloc(size_t,myf)"
"open_table_uncached(THD*,const char*,const char*,const char*,bool,bool)" -> "strlen(const char*)"
"open_table_uncached(THD*,const char*,const char*,const char*,bool,bool)" -> "__builtin_stpcpy(char*,const char*)"
"Alter_table_prelocking_strategy::Alter_table_prelocking_strategy()" -> "Prelocking_strategy::Prelocking_strategy()"
"create_table_impl(THD*,const char*,const char*,const char*,HA_CREATE_INFO*,Alter_info*,bool,uint,bool,bool*,KEY**,uint*)" -> "List_iterator_fast<T>::List_iterator_fast(List<T>&) [with T = Key]"
"create_table_impl(THD*,const char*,const char*,const char*,HA_CREATE_INFO*,Alter_info*,bool,uint,bool,bool*,KEY**,uint*)" -> "open_table_def(THD*,TABLE_SHARE*,uint)"
"create_table_impl(THD*,const char*,const char*,const char*,HA_CREATE_INFO*,Alter_info*,bool,uint,bool,bool*,KEY**,uint*)" -> "generate_partition_syntax(partition_info*,uint*,bool,bool,HA_CREATE_INFO*,Alter_info*,const char*)"
"create_table_impl(THD*,const char*,const char*,const char*,HA_CREATE_INFO*,Alter_info*,bool,uint,bool,bool*,KEY**,uint*)" -> "free_table_share(TABLE_SHARE*)"
"create_table_impl(THD*,const char*,const char*,const char*,HA_CREATE_INFO*,Alter_info*,bool,uint,bool,bool*,KEY**,uint*)" -> "ha_table_exists_in_engine(THD*,const char*,const char*)"
"create_table_impl(THD*,const char*,const char*,const char*,HA_CREATE_INFO*,Alter_info*,bool,uint,bool,bool*,KEY**,uint*)" -> "handler::has_transactions()"
"create_table_impl(THD*,const char*,const char*,const char*,HA_CREATE_INFO*,Alter_info*,bool,uint,bool,bool*,KEY**,uint*)" -> "check_partition_dirs(partition_info*)"
"create_table_impl(THD*,const char*,const char*,const char*,HA_CREATE_INFO*,Alter_info*,bool,uint,bool,bool*,KEY**,uint*)" -> "partition_info::is_sub_partitioned()"
"create_table_impl(THD*,const char*,const char*,const char*,HA_CREATE_INFO*,Alter_info*,bool,uint,bool,bool*,KEY**,uint*)" -> "get_ha_partition(partition_info*)"
"create_table_impl(THD*,const char*,const char*,const char*,HA_CREATE_INFO*,Alter_info*,bool,uint,bool,bool*,KEY**,uint*)" -> "table_case_name(HA_CREATE_INFO*,const char*)"
"create_table_impl(THD*,const char*,const char*,const char*,HA_CREATE_INFO*,Alter_info*,bool,uint,bool,bool*,KEY**,uint*)" -> "find_temporary_table(THD*,const char*,const char*)"
"create_table_impl(THD*,const char*,const char*,const char*,HA_CREATE_INFO*,Alter_info*,bool,uint,bool,bool*,KEY**,uint*)" -> "strlen(const char*)"
"create_table_impl(THD*,const char*,const char*,const char*,HA_CREATE_INFO*,Alter_info*,bool,uint,bool,bool*,KEY**,uint*)" -> "handler::ha_create_handler_files(const char*,const char*,int,HA_CREATE_INFO*)"
"create_table_impl(THD*,const char*,const char*,const char*,HA_CREATE_INFO*,Alter_info*,bool,uint,bool,bool*,KEY**,uint*)" -> "rea_create_table(THD*,const char*,const char*,const char*,HA_CREATE_INFO*,List<Create_field>&,uint,KEY*,handler*,bool)"
"create_table_impl(THD*,const char*,const char*,const char*,HA_CREATE_INFO*,Alter_info*,bool,uint,bool,bool*,KEY**,uint*)" -> "dirname_part(char*,const char*,size_t*)"
"create_table_impl(THD*,const char*,const char*,const char*,HA_CREATE_INFO*,Alter_info*,bool,uint,bool,bool*,KEY**,uint*)" -> "access(const char*,int)"
"create_table_impl(THD*,const char*,const char*,const char*,HA_CREATE_INFO*,Alter_info*,bool,uint,bool,bool*,KEY**,uint*)" -> "List_iterator<T>::List_iterator(List<T>&) [with T = partition_element]"
"create_table_impl(THD*,const char*,const char*,const char*,HA_CREATE_INFO*,Alter_info*,bool,uint,bool,bool*,KEY**,uint*)" -> "List_iterator_fast<T>::operator++(int) [with T = Key]"
"create_table_impl(THD*,const char*,const char*,const char*,HA_CREATE_INFO*,Alter_info*,bool,uint,bool,bool*,KEY**,uint*)" -> "mem_alloc_error(size_t)"
"create_table_impl(THD*,const char*,const char*,const char*,HA_CREATE_INFO*,Alter_info*,bool,uint,bool,bool*,KEY**,uint*)" -> "set_table_default_charset(THD*,HA_CREATE_INFO*,char*)"
"create_table_impl(THD*,const char*,const char*,const char*,HA_CREATE_INFO*,Alter_info*,bool,uint,bool,bool*,KEY**,uint*)" -> "open_table_from_share(THD*,TABLE_SHARE*,const char*,uint,uint,uint,TABLE*,bool)"
"create_table_impl(THD*,const char*,const char*,const char*,HA_CREATE_INFO*,Alter_info*,bool,uint,bool,bool*,KEY**,uint*)" -> "my_message(uint,const char*,myf)"
"create_table_impl(THD*,const char*,const char*,const char*,HA_CREATE_INFO*,Alter_info*,bool,uint,bool,bool*,KEY**,uint*)" -> "partition_info::check_partition_info(THD*,handlerton**,handler*,HA_CREATE_INFO*,bool)"
"create_table_impl(THD*,const char*,const char*,const char*,HA_CREATE_INFO*,Alter_info*,bool,uint,bool,bool*,KEY**,uint*)" -> "get_new_handler(TABLE_SHARE*,MEM_ROOT*,handlerton*)"
"create_table_impl(THD*,const char*,const char*,const char*,HA_CREATE_INFO*,Alter_info*,bool,uint,bool,bool*,KEY**,uint*)" -> "partition_info::partition_info()"
"create_table_impl(THD*,const char*,const char*,const char*,HA_CREATE_INFO*,Alter_info*,bool,uint,bool,bool*,KEY**,uint*)" -> "init_tmp_table_share(THD*,TABLE_SHARE*,const char*,uint,const char*,const char*)"
"create_table_impl(THD*,const char*,const char*,const char*,HA_CREATE_INFO*,Alter_info*,bool,uint,bool,bool*,KEY**,uint*)" -> "rm_temporary_table(handlerton*,const char*)"
"create_table_impl(THD*,const char*,const char*,const char*,HA_CREATE_INFO*,Alter_info*,bool,uint,bool,bool*,KEY**,uint*)" -> "inline_mysql_mutex_lock(mysql_mutex_t*)"
"create_table_impl(THD*,const char*,const char*,const char*,HA_CREATE_INFO*,Alter_info*,bool,uint,bool,bool*,KEY**,uint*)" -> "TABLE::TABLE()"
"create_table_impl(THD*,const char*,const char*,const char*,HA_CREATE_INFO*,Alter_info*,bool,uint,bool,bool*,KEY**,uint*)" -> "TABLE_SHARE::TABLE_SHARE()"
"create_table_impl(THD*,const char*,const char*,const char*,HA_CREATE_INFO*,Alter_info*,bool,uint,bool,bool*,KEY**,uint*)" -> "check_engine(THD*,const char*,const char*,HA_CREATE_INFO*)"
"create_table_impl(THD*,const char*,const char*,const char*,HA_CREATE_INFO*,Alter_info*,bool,uint,bool,bool*,KEY**,uint*)" -> "get_cached_table_share(const char*,const char*)"
"create_table_impl(THD*,const char*,const char*,const char*,HA_CREATE_INFO*,Alter_info*,bool,uint,bool,bool*,KEY**,uint*)" -> "mysql_prepare_create_table(THD*,HA_CREATE_INFO*,Alter_info*,bool,uint*,handler*,KEY**,uint*,int)"
"create_table_impl(THD*,const char*,const char*,const char*,HA_CREATE_INFO*,Alter_info*,bool,uint,bool,bool*,KEY**,uint*)" -> "inline_mysql_file_delete(const char*,myf)"
"create_table_impl(THD*,const char*,const char*,const char*,HA_CREATE_INFO*,Alter_info*,bool,uint,bool,bool*,KEY**,uint*)" -> "validate_comment_length(THD*,const char*,size_t*,uint,uint,const char*)"
"create_table_impl(THD*,const char*,const char*,const char*,HA_CREATE_INFO*,Alter_info*,bool,uint,bool,bool*,KEY**,uint*)" -> "open_table_uncached(THD*,const char*,const char*,const char*,bool,bool)"
"create_table_impl(THD*,const char*,const char*,const char*,HA_CREATE_INFO*,Alter_info*,bool,uint,bool,bool*,KEY**,uint*)" -> "test_if_data_home_dir(const char*)"
"create_table_impl(THD*,const char*,const char*,const char*,HA_CREATE_INFO*,Alter_info*,bool,uint,bool,bool*,KEY**,uint*)" -> "_current_thd()"
"create_table_impl(THD*,const char*,const char*,const char*,HA_CREATE_INFO*,Alter_info*,bool,uint,bool,bool*,KEY**,uint*)" -> "inline_mysql_mutex_unlock(mysql_mutex_t*)"
"create_table_impl(THD*,const char*,const char*,const char*,HA_CREATE_INFO*,Alter_info*,bool,uint,bool,bool*,KEY**,uint*)" -> "my_error(int,myf,...)"
"create_table_impl(THD*,const char*,const char*,const char*,HA_CREATE_INFO*,Alter_info*,bool,uint,bool,bool*,KEY**,uint*)" -> "List_iterator<T>::operator++(int) [with T = partition_element]"
"create_table_impl(THD*,const char*,const char*,const char*,HA_CREATE_INFO*,Alter_info*,bool,uint,bool,bool*,KEY**,uint*)" -> "ha_checktype(THD*,legacy_db_type,bool,bool)"
"create_table_impl(THD*,const char*,const char*,const char*,HA_CREATE_INFO*,Alter_info*,bool,uint,bool,bool*,KEY**,uint*)" -> "strxnmov(char*,size_t,const char*,...)"
"create_table_impl(THD*,const char*,const char*,const char*,HA_CREATE_INFO*,Alter_info*,bool,uint,bool,bool*,KEY**,uint*)" -> "THD::enter_stage(const PSI_stage_info*,PSI_stage_info*,const char*,const char*,unsigned int)"
"create_table_impl(THD*,const char*,const char*,const char*,HA_CREATE_INFO*,Alter_info*,bool,uint,bool,bool*,KEY**,uint*)" -> "closefrm(TABLE*,bool)"
"create_table_impl(THD*,const char*,const char*,const char*,HA_CREATE_INFO*,Alter_info*,bool,uint,bool,bool*,KEY**,uint*)" -> "push_warning_printf(THD*,Sql_condition::enum_warning_level,uint,const char*,...)"
"List_iterator_fast<T>::List_iterator_fast(List<T>&) [with T = Key]" -> "base_list_iterator::base_list_iterator(base_list&)"
"generate_partition_syntax(partition_info*,uint*,bool,bool,HA_CREATE_INFO*,Alter_info*,const char*)" -> "add_string_len(File,const char*,uint)"
"generate_partition_syntax(partition_info*,uint*,bool,bool,HA_CREATE_INFO*,Alter_info*,const char*)" -> "add_space(File)"
"generate_partition_syntax(partition_info*,uint*,bool,bool,HA_CREATE_INFO*,Alter_info*,const char*)" -> "add_part_field_list(File,List<char>)"
"generate_partition_syntax(partition_info*,uint*,bool,bool,HA_CREATE_INFO*,Alter_info*,const char*)" -> "add_end_parenthesis(File)"
"generate_partition_syntax(partition_info*,uint*,bool,bool,HA_CREATE_INFO*,Alter_info*,const char*)" -> "add_part_key_word(File,const char*)"
"generate_partition_syntax(partition_info*,uint*,bool,bool,HA_CREATE_INFO*,Alter_info*,const char*)" -> "List_iterator<T>::operator++(int) [with T = partition_element]"
"generate_partition_syntax(partition_info*,uint*,bool,bool,HA_CREATE_INFO*,Alter_info*,const char*)" -> "add_partition_options(File,partition_element*)"
"generate_partition_syntax(partition_info*,uint*,bool,bool,HA_CREATE_INFO*,Alter_info*,const char*)" -> "add_int(File,longlong)"
"generate_partition_syntax(partition_info*,uint*,bool,bool,HA_CREATE_INFO*,Alter_info*,const char*)" -> "add_subpartition_by(File)"
"generate_partition_syntax(partition_info*,uint*,bool,bool,HA_CREATE_INFO*,Alter_info*,const char*)" -> "my_tmpdir(MY_TMPDIR*)"
"generate_partition_syntax(partition_info*,uint*,bool,bool,HA_CREATE_INFO*,Alter_info*,const char*)" -> "add_begin_parenthesis(File)"
"generate_partition_syntax(partition_info*,uint*,bool,bool,HA_CREATE_INFO*,Alter_info*,const char*)" -> "__builtin_expect(long int,long int)"
"generate_partition_syntax(partition_info*,uint*,bool,bool,HA_CREATE_INFO*,Alter_info*,const char*)" -> "inline_mysql_file_close(File,myf)"
"generate_partition_syntax(partition_info*,uint*,bool,bool,HA_CREATE_INFO*,Alter_info*,const char*)" -> "sql_alloc(size_t)"
"generate_partition_syntax(partition_info*,uint*,bool,bool,HA_CREATE_INFO*,Alter_info*,const char*)" -> "add_string(File,const char*)"
"generate_partition_syntax(partition_info*,uint*,bool,bool,HA_CREATE_INFO*,Alter_info*,const char*)" -> "add_partition_by(File)"
"generate_partition_syntax(partition_info*,uint*,bool,bool,HA_CREATE_INFO*,Alter_info*,const char*)" -> "add_partition(File)"
"generate_partition_syntax(partition_info*,uint*,bool,bool,HA_CREATE_INFO*,Alter_info*,const char*)" -> "add_key_with_algorithm(File,partition_info*,const char*)"
"generate_partition_syntax(partition_info*,uint*,bool,bool,HA_CREATE_INFO*,Alter_info*,const char*)" -> "inline_mysql_file_read(File,uchar*,size_t,myf)"
"generate_partition_syntax(partition_info*,uint*,bool,bool,HA_CREATE_INFO*,Alter_info*,const char*)" -> "partition_info::is_sub_partitioned()"
"generate_partition_syntax(partition_info*,uint*,bool,bool,HA_CREATE_INFO*,Alter_info*,const char*)" -> "add_comma(File)"
"generate_partition_syntax(partition_info*,uint*,bool,bool,HA_CREATE_INFO*,Alter_info*,const char*)" -> "List_iterator<T>::List_iterator(List<T>&) [with T = partition_element]"
"generate_partition_syntax(partition_info*,uint*,bool,bool,HA_CREATE_INFO*,Alter_info*,const char*)" -> "unlink(const char*)"
"generate_partition_syntax(partition_info*,uint*,bool,bool,HA_CREATE_INFO*,Alter_info*,const char*)" -> "add_name_string(File,const char*)"
"generate_partition_syntax(partition_info*,uint*,bool,bool,HA_CREATE_INFO*,Alter_info*,const char*)" -> "inline_mysql_file_seek(File,my_off_t,int,myf)"
"generate_partition_syntax(partition_info*,uint*,bool,bool,HA_CREATE_INFO*,Alter_info*,const char*)" -> "my_error(int,myf,...)"
"generate_partition_syntax(partition_info*,uint*,bool,bool,HA_CREATE_INFO*,Alter_info*,const char*)" -> "List<T>::List(const List<T>&) [with T = char]"
"generate_partition_syntax(partition_info*,uint*,bool,bool,HA_CREATE_INFO*,Alter_info*,const char*)" -> "add_partition_values(File,partition_info*,partition_element*,HA_CREATE_INFO*,Alter_info*)"
"generate_partition_syntax(partition_info*,uint*,bool,bool,HA_CREATE_INFO*,Alter_info*,const char*)" -> "add_subpartition(File)"
"generate_partition_syntax(partition_info*,uint*,bool,bool,HA_CREATE_INFO*,Alter_info*,const char*)" -> "my_malloc(size_t,myf)"
"generate_partition_syntax(partition_info*,uint*,bool,bool,HA_CREATE_INFO*,Alter_info*,const char*)" -> "create_temp_file(char*,const char*,const char*,int,myf)"
"generate_partition_syntax(partition_info*,uint*,bool,bool,HA_CREATE_INFO*,Alter_info*,const char*)" -> "my_free(void*)"
"add_string_len(File,const char*,uint)" -> "add_write(File,const char*,uint)"
"add_write(File,const char*,uint)" -> "__builtin_expect(long int,long int)"
"add_write(File,const char*,uint)" -> "inline_mysql_file_write(File,const uchar*,size_t,myf)"
"add_space(File)" -> "add_string(File,const char*)"
"add_string(File,const char*)" -> "add_write(File,const char*,uint)"
"add_string(File,const char*)" -> "strlen(const char*)"
"add_part_field_list(File,List<char>)" -> "add_end_parenthesis(File)"
"add_part_field_list(File,List<char>)" -> "List_iterator<T>::List_iterator(List<T>&) [with T = char]"
"add_part_field_list(File,List<char>)" -> "_current_thd()"
"add_part_field_list(File,List<char>)" -> "String::String(const char*,uint32,const CHARSET_INFO*)"
"add_part_field_list(File,List<char>)" -> "add_comma(File)"
"add_part_field_list(File,List<char>)" -> "add_string_object(File,String*)"
"add_part_field_list(File,List<char>)" -> "append_identifier(THD*,String*,const char*,uint)"
"add_part_field_list(File,List<char>)" -> "add_begin_parenthesis(File)"
"add_part_field_list(File,List<char>)" -> "strlen(const char*)"
"add_part_field_list(File,List<char>)" -> "List_iterator<T>::operator++(int) [with T = char]"
"add_end_parenthesis(File)" -> "add_string(File,const char*)"
"add_comma(File)" -> "add_string(File,const char*)"
"add_string_object(File,String*)" -> "add_write(File,const char*,uint)"
"add_string_object(File,String*)" -> "String::length() const"
"add_string_object(File,String*)" -> "String::ptr() const"
"add_begin_parenthesis(File)" -> "add_string(File,const char*)"
"add_part_key_word(File,const char*)" -> "add_space(File)"
"add_part_key_word(File,const char*)" -> "add_string(File,const char*)"
"add_partition_options(File,partition_element*)" -> "add_keyword_string(File,const char*,bool,const char*)"
"add_partition_options(File,partition_element*)" -> "add_engine(File,handlerton*)"
"add_partition_options(File,partition_element*)" -> "add_keyword_int(File,const char*,longlong)"
"add_partition_options(File,partition_element*)" -> "_current_thd()"
"add_partition_options(File,partition_element*)" -> "add_space(File)"
"add_partition_options(File,partition_element*)" -> "add_keyword_path(File,const char*,const char*)"
"add_keyword_string(File,const char*,bool,const char*)" -> "add_quoted_string(File,const char*)"
"add_keyword_string(File,const char*,bool,const char*)" -> "add_equal(File)"
"add_keyword_string(File,const char*,bool,const char*)" -> "add_string(File,const char*)"
"add_keyword_string(File,const char*,bool,const char*)" -> "add_space(File)"
"add_quoted_string(File,const char*)" -> "add_string(File,const char*)"
"add_quoted_string(File,const char*)" -> "String::c_ptr_safe()"
"add_quoted_string(File,const char*)" -> "append_escaped(String*,String*)"
"add_quoted_string(File,const char*)" -> "String::String()"
"add_quoted_string(File,const char*)" -> "String::String(const char*,const CHARSET_INFO*)"
"append_escaped(String*,String*)" -> "String::realloc(uint32)"
"append_escaped(String*,String*)" -> "String::ptr() const"
"append_escaped(String*,String*)" -> "String::length() const"
"append_escaped(String*,String*)" -> "String::append(char)"
"add_equal(File)" -> "add_string(File,const char*)"
"add_engine(File,handlerton*)" -> "add_string(File,const char*)"
"add_engine(File,handlerton*)" -> "ha_resolve_storage_engine_name(const handlerton*)"
"add_keyword_int(File,const char*,longlong)" -> "add_equal(File)"
"add_keyword_int(File,const char*,longlong)" -> "add_space(File)"
"add_keyword_int(File,const char*,longlong)" -> "add_string(File,const char*)"
"add_keyword_int(File,const char*,longlong)" -> "add_int(File,longlong)"
"add_int(File,longlong)" -> "llstr(longlong,char*)"
"add_int(File,longlong)" -> "add_string(File,const char*)"
"add_keyword_path(File,const char*,const char*)" -> "add_equal(File)"
"add_keyword_path(File,const char*,const char*)" -> "add_space(File)"
"add_keyword_path(File,const char*,const char*)" -> "add_string(File,const char*)"
"add_keyword_path(File,const char*,const char*)" -> "add_quoted_string(File,const char*)"
"add_keyword_path(File,const char*,const char*)" -> "truncate_partition_filename(char*)"
"add_keyword_path(File,const char*,const char*)" -> "strcpy(char*,const char*)"
"truncate_partition_filename(char*)" -> "strrchr(char*,int)"
"truncate_partition_filename(char*)" -> "strchr(char*,int)"
"add_subpartition_by(File)" -> "add_string(File,const char*)"
"add_subpartition_by(File)" -> "add_partition_by(File)"
"add_partition_by(File)" -> "strxmov(char*,const char*,...)"
"add_partition_by(File)" -> "add_string(File,const char*)"
"add_partition(File)" -> "strxmov(char*,const char*,...)"
"add_partition(File)" -> "add_string(File,const char*)"
"add_key_with_algorithm(File,partition_info*,const char*)" -> "add_space(File)"
"add_key_with_algorithm(File,partition_info*,const char*)" -> "add_int(File,longlong)"
"add_key_with_algorithm(File,partition_info*,const char*)" -> "add_equal(File)"
"add_key_with_algorithm(File,partition_info*,const char*)" -> "add_part_key_word(File,const char*)"
"add_key_with_algorithm(File,partition_info*,const char*)" -> "add_string(File,const char*)"
"add_name_string(File,const char*)" -> "strlen(const char*)"
"add_name_string(File,const char*)" -> "String::String(const char*,uint32,const CHARSET_INFO*)"
"add_name_string(File,const char*)" -> "add_string_object(File,String*)"
"add_name_string(File,const char*)" -> "_current_thd()"
"add_name_string(File,const char*)" -> "append_identifier(THD*,String*,const char*,uint)"
"add_partition_values(File,partition_info*,partition_element*,HA_CREATE_INFO*,Alter_info*)" -> "List_iterator<T>::operator++(int) [with T = p_elem_val]"
"add_partition_values(File,partition_info*,partition_element*,HA_CREATE_INFO*,Alter_info*)" -> "add_begin_parenthesis(File)"
"add_partition_values(File,partition_info*,partition_element*,HA_CREATE_INFO*,Alter_info*)" -> "add_column_list_values(File,partition_info*,part_elem_value*,HA_CREATE_INFO*,Alter_info*)"
"add_partition_values(File,partition_info*,partition_element*,HA_CREATE_INFO*,Alter_info*)" -> "add_comma(File)"
"add_partition_values(File,partition_info*,partition_element*,HA_CREATE_INFO*,Alter_info*)" -> "add_int(File,longlong)"
"add_partition_values(File,partition_info*,partition_element*,HA_CREATE_INFO*,Alter_info*)" -> "add_uint(File,ulonglong)"
"add_partition_values(File,partition_info*,partition_element*,HA_CREATE_INFO*,Alter_info*)" -> "add_end_parenthesis(File)"
"add_partition_values(File,partition_info*,partition_element*,HA_CREATE_INFO*,Alter_info*)" -> "add_string(File,const char*)"
"add_partition_values(File,partition_info*,partition_element*,HA_CREATE_INFO*,Alter_info*)" -> "List_iterator<T>::List_iterator(List<T>&) [with T = p_elem_val]"
"add_column_list_values(File,partition_info*,part_elem_value*,HA_CREATE_INFO*,Alter_info*)" -> "get_sql_field_charset(Create_field*,HA_CREATE_INFO*)"
"add_column_list_values(File,partition_info*,part_elem_value*,HA_CREATE_INFO*,Alter_info*)" -> "String::String()"
"add_column_list_values(File,partition_info*,part_elem_value*,HA_CREATE_INFO*,Alter_info*)" -> "check_part_field(enum_field_types,const char*,Item_result*,bool*)"
"add_column_list_values(File,partition_info*,part_elem_value*,HA_CREATE_INFO*,Alter_info*)" -> "get_sql_field(char*,Alter_info*)"
"add_column_list_values(File,partition_info*,part_elem_value*,HA_CREATE_INFO*,Alter_info*)" -> "get_cs_converted_part_value_from_string(THD*,Item*,String*,String*,const CHARSET_INFO*,bool)"
"add_column_list_values(File,partition_info*,part_elem_value*,HA_CREATE_INFO*,Alter_info*)" -> "List_iterator<T>::operator++(int) [with T = char]"
"add_column_list_values(File,partition_info*,part_elem_value*,HA_CREATE_INFO*,Alter_info*)" -> "_current_thd()"
"add_column_list_values(File,partition_info*,part_elem_value*,HA_CREATE_INFO*,Alter_info*)" -> "add_string_object(File,String*)"
"add_column_list_values(File,partition_info*,part_elem_value*,HA_CREATE_INFO*,Alter_info*)" -> "List_iterator<T>::List_iterator(List<T>&) [with T = char]"
"add_column_list_values(File,partition_info*,part_elem_value*,HA_CREATE_INFO*,Alter_info*)" -> "convert_charset_partition_constant(Item*,const CHARSET_INFO*)"
"add_column_list_values(File,partition_info*,part_elem_value*,HA_CREATE_INFO*,Alter_info*)" -> "add_end_parenthesis(File)"
"add_column_list_values(File,partition_info*,part_elem_value*,HA_CREATE_INFO*,Alter_info*)" -> "String::String(char*,uint32,const CHARSET_INFO*)"
"add_column_list_values(File,partition_info*,part_elem_value*,HA_CREATE_INFO*,Alter_info*)" -> "add_begin_parenthesis(File)"
"add_column_list_values(File,partition_info*,part_elem_value*,HA_CREATE_INFO*,Alter_info*)" -> "add_string(File,const char*)"
"add_column_list_values(File,partition_info*,part_elem_value*,HA_CREATE_INFO*,Alter_info*)" -> "String::set_charset(const CHARSET_INFO*)"
"add_column_list_values(File,partition_info*,part_elem_value*,HA_CREATE_INFO*,Alter_info*)" -> "my_error(int,myf,...)"
"check_part_field(enum_field_types,const char*,Item_result*,bool*)" -> "my_error(int,myf,...)"
"get_sql_field(char*,Alter_info*)" -> "List_iterator<T>::List_iterator(List<T>&) [with T = Create_field]"
"get_sql_field(char*,Alter_info*)" -> "List_iterator<T>::operator++(int) [with T = Create_field]"
"get_cs_converted_part_value_from_string(THD*,Item*,String*,String*,const CHARSET_INFO*,bool)" -> "get_cs_converted_string_value(THD*,String*,String*,const CHARSET_INFO*,bool)"
"get_cs_converted_part_value_from_string(THD*,Item*,String*,String*,const CHARSET_INFO*,bool)" -> "my_error(int,myf,...)"
"get_cs_converted_part_value_from_string(THD*,Item*,String*,String*,const CHARSET_INFO*,bool)" -> "String::set(longlong,const CHARSET_INFO*)"
"get_cs_converted_string_value(THD*,String*,String*,const CHARSET_INFO*,bool)" -> "String::String()"
"get_cs_converted_string_value(THD*,String*,String*,const CHARSET_INFO*,bool)" -> "String::copy(const char*,uint32,const CHARSET_INFO*,const CHARSET_INFO*,uint*)"
"get_cs_converted_string_value(THD*,String*,String*,const CHARSET_INFO*,bool)" -> "String::append(const char*)"
"get_cs_converted_string_value(THD*,String*,String*,const CHARSET_INFO*,bool)" -> "append_unescaped(String*,const char*,uint)"
"get_cs_converted_string_value(THD*,String*,String*,const CHARSET_INFO*,bool)" -> "String::length(uint32)"
"get_cs_converted_string_value(THD*,String*,String*,const CHARSET_INFO*,bool)" -> "String::length() const"
"get_cs_converted_string_value(THD*,String*,String*,const CHARSET_INFO*,bool)" -> "String::ptr() const"
"add_uint(File,ulonglong)" -> "int2str(long int,char*,int,int)"
"add_uint(File,ulonglong)" -> "add_string(File,const char*)"
"add_subpartition(File)" -> "add_string(File,const char*)"
"add_subpartition(File)" -> "add_partition(File)"
"ha_table_exists_in_engine(THD*,const char*,const char*)" -> "plugin_foreach_with_mask(THD*,my_bool (*)(THD*,plugin_ref,void*),int,uint,void*)"
"check_partition_dirs(partition_info*)" -> "List_iterator<T>::List_iterator(List<T>&) [with T = partition_element]"
"check_partition_dirs(partition_info*)" -> "List_iterator<T>::operator++(int) [with T = partition_element]"
"check_partition_dirs(partition_info*)" -> "my_error(int,myf,...)"
"check_partition_dirs(partition_info*)" -> "test_if_data_home_dir(const char*)"
"test_if_data_home_dir(const char*)" -> "memcmp(const void*,const void*,size_t)"
"test_if_data_home_dir(const char*)" -> "fn_format(char*,const char*,const char*,const char*,uint)"
"test_if_data_home_dir(const char*)" -> "strlen(const char*)"
"get_ha_partition(partition_info*)" -> "ha_partition::initialize_partition(MEM_ROOT*)"
"get_ha_partition(partition_info*)" -> "_current_thd()"
"get_ha_partition(partition_info*)" -> "handler::init()"
"get_ha_partition(partition_info*)" -> "my_error(int,myf,...)"
"get_ha_partition(partition_info*)" -> "ha_partition::ha_partition(handlerton*,partition_info*)"
"ha_partition::initialize_partition(MEM_ROOT*)" -> "partition_info::get_tot_partitions()"
"ha_partition::initialize_partition(MEM_ROOT*)" -> "ha_partition::get_from_handler_file(const char*,MEM_ROOT*,bool)"
"ha_partition::initialize_partition(MEM_ROOT*)" -> "my_error(int,myf,...)"
"ha_partition::initialize_partition(MEM_ROOT*)" -> "ha_partition::new_handlers_from_part_info(MEM_ROOT*)"
"ha_partition::initialize_partition(MEM_ROOT*)" -> "handler::ha_table_flags() const"
"ha_partition::get_from_handler_file(const char*,MEM_ROOT*,bool)" -> "ha_partition::read_par_file(const char*)"
"ha_partition::get_from_handler_file(const char*,MEM_ROOT*,bool)" -> "ha_partition::setup_engine_array(MEM_ROOT*)"
"ha_partition::read_par_file(const char*)" -> "inline_mysql_file_close(File,myf)"
"ha_partition::read_par_file(const char*)" -> "inline_mysql_file_open(const char*,int,myf)"
"ha_partition::read_par_file(const char*)" -> "inline_mysql_file_read(File,uchar*,size_t,myf)"
"ha_partition::read_par_file(const char*)" -> "my_free(void*)"
"ha_partition::read_par_file(const char*)" -> "my_malloc(size_t,myf)"
"ha_partition::read_par_file(const char*)" -> "fn_format(char*,const char*,const char*,const char*,uint)"
"ha_partition::read_par_file(const char*)" -> "inline_mysql_file_seek(File,my_off_t,int,myf)"
"ha_partition::setup_engine_array(MEM_ROOT*)" -> "ha_resolve_by_legacy_type(THD*,legacy_db_type)"
"ha_partition::setup_engine_array(MEM_ROOT*)" -> "my_malloc(size_t,myf)"
"ha_partition::setup_engine_array(MEM_ROOT*)" -> "handler::ha_thd() const"
"ha_partition::setup_engine_array(MEM_ROOT*)" -> "ha_lock_engine(THD*,const handlerton*)"
"ha_partition::setup_engine_array(MEM_ROOT*)" -> "ha_partition::clear_handler_file()"
"ha_partition::setup_engine_array(MEM_ROOT*)" -> "ha_partition::create_handlers(MEM_ROOT*)"
"ha_partition::setup_engine_array(MEM_ROOT*)" -> "__builtin_alloca(long unsigned int)"
"ha_partition::clear_handler_file()" -> "plugin_unlock_list(THD*,st_plugin_int**,uint)"
"ha_partition::clear_handler_file()" -> "my_free(void*)"
"ha_partition::create_handlers(MEM_ROOT*)" -> "memset(void*,int,size_t)"
"ha_partition::create_handlers(MEM_ROOT*)" -> "get_new_handler(TABLE_SHARE*,MEM_ROOT*,handlerton*)"
"ha_partition::create_handlers(MEM_ROOT*)" -> "alloc_root(MEM_ROOT*,size_t)"
"ha_partition::create_handlers(MEM_ROOT*)" -> "ha_legacy_type(const handlerton*)"
"ha_partition::new_handlers_from_part_info(MEM_ROOT*)" -> "memset(void*,int,size_t)"
"ha_partition::new_handlers_from_part_info(MEM_ROOT*)" -> "List_iterator_fast<T>::List_iterator_fast(List<T>&) [with T = partition_element]"
"ha_partition::new_handlers_from_part_info(MEM_ROOT*)" -> "List_iterator_fast<T>::operator++(int) [with T = partition_element]"
"ha_partition::new_handlers_from_part_info(MEM_ROOT*)" -> "alloc_root(MEM_ROOT*,size_t)"
"ha_partition::new_handlers_from_part_info(MEM_ROOT*)" -> "get_new_handler(TABLE_SHARE*,MEM_ROOT*,handlerton*)"
"ha_partition::new_handlers_from_part_info(MEM_ROOT*)" -> "mem_alloc_error(size_t)"
"List_iterator_fast<T>::List_iterator_fast(List<T>&) [with T = partition_element]" -> "base_list_iterator::base_list_iterator(base_list&)"
"List_iterator_fast<T>::operator++(int) [with T = partition_element]" -> "base_list_iterator::next_fast()"
"ha_partition::ha_partition(handlerton*,partition_info*)" -> "partition_info::is_sub_partitioned()"
"ha_partition::ha_partition(handlerton*,partition_info*)" -> "ha_partition::init_handler_variables()"
"ha_partition::ha_partition(handlerton*,partition_info*)" -> "handler::handler(handlerton*,TABLE_SHARE*)"
"ha_partition::ha_partition(handlerton*,partition_info*)" -> "List<T>::List() [with T = Parts_share_refs]"
"ha_partition::init_handler_variables()" -> "base_list::empty()"
"handler::handler(handlerton*,TABLE_SHARE*)" -> "Discrete_interval::Discrete_interval()"
"handler::handler(handlerton*,TABLE_SHARE*)" -> "Sql_alloc::Sql_alloc()"
"handler::handler(handlerton*,TABLE_SHARE*)" -> "ha_statistics::ha_statistics()"
"List<T>::List() [with T = Parts_share_refs]" -> "base_list::base_list()"
"find_temporary_table(THD*,const char*,const char*)" -> "find_temporary_table(THD*,const char*,uint)"
"find_temporary_table(THD*,const char*,const char*)" -> "create_table_def_key(THD*,char*,const char*,const char*,bool)"
"find_temporary_table(THD*,const char*,uint)" -> "memcmp(const void*,const void*,size_t)"
"rea_create_table(THD*,const char*,const char*,const char*,HA_CREATE_INFO*,List<Create_field>&,uint,KEY*,handler*,bool)" -> "handler::ha_create_handler_files(const char*,const char*,int,HA_CREATE_INFO*)"
"rea_create_table(THD*,const char*,const char*,const char*,HA_CREATE_INFO*,List<Create_field>&,uint,KEY*,handler*,bool)" -> "mysql_create_frm(THD*,const char*,const char*,const char*,HA_CREATE_INFO*,List<Create_field>&,uint,KEY*,handler*)"
"rea_create_table(THD*,const char*,const char*,const char*,HA_CREATE_INFO*,List<Create_field>&,uint,KEY*,handler*,bool)" -> "ha_create_table(THD*,const char*,const char*,const char*,HA_CREATE_INFO*,bool,bool)"
"rea_create_table(THD*,const char*,const char*,const char*,HA_CREATE_INFO*,List<Create_field>&,uint,KEY*,handler*,bool)" -> "inline_mysql_file_delete(const char*,myf)"
"rea_create_table(THD*,const char*,const char*,const char*,HA_CREATE_INFO*,List<Create_field>&,uint,KEY*,handler*,bool)" -> "strxmov(char*,const char*,...)"
"mysql_create_frm(THD*,const char*,const char*,const char*,HA_CREATE_INFO*,List<Create_field>&,uint,KEY*,handler*)" -> "validate_comment_length(THD*,const char*,size_t*,uint,uint,const char*)"
"mysql_create_frm(THD*,const char*,const char*,const char*,HA_CREATE_INFO*,List<Create_field>&,uint,KEY*,handler*)" -> "ha_legacy_type(const handlerton*)"
"mysql_create_frm(THD*,const char*,const char*,const char*,HA_CREATE_INFO*,List<Create_field>&,uint,KEY*,handler*)" -> "create_frm(THD*,const char*,const char*,const char*,uint,uchar*,HA_CREATE_INFO*,uint,KEY*)"
"mysql_create_frm(THD*,const char*,const char*,const char*,HA_CREATE_INFO*,List<Create_field>&,uint,KEY*,handler*)" -> "inline_mysql_file_seek(File,my_off_t,int,myf)"
"mysql_create_frm(THD*,const char*,const char*,const char*,HA_CREATE_INFO*,List<Create_field>&,uint,KEY*,handler*)" -> "THD::pop_internal_handler()"
"mysql_create_frm(THD*,const char*,const char*,const char*,HA_CREATE_INFO*,List<Create_field>&,uint,KEY*,handler*)" -> "Create_field::column_format() const"
"mysql_create_frm(THD*,const char*,const char*,const char*,HA_CREATE_INFO*,List<Create_field>&,uint,KEY*,handler*)" -> "inline_mysql_file_delete(const char*,myf)"
"mysql_create_frm(THD*,const char*,const char*,const char*,HA_CREATE_INFO*,List<Create_field>&,uint,KEY*,handler*)" -> "memset(void*,int,size_t)"
"mysql_create_frm(THD*,const char*,const char*,const char*,HA_CREATE_INFO*,List<Create_field>&,uint,KEY*,handler*)" -> "make_new_entry(File,uchar*,TYPELIB*,const char*)"
"mysql_create_frm(THD*,const char*,const char*,const char*,HA_CREATE_INFO*,List<Create_field>&,uint,KEY*,handler*)" -> "inline_mysql_file_pwrite(File,const uchar*,size_t,my_off_t,myf)"
"mysql_create_frm(THD*,const char*,const char*,const char*,HA_CREATE_INFO*,List<Create_field>&,uint,KEY*,handler*)" -> "strmake(char*,const char*,size_t)"
"mysql_create_frm(THD*,const char*,const char*,const char*,HA_CREATE_INFO*,List<Create_field>&,uint,KEY*,handler*)" -> "make_empty_rec(THD*,File,uint,List<Create_field>&,uint,ulong,handler*)"
"mysql_create_frm(THD*,const char*,const char*,const char*,HA_CREATE_INFO*,List<Create_field>&,uint,KEY*,handler*)" -> "memcpy(void*,const void*,size_t)"
"mysql_create_frm(THD*,const char*,const char*,const char*,HA_CREATE_INFO*,List<Create_field>&,uint,KEY*,handler*)" -> "my_malloc(size_t,myf)"
"mysql_create_frm(THD*,const char*,const char*,const char*,HA_CREATE_INFO*,List<Create_field>&,uint,KEY*,handler*)" -> "pack_fields(File,List<Create_field>&,ulong)"
"mysql_create_frm(THD*,const char*,const char*,const char*,HA_CREATE_INFO*,List<Create_field>&,uint,KEY*,handler*)" -> "my_sync_dir_by_file(const char*,myf)"
"mysql_create_frm(THD*,const char*,const char*,const char*,HA_CREATE_INFO*,List<Create_field>&,uint,KEY*,handler*)" -> "pack_header(uchar*,legacy_db_type,List<Create_field>&,uint,uint,uint,ulong,handler*)"
"mysql_create_frm(THD*,const char*,const char*,const char*,HA_CREATE_INFO*,List<Create_field>&,uint,KEY*,handler*)" -> "inline_mysql_file_close(File,myf)"
"mysql_create_frm(THD*,const char*,const char*,const char*,HA_CREATE_INFO*,List<Create_field>&,uint,KEY*,handler*)" -> "my_free(void*)"
"mysql_create_frm(THD*,const char*,const char*,const char*,HA_CREATE_INFO*,List<Create_field>&,uint,KEY*,handler*)" -> "ha_resolve_storage_engine_name(const handlerton*)"
"mysql_create_frm(THD*,const char*,const char*,const char*,HA_CREATE_INFO*,List<Create_field>&,uint,KEY*,handler*)" -> "THD::push_internal_handler(Internal_error_handler*)"
"mysql_create_frm(THD*,const char*,const char*,const char*,HA_CREATE_INFO*,List<Create_field>&,uint,KEY*,handler*)" -> "List_iterator<T>::List_iterator(List<T>&) [with T = Create_field]"
"mysql_create_frm(THD*,const char*,const char*,const char*,HA_CREATE_INFO*,List<Create_field>&,uint,KEY*,handler*)" -> "strlen(const char*)"
"mysql_create_frm(THD*,const char*,const char*,const char*,HA_CREATE_INFO*,List<Create_field>&,uint,KEY*,handler*)" -> "pack_screens(List<Create_field>&,uint*,uint*,bool)"
"mysql_create_frm(THD*,const char*,const char*,const char*,HA_CREATE_INFO*,List<Create_field>&,uint,KEY*,handler*)" -> "List_iterator<T>::operator++(int) [with T = Create_field]"
"mysql_create_frm(THD*,const char*,const char*,const char*,HA_CREATE_INFO*,List<Create_field>&,uint,KEY*,handler*)" -> "inline_mysql_file_sync(File,myf)"
"mysql_create_frm(THD*,const char*,const char*,const char*,HA_CREATE_INFO*,List<Create_field>&,uint,KEY*,handler*)" -> "Pack_header_error_handler::Pack_header_error_handler()"
"mysql_create_frm(THD*,const char*,const char*,const char*,HA_CREATE_INFO*,List<Create_field>&,uint,KEY*,handler*)" -> "next_io_size(ulong)"
"mysql_create_frm(THD*,const char*,const char*,const char*,HA_CREATE_INFO*,List<Create_field>&,uint,KEY*,handler*)" -> "Create_field::field_storage_type() const"
"mysql_create_frm(THD*,const char*,const char*,const char*,HA_CREATE_INFO*,List<Create_field>&,uint,KEY*,handler*)" -> "inline_mysql_file_write(File,const uchar*,size_t,myf)"
"mysql_create_frm(THD*,const char*,const char*,const char*,HA_CREATE_INFO*,List<Create_field>&,uint,KEY*,handler*)" -> "pack_keys(uchar*,uint,KEY*,ulong)"
"validate_comment_length(THD*,const char*,size_t*,uint,uint,const char*)" -> "my_snprintf(char*,size_t,const char*,...)"
"validate_comment_length(THD*,const char*,size_t*,uint,uint,const char*)" -> "Diagnostics_area::has_sql_condition(const char*,ulong) const"
"validate_comment_length(THD*,const char*,size_t*,uint,uint,const char*)" -> "my_error(int,myf,...)"
"validate_comment_length(THD*,const char*,size_t*,uint,uint,const char*)" -> "_current_thd()"
"validate_comment_length(THD*,const char*,size_t*,uint,uint,const char*)" -> "THD::get_stmt_da()"
"validate_comment_length(THD*,const char*,size_t*,uint,uint,const char*)" -> "THD::is_strict_mode() const"
"validate_comment_length(THD*,const char*,size_t*,uint,uint,const char*)" -> "push_warning(THD*,Sql_condition::enum_warning_level,uint,const char*)"
"Diagnostics_area::has_sql_condition(const char*,ulong) const" -> "Warning_info::has_sql_condition(const char*,ulong) const"
"Diagnostics_area::has_sql_condition(const char*,ulong) const" -> "Diagnostics_area::get_warning_info() const"
"Warning_info::has_sql_condition(const char*,ulong) const" -> "L>::I_P_List_iterator(const L&) [with T = const Sql_condition,L = I_P_List<Sql_condition,I_P_List_adapter<Sql_condition,&Sql_condition::next_in_wi,&Sql_condition::prev_in_wi>,I_P_List_counter,I_P_List_fast_push_back<Sql_condition> >]"
"Warning_info::has_sql_condition(const char*,ulong) const" -> "Sql_condition::get_message_text() const"
"Warning_info::has_sql_condition(const char*,ulong) const" -> "strncmp(const char*,const char*,size_t)"
"Warning_info::has_sql_condition(const char*,ulong) const" -> "L>::operator++(int) [with T = const Sql_condition,L = I_P_List<Sql_condition,I_P_List_adapter<Sql_condition,&Sql_condition::next_in_wi,&Sql_condition::prev_in_wi>,I_P_List_counter,I_P_List_fast_push_back<Sql_condition> >]"
"create_frm(THD*,const char*,const char*,const char*,uint,uchar*,HA_CREATE_INFO*,uint,KEY*)" -> "inline_mysql_file_write(File,const uchar*,size_t,myf)"
"create_frm(THD*,const char*,const char*,const char*,uint,uchar*,HA_CREATE_INFO*,uint,KEY*)" -> "inline_mysql_file_close(File,myf)"
"create_frm(THD*,const char*,const char*,const char*,uint,uchar*,HA_CREATE_INFO*,uint,KEY*)" -> "ha_legacy_type(const handlerton*)"
"create_frm(THD*,const char*,const char*,const char*,uint,uchar*,HA_CREATE_INFO*,uint,KEY*)" -> "next_io_size(ulong)"
"create_frm(THD*,const char*,const char*,const char*,uint,uchar*,HA_CREATE_INFO*,uint,KEY*)" -> "ha_checktype(THD*,legacy_db_type,bool,bool)"
"create_frm(THD*,const char*,const char*,const char*,uint,uchar*,HA_CREATE_INFO*,uint,KEY*)" -> "inline_mysql_file_create(const char*,int,int,myf)"
"create_frm(THD*,const char*,const char*,const char*,uint,uchar*,HA_CREATE_INFO*,uint,KEY*)" -> "memset(void*,int,size_t)"
"create_frm(THD*,const char*,const char*,const char*,uint,uchar*,HA_CREATE_INFO*,uint,KEY*)" -> "inline_mysql_file_delete(const char*,myf)"
"create_frm(THD*,const char*,const char*,const char*,uint,uchar*,HA_CREATE_INFO*,uint,KEY*)" -> "_my_thread_var()"
"create_frm(THD*,const char*,const char*,const char*,uint,uchar*,HA_CREATE_INFO*,uint,KEY*)" -> "my_error(int,myf,...)"
"make_new_entry(File,uchar*,TYPELIB*,const char*)" -> "memset(void*,int,size_t)"
"make_new_entry(File,uchar*,TYPELIB*,const char*)" -> "inline_mysql_file_seek(File,my_off_t,int,myf)"
"make_new_entry(File,uchar*,TYPELIB*,const char*)" -> "inline_mysql_file_write(File,const uchar*,size_t,myf)"
"make_new_entry(File,uchar*,TYPELIB*,const char*)" -> "strlen(const char*)"
"make_new_entry(File,uchar*,TYPELIB*,const char*)" -> "strxmov(char*,const char*,...)"
"make_new_entry(File,uchar*,TYPELIB*,const char*)" -> "inline_mysql_file_read(File,uchar*,size_t,myf)"
"make_new_entry(File,uchar*,TYPELIB*,const char*)" -> "inline_mysql_file_chsize(File,my_off_t,int,myf)"
"inline_mysql_file_chsize(File,my_off_t,int,myf)" -> "my_chsize(File,my_off_t,int,myf)"
"make_empty_rec(THD*,File,uint,List<Create_field>&,uint,ulong,handler*)" -> "TABLE_SHARE::TABLE_SHARE()"
"make_empty_rec(THD*,File,uint,List<Create_field>&,uint,ulong,handler*)" -> "my_malloc(size_t,myf)"
"make_empty_rec(THD*,File,uint,List<Create_field>&,uint,ulong,handler*)" -> "make_field(TABLE_SHARE*,uchar*,uint32,uchar*,uchar,uint,enum_field_types,const CHARSET_INFO*,Field::geometry_type,Field::utype,TYPELIB*,const char*,MEM_ROOT*)"
"make_empty_rec(THD*,File,uint,List<Create_field>&,uint,ulong,handler*)" -> "Field::init(TABLE*)"
"make_empty_rec(THD*,File,uint,List<Create_field>&,uint,ulong,handler*)" -> "Field::set_notnull(my_ptrdiff_t)"
"make_empty_rec(THD*,File,uint,List<Create_field>&,uint,ulong,handler*)" -> "inline_mysql_file_write(File,const uchar*,size_t,myf)"
"make_empty_rec(THD*,File,uint,List<Create_field>&,uint,ulong,handler*)" -> "List_iterator<T>::List_iterator(List<T>&) [with T = Create_field]"
"make_empty_rec(THD*,File,uint,List<Create_field>&,uint,ulong,handler*)" -> "memset(void*,int,size_t)"
"make_empty_rec(THD*,File,uint,List<Create_field>&,uint,ulong,handler*)" -> "Field::set_null(my_ptrdiff_t)"
"make_empty_rec(THD*,File,uint,List<Create_field>&,uint,ulong,handler*)" -> "THD::is_error() const"
"make_empty_rec(THD*,File,uint,List<Create_field>&,uint,ulong,handler*)" -> "_current_thd()"
"make_empty_rec(THD*,File,uint,List<Create_field>&,uint,ulong,handler*)" -> "strlen(const char*)"
"make_empty_rec(THD*,File,uint,List<Create_field>&,uint,ulong,handler*)" -> "List_iterator<T>::operator++(int) [with T = Create_field]"
"make_empty_rec(THD*,File,uint,List<Create_field>&,uint,ulong,handler*)" -> "TABLE::TABLE()"
"make_empty_rec(THD*,File,uint,List<Create_field>&,uint,ulong,handler*)" -> "THD::clear_error()"
"make_empty_rec(THD*,File,uint,List<Create_field>&,uint,ulong,handler*)" -> "my_error(int,myf,...)"
"make_empty_rec(THD*,File,uint,List<Create_field>&,uint,ulong,handler*)" -> "my_free(void*)"
"pack_fields(File,List<Create_field>&,ulong)" -> "_current_thd()"
"pack_fields(File,List<Create_field>&,ulong)" -> "List_iterator<T>::operator++(int) [with T = Create_field]"
"pack_fields(File,List<Create_field>&,ulong)" -> "String::ptr() const"
"pack_fields(File,List<Create_field>&,ulong)" -> "String::length() const"
"pack_fields(File,List<Create_field>&,ulong)" -> "String::length(uint32)"
"pack_fields(File,List<Create_field>&,ulong)" -> "List_iterator<T>::rewind() [with T = Create_field]"
"pack_fields(File,List<Create_field>&,ulong)" -> "my_message(uint,const char*,myf)"
"pack_fields(File,List<Create_field>&,ulong)" -> "String::append(const char*)"
"pack_fields(File,List<Create_field>&,ulong)" -> "inline_mysql_file_write(File,const uchar*,size_t,myf)"
"pack_fields(File,List<Create_field>&,ulong)" -> "__builtin_stpcpy(char*,const char*)"
"pack_fields(File,List<Create_field>&,ulong)" -> "memset(void*,int,size_t)"
"pack_fields(File,List<Create_field>&,ulong)" -> "List_iterator<T>::List_iterator(List<T>&) [with T = Create_field]"
"pack_fields(File,List<Create_field>&,ulong)" -> "String::append(char)"
"pack_fields(File,List<Create_field>&,ulong)" -> "String::String(char*,uint32,const CHARSET_INFO*)"
"pack_header(uchar*,legacy_db_type,List<Create_field>&,uint,uint,uint,ulong,handler*)" -> "get_interval_id(uint*,List<Create_field>&,Create_field*)"
"pack_header(uchar*,legacy_db_type,List<Create_field>&,uint,uint,uint,ulong,handler*)" -> "std::max(const _Tp&,const _Tp&) [with _Tp = long unsigned int]"
"pack_header(uchar*,legacy_db_type,List<Create_field>&,uint,uint,uint,ulong,handler*)" -> "handler::max_record_length() const"
"pack_header(uchar*,legacy_db_type,List<Create_field>&,uint,uint,uint,ulong,handler*)" -> "my_error(int,myf,...)"
"pack_header(uchar*,legacy_db_type,List<Create_field>&,uint,uint,uint,ulong,handler*)" -> "List_iterator<T>::List_iterator(List<T>&) [with T = Create_field]"
"pack_header(uchar*,legacy_db_type,List<Create_field>&,uint,uint,uint,ulong,handler*)" -> "octet2hex(char*,const char*,unsigned int)"
"pack_header(uchar*,legacy_db_type,List<Create_field>&,uint,uint,uint,ulong,handler*)" -> "List_iterator<T>::operator++(int) [with T = Create_field]"
"pack_header(uchar*,legacy_db_type,List<Create_field>&,uint,uint,uint,ulong,handler*)" -> "memset(void*,int,size_t)"
"pack_header(uchar*,legacy_db_type,List<Create_field>&,uint,uint,uint,ulong,handler*)" -> "my_message(uint,const char*,myf)"
"pack_header(uchar*,legacy_db_type,List<Create_field>&,uint,uint,uint,ulong,handler*)" -> "validate_comment_length(THD*,const char*,size_t*,uint,uint,const char*)"
"pack_header(uchar*,legacy_db_type,List<Create_field>&,uint,uint,uint,ulong,handler*)" -> "sql_alloc(size_t)"
"pack_header(uchar*,legacy_db_type,List<Create_field>&,uint,uint,uint,ulong,handler*)" -> "strlen(const char*)"
"pack_header(uchar*,legacy_db_type,List<Create_field>&,uint,uint,uint,ulong,handler*)" -> "_current_thd()"
"get_interval_id(uint*,List<Create_field>&,Create_field*)" -> "List_iterator<T>::List_iterator(List<T>&) [with T = Create_field]"
"get_interval_id(uint*,List<Create_field>&,Create_field*)" -> "List_iterator<T>::operator++(int) [with T = Create_field]"
"get_interval_id(uint*,List<Create_field>&,Create_field*)" -> "strcmp(const char*,const char*)"
"handler::max_record_length() const" -> "std::min(const _Tp&,const _Tp&) [with _Tp = unsigned int]"
"pack_screens(List<Create_field>&,uint*,uint*,bool)" -> "std::min(const _Tp&,const _Tp&) [with _Tp = unsigned char]"
"pack_screens(List<Create_field>&,uint*,uint*,bool)" -> "strmake(char*,const char*,size_t)"
"pack_screens(List<Create_field>&,uint*,uint*,bool)" -> "strfill(char*,size_t,pchar)"
"pack_screens(List<Create_field>&,uint*,uint*,bool)" -> "my_malloc(size_t,myf)"
"pack_screens(List<Create_field>&,uint*,uint*,bool)" -> "List_iterator<T>::rewind() [with T = Create_field]"
"pack_screens(List<Create_field>&,uint*,uint*,bool)" -> "List_iterator<T>::List_iterator(List<T>&) [with T = Create_field]"
"pack_screens(List<Create_field>&,uint*,uint*,bool)" -> "strlen(const char*)"
"pack_screens(List<Create_field>&,uint*,uint*,bool)" -> "List_iterator<T>::operator++(int) [with T = Create_field]"
"Pack_header_error_handler::Pack_header_error_handler()" -> "Internal_error_handler::Internal_error_handler()"
"pack_keys(uchar*,uint,KEY*,ulong)" -> "strnmov(char*,const char*,size_t)"
"pack_keys(uchar*,uint,KEY*,ulong)" -> "__builtin_stpcpy(char*,const char*)"
"ha_create_table(THD*,const char*,const char*,const char*,HA_CREATE_INFO*,bool,bool)" -> "get_canonical_filename(handler*,const char*,char*)"
"ha_create_table(THD*,const char*,const char*,const char*,HA_CREATE_INFO*,bool,bool)" -> "open_table_from_share(THD*,TABLE_SHARE*,const char*,uint,uint,uint,TABLE*,bool)"
"ha_create_table(THD*,const char*,const char*,const char*,HA_CREATE_INFO*,bool,bool)" -> "free_table_share(TABLE_SHARE*)"
"ha_create_table(THD*,const char*,const char*,const char*,HA_CREATE_INFO*,bool,bool)" -> "update_create_info_from_table(HA_CREATE_INFO*,TABLE*)"
"ha_create_table(THD*,const char*,const char*,const char*,HA_CREATE_INFO*,bool,bool)" -> "init_tmp_table_share(THD*,TABLE_SHARE*,const char*,uint,const char*,const char*)"
"ha_create_table(THD*,const char*,const char*,const char*,HA_CREATE_INFO*,bool,bool)" -> "TABLE_SHARE::TABLE_SHARE()"
"ha_create_table(THD*,const char*,const char*,const char*,HA_CREATE_INFO*,bool,bool)" -> "closefrm(TABLE*,bool)"
"ha_create_table(THD*,const char*,const char*,const char*,HA_CREATE_INFO*,bool,bool)" -> "handler::ha_create(const char*,TABLE*,HA_CREATE_INFO*)"
"ha_create_table(THD*,const char*,const char*,const char*,HA_CREATE_INFO*,bool,bool)" -> "open_table_def(THD*,TABLE_SHARE*,uint)"
"ha_create_table(THD*,const char*,const char*,const char*,HA_CREATE_INFO*,bool,bool)" -> "TABLE::TABLE()"
"List_iterator_fast<T>::operator++(int) [with T = Key]" -> "base_list_iterator::next_fast()"
"mysql_prepare_create_table(THD*,HA_CREATE_INFO*,Alter_info*,bool,uint*,handler*,KEY**,uint*,int)" -> "my_qsort(void*,size_t,size_t,qsort_cmp)"
"mysql_prepare_create_table(THD*,HA_CREATE_INFO*,Alter_info*,bool,uint*,handler*,KEY**,uint*,int)" -> "get_sql_field_charset(Create_field*,HA_CREATE_INFO*)"
"mysql_prepare_create_table(THD*,HA_CREATE_INFO*,Alter_info*,bool,uint*,handler*,KEY**,uint*,int)" -> "List_iterator<T>::operator++(int) [with T = Key]"
"mysql_prepare_create_table(THD*,HA_CREATE_INFO*,Alter_info*,bool,uint*,handler*,KEY**,uint*,int)" -> "List_iterator<T>::operator++(int) [with T = Create_field]"
"mysql_prepare_create_table(THD*,HA_CREATE_INFO*,Alter_info*,bool,uint*,handler*,KEY**,uint*,int)" -> "check_string_char_length(LEX_STRING*,const char*,uint,const CHARSET_INFO*,bool)"
"mysql_prepare_create_table(THD*,HA_CREATE_INFO*,Alter_info*,bool,uint*,handler*,KEY**,uint*,int)" -> "String::String()"
"mysql_prepare_create_table(THD*,HA_CREATE_INFO*,Alter_info*,bool,uint*,handler*,KEY**,uint*,int)" -> "std::min(const _Tp&,const _Tp&) [with _Tp = unsigned int]"
"mysql_prepare_create_table(THD*,HA_CREATE_INFO*,Alter_info*,bool,uint*,handler*,KEY**,uint*,int)" -> "get_charset_by_csname(const char*,uint,myf)"
"mysql_prepare_create_table(THD*,HA_CREATE_INFO*,Alter_info*,bool,uint*,handler*,KEY**,uint*,int)" -> "is_timestamp_type(enum_field_types)"
"mysql_prepare_create_table(THD*,HA_CREATE_INFO*,Alter_info*,bool,uint*,handler*,KEY**,uint*,int)" -> "Query_tables_list::set_stmt_unsafe(Query_tables_list::enum_binlog_stmt_unsafe)"
"mysql_prepare_create_table(THD*,HA_CREATE_INFO*,Alter_info*,bool,uint*,handler*,KEY**,uint*,int)" -> "validate_comment_length(THD*,const char*,size_t*,uint,uint,const char*)"
"mysql_prepare_create_table(THD*,HA_CREATE_INFO*,Alter_info*,bool,uint*,handler*,KEY**,uint*,int)" -> "calculate_interval_lengths(const CHARSET_INFO*,TYPELIB*,uint32*,uint32*)"
"mysql_prepare_create_table(THD*,HA_CREATE_INFO*,Alter_info*,bool,uint*,handler*,KEY**,uint*,int)" -> "_current_thd()"
"mysql_prepare_create_table(THD*,HA_CREATE_INFO*,Alter_info*,bool,uint*,handler*,KEY**,uint*,int)" -> "ErrConvString::ptr()"
"mysql_prepare_create_table(THD*,HA_CREATE_INFO*,Alter_info*,bool,uint*,handler*,KEY**,uint*,int)" -> "push_warning_printf(THD*,Sql_condition::enum_warning_level,uint,const char*,...)"
"mysql_prepare_create_table(THD*,HA_CREATE_INFO*,Alter_info*,bool,uint*,handler*,KEY**,uint*,int)" -> "find_set(TYPELIB*,const char*,uint,const CHARSET_INFO*,char**,uint*,bool*)"
"mysql_prepare_create_table(THD*,HA_CREATE_INFO*,Alter_info*,bool,uint*,handler*,KEY**,uint*,int)" -> "String::length() const"
"mysql_prepare_create_table(THD*,HA_CREATE_INFO*,Alter_info*,bool,uint*,handler*,KEY**,uint*,int)" -> "List_iterator<T>::rewind() [with T = Key_part_spec]"
"mysql_prepare_create_table(THD*,HA_CREATE_INFO*,Alter_info*,bool,uint*,handler*,KEY**,uint*,int)" -> "strmake_root(MEM_ROOT*,const char*,size_t)"
"mysql_prepare_create_table(THD*,HA_CREATE_INFO*,Alter_info*,bool,uint*,handler*,KEY**,uint*,int)" -> "make_unique_key_name(const char*,KEY*,KEY*)"
"mysql_prepare_create_table(THD*,HA_CREATE_INFO*,Alter_info*,bool,uint*,handler*,KEY**,uint*,int)" -> "prepare_create_field(Create_field*,uint*,longlong)"
"mysql_prepare_create_table(THD*,HA_CREATE_INFO*,Alter_info*,bool,uint*,handler*,KEY**,uint*,int)" -> "my_printf_error(uint,const char*,myf,...)"
"mysql_prepare_create_table(THD*,HA_CREATE_INFO*,Alter_info*,bool,uint*,handler*,KEY**,uint*,int)" -> "check_column_name(const char*)"
"mysql_prepare_create_table(THD*,HA_CREATE_INFO*,Alter_info*,bool,uint*,handler*,KEY**,uint*,int)" -> "base_list::empty()"
"mysql_prepare_create_table(THD*,HA_CREATE_INFO*,Alter_info*,bool,uint*,handler*,KEY**,uint*,int)" -> "handler::max_key_length() const"
"mysql_prepare_create_table(THD*,HA_CREATE_INFO*,Alter_info*,bool,uint*,handler*,KEY**,uint*,int)" -> "List_iterator<T>::rewind() [with T = Key]"
"mysql_prepare_create_table(THD*,HA_CREATE_INFO*,Alter_info*,bool,uint*,handler*,KEY**,uint*,int)" -> "typelib(MEM_ROOT*,List<String>&)"
"mysql_prepare_create_table(THD*,HA_CREATE_INFO*,Alter_info*,bool,uint*,handler*,KEY**,uint*,int)" -> "List_iterator<T>::List_iterator(List<T>&) [with T = String]"
"mysql_prepare_create_table(THD*,HA_CREATE_INFO*,Alter_info*,bool,uint*,handler*,KEY**,uint*,int)" -> "foreign_key_prefix(Key*,Key*)"
"mysql_prepare_create_table(THD*,HA_CREATE_INFO*,Alter_info*,bool,uint*,handler*,KEY**,uint*,int)" -> "String::length(uint32)"
"mysql_prepare_create_table(THD*,HA_CREATE_INFO*,Alter_info*,bool,uint*,handler*,KEY**,uint*,int)" -> "List_iterator<T>::List_iterator(List<T>&) [with T = Key_part_spec]"
"mysql_prepare_create_table(THD*,HA_CREATE_INFO*,Alter_info*,bool,uint*,handler*,KEY**,uint*,int)" -> "handler::max_keys() const"
"mysql_prepare_create_table(THD*,HA_CREATE_INFO*,Alter_info*,bool,uint*,handler*,KEY**,uint*,int)" -> "THD::is_error() const"
"mysql_prepare_create_table(THD*,HA_CREATE_INFO*,Alter_info*,bool,uint*,handler*,KEY**,uint*,int)" -> "List_iterator<T>::operator++(int) [with T = Key_part_spec]"
"mysql_prepare_create_table(THD*,HA_CREATE_INFO*,Alter_info*,bool,uint*,handler*,KEY**,uint*,int)" -> "handler::ha_table_flags() const"
"mysql_prepare_create_table(THD*,HA_CREATE_INFO*,Alter_info*,bool,uint*,handler*,KEY**,uint*,int)" -> "ErrConvString::ErrConvString(const char*,uint,const CHARSET_INFO*)"
"mysql_prepare_create_table(THD*,HA_CREATE_INFO*,Alter_info*,bool,uint*,handler*,KEY**,uint*,int)" -> "strmake(char*,const char*,size_t)"
"mysql_prepare_create_table(THD*,HA_CREATE_INFO*,Alter_info*,bool,uint*,handler*,KEY**,uint*,int)" -> "List_iterator<T>::List_iterator(List<T>&) [with T = Key]"
"mysql_prepare_create_table(THD*,HA_CREATE_INFO*,Alter_info*,bool,uint*,handler*,KEY**,uint*,int)" -> "List_iterator<T>::remove() [with T = Create_field]"
"mysql_prepare_create_table(THD*,HA_CREATE_INFO*,Alter_info*,bool,uint*,handler*,KEY**,uint*,int)" -> "String::charset() const"
"mysql_prepare_create_table(THD*,HA_CREATE_INFO*,Alter_info*,bool,uint*,handler*,KEY**,uint*,int)" -> "my_error(int,myf,...)"
"mysql_prepare_create_table(THD*,HA_CREATE_INFO*,Alter_info*,bool,uint*,handler*,KEY**,uint*,int)" -> "prepare_blob_field(THD*,Create_field*)"
"mysql_prepare_create_table(THD*,HA_CREATE_INFO*,Alter_info*,bool,uint*,handler*,KEY**,uint*,int)" -> "List_iterator<T>::rewind() [with T = Create_field]"
"mysql_prepare_create_table(THD*,HA_CREATE_INFO*,Alter_info*,bool,uint*,handler*,KEY**,uint*,int)" -> "String::ptr() const"
"mysql_prepare_create_table(THD*,HA_CREATE_INFO*,Alter_info*,bool,uint*,handler*,KEY**,uint*,int)" -> "String::copy(const char*,uint32,const CHARSET_INFO*,const CHARSET_INFO*,uint*)"
"mysql_prepare_create_table(THD*,HA_CREATE_INFO*,Alter_info*,bool,uint*,handler*,KEY**,uint*,int)" -> "check_if_keyname_exists(const char*,KEY*,KEY*)"
"mysql_prepare_create_table(THD*,HA_CREATE_INFO*,Alter_info*,bool,uint*,handler*,KEY**,uint*,int)" -> "handler::max_key_parts() const"
"mysql_prepare_create_table(THD*,HA_CREATE_INFO*,Alter_info*,bool,uint*,handler*,KEY**,uint*,int)" -> "handler::max_key_part_length() const"
"mysql_prepare_create_table(THD*,HA_CREATE_INFO*,Alter_info*,bool,uint*,handler*,KEY**,uint*,int)" -> "find_type2(const TYPELIB*,const char*,uint,const CHARSET_INFO*)"
"mysql_prepare_create_table(THD*,HA_CREATE_INFO*,Alter_info*,bool,uint*,handler*,KEY**,uint*,int)" -> "my_message(uint,const char*,myf)"
"mysql_prepare_create_table(THD*,HA_CREATE_INFO*,Alter_info*,bool,uint*,handler*,KEY**,uint*,int)" -> "check_duplicate_key(THD*,Key*,KEY*,Alter_info*)"
"mysql_prepare_create_table(THD*,HA_CREATE_INFO*,Alter_info*,bool,uint*,handler*,KEY**,uint*,int)" -> "sql_calloc(size_t)"
"mysql_prepare_create_table(THD*,HA_CREATE_INFO*,Alter_info*,bool,uint*,handler*,KEY**,uint*,int)" -> "List_iterator<T>::List_iterator(List<T>&) [with T = Create_field]"
"mysql_prepare_create_table(THD*,HA_CREATE_INFO*,Alter_info*,bool,uint*,handler*,KEY**,uint*,int)" -> "List_iterator<T>::operator++(int) [with T = String]"
"mysql_prepare_create_table(THD*,HA_CREATE_INFO*,Alter_info*,bool,uint*,handler*,KEY**,uint*,int)" -> "Field::type_can_have_key_part(enum_field_types)"
"mysql_prepare_create_table(THD*,HA_CREATE_INFO*,Alter_info*,bool,uint*,handler*,KEY**,uint*,int)" -> "String::needs_conversion(uint32,const CHARSET_INFO*,const CHARSET_INFO*,uint32*)"
"mysql_prepare_create_table(THD*,HA_CREATE_INFO*,Alter_info*,bool,uint*,handler*,KEY**,uint*,int)" -> "Create_field::create_length_to_internal_length()"
"find_set(TYPELIB*,const char*,uint,const CHARSET_INFO*,char**,uint*,bool*)" -> "find_type2(const TYPELIB*,const char*,uint,const CHARSET_INFO*)"
"find_set(TYPELIB*,const char*,uint,const CHARSET_INFO*,char**,uint*,bool*)" -> "find_type(const TYPELIB*,const char*,uint,bool)"
"List_iterator<T>::rewind() [with T = Key_part_spec]" -> "base_list_iterator::rewind()"
"make_unique_key_name(const char*,KEY*,KEY*)" -> "sql_strdup(const char*)"
"make_unique_key_name(const char*,KEY*,KEY*)" -> "int10_to_str(long int,char*,int)"
"make_unique_key_name(const char*,KEY*,KEY*)" -> "strmake(char*,const char*,size_t)"
"make_unique_key_name(const char*,KEY*,KEY*)" -> "check_if_keyname_exists(const char*,KEY*,KEY*)"
"sql_strdup(const char*)" -> "sql_alloc(size_t)"
"sql_strdup(const char*)" -> "memcpy(void*,const void*,size_t)"
"sql_strdup(const char*)" -> "strlen(const char*)"
"List_iterator<T>::rewind() [with T = Key]" -> "base_list_iterator::rewind()"
"typelib(MEM_ROOT*,List<String>&)" -> "String::length() const"
"typelib(MEM_ROOT*,List<String>&)" -> "alloc_root(MEM_ROOT*,size_t)"
"typelib(MEM_ROOT*,List<String>&)" -> "List_iterator<T>::operator++(int) [with T = String]"
"typelib(MEM_ROOT*,List<String>&)" -> "List_iterator<T>::List_iterator(List<T>&) [with T = String]"
"typelib(MEM_ROOT*,List<String>&)" -> "String::ptr() const"
"foreign_key_prefix(Key*,Key*)" -> "List_iterator<T>::List_iterator(List<T>&) [with T = Key_part_spec]"
"foreign_key_prefix(Key*,Key*)" -> "List_iterator<T>::operator++(int) [with T = Key_part_spec]"
"foreign_key_prefix(Key*,Key*)" -> "Key_part_spec::operator==(const Key_part_spec&) const"
"List_iterator<T>::List_iterator(List<T>&) [with T = Key_part_spec]" -> "base_list_iterator::base_list_iterator(base_list&)"
"List_iterator<T>::operator++(int) [with T = Key_part_spec]" -> "base_list_iterator::next()"
"handler::max_keys() const" -> "std::min(const _Tp&,const _Tp&) [with _Tp = unsigned int]"
"handler::max_key_part_length() const" -> "std::min(const _Tp&,const _Tp&) [with _Tp = unsigned int]"
"check_duplicate_key(THD*,Key*,KEY*,Alter_info*)" -> "List_iterator<T>::rewind() [with T = Key_part_spec]"
"check_duplicate_key(THD*,Key*,KEY*,Alter_info*)" -> "List_iterator<T>::operator++(int) [with T = Key_part_spec]"
"check_duplicate_key(THD*,Key*,KEY*,Alter_info*)" -> "List_iterator<T>::List_iterator(List<T>&) [with T = Key]"
"check_duplicate_key(THD*,Key*,KEY*,Alter_info*)" -> "_current_thd()"
"check_duplicate_key(THD*,Key*,KEY*,Alter_info*)" -> "List_iterator<T>::operator++(int) [with T = Key]"
"check_duplicate_key(THD*,Key*,KEY*,Alter_info*)" -> "List_iterator<T>::List_iterator(List<T>&) [with T = Key_part_spec]"
"check_duplicate_key(THD*,Key*,KEY*,Alter_info*)" -> "push_warning_printf(THD*,Sql_condition::enum_warning_level,uint,const char*,...)"
"ErrConvString::ErrConvString(const char*,uint)" -> "err_conv(char*,size_t,const char*,size_t,const CHARSET_INFO*)"
"fk_prepare_copy_alter_table(THD*,TABLE*,Alter_info*,Alter_table_ctx*)" -> "List<T>::List() [with T = st_foreign_key_info]"
"fk_prepare_copy_alter_table(THD*,TABLE*,Alter_info*,Alter_table_ctx*)" -> "List_iterator_fast<T>::List_iterator_fast(List<T>&) [with T = Alter_drop]"
"fk_prepare_copy_alter_table(THD*,TABLE*,Alter_info*,Alter_table_ctx*)" -> "List_iterator<T>::remove() [with T = st_foreign_key_info]"
"fk_prepare_copy_alter_table(THD*,TABLE*,Alter_info*,Alter_table_ctx*)" -> "List<T>::head() [with T = st_foreign_key_info]"
"fk_prepare_copy_alter_table(THD*,TABLE*,Alter_info*,Alter_table_ctx*)" -> "my_error(int,myf,...)"
"fk_prepare_copy_alter_table(THD*,TABLE*,Alter_info*,Alter_table_ctx*)" -> "base_list::is_empty() const"
"fk_prepare_copy_alter_table(THD*,TABLE*,Alter_info*,Alter_table_ctx*)" -> "_current_thd()"
"fk_prepare_copy_alter_table(THD*,TABLE*,Alter_info*,Alter_table_ctx*)" -> "strxnmov(char*,size_t,const char*,...)"
"fk_prepare_copy_alter_table(THD*,TABLE*,Alter_info*,Alter_table_ctx*)" -> "List_iterator_fast<T>::operator++(int) [with T = Alter_drop]"
"fk_prepare_copy_alter_table(THD*,TABLE*,Alter_info*,Alter_table_ctx*)" -> "List_iterator<T>::List_iterator(List<T>&) [with T = st_foreign_key_info]"
"fk_prepare_copy_alter_table(THD*,TABLE*,Alter_info*,Alter_table_ctx*)" -> "List_iterator<T>::operator++(int) [with T = st_foreign_key_info]"
"fk_prepare_copy_alter_table(THD*,TABLE*,Alter_info*,Alter_table_ctx*)" -> "THD::is_error() const"
"fk_prepare_copy_alter_table(THD*,TABLE*,Alter_info*,Alter_table_ctx*)" -> "fk_check_column_changes(THD*,Alter_info*,List<st_mysql_lex_string>&,const char**)"
"fk_prepare_copy_alter_table(THD*,TABLE*,Alter_info*,Alter_table_ctx*)" -> "Alter_table_ctx::set_fk_error_if_delete_row(FOREIGN_KEY_INFO*)"
"fk_prepare_copy_alter_table(THD*,TABLE*,Alter_info*,Alter_table_ctx*)" -> "List_iterator<T>::rewind() [with T = st_foreign_key_info]"
"List<T>::List() [with T = st_foreign_key_info]" -> "base_list::base_list()"
"List_iterator_fast<T>::List_iterator_fast(List<T>&) [with T = Alter_drop]" -> "base_list_iterator::base_list_iterator(base_list&)"
"List_iterator<T>::remove() [with T = st_foreign_key_info]" -> "base_list_iterator::remove()"
"List<T>::head() [with T = st_foreign_key_info]" -> "base_list::head()"
"List_iterator_fast<T>::operator++(int) [with T = Alter_drop]" -> "base_list_iterator::next_fast()"
"List_iterator<T>::List_iterator(List<T>&) [with T = st_foreign_key_info]" -> "base_list_iterator::base_list_iterator(base_list&)"
"List_iterator<T>::operator++(int) [with T = st_foreign_key_info]" -> "base_list_iterator::next()"
"fk_check_column_changes(THD*,Alter_info*,List<st_mysql_lex_string>&,const char**)" -> "List_iterator_fast<T>::operator++(int) [with T = st_mysql_lex_string]"
"fk_check_column_changes(THD*,Alter_info*,List<st_mysql_lex_string>&,const char**)" -> "get_field_by_old_name(Alter_info*,const char*)"
"fk_check_column_changes(THD*,Alter_info*,List<st_mysql_lex_string>&,const char**)" -> "List_iterator_fast<T>::List_iterator_fast(List<T>&) [with T = st_mysql_lex_string]"
"get_field_by_old_name(Alter_info*,const char*)" -> "List_iterator_fast<T>::operator++(int) [with T = Create_field]"
"get_field_by_old_name(Alter_info*,const char*)" -> "List_iterator_fast<T>::List_iterator_fast(List<T>&) [with T = Create_field]"
"List_iterator<T>::rewind() [with T = st_foreign_key_info]" -> "base_list_iterator::rewind()"
"rename_temporary_table(THD*,TABLE*,const char*,const char*)" -> "create_table_def_key(THD*,char*,const char*,const char*,bool)"
"rename_temporary_table(THD*,TABLE*,const char*,const char*)" -> "alloc_root(MEM_ROOT*,size_t)"
"rename_temporary_table(THD*,TABLE*,const char*,const char*)" -> "TABLE_SHARE::set_table_cache_key(char*,uint)"
"upgrade_old_temporal_types(THD*,Alter_info*)" -> "List_iterator<T>::operator++(int) [with T = Create_field]"
"upgrade_old_temporal_types(THD*,Alter_info*)" -> "Create_field::Create_field()"
"upgrade_old_temporal_types(THD*,Alter_info*)" -> "push_warning_printf(THD*,Sql_condition::enum_warning_level,uint,const char*,...)"
"upgrade_old_temporal_types(THD*,Alter_info*)" -> "List_iterator<T>::replace(T*) [with T = Create_field]"
"upgrade_old_temporal_types(THD*,Alter_info*)" -> "Item_func_now_local::Item_func_now_local(uint8)"
"upgrade_old_temporal_types(THD*,Alter_info*)" -> "List_iterator<T>::List_iterator(List<T>&) [with T = Create_field]"
"upgrade_old_temporal_types(THD*,Alter_info*)" -> "List_iterator<T>::rewind() [with T = Create_field]"
"upgrade_old_temporal_types(THD*,Alter_info*)" -> "Create_field::init(THD*,const char*,enum_field_types,const char*,const char*,uint,Item*,Item*,LEX_STRING*,const char*,List<String>*,const CHARSET_INFO*,uint)"
"upgrade_old_temporal_types(THD*,Alter_info*)" -> "_current_thd()"
"List_iterator<T>::replace(T*) [with T = Create_field]" -> "base_list_iterator::replace(void*)"
"fill_alter_inplace_info(THD*,TABLE*,bool,Alter_inplace_info*)" -> "List_iterator_fast<T>::init(List<T>&) [with T = Create_field]"
"fill_alter_inplace_info(THD*,TABLE*,bool,Alter_inplace_info*)" -> "strcmp(const char*,const char*)"
"fill_alter_inplace_info(THD*,TABLE*,bool,Alter_inplace_info*)" -> "get_field_by_index(Alter_info*,uint)"
"fill_alter_inplace_info(THD*,TABLE*,bool,Alter_inplace_info*)" -> "my_qsort(void*,size_t,size_t,qsort_cmp)"
"fill_alter_inplace_info(THD*,TABLE*,bool,Alter_inplace_info*)" -> "is_candidate_key(KEY*)"
"fill_alter_inplace_info(THD*,TABLE*,bool,Alter_inplace_info*)" -> "Query_arena::alloc(size_t)"
"fill_alter_inplace_info(THD*,TABLE*,bool,Alter_inplace_info*)" -> "Field::column_format() const"
"fill_alter_inplace_info(THD*,TABLE*,bool,Alter_inplace_info*)" -> "List_iterator_fast<T>::List_iterator_fast() [with T = Create_field]"
"fill_alter_inplace_info(THD*,TABLE*,bool,Alter_inplace_info*)" -> "List_iterator_fast<T>::operator++(int) [with T = Create_field]"
"fill_alter_inplace_info(THD*,TABLE*,bool,Alter_inplace_info*)" -> "Field::field_storage_type() const"
"fill_alter_inplace_info(THD*,TABLE*,bool,Alter_inplace_info*)" -> "Create_field::column_format() const"
"fill_alter_inplace_info(THD*,TABLE*,bool,Alter_inplace_info*)" -> "Create_field::field_storage_type() const"
"List_iterator_fast<T>::init(List<T>&) [with T = Create_field]" -> "base_list_iterator::init(base_list&)"
"get_field_by_index(Alter_info*,uint)" -> "List_iterator_fast<T>::List_iterator_fast(List<T>&) [with T = Create_field]"
"get_field_by_index(Alter_info*,uint)" -> "List_iterator_fast<T>::operator++(int) [with T = Create_field]"
"List_iterator_fast<T>::List_iterator_fast() [with T = Create_field]" -> "base_list_iterator::base_list_iterator()"
"promote_first_timestamp_column(List<Create_field>*)" -> "List_iterator<T>::operator++(int) [with T = Create_field]"
"promote_first_timestamp_column(List<Create_field>*)" -> "List_iterator<T>::List_iterator(List<T>&) [with T = Create_field]"
"is_inplace_alter_impossible(TABLE*,HA_CREATE_INFO*,const Alter_info*)" -> "TABLE_SHARE::db_type() const"
"fast_alter_partition_table(THD*,TABLE*,Alter_info*,HA_CREATE_INFO*,TABLE_LIST*,char*,const char*)" -> "write_log_completed(ALTER_PARTITION_PARAM_TYPE*,bool)"
"fast_alter_partition_table(THD*,TABLE*,Alter_info*,HA_CREATE_INFO*,TABLE_LIST*,char*,const char*)" -> "write_log_rename_frm(ALTER_PARTITION_PARAM_TYPE*)"
"fast_alter_partition_table(THD*,TABLE*,Alter_info*,HA_CREATE_INFO*,TABLE_LIST*,char*,const char*)" -> "alter_close_table(ALTER_PARTITION_PARAM_TYPE*)"
"fast_alter_partition_table(THD*,TABLE*,Alter_info*,HA_CREATE_INFO*,TABLE_LIST*,char*,const char*)" -> "mysql_change_partitions(ALTER_PARTITION_PARAM_TYPE*)"
"fast_alter_partition_table(THD*,TABLE*,Alter_info*,HA_CREATE_INFO*,TABLE_LIST*,char*,const char*)" -> "mysql_rename_partitions(ALTER_PARTITION_PARAM_TYPE*)"
"fast_alter_partition_table(THD*,TABLE*,Alter_info*,HA_CREATE_INFO*,TABLE_LIST*,char*,const char*)" -> "mysql_write_frm(ALTER_PARTITION_PARAM_TYPE*,uint)"
"fast_alter_partition_table(THD*,TABLE*,Alter_info*,HA_CREATE_INFO*,TABLE_LIST*,char*,const char*)" -> "wait_while_table_is_used(THD*,TABLE*,ha_extra_function)"
"fast_alter_partition_table(THD*,TABLE*,Alter_info*,HA_CREATE_INFO*,TABLE_LIST*,char*,const char*)" -> "Statement::query() const"
"fast_alter_partition_table(THD*,TABLE*,Alter_info*,HA_CREATE_INFO*,TABLE_LIST*,char*,const char*)" -> "alter_partition_lock_handling(ALTER_PARTITION_PARAM_TYPE*)"
"fast_alter_partition_table(THD*,TABLE*,Alter_info*,HA_CREATE_INFO*,TABLE_LIST*,char*,const char*)" -> "write_log_drop_shadow_frm(ALTER_PARTITION_PARAM_TYPE*)"
"fast_alter_partition_table(THD*,TABLE*,Alter_info*,HA_CREATE_INFO*,TABLE_LIST*,char*,const char*)" -> "write_log_add_change_partition(ALTER_PARTITION_PARAM_TYPE*)"
"fast_alter_partition_table(THD*,TABLE*,Alter_info*,HA_CREATE_INFO*,TABLE_LIST*,char*,const char*)" -> "write_log_drop_partition(ALTER_PARTITION_PARAM_TYPE*)"
"fast_alter_partition_table(THD*,TABLE*,Alter_info*,HA_CREATE_INFO*,TABLE_LIST*,char*,const char*)" -> "write_log_final_change_partition(ALTER_PARTITION_PARAM_TYPE*)"
"fast_alter_partition_table(THD*,TABLE*,Alter_info*,HA_CREATE_INFO*,TABLE_LIST*,char*,const char*)" -> "handle_alter_part_error(ALTER_PARTITION_PARAM_TYPE*,bool,bool,bool,bool)"
"fast_alter_partition_table(THD*,TABLE*,Alter_info*,HA_CREATE_INFO*,TABLE_LIST*,char*,const char*)" -> "fast_end_partition(THD*,ulonglong,ulonglong,TABLE_LIST*)"
"fast_alter_partition_table(THD*,TABLE*,Alter_info*,HA_CREATE_INFO*,TABLE_LIST*,char*,const char*)" -> "Statement::query_length() const"
"fast_alter_partition_table(THD*,TABLE*,Alter_info*,HA_CREATE_INFO*,TABLE_LIST*,char*,const char*)" -> "write_bin_log(THD*,bool,const char*,ulong,bool)"
"fast_alter_partition_table(THD*,TABLE*,Alter_info*,HA_CREATE_INFO*,TABLE_LIST*,char*,const char*)" -> "mysql_drop_partitions(ALTER_PARTITION_PARAM_TYPE*)"
"fast_alter_partition_table(THD*,TABLE*,Alter_info*,HA_CREATE_INFO*,TABLE_LIST*,char*,const char*)" -> "downgrade_mdl_if_lock_tables_mode(THD*,MDL_ticket*,enum_mdl_type)"
"write_log_completed(ALTER_PARTITION_PARAM_TYPE*,bool)" -> "inline_mysql_mutex_unlock(mysql_mutex_t*)"
"write_log_completed(ALTER_PARTITION_PARAM_TYPE*,bool)" -> "write_execute_ddl_log_entry(uint,bool,DDL_LOG_MEMORY_ENTRY**)"
"write_log_completed(ALTER_PARTITION_PARAM_TYPE*,bool)" -> "inline_mysql_mutex_lock(mysql_mutex_t*)"
"write_log_completed(ALTER_PARTITION_PARAM_TYPE*,bool)" -> "release_part_info_log_entries(DDL_LOG_MEMORY_ENTRY*)"
"write_execute_ddl_log_entry(uint,bool,DDL_LOG_MEMORY_ENTRY**)" -> "release_ddl_log_memory_entry(DDL_LOG_MEMORY_ENTRY*)"
"write_execute_ddl_log_entry(uint,bool,DDL_LOG_MEMORY_ENTRY**)" -> "write_ddl_log_header()"
"write_execute_ddl_log_entry(uint,bool,DDL_LOG_MEMORY_ENTRY**)" -> "sql_print_error(const char*,...)"
"write_execute_ddl_log_entry(uint,bool,DDL_LOG_MEMORY_ENTRY**)" -> "get_free_ddl_log_entry(DDL_LOG_MEMORY_ENTRY**,bool*)"
"write_execute_ddl_log_entry(uint,bool,DDL_LOG_MEMORY_ENTRY**)" -> "sync_ddl_log_no_lock()"
"write_execute_ddl_log_entry(uint,bool,DDL_LOG_MEMORY_ENTRY**)" -> "init_ddl_log()"
"write_execute_ddl_log_entry(uint,bool,DDL_LOG_MEMORY_ENTRY**)" -> "write_ddl_log_file_entry(uint)"
"write_ddl_log_header()" -> "sync_ddl_log_file()"
"write_ddl_log_header()" -> "sql_print_error(const char*,...)"
"write_ddl_log_header()" -> "write_ddl_log_file_entry(uint)"
"sync_ddl_log_file()" -> "inline_mysql_file_sync(File,myf)"
"write_ddl_log_file_entry(uint)" -> "inline_mysql_file_pwrite(File,const uchar*,size_t,my_off_t,myf)"
"get_free_ddl_log_entry(DDL_LOG_MEMORY_ENTRY**,bool*)" -> "sql_print_error(const char*,...)"
"get_free_ddl_log_entry(DDL_LOG_MEMORY_ENTRY**,bool*)" -> "my_malloc(size_t,myf)"
"sync_ddl_log_no_lock()" -> "init_ddl_log()"
"sync_ddl_log_no_lock()" -> "sync_ddl_log_file()"
"init_ddl_log()" -> "inline_mysql_file_close(File,myf)"
"init_ddl_log()" -> "write_ddl_log_header()"
"init_ddl_log()" -> "create_ddl_log_file_name(char*)"
"init_ddl_log()" -> "sql_print_error(const char*,...)"
"init_ddl_log()" -> "inline_mysql_file_create(const char*,int,int,myf)"
"create_ddl_log_file_name(char*)" -> "strxmov(char*,const char*,...)"
"release_part_info_log_entries(DDL_LOG_MEMORY_ENTRY*)" -> "release_ddl_log_memory_entry(DDL_LOG_MEMORY_ENTRY*)"
"write_log_rename_frm(ALTER_PARTITION_PARAM_TYPE*)" -> "release_part_info_log_entries(DDL_LOG_MEMORY_ENTRY*)"
"write_log_rename_frm(ALTER_PARTITION_PARAM_TYPE*)" -> "my_error(int,myf,...)"
"write_log_rename_frm(ALTER_PARTITION_PARAM_TYPE*)" -> "inline_mysql_mutex_lock(mysql_mutex_t*)"
"write_log_rename_frm(ALTER_PARTITION_PARAM_TYPE*)" -> "build_table_filename(char*,size_t,const char*,const char*,const char*,uint)"
"write_log_rename_frm(ALTER_PARTITION_PARAM_TYPE*)" -> "build_table_shadow_filename(char*,size_t,ALTER_PARTITION_PARAM_TYPE*)"
"write_log_rename_frm(ALTER_PARTITION_PARAM_TYPE*)" -> "inline_mysql_mutex_unlock(mysql_mutex_t*)"
"write_log_rename_frm(ALTER_PARTITION_PARAM_TYPE*)" -> "write_log_replace_delete_frm(ALTER_PARTITION_PARAM_TYPE*,uint,const char*,const char*,bool)"
"write_log_rename_frm(ALTER_PARTITION_PARAM_TYPE*)" -> "write_execute_ddl_log_entry(uint,bool,DDL_LOG_MEMORY_ENTRY**)"
"build_table_shadow_filename(char*,size_t,ALTER_PARTITION_PARAM_TYPE*)" -> "my_snprintf(char*,size_t,const char*,...)"
"build_table_shadow_filename(char*,size_t,ALTER_PARTITION_PARAM_TYPE*)" -> "build_table_filename(char*,size_t,const char*,const char*,const char*,uint)"
"write_log_replace_delete_frm(ALTER_PARTITION_PARAM_TYPE*,uint,const char*,const char*,bool)" -> "insert_part_info_log_entry_list(partition_info*,DDL_LOG_MEMORY_ENTRY*)"
"write_log_replace_delete_frm(ALTER_PARTITION_PARAM_TYPE*,uint,const char*,const char*,bool)" -> "write_ddl_log_entry(DDL_LOG_ENTRY*,DDL_LOG_MEMORY_ENTRY**)"
"write_ddl_log_entry(DDL_LOG_ENTRY*,DDL_LOG_MEMORY_ENTRY**)" -> "write_ddl_log_header()"
"write_ddl_log_entry(DDL_LOG_ENTRY*,DDL_LOG_MEMORY_ENTRY**)" -> "release_ddl_log_memory_entry(DDL_LOG_MEMORY_ENTRY*)"
"write_ddl_log_entry(DDL_LOG_ENTRY*,DDL_LOG_MEMORY_ENTRY**)" -> "set_global_from_ddl_log_entry(const DDL_LOG_ENTRY*)"
"write_ddl_log_entry(DDL_LOG_ENTRY*,DDL_LOG_MEMORY_ENTRY**)" -> "sql_print_error(const char*,...)"
"write_ddl_log_entry(DDL_LOG_ENTRY*,DDL_LOG_MEMORY_ENTRY**)" -> "write_ddl_log_file_entry(uint)"
"write_ddl_log_entry(DDL_LOG_ENTRY*,DDL_LOG_MEMORY_ENTRY**)" -> "get_free_ddl_log_entry(DDL_LOG_MEMORY_ENTRY**,bool*)"
"write_ddl_log_entry(DDL_LOG_ENTRY*,DDL_LOG_MEMORY_ENTRY**)" -> "sync_ddl_log_no_lock()"
"write_ddl_log_entry(DDL_LOG_ENTRY*,DDL_LOG_MEMORY_ENTRY**)" -> "init_ddl_log()"
"set_global_from_ddl_log_entry(const DDL_LOG_ENTRY*)" -> "strmake(char*,const char*,size_t)"
"alter_close_table(ALTER_PARTITION_PARAM_TYPE*)" -> "handler::ha_close()"
"alter_close_table(ALTER_PARTITION_PARAM_TYPE*)" -> "mysql_lock_remove(THD*,MYSQL_LOCK*,TABLE*)"
"mysql_change_partitions(ALTER_PARTITION_PARAM_TYPE*)" -> "handler::ha_change_partitions(HA_CREATE_INFO*,const char*,ulonglong*,ulonglong*,const uchar*,size_t)"
"mysql_change_partitions(ALTER_PARTITION_PARAM_TYPE*)" -> "build_table_filename(char*,size_t,const char*,const char*,const char*,uint)"
"mysql_change_partitions(ALTER_PARTITION_PARAM_TYPE*)" -> "mysql_trans_commit_alter_copy_data(THD*)"
"mysql_change_partitions(ALTER_PARTITION_PARAM_TYPE*)" -> "mysql_trans_prepare_alter_copy_data(THD*)"
"handler::ha_change_partitions(HA_CREATE_INFO*,const char*,ulonglong*,ulonglong*,const uchar*,size_t)" -> "handler::mark_trx_read_write()"
"mysql_rename_partitions(ALTER_PARTITION_PARAM_TYPE*)" -> "handler::ha_rename_partitions(const char*)"
"mysql_rename_partitions(ALTER_PARTITION_PARAM_TYPE*)" -> "build_table_filename(char*,size_t,const char*,const char*,const char*,uint)"
"handler::ha_rename_partitions(const char*)" -> "handler::mark_trx_read_write()"
"mysql_write_frm(ALTER_PARTITION_PARAM_TYPE*,uint)" -> "mysql_prepare_create_table(THD*,HA_CREATE_INFO*,Alter_info*,bool,uint*,handler*,KEY**,uint*,int)"
"mysql_write_frm(ALTER_PARTITION_PARAM_TYPE*,uint)" -> "mysql_create_frm(THD*,const char*,const char*,const char*,HA_CREATE_INFO*,List<Create_field>&,uint,KEY*,handler*)"
"mysql_write_frm(ALTER_PARTITION_PARAM_TYPE*,uint)" -> "build_table_filename(char*,size_t,const char*,const char*,const char*,uint)"
"mysql_write_frm(ALTER_PARTITION_PARAM_TYPE*,uint)" -> "strmake_root(MEM_ROOT*,const char*,size_t)"
"mysql_write_frm(ALTER_PARTITION_PARAM_TYPE*,uint)" -> "handler::ha_create_handler_files(const char*,const char*,int,HA_CREATE_INFO*)"
"mysql_write_frm(ALTER_PARTITION_PARAM_TYPE*,uint)" -> "packfrm(uchar*,size_t,uchar**,size_t*)"
"mysql_write_frm(ALTER_PARTITION_PARAM_TYPE*,uint)" -> "build_table_shadow_filename(char*,size_t,ALTER_PARTITION_PARAM_TYPE*)"
"mysql_write_frm(ALTER_PARTITION_PARAM_TYPE*,uint)" -> "deactivate_ddl_log_entry(uint)"
"mysql_write_frm(ALTER_PARTITION_PARAM_TYPE*,uint)" -> "inline_mysql_file_delete(const char*,myf)"
"mysql_write_frm(ALTER_PARTITION_PARAM_TYPE*,uint)" -> "generate_partition_syntax(partition_info*,uint*,bool,bool,HA_CREATE_INFO*,Alter_info*,const char*)"
"mysql_write_frm(ALTER_PARTITION_PARAM_TYPE*,uint)" -> "sync_ddl_log()"
"mysql_write_frm(ALTER_PARTITION_PARAM_TYPE*,uint)" -> "mem_alloc_error(size_t)"
"mysql_write_frm(ALTER_PARTITION_PARAM_TYPE*,uint)" -> "readfrm(const char*,uchar**,size_t*)"
"mysql_write_frm(ALTER_PARTITION_PARAM_TYPE*,uint)" -> "strxmov(char*,const char*,...)"
"mysql_write_frm(ALTER_PARTITION_PARAM_TYPE*,uint)" -> "memcpy(void*,const void*,size_t)"
"mysql_write_frm(ALTER_PARTITION_PARAM_TYPE*,uint)" -> "inline_mysql_file_rename(const char*,const char*,myf)"
"mysql_write_frm(ALTER_PARTITION_PARAM_TYPE*,uint)" -> "my_free(void*)"
"deactivate_ddl_log_entry(uint)" -> "inline_mysql_mutex_lock(mysql_mutex_t*)"
"deactivate_ddl_log_entry(uint)" -> "deactivate_ddl_log_entry_no_lock(uint)"
"deactivate_ddl_log_entry(uint)" -> "inline_mysql_mutex_unlock(mysql_mutex_t*)"
"deactivate_ddl_log_entry_no_lock(uint)" -> "sql_print_error(const char*,...)"
"deactivate_ddl_log_entry_no_lock(uint)" -> "write_ddl_log_file_entry(uint)"
"deactivate_ddl_log_entry_no_lock(uint)" -> "read_ddl_log_file_entry(uint)"
"read_ddl_log_file_entry(uint)" -> "inline_mysql_file_pread(File,uchar*,size_t,my_off_t,myf)"
"sync_ddl_log()" -> "sync_ddl_log_no_lock()"
"sync_ddl_log()" -> "inline_mysql_mutex_unlock(mysql_mutex_t*)"
"sync_ddl_log()" -> "inline_mysql_mutex_lock(mysql_mutex_t*)"
"readfrm(const char*,uchar**,size_t*)" -> "inline_mysql_file_fstat(int,stat*,myf)"
"readfrm(const char*,uchar**,size_t*)" -> "inline_mysql_file_open(const char*,int,myf)"
"readfrm(const char*,uchar**,size_t*)" -> "fn_format(char*,const char*,const char*,const char*,uint)"
"readfrm(const char*,uchar**,size_t*)" -> "read_string(File,uchar**,size_t)"
"readfrm(const char*,uchar**,size_t*)" -> "inline_mysql_file_close(File,myf)"
"inline_mysql_file_fstat(int,stat*,myf)" -> "my_fstat(int,stat*,myf)"
"alter_partition_lock_handling(ALTER_PARTITION_PARAM_TYPE*)" -> "Diagnostics_area::Diagnostics_area()"
"alter_partition_lock_handling(ALTER_PARTITION_PARAM_TYPE*)" -> "Locked_tables_list::reopen_tables(THD*)"
"alter_partition_lock_handling(ALTER_PARTITION_PARAM_TYPE*)" -> "close_all_tables_for_name(THD*,TABLE_SHARE*,bool,TABLE*)"
"alter_partition_lock_handling(ALTER_PARTITION_PARAM_TYPE*)" -> "sql_print_warning(const char*,...)"
"alter_partition_lock_handling(ALTER_PARTITION_PARAM_TYPE*)" -> "THD::get_stmt_da()"
"alter_partition_lock_handling(ALTER_PARTITION_PARAM_TYPE*)" -> "THD::is_error() const"
"alter_partition_lock_handling(ALTER_PARTITION_PARAM_TYPE*)" -> "THD::set_stmt_da(Diagnostics_area*)"
"Diagnostics_area::Diagnostics_area()" -> "I>::I_P_List() [with T = Warning_info,B = I_P_List_adapter<Warning_info,&Warning_info::m_next_in_da,&Warning_info::m_prev_in_da>,C = I_P_List_counter,I = I_P_List_fast_push_back<Warning_info>]"
"Diagnostics_area::Diagnostics_area()" -> "Warning_info::Warning_info(ulonglong,bool)"
"Diagnostics_area::Diagnostics_area()" -> "Diagnostics_area::push_warning_info(Warning_info*)"
"Diagnostics_area::Diagnostics_area()" -> "Diagnostics_area::reset_diagnostics_area()"
"write_log_drop_shadow_frm(ALTER_PARTITION_PARAM_TYPE*)" -> "my_error(int,myf,...)"
"write_log_drop_shadow_frm(ALTER_PARTITION_PARAM_TYPE*)" -> "set_part_info_exec_log_entry(partition_info*,DDL_LOG_MEMORY_ENTRY*)"
"write_log_drop_shadow_frm(ALTER_PARTITION_PARAM_TYPE*)" -> "inline_mysql_mutex_lock(mysql_mutex_t*)"
"write_log_drop_shadow_frm(ALTER_PARTITION_PARAM_TYPE*)" -> "release_part_info_log_entries(DDL_LOG_MEMORY_ENTRY*)"
"write_log_drop_shadow_frm(ALTER_PARTITION_PARAM_TYPE*)" -> "write_log_replace_delete_frm(ALTER_PARTITION_PARAM_TYPE*,uint,const char*,const char*,bool)"
"write_log_drop_shadow_frm(ALTER_PARTITION_PARAM_TYPE*)" -> "build_table_shadow_filename(char*,size_t,ALTER_PARTITION_PARAM_TYPE*)"
"write_log_drop_shadow_frm(ALTER_PARTITION_PARAM_TYPE*)" -> "write_execute_ddl_log_entry(uint,bool,DDL_LOG_MEMORY_ENTRY**)"
"write_log_drop_shadow_frm(ALTER_PARTITION_PARAM_TYPE*)" -> "inline_mysql_mutex_unlock(mysql_mutex_t*)"
"write_log_add_change_partition(ALTER_PARTITION_PARAM_TYPE*)" -> "write_log_dropped_partitions(ALTER_PARTITION_PARAM_TYPE*,uint*,const char*,bool)"
"write_log_add_change_partition(ALTER_PARTITION_PARAM_TYPE*)" -> "set_part_info_exec_log_entry(partition_info*,DDL_LOG_MEMORY_ENTRY*)"
"write_log_add_change_partition(ALTER_PARTITION_PARAM_TYPE*)" -> "build_table_shadow_filename(char*,size_t,ALTER_PARTITION_PARAM_TYPE*)"
"write_log_add_change_partition(ALTER_PARTITION_PARAM_TYPE*)" -> "my_error(int,myf,...)"
"write_log_add_change_partition(ALTER_PARTITION_PARAM_TYPE*)" -> "inline_mysql_mutex_unlock(mysql_mutex_t*)"
"write_log_add_change_partition(ALTER_PARTITION_PARAM_TYPE*)" -> "inline_mysql_mutex_lock(mysql_mutex_t*)"
"write_log_add_change_partition(ALTER_PARTITION_PARAM_TYPE*)" -> "release_part_info_log_entries(DDL_LOG_MEMORY_ENTRY*)"
"write_log_add_change_partition(ALTER_PARTITION_PARAM_TYPE*)" -> "write_execute_ddl_log_entry(uint,bool,DDL_LOG_MEMORY_ENTRY**)"
"write_log_add_change_partition(ALTER_PARTITION_PARAM_TYPE*)" -> "build_table_filename(char*,size_t,const char*,const char*,const char*,uint)"
"write_log_dropped_partitions(ALTER_PARTITION_PARAM_TYPE*,uint*,const char*,bool)" -> "insert_part_info_log_entry_list(partition_info*,DDL_LOG_MEMORY_ENTRY*)"
"write_log_dropped_partitions(ALTER_PARTITION_PARAM_TYPE*,uint*,const char*,bool)" -> "ha_resolve_storage_engine_name(const handlerton*)"
"write_log_dropped_partitions(ALTER_PARTITION_PARAM_TYPE*,uint*,const char*,bool)" -> "List_iterator<T>::List_iterator(List<T>&) [with T = partition_element]"
"write_log_dropped_partitions(ALTER_PARTITION_PARAM_TYPE*,uint*,const char*,bool)" -> "create_subpartition_name(char*,const char*,const char*,const char*,uint)"
"write_log_dropped_partitions(ALTER_PARTITION_PARAM_TYPE*,uint*,const char*,bool)" -> "partition_info::is_sub_partitioned()"
"write_log_dropped_partitions(ALTER_PARTITION_PARAM_TYPE*,uint*,const char*,bool)" -> "List_iterator<T>::operator++(int) [with T = partition_element]"
"write_log_dropped_partitions(ALTER_PARTITION_PARAM_TYPE*,uint*,const char*,bool)" -> "create_partition_name(char*,const char*,const char*,uint,bool)"
"write_log_dropped_partitions(ALTER_PARTITION_PARAM_TYPE*,uint*,const char*,bool)" -> "write_ddl_log_entry(DDL_LOG_ENTRY*,DDL_LOG_MEMORY_ENTRY**)"
"create_subpartition_name(char*,const char*,const char*,const char*,uint)" -> "tablename_to_filename(const char*,char*,uint)"
"create_subpartition_name(char*,const char*,const char*,const char*,uint)" -> "strxmov(char*,const char*,...)"
"create_partition_name(char*,const char*,const char*,uint,bool)" -> "strxmov(char*,const char*,...)"
"create_partition_name(char*,const char*,const char*,uint,bool)" -> "tablename_to_filename(const char*,char*,uint)"
"write_log_drop_partition(ALTER_PARTITION_PARAM_TYPE*)" -> "my_error(int,myf,...)"
"write_log_drop_partition(ALTER_PARTITION_PARAM_TYPE*)" -> "write_execute_ddl_log_entry(uint,bool,DDL_LOG_MEMORY_ENTRY**)"
"write_log_drop_partition(ALTER_PARTITION_PARAM_TYPE*)" -> "inline_mysql_mutex_lock(mysql_mutex_t*)"
"write_log_drop_partition(ALTER_PARTITION_PARAM_TYPE*)" -> "write_log_dropped_partitions(ALTER_PARTITION_PARAM_TYPE*,uint*,const char*,bool)"
"write_log_drop_partition(ALTER_PARTITION_PARAM_TYPE*)" -> "build_table_shadow_filename(char*,size_t,ALTER_PARTITION_PARAM_TYPE*)"
"write_log_drop_partition(ALTER_PARTITION_PARAM_TYPE*)" -> "inline_mysql_mutex_unlock(mysql_mutex_t*)"
"write_log_drop_partition(ALTER_PARTITION_PARAM_TYPE*)" -> "release_part_info_log_entries(DDL_LOG_MEMORY_ENTRY*)"
"write_log_drop_partition(ALTER_PARTITION_PARAM_TYPE*)" -> "write_log_replace_delete_frm(ALTER_PARTITION_PARAM_TYPE*,uint,const char*,const char*,bool)"
"write_log_drop_partition(ALTER_PARTITION_PARAM_TYPE*)" -> "build_table_filename(char*,size_t,const char*,const char*,const char*,uint)"
"write_log_final_change_partition(ALTER_PARTITION_PARAM_TYPE*)" -> "inline_mysql_mutex_unlock(mysql_mutex_t*)"
"write_log_final_change_partition(ALTER_PARTITION_PARAM_TYPE*)" -> "build_table_shadow_filename(char*,size_t,ALTER_PARTITION_PARAM_TYPE*)"
"write_log_final_change_partition(ALTER_PARTITION_PARAM_TYPE*)" -> "inline_mysql_mutex_lock(mysql_mutex_t*)"
"write_log_final_change_partition(ALTER_PARTITION_PARAM_TYPE*)" -> "release_part_info_log_entries(DDL_LOG_MEMORY_ENTRY*)"
"write_log_final_change_partition(ALTER_PARTITION_PARAM_TYPE*)" -> "build_table_filename(char*,size_t,const char*,const char*,const char*,uint)"
"write_log_final_change_partition(ALTER_PARTITION_PARAM_TYPE*)" -> "write_log_replace_delete_frm(ALTER_PARTITION_PARAM_TYPE*,uint,const char*,const char*,bool)"
"write_log_final_change_partition(ALTER_PARTITION_PARAM_TYPE*)" -> "write_log_changed_partitions(ALTER_PARTITION_PARAM_TYPE*,uint*,const char*)"
"write_log_final_change_partition(ALTER_PARTITION_PARAM_TYPE*)" -> "my_error(int,myf,...)"
"write_log_final_change_partition(ALTER_PARTITION_PARAM_TYPE*)" -> "write_execute_ddl_log_entry(uint,bool,DDL_LOG_MEMORY_ENTRY**)"
"write_log_final_change_partition(ALTER_PARTITION_PARAM_TYPE*)" -> "write_log_dropped_partitions(ALTER_PARTITION_PARAM_TYPE*,uint*,const char*,bool)"
"write_log_changed_partitions(ALTER_PARTITION_PARAM_TYPE*,uint*,const char*)" -> "List_iterator<T>::List_iterator(List<T>&) [with T = partition_element]"
"write_log_changed_partitions(ALTER_PARTITION_PARAM_TYPE*,uint*,const char*)" -> "List_iterator<T>::operator++(int) [with T = partition_element]"
"write_log_changed_partitions(ALTER_PARTITION_PARAM_TYPE*,uint*,const char*)" -> "create_partition_name(char*,const char*,const char*,uint,bool)"
"write_log_changed_partitions(ALTER_PARTITION_PARAM_TYPE*,uint*,const char*)" -> "write_ddl_log_entry(DDL_LOG_ENTRY*,DDL_LOG_MEMORY_ENTRY**)"
"write_log_changed_partitions(ALTER_PARTITION_PARAM_TYPE*,uint*,const char*)" -> "insert_part_info_log_entry_list(partition_info*,DDL_LOG_MEMORY_ENTRY*)"
"write_log_changed_partitions(ALTER_PARTITION_PARAM_TYPE*,uint*,const char*)" -> "create_subpartition_name(char*,const char*,const char*,const char*,uint)"
"write_log_changed_partitions(ALTER_PARTITION_PARAM_TYPE*,uint*,const char*)" -> "partition_info::is_sub_partitioned()"
"write_log_changed_partitions(ALTER_PARTITION_PARAM_TYPE*,uint*,const char*)" -> "ha_resolve_storage_engine_name(const handlerton*)"
"handle_alter_part_error(ALTER_PARTITION_PARAM_TYPE*,bool,bool,bool,bool)" -> "mysql_lock_remove(THD*,MYSQL_LOCK*,TABLE*)"
"handle_alter_part_error(ALTER_PARTITION_PARAM_TYPE*,bool,bool,bool,bool)" -> "THD::is_error() const"
"handle_alter_part_error(ALTER_PARTITION_PARAM_TYPE*,bool,bool,bool,bool)" -> "release_log_entries(partition_info*)"
"handle_alter_part_error(ALTER_PARTITION_PARAM_TYPE*,bool,bool,bool,bool)" -> "wait_while_table_is_used(THD*,TABLE*,ha_extra_function)"
"handle_alter_part_error(ALTER_PARTITION_PARAM_TYPE*,bool,bool,bool,bool)" -> "close_thread_table(THD*,TABLE**)"
"handle_alter_part_error(ALTER_PARTITION_PARAM_TYPE*,bool,bool,bool,bool)" -> "THD::get_stmt_da()"
"handle_alter_part_error(ALTER_PARTITION_PARAM_TYPE*,bool,bool,bool,bool)" -> "write_log_completed(ALTER_PARTITION_PARAM_TYPE*,bool)"
"handle_alter_part_error(ALTER_PARTITION_PARAM_TYPE*,bool,bool,bool,bool)" -> "push_warning_printf(THD*,Sql_condition::enum_warning_level,uint,const char*,...)"
"handle_alter_part_error(ALTER_PARTITION_PARAM_TYPE*,bool,bool,bool,bool)" -> "Locked_tables_list::reopen_tables(THD*)"
"handle_alter_part_error(ALTER_PARTITION_PARAM_TYPE*,bool,bool,bool,bool)" -> "MDL_context::is_lock_owner(MDL_key::enum_mdl_namespace,const char*,const char*,enum_mdl_type)"
"handle_alter_part_error(ALTER_PARTITION_PARAM_TYPE*,bool,bool,bool,bool)" -> "THD::set_stmt_da(Diagnostics_area*)"
"handle_alter_part_error(ALTER_PARTITION_PARAM_TYPE*,bool,bool,bool,bool)" -> "Diagnostics_area::Diagnostics_area()"
"handle_alter_part_error(ALTER_PARTITION_PARAM_TYPE*,bool,bool,bool,bool)" -> "partition_info::get_clone()"
"handle_alter_part_error(ALTER_PARTITION_PARAM_TYPE*,bool,bool,bool,bool)" -> "sql_print_warning(const char*,...)"
"handle_alter_part_error(ALTER_PARTITION_PARAM_TYPE*,bool,bool,bool,bool)" -> "Locked_tables_list::unlink_from_list(THD*,TABLE_LIST*,bool)"
"handle_alter_part_error(ALTER_PARTITION_PARAM_TYPE*,bool,bool,bool,bool)" -> "close_all_tables_for_name(THD*,TABLE_SHARE*,bool,TABLE*)"
"handle_alter_part_error(ALTER_PARTITION_PARAM_TYPE*,bool,bool,bool,bool)" -> "execute_ddl_log_entry(THD*,uint)"
"release_log_entries(partition_info*)" -> "release_part_info_log_entries(DDL_LOG_MEMORY_ENTRY*)"
"release_log_entries(partition_info*)" -> "inline_mysql_mutex_unlock(mysql_mutex_t*)"
"release_log_entries(partition_info*)" -> "inline_mysql_mutex_lock(mysql_mutex_t*)"
"execute_ddl_log_entry(THD*,uint)" -> "inline_mysql_mutex_lock(mysql_mutex_t*)"
"execute_ddl_log_entry(THD*,uint)" -> "execute_ddl_log_entry_no_lock(THD*,uint)"
"execute_ddl_log_entry(THD*,uint)" -> "inline_mysql_mutex_unlock(mysql_mutex_t*)"
"execute_ddl_log_entry_no_lock(THD*,uint)" -> "execute_ddl_log_action(THD*,DDL_LOG_ENTRY*)"
"execute_ddl_log_entry_no_lock(THD*,uint)" -> "sql_print_error(const char*,...)"
"execute_ddl_log_entry_no_lock(THD*,uint)" -> "read_ddl_log_entry(uint,DDL_LOG_ENTRY*)"
"execute_ddl_log_action(THD*,DDL_LOG_ENTRY*)" -> "strxmov(char*,const char*,...)"
"execute_ddl_log_action(THD*,DDL_LOG_ENTRY*)" -> "free_root(MEM_ROOT*,myf)"
"execute_ddl_log_action(THD*,DDL_LOG_ENTRY*)" -> "get_new_handler(TABLE_SHARE*,MEM_ROOT*,handlerton*)"
"execute_ddl_log_action(THD*,DDL_LOG_ENTRY*)" -> "sync_ddl_log_no_lock()"
"execute_ddl_log_action(THD*,DDL_LOG_ENTRY*)" -> "inline_mysql_file_rename(const char*,const char*,myf)"
"execute_ddl_log_action(THD*,DDL_LOG_ENTRY*)" -> "mem_alloc_error(size_t)"
"execute_ddl_log_action(THD*,DDL_LOG_ENTRY*)" -> "handler::ha_delete_table(const char*)"
"execute_ddl_log_action(THD*,DDL_LOG_ENTRY*)" -> "init_sql_alloc(MEM_ROOT*,uint,uint)"
"execute_ddl_log_action(THD*,DDL_LOG_ENTRY*)" -> "strlen(const char*)"
"execute_ddl_log_action(THD*,DDL_LOG_ENTRY*)" -> "_my_thread_var()"
"execute_ddl_log_action(THD*,DDL_LOG_ENTRY*)" -> "inline_mysql_file_delete(const char*,myf)"
"execute_ddl_log_action(THD*,DDL_LOG_ENTRY*)" -> "ha_resolve_by_name(THD*,const LEX_STRING*,bool)"
"execute_ddl_log_action(THD*,DDL_LOG_ENTRY*)" -> "my_error(int,myf,...)"
"execute_ddl_log_action(THD*,DDL_LOG_ENTRY*)" -> "write_ddl_log_file_entry(uint)"
"execute_ddl_log_action(THD*,DDL_LOG_ENTRY*)" -> "handler::ha_rename_table(const char*,const char*)"
"execute_ddl_log_action(THD*,DDL_LOG_ENTRY*)" -> "strcmp(const char*,const char*)"
"execute_ddl_log_action(THD*,DDL_LOG_ENTRY*)" -> "deactivate_ddl_log_entry_no_lock(uint)"
"read_ddl_log_entry(uint,DDL_LOG_ENTRY*)" -> "set_ddl_log_entry_from_global(DDL_LOG_ENTRY*,uint)"
"read_ddl_log_entry(uint,DDL_LOG_ENTRY*)" -> "read_ddl_log_file_entry(uint)"
"fast_end_partition(THD*,ulonglong,ulonglong,TABLE_LIST*)" -> "my_snprintf(char*,size_t,const char*,...)"
"fast_end_partition(THD*,ulonglong,ulonglong,TABLE_LIST*)" -> "my_ok(THD*,ulonglong,ulonglong,const char*)"
"fast_end_partition(THD*,ulonglong,ulonglong,TABLE_LIST*)" -> "Query_cache::invalidate(THD*,TABLE_LIST*,my_bool)"
"fast_end_partition(THD*,ulonglong,ulonglong,TABLE_LIST*)" -> "_current_thd()"
"mysql_drop_partitions(ALTER_PARTITION_PARAM_TYPE*)" -> "handler::ha_drop_partitions(const char*)"
"mysql_drop_partitions(ALTER_PARTITION_PARAM_TYPE*)" -> "List_iterator<T>::List_iterator(List<T>&) [with T = partition_element]"
"mysql_drop_partitions(ALTER_PARTITION_PARAM_TYPE*)" -> "build_table_filename(char*,size_t,const char*,const char*,const char*,uint)"
"mysql_drop_partitions(ALTER_PARTITION_PARAM_TYPE*)" -> "List_iterator<T>::remove() [with T = partition_element]"
"mysql_drop_partitions(ALTER_PARTITION_PARAM_TYPE*)" -> "List_iterator<T>::operator++(int) [with T = partition_element]"
"handler::ha_drop_partitions(const char*)" -> "handler::mark_trx_read_write()"
"downgrade_mdl_if_lock_tables_mode(THD*,MDL_ticket*,enum_mdl_type)" -> "MDL_ticket::downgrade_lock(enum_mdl_type)"
"Alter_inplace_info::report_unsupported_error(const char*,const char*)" -> "my_error(int,myf,...)"
"check_if_log_table(size_t,const char*,size_t,const char*,bool)" -> "strcmp(const char*,const char*)"
"check_if_log_table(size_t,const char*,size_t,const char*,bool)" -> "LOGGER::is_log_table_enabled(uint)"
"view_checksum(THD*,TABLE_LIST*)" -> "strncmp(const char*,const char*,size_t)"
"view_checksum(THD*,TABLE_LIST*)" -> "TABLE_LIST::calc_md5(char*)"
"TABLE_LIST::calc_md5(char*)" -> "compute_md5_hash(char*,const char*,int)"
"TABLE_LIST::calc_md5(char*)" -> "array_to_hex(char*,const unsigned char*,uint)"
"compute_md5_hash(char*,const char*,int)" -> "my_md5_hash(char*,const char*,int)"
"my_md5_hash(char*,const char*,int)" -> "TaoCrypt::HASHwithTransform::Final(TaoCrypt::byte*)"
"my_md5_hash(char*,const char*,int)" -> "TaoCrypt::HASHwithTransform::Update(const byte*,TaoCrypt::word32)"
"my_md5_hash(char*,const char*,int)" -> "TaoCrypt::MD5::MD5()"
"TaoCrypt::HASHwithTransform::Final(TaoCrypt::byte*)" -> "TaoCrypt::HASHwithTransform::GetBitCountHi() const"
"TaoCrypt::HASHwithTransform::Final(TaoCrypt::byte*)" -> "memcpy(void*,const void*,size_t)"
"TaoCrypt::HASHwithTransform::Final(TaoCrypt::byte*)" -> "TaoCrypt::HASHwithTransform::AddLength(TaoCrypt::word32)"
"TaoCrypt::HASHwithTransform::Final(TaoCrypt::byte*)" -> "TaoCrypt::ByteReverseIf(T*,const T*,TaoCrypt::word32,TaoCrypt::ByteOrder) [with T = unsigned int,TaoCrypt::word32 = unsigned int]"
"TaoCrypt::HASHwithTransform::Final(TaoCrypt::byte*)" -> "TaoCrypt::ByteReverseIf(T*,const T*,TaoCrypt::word32,TaoCrypt::ByteOrder) [with T = unsigned char,TaoCrypt::word32 = unsigned int]"
"TaoCrypt::HASHwithTransform::Final(TaoCrypt::byte*)" -> "memset(void*,int,size_t)"
"TaoCrypt::HASHwithTransform::Final(TaoCrypt::byte*)" -> "TaoCrypt::HASHwithTransform::GetBitCountLo() const"
"TaoCrypt::HASHwithTransform::AddLength(TaoCrypt::word32)" -> "TaoCrypt::SafeRightShift(T) [with unsigned int bits = 32u,T = unsigned int]"
"TaoCrypt::SafeRightShift(T) [with unsigned int bits = 32u,T = unsigned int]" -> "TaoCrypt::SafeShifter<true>::RightShift(T,unsigned int) [with T = unsigned int]"
"TaoCrypt::ByteReverseIf(T*,const T*,TaoCrypt::word32,TaoCrypt::ByteOrder) [with T = unsigned int,TaoCrypt::word32 = unsigned int]" -> "TaoCrypt::ByteReverse(T*,const T*,TaoCrypt::word32) [with T = unsigned int,TaoCrypt::word32 = unsigned int]"
"TaoCrypt::ByteReverseIf(T*,const T*,TaoCrypt::word32,TaoCrypt::ByteOrder) [with T = unsigned int,TaoCrypt::word32 = unsigned int]" -> "memcpy(void*,const void*,size_t)"
"TaoCrypt::ByteReverseIf(T*,const T*,TaoCrypt::word32,TaoCrypt::ByteOrder) [with T = unsigned int,TaoCrypt::word32 = unsigned int]" -> "TaoCrypt::HostByteOrderIs(TaoCrypt::ByteOrder)"
"TaoCrypt::ByteReverse(T*,const T*,TaoCrypt::word32) [with T = unsigned int,TaoCrypt::word32 = unsigned int]" -> "TaoCrypt::ByteReverse(TaoCrypt::word32)"
"TaoCrypt::ByteReverse(TaoCrypt::word32)" -> "TaoCrypt::rotlFixed(T,unsigned int) [with T = unsigned int]"
"TaoCrypt::HostByteOrderIs(TaoCrypt::ByteOrder)" -> "TaoCrypt::GetHostByteOrder()"
"TaoCrypt::GetHostByteOrder()" -> "VALUE>::ToEnum() [with ENUM_TYPE = TaoCrypt::ByteOrder,int VALUE = 0]"
"TaoCrypt::ByteReverseIf(T*,const T*,TaoCrypt::word32,TaoCrypt::ByteOrder) [with T = unsigned char,TaoCrypt::word32 = unsigned int]" -> "TaoCrypt::HostByteOrderIs(TaoCrypt::ByteOrder)"
"TaoCrypt::ByteReverseIf(T*,const T*,TaoCrypt::word32,TaoCrypt::ByteOrder) [with T = unsigned char,TaoCrypt::word32 = unsigned int]" -> "memcpy(void*,const void*,size_t)"
"TaoCrypt::ByteReverseIf(T*,const T*,TaoCrypt::word32,TaoCrypt::ByteOrder) [with T = unsigned char,TaoCrypt::word32 = unsigned int]" -> "TaoCrypt::ByteReverse(TaoCrypt::byte*,const byte*,TaoCrypt::word32)"
"TaoCrypt::ByteReverse(TaoCrypt::byte*,const byte*,TaoCrypt::word32)" -> "TaoCrypt::ByteReverse(T*,const T*,TaoCrypt::word32) [with T = unsigned int,TaoCrypt::word32 = unsigned int]"
"TaoCrypt::HASHwithTransform::Update(const byte*,TaoCrypt::word32)" -> "TaoCrypt::HASHwithTransform::AddLength(TaoCrypt::word32)"
"TaoCrypt::HASHwithTransform::Update(const byte*,TaoCrypt::word32)" -> "TaoCrypt::min(const T&,const T&) [with T = unsigned int]"
"TaoCrypt::HASHwithTransform::Update(const byte*,TaoCrypt::word32)" -> "TaoCrypt::ByteReverseIf(T*,const T*,TaoCrypt::word32,TaoCrypt::ByteOrder) [with T = unsigned char,TaoCrypt::word32 = unsigned int]"
"TaoCrypt::HASHwithTransform::Update(const byte*,TaoCrypt::word32)" -> "memcpy(void*,const void*,size_t)"
"TaoCrypt::MD5::MD5()" -> "TaoCrypt::MD5::Init()"
"TaoCrypt::MD5::MD5()" -> "TaoCrypt::HASHwithTransform::HASHwithTransform(TaoCrypt::word32,TaoCrypt::word32)"
"TaoCrypt::HASHwithTransform::HASHwithTransform(TaoCrypt::word32,TaoCrypt::word32)" -> "TaoCrypt::HASH::HASH()"
"TaoCrypt::HASH::HASH()" -> "TaoCrypt::virtual_base::virtual_base()"
"Query_cache::invalidate(THD*,TABLE*,my_bool)" -> "THD::add_changed_table(TABLE*)"
"Query_cache::invalidate(THD*,TABLE*,my_bool)" -> "Query_cache::is_disabled()"
"Query_cache::invalidate(THD*,TABLE*,my_bool)" -> "THD::in_multi_stmt_transaction_mode() const"
"Query_cache::invalidate(THD*,TABLE*,my_bool)" -> "Query_cache::invalidate_table(THD*,TABLE*)"
"handler::ha_analyze(THD*,HA_CHECK_OPT*)" -> "handler::mark_trx_read_write()"
"open_n_lock_single_table(THD*,TABLE_LIST*,thr_lock_type,uint)" -> "open_n_lock_single_table(THD*,TABLE_LIST*,thr_lock_type,uint,Prelocking_strategy*)"
"open_n_lock_single_table(THD*,TABLE_LIST*,thr_lock_type,uint)" -> "DML_prelocking_strategy::DML_prelocking_strategy()"
"open_n_lock_single_table(THD*,TABLE_LIST*,thr_lock_type,uint,Prelocking_strategy*)" -> "open_and_lock_tables(THD*,TABLE_LIST*,bool,uint,Prelocking_strategy*)"
"Item_empty_string::Item_empty_string(const char*,uint,const CHARSET_INFO*)" -> "Name_string::Name_string(const char*,size_t)"
"Item_empty_string::Item_empty_string(const char*,uint,const CHARSET_INFO*)" -> "Item_partition_func_safe_string::Item_partition_func_safe_string(Name_string,uint,const CHARSET_INFO*)"
"Item_empty_string::Item_empty_string(const char*,uint,const CHARSET_INFO*)" -> "strlen(const char*)"
"Item_partition_func_safe_string::Item_partition_func_safe_string(Name_string,uint,const CHARSET_INFO*)" -> "Item_string::Item_string(Name_string,const char*,uint,const CHARSET_INFO*,Derivation,uint)"
"mysql_rm_table(THD*,TABLE_LIST*,my_bool,my_bool)" -> "find_table_for_mdl_upgrade(THD*,const char*,const char*,bool)"
"mysql_rm_table(THD*,TABLE_LIST*,my_bool,my_bool)" -> "is_temporary_table(TABLE_LIST*)"
"mysql_rm_table(THD*,TABLE_LIST*,my_bool,my_bool)" -> "tdc_remove_table(THD*,enum_tdc_remove_table_type,const char*,const char*,bool)"
"mysql_rm_table(THD*,TABLE_LIST*,my_bool,my_bool)" -> "my_error(int,myf,...)"
"mysql_rm_table(THD*,TABLE_LIST*,my_bool,my_bool)" -> "lock_table_names(THD*,TABLE_LIST*,TABLE_LIST*,ulong,uint)"
"mysql_rm_table(THD*,TABLE_LIST*,my_bool,my_bool)" -> "THD::pop_internal_handler()"
"mysql_rm_table(THD*,TABLE_LIST*,my_bool,my_bool)" -> "mysql_rm_table_no_locks(THD*,TABLE_LIST*,bool,bool,bool,bool)"
"mysql_rm_table(THD*,TABLE_LIST*,my_bool,my_bool)" -> "Drop_table_error_handler::Drop_table_error_handler()"
"mysql_rm_table(THD*,TABLE_LIST*,my_bool,my_bool)" -> "THD::push_internal_handler(Internal_error_handler*)"
"mysql_rm_table(THD*,TABLE_LIST*,my_bool,my_bool)" -> "my_ok(THD*,ulonglong,ulonglong,const char*)"
"mysql_rm_table(THD*,TABLE_LIST*,my_bool,my_bool)" -> "check_if_log_table(size_t,const char*,size_t,const char*,bool)"
"mysql_rm_table_no_locks(THD*,TABLE_LIST*,bool,bool,bool,bool)" -> "close_all_tables_for_name(THD*,TABLE_SHARE*,bool,TABLE*)"
"mysql_rm_table_no_locks(THD*,TABLE_LIST*,bool,bool,bool,bool)" -> "String::ptr() const"
"mysql_rm_table_no_locks(THD*,TABLE_LIST*,bool,bool,bool,bool)" -> "THD::is_current_stmt_binlog_format_row() const"
"mysql_rm_table_no_locks(THD*,TABLE_LIST*,bool,bool,bool,bool)" -> "String::String()"
"mysql_rm_table_no_locks(THD*,TABLE_LIST*,bool,bool,bool,bool)" -> "String::set_charset(const CHARSET_INFO*)"
"mysql_rm_table_no_locks(THD*,TABLE_LIST*,bool,bool,bool,bool)" -> "MYSQL_BIN_LOG::commit(THD*,bool)"
"mysql_rm_table_no_locks(THD*,TABLE_LIST*,bool,bool,bool,bool)" -> "String::length() const"
"mysql_rm_table_no_locks(THD*,TABLE_LIST*,bool,bool,bool,bool)" -> "MYSQL_LOG::is_open()"
"mysql_rm_table_no_locks(THD*,TABLE_LIST*,bool,bool,bool,bool)" -> "my_message(uint,const char*,myf)"
"mysql_rm_table_no_locks(THD*,TABLE_LIST*,bool,bool,bool,bool)" -> "strcmp(const char*,const char*)"
"mysql_rm_table_no_locks(THD*,TABLE_LIST*,bool,bool,bool,bool)" -> "access(const char*,int)"
"mysql_rm_table_no_locks(THD*,TABLE_LIST*,bool,bool,bool,bool)" -> "THD_TRANS::mark_dropped_temp_table()"
"mysql_rm_table_no_locks(THD*,TABLE_LIST*,bool,bool,bool,bool)" -> "build_table_filename(char*,size_t,const char*,const char*,const char*,uint)"
"mysql_rm_table_no_locks(THD*,TABLE_LIST*,bool,bool,bool,bool)" -> "String::String(const char*,const CHARSET_INFO*)"
"mysql_rm_table_no_locks(THD*,TABLE_LIST*,bool,bool,bool,bool)" -> "strlen(const char*)"
"mysql_rm_table_no_locks(THD*,TABLE_LIST*,bool,bool,bool,bool)" -> "ha_resolve_by_legacy_type(THD*,legacy_db_type)"
"mysql_rm_table_no_locks(THD*,TABLE_LIST*,bool,bool,bool,bool)" -> "THD::binlog_query(THD::enum_binlog_query_type,const char*,ulong,bool,bool,bool,int)"
"mysql_rm_table_no_locks(THD*,TABLE_LIST*,bool,bool,bool,bool)" -> "MDL_context::release_all_locks_for_name(MDL_ticket*)"
"mysql_rm_table_no_locks(THD*,TABLE_LIST*,bool,bool,bool,bool)" -> "Locked_tables_list::unlock_locked_tables(THD*)"
"mysql_rm_table_no_locks(THD*,TABLE_LIST*,bool,bool,bool,bool)" -> "ha_create_table_from_engine(THD*,const char*,const char*)"
"mysql_rm_table_no_locks(THD*,TABLE_LIST*,bool,bool,bool,bool)" -> "String::append(char)"
"mysql_rm_table_no_locks(THD*,TABLE_LIST*,bool,bool,bool,bool)" -> "__builtin_strcpy(char*,const char*)"
"mysql_rm_table_no_locks(THD*,TABLE_LIST*,bool,bool,bool,bool)" -> "Table_triggers_list::drop_all_triggers(THD*,char*,char*)"
"mysql_rm_table_no_locks(THD*,TABLE_LIST*,bool,bool,bool,bool)" -> "ha_delete_table(THD*,handlerton*,const char*,const char*,const char*,bool)"
"mysql_rm_table_no_locks(THD*,TABLE_LIST*,bool,bool,bool,bool)" -> "_current_thd()"
"mysql_rm_table_no_locks(THD*,TABLE_LIST*,bool,bool,bool,bool)" -> "inline_mysql_file_delete(const char*,myf)"
"mysql_rm_table_no_locks(THD*,TABLE_LIST*,bool,bool,bool,bool)" -> "drop_temporary_table(THD*,TABLE_LIST*,bool*)"
"mysql_rm_table_no_locks(THD*,TABLE_LIST*,bool,bool,bool,bool)" -> "dd_frm_type(THD*,char*,legacy_db_type*)"
"mysql_rm_table_no_locks(THD*,TABLE_LIST*,bool,bool,bool,bool)" -> "String::append(const char*)"
"mysql_rm_table_no_locks(THD*,TABLE_LIST*,bool,bool,bool,bool)" -> "String::chop()"
"mysql_rm_table_no_locks(THD*,TABLE_LIST*,bool,bool,bool,bool)" -> "String::c_ptr()"
"mysql_rm_table_no_locks(THD*,TABLE_LIST*,bool,bool,bool,bool)" -> "wait_while_table_is_used(THD*,TABLE*,ha_extra_function)"
"mysql_rm_table_no_locks(THD*,TABLE_LIST*,bool,bool,bool,bool)" -> "push_warning_printf(THD*,Sql_condition::enum_warning_level,uint,const char*,...)"
"mysql_rm_table_no_locks(THD*,TABLE_LIST*,bool,bool,bool,bool)" -> "my_error(int,myf,...)"
"mysql_rm_table_no_locks(THD*,TABLE_LIST*,bool,bool,bool,bool)" -> "Query_cache::invalidate(THD*,TABLE_LIST*,my_bool)"
"mysql_rm_table_no_locks(THD*,TABLE_LIST*,bool,bool,bool,bool)" -> "String::free()"
"mysql_rm_table_no_locks(THD*,TABLE_LIST*,bool,bool,bool,bool)" -> "THD::add_to_binlog_accessed_dbs(const char*)"
"mysql_rm_table_no_locks(THD*,TABLE_LIST*,bool,bool,bool,bool)" -> "append_identifier(THD*,String*,const char*,uint)"
"mysql_rm_table_no_locks(THD*,TABLE_LIST*,bool,bool,bool,bool)" -> "String::append(const String&)"
"mysql_rm_table_no_locks(THD*,TABLE_LIST*,bool,bool,bool,bool)" -> "THD::clear_error()"
"mysql_rm_table_no_locks(THD*,TABLE_LIST*,bool,bool,bool,bool)" -> "my_printf_error(uint,const char*,myf,...)"
"Table_triggers_list::drop_all_triggers(THD*,char*,char*)" -> "init_sql_alloc(MEM_ROOT*,uint,uint)"
"Table_triggers_list::drop_all_triggers(THD*,char*,char*)" -> "rm_trigname_file(char*,const char*,const char*)"
"Table_triggers_list::drop_all_triggers(THD*,char*,char*)" -> "Table_triggers_list::check_n_load(THD*,const char*,const char*,TABLE*,bool)"
"Table_triggers_list::drop_all_triggers(THD*,char*,char*)" -> "memset(void*,int,size_t)"
"Table_triggers_list::drop_all_triggers(THD*,char*,char*)" -> "free_root(MEM_ROOT*,myf)"
"Table_triggers_list::drop_all_triggers(THD*,char*,char*)" -> "List_iterator_fast<T>::List_iterator_fast(List<T>&) [with T = st_mysql_lex_string]"
"Table_triggers_list::drop_all_triggers(THD*,char*,char*)" -> "TABLE::TABLE()"
"Table_triggers_list::drop_all_triggers(THD*,char*,char*)" -> "List_iterator_fast<T>::operator++(int) [with T = st_mysql_lex_string]"
"Table_triggers_list::drop_all_triggers(THD*,char*,char*)" -> "rm_trigger_file(char*,const char*,const char*)"
"drop_temporary_table(THD*,TABLE_LIST*,bool*)" -> "close_temporary_table(THD*,TABLE*,bool,bool)"
"drop_temporary_table(THD*,TABLE_LIST*,bool*)" -> "handler::has_transactions()"
"drop_temporary_table(THD*,TABLE_LIST*,bool*)" -> "my_error(int,myf,...)"
"drop_temporary_table(THD*,TABLE_LIST*,bool*)" -> "mysql_lock_remove(THD*,MYSQL_LOCK*,TABLE*)"
"drop_temporary_table(THD*,TABLE_LIST*,bool*)" -> "is_temporary_table(TABLE_LIST*)"
"Drop_table_error_handler::Drop_table_error_handler()" -> "Internal_error_handler::Internal_error_handler()"
"trans_xa_prepare(THD*)" -> "my_error(int,myf,...)"
"trans_xa_prepare(THD*)" -> "THD::is_error() const"
"trans_xa_prepare(THD*)" -> "xid_cache_delete(XID_STATE*)"
"trans_xa_prepare(THD*)" -> "ha_prepare(THD*)"
"trans_xa_prepare(THD*)" -> "xid_t::eq(xid_t*)"
"ha_prepare(THD*)" -> "my_error(int,myf,...)"
"ha_prepare(THD*)" -> "push_warning_printf(THD*,Sql_condition::enum_warning_level,uint,const char*,...)"
"ha_prepare(THD*)" -> "Ha_trx_info::next() const"
"ha_prepare(THD*)" -> "_current_thd()"
"ha_prepare(THD*)" -> "Ha_trx_info::ht() const"
"ha_prepare(THD*)" -> "ha_rollback_trans(THD*,bool)"
"ha_prepare(THD*)" -> "ha_resolve_storage_engine_name(const handlerton*)"
"xid_t::eq(xid_t*)" -> "xid_t::eq(long int,long int,const char*)"
"xid_t::eq(long int,long int,const char*)" -> "memcmp(const void*,const void*,size_t)"
"trans_xa_rollback(THD*)" -> "xid_t::eq(xid_t*)"
"trans_xa_rollback(THD*)" -> "my_error(int,myf,...)"
"trans_xa_rollback(THD*)" -> "ha_commit_or_rollback_by_xid(THD*,XID*,bool)"
"trans_xa_rollback(THD*)" -> "THD_TRANS::reset_unsafe_rollback_flags()"
"trans_xa_rollback(THD*)" -> "THD::get_stmt_da()"
"trans_xa_rollback(THD*)" -> "xa_trans_rolled_back(XID_STATE*)"
"trans_xa_rollback(THD*)" -> "xa_trans_force_rollback(THD*)"
"trans_xa_rollback(THD*)" -> "Diagnostics_area::is_error() const"
"trans_xa_rollback(THD*)" -> "xid_cache_search(XID*)"
"trans_xa_rollback(THD*)" -> "xid_cache_delete(XID_STATE*)"
"ha_commit_or_rollback_by_xid(THD*,XID*,bool)" -> "gtid_rollback(THD*)"
"ha_commit_or_rollback_by_xid(THD*,XID*,bool)" -> "plugin_foreach_with_mask(THD*,my_bool (*)(THD*,plugin_ref,void*),int,uint,void*)"
"xa_trans_rolled_back(XID_STATE*)" -> "my_error(int,myf,...)"
"xa_trans_force_rollback(THD*)" -> "my_error(int,myf,...)"
"xa_trans_force_rollback(THD*)" -> "ha_rollback_trans(THD*,bool)"
"xid_cache_search(XID*)" -> "inline_mysql_mutex_lock(mysql_mutex_t*)"
"xid_cache_search(XID*)" -> "xid_t::key()"
"xid_cache_search(XID*)" -> "inline_mysql_mutex_unlock(mysql_mutex_t*)"
"xid_cache_search(XID*)" -> "xid_t::key_length()"
"xid_cache_search(XID*)" -> "my_hash_search(const HASH*,const uchar*,size_t)"
"mysql_multi_delete_prepare(THD*,uint*)" -> "setup_tables_and_check_access(THD*,Name_resolution_context*,List<TABLE_LIST>*,TABLE_LIST*,TABLE_LIST**,bool,ulong,ulong)"
"mysql_multi_delete_prepare(THD*,uint*)" -> "update_non_unique_table_error(TABLE_LIST*,const char*,TABLE_LIST*)"
"mysql_multi_delete_prepare(THD*,uint*)" -> "check_key_in_view(THD*,TABLE_LIST*)"
"mysql_multi_delete_prepare(THD*,uint*)" -> "unique_table(THD*,TABLE_LIST*,TABLE_LIST*,bool)"
"mysql_multi_delete_prepare(THD*,uint*)" -> "my_error(int,myf,...)"
"explain_multi_table_modification(THD*,select_result_interceptor*)" -> "explain_send::explain_send(select_result_interceptor*)"
"explain_multi_table_modification(THD*,select_result_interceptor*)" -> "explain_query_expression(THD*,select_result*)"
"explain_send::explain_send(select_result_interceptor*)" -> "select_send::select_send()"
"explain_query_expression(THD*,select_result*)" -> "st_select_lex_unit::print(String*,enum_query_type)"
"explain_query_expression(THD*,select_result*)" -> "String::append(char)"
"explain_query_expression(THD*,select_result*)" -> "StringBuffer<buff_sz>::StringBuffer() [with long unsigned int buff_sz = 1024ul]"
"explain_query_expression(THD*,select_result*)" -> "mysql_explain_unit(THD*,SELECT_LEX_UNIT*,select_result*)"
"explain_query_expression(THD*,select_result*)" -> "push_warning(THD*,Sql_condition::enum_warning_level,uint,const char*)"
"explain_query_expression(THD*,select_result*)" -> "String::ptr() const"
"explain_query_expression(THD*,select_result*)" -> "THD::is_error() const"
"StringBuffer<buff_sz>::StringBuffer() [with long unsigned int buff_sz = 1024ul]" -> "String::length(uint32)"
"StringBuffer<buff_sz>::StringBuffer() [with long unsigned int buff_sz = 1024ul]" -> "String::String(char*,uint32,const CHARSET_INFO*)"
"mysql_explain_unit(THD*,SELECT_LEX_UNIT*,select_result*)" -> "propagate_explain_option(THD*,SELECT_LEX_UNIT*)"
"mysql_explain_unit(THD*,SELECT_LEX_UNIT*,select_result*)" -> "st_select_lex_unit::first_select()"
"mysql_explain_unit(THD*,SELECT_LEX_UNIT*,select_result*)" -> "st_select_lex_unit::optimize()"
"mysql_explain_unit(THD*,SELECT_LEX_UNIT*,select_result*)" -> "st_select_lex_unit::prepare(THD*,select_result*,ulong)"
"mysql_explain_unit(THD*,SELECT_LEX_UNIT*,select_result*)" -> "st_select_lex_unit::explain()"
"mysql_explain_unit(THD*,SELECT_LEX_UNIT*,select_result*)" -> "st_select_lex_unit::is_union()"
"mysql_explain_unit(THD*,SELECT_LEX_UNIT*,select_result*)" -> "THD::is_error() const"
"mysql_explain_unit(THD*,SELECT_LEX_UNIT*,select_result*)" -> "lock_tables(THD*,TABLE_LIST*,uint,uint)"
"mysql_explain_unit(THD*,SELECT_LEX_UNIT*,select_result*)" -> "Query_tables_list::is_query_tables_locked()"
"mysql_explain_unit(THD*,SELECT_LEX_UNIT*,select_result*)" -> "mysql_select(THD*,TABLE_LIST*,uint,List<Item>&,Item*,SQL_I_List<st_order>*,SQL_I_List<st_order>*,Item*,ulonglong,select_result*,SELECT_LEX_UNIT*,SELECT_LEX*)"
"mysql_explain_unit(THD*,SELECT_LEX_UNIT*,select_result*)" -> "st_select_lex_unit::set_limit(st_select_lex*)"
"propagate_explain_option(THD*,SELECT_LEX_UNIT*)" -> "st_select_lex_unit::first_select()"
"propagate_explain_option(THD*,SELECT_LEX_UNIT*)" -> "st_select_lex::next_select()"
"st_select_lex_unit::optimize()" -> "Item_subselect::assigned() const"
"st_select_lex_unit::optimize()" -> "st_select_lex::next_select()"
"st_select_lex_unit::optimize()" -> "JOIN::reset()"
"st_select_lex_unit::optimize()" -> "st_select_lex_unit::is_union()"
"st_select_lex_unit::optimize()" -> "st_select_lex_unit::set_limit(st_select_lex*)"
"st_select_lex_unit::optimize()" -> "JOIN::optimize()"
"st_select_lex_unit::optimize()" -> "st_select_lex_unit::first_select()"
"st_select_lex_unit::set_limit(st_select_lex*)" -> "Item::val_uint()"
"JOIN::optimize()" -> "optimize_cond(THD*,Item*,COND_EQUAL**,List<TABLE_LIST>*,bool,Item::cond_result*)"
"JOIN::optimize()" -> "remove_additional_cond(Item*)"
"JOIN::optimize()" -> "calc_group_buffer(JOIN*,ORDER*)"
"JOIN::optimize()" -> "mysql_unlock_some_tables(THD*,TABLE**,uint)"
"JOIN::optimize()" -> "is_indexed_agg_distinct(JOIN*,List<Item_field>*)"
"JOIN::optimize()" -> "Opt_trace_struct::end()"
"JOIN::optimize()" -> "JOIN::prune_table_partitions(THD*)"
"JOIN::optimize()" -> "record_join_nest_info(st_select_lex*,List<TABLE_LIST>*)"
"JOIN::optimize()" -> "ha_make_pushed_joins(THD*,const AQP::Join_plan*)"
"JOIN::optimize()" -> "JOIN::ORDER_with_src::ORDER_with_src(ORDER*,Explain_sort_clause)"
"JOIN::optimize()" -> "make_outerjoin_info(JOIN*)"
"JOIN::optimize()" -> "JOIN::plan_is_single_table()"
"JOIN::optimize()" -> "JOIN::set_access_methods()"
"JOIN::optimize()" -> "Opt_trace_array::Opt_trace_array(Opt_trace_context*,const char*,Opt_trace_context::feature_value)"
"JOIN::optimize()" -> "remove_eq_conds(THD*,Item*,Item::cond_result*)"
"JOIN::optimize()" -> "make_join_statistics(JOIN*,TABLE_LIST*,Item*,Key_use_array*,bool)"
"JOIN::optimize()" -> "Opt_trace_struct::add_select_number(uint)"
"JOIN::optimize()" -> "JOIN::optimize_fts_limit_query()"
"JOIN::optimize()" -> "substitute_for_best_equal_field(Item*,COND_EQUAL*,void*)"
"JOIN::optimize()" -> "save_index_subquery_explain_info(JOIN_TAB*,Item*)"
"JOIN::optimize()" -> "update_depend_map(JOIN*)"
"JOIN::optimize()" -> "remove_const(JOIN*,ORDER*,Item*,bool,bool*,const char*)"
"JOIN::optimize()" -> "make_join_readinfo(JOIN*,ulonglong,uint)"
"JOIN::optimize()" -> "THD::is_error() const"
"JOIN::optimize()" -> "count_field_types(SELECT_LEX*,TMP_TABLE_PARAM*,List<Item>&,bool)"
"JOIN::optimize()" -> "THD::enter_stage(const PSI_stage_info*,PSI_stage_info*,const char*,const char*,unsigned int)"
"JOIN::optimize()" -> "subselect_indexsubquery_engine::subselect_indexsubquery_engine(THD*,st_join_table*,Item_subselect*,Item*,Item*,bool,bool)"
"JOIN::optimize()" -> "Simple_cstring::ptr() const"
"JOIN::optimize()" -> "opt_sum_query(THD*,TABLE_LIST*,List<Item>&,Item*)"
"JOIN::optimize()" -> "test_if_skip_sort_order(JOIN_TAB*,ORDER*,ha_rows,bool,const key_map*,const char*)"
"JOIN::optimize()" -> "JOIN::ORDER_with_src::operator=(JOIN::ORDER_with_src::null*)"
"JOIN::optimize()" -> "list_contains_unique_index(JOIN_TAB*,bool (*)(Field*,void*),void*)"
"JOIN::optimize()" -> "JOIN::rollup_process_const_fields()"
"JOIN::optimize()" -> "JOIN::remove_subq_pushed_predicates(Item**)"
"JOIN::optimize()" -> "simplify_joins(JOIN*,List<TABLE_LIST>*,Item*,bool,bool,Item**,uint*)"
"JOIN::optimize()" -> "JOIN::set_prefix_tables()"
"JOIN::optimize()" -> "JOIN::flatten_subqueries()"
"JOIN::optimize()" -> "st_select_lex::handle_derived(LEX*,bool (*)(THD*,LEX*,TABLE_LIST*))"
"JOIN::optimize()" -> "make_cond_for_table(Item*,table_map,table_map,bool)"
"JOIN::optimize()" -> "JOIN::optimize_fts_query()"
"JOIN::optimize()" -> "JOIN::drop_unused_derived_keys()"
"JOIN::optimize()" -> "Opt_trace_object::Opt_trace_object(Opt_trace_context*,const char*,Opt_trace_context::feature_value)"
"JOIN::optimize()" -> "create_distinct_group(THD*,Ref_ptr_array,ORDER*,List<Item>&,List<Item>&,bool*)"
"JOIN::optimize()" -> "add_ref_to_table_cond(THD*,JOIN_TAB*)"
"JOIN::optimize()" -> "Opt_trace_object::Opt_trace_object(Opt_trace_context*,Opt_trace_context::feature_value)"
"JOIN::optimize()" -> "test_if_subpart(ORDER*,ORDER*)"
"JOIN::optimize()" -> "init_ftfuncs(THD*,SELECT_LEX*,bool)"
"JOIN::optimize()" -> "Opt_trace_struct::add_alnum(const char*,const char*)"
"JOIN::optimize()" -> "reset_nj_counters(List<TABLE_LIST>*)"
"JOIN::optimize()" -> "JOIN::cache_const_exprs()"
"JOIN::optimize()" -> "pick_table_access_method(JOIN_TAB*)"
"JOIN::optimize()" -> "st_select_lex_unit::is_union()"
"JOIN::optimize()" -> "JOIN::plan_is_const() const"
"JOIN::optimize()" -> "Item_int::Item_int(longlong,uint)"
"JOIN::optimize()" -> "Item_subselect::change_engine(subselect_engine*)"
"JOIN::optimize()" -> "my_message(uint,const char*,myf)"
"JOIN::optimize()" -> "Prepared_stmt_arena_holder::Prepared_stmt_arena_holder(THD*,bool)"
"JOIN::optimize()" -> "build_bitmap_for_nested_joins(List<TABLE_LIST>*,uint)"
"JOIN::optimize()" -> "get_sort_by_table(ORDER*,ORDER*,TABLE_LIST*)"
"JOIN::optimize()" -> "JOIN::Prepare_error_tracker::Prepare_error_tracker(THD*)"
"JOIN::optimize()" -> "AQP::Join_plan::Join_plan(const JOIN*)"
"JOIN::optimize()" -> "TABLE::prepare_for_position()"
"JOIN::optimize()" -> "JOIN::make_tmp_tables_info()"
"JOIN::optimize()" -> "JOIN::ORDER_with_src::operator ORDER*()"
"JOIN::optimize()" -> "_current_thd()"
"JOIN::optimize()" -> "make_join_select(JOIN*,Item*)"
"optimize_cond(THD*,Item*,COND_EQUAL**,List<TABLE_LIST>*,bool,Item::cond_result*)" -> "Opt_trace_struct::add_alnum(const char*,const char*)"
"optimize_cond(THD*,Item*,COND_EQUAL**,List<TABLE_LIST>*,bool,Item::cond_result*)" -> "remove_eq_conds(THD*,Item*,Item::cond_result*)"
"optimize_cond(THD*,Item*,COND_EQUAL**,List<TABLE_LIST>*,bool,Item::cond_result*)" -> "Opt_trace_struct::add(const char*,Item*)"
"optimize_cond(THD*,Item*,COND_EQUAL**,List<TABLE_LIST>*,bool,Item::cond_result*)" -> "Opt_trace_object::Opt_trace_object(Opt_trace_context*,const char*,Opt_trace_context::feature_value)"
"optimize_cond(THD*,Item*,COND_EQUAL**,List<TABLE_LIST>*,bool,Item::cond_result*)" -> "Opt_trace_array::Opt_trace_array(Opt_trace_context*,const char*,Opt_trace_context::feature_value)"
"optimize_cond(THD*,Item*,COND_EQUAL**,List<TABLE_LIST>*,bool,Item::cond_result*)" -> "Opt_trace_disable_I_S::Opt_trace_disable_I_S(Opt_trace_context*,bool)"
"optimize_cond(THD*,Item*,COND_EQUAL**,List<TABLE_LIST>*,bool,Item::cond_result*)" -> "Opt_trace_object::Opt_trace_object(Opt_trace_context*,Opt_trace_context::feature_value)"
"optimize_cond(THD*,Item*,COND_EQUAL**,List<TABLE_LIST>*,bool,Item::cond_result*)" -> "build_equal_items(THD*,Item*,COND_EQUAL*,bool,List<TABLE_LIST>*,COND_EQUAL**)"
"optimize_cond(THD*,Item*,COND_EQUAL**,List<TABLE_LIST>*,bool,Item::cond_result*)" -> "propagate_cond_constants(THD*,I_List<COND_CMP>*,Item*,Item*)"
"remove_eq_conds(THD*,Item*,Item::cond_result*)" -> "Query_cache::abort(Query_cache_tls*)"
"remove_eq_conds(THD*,Item*,Item::cond_result*)" -> "Item_func_eq::Item_func_eq(Item*,Item*)"
"remove_eq_conds(THD*,Item*,Item::cond_result*)" -> "Item_int::Item_int(const Name_string&,longlong,uint)"
"remove_eq_conds(THD*,Item*,Item::cond_result*)" -> "Item_func::arguments() const"
"remove_eq_conds(THD*,Item*,Item::cond_result*)" -> "Name_string::Name_string(const char*,size_t)"
"remove_eq_conds(THD*,Item*,Item::cond_result*)" -> "THD::read_first_successful_insert_id_in_prev_stmt()"
"remove_eq_conds(THD*,Item*,Item::cond_result*)" -> "internal_remove_eq_conds(THD*,Item*,Item::cond_result*)"
"internal_remove_eq_conds(THD*,Item*,Item::cond_result*)" -> "List_iterator<T>::operator++(int) [with T = Item]"
"internal_remove_eq_conds(THD*,Item*,Item::cond_result*)" -> "Item_cond_or::Item_cond_or(Item*,Item*)"
"internal_remove_eq_conds(THD*,Item*,Item::cond_result*)" -> "internal_remove_eq_conds(THD*,Item*,Item::cond_result*)"
"internal_remove_eq_conds(THD*,Item*,Item::cond_result*)" -> "List_iterator<T>::remove() [with T = Item]"
"internal_remove_eq_conds(THD*,Item*,Item::cond_result*)" -> "Item_int::Item_int(longlong,uint)"
"internal_remove_eq_conds(THD*,Item*,Item::cond_result*)" -> "eval_const_cond(Item*)"
"internal_remove_eq_conds(THD*,Item*,Item::cond_result*)" -> "List_iterator<T>::List_iterator(List<T>&) [with T = Item]"
"internal_remove_eq_conds(THD*,Item*,Item::cond_result*)" -> "Item_cond::argument_list()"
"internal_remove_eq_conds(THD*,Item*,Item::cond_result*)" -> "Item_func::arguments() const"
"internal_remove_eq_conds(THD*,Item*,Item::cond_result*)" -> "List_iterator<T>::replace(T*) [with T = Item]"
"internal_remove_eq_conds(THD*,Item*,Item::cond_result*)" -> "List<T>::head() [with T = Item]"
"internal_remove_eq_conds(THD*,Item*,Item::cond_result*)" -> "Item_func_eq::Item_func_eq(Item*,Item*)"
"List_iterator<T>::remove() [with T = Item]" -> "base_list_iterator::remove()"
"Opt_trace_disable_I_S::Opt_trace_disable_I_S(Opt_trace_context*,bool)" -> "Opt_trace_context::disable_I_S_for_this_and_children()"
"build_equal_items(THD*,Item*,COND_EQUAL*,bool,List<TABLE_LIST>*,COND_EQUAL**)" -> "List_iterator<T>::operator++(int) [with T = TABLE_LIST]"
"build_equal_items(THD*,Item*,COND_EQUAL*,bool,List<TABLE_LIST>*,COND_EQUAL**)" -> "TABLE_LIST::set_join_cond(Item*)"
"build_equal_items(THD*,Item*,COND_EQUAL*,bool,List<TABLE_LIST>*,COND_EQUAL**)" -> "COND_EQUAL::COND_EQUAL()"
"build_equal_items(THD*,Item*,COND_EQUAL*,bool,List<TABLE_LIST>*,COND_EQUAL**)" -> "build_equal_items_for_cond(THD*,Item*,COND_EQUAL*,bool)"
"build_equal_items(THD*,Item*,COND_EQUAL*,bool,List<TABLE_LIST>*,COND_EQUAL**)" -> "List<T>::push_back(T*) [with T = Item_equal]"
"build_equal_items(THD*,Item*,COND_EQUAL*,bool,List<TABLE_LIST>*,COND_EQUAL**)" -> "build_equal_items(THD*,Item*,COND_EQUAL*,bool,List<TABLE_LIST>*,COND_EQUAL**)"
"build_equal_items(THD*,Item*,COND_EQUAL*,bool,List<TABLE_LIST>*,COND_EQUAL**)" -> "List_iterator<T>::List_iterator(List<T>&) [with T = TABLE_LIST]"
"build_equal_items(THD*,Item*,COND_EQUAL*,bool,List<TABLE_LIST>*,COND_EQUAL**)" -> "TABLE_LIST::join_cond() const"
"build_equal_items_for_cond(THD*,Item*,COND_EQUAL*,bool)" -> "List_iterator<T>::operator++(int) [with T = Item]"
"build_equal_items_for_cond(THD*,Item*,COND_EQUAL*,bool)" -> "Item_int::Item_int(longlong,uint)"
"build_equal_items_for_cond(THD*,Item*,COND_EQUAL*,bool)" -> "List<T>::List() [with T = Item]"
"build_equal_items_for_cond(THD*,Item*,COND_EQUAL*,bool)" -> "COND_EQUAL::COND_EQUAL()"
"build_equal_items_for_cond(THD*,Item*,COND_EQUAL*,bool)" -> "List_iterator<T>::replace(T*) [with T = Item]"
"build_equal_items_for_cond(THD*,Item*,COND_EQUAL*,bool)" -> "List_iterator_fast<T>::operator++(int) [with T = Item_equal]"
"build_equal_items_for_cond(THD*,Item*,COND_EQUAL*,bool)" -> "List<T>::concat(List<T>*) [with T = Item]"
"build_equal_items_for_cond(THD*,Item*,COND_EQUAL*,bool)" -> "List_iterator<T>::rewind() [with T = Item]"
"build_equal_items_for_cond(THD*,Item*,COND_EQUAL*,bool)" -> "List<T>::pop() [with T = Item]"
"build_equal_items_for_cond(THD*,Item*,COND_EQUAL*,bool)" -> "Item_cond_and::Item_cond_and(List<Item>&)"
"build_equal_items_for_cond(THD*,Item*,COND_EQUAL*,bool)" -> "List<T>::pop() [with T = Item_equal]"
"build_equal_items_for_cond(THD*,Item*,COND_EQUAL*,bool)" -> "check_equality(THD*,Item*,COND_EQUAL*,List<Item>*)"
"build_equal_items_for_cond(THD*,Item*,COND_EQUAL*,bool)" -> "List_iterator_fast<T>::List_iterator_fast(List<T>&) [with T = Item_equal]"
"build_equal_items_for_cond(THD*,Item*,COND_EQUAL*,bool)" -> "Item_cond::argument_list()"
"build_equal_items_for_cond(THD*,Item*,COND_EQUAL*,bool)" -> "Item_equal::members()"
"build_equal_items_for_cond(THD*,Item*,COND_EQUAL*,bool)" -> "List_iterator<T>::remove() [with T = Item]"
"build_equal_items_for_cond(THD*,Item*,COND_EQUAL*,bool)" -> "List_iterator<T>::List_iterator(List<T>&) [with T = Item]"
"build_equal_items_for_cond(THD*,Item*,COND_EQUAL*,bool)" -> "Item::quick_fix_field()"
"build_equal_items_for_cond(THD*,Item*,COND_EQUAL*,bool)" -> "build_equal_items_for_cond(THD*,Item*,COND_EQUAL*,bool)"
"List_iterator_fast<T>::operator++(int) [with T = Item_equal]" -> "base_list_iterator::next_fast()"
"List<T>::concat(List<T>*) [with T = Item]" -> "base_list::concat(base_list*)"
"List_iterator<T>::rewind() [with T = Item]" -> "base_list_iterator::rewind()"
"Item_cond_and::Item_cond_and(List<Item>&)" -> "COND_EQUAL::COND_EQUAL()"
"Item_cond_and::Item_cond_and(List<Item>&)" -> "Item_cond::Item_cond(List<Item>&)"
"Item_cond::Item_cond(List<Item>&)" -> "List<T>::List(const List<T>&) [with T = Item]"
"Item_cond::Item_cond(List<Item>&)" -> "Item_bool_func::Item_bool_func()"
"List<T>::List(const List<T>&) [with T = Item]" -> "base_list::base_list(const base_list&)"
"List<T>::pop() [with T = Item_equal]" -> "base_list::pop()"
"check_equality(THD*,Item*,COND_EQUAL*,List<Item>*)" -> "Item_func::arguments() const"
"check_equality(THD*,Item*,COND_EQUAL*,List<Item>*)" -> "check_simple_equality(Item*,Item*,Item*,COND_EQUAL*)"
"check_equality(THD*,Item*,COND_EQUAL*,List<Item>*)" -> "check_row_equality(THD*,Item*,Item_row*,COND_EQUAL*,List<Item>*)"
"check_simple_equality(Item*,Item*,Item*,COND_EQUAL*)" -> "Item_func_eq::Item_func_eq(Item*,Item*)"
"check_simple_equality(Item*,Item*,Item*,COND_EQUAL*)" -> "Item_equal::Item_equal(Item_field*,Item_field*)"
"check_simple_equality(Item*,Item*,Item*,COND_EQUAL*)" -> "Item_equal::Item_equal(Item*,Item_field*)"
"check_simple_equality(Item*,Item*,Item*,COND_EQUAL*)" -> "Field::maybe_null() const"
"check_simple_equality(Item*,Item*,Item*,COND_EQUAL*)" -> "Item_equal::Item_equal(Item_equal*)"
"check_simple_equality(Item*,Item*,Item*,COND_EQUAL*)" -> "List_iterator<T>::remove() [with T = Item_equal]"
"check_simple_equality(Item*,Item*,Item*,COND_EQUAL*)" -> "Item_equal::add(Item*,Item_field*)"
"check_simple_equality(Item*,Item*,Item*,COND_EQUAL*)" -> "Item_equal::add(Item_field*)"
"check_simple_equality(Item*,Item*,Item*,COND_EQUAL*)" -> "Item_bool_func2::set_cmp_func()"
"check_simple_equality(Item*,Item*,Item*,COND_EQUAL*)" -> "List<T>::push_back(T*) [with T = Item_equal]"
"check_simple_equality(Item*,Item*,Item*,COND_EQUAL*)" -> "find_item_equal(COND_EQUAL*,Field*,bool*)"
"check_simple_equality(Item*,Item*,Item*,COND_EQUAL*)" -> "Item::quick_fix_field()"
"check_simple_equality(Item*,Item*,Item*,COND_EQUAL*)" -> "Item_equal::merge(Item_equal*)"
"check_simple_equality(Item*,Item*,Item*,COND_EQUAL*)" -> "List_iterator<T>::operator++(int) [with T = Item_equal]"
"check_simple_equality(Item*,Item*,Item*,COND_EQUAL*)" -> "List_iterator<T>::List_iterator(List<T>&) [with T = Item_equal]"
"Item_equal::Item_equal(Item_field*,Item_field*)" -> "List<T>::push_back(T*) [with T = Item_field]"
"Item_equal::Item_equal(Item_field*,Item_field*)" -> "Arg_comparator::Arg_comparator()"
"Item_equal::Item_equal(Item_field*,Item_field*)" -> "Item_bool_func::Item_bool_func()"
"Item_equal::Item_equal(Item_field*,Item_field*)" -> "List<T>::List() [with T = Item_field]"
"List<T>::push_back(T*) [with T = Item_field]" -> "base_list::push_back(void*)"
"Item_equal::Item_equal(Item*,Item_field*)" -> "List<T>::List() [with T = Item_field]"
"Item_equal::Item_equal(Item*,Item_field*)" -> "Item::is_temporal_with_date() const"
"Item_equal::Item_equal(Item*,Item_field*)" -> "List<T>::push_back(T*) [with T = Item_field]"
"Item_equal::Item_equal(Item*,Item_field*)" -> "Arg_comparator::Arg_comparator()"
"Item_equal::Item_equal(Item*,Item_field*)" -> "Item_bool_func::Item_bool_func()"
"Item_equal::Item_equal(Item_equal*)" -> "List_iterator_fast<T>::operator++(int) [with T = Item_field]"
"Item_equal::Item_equal(Item_equal*)" -> "List<T>::push_back(T*) [with T = Item_field]"
"Item_equal::Item_equal(Item_equal*)" -> "Item_bool_func::Item_bool_func()"
"Item_equal::Item_equal(Item_equal*)" -> "Arg_comparator::Arg_comparator()"
"Item_equal::Item_equal(Item_equal*)" -> "List_iterator_fast<T>::List_iterator_fast(List<T>&) [with T = Item_field]"
"Item_equal::Item_equal(Item_equal*)" -> "List<T>::List() [with T = Item_field]"
"List_iterator<T>::remove() [with T = Item_equal]" -> "base_list_iterator::remove()"
"Item_equal::add(Item*,Item_field*)" -> "Item_equal::compare_const(Item*)"
"Item_equal::add(Item*,Item_field*)" -> "Item::is_temporal_with_date() const"
"Item_equal::compare_const(Item*)" -> "Item::quick_fix_field()"
"Item_equal::compare_const(Item*)" -> "Arg_comparator::set_datetime_cmp_func(Item_result_field*,Item**,Item**)"
"Item_equal::compare_const(Item*)" -> "Arg_comparator::compare()"
"Item_equal::compare_const(Item*)" -> "Item_bool_func2::set_cmp_func()"
"Item_equal::compare_const(Item*)" -> "Item_func_eq::Item_func_eq(Item*,Item*)"
"Arg_comparator::set_datetime_cmp_func(Item_result_field*,Item**,Item**)" -> "Arg_comparator::set_cmp_context_for_datetime()"
"Arg_comparator::set_datetime_cmp_func(Item_result_field*,Item**,Item**)" -> "_current_thd()"
"Arg_comparator::set_cmp_context_for_datetime()" -> "Item::is_temporal() const"
"Item_bool_func2::set_cmp_func()" -> "Arg_comparator::set_cmp_func(Item_result_field*,Item**,Item**,bool)"
"Arg_comparator::set_cmp_func(Item_result_field*,Item**,Item**,bool)" -> "item_cmp_type(Item_result,Item_result)"
"Arg_comparator::set_cmp_func(Item_result_field*,Item**,Item**,bool)" -> "Arg_comparator::set_cmp_func(Item_result_field*,Item**,Item**,Item_result)"
"Arg_comparator::set_cmp_func(Item_result_field*,Item**,Item**,Item_result)" -> "_current_thd()"
"Arg_comparator::set_cmp_func(Item_result_field*,Item**,Item**,Item_result)" -> "Item::is_temporal_with_date() const"
"Arg_comparator::set_cmp_func(Item_result_field*,Item**,Item**,Item_result)" -> "Arg_comparator::can_compare_as_dates(Item*,Item*,ulonglong*)"
"Arg_comparator::set_cmp_func(Item_result_field*,Item**,Item**,Item_result)" -> "Item_cache_datetime::Item_cache_datetime(enum_field_types)"
"Arg_comparator::set_cmp_func(Item_result_field*,Item**,Item**,Item_result)" -> "agg_item_set_converter(DTCollation&,const char*,Item**,uint,uint,int)"
"Arg_comparator::set_cmp_func(Item_result_field*,Item**,Item**,Item_result)" -> "Item_cache_datetime::store(Item*,longlong)"
"Arg_comparator::set_cmp_func(Item_result_field*,Item**,Item**,Item_result)" -> "DTCollation::DTCollation()"
"Arg_comparator::set_cmp_func(Item_result_field*,Item**,Item**,Item_result)" -> "Arg_comparator::set_cmp_context_for_datetime()"
"Arg_comparator::set_cmp_func(Item_result_field*,Item**,Item**,Item_result)" -> "Arg_comparator::is_owner_equal_func()"
"Arg_comparator::set_cmp_func(Item_result_field*,Item**,Item**,Item_result)" -> "Arg_comparator::cache_converted_constant(THD*,Item**,Item**,Item_result)"
"Arg_comparator::set_cmp_func(Item_result_field*,Item**,Item**,Item_result)" -> "Item_cache::set_used_tables(table_map)"
"Arg_comparator::set_cmp_func(Item_result_field*,Item**,Item**,Item_result)" -> "DTCollation::set(const CHARSET_INFO*)"
"Arg_comparator::set_cmp_func(Item_result_field*,Item**,Item**,Item_result)" -> "Arg_comparator::set_compare_func(Item_result_field*,Item_result)"
"Arg_comparator::set_cmp_func(Item_result_field*,Item**,Item**,Item_result)" -> "Arg_comparator::try_year_cmp_func(Item_result)"
"Arg_comparator::can_compare_as_dates(Item*,Item*,ulonglong*)" -> "Arg_comparator::get_date_from_const(Item*,Item*,ulonglong*)"
"Arg_comparator::can_compare_as_dates(Item*,Item*,ulonglong*)" -> "Item::is_temporal_with_date() const"
"Arg_comparator::get_date_from_const(Item*,Item*,ulonglong*)" -> "Simple_cstring::ptr() const"
"Arg_comparator::get_date_from_const(Item*,Item*,ulonglong*)" -> "LEX::is_ps_or_view_context_analysis()"
"Arg_comparator::get_date_from_const(Item*,Item*,ulonglong*)" -> "_current_thd()"
"Arg_comparator::get_date_from_const(Item*,Item*,ulonglong*)" -> "String::String()"
"Arg_comparator::get_date_from_const(Item*,Item*,ulonglong*)" -> "get_date_from_str(THD*,String*,timestamp_type,const char*,bool*)"
"get_date_from_str(THD*,String*,timestamp_type,const char*,bool*)" -> "get_mysql_time_from_str(THD*,String*,timestamp_type,const char*,MYSQL_TIME*)"
"get_date_from_str(THD*,String*,timestamp_type,const char*,bool*)" -> "TIME_to_longlong_datetime_packed(const MYSQL_TIME*)"
"Item_cache_datetime::Item_cache_datetime(enum_field_types)" -> "String::String()"
"Item_cache_datetime::Item_cache_datetime(enum_field_types)" -> "Item_cache::Item_cache(enum_field_types)"
"Item_cache::Item_cache(enum_field_types)" -> "Item_basic_constant::Item_basic_constant()"
"agg_item_set_converter(DTCollation&,const char*,Item**,uint,uint,int)" -> "THD::change_item_tree(Item**,Item*)"
"agg_item_set_converter(DTCollation&,const char*,Item**,uint,uint,int)" -> "Prepared_stmt_arena_holder::Prepared_stmt_arena_holder(THD*,bool)"
"agg_item_set_converter(DTCollation&,const char*,Item**,uint,uint,int)" -> "my_coll_agg_error(Item**,uint,const char*,int)"
"agg_item_set_converter(DTCollation&,const char*,Item**,uint,uint,int)" -> "String::needs_conversion(uint32,const CHARSET_INFO*,const CHARSET_INFO*,uint32*)"
"agg_item_set_converter(DTCollation&,const char*,Item**,uint,uint,int)" -> "_current_thd()"
"agg_item_set_converter(DTCollation&,const char*,Item**,uint,uint,int)" -> "Item_func_conv_charset::Item_func_conv_charset(Item*,const CHARSET_INFO*,bool)"
"agg_item_set_converter(DTCollation&,const char*,Item**,uint,uint,int)" -> "Query_arena::is_stmt_prepare() const"
"my_coll_agg_error(Item**,uint,const char*,int)" -> "my_coll_agg_error(DTCollation&,DTCollation&,const char*)"
"my_coll_agg_error(Item**,uint,const char*,int)" -> "my_coll_agg_error(DTCollation&,DTCollation&,DTCollation&,const char*)"
"my_coll_agg_error(Item**,uint,const char*,int)" -> "my_error(int,myf,...)"
"my_coll_agg_error(DTCollation&,DTCollation&,const char*)" -> "DTCollation::derivation_name() const"
"my_coll_agg_error(DTCollation&,DTCollation&,const char*)" -> "my_error(int,myf,...)"
"my_coll_agg_error(DTCollation&,DTCollation&,DTCollation&,const char*)" -> "DTCollation::derivation_name() const"
"my_coll_agg_error(DTCollation&,DTCollation&,DTCollation&,const char*)" -> "my_error(int,myf,...)"
"Item_func_conv_charset::Item_func_conv_charset(Item*,const CHARSET_INFO*,bool)" -> "Item_str_func::Item_str_func(Item*)"
"Item_func_conv_charset::Item_func_conv_charset(Item*,const CHARSET_INFO*,bool)" -> "String::String()"
"Item_func_conv_charset::Item_func_conv_charset(Item*,const CHARSET_INFO*,bool)" -> "String::copy(const char*,uint32,const CHARSET_INFO*,const CHARSET_INFO*,uint*)"
"Item_func_conv_charset::Item_func_conv_charset(Item*,const CHARSET_INFO*,bool)" -> "String::mark_as_const()"
"Item_func_conv_charset::Item_func_conv_charset(Item*,const CHARSET_INFO*,bool)" -> "String::ptr() const"
"Item_func_conv_charset::Item_func_conv_charset(Item*,const CHARSET_INFO*,bool)" -> "String::charset() const"
"Item_func_conv_charset::Item_func_conv_charset(Item*,const CHARSET_INFO*,bool)" -> "String::length() const"
"Arg_comparator::cache_converted_constant(THD*,Item**,Item**,Item_result)" -> "LEX::is_ps_or_view_context_analysis()"
"Arg_comparator::cache_converted_constant(THD*,Item**,Item**,Item_result)" -> "Item_cache::get_cache(const Item*,Item_result)"
"Item_cache::get_cache(const Item*,Item_result)" -> "Item_cache_str::Item_cache_str(const Item*)"
"Item_cache::get_cache(const Item*,Item_result)" -> "Item::is_temporal() const"
"Item_cache::get_cache(const Item*,Item_result)" -> "Item_cache_row::Item_cache_row()"
"Item_cache::get_cache(const Item*,Item_result)" -> "Item_cache_datetime::Item_cache_datetime(enum_field_types)"
"Item_cache::get_cache(const Item*,Item_result)" -> "Item_cache_decimal::Item_cache_decimal()"
"Item_cache::get_cache(const Item*,Item_result)" -> "Item_cache_int::Item_cache_int(enum_field_types)"
"Item_cache::get_cache(const Item*,Item_result)" -> "Item_cache_real::Item_cache_real()"
"Item_cache_str::Item_cache_str(const Item*)" -> "Item_cache::Item_cache(enum_field_types)"
"Item_cache_str::Item_cache_str(const Item*)" -> "DTCollation::set(DTCollation&)"
"Item_cache_str::Item_cache_str(const Item*)" -> "String::String()"
"Item_cache_row::Item_cache_row()" -> "Item_cache::Item_cache()"
"Item_cache::Item_cache()" -> "Item_basic_constant::Item_basic_constant()"
"Item_cache_decimal::Item_cache_decimal()" -> "my_decimal::my_decimal()"
"Item_cache_decimal::Item_cache_decimal()" -> "Item_cache::Item_cache()"
"Item_cache_int::Item_cache_int(enum_field_types)" -> "Item_cache::Item_cache(enum_field_types)"
"Item_cache_real::Item_cache_real()" -> "Item_cache::Item_cache()"
"Arg_comparator::set_compare_func(Item_result_field*,Item_result)" -> "my_error(int,myf,...)"
"Arg_comparator::set_compare_func(Item_result_field*,Item_result)" -> "std::max(const _Tp&,const _Tp&) [with _Tp = unsigned char]"
"Arg_comparator::set_compare_func(Item_result_field*,Item_result)" -> "DTCollation::set(DTCollation&,DTCollation&,uint)"
"Arg_comparator::set_compare_func(Item_result_field*,Item_result)" -> "Arg_comparator::is_owner_equal_func()"
"Arg_comparator::set_compare_func(Item_result_field*,Item_result)" -> "Arg_comparator::set_cmp_func(Item_result_field*,Item**,Item**,bool)"
"Arg_comparator::set_compare_func(Item_result_field*,Item_result)" -> "Arg_comparator::Arg_comparator()"
"Arg_comparator::set_compare_func(Item_result_field*,Item_result)" -> "my_coll_agg_error(DTCollation&,DTCollation&,const char*)"
"Arg_comparator::set_compare_func(Item_result_field*,Item_result)" -> "Item::is_temporal() const"
"DTCollation::set(DTCollation&,DTCollation&,uint)" -> "DTCollation::set(DTCollation&)"
"DTCollation::set(DTCollation&,DTCollation&,uint)" -> "DTCollation::aggregate(DTCollation&,uint)"
"Arg_comparator::try_year_cmp_func(Item_result)" -> "Arg_comparator::set_cmp_context_for_datetime()"
"Arg_comparator::try_year_cmp_func(Item_result)" -> "Item::is_temporal_with_date() const"
"Arg_comparator::try_year_cmp_func(Item_result)" -> "Arg_comparator::is_owner_equal_func()"
"Item_equal::add(Item_field*)" -> "List<T>::push_back(T*) [with T = Item_field]"
"List<T>::push_back(T*) [with T = Item_equal]" -> "base_list::push_back(void*)"
"find_item_equal(COND_EQUAL*,Field*,bool*)" -> "List_iterator_fast<T>::operator++(int) [with T = Item_equal]"
"find_item_equal(COND_EQUAL*,Field*,bool*)" -> "List_iterator_fast<T>::List_iterator_fast(List<T>&) [with T = Item_equal]"
"find_item_equal(COND_EQUAL*,Field*,bool*)" -> "Item_equal::contains(Field*)"
"List_iterator_fast<T>::List_iterator_fast(List<T>&) [with T = Item_equal]" -> "base_list_iterator::base_list_iterator(base_list&)"
"Item_equal::contains(Field*)" -> "List_iterator_fast<T>::List_iterator_fast(List<T>&) [with T = Item_field]"
"Item_equal::contains(Field*)" -> "List_iterator_fast<T>::operator++(int) [with T = Item_field]"
"Item_equal::merge(Item_equal*)" -> "Item_equal::add(Item*)"
"Item_equal::merge(Item_equal*)" -> "List<T>::concat(List<T>*) [with T = Item_field]"
"Item_equal::add(Item*)" -> "Item_equal::compare_const(Item*)"
"List<T>::concat(List<T>*) [with T = Item_field]" -> "base_list::concat(base_list*)"
"List_iterator<T>::operator++(int) [with T = Item_equal]" -> "base_list_iterator::next()"
"List_iterator<T>::List_iterator(List<T>&) [with T = Item_equal]" -> "base_list_iterator::base_list_iterator(base_list&)"
"check_row_equality(THD*,Item*,Item_row*,COND_EQUAL*,List<Item>*)" -> "Item::quick_fix_field()"
"check_row_equality(THD*,Item*,Item_row*,COND_EQUAL*,List<Item>*)" -> "check_simple_equality(Item*,Item*,Item*,COND_EQUAL*)"
"check_row_equality(THD*,Item*,Item_row*,COND_EQUAL*,List<Item>*)" -> "Item_bool_func2::set_cmp_func()"
"check_row_equality(THD*,Item*,Item_row*,COND_EQUAL*,List<Item>*)" -> "check_row_equality(THD*,Item*,Item_row*,COND_EQUAL*,List<Item>*)"
"check_row_equality(THD*,Item*,Item_row*,COND_EQUAL*,List<Item>*)" -> "List<T>::push_back(T*) [with T = Item]"
"check_row_equality(THD*,Item*,Item_row*,COND_EQUAL*,List<Item>*)" -> "Item_func_eq::Item_func_eq(Item*,Item*)"
"propagate_cond_constants(THD*,I_List<COND_CMP>*,Item*,Item*)" -> "I_List_iterator<T>::operator++(int) [with T = COND_CMP]"
"propagate_cond_constants(THD*,I_List<COND_CMP>*,Item*,Item*)" -> "Item_cond::argument_list()"
"propagate_cond_constants(THD*,I_List<COND_CMP>*,Item*,Item*)" -> "List_iterator_fast<T>::operator++(int) [with T = Item]"
"propagate_cond_constants(THD*,I_List<COND_CMP>*,Item*,Item*)" -> "Item_func::arguments() const"
"propagate_cond_constants(THD*,I_List<COND_CMP>*,Item*,Item*)" -> "resolve_const_item(THD*,Item**,Item*)"
"propagate_cond_constants(THD*,I_List<COND_CMP>*,Item*,Item*)" -> "I_List<COND_CMP>::I_List()"
"propagate_cond_constants(THD*,I_List<COND_CMP>*,Item*,Item*)" -> "I_List_iterator<T>::I_List_iterator(I_List<T>&) [with T = COND_CMP]"
"propagate_cond_constants(THD*,I_List<COND_CMP>*,Item*,Item*)" -> "change_cond_ref_to_const(THD*,I_List<COND_CMP>*,Item*,Item*,Item*,Item*)"
"propagate_cond_constants(THD*,I_List<COND_CMP>*,Item*,Item*)" -> "propagate_cond_constants(THD*,I_List<COND_CMP>*,Item*,Item*)"
"propagate_cond_constants(THD*,I_List<COND_CMP>*,Item*,Item*)" -> "List_iterator_fast<T>::List_iterator_fast(List<T>&) [with T = Item]"
"I_List_iterator<T>::operator++(int) [with T = COND_CMP]" -> "base_ilist_iterator<T>::next() [with T = COND_CMP]"
"resolve_const_item(THD*,Item**,Item*)" -> "Item_int::Item_int(const Name_string&,longlong,uint)"
"resolve_const_item(THD*,Item**,Item*)" -> "String::ptr() const"
"resolve_const_item(THD*,Item**,Item*)" -> "resolve_const_item(THD*,Item**,Item*)"
"resolve_const_item(THD*,Item**,Item*)" -> "Item_null::Item_null(const Name_string&)"
"resolve_const_item(THD*,Item**,Item*)" -> "String::String(char*,uint32,const CHARSET_INFO*)"
"resolve_const_item(THD*,Item**,Item*)" -> "String::length() const"
"resolve_const_item(THD*,Item**,Item*)" -> "Item_decimal::Item_decimal(const Name_string&,const my_decimal*,uint,uint)"
"resolve_const_item(THD*,Item**,Item*)" -> "THD::change_item_tree(Item**,Item*)"
"resolve_const_item(THD*,Item**,Item*)" -> "my_decimal::my_decimal()"
"resolve_const_item(THD*,Item**,Item*)" -> "item_cmp_type(Item_result,Item_result)"
"resolve_const_item(THD*,Item**,Item*)" -> "String::charset() const"
"resolve_const_item(THD*,Item**,Item*)" -> "Item::is_temporal() const"
"resolve_const_item(THD*,Item**,Item*)" -> "sql_strmake(const char*,size_t)"
"resolve_const_item(THD*,Item**,Item*)" -> "create_temporal_literal(THD*,const char*,uint,const CHARSET_INFO*,enum_field_types,bool)"
"resolve_const_item(THD*,Item**,Item*)" -> "Item_string::Item_string(Name_string,const char*,uint,const CHARSET_INFO*,Derivation,uint)"
"resolve_const_item(THD*,Item**,Item*)" -> "Item_float::Item_float(Name_string,double,uint,uint)"
"Item_null::Item_null(const Name_string&)" -> "Item_null::init()"
"Item_null::Item_null(const Name_string&)" -> "Item_name_string::Item_name_string(Name_string)"
"Item_null::Item_null(const Name_string&)" -> "__builtin_memcpy(void*,const void*,long unsigned int)"
"Item_null::Item_null(const Name_string&)" -> "Item_basic_constant::Item_basic_constant()"
"Item_decimal::Item_decimal(const Name_string&,const my_decimal*,uint,uint)" -> "Item_name_string::Item_name_string(Name_string)"
"Item_decimal::Item_decimal(const Name_string&,const my_decimal*,uint,uint)" -> "my_decimal2decimal(const my_decimal*,my_decimal*)"
"Item_decimal::Item_decimal(const Name_string&,const my_decimal*,uint,uint)" -> "__builtin_memcpy(void*,const void*,long unsigned int)"
"Item_decimal::Item_decimal(const Name_string&,const my_decimal*,uint,uint)" -> "my_decimal::my_decimal()"
"Item_decimal::Item_decimal(const Name_string&,const my_decimal*,uint,uint)" -> "Item_num::Item_num()"
"Item_float::Item_float(Name_string,double,uint,uint)" -> "Item_num::Item_num()"
"Item_float::Item_float(Name_string,double,uint,uint)" -> "Name_string::Name_string()"
"Item_float::Item_float(Name_string,double,uint,uint)" -> "__builtin_memcpy(void*,const void*,long unsigned int)"
"Item_float::Item_float(Name_string,double,uint,uint)" -> "Item_name_string::Item_name_string(Name_string)"
"I_List<COND_CMP>::I_List()" -> "base_ilist<T>::base_ilist() [with T = COND_CMP]"
"base_ilist<T>::base_ilist() [with T = COND_CMP]" -> "base_ilist<T>::empty() [with T = COND_CMP]"
"base_ilist<T>::base_ilist() [with T = COND_CMP]" -> "ilink<T>::ilink() [with T = COND_CMP]"
"I_List_iterator<T>::I_List_iterator(I_List<T>&) [with T = COND_CMP]" -> "base_ilist_iterator<T>::base_ilist_iterator(base_ilist<T>&) [with T = COND_CMP]"
"change_cond_ref_to_const(THD*,I_List<COND_CMP>*,Item*,Item*,Item*,Item*)" -> "Item_func::arguments() const"
"change_cond_ref_to_const(THD*,I_List<COND_CMP>*,Item*,Item*,Item*,Item*)" -> "DTCollation::set(DTCollation&)"
"change_cond_ref_to_const(THD*,I_List<COND_CMP>*,Item*,Item*,Item*,Item*)" -> "List_iterator<T>::List_iterator(List<T>&) [with T = Item]"
"change_cond_ref_to_const(THD*,I_List<COND_CMP>*,Item*,Item*,Item*,Item*)" -> "change_cond_ref_to_const(THD*,I_List<COND_CMP>*,Item*,Item*,Item*,Item*)"
"change_cond_ref_to_const(THD*,I_List<COND_CMP>*,Item*,Item*,Item*,Item*)" -> "Item_cond::argument_list()"
"change_cond_ref_to_const(THD*,I_List<COND_CMP>*,Item*,Item*,Item*,Item*)" -> "THD::change_item_tree(Item**,Item*)"
"change_cond_ref_to_const(THD*,I_List<COND_CMP>*,Item*,Item*,Item*,Item*)" -> "List_iterator<T>::operator++(int) [with T = Item]"
"change_cond_ref_to_const(THD*,I_List<COND_CMP>*,Item*,Item*,Item*,Item*)" -> "Item_bool_func2::set_cmp_func()"
"change_cond_ref_to_const(THD*,I_List<COND_CMP>*,Item*,Item*,Item*,Item*)" -> "COND_CMP::COND_CMP(Item*,Item_func*)"
"change_cond_ref_to_const(THD*,I_List<COND_CMP>*,Item*,Item*,Item*,Item*)" -> "base_ilist<T>::push_back(T*) [with T = COND_CMP]"
"COND_CMP::COND_CMP(Item*,Item_func*)" -> "ilink<T>::ilink() [with T = COND_CMP]"
"remove_additional_cond(Item*)" -> "Simple_cstring::ptr() const"
"remove_additional_cond(Item*)" -> "List_iterator<T>::operator++(int) [with T = Item]"
"remove_additional_cond(Item*)" -> "Item_cond::argument_list()"
"remove_additional_cond(Item*)" -> "List_iterator<T>::remove() [with T = Item]"
"remove_additional_cond(Item*)" -> "List_iterator<T>::List_iterator(List<T>&) [with T = Item]"
"remove_additional_cond(Item*)" -> "List<T>::head() [with T = Item]"
"calc_group_buffer(JOIN*,ORDER*)" -> "my_decimal_get_binary_size(uint,uint)"
"calc_group_buffer(JOIN*,ORDER*)" -> "Item::is_temporal() const"
"calc_group_buffer(JOIN*,ORDER*)" -> "my_error(int,myf,...)"
"is_indexed_agg_distinct(JOIN*,List<Item_field>*)" -> "Item_sum::get_arg(uint)"
"is_indexed_agg_distinct(JOIN*,List<Item_field>*)" -> "JOIN::make_sum_func_list(List<Item>&,List<Item>&,bool,bool)"
"is_indexed_agg_distinct(JOIN*,List<Item_field>*)" -> "Bitmap<default_width>::set_bit(uint) [with unsigned int default_width = 4096u,uint = unsigned int]"
"is_indexed_agg_distinct(JOIN*,List<Item_field>*)" -> "Item_sum::get_arg_count() const"
"is_indexed_agg_distinct(JOIN*,List<Item_field>*)" -> "Bitmap<default_width>::merge(const Bitmap<default_width>&) [with unsigned int default_width = 4096u,Bitmap<default_width> = Bitmap<4096u>]"
"is_indexed_agg_distinct(JOIN*,List<Item_field>*)" -> "Bitmap<default_width>::Bitmap() [with unsigned int default_width = 4096u]"
"is_indexed_agg_distinct(JOIN*,List<Item_field>*)" -> "Bitmap<default_width>::operator!=(const Bitmap<default_width>&) const [with unsigned int default_width = 4096u,my_bool = char,Bitmap<default_width> = Bitmap<4096u>]"
"is_indexed_agg_distinct(JOIN*,List<Item_field>*)" -> "Bitmap<default_width>::is_clear_all() const [with unsigned int default_width = 4096u,my_bool = char]"
"is_indexed_agg_distinct(JOIN*,List<Item_field>*)" -> "List<T>::push_back(T*) [with T = Item_field]"
"JOIN::make_sum_func_list(List<Item>&,List<Item>&,bool,bool)" -> "Item_sum::depended_from()"
"JOIN::make_sum_func_list(List<Item>&,List<Item>&,bool,bool)" -> "List_iterator_fast<T>::List_iterator_fast(List<T>&) [with T = Item]"
"JOIN::make_sum_func_list(List<Item>&,List<Item>&,bool,bool)" -> "List_iterator_fast<T>::operator++(int) [with T = Item]"
"JOIN::make_sum_func_list(List<Item>&,List<Item>&,bool,bool)" -> "JOIN::rollup_make_fields(List<Item>&,List<Item>&,Item_sum***)"
"JOIN::rollup_make_fields(List<Item>&,List<Item>&,Item_sum***)" -> "List_iterator_fast<T>::rewind() [with T = Item]"
"JOIN::rollup_make_fields(List<Item>&,List<Item>&,Item_sum***)" -> "List_iterator<T>::List_iterator(List<T>&) [with T = Item]"
"JOIN::rollup_make_fields(List<Item>&,List<Item>&,Item_sum***)" -> "Item_sum::depended_from()"
"JOIN::rollup_make_fields(List<Item>&,List<Item>&,Item_sum***)" -> "JOIN::ORDER_with_src::operator ORDER*()"
"JOIN::rollup_make_fields(List<Item>&,List<Item>&,Item_sum***)" -> "Bounds_checked_array<Element_type>::operator[](size_t) [with Element_type = Item*,size_t = long unsigned int]"
"JOIN::rollup_make_fields(List<Item>&,List<Item>&,Item_sum***)" -> "Item_null_result::Item_null_result(enum_field_types,Item_result)"
"JOIN::rollup_make_fields(List<Item>&,List<Item>&,Item_sum***)" -> "List_iterator<T>::operator++(int) [with T = Item]"
"JOIN::rollup_make_fields(List<Item>&,List<Item>&,Item_sum***)" -> "List_iterator<T>::replace(T*) [with T = Item]"
"JOIN::rollup_make_fields(List<Item>&,List<Item>&,Item_sum***)" -> "List<T>::head() [with T = Item]"
"JOIN::rollup_make_fields(List<Item>&,List<Item>&,Item_sum***)" -> "List_iterator_fast<T>::List_iterator_fast(List<T>&) [with T = Item]"
"JOIN::rollup_make_fields(List<Item>&,List<Item>&,Item_sum***)" -> "List_iterator_fast<T>::operator++(int) [with T = Item]"
"Bitmap<default_width>::set_bit(uint) [with unsigned int default_width = 4096u,uint = unsigned int]" -> "bitmap_set_bit(MY_BITMAP*,uint)"
"Bitmap<default_width>::merge(const Bitmap<default_width>&) [with unsigned int default_width = 4096u,Bitmap<default_width> = Bitmap<4096u>]" -> "bitmap_union(MY_BITMAP*,const MY_BITMAP*)"
"Bitmap<default_width>::Bitmap() [with unsigned int default_width = 4096u]" -> "Bitmap<default_width>::init() [with unsigned int default_width = 4096u]"
"Bitmap<default_width>::init() [with unsigned int default_width = 4096u]" -> "bitmap_init(MY_BITMAP*,my_bitmap_map*,uint,my_bool)"
"Bitmap<default_width>::operator!=(const Bitmap<default_width>&) const [with unsigned int default_width = 4096u,my_bool = char,Bitmap<default_width> = Bitmap<4096u>]" -> "Bitmap<default_width>::operator==(const Bitmap<default_width>&) const [with unsigned int default_width = 4096u,my_bool = char,Bitmap<default_width> = Bitmap<4096u>]"
"Bitmap<default_width>::operator==(const Bitmap<default_width>&) const [with unsigned int default_width = 4096u,my_bool = char,Bitmap<default_width> = Bitmap<4096u>]" -> "bitmap_cmp(const MY_BITMAP*,const MY_BITMAP*)"
"bitmap_cmp(const MY_BITMAP*,const MY_BITMAP*)" -> "memcmp(const void*,const void*,size_t)"
"Bitmap<default_width>::is_clear_all() const [with unsigned int default_width = 4096u,my_bool = char]" -> "bitmap_is_clear_all(const MY_BITMAP*)"
"Opt_trace_struct::end()" -> "__builtin_expect(long int,long int)"
"Opt_trace_struct::end()" -> "Opt_trace_struct::do_destruct()"
"Opt_trace_struct::do_destruct()" -> "anonymous}::closing_bracket(bool)"
"Opt_trace_struct::do_destruct()" -> "Opt_trace_stmt::close_struct(const char*,bool,char)"
"Opt_trace_stmt::close_struct(const char*,bool,char)" -> "Opt_trace_context::get_end_marker() const"
"Opt_trace_stmt::close_struct(const char*,bool,char)" -> "Dynamic_array<Elem>::pop() [with Elem = Opt_trace_struct*]"
"Opt_trace_stmt::close_struct(const char*,bool,char)" -> "random_name_to_avoid_gcc_bug_29365::Buffer::append(const char*)"
"Opt_trace_stmt::close_struct(const char*,bool,char)" -> "Opt_trace_stmt::next_line()"
"Opt_trace_stmt::close_struct(const char*,bool,char)" -> "random_name_to_avoid_gcc_bug_29365::Buffer::append(char)"
"Opt_trace_stmt::close_struct(const char*,bool,char)" -> "Dynamic_array<Elem>::back() [with Elem = Opt_trace_struct*]"
"Opt_trace_stmt::close_struct(const char*,bool,char)" -> "random_name_to_avoid_gcc_bug_29365::Buffer::append(const char*,size_t)"
"Opt_trace_stmt::close_struct(const char*,bool,char)" -> "Opt_trace_context::restore_I_S()"
"Opt_trace_stmt::close_struct(const char*,bool,char)" -> "Opt_trace_stmt::support_I_S() const"
"Dynamic_array<Elem>::pop() [with Elem = Opt_trace_struct*]" -> "pop_dynamic(DYNAMIC_ARRAY*)"
"Opt_trace_context::restore_I_S()" -> "Opt_trace_context::Opt_trace_context_impl::restore_I_S()"
"Opt_trace_context::restore_I_S()" -> "__builtin_expect(long int,long int)"
"Opt_trace_context::Opt_trace_context_impl::restore_I_S()" -> "Opt_trace_stmt::restore_I_S()"
"JOIN::prune_table_partitions(THD*)" -> "TABLE_LIST::join_cond() const"
"JOIN::prune_table_partitions(THD*)" -> "prune_partitions(THD*,TABLE*,Item*)"
"record_join_nest_info(st_select_lex*,List<TABLE_LIST>*)" -> "TABLE_LIST::join_cond() const"
"record_join_nest_info(st_select_lex*,List<TABLE_LIST>*)" -> "List_iterator<T>::List_iterator(List<T>&) [with T = TABLE_LIST]"
"record_join_nest_info(st_select_lex*,List<TABLE_LIST>*)" -> "List<T>::push_back(T*) [with T = TABLE_LIST]"
"record_join_nest_info(st_select_lex*,List<TABLE_LIST>*)" -> "List_iterator<T>::operator++(int) [with T = TABLE_LIST]"
"record_join_nest_info(st_select_lex*,List<TABLE_LIST>*)" -> "record_join_nest_info(st_select_lex*,List<TABLE_LIST>*)"
"ha_make_pushed_joins(THD*,const AQP::Join_plan*)" -> "plugin_foreach_with_mask(THD*,my_bool (*)(THD*,plugin_ref,void*),int,uint,void*)"
"make_outerjoin_info(JOIN*)" -> "TABLE_LIST::outer_join_nest() const"
"make_outerjoin_info(JOIN*)" -> "TABLE_LIST::join_cond_ref()"
"make_outerjoin_info(JOIN*)" -> "TABLE_LIST::join_cond() const"
"JOIN::set_access_methods()" -> "st_join_table::prefix_tables() const"
"JOIN::set_access_methods()" -> "create_ref_for_key(JOIN*,JOIN_TAB*,Key_use*,table_map)"
"create_ref_for_key(JOIN*,JOIN_TAB*,Key_use*,table_map)" -> "store_key::copy()"
"create_ref_for_key(JOIN*,JOIN_TAB*,Key_use*,table_map)" -> "get_best_field(Item_field*,COND_EQUAL*)"
"create_ref_for_key(JOIN*,JOIN_TAB*,Key_use*,table_map)" -> "Query_arena::calloc(size_t)"
"create_ref_for_key(JOIN*,JOIN_TAB*,Key_use*,table_map)" -> "actual_key_parts(KEY*)"
"create_ref_for_key(JOIN*,JOIN_TAB*,Key_use*,table_map)" -> "actual_key_flags(KEY*)"
"create_ref_for_key(JOIN*,JOIN_TAB*,Key_use*,table_map)" -> "Query_arena::alloc(size_t)"
"create_ref_for_key(JOIN*,JOIN_TAB*,Key_use*,table_map)" -> "get_store_key(THD*,Key_use*,table_map,KEY_PART_INFO*,uchar*,uint)"
"create_ref_for_key(JOIN*,JOIN_TAB*,Key_use*,table_map)" -> "handler::ha_table_flags() const"
"create_ref_for_key(JOIN*,JOIN_TAB*,Key_use*,table_map)" -> "__builtin_expect(long int,long int)"
"create_ref_for_key(JOIN*,JOIN_TAB*,Key_use*,table_map)" -> "memset(void*,int,size_t)"
"get_best_field(Item_field*,COND_EQUAL*)" -> "Item_equal::get_subst_item(const Item_field*)"
"get_best_field(Item_field*,COND_EQUAL*)" -> "find_item_equal(COND_EQUAL*,Field*,bool*)"
"Item_equal::get_subst_item(const Item_field*)" -> "List<T>::head() [with T = Item_field]"
"Item_equal::get_subst_item(const Item_field*)" -> "sj_is_materialize_strategy(uint)"
"Item_equal::get_subst_item(const Item_field*)" -> "List_iterator<T>::operator++(int) [with T = Item_field]"
"Item_equal::get_subst_item(const Item_field*)" -> "List_iterator<T>::List_iterator(List<T>&) [with T = Item_field]"
"Item_equal::get_subst_item(const Item_field*)" -> "st_join_table::get_sj_strategy() const"
"List<T>::head() [with T = Item_field]" -> "base_list::head()"
"actual_key_parts(KEY*)" -> "THD::optimizer_switch_flag(ulonglong) const"
"actual_key_flags(KEY*)" -> "THD::optimizer_switch_flag(ulonglong) const"
"get_store_key(THD*,Key_use*,table_map,KEY_PART_INFO*,uchar*,uint)" -> "store_key_item::store_key_item(THD*,Field*,uchar*,uchar*,uint,Item*)"
"get_store_key(THD*,Key_use*,table_map,KEY_PART_INFO*,uchar*,uint)" -> "store_key_field::store_key_field(THD*,Field*,uchar*,uchar*,uint,Field*,const char*)"
"get_store_key(THD*,Key_use*,table_map,KEY_PART_INFO*,uchar*,uint)" -> "store_key_const_item::store_key_const_item(THD*,Field*,uchar*,uchar*,uint,Item*)"
"store_key_item::store_key_item(THD*,Field*,uchar*,uchar*,uint,Item*)" -> "store_key::store_key(THD*,Field*,uchar*,uchar*,uint)"
"store_key::store_key(THD*,Field*,uchar*,uchar*,uint)" -> "Field_varstring::Field_varstring(uchar*,uint32,uint,uchar*,uchar,Field::utype,const char*,TABLE_SHARE*,const CHARSET_INFO*)"
"store_key::store_key(THD*,Field*,uchar*,uchar*,uint)" -> "Sql_alloc::Sql_alloc()"
"store_key::store_key(THD*,Field*,uchar*,uchar*,uint)" -> "Field::init(TABLE*)"
"store_key_field::store_key_field(THD*,Field*,uchar*,uchar*,uint,Field*,const char*)" -> "Copy_field::set(Field*,Field*,bool)"
"store_key_field::store_key_field(THD*,Field*,uchar*,uchar*,uint,Field*,const char*)" -> "store_key::store_key(THD*,Field*,uchar*,uchar*,uint)"
"store_key_field::store_key_field(THD*,Field*,uchar*,uchar*,uint,Field*,const char*)" -> "Copy_field::Copy_field()"
"store_key_field::store_key_field(THD*,Field*,uchar*,uchar*,uint,Field*,const char*)" -> "Field::maybe_null() const"
"store_key_const_item::store_key_const_item(THD*,Field*,uchar*,uchar*,uint,Item*)" -> "store_key_item::store_key_item(THD*,Field*,uchar*,uchar*,uint,Item*)"
"make_join_statistics(JOIN*,TABLE_LIST*,Item*,Key_use_array*,bool)" -> "__builtin_expect(long int,long int)"
"make_join_statistics(JOIN*,TABLE_LIST*,Item*,Key_use_array*,bool)" -> "Bitmap<64u>::Bitmap()"
"make_join_statistics(JOIN*,TABLE_LIST*,Item*,Key_use_array*,bool)" -> "set_position(JOIN*,uint,JOIN_TAB*,Key_use*)"
"make_join_statistics(JOIN*,TABLE_LIST*,Item*,Key_use_array*,bool)" -> "optimize_semijoin_nests_for_materialization(JOIN*)"
"make_join_statistics(JOIN*,TABLE_LIST*,Item*,Key_use_array*,bool)" -> "Opt_trace_struct::add(const char*,ulonglong)"
"make_join_statistics(JOIN*,TABLE_LIST*,Item*,Key_use_array*,bool)" -> "Opt_trace_object::Opt_trace_object(Opt_trace_context*,const char*,Opt_trace_context::feature_value)"
"make_join_statistics(JOIN*,TABLE_LIST*,Item*,Key_use_array*,bool)" -> "memset(void*,int,size_t)"
"make_join_statistics(JOIN*,TABLE_LIST*,Item*,Key_use_array*,bool)" -> "Bitmap<64u>::is_clear_all() const"
"make_join_statistics(JOIN*,TABLE_LIST*,Item*,Key_use_array*,bool)" -> "Opt_trace_struct::add(const char*,bool)"
"make_join_statistics(JOIN*,TABLE_LIST*,Item*,Key_use_array*,bool)" -> "Query_arena::alloc(size_t)"
"make_join_statistics(JOIN*,TABLE_LIST*,Item*,Key_use_array*,bool)" -> "Bitmap<64u>::clear_all()"
"make_join_statistics(JOIN*,TABLE_LIST*,Item*,Key_use_array*,bool)" -> "trace_table_dependencies(Opt_trace_context*,JOIN_TAB*,uint)"
"make_join_statistics(JOIN*,TABLE_LIST*,Item*,Key_use_array*,bool)" -> "pull_out_semijoin_tables(JOIN*)"
"make_join_statistics(JOIN*,TABLE_LIST*,Item*,Key_use_array*,bool)" -> "Opt_trace_array::Opt_trace_array(Opt_trace_context*,const char*,Opt_trace_context::feature_value)"
"make_join_statistics(JOIN*,TABLE_LIST*,Item*,Key_use_array*,bool)" -> "st_join_table::st_join_table()"
"make_join_statistics(JOIN*,TABLE_LIST*,Item*,Key_use_array*,bool)" -> "_current_thd()"
"make_join_statistics(JOIN*,TABLE_LIST*,Item*,Key_use_array*,bool)" -> "Opt_trace_context::is_started() const"
"make_join_statistics(JOIN*,TABLE_LIST*,Item*,Key_use_array*,bool)" -> "handler::ha_table_flags() const"
"make_join_statistics(JOIN*,TABLE_LIST*,Item*,Key_use_array*,bool)" -> "Optimize_table_order::choose_table_order()"
"make_join_statistics(JOIN*,TABLE_LIST*,Item*,Key_use_array*,bool)" -> "JOIN::get_best_combination()"
"make_join_statistics(JOIN*,TABLE_LIST*,Item*,Key_use_array*,bool)" -> "mark_as_null_row(TABLE*)"
"make_join_statistics(JOIN*,TABLE_LIST*,Item*,Key_use_array*,bool)" -> "Opt_trace_struct::add_alnum(const char*,const char*)"
"make_join_statistics(JOIN*,TABLE_LIST*,Item*,Key_use_array*,bool)" -> "create_ref_for_key(JOIN*,JOIN_TAB*,Key_use*,table_map)"
"make_join_statistics(JOIN*,TABLE_LIST*,Item*,Key_use_array*,bool)" -> "st_position::st_position()"
"make_join_statistics(JOIN*,TABLE_LIST*,Item*,Key_use_array*,bool)" -> "optimize_keyuse(JOIN*,Key_use_array*)"
"make_join_statistics(JOIN*,TABLE_LIST*,Item*,Key_use_array*,bool)" -> "LEX::is_single_level_stmt()"
"make_join_statistics(JOIN*,TABLE_LIST*,Item*,Key_use_array*,bool)" -> "TABLE_LIST::outer_join_nest() const"
"make_join_statistics(JOIN*,TABLE_LIST*,Item*,Key_use_array*,bool)" -> "update_ref_and_keys(THD*,Key_use_array*,JOIN_TAB*,uint,Item*,COND_EQUAL*,table_map,SELECT_LEX*,SARGABLE_PARAM**)"
"make_join_statistics(JOIN*,TABLE_LIST*,Item*,Key_use_array*,bool)" -> "TABLE_LIST::fetch_number_of_rows()"
"make_join_statistics(JOIN*,TABLE_LIST*,Item*,Key_use_array*,bool)" -> "JOIN::plan_is_const() const"
"make_join_statistics(JOIN*,TABLE_LIST*,Item*,Key_use_array*,bool)" -> "TABLE_LIST::join_cond_ref()"
"make_join_statistics(JOIN*,TABLE_LIST*,Item*,Key_use_array*,bool)" -> "JOIN::decide_subquery_strategy()"
"make_join_statistics(JOIN*,TABLE_LIST*,Item*,Key_use_array*,bool)" -> "my_message(uint,const char*,myf)"
"make_join_statistics(JOIN*,TABLE_LIST*,Item*,Key_use_array*,bool)" -> "Opt_trace_object::Opt_trace_object(Opt_trace_context*,Opt_trace_context::feature_value)"
"make_join_statistics(JOIN*,TABLE_LIST*,Item*,Key_use_array*,bool)" -> "JOIN::set_semijoin_embedding()"
"make_join_statistics(JOIN*,TABLE_LIST*,Item*,Key_use_array*,bool)" -> "join_read_const_table(JOIN_TAB*,POSITION*)"
"make_join_statistics(JOIN*,TABLE_LIST*,Item*,Key_use_array*,bool)" -> "Bitmap<64u>::set_bit(uint)"
"make_join_statistics(JOIN*,TABLE_LIST*,Item*,Key_use_array*,bool)" -> "Optimize_table_order::Optimize_table_order(THD*,JOIN*,TABLE_LIST*)"
"make_join_statistics(JOIN*,TABLE_LIST*,Item*,Key_use_array*,bool)" -> "get_quick_record_count(THD*,SQL_SELECT*,TABLE*,const key_map*,ha_rows)"
"make_join_statistics(JOIN*,TABLE_LIST*,Item*,Key_use_array*,bool)" -> "std::min(const _Tp&,const _Tp&) [with _Tp = double]"
"make_join_statistics(JOIN*,TABLE_LIST*,Item*,Key_use_array*,bool)" -> "Bitmap<64u>::intersect(const Bitmap<64u>&)"
"make_join_statistics(JOIN*,TABLE_LIST*,Item*,Key_use_array*,bool)" -> "add_group_and_distinct_keys(JOIN*,JOIN_TAB*)"
"make_join_statistics(JOIN*,TABLE_LIST*,Item*,Key_use_array*,bool)" -> "Opt_trace_struct::add_utf8_table(const TABLE*)"
"make_join_statistics(JOIN*,TABLE_LIST*,Item*,Key_use_array*,bool)" -> "Bitmap<64u>::operator==(const Bitmap<64u>&) const"
"make_join_statistics(JOIN*,TABLE_LIST*,Item*,Key_use_array*,bool)" -> "Bitmap<64u>::merge(const Bitmap<64u>&)"
"make_join_statistics(JOIN*,TABLE_LIST*,Item*,Key_use_array*,bool)" -> "THD::is_error() const"
"make_join_statistics(JOIN*,TABLE_LIST*,Item*,Key_use_array*,bool)" -> "Bitmap<64u>::is_prefix(uint) const"
"make_join_statistics(JOIN*,TABLE_LIST*,Item*,Key_use_array*,bool)" -> "Opt_trace_struct::add(const char*,int)"
"make_join_statistics(JOIN*,TABLE_LIST*,Item*,Key_use_array*,bool)" -> "make_select(TABLE*,table_map,table_map,Item*,bool,int*)"
"make_join_statistics(JOIN*,TABLE_LIST*,Item*,Key_use_array*,bool)" -> "JOIN::refine_best_rowcount()"
"optimize_semijoin_nests_for_materialization(JOIN*)" -> "calculate_materialization_costs(JOIN*,TABLE_LIST*,uint,Semijoin_mat_optimize*)"
"optimize_semijoin_nests_for_materialization(JOIN*)" -> "Optimize_table_order::choose_table_order()"
"optimize_semijoin_nests_for_materialization(JOIN*)" -> "List_iterator<T>::List_iterator(List<T>&) [with T = TABLE_LIST]"
"optimize_semijoin_nests_for_materialization(JOIN*)" -> "THD::optimizer_switch_flag(ulonglong) const"
"optimize_semijoin_nests_for_materialization(JOIN*)" -> "List_iterator<T>::operator++(int) [with T = TABLE_LIST]"
"optimize_semijoin_nests_for_materialization(JOIN*)" -> "memcpy(void*,const void*,size_t)"
"optimize_semijoin_nests_for_materialization(JOIN*)" -> "Opt_trace_object::Opt_trace_object(Opt_trace_context*,Opt_trace_context::feature_value)"
"optimize_semijoin_nests_for_materialization(JOIN*)" -> "Query_arena::alloc(size_t)"
"optimize_semijoin_nests_for_materialization(JOIN*)" -> "Opt_trace_object::Opt_trace_object(Opt_trace_context*,const char*,Opt_trace_context::feature_value)"
"optimize_semijoin_nests_for_materialization(JOIN*)" -> "semijoin_types_allow_materialization(TABLE_LIST*)"
"optimize_semijoin_nests_for_materialization(JOIN*)" -> "my_count_bits(ulonglong)"
"optimize_semijoin_nests_for_materialization(JOIN*)" -> "Opt_trace_array::Opt_trace_array(Opt_trace_context*,const char*,Opt_trace_context::feature_value)"
"optimize_semijoin_nests_for_materialization(JOIN*)" -> "Optimize_table_order::Optimize_table_order(THD*,JOIN*,TABLE_LIST*)"
"calculate_materialization_costs(JOIN*,TABLE_LIST*,uint,Semijoin_mat_optimize*)" -> "Table_map_iterator::Table_map_iterator(ulonglong)"
"calculate_materialization_costs(JOIN*,TABLE_LIST*,uint,Semijoin_mat_optimize*)" -> "std::min(const _Tp&,const _Tp&) [with _Tp = double]"
"calculate_materialization_costs(JOIN*,TABLE_LIST*,uint,Semijoin_mat_optimize*)" -> "get_tmp_table_rec_length(List<Item>&)"
"calculate_materialization_costs(JOIN*,TABLE_LIST*,uint,Semijoin_mat_optimize*)" -> "Cost_estimate::reset()"
"calculate_materialization_costs(JOIN*,TABLE_LIST*,uint,Semijoin_mat_optimize*)" -> "Table_map_iterator::next_bit()"
"calculate_materialization_costs(JOIN*,TABLE_LIST*,uint,Semijoin_mat_optimize*)" -> "List_iterator<T>::operator++(int) [with T = Item]"
"calculate_materialization_costs(JOIN*,TABLE_LIST*,uint,Semijoin_mat_optimize*)" -> "List_iterator<T>::List_iterator(List<T>&) [with T = Item]"
"calculate_materialization_costs(JOIN*,TABLE_LIST*,uint,Semijoin_mat_optimize*)" -> "Cost_estimate::add_io(double)"
"calculate_materialization_costs(JOIN*,TABLE_LIST*,uint,Semijoin_mat_optimize*)" -> "get_partial_join_cost(JOIN*,uint,double*,double*)"
"get_tmp_table_rec_length(List<Item>&)" -> "List_iterator<T>::List_iterator(List<T>&) [with T = Item]"
"get_tmp_table_rec_length(List<Item>&)" -> "Item::is_temporal() const"
"get_tmp_table_rec_length(List<Item>&)" -> "List_iterator<T>::operator++(int) [with T = Item]"
"Optimize_table_order::choose_table_order()" -> "Join_tab_compare_embedded_first::Join_tab_compare_embedded_first(const TABLE_LIST*)"
"Optimize_table_order::choose_table_order()" -> "Opt_trace_object::Opt_trace_object(Opt_trace_context*,Opt_trace_context::feature_value)"
"Optimize_table_order::choose_table_order()" -> "Optimize_table_order::optimize_straight_join(table_map)"
"Optimize_table_order::choose_table_order()" -> "merge_sort(Element_type**,Element_type**,Comp_func) [with Element_type = st_join_table,Comp_func = Join_tab_compare_default]"
"Optimize_table_order::choose_table_order()" -> "memcpy(void*,const void*,size_t)"
"Optimize_table_order::choose_table_order()" -> "reset_nj_counters(List<TABLE_LIST>*)"
"Optimize_table_order::choose_table_order()" -> "Optimize_table_order::greedy_search(table_map)"
"Optimize_table_order::choose_table_order()" -> "merge_sort(Element_type**,Element_type**,Comp_func) [with Element_type = st_join_table,Comp_func = Join_tab_compare_straight]"
"Optimize_table_order::choose_table_order()" -> "Optimize_table_order::fix_semijoin_strategies()"
"Optimize_table_order::choose_table_order()" -> "merge_sort(Element_type**,Element_type**,Comp_func) [with Element_type = st_join_table,Comp_func = Join_tab_compare_embedded_first]"
"Optimize_table_order::choose_table_order()" -> "Opt_trace_array::Opt_trace_array(Opt_trace_context*,const char*,Opt_trace_context::feature_value)"
"Join_tab_compare_embedded_first::Join_tab_compare_embedded_first(const TABLE_LIST*)" -> "bool>::binary_function()"
"Optimize_table_order::optimize_straight_join(table_map)" -> "Optimize_table_order::best_access_path(JOIN_TAB*,table_map,uint,bool,double,POSITION*,POSITION*)"
"Optimize_table_order::optimize_straight_join(table_map)" -> "trace_plan_prefix(JOIN*,uint,table_map)"
"Optimize_table_order::optimize_straight_join(table_map)" -> "base_list::is_empty() const"
"Optimize_table_order::optimize_straight_join(table_map)" -> "Opt_trace_context::is_started() const"
"Optimize_table_order::optimize_straight_join(table_map)" -> "__builtin_expect(long int,long int)"
"Optimize_table_order::optimize_straight_join(table_map)" -> "memcpy(void*,const void*,size_t)"
"Optimize_table_order::optimize_straight_join(table_map)" -> "Opt_trace_object::Opt_trace_object(Opt_trace_context*,Opt_trace_context::feature_value)"
"Optimize_table_order::optimize_straight_join(table_map)" -> "Optimize_table_order::advance_sj_state(table_map,const JOIN_TAB*,uint,double*,double*,POSITION*)"
"Optimize_table_order::optimize_straight_join(table_map)" -> "Opt_trace_struct::add_utf8_table(const TABLE*)"
"Optimize_table_order::optimize_straight_join(table_map)" -> "st_position::set_prefix_costs(double,double)"
"Optimize_table_order::optimize_straight_join(table_map)" -> "Opt_trace_struct::add(const char*,double)"
"Optimize_table_order::optimize_straight_join(table_map)" -> "st_position::no_semijoin()"
"Optimize_table_order::optimize_straight_join(table_map)" -> "st_position::st_position()"
"Optimize_table_order::best_access_path(JOIN_TAB*,table_map,uint,bool,double,POSITION*,POSITION*)" -> "Loose_scan_opt::check_ref_access_part1(JOIN_TAB*,uint,Key_use*,key_part_map)"
"Optimize_table_order::best_access_path(JOIN_TAB*,table_map,uint,bool,double,POSITION*,POSITION*)" -> "Opt_trace_array::Opt_trace_array(Opt_trace_context*,const char*,Opt_trace_context::feature_value)"
"Optimize_table_order::best_access_path(JOIN_TAB*,table_map,uint,bool,double,POSITION*,POSITION*)" -> "std::min(const _Tp&,const _Tp&) [with _Tp = double]"
"Optimize_table_order::best_access_path(JOIN_TAB*,table_map,uint,bool,double,POSITION*,POSITION*)" -> "Loose_scan_opt::init(JOIN_TAB*,table_map,bool,bool)"
"Optimize_table_order::best_access_path(JOIN_TAB*,table_map,uint,bool,double,POSITION*,POSITION*)" -> "Loose_scan_opt::check_range_access(JOIN*,uint,QUICK_SELECT_I*)"
"Optimize_table_order::best_access_path(JOIN_TAB*,table_map,uint,bool,double,POSITION*,POSITION*)" -> "Loose_scan_opt::have_a_case()"
"Optimize_table_order::best_access_path(JOIN_TAB*,table_map,uint,bool,double,POSITION*,POSITION*)" -> "Loose_scan_opt::next_ref_key()"
"Optimize_table_order::best_access_path(JOIN_TAB*,table_map,uint,bool,double,POSITION*,POSITION*)" -> "actual_key_parts(KEY*)"
"Optimize_table_order::best_access_path(JOIN_TAB*,table_map,uint,bool,double,POSITION*,POSITION*)" -> "Opt_trace_struct::add_utf8(const char*,const char*)"
"Optimize_table_order::best_access_path(JOIN_TAB*,table_map,uint,bool,double,POSITION*,POSITION*)" -> "handler::ha_table_flags() const"
"Optimize_table_order::best_access_path(JOIN_TAB*,table_map,uint,bool,double,POSITION*,POSITION*)" -> "Opt_trace_object::Opt_trace_object(Opt_trace_context*,const char*,Opt_trace_context::feature_value)"
"Optimize_table_order::best_access_path(JOIN_TAB*,table_map,uint,bool,double,POSITION*,POSITION*)" -> "Bitmap<64u>::is_clear_all() const"
"Optimize_table_order::best_access_path(JOIN_TAB*,table_map,uint,bool,double,POSITION*,POSITION*)" -> "Opt_trace_struct::add(const char*,bool)"
"Optimize_table_order::best_access_path(JOIN_TAB*,table_map,uint,bool,double,POSITION*,POSITION*)" -> "Loose_scan_opt::Loose_scan_opt()"
"Optimize_table_order::best_access_path(JOIN_TAB*,table_map,uint,bool,double,POSITION*,POSITION*)" -> "Opt_trace_object::Opt_trace_object(Opt_trace_context*,Opt_trace_context::feature_value)"
"Optimize_table_order::best_access_path(JOIN_TAB*,table_map,uint,bool,double,POSITION*,POSITION*)" -> "Opt_trace_struct::add(const char*,double)"
"Optimize_table_order::best_access_path(JOIN_TAB*,table_map,uint,bool,double,POSITION*,POSITION*)" -> "Opt_trace_struct::add_alnum(const char*,const char*)"
"Optimize_table_order::best_access_path(JOIN_TAB*,table_map,uint,bool,double,POSITION*,POSITION*)" -> "cache_record_length(JOIN*,uint)"
"Optimize_table_order::best_access_path(JOIN_TAB*,table_map,uint,bool,double,POSITION*,POSITION*)" -> "__builtin_expect(long int,long int)"
"Optimize_table_order::best_access_path(JOIN_TAB*,table_map,uint,bool,double,POSITION*,POSITION*)" -> "Bitmap<64u>::is_set(uint) const"
"Optimize_table_order::best_access_path(JOIN_TAB*,table_map,uint,bool,double,POSITION*,POSITION*)" -> "THD::optimizer_switch_flag(ulonglong) const"
"Optimize_table_order::best_access_path(JOIN_TAB*,table_map,uint,bool,double,POSITION*,POSITION*)" -> "max_part_bit(key_part_map)"
"Optimize_table_order::best_access_path(JOIN_TAB*,table_map,uint,bool,double,POSITION*,POSITION*)" -> "Loose_scan_opt::save_to_position(JOIN_TAB*,POSITION*)"
"Optimize_table_order::best_access_path(JOIN_TAB*,table_map,uint,bool,double,POSITION*,POSITION*)" -> "Opt_trace_struct::add(const char*,ulonglong)"
"Optimize_table_order::best_access_path(JOIN_TAB*,table_map,uint,bool,double,POSITION*,POSITION*)" -> "prev_record_reads(JOIN*,uint,table_map)"
"Optimize_table_order::best_access_path(JOIN_TAB*,table_map,uint,bool,double,POSITION*,POSITION*)" -> "Loose_scan_opt::add_keyuse(table_map,Key_use*)"
"Loose_scan_opt::check_ref_access_part1(JOIN_TAB*,uint,Key_use*,key_part_map)" -> "Bitmap<64u>::is_set(uint) const"
"Loose_scan_opt::check_ref_access_part1(JOIN_TAB*,uint,Key_use*,key_part_map)" -> "key_uses_partial_cols(TABLE*,uint)"
"key_uses_partial_cols(TABLE*,uint)" -> "Bitmap<64u>::is_set(uint) const"
"Loose_scan_opt::init(JOIN_TAB*,table_map,bool,bool)" -> "THD::optimizer_switch_flag(ulonglong) const"
"Loose_scan_opt::init(JOIN_TAB*,table_map,bool,bool)" -> "TABLE_LIST::uses_materialization() const"
"cache_record_length(JOIN*,uint)" -> "calc_used_field_length(THD*,JOIN_TAB*)"
"calc_used_field_length(THD*,JOIN_TAB*)" -> "bitmap_is_set(const MY_BITMAP*,uint)"
"calc_used_field_length(THD*,JOIN_TAB*)" -> "std::max(const _Tp&,const _Tp&) [with _Tp = unsigned int]"
"trace_plan_prefix(JOIN*,uint,table_map)" -> "String::ptr() const"
"trace_plan_prefix(JOIN*,uint,table_map)" -> "TABLE_LIST::print(THD*,String*,enum_query_type)"
"trace_plan_prefix(JOIN*,uint,table_map)" -> "Opt_trace_array::Opt_trace_array(Opt_trace_context*,const char*,Opt_trace_context::feature_value)"
"trace_plan_prefix(JOIN*,uint,table_map)" -> "StringBuffer<buff_sz>::StringBuffer() [with long unsigned int buff_sz = 32ul]"
"trace_plan_prefix(JOIN*,uint,table_map)" -> "Opt_trace_struct::add_utf8(const char*,size_t)"
"trace_plan_prefix(JOIN*,uint,table_map)" -> "String::length() const"
"Opt_trace_struct::add_utf8(const char*,size_t)" -> "__builtin_expect(long int,long int)"
"Opt_trace_struct::add_utf8(const char*,size_t)" -> "Opt_trace_struct::do_add(const char*,const char*,size_t,bool)"
"Optimize_table_order::advance_sj_state(table_map,const JOIN_TAB*,uint,double*,double*,POSITION*)" -> "Optimize_table_order::semijoin_dupsweedout_access_paths(uint,uint,table_map,double*,double*)"
"Optimize_table_order::advance_sj_state(table_map,const JOIN_TAB*,uint,double*,double*,POSITION*)" -> "THD::optimizer_switch_flag(ulonglong) const"
"Optimize_table_order::advance_sj_state(table_map,const JOIN_TAB*,uint,double*,double*,POSITION*)" -> "Opt_trace_object::Opt_trace_object(Opt_trace_context*,Opt_trace_context::feature_value)"
"Optimize_table_order::advance_sj_state(table_map,const JOIN_TAB*,uint,double*,double*,POSITION*)" -> "Optimize_table_order::semijoin_mat_scan_access_paths(uint,uint,table_map,TABLE_LIST*,bool,double*,double*)"
"Optimize_table_order::advance_sj_state(table_map,const JOIN_TAB*,uint,double*,double*,POSITION*)" -> "Optimize_table_order::semijoin_firstmatch_loosescan_access_paths(uint,uint,table_map,bool,bool,double*,double*)"
"Optimize_table_order::advance_sj_state(table_map,const JOIN_TAB*,uint,double*,double*,POSITION*)" -> "semijoin_order_allows_materialization(const JOIN*,table_map,const JOIN_TAB*,uint)"
"Optimize_table_order::advance_sj_state(table_map,const JOIN_TAB*,uint,double*,double*,POSITION*)" -> "Opt_trace_struct::add_alnum(const char*,const char*)"
"Optimize_table_order::advance_sj_state(table_map,const JOIN_TAB*,uint,double*,double*,POSITION*)" -> "st_position::set_prefix_costs(double,double)"
"Optimize_table_order::advance_sj_state(table_map,const JOIN_TAB*,uint,double*,double*,POSITION*)" -> "Opt_trace_struct::add(const char*,double)"
"Optimize_table_order::advance_sj_state(table_map,const JOIN_TAB*,uint,double*,double*,POSITION*)" -> "Opt_trace_array::Opt_trace_array(Opt_trace_context*,const char*,Opt_trace_context::feature_value)"
"Optimize_table_order::advance_sj_state(table_map,const JOIN_TAB*,uint,double*,double*,POSITION*)" -> "Optimize_table_order::semijoin_mat_lookup_access_paths(uint,TABLE_LIST*,double*,double*)"
"Optimize_table_order::advance_sj_state(table_map,const JOIN_TAB*,uint,double*,double*,POSITION*)" -> "Opt_trace_struct::add(const char*,bool)"
"Optimize_table_order::semijoin_dupsweedout_access_paths(uint,uint,table_map,double*,double*)" -> "Cost_estimate::total_cost() const"
"Optimize_table_order::semijoin_mat_scan_access_paths(uint,uint,table_map,TABLE_LIST*,bool,double*,double*)" -> "Opt_trace_object::Opt_trace_object(Opt_trace_context*,const char*,Opt_trace_context::feature_value)"
"Optimize_table_order::semijoin_mat_scan_access_paths(uint,uint,table_map,TABLE_LIST*,bool,double*,double*)" -> "Opt_trace_struct::add_utf8_table(const TABLE*)"
"Optimize_table_order::semijoin_mat_scan_access_paths(uint,uint,table_map,TABLE_LIST*,bool,double*,double*)" -> "Cost_estimate::total_cost() const"
"Optimize_table_order::semijoin_mat_scan_access_paths(uint,uint,table_map,TABLE_LIST*,bool,double*,double*)" -> "Opt_trace_array::Opt_trace_array(Opt_trace_context*,const char*,Opt_trace_context::feature_value)"
"Optimize_table_order::semijoin_mat_scan_access_paths(uint,uint,table_map,TABLE_LIST*,bool,double*,double*)" -> "Opt_trace_object::Opt_trace_object(Opt_trace_context*,Opt_trace_context::feature_value)"
"Optimize_table_order::semijoin_mat_scan_access_paths(uint,uint,table_map,TABLE_LIST*,bool,double*,double*)" -> "my_count_bits(ulonglong)"
"Optimize_table_order::semijoin_mat_scan_access_paths(uint,uint,table_map,TABLE_LIST*,bool,double*,double*)" -> "Optimize_table_order::best_access_path(JOIN_TAB*,table_map,uint,bool,double,POSITION*,POSITION*)"
"Optimize_table_order::semijoin_mat_scan_access_paths(uint,uint,table_map,TABLE_LIST*,bool,double*,double*)" -> "st_position::st_position()"
"st_position::st_position()" -> "Cost_estimate::Cost_estimate()"
"st_position::st_position()" -> "Sql_alloc::Sql_alloc()"
"Optimize_table_order::semijoin_firstmatch_loosescan_access_paths(uint,uint,table_map,bool,bool,double*,double*)" -> "Opt_trace_object::Opt_trace_object(Opt_trace_context*,Opt_trace_context::feature_value)"
"Optimize_table_order::semijoin_firstmatch_loosescan_access_paths(uint,uint,table_map,bool,bool,double*,double*)" -> "Opt_trace_object::Opt_trace_object(Opt_trace_context*,const char*,Opt_trace_context::feature_value)"
"Optimize_table_order::semijoin_firstmatch_loosescan_access_paths(uint,uint,table_map,bool,bool,double*,double*)" -> "Opt_trace_struct::add_utf8_table(const TABLE*)"
"Optimize_table_order::semijoin_firstmatch_loosescan_access_paths(uint,uint,table_map,bool,bool,double*,double*)" -> "Optimize_table_order::best_access_path(JOIN_TAB*,table_map,uint,bool,double,POSITION*,POSITION*)"
"Optimize_table_order::semijoin_firstmatch_loosescan_access_paths(uint,uint,table_map,bool,bool,double*,double*)" -> "Cost_estimate::total_cost() const"
"Optimize_table_order::semijoin_firstmatch_loosescan_access_paths(uint,uint,table_map,bool,bool,double*,double*)" -> "st_position::set_prefix_costs(double,double)"
"Optimize_table_order::semijoin_firstmatch_loosescan_access_paths(uint,uint,table_map,bool,bool,double*,double*)" -> "Opt_trace_array::Opt_trace_array(Opt_trace_context*,const char*,Opt_trace_context::feature_value)"
"Optimize_table_order::semijoin_firstmatch_loosescan_access_paths(uint,uint,table_map,bool,bool,double*,double*)" -> "st_position::st_position()"
"st_position::set_prefix_costs(double,double)" -> "Cost_estimate::add_io(double)"
"st_position::set_prefix_costs(double,double)" -> "Cost_estimate::reset()"
"semijoin_order_allows_materialization(const JOIN*,table_map,const JOIN_TAB*,uint)" -> "my_count_bits(ulonglong)"
"Optimize_table_order::semijoin_mat_lookup_access_paths(uint,TABLE_LIST*,double*,double*)" -> "my_count_bits(ulonglong)"
"Optimize_table_order::semijoin_mat_lookup_access_paths(uint,TABLE_LIST*,double*,double*)" -> "Cost_estimate::total_cost() const"
"merge_sort(Element_type**,Element_type**,Comp_func) [with Element_type = st_join_table,Comp_func = Join_tab_compare_default]" -> "_Sequence>::queue(const _Sequence&) [with _Tp = st_join_table*,_Sequence = std::deque<st_join_table*,std::allocator<st_join_table*> >]"
"merge_sort(Element_type**,Element_type**,Comp_func) [with Element_type = st_join_table,Comp_func = Join_tab_compare_default]" -> "merge_sort(Element_type**,Element_type**,Comp_func) [with Element_type = st_join_table,Comp_func = Join_tab_compare_default]"
"merge_sort(Element_type**,Element_type**,Comp_func) [with Element_type = st_join_table,Comp_func = Join_tab_compare_default]" -> "_Sequence>::push(const value_type&) [with _Tp = st_join_table*,_Sequence = std::deque<st_join_table*,std::allocator<st_join_table*> >,std::queue<_Tp,_Sequence>::value_type = st_join_table*]"
"merge_sort(Element_type**,Element_type**,Comp_func) [with Element_type = st_join_table,Comp_func = Join_tab_compare_default]" -> "insert_sort(Element_type**,Element_type**,Comp_func) [with Element_type = st_join_table,Comp_func = Join_tab_compare_default]"
"merge_sort(Element_type**,Element_type**,Comp_func) [with Element_type = st_join_table,Comp_func = Join_tab_compare_default]" -> "_Alloc>::deque() [with _Tp = st_join_table*,_Alloc = std::allocator<st_join_table*>]"
"merge_sort(Element_type**,Element_type**,Comp_func) [with Element_type = st_join_table,Comp_func = Join_tab_compare_default]" -> "_Sequence>::pop() [with _Tp = st_join_table*,_Sequence = std::deque<st_join_table*,std::allocator<st_join_table*> >]"
"merge_sort(Element_type**,Element_type**,Comp_func) [with Element_type = st_join_table,Comp_func = Join_tab_compare_default]" -> "_Sequence>::empty() const [with _Tp = st_join_table*,_Sequence = std::deque<st_join_table*,std::allocator<st_join_table*> >]"
"merge_sort(Element_type**,Element_type**,Comp_func) [with Element_type = st_join_table,Comp_func = Join_tab_compare_default]" -> "Join_tab_compare_default::operator()(const JOIN_TAB*,const JOIN_TAB*)"
"merge_sort(Element_type**,Element_type**,Comp_func) [with Element_type = st_join_table,Comp_func = Join_tab_compare_default]" -> "_Sequence>::front() [with _Tp = st_join_table*,_Sequence = std::deque<st_join_table*,std::allocator<st_join_table*> >,std::queue<_Tp,_Sequence>::reference = st_join_table*&]"
"_Sequence>::queue(const _Sequence&) [with _Tp = st_join_table*,_Sequence = std::deque<st_join_table*,std::allocator<st_join_table*> >]" -> "_Alloc>::deque(const std::deque<_Tp,_Alloc>&) [with _Tp = st_join_table*,_Alloc = std::allocator<st_join_table*>,std::deque<_Tp,_Alloc> = std::deque<st_join_table*,std::allocator<st_join_table*> >]"
"_Alloc>::deque(const std::deque<_Tp,_Alloc>&) [with _Tp = st_join_table*,_Alloc = std::allocator<st_join_table*>,std::deque<_Tp,_Alloc> = std::deque<st_join_table*,std::allocator<st_join_table*> >]" -> "_Alloc>::_M_get_Tp_allocator() const [with _Tp = st_join_table*,_Alloc = std::allocator<st_join_table*>,std::_Deque_base<_Tp,_Alloc>::_Tp_alloc_type = std::allocator<st_join_table*>]"
"_Alloc>::deque(const std::deque<_Tp,_Alloc>&) [with _Tp = st_join_table*,_Alloc = std::allocator<st_join_table*>,std::deque<_Tp,_Alloc> = std::deque<st_join_table*,std::allocator<st_join_table*> >]" -> "_Ptr>::_Deque_iterator(const iterator&) [with _Tp = st_join_table*,_Ref = st_join_table*&,_Ptr = st_join_table**,std::_Deque_iterator<_Tp,_Ref,_Ptr>::iterator = std::_Deque_iterator<st_join_table*,st_join_table*&,st_join_table**>]"
"_Alloc>::deque(const std::deque<_Tp,_Alloc>&) [with _Tp = st_join_table*,_Alloc = std::allocator<st_join_table*>,std::deque<_Tp,_Alloc> = std::deque<st_join_table*,std::allocator<st_join_table*> >]" -> "_Alloc>::end() const [with _Tp = st_join_table*,_Alloc = std::allocator<st_join_table*>,std::deque<_Tp,_Alloc>::const_iterator = std::_Deque_iterator<st_join_table*,st_join_table* const&,st_join_table* const*>]"
"_Alloc>::deque(const std::deque<_Tp,_Alloc>&) [with _Tp = st_join_table*,_Alloc = std::allocator<st_join_table*>,std::deque<_Tp,_Alloc> = std::deque<st_join_table*,std::allocator<st_join_table*> >]" -> "_Alloc>::_M_get_Tp_allocator() [with _Tp = st_join_table*,_Alloc = std::allocator<st_join_table*>,std::_Deque_base<_Tp,_Alloc>::_Tp_alloc_type = std::allocator<st_join_table*>]"
"_Alloc>::deque(const std::deque<_Tp,_Alloc>&) [with _Tp = st_join_table*,_Alloc = std::allocator<st_join_table*>,std::deque<_Tp,_Alloc> = std::deque<st_join_table*,std::allocator<st_join_table*> >]" -> "_Alloc>::begin() const [with _Tp = st_join_table*,_Alloc = std::allocator<st_join_table*>,std::deque<_Tp,_Alloc>::const_iterator = std::_Deque_iterator<st_join_table*,st_join_table* const&,st_join_table* const*>]"
"_Alloc>::deque(const std::deque<_Tp,_Alloc>&) [with _Tp = st_join_table*,_Alloc = std::allocator<st_join_table*>,std::deque<_Tp,_Alloc> = std::deque<st_join_table*,std::allocator<st_join_table*> >]" -> "_Alloc>::size() const [with _Tp = st_join_table*,_Alloc = std::allocator<st_join_table*>,std::deque<_Tp,_Alloc>::size_type = long unsigned int]"
"_Alloc>::deque(const std::deque<_Tp,_Alloc>&) [with _Tp = st_join_table*,_Alloc = std::allocator<st_join_table*>,std::deque<_Tp,_Alloc> = std::deque<st_join_table*,std::allocator<st_join_table*> >]" -> "_Alloc>::_Deque_base(const allocator_type&,std::size_t) [with _Tp = st_join_table*,_Alloc = std::allocator<st_join_table*>,std::_Deque_base<_Tp,_Alloc>::allocator_type = std::allocator<st_join_table*>,std::size_t = long unsigned int]"
"_Alloc>::deque(const std::deque<_Tp,_Alloc>&) [with _Tp = st_join_table*,_Alloc = std::allocator<st_join_table*>,std::deque<_Tp,_Alloc> = std::deque<st_join_table*,std::allocator<st_join_table*> >]" -> "std::__uninitialized_copy_a(_InputIterator,_InputIterator,_ForwardIterator,std::allocator<_Tp>&) [with _InputIterator = std::_Deque_iterator<st_join_table*,st_join_table* const&,st_join_table* const*>,_ForwardIterator = std::_Deque_iterator<st_join_table*,st_join_table*&,st_join_table**>,_Tp = st_join_table*]"
"_Alloc>::end() const [with _Tp = st_join_table*,_Alloc = std::allocator<st_join_table*>,std::deque<_Tp,_Alloc>::const_iterator = std::_Deque_iterator<st_join_table*,st_join_table* const&,st_join_table* const*>]" -> "_Ptr>::_Deque_iterator(const iterator&) [with _Tp = st_join_table*,_Ref = st_join_table* const&,_Ptr = st_join_table* const*,std::_Deque_iterator<_Tp,_Ref,_Ptr>::iterator = std::_Deque_iterator<st_join_table*,st_join_table*&,st_join_table**>]"
"_Alloc>::begin() const [with _Tp = st_join_table*,_Alloc = std::allocator<st_join_table*>,std::deque<_Tp,_Alloc>::const_iterator = std::_Deque_iterator<st_join_table*,st_join_table* const&,st_join_table* const*>]" -> "_Ptr>::_Deque_iterator(const iterator&) [with _Tp = st_join_table*,_Ref = st_join_table* const&,_Ptr = st_join_table* const*,std::_Deque_iterator<_Tp,_Ref,_Ptr>::iterator = std::_Deque_iterator<st_join_table*,st_join_table*&,st_join_table**>]"
"_Alloc>::size() const [with _Tp = st_join_table*,_Alloc = std::allocator<st_join_table*>,std::deque<_Tp,_Alloc>::size_type = long unsigned int]" -> "std::operator-(const std::_Deque_iterator<_Tp,_Ref,_Ptr>&,const std::_Deque_iterator<_Tp,_Ref,_Ptr>&) [with _Tp = st_join_table*,_Ref = st_join_table*&,_Ptr = st_join_table**,typename std::_Deque_iterator<_Tp,_Ref,_Ptr>::difference_type = long int]"
"std::operator-(const std::_Deque_iterator<_Tp,_Ref,_Ptr>&,const std::_Deque_iterator<_Tp,_Ref,_Ptr>&) [with _Tp = st_join_table*,_Ref = st_join_table*&,_Ptr = st_join_table**,typename std::_Deque_iterator<_Tp,_Ref,_Ptr>::difference_type = long int]" -> "_Ptr>::_S_buffer_size() [with _Tp = st_join_table*,_Ref = st_join_table*&,_Ptr = st_join_table**,std::size_t = long unsigned int]"
"_Ptr>::_S_buffer_size() [with _Tp = st_join_table*,_Ref = st_join_table*&,_Ptr = st_join_table**,std::size_t = long unsigned int]" -> "std::__deque_buf_size(std::size_t)"
"_Alloc>::_Deque_base(const allocator_type&,std::size_t) [with _Tp = st_join_table*,_Alloc = std::allocator<st_join_table*>,std::_Deque_base<_Tp,_Alloc>::allocator_type = std::allocator<st_join_table*>,std::size_t = long unsigned int]" -> "_Alloc>::_M_initialize_map(std::size_t) [with _Tp = st_join_table*,_Alloc = std::allocator<st_join_table*>,std::size_t = long unsigned int]"
"_Alloc>::_Deque_base(const allocator_type&,std::size_t) [with _Tp = st_join_table*,_Alloc = std::allocator<st_join_table*>,std::_Deque_base<_Tp,_Alloc>::allocator_type = std::allocator<st_join_table*>,std::size_t = long unsigned int]" -> "_Alloc>::_Deque_impl::_Deque_impl(const _Tp_alloc_type&) [with _Tp = st_join_table*,_Alloc = std::allocator<st_join_table*>,std::_Deque_base<_Tp,_Alloc>::_Tp_alloc_type = std::allocator<st_join_table*>]"
"_Alloc>::_M_initialize_map(std::size_t) [with _Tp = st_join_table*,_Alloc = std::allocator<st_join_table*>,std::size_t = long unsigned int]" -> "std::max(const _Tp&,const _Tp&) [with _Tp = long unsigned int]"
"_Alloc>::_M_initialize_map(std::size_t) [with _Tp = st_join_table*,_Alloc = std::allocator<st_join_table*>,std::size_t = long unsigned int]" -> "__cxa_rethrow()"
"_Alloc>::_M_initialize_map(std::size_t) [with _Tp = st_join_table*,_Alloc = std::allocator<st_join_table*>,std::size_t = long unsigned int]" -> "__builtin_eh_pointer(int)"
"_Alloc>::_M_initialize_map(std::size_t) [with _Tp = st_join_table*,_Alloc = std::allocator<st_join_table*>,std::size_t = long unsigned int]" -> "__cxa_begin_catch(void*)"
"_Alloc>::_M_initialize_map(std::size_t) [with _Tp = st_join_table*,_Alloc = std::allocator<st_join_table*>,std::size_t = long unsigned int]" -> "_Alloc>::_M_create_nodes(_Tp**,_Tp**) [with _Tp = st_join_table*,_Alloc = std::allocator<st_join_table*>]"
"_Alloc>::_M_initialize_map(std::size_t) [with _Tp = st_join_table*,_Alloc = std::allocator<st_join_table*>,std::size_t = long unsigned int]" -> "__cxa_end_catch()"
"_Alloc>::_M_initialize_map(std::size_t) [with _Tp = st_join_table*,_Alloc = std::allocator<st_join_table*>,std::size_t = long unsigned int]" -> "_Ptr>::_M_set_node(std::_Deque_iterator<_Tp,_Ref,_Ptr>::_Map_pointer) [with _Tp = st_join_table*,_Ref = st_join_table*&,_Ptr = st_join_table**,std::_Deque_iterator<_Tp,_Ref,_Ptr>::_Map_pointer = st_join_table***]"
"_Alloc>::_M_initialize_map(std::size_t) [with _Tp = st_join_table*,_Alloc = std::allocator<st_join_table*>,std::size_t = long unsigned int]" -> "_Alloc>::_M_allocate_map(std::size_t) [with _Tp = st_join_table*,_Alloc = std::allocator<st_join_table*>,std::size_t = long unsigned int]"
"_Alloc>::_M_initialize_map(std::size_t) [with _Tp = st_join_table*,_Alloc = std::allocator<st_join_table*>,std::size_t = long unsigned int]" -> "std::__deque_buf_size(std::size_t)"
"_Alloc>::_M_initialize_map(std::size_t) [with _Tp = st_join_table*,_Alloc = std::allocator<st_join_table*>,std::size_t = long unsigned int]" -> "_Alloc>::_M_deallocate_map(_Tp**,std::size_t) [with _Tp = st_join_table*,_Alloc = std::allocator<st_join_table*>,std::size_t = long unsigned int]"
"_Alloc>::_M_create_nodes(_Tp**,_Tp**) [with _Tp = st_join_table*,_Alloc = std::allocator<st_join_table*>]" -> "__cxa_begin_catch(void*)"
"_Alloc>::_M_create_nodes(_Tp**,_Tp**) [with _Tp = st_join_table*,_Alloc = std::allocator<st_join_table*>]" -> "_Alloc>::_M_destroy_nodes(_Tp**,_Tp**) [with _Tp = st_join_table*,_Alloc = std::allocator<st_join_table*>]"
"_Alloc>::_M_create_nodes(_Tp**,_Tp**) [with _Tp = st_join_table*,_Alloc = std::allocator<st_join_table*>]" -> "__cxa_rethrow()"
"_Alloc>::_M_create_nodes(_Tp**,_Tp**) [with _Tp = st_join_table*,_Alloc = std::allocator<st_join_table*>]" -> "_Alloc>::_M_allocate_node() [with _Tp = st_join_table*,_Alloc = std::allocator<st_join_table*>]"
"_Alloc>::_M_create_nodes(_Tp**,_Tp**) [with _Tp = st_join_table*,_Alloc = std::allocator<st_join_table*>]" -> "__cxa_end_catch()"
"_Alloc>::_M_create_nodes(_Tp**,_Tp**) [with _Tp = st_join_table*,_Alloc = std::allocator<st_join_table*>]" -> "__builtin_eh_pointer(int)"
"_Alloc>::_M_destroy_nodes(_Tp**,_Tp**) [with _Tp = st_join_table*,_Alloc = std::allocator<st_join_table*>]" -> "_Alloc>::_M_deallocate_node(_Tp*) [with _Tp = st_join_table*,_Alloc = std::allocator<st_join_table*>]"
"_Alloc>::_M_deallocate_node(_Tp*) [with _Tp = st_join_table*,_Alloc = std::allocator<st_join_table*>]" -> "std::__deque_buf_size(std::size_t)"
"_Alloc>::_M_deallocate_node(_Tp*) [with _Tp = st_join_table*,_Alloc = std::allocator<st_join_table*>]" -> "__gnu_cxx::new_allocator<_Tp>::deallocate(__gnu_cxx::new_allocator<_Tp>::pointer,__gnu_cxx::new_allocator<_Tp>::size_type) [with _Tp = st_join_table*,__gnu_cxx::new_allocator<_Tp>::pointer = st_join_table**,__gnu_cxx::new_allocator<_Tp>::size_type = long unsigned int]"
"_Alloc>::_M_allocate_node() [with _Tp = st_join_table*,_Alloc = std::allocator<st_join_table*>]" -> "std::__deque_buf_size(std::size_t)"
"_Alloc>::_M_allocate_node() [with _Tp = st_join_table*,_Alloc = std::allocator<st_join_table*>]" -> "__gnu_cxx::new_allocator<_Tp>::allocate(__gnu_cxx::new_allocator<_Tp>::size_type,const void*) [with _Tp = st_join_table*,__gnu_cxx::new_allocator<_Tp>::pointer = st_join_table**,__gnu_cxx::new_allocator<_Tp>::size_type = long unsigned int]"
"__gnu_cxx::new_allocator<_Tp>::allocate(__gnu_cxx::new_allocator<_Tp>::size_type,const void*) [with _Tp = st_join_table*,__gnu_cxx::new_allocator<_Tp>::pointer = st_join_table**,__gnu_cxx::new_allocator<_Tp>::size_type = long unsigned int]" -> "__gnu_cxx::new_allocator<_Tp>::max_size() const [with _Tp = st_join_table*,__gnu_cxx::new_allocator<_Tp>::size_type = long unsigned int]"
"__gnu_cxx::new_allocator<_Tp>::allocate(__gnu_cxx::new_allocator<_Tp>::size_type,const void*) [with _Tp = st_join_table*,__gnu_cxx::new_allocator<_Tp>::pointer = st_join_table**,__gnu_cxx::new_allocator<_Tp>::size_type = long unsigned int]" -> "std::__throw_bad_alloc()"
"_Ptr>::_M_set_node(std::_Deque_iterator<_Tp,_Ref,_Ptr>::_Map_pointer) [with _Tp = st_join_table*,_Ref = st_join_table*&,_Ptr = st_join_table**,std::_Deque_iterator<_Tp,_Ref,_Ptr>::_Map_pointer = st_join_table***]" -> "_Ptr>::_S_buffer_size() [with _Tp = st_join_table*,_Ref = st_join_table*&,_Ptr = st_join_table**,std::size_t = long unsigned int]"
"_Alloc>::_M_allocate_map(std::size_t) [with _Tp = st_join_table*,_Alloc = std::allocator<st_join_table*>,std::size_t = long unsigned int]" -> "__gnu_cxx::new_allocator<_Tp>::allocate(__gnu_cxx::new_allocator<_Tp>::size_type,const void*) [with _Tp = st_join_table**,__gnu_cxx::new_allocator<_Tp>::pointer = st_join_table***,__gnu_cxx::new_allocator<_Tp>::size_type = long unsigned int]"
"_Alloc>::_M_allocate_map(std::size_t) [with _Tp = st_join_table*,_Alloc = std::allocator<st_join_table*>,std::size_t = long unsigned int]" -> "_Alloc>::_M_get_map_allocator() const [with _Tp = st_join_table*,_Alloc = std::allocator<st_join_table*>,std::_Deque_base<_Tp,_Alloc>::_Map_alloc_type = std::allocator<st_join_table**>]"
"__gnu_cxx::new_allocator<_Tp>::allocate(__gnu_cxx::new_allocator<_Tp>::size_type,const void*) [with _Tp = st_join_table**,__gnu_cxx::new_allocator<_Tp>::pointer = st_join_table***,__gnu_cxx::new_allocator<_Tp>::size_type = long unsigned int]" -> "__gnu_cxx::new_allocator<_Tp>::max_size() const [with _Tp = st_join_table**,__gnu_cxx::new_allocator<_Tp>::size_type = long unsigned int]"
"__gnu_cxx::new_allocator<_Tp>::allocate(__gnu_cxx::new_allocator<_Tp>::size_type,const void*) [with _Tp = st_join_table**,__gnu_cxx::new_allocator<_Tp>::pointer = st_join_table***,__gnu_cxx::new_allocator<_Tp>::size_type = long unsigned int]" -> "std::__throw_bad_alloc()"
"_Alloc>::_M_get_map_allocator() const [with _Tp = st_join_table*,_Alloc = std::allocator<st_join_table*>,std::_Deque_base<_Tp,_Alloc>::_Map_alloc_type = std::allocator<st_join_table**>]" -> "_Alloc>::_M_get_Tp_allocator() const [with _Tp = st_join_table*,_Alloc = std::allocator<st_join_table*>,std::_Deque_base<_Tp,_Alloc>::_Tp_alloc_type = std::allocator<st_join_table*>]"
"_Alloc>::_M_get_map_allocator() const [with _Tp = st_join_table*,_Alloc = std::allocator<st_join_table*>,std::_Deque_base<_Tp,_Alloc>::_Map_alloc_type = std::allocator<st_join_table**>]" -> "std::allocator<_Tp>::allocator(const std::allocator<_Tp1>&) [with _Tp1 = st_join_table*,_Tp = st_join_table**]"
"std::allocator<_Tp>::allocator(const std::allocator<_Tp1>&) [with _Tp1 = st_join_table*,_Tp = st_join_table**]" -> "__gnu_cxx::new_allocator<_Tp>::new_allocator() [with _Tp = st_join_table**]"
"_Alloc>::_M_deallocate_map(_Tp**,std::size_t) [with _Tp = st_join_table*,_Alloc = std::allocator<st_join_table*>,std::size_t = long unsigned int]" -> "__gnu_cxx::new_allocator<_Tp>::deallocate(__gnu_cxx::new_allocator<_Tp>::pointer,__gnu_cxx::new_allocator<_Tp>::size_type) [with _Tp = st_join_table**,__gnu_cxx::new_allocator<_Tp>::pointer = st_join_table***,__gnu_cxx::new_allocator<_Tp>::size_type = long unsigned int]"
"_Alloc>::_M_deallocate_map(_Tp**,std::size_t) [with _Tp = st_join_table*,_Alloc = std::allocator<st_join_table*>,std::size_t = long unsigned int]" -> "_Alloc>::_M_get_map_allocator() const [with _Tp = st_join_table*,_Alloc = std::allocator<st_join_table*>,std::_Deque_base<_Tp,_Alloc>::_Map_alloc_type = std::allocator<st_join_table**>]"
"_Alloc>::_Deque_impl::_Deque_impl(const _Tp_alloc_type&) [with _Tp = st_join_table*,_Alloc = std::allocator<st_join_table*>,std::_Deque_base<_Tp,_Alloc>::_Tp_alloc_type = std::allocator<st_join_table*>]" -> "std::allocator<_Tp>::allocator(const std::allocator<_Tp>&) [with _Tp = st_join_table*,std::allocator<_Tp> = std::allocator<st_join_table*>]"
"_Alloc>::_Deque_impl::_Deque_impl(const _Tp_alloc_type&) [with _Tp = st_join_table*,_Alloc = std::allocator<st_join_table*>,std::_Deque_base<_Tp,_Alloc>::_Tp_alloc_type = std::allocator<st_join_table*>]" -> "_Ptr>::_Deque_iterator() [with _Tp = st_join_table*,_Ref = st_join_table*&,_Ptr = st_join_table**]"
"std::allocator<_Tp>::allocator(const std::allocator<_Tp>&) [with _Tp = st_join_table*,std::allocator<_Tp> = std::allocator<st_join_table*>]" -> "__gnu_cxx::new_allocator<_Tp>::new_allocator(const __gnu_cxx::new_allocator<_Tp>&) [with _Tp = st_join_table*,__gnu_cxx::new_allocator<_Tp> = __gnu_cxx::new_allocator<st_join_table*>]"
"std::__uninitialized_copy_a(_InputIterator,_InputIterator,_ForwardIterator,std::allocator<_Tp>&) [with _InputIterator = std::_Deque_iterator<st_join_table*,st_join_table* const&,st_join_table* const*>,_ForwardIterator = std::_Deque_iterator<st_join_table*,st_join_table*&,st_join_table**>,_Tp = st_join_table*]" -> "_Ptr>::_Deque_iterator(const iterator&) [with _Tp = st_join_table*,_Ref = st_join_table*&,_Ptr = st_join_table**,std::_Deque_iterator<_Tp,_Ref,_Ptr>::iterator = std::_Deque_iterator<st_join_table*,st_join_table*&,st_join_table**>]"
"std::__uninitialized_copy_a(_InputIterator,_InputIterator,_ForwardIterator,std::allocator<_Tp>&) [with _InputIterator = std::_Deque_iterator<st_join_table*,st_join_table* const&,st_join_table* const*>,_ForwardIterator = std::_Deque_iterator<st_join_table*,st_join_table*&,st_join_table**>,_Tp = st_join_table*]" -> "std::uninitialized_copy(_InputIterator,_InputIterator,_ForwardIterator) [with _InputIterator = std::_Deque_iterator<st_join_table*,st_join_table* const&,st_join_table* const*>,_ForwardIterator = std::_Deque_iterator<st_join_table*,st_join_table*&,st_join_table**>]"
"std::uninitialized_copy(_InputIterator,_InputIterator,_ForwardIterator) [with _InputIterator = std::_Deque_iterator<st_join_table*,st_join_table* const&,st_join_table* const*>,_ForwardIterator = std::_Deque_iterator<st_join_table*,st_join_table*&,st_join_table**>]" -> "_Ptr>::_Deque_iterator(const iterator&) [with _Tp = st_join_table*,_Ref = st_join_table*&,_Ptr = st_join_table**,std::_Deque_iterator<_Tp,_Ref,_Ptr>::iterator = std::_Deque_iterator<st_join_table*,st_join_table*&,st_join_table**>]"
"std::uninitialized_copy(_InputIterator,_InputIterator,_ForwardIterator) [with _InputIterator = std::_Deque_iterator<st_join_table*,st_join_table* const&,st_join_table* const*>,_ForwardIterator = std::_Deque_iterator<st_join_table*,st_join_table*&,st_join_table**>]" -> "std::__uninitialized_copy<true>::__uninit_copy(_InputIterator,_InputIterator,_ForwardIterator) [with _InputIterator = std::_Deque_iterator<st_join_table*,st_join_table* const&,st_join_table* const*>,_ForwardIterator = std::_Deque_iterator<st_join_table*,st_join_table*&,st_join_table**>]"
"std::__uninitialized_copy<true>::__uninit_copy(_InputIterator,_InputIterator,_ForwardIterator) [with _InputIterator = std::_Deque_iterator<st_join_table*,st_join_table* const&,st_join_table* const*>,_ForwardIterator = std::_Deque_iterator<st_join_table*,st_join_table*&,st_join_table**>]" -> "_Ptr>::_Deque_iterator(const iterator&) [with _Tp = st_join_table*,_Ref = st_join_table*&,_Ptr = st_join_table**,std::_Deque_iterator<_Tp,_Ref,_Ptr>::iterator = std::_Deque_iterator<st_join_table*,st_join_table*&,st_join_table**>]"
"std::__uninitialized_copy<true>::__uninit_copy(_InputIterator,_InputIterator,_ForwardIterator) [with _InputIterator = std::_Deque_iterator<st_join_table*,st_join_table* const&,st_join_table* const*>,_ForwardIterator = std::_Deque_iterator<st_join_table*,st_join_table*&,st_join_table**>]" -> "std::copy(_II,_II,_OI) [with _II = std::_Deque_iterator<st_join_table*,st_join_table* const&,st_join_table* const*>,_OI = std::_Deque_iterator<st_join_table*,st_join_table*&,st_join_table**>]"
"std::copy(_II,_II,_OI) [with _II = std::_Deque_iterator<st_join_table*,st_join_table* const&,st_join_table* const*>,_OI = std::_Deque_iterator<st_join_table*,st_join_table*&,st_join_table**>]" -> "std::__copy_move_a2(_II,_II,_OI) [with bool _IsMove = false,_II = std::_Deque_iterator<st_join_table*,st_join_table* const&,st_join_table* const*>,_OI = std::_Deque_iterator<st_join_table*,st_join_table*&,st_join_table**>]"
"std::copy(_II,_II,_OI) [with _II = std::_Deque_iterator<st_join_table*,st_join_table* const&,st_join_table* const*>,_OI = std::_Deque_iterator<st_join_table*,st_join_table*&,st_join_table**>]" -> "std::__miter_base(_Iterator) [with _Iterator = std::_Deque_iterator<st_join_table*,st_join_table* const&,st_join_table* const*>,typename std::_Miter_base<_Iterator>::iterator_type = std::_Deque_iterator<st_join_table*,st_join_table* const&,st_join_table* const*>]"
"std::copy(_II,_II,_OI) [with _II = std::_Deque_iterator<st_join_table*,st_join_table* const&,st_join_table* const*>,_OI = std::_Deque_iterator<st_join_table*,st_join_table*&,st_join_table**>]" -> "_Ptr>::_Deque_iterator(const iterator&) [with _Tp = st_join_table*,_Ref = st_join_table*&,_Ptr = st_join_table**,std::_Deque_iterator<_Tp,_Ref,_Ptr>::iterator = std::_Deque_iterator<st_join_table*,st_join_table*&,st_join_table**>]"
"std::__copy_move_a2(_II,_II,_OI) [with bool _IsMove = false,_II = std::_Deque_iterator<st_join_table*,st_join_table* const&,st_join_table* const*>,_OI = std::_Deque_iterator<st_join_table*,st_join_table*&,st_join_table**>]" -> "std::__niter_base(_Iterator) [with _Iterator = std::_Deque_iterator<st_join_table*,st_join_table*&,st_join_table**>,typename std::_Niter_base<_Iterator>::iterator_type = std::_Deque_iterator<st_join_table*,st_join_table*&,st_join_table**>]"
"std::__copy_move_a2(_II,_II,_OI) [with bool _IsMove = false,_II = std::_Deque_iterator<st_join_table*,st_join_table* const&,st_join_table* const*>,_OI = std::_Deque_iterator<st_join_table*,st_join_table*&,st_join_table**>]" -> "std::__niter_base(_Iterator) [with _Iterator = std::_Deque_iterator<st_join_table*,st_join_table* const&,st_join_table* const*>,typename std::_Niter_base<_Iterator>::iterator_type = std::_Deque_iterator<st_join_table*,st_join_table* const&,st_join_table* const*>]"
"std::__copy_move_a2(_II,_II,_OI) [with bool _IsMove = false,_II = std::_Deque_iterator<st_join_table*,st_join_table* const&,st_join_table* const*>,_OI = std::_Deque_iterator<st_join_table*,st_join_table*&,st_join_table**>]" -> "std::__copy_move_a(_II,_II,_OI) [with bool _IsMove = false,_II = std::_Deque_iterator<st_join_table*,st_join_table* const&,st_join_table* const*>,_OI = std::_Deque_iterator<st_join_table*,st_join_table*&,st_join_table**>]"
"std::__copy_move_a2(_II,_II,_OI) [with bool _IsMove = false,_II = std::_Deque_iterator<st_join_table*,st_join_table* const&,st_join_table* const*>,_OI = std::_Deque_iterator<st_join_table*,st_join_table*&,st_join_table**>]" -> "_Ptr>::_Deque_iterator(const iterator&) [with _Tp = st_join_table*,_Ref = st_join_table*&,_Ptr = st_join_table**,std::_Deque_iterator<_Tp,_Ref,_Ptr>::iterator = std::_Deque_iterator<st_join_table*,st_join_table*&,st_join_table**>]"
"std::__niter_base(_Iterator) [with _Iterator = std::_Deque_iterator<st_join_table*,st_join_table*&,st_join_table**>,typename std::_Niter_base<_Iterator>::iterator_type = std::_Deque_iterator<st_join_table*,st_join_table*&,st_join_table**>]" -> "_Ptr>::_Deque_iterator(const iterator&) [with _Tp = st_join_table*,_Ref = st_join_table*&,_Ptr = st_join_table**,std::_Deque_iterator<_Tp,_Ref,_Ptr>::iterator = std::_Deque_iterator<st_join_table*,st_join_table*&,st_join_table**>]"
"std::__niter_base(_Iterator) [with _Iterator = std::_Deque_iterator<st_join_table*,st_join_table*&,st_join_table**>,typename std::_Niter_base<_Iterator>::iterator_type = std::_Deque_iterator<st_join_table*,st_join_table*&,st_join_table**>]" -> "_HasBase>::_S_base(_Iterator) [with _Iterator = std::_Deque_iterator<st_join_table*,st_join_table*&,st_join_table**>,bool _HasBase = false,std::_Iter_base<_Iterator,_HasBase>::iterator_type = std::_Deque_iterator<st_join_table*,st_join_table*&,st_join_table**>]"
"_HasBase>::_S_base(_Iterator) [with _Iterator = std::_Deque_iterator<st_join_table*,st_join_table*&,st_join_table**>,bool _HasBase = false,std::_Iter_base<_Iterator,_HasBase>::iterator_type = std::_Deque_iterator<st_join_table*,st_join_table*&,st_join_table**>]" -> "_Ptr>::_Deque_iterator(const iterator&) [with _Tp = st_join_table*,_Ref = st_join_table*&,_Ptr = st_join_table**,std::_Deque_iterator<_Tp,_Ref,_Ptr>::iterator = std::_Deque_iterator<st_join_table*,st_join_table*&,st_join_table**>]"
"std::__niter_base(_Iterator) [with _Iterator = std::_Deque_iterator<st_join_table*,st_join_table* const&,st_join_table* const*>,typename std::_Niter_base<_Iterator>::iterator_type = std::_Deque_iterator<st_join_table*,st_join_table* const&,st_join_table* const*>]" -> "_HasBase>::_S_base(_Iterator) [with _Iterator = std::_Deque_iterator<st_join_table*,st_join_table* const&,st_join_table* const*>,bool _HasBase = false,std::_Iter_base<_Iterator,_HasBase>::iterator_type = std::_Deque_iterator<st_join_table*,st_join_table* const&,st_join_table* const*>]"
"std::__copy_move_a(_II,_II,_OI) [with bool _IsMove = false,_II = std::_Deque_iterator<st_join_table*,st_join_table* const&,st_join_table* const*>,_OI = std::_Deque_iterator<st_join_table*,st_join_table*&,st_join_table**>]" -> "_Ptr>::_Deque_iterator(const iterator&) [with _Tp = st_join_table*,_Ref = st_join_table*&,_Ptr = st_join_table**,std::_Deque_iterator<_Tp,_Ref,_Ptr>::iterator = std::_Deque_iterator<st_join_table*,st_join_table*&,st_join_table**>]"
"std::__copy_move_a(_II,_II,_OI) [with bool _IsMove = false,_II = std::_Deque_iterator<st_join_table*,st_join_table* const&,st_join_table* const*>,_OI = std::_Deque_iterator<st_join_table*,st_join_table*&,st_join_table**>]" -> "std::random_access_iterator_tag>::__copy_m(_II,_II,_OI) [with _II = std::_Deque_iterator<st_join_table*,st_join_table* const&,st_join_table* const*>,_OI = std::_Deque_iterator<st_join_table*,st_join_table*&,st_join_table**>]"
"std::random_access_iterator_tag>::__copy_m(_II,_II,_OI) [with _II = std::_Deque_iterator<st_join_table*,st_join_table* const&,st_join_table* const*>,_OI = std::_Deque_iterator<st_join_table*,st_join_table*&,st_join_table**>]" -> "_Ptr>::operator++() [with _Tp = st_join_table*,_Ref = st_join_table*&,_Ptr = st_join_table**,std::_Deque_iterator<_Tp,_Ref,_Ptr>::_Self = std::_Deque_iterator<st_join_table*,st_join_table*&,st_join_table**>]"
"std::random_access_iterator_tag>::__copy_m(_II,_II,_OI) [with _II = std::_Deque_iterator<st_join_table*,st_join_table* const&,st_join_table* const*>,_OI = std::_Deque_iterator<st_join_table*,st_join_table*&,st_join_table**>]" -> "std::operator-(const std::_Deque_iterator<_Tp,_Ref,_Ptr>&,const std::_Deque_iterator<_Tp,_Ref,_Ptr>&) [with _Tp = st_join_table*,_Ref = st_join_table* const&,_Ptr = st_join_table* const*,typename std::_Deque_iterator<_Tp,_Ref,_Ptr>::difference_type = long int]"
"std::random_access_iterator_tag>::__copy_m(_II,_II,_OI) [with _II = std::_Deque_iterator<st_join_table*,st_join_table* const&,st_join_table* const*>,_OI = std::_Deque_iterator<st_join_table*,st_join_table*&,st_join_table**>]" -> "_Ptr>::operator++() [with _Tp = st_join_table*,_Ref = st_join_table* const&,_Ptr = st_join_table* const*,std::_Deque_iterator<_Tp,_Ref,_Ptr>::_Self = std::_Deque_iterator<st_join_table*,st_join_table* const&,st_join_table* const*>]"
"std::random_access_iterator_tag>::__copy_m(_II,_II,_OI) [with _II = std::_Deque_iterator<st_join_table*,st_join_table* const&,st_join_table* const*>,_OI = std::_Deque_iterator<st_join_table*,st_join_table*&,st_join_table**>]" -> "_Ptr>::operator*() const [with _Tp = st_join_table*,_Ref = st_join_table* const&,_Ptr = st_join_table* const*,std::_Deque_iterator<_Tp,_Ref,_Ptr>::reference = st_join_table* const&]"
"std::random_access_iterator_tag>::__copy_m(_II,_II,_OI) [with _II = std::_Deque_iterator<st_join_table*,st_join_table* const&,st_join_table* const*>,_OI = std::_Deque_iterator<st_join_table*,st_join_table*&,st_join_table**>]" -> "_Ptr>::operator*() const [with _Tp = st_join_table*,_Ref = st_join_table*&,_Ptr = st_join_table**,std::_Deque_iterator<_Tp,_Ref,_Ptr>::reference = st_join_table*&]"
"std::random_access_iterator_tag>::__copy_m(_II,_II,_OI) [with _II = std::_Deque_iterator<st_join_table*,st_join_table* const&,st_join_table* const*>,_OI = std::_Deque_iterator<st_join_table*,st_join_table*&,st_join_table**>]" -> "_Ptr>::_Deque_iterator(const iterator&) [with _Tp = st_join_table*,_Ref = st_join_table*&,_Ptr = st_join_table**,std::_Deque_iterator<_Tp,_Ref,_Ptr>::iterator = std::_Deque_iterator<st_join_table*,st_join_table*&,st_join_table**>]"
"_Ptr>::operator++() [with _Tp = st_join_table*,_Ref = st_join_table*&,_Ptr = st_join_table**,std::_Deque_iterator<_Tp,_Ref,_Ptr>::_Self = std::_Deque_iterator<st_join_table*,st_join_table*&,st_join_table**>]" -> "_Ptr>::_M_set_node(std::_Deque_iterator<_Tp,_Ref,_Ptr>::_Map_pointer) [with _Tp = st_join_table*,_Ref = st_join_table*&,_Ptr = st_join_table**,std::_Deque_iterator<_Tp,_Ref,_Ptr>::_Map_pointer = st_join_table***]"
"std::operator-(const std::_Deque_iterator<_Tp,_Ref,_Ptr>&,const std::_Deque_iterator<_Tp,_Ref,_Ptr>&) [with _Tp = st_join_table*,_Ref = st_join_table* const&,_Ptr = st_join_table* const*,typename std::_Deque_iterator<_Tp,_Ref,_Ptr>::difference_type = long int]" -> "_Ptr>::_S_buffer_size() [with _Tp = st_join_table*,_Ref = st_join_table* const&,_Ptr = st_join_table* const*,std::size_t = long unsigned int]"
"_Ptr>::_S_buffer_size() [with _Tp = st_join_table*,_Ref = st_join_table* const&,_Ptr = st_join_table* const*,std::size_t = long unsigned int]" -> "std::__deque_buf_size(std::size_t)"
"_Ptr>::operator++() [with _Tp = st_join_table*,_Ref = st_join_table* const&,_Ptr = st_join_table* const*,std::_Deque_iterator<_Tp,_Ref,_Ptr>::_Self = std::_Deque_iterator<st_join_table*,st_join_table* const&,st_join_table* const*>]" -> "_Ptr>::_M_set_node(std::_Deque_iterator<_Tp,_Ref,_Ptr>::_Map_pointer) [with _Tp = st_join_table*,_Ref = st_join_table* const&,_Ptr = st_join_table* const*,std::_Deque_iterator<_Tp,_Ref,_Ptr>::_Map_pointer = st_join_table***]"
"_Ptr>::_M_set_node(std::_Deque_iterator<_Tp,_Ref,_Ptr>::_Map_pointer) [with _Tp = st_join_table*,_Ref = st_join_table* const&,_Ptr = st_join_table* const*,std::_Deque_iterator<_Tp,_Ref,_Ptr>::_Map_pointer = st_join_table***]" -> "_Ptr>::_S_buffer_size() [with _Tp = st_join_table*,_Ref = st_join_table* const&,_Ptr = st_join_table* const*,std::size_t = long unsigned int]"
"std::__miter_base(_Iterator) [with _Iterator = std::_Deque_iterator<st_join_table*,st_join_table* const&,st_join_table* const*>,typename std::_Miter_base<_Iterator>::iterator_type = std::_Deque_iterator<st_join_table*,st_join_table* const&,st_join_table* const*>]" -> "_HasBase>::_S_base(_Iterator) [with _Iterator = std::_Deque_iterator<st_join_table*,st_join_table* const&,st_join_table* const*>,bool _HasBase = false,std::_Iter_base<_Iterator,_HasBase>::iterator_type = std::_Deque_iterator<st_join_table*,st_join_table* const&,st_join_table* const*>]"
"_Sequence>::push(const value_type&) [with _Tp = st_join_table*,_Sequence = std::deque<st_join_table*,std::allocator<st_join_table*> >,std::queue<_Tp,_Sequence>::value_type = st_join_table*]" -> "_Alloc>::push_back(const value_type&) [with _Tp = st_join_table*,_Alloc = std::allocator<st_join_table*>,std::deque<_Tp,_Alloc>::value_type = st_join_table*]"
"_Alloc>::push_back(const value_type&) [with _Tp = st_join_table*,_Alloc = std::allocator<st_join_table*>,std::deque<_Tp,_Alloc>::value_type = st_join_table*]" -> "_Alloc>::_M_push_back_aux(const value_type&) [with _Tp = st_join_table*,_Alloc = std::allocator<st_join_table*>,std::deque<_Tp,_Alloc>::value_type = st_join_table*]"
"_Alloc>::push_back(const value_type&) [with _Tp = st_join_table*,_Alloc = std::allocator<st_join_table*>,std::deque<_Tp,_Alloc>::value_type = st_join_table*]" -> "__gnu_cxx::new_allocator<_Tp>::construct(__gnu_cxx::new_allocator<_Tp>::pointer,const _Tp&) [with _Tp = st_join_table*,__gnu_cxx::new_allocator<_Tp>::pointer = st_join_table**]"
"_Alloc>::_M_push_back_aux(const value_type&) [with _Tp = st_join_table*,_Alloc = std::allocator<st_join_table*>,std::deque<_Tp,_Alloc>::value_type = st_join_table*]" -> "_Ptr>::_M_set_node(std::_Deque_iterator<_Tp,_Ref,_Ptr>::_Map_pointer) [with _Tp = st_join_table*,_Ref = st_join_table*&,_Ptr = st_join_table**,std::_Deque_iterator<_Tp,_Ref,_Ptr>::_Map_pointer = st_join_table***]"
"_Alloc>::_M_push_back_aux(const value_type&) [with _Tp = st_join_table*,_Alloc = std::allocator<st_join_table*>,std::deque<_Tp,_Alloc>::value_type = st_join_table*]" -> "__cxa_rethrow()"
"_Alloc>::_M_push_back_aux(const value_type&) [with _Tp = st_join_table*,_Alloc = std::allocator<st_join_table*>,std::deque<_Tp,_Alloc>::value_type = st_join_table*]" -> "__builtin_eh_pointer(int)"
"_Alloc>::_M_push_back_aux(const value_type&) [with _Tp = st_join_table*,_Alloc = std::allocator<st_join_table*>,std::deque<_Tp,_Alloc>::value_type = st_join_table*]" -> "__gnu_cxx::new_allocator<_Tp>::construct(__gnu_cxx::new_allocator<_Tp>::pointer,const _Tp&) [with _Tp = st_join_table*,__gnu_cxx::new_allocator<_Tp>::pointer = st_join_table**]"
"_Alloc>::_M_push_back_aux(const value_type&) [with _Tp = st_join_table*,_Alloc = std::allocator<st_join_table*>,std::deque<_Tp,_Alloc>::value_type = st_join_table*]" -> "__cxa_end_catch()"
"_Alloc>::_M_push_back_aux(const value_type&) [with _Tp = st_join_table*,_Alloc = std::allocator<st_join_table*>,std::deque<_Tp,_Alloc>::value_type = st_join_table*]" -> "_Alloc>::_M_reserve_map_at_back(std::deque<_Tp,_Alloc>::size_type) [with _Tp = st_join_table*,_Alloc = std::allocator<st_join_table*>,std::deque<_Tp,_Alloc>::size_type = long unsigned int]"
"_Alloc>::_M_push_back_aux(const value_type&) [with _Tp = st_join_table*,_Alloc = std::allocator<st_join_table*>,std::deque<_Tp,_Alloc>::value_type = st_join_table*]" -> "_Alloc>::_M_deallocate_node(_Tp*) [with _Tp = st_join_table*,_Alloc = std::allocator<st_join_table*>]"
"_Alloc>::_M_push_back_aux(const value_type&) [with _Tp = st_join_table*,_Alloc = std::allocator<st_join_table*>,std::deque<_Tp,_Alloc>::value_type = st_join_table*]" -> "__cxa_begin_catch(void*)"
"_Alloc>::_M_push_back_aux(const value_type&) [with _Tp = st_join_table*,_Alloc = std::allocator<st_join_table*>,std::deque<_Tp,_Alloc>::value_type = st_join_table*]" -> "_Alloc>::_M_allocate_node() [with _Tp = st_join_table*,_Alloc = std::allocator<st_join_table*>]"
"_Alloc>::_M_reserve_map_at_back(std::deque<_Tp,_Alloc>::size_type) [with _Tp = st_join_table*,_Alloc = std::allocator<st_join_table*>,std::deque<_Tp,_Alloc>::size_type = long unsigned int]" -> "_Alloc>::_M_reallocate_map(std::deque<_Tp,_Alloc>::size_type,bool) [with _Tp = st_join_table*,_Alloc = std::allocator<st_join_table*>,std::deque<_Tp,_Alloc>::size_type = long unsigned int]"
"_Alloc>::_M_reallocate_map(std::deque<_Tp,_Alloc>::size_type,bool) [with _Tp = st_join_table*,_Alloc = std::allocator<st_join_table*>,std::deque<_Tp,_Alloc>::size_type = long unsigned int]" -> "std::copy(_II,_II,_OI) [with _II = st_join_table***,_OI = st_join_table***]"
"_Alloc>::_M_reallocate_map(std::deque<_Tp,_Alloc>::size_type,bool) [with _Tp = st_join_table*,_Alloc = std::allocator<st_join_table*>,std::deque<_Tp,_Alloc>::size_type = long unsigned int]" -> "std::max(const _Tp&,const _Tp&) [with _Tp = long unsigned int]"
"_Alloc>::_M_reallocate_map(std::deque<_Tp,_Alloc>::size_type,bool) [with _Tp = st_join_table*,_Alloc = std::allocator<st_join_table*>,std::deque<_Tp,_Alloc>::size_type = long unsigned int]" -> "std::copy_backward(_BI1,_BI1,_BI2) [with _BI1 = st_join_table***,_BI2 = st_join_table***]"
"_Alloc>::_M_reallocate_map(std::deque<_Tp,_Alloc>::size_type,bool) [with _Tp = st_join_table*,_Alloc = std::allocator<st_join_table*>,std::deque<_Tp,_Alloc>::size_type = long unsigned int]" -> "_Ptr>::_M_set_node(std::_Deque_iterator<_Tp,_Ref,_Ptr>::_Map_pointer) [with _Tp = st_join_table*,_Ref = st_join_table*&,_Ptr = st_join_table**,std::_Deque_iterator<_Tp,_Ref,_Ptr>::_Map_pointer = st_join_table***]"
"_Alloc>::_M_reallocate_map(std::deque<_Tp,_Alloc>::size_type,bool) [with _Tp = st_join_table*,_Alloc = std::allocator<st_join_table*>,std::deque<_Tp,_Alloc>::size_type = long unsigned int]" -> "_Alloc>::_M_deallocate_map(_Tp**,std::size_t) [with _Tp = st_join_table*,_Alloc = std::allocator<st_join_table*>,std::size_t = long unsigned int]"
"_Alloc>::_M_reallocate_map(std::deque<_Tp,_Alloc>::size_type,bool) [with _Tp = st_join_table*,_Alloc = std::allocator<st_join_table*>,std::deque<_Tp,_Alloc>::size_type = long unsigned int]" -> "_Alloc>::_M_allocate_map(std::size_t) [with _Tp = st_join_table*,_Alloc = std::allocator<st_join_table*>,std::size_t = long unsigned int]"
"std::copy(_II,_II,_OI) [with _II = st_join_table***,_OI = st_join_table***]" -> "std::__miter_base(_Iterator) [with _Iterator = st_join_table***,typename std::_Miter_base<_Iterator>::iterator_type = st_join_table***]"
"std::copy(_II,_II,_OI) [with _II = st_join_table***,_OI = st_join_table***]" -> "std::__copy_move_a2(_II,_II,_OI) [with bool _IsMove = false,_II = st_join_table***,_OI = st_join_table***]"
"std::__miter_base(_Iterator) [with _Iterator = st_join_table***,typename std::_Miter_base<_Iterator>::iterator_type = st_join_table***]" -> "_HasBase>::_S_base(_Iterator) [with _Iterator = st_join_table***,bool _HasBase = false,std::_Iter_base<_Iterator,_HasBase>::iterator_type = st_join_table***]"
"std::__copy_move_a2(_II,_II,_OI) [with bool _IsMove = false,_II = st_join_table***,_OI = st_join_table***]" -> "std::__niter_base(_Iterator) [with _Iterator = st_join_table***,typename std::_Niter_base<_Iterator>::iterator_type = st_join_table***]"
"std::__copy_move_a2(_II,_II,_OI) [with bool _IsMove = false,_II = st_join_table***,_OI = st_join_table***]" -> "std::__copy_move_a(_II,_II,_OI) [with bool _IsMove = false,_II = st_join_table***,_OI = st_join_table***]"
"std::__niter_base(_Iterator) [with _Iterator = st_join_table***,typename std::_Niter_base<_Iterator>::iterator_type = st_join_table***]" -> "_HasBase>::_S_base(_Iterator) [with _Iterator = st_join_table***,bool _HasBase = false,std::_Iter_base<_Iterator,_HasBase>::iterator_type = st_join_table***]"
"std::__copy_move_a(_II,_II,_OI) [with bool _IsMove = false,_II = st_join_table***,_OI = st_join_table***]" -> "std::random_access_iterator_tag>::__copy_m(const _Tp*,const _Tp*,_Tp*) [with _Tp = st_join_table**,bool _IsMove = false]"
"std::random_access_iterator_tag>::__copy_m(const _Tp*,const _Tp*,_Tp*) [with _Tp = st_join_table**,bool _IsMove = false]" -> "__builtin_memmove(void*,const void*,long unsigned int)"
"std::copy_backward(_BI1,_BI1,_BI2) [with _BI1 = st_join_table***,_BI2 = st_join_table***]" -> "std::__miter_base(_Iterator) [with _Iterator = st_join_table***,typename std::_Miter_base<_Iterator>::iterator_type = st_join_table***]"
"std::copy_backward(_BI1,_BI1,_BI2) [with _BI1 = st_join_table***,_BI2 = st_join_table***]" -> "std::__copy_move_backward_a2(_BI1,_BI1,_BI2) [with bool _IsMove = false,_BI1 = st_join_table***,_BI2 = st_join_table***]"
"std::__copy_move_backward_a2(_BI1,_BI1,_BI2) [with bool _IsMove = false,_BI1 = st_join_table***,_BI2 = st_join_table***]" -> "std::__copy_move_backward_a(_BI1,_BI1,_BI2) [with bool _IsMove = false,_BI1 = st_join_table***,_BI2 = st_join_table***]"
"std::__copy_move_backward_a2(_BI1,_BI1,_BI2) [with bool _IsMove = false,_BI1 = st_join_table***,_BI2 = st_join_table***]" -> "std::__niter_base(_Iterator) [with _Iterator = st_join_table***,typename std::_Niter_base<_Iterator>::iterator_type = st_join_table***]"
"std::__copy_move_backward_a(_BI1,_BI1,_BI2) [with bool _IsMove = false,_BI1 = st_join_table***,_BI2 = st_join_table***]" -> "std::random_access_iterator_tag>::__copy_move_b(const _Tp*,const _Tp*,_Tp*) [with _Tp = st_join_table**,bool _IsMove = false]"
"std::random_access_iterator_tag>::__copy_move_b(const _Tp*,const _Tp*,_Tp*) [with _Tp = st_join_table**,bool _IsMove = false]" -> "__builtin_memmove(void*,const void*,long unsigned int)"
"insert_sort(Element_type**,Element_type**,Comp_func) [with Element_type = st_join_table,Comp_func = Join_tab_compare_default]" -> "Join_tab_compare_default::operator()(const JOIN_TAB*,const JOIN_TAB*)"
"_Alloc>::deque() [with _Tp = st_join_table*,_Alloc = std::allocator<st_join_table*>]" -> "_Alloc>::_Deque_base() [with _Tp = st_join_table*,_Alloc = std::allocator<st_join_table*>]"
"_Alloc>::_Deque_base() [with _Tp = st_join_table*,_Alloc = std::allocator<st_join_table*>]" -> "_Alloc>::_M_initialize_map(std::size_t) [with _Tp = st_join_table*,_Alloc = std::allocator<st_join_table*>,std::size_t = long unsigned int]"
"_Alloc>::_Deque_base() [with _Tp = st_join_table*,_Alloc = std::allocator<st_join_table*>]" -> "_Alloc>::_Deque_impl::_Deque_impl() [with _Tp = st_join_table*,_Alloc = std::allocator<st_join_table*>]"
"_Alloc>::_Deque_impl::_Deque_impl() [with _Tp = st_join_table*,_Alloc = std::allocator<st_join_table*>]" -> "_Ptr>::_Deque_iterator() [with _Tp = st_join_table*,_Ref = st_join_table*&,_Ptr = st_join_table**]"
"_Alloc>::_Deque_impl::_Deque_impl() [with _Tp = st_join_table*,_Alloc = std::allocator<st_join_table*>]" -> "std::allocator<_Tp>::allocator() [with _Tp = st_join_table*]"
"std::allocator<_Tp>::allocator() [with _Tp = st_join_table*]" -> "__gnu_cxx::new_allocator<_Tp>::new_allocator() [with _Tp = st_join_table*]"
"_Sequence>::pop() [with _Tp = st_join_table*,_Sequence = std::deque<st_join_table*,std::allocator<st_join_table*> >]" -> "_Alloc>::pop_front() [with _Tp = st_join_table*,_Alloc = std::allocator<st_join_table*>]"
"_Alloc>::pop_front() [with _Tp = st_join_table*,_Alloc = std::allocator<st_join_table*>]" -> "__gnu_cxx::new_allocator<_Tp>::destroy(__gnu_cxx::new_allocator<_Tp>::pointer) [with _Tp = st_join_table*,__gnu_cxx::new_allocator<_Tp>::pointer = st_join_table**]"
"_Alloc>::pop_front() [with _Tp = st_join_table*,_Alloc = std::allocator<st_join_table*>]" -> "_Alloc>::_M_pop_front_aux() [with _Tp = st_join_table*,_Alloc = std::allocator<st_join_table*>]"
"_Alloc>::_M_pop_front_aux() [with _Tp = st_join_table*,_Alloc = std::allocator<st_join_table*>]" -> "_Alloc>::_M_deallocate_node(_Tp*) [with _Tp = st_join_table*,_Alloc = std::allocator<st_join_table*>]"
"_Alloc>::_M_pop_front_aux() [with _Tp = st_join_table*,_Alloc = std::allocator<st_join_table*>]" -> "__gnu_cxx::new_allocator<_Tp>::destroy(__gnu_cxx::new_allocator<_Tp>::pointer) [with _Tp = st_join_table*,__gnu_cxx::new_allocator<_Tp>::pointer = st_join_table**]"
"_Alloc>::_M_pop_front_aux() [with _Tp = st_join_table*,_Alloc = std::allocator<st_join_table*>]" -> "_Ptr>::_M_set_node(std::_Deque_iterator<_Tp,_Ref,_Ptr>::_Map_pointer) [with _Tp = st_join_table*,_Ref = st_join_table*&,_Ptr = st_join_table**,std::_Deque_iterator<_Tp,_Ref,_Ptr>::_Map_pointer = st_join_table***]"
"_Sequence>::empty() const [with _Tp = st_join_table*,_Sequence = std::deque<st_join_table*,std::allocator<st_join_table*> >]" -> "_Alloc>::empty() const [with _Tp = st_join_table*,_Alloc = std::allocator<st_join_table*>]"
"_Alloc>::empty() const [with _Tp = st_join_table*,_Alloc = std::allocator<st_join_table*>]" -> "std::operator==(const std::_Deque_iterator<_Tp,_Ref,_Ptr>&,const std::_Deque_iterator<_Tp,_Ref,_Ptr>&) [with _Tp = st_join_table*,_Ref = st_join_table*&,_Ptr = st_join_table**]"
"_Sequence>::front() [with _Tp = st_join_table*,_Sequence = std::deque<st_join_table*,std::allocator<st_join_table*> >,std::queue<_Tp,_Sequence>::reference = st_join_table*&]" -> "_Alloc>::front() [with _Tp = st_join_table*,_Alloc = std::allocator<st_join_table*>,std::deque<_Tp,_Alloc>::reference = st_join_table*&]"
"_Alloc>::front() [with _Tp = st_join_table*,_Alloc = std::allocator<st_join_table*>,std::deque<_Tp,_Alloc>::reference = st_join_table*&]" -> "_Ptr>::operator*() const [with _Tp = st_join_table*,_Ref = st_join_table*&,_Ptr = st_join_table**,std::_Deque_iterator<_Tp,_Ref,_Ptr>::reference = st_join_table*&]"
"_Alloc>::front() [with _Tp = st_join_table*,_Alloc = std::allocator<st_join_table*>,std::deque<_Tp,_Alloc>::reference = st_join_table*&]" -> "_Alloc>::begin() [with _Tp = st_join_table*,_Alloc = std::allocator<st_join_table*>,std::deque<_Tp,_Alloc>::iterator = std::_Deque_iterator<st_join_table*,st_join_table*&,st_join_table**>]"
"_Alloc>::begin() [with _Tp = st_join_table*,_Alloc = std::allocator<st_join_table*>,std::deque<_Tp,_Alloc>::iterator = std::_Deque_iterator<st_join_table*,st_join_table*&,st_join_table**>]" -> "_Ptr>::_Deque_iterator(const iterator&) [with _Tp = st_join_table*,_Ref = st_join_table*&,_Ptr = st_join_table**,std::_Deque_iterator<_Tp,_Ref,_Ptr>::iterator = std::_Deque_iterator<st_join_table*,st_join_table*&,st_join_table**>]"
"reset_nj_counters(List<TABLE_LIST>*)" -> "List_iterator<T>::List_iterator(List<T>&) [with T = TABLE_LIST]"
"reset_nj_counters(List<TABLE_LIST>*)" -> "List_iterator<T>::operator++(int) [with T = TABLE_LIST]"
"reset_nj_counters(List<TABLE_LIST>*)" -> "reset_nj_counters(List<TABLE_LIST>*)"
"Optimize_table_order::greedy_search(table_map)" -> "Optimize_table_order::check_interleaving_with_nj(JOIN_TAB*)"
"Optimize_table_order::greedy_search(table_map)" -> "Optimize_table_order::best_extension_by_limited_search(table_map,uint,double,double,uint)"
"Optimize_table_order::greedy_search(table_map)" -> "st_position::st_position()"
"Optimize_table_order::greedy_search(table_map)" -> "memmove(void*,const void*,size_t)"
"Optimize_table_order::greedy_search(table_map)" -> "my_count_bits(ulonglong)"
"Optimize_table_order::check_interleaving_with_nj(JOIN_TAB*)" -> "TABLE_LIST::join_cond() const"
"Optimize_table_order::best_extension_by_limited_search(table_map,uint,double,double,uint)" -> "st_position::no_semijoin()"
"Optimize_table_order::best_extension_by_limited_search(table_map,uint,double,double,uint)" -> "st_position::st_position()"
"Optimize_table_order::best_extension_by_limited_search(table_map,uint,double,double,uint)" -> "Optimize_table_order::backout_nj_state(table_map,const JOIN_TAB*)"
"Optimize_table_order::best_extension_by_limited_search(table_map,uint,double,double,uint)" -> "st_position::set_prefix_costs(double,double)"
"Optimize_table_order::best_extension_by_limited_search(table_map,uint,double,double,uint)" -> "Optimize_table_order::advance_sj_state(table_map,const JOIN_TAB*,uint,double*,double*,POSITION*)"
"Optimize_table_order::best_extension_by_limited_search(table_map,uint,double,double,uint)" -> "Opt_trace_object::Opt_trace_object(Opt_trace_context*,Opt_trace_context::feature_value)"
"Optimize_table_order::best_extension_by_limited_search(table_map,uint,double,double,uint)" -> "Optimize_table_order::consider_plan(uint,double,double,Opt_trace_object*)"
"Optimize_table_order::best_extension_by_limited_search(table_map,uint,double,double,uint)" -> "base_list::is_empty() const"
"Optimize_table_order::best_extension_by_limited_search(table_map,uint,double,double,uint)" -> "Opt_trace_struct::add(const char*,double)"
"Optimize_table_order::best_extension_by_limited_search(table_map,uint,double,double,uint)" -> "Opt_trace_struct::add_utf8_table(const TABLE*)"
"Optimize_table_order::best_extension_by_limited_search(table_map,uint,double,double,uint)" -> "Optimize_table_order::eq_ref_extension_by_limited_search(table_map,uint,double,double,uint)"
"Optimize_table_order::best_extension_by_limited_search(table_map,uint,double,double,uint)" -> "Optimize_table_order::best_access_path(JOIN_TAB*,table_map,uint,bool,double,POSITION*,POSITION*)"
"Optimize_table_order::best_extension_by_limited_search(table_map,uint,double,double,uint)" -> "Opt_trace_struct::add(const char*,bool)"
"Optimize_table_order::best_extension_by_limited_search(table_map,uint,double,double,uint)" -> "Optimize_table_order::check_interleaving_with_nj(JOIN_TAB*)"
"Optimize_table_order::best_extension_by_limited_search(table_map,uint,double,double,uint)" -> "__builtin_expect(long int,long int)"
"Optimize_table_order::best_extension_by_limited_search(table_map,uint,double,double,uint)" -> "Opt_trace_array::Opt_trace_array(Opt_trace_context*,const char*,Opt_trace_context::feature_value)"
"Optimize_table_order::best_extension_by_limited_search(table_map,uint,double,double,uint)" -> "memcpy(void*,const void*,size_t)"
"Optimize_table_order::best_extension_by_limited_search(table_map,uint,double,double,uint)" -> "Optimize_table_order::best_extension_by_limited_search(table_map,uint,double,double,uint)"
"Optimize_table_order::best_extension_by_limited_search(table_map,uint,double,double,uint)" -> "Opt_trace_context::is_started() const"
"Optimize_table_order::best_extension_by_limited_search(table_map,uint,double,double,uint)" -> "trace_plan_prefix(JOIN*,uint,table_map)"
"Optimize_table_order::backout_nj_state(table_map,const JOIN_TAB*)" -> "TABLE_LIST::join_cond() const"
"Optimize_table_order::consider_plan(uint,double,double,Opt_trace_object*)" -> "Opt_trace_struct::add(const char*,double)"
"Optimize_table_order::consider_plan(uint,double,double,Opt_trace_object*)" -> "memcpy(void*,const void*,size_t)"
"Optimize_table_order::consider_plan(uint,double,double,Opt_trace_object*)" -> "Opt_trace_struct::add(const char*,bool)"
"Optimize_table_order::eq_ref_extension_by_limited_search(table_map,uint,double,double,uint)" -> "Optimize_table_order::best_access_path(JOIN_TAB*,table_map,uint,bool,double,POSITION*,POSITION*)"
"Optimize_table_order::eq_ref_extension_by_limited_search(table_map,uint,double,double,uint)" -> "base_list::is_empty() const"
"Optimize_table_order::eq_ref_extension_by_limited_search(table_map,uint,double,double,uint)" -> "Opt_trace_struct::add_utf8_table(const TABLE*)"
"Optimize_table_order::eq_ref_extension_by_limited_search(table_map,uint,double,double,uint)" -> "Optimize_table_order::best_extension_by_limited_search(table_map,uint,double,double,uint)"
"Optimize_table_order::eq_ref_extension_by_limited_search(table_map,uint,double,double,uint)" -> "Opt_trace_context::is_started() const"
"Optimize_table_order::eq_ref_extension_by_limited_search(table_map,uint,double,double,uint)" -> "st_position::set_prefix_costs(double,double)"
"Optimize_table_order::eq_ref_extension_by_limited_search(table_map,uint,double,double,uint)" -> "trace_plan_prefix(JOIN*,uint,table_map)"
"Optimize_table_order::eq_ref_extension_by_limited_search(table_map,uint,double,double,uint)" -> "st_position::st_position()"
"Optimize_table_order::eq_ref_extension_by_limited_search(table_map,uint,double,double,uint)" -> "Optimize_table_order::advance_sj_state(table_map,const JOIN_TAB*,uint,double*,double*,POSITION*)"
"Optimize_table_order::eq_ref_extension_by_limited_search(table_map,uint,double,double,uint)" -> "__builtin_expect(long int,long int)"
"Optimize_table_order::eq_ref_extension_by_limited_search(table_map,uint,double,double,uint)" -> "Optimize_table_order::consider_plan(uint,double,double,Opt_trace_object*)"
"Optimize_table_order::eq_ref_extension_by_limited_search(table_map,uint,double,double,uint)" -> "Opt_trace_array::Opt_trace_array(Opt_trace_context*,const char*,Opt_trace_context::feature_value)"
"Optimize_table_order::eq_ref_extension_by_limited_search(table_map,uint,double,double,uint)" -> "memcpy(void*,const void*,size_t)"
"Optimize_table_order::eq_ref_extension_by_limited_search(table_map,uint,double,double,uint)" -> "Opt_trace_object::Opt_trace_object(Opt_trace_context*,Opt_trace_context::feature_value)"
"Optimize_table_order::eq_ref_extension_by_limited_search(table_map,uint,double,double,uint)" -> "Opt_trace_struct::add(const char*,double)"
"Optimize_table_order::eq_ref_extension_by_limited_search(table_map,uint,double,double,uint)" -> "Optimize_table_order::check_interleaving_with_nj(JOIN_TAB*)"
"Optimize_table_order::eq_ref_extension_by_limited_search(table_map,uint,double,double,uint)" -> "Optimize_table_order::eq_ref_extension_by_limited_search(table_map,uint,double,double,uint)"
"Optimize_table_order::eq_ref_extension_by_limited_search(table_map,uint,double,double,uint)" -> "Optimize_table_order::backout_nj_state(table_map,const JOIN_TAB*)"
"Optimize_table_order::eq_ref_extension_by_limited_search(table_map,uint,double,double,uint)" -> "Opt_trace_struct::add(const char*,bool)"
"Optimize_table_order::eq_ref_extension_by_limited_search(table_map,uint,double,double,uint)" -> "st_position::no_semijoin()"
"merge_sort(Element_type**,Element_type**,Comp_func) [with Element_type = st_join_table,Comp_func = Join_tab_compare_straight]" -> "_Sequence>::push(const value_type&) [with _Tp = st_join_table*,_Sequence = std::deque<st_join_table*,std::allocator<st_join_table*> >,std::queue<_Tp,_Sequence>::value_type = st_join_table*]"
"merge_sort(Element_type**,Element_type**,Comp_func) [with Element_type = st_join_table,Comp_func = Join_tab_compare_straight]" -> "Join_tab_compare_straight::operator()(const JOIN_TAB*,const JOIN_TAB*)"
"merge_sort(Element_type**,Element_type**,Comp_func) [with Element_type = st_join_table,Comp_func = Join_tab_compare_straight]" -> "_Sequence>::empty() const [with _Tp = st_join_table*,_Sequence = std::deque<st_join_table*,std::allocator<st_join_table*> >]"
"merge_sort(Element_type**,Element_type**,Comp_func) [with Element_type = st_join_table,Comp_func = Join_tab_compare_straight]" -> "insert_sort(Element_type**,Element_type**,Comp_func) [with Element_type = st_join_table,Comp_func = Join_tab_compare_straight]"
"merge_sort(Element_type**,Element_type**,Comp_func) [with Element_type = st_join_table,Comp_func = Join_tab_compare_straight]" -> "_Sequence>::pop() [with _Tp = st_join_table*,_Sequence = std::deque<st_join_table*,std::allocator<st_join_table*> >]"
"merge_sort(Element_type**,Element_type**,Comp_func) [with Element_type = st_join_table,Comp_func = Join_tab_compare_straight]" -> "_Sequence>::queue(const _Sequence&) [with _Tp = st_join_table*,_Sequence = std::deque<st_join_table*,std::allocator<st_join_table*> >]"
"merge_sort(Element_type**,Element_type**,Comp_func) [with Element_type = st_join_table,Comp_func = Join_tab_compare_straight]" -> "merge_sort(Element_type**,Element_type**,Comp_func) [with Element_type = st_join_table,Comp_func = Join_tab_compare_straight]"
"merge_sort(Element_type**,Element_type**,Comp_func) [with Element_type = st_join_table,Comp_func = Join_tab_compare_straight]" -> "_Sequence>::front() [with _Tp = st_join_table*,_Sequence = std::deque<st_join_table*,std::allocator<st_join_table*> >,std::queue<_Tp,_Sequence>::reference = st_join_table*&]"
"merge_sort(Element_type**,Element_type**,Comp_func) [with Element_type = st_join_table,Comp_func = Join_tab_compare_straight]" -> "_Alloc>::deque() [with _Tp = st_join_table*,_Alloc = std::allocator<st_join_table*>]"
"insert_sort(Element_type**,Element_type**,Comp_func) [with Element_type = st_join_table,Comp_func = Join_tab_compare_straight]" -> "Join_tab_compare_straight::operator()(const JOIN_TAB*,const JOIN_TAB*)"
"Optimize_table_order::fix_semijoin_strategies()" -> "base_list::is_empty() const"
"Optimize_table_order::fix_semijoin_strategies()" -> "memcpy(void*,const void*,size_t)"
"Optimize_table_order::fix_semijoin_strategies()" -> "Optimize_table_order::semijoin_mat_scan_access_paths(uint,uint,table_map,TABLE_LIST*,bool,double*,double*)"
"Optimize_table_order::fix_semijoin_strategies()" -> "Opt_trace_object::Opt_trace_object(Opt_trace_context*,Opt_trace_context::feature_value)"
"Optimize_table_order::fix_semijoin_strategies()" -> "Optimize_table_order::semijoin_firstmatch_loosescan_access_paths(uint,uint,table_map,bool,bool,double*,double*)"
"Optimize_table_order::fix_semijoin_strategies()" -> "my_count_bits(ulonglong)"
"Optimize_table_order::fix_semijoin_strategies()" -> "Opt_trace_struct::add_alnum(const char*,const char*)"
"merge_sort(Element_type**,Element_type**,Comp_func) [with Element_type = st_join_table,Comp_func = Join_tab_compare_embedded_first]" -> "Join_tab_compare_embedded_first::operator()(const JOIN_TAB*,const JOIN_TAB*)"
"merge_sort(Element_type**,Element_type**,Comp_func) [with Element_type = st_join_table,Comp_func = Join_tab_compare_embedded_first]" -> "insert_sort(Element_type**,Element_type**,Comp_func) [with Element_type = st_join_table,Comp_func = Join_tab_compare_embedded_first]"
"merge_sort(Element_type**,Element_type**,Comp_func) [with Element_type = st_join_table,Comp_func = Join_tab_compare_embedded_first]" -> "_Sequence>::push(const value_type&) [with _Tp = st_join_table*,_Sequence = std::deque<st_join_table*,std::allocator<st_join_table*> >,std::queue<_Tp,_Sequence>::value_type = st_join_table*]"
"merge_sort(Element_type**,Element_type**,Comp_func) [with Element_type = st_join_table,Comp_func = Join_tab_compare_embedded_first]" -> "merge_sort(Element_type**,Element_type**,Comp_func) [with Element_type = st_join_table,Comp_func = Join_tab_compare_embedded_first]"
"merge_sort(Element_type**,Element_type**,Comp_func) [with Element_type = st_join_table,Comp_func = Join_tab_compare_embedded_first]" -> "_Sequence>::queue(const _Sequence&) [with _Tp = st_join_table*,_Sequence = std::deque<st_join_table*,std::allocator<st_join_table*> >]"
"merge_sort(Element_type**,Element_type**,Comp_func) [with Element_type = st_join_table,Comp_func = Join_tab_compare_embedded_first]" -> "_Sequence>::front() [with _Tp = st_join_table*,_Sequence = std::deque<st_join_table*,std::allocator<st_join_table*> >,std::queue<_Tp,_Sequence>::reference = st_join_table*&]"
"merge_sort(Element_type**,Element_type**,Comp_func) [with Element_type = st_join_table,Comp_func = Join_tab_compare_embedded_first]" -> "_Sequence>::empty() const [with _Tp = st_join_table*,_Sequence = std::deque<st_join_table*,std::allocator<st_join_table*> >]"
"merge_sort(Element_type**,Element_type**,Comp_func) [with Element_type = st_join_table,Comp_func = Join_tab_compare_embedded_first]" -> "_Alloc>::deque() [with _Tp = st_join_table*,_Alloc = std::allocator<st_join_table*>]"
"merge_sort(Element_type**,Element_type**,Comp_func) [with Element_type = st_join_table,Comp_func = Join_tab_compare_embedded_first]" -> "_Sequence>::pop() [with _Tp = st_join_table*,_Sequence = std::deque<st_join_table*,std::allocator<st_join_table*> >]"
"Join_tab_compare_embedded_first::operator()(const JOIN_TAB*,const JOIN_TAB*)" -> "Join_tab_compare_default::operator()(const JOIN_TAB*,const JOIN_TAB*)"
"insert_sort(Element_type**,Element_type**,Comp_func) [with Element_type = st_join_table,Comp_func = Join_tab_compare_embedded_first]" -> "Join_tab_compare_embedded_first::operator()(const JOIN_TAB*,const JOIN_TAB*)"
"semijoin_types_allow_materialization(TABLE_LIST*)" -> "List_iterator<T>::operator++(int) [with T = Item]"
"semijoin_types_allow_materialization(TABLE_LIST*)" -> "types_allow_materialization(Item*,Item*)"
"semijoin_types_allow_materialization(TABLE_LIST*)" -> "Item::is_blob_field() const"
"semijoin_types_allow_materialization(TABLE_LIST*)" -> "List_iterator<T>::List_iterator(List<T>&) [with T = Item]"
"types_allow_materialization(Item*,Item*)" -> "Item::is_temporal_with_date() const"
"Optimize_table_order::Optimize_table_order(THD*,JOIN*,TABLE_LIST*)" -> "Optimize_table_order::determine_search_depth(uint,uint)"
"trace_table_dependencies(Opt_trace_context*,JOIN_TAB*,uint)" -> "Opt_trace_struct::add(uint)"
"trace_table_dependencies(Opt_trace_context*,JOIN_TAB*,uint)" -> "Opt_trace_struct::add(const char*,bool)"
"trace_table_dependencies(Opt_trace_context*,JOIN_TAB*,uint)" -> "Opt_trace_object::Opt_trace_object(Opt_trace_context*,Opt_trace_context::feature_value)"
"trace_table_dependencies(Opt_trace_context*,JOIN_TAB*,uint)" -> "Opt_trace_array::Opt_trace_array(Opt_trace_context*,const char*,Opt_trace_context::feature_value)"
"trace_table_dependencies(Opt_trace_context*,JOIN_TAB*,uint)" -> "Opt_trace_struct::add(const char*,uint)"
"trace_table_dependencies(Opt_trace_context*,JOIN_TAB*,uint)" -> "Opt_trace_struct::add_utf8_table(const TABLE*)"
"Opt_trace_struct::add(uint)" -> "__builtin_expect(long int,long int)"
"Opt_trace_struct::add(uint)" -> "Opt_trace_struct::do_add(const char*,ulonglong)"
"pull_out_semijoin_tables(JOIN*)" -> "List<T>::push_back(T*) [with T = TABLE_LIST]"
"pull_out_semijoin_tables(JOIN*)" -> "find_eq_ref_candidate(TABLE*,table_map)"
"pull_out_semijoin_tables(JOIN*)" -> "List_iterator<T>::rewind() [with T = TABLE_LIST]"
"pull_out_semijoin_tables(JOIN*)" -> "List_iterator<T>::operator++(int) [with T = TABLE_LIST]"
"pull_out_semijoin_tables(JOIN*)" -> "Opt_trace_struct::add_utf8_table(const TABLE*)"
"pull_out_semijoin_tables(JOIN*)" -> "Opt_trace_struct::add(const char*,bool)"
"pull_out_semijoin_tables(JOIN*)" -> "Prepared_stmt_arena_holder::Prepared_stmt_arena_holder(THD*,bool)"
"pull_out_semijoin_tables(JOIN*)" -> "Opt_trace_array::Opt_trace_array(Opt_trace_context*,const char*,Opt_trace_context::feature_value)"
"pull_out_semijoin_tables(JOIN*)" -> "List_iterator<T>::List_iterator(List<T>&) [with T = TABLE_LIST]"
"pull_out_semijoin_tables(JOIN*)" -> "List_iterator<T>::remove() [with T = TABLE_LIST]"
"pull_out_semijoin_tables(JOIN*)" -> "Opt_trace_object::Opt_trace_object(Opt_trace_context*,Opt_trace_context::feature_value)"
"List_iterator<T>::rewind() [with T = TABLE_LIST]" -> "base_list_iterator::rewind()"
"List_iterator<T>::remove() [with T = TABLE_LIST]" -> "base_list_iterator::remove()"
"st_join_table::st_join_table()" -> "READ_RECORD::READ_RECORD()"
"st_join_table::st_join_table()" -> "memset(void*,int,size_t)"
"st_join_table::st_join_table()" -> "Bitmap<64u>::Bitmap()"
"st_join_table::st_join_table()" -> "st_table_ref::st_table_ref()"
"st_join_table::st_join_table()" -> "Sql_alloc::Sql_alloc()"
"st_table_ref::st_table_ref()" -> "Sql_alloc::Sql_alloc()"
"JOIN::get_best_combination()" -> "List_iterator<T>::List_iterator(List<T>&) [with T = TABLE_LIST]"
"JOIN::get_best_combination()" -> "sj_is_materialize_strategy(uint)"
"JOIN::get_best_combination()" -> "st_join_table::st_join_table()"
"JOIN::get_best_combination()" -> "Semijoin_mat_exec::Semijoin_mat_exec(TABLE_LIST*,bool,uint,uint,uint)"
"JOIN::get_best_combination()" -> "JOIN::setup_materialized_table(JOIN_TAB*,uint,const POSITION*,POSITION*)"
"JOIN::get_best_combination()" -> "base_list::is_empty() const"
"JOIN::get_best_combination()" -> "JOIN::update_equalities_for_sjm()"
"JOIN::get_best_combination()" -> "JOIN::ORDER_with_src::operator ORDER*()"
"JOIN::get_best_combination()" -> "JOIN::set_semijoin_info()"
"JOIN::get_best_combination()" -> "List_iterator<T>::operator++(int) [with T = TABLE_LIST]"
"JOIN::get_best_combination()" -> "__builtin_memcpy(void*,const void*,long unsigned int)"
"Semijoin_mat_exec::Semijoin_mat_exec(TABLE_LIST*,bool,uint,uint,uint)" -> "TMP_TABLE_PARAM::TMP_TABLE_PARAM()"
"Semijoin_mat_exec::Semijoin_mat_exec(TABLE_LIST*,bool,uint,uint,uint)" -> "Sql_alloc::Sql_alloc()"
"JOIN::setup_materialized_table(JOIN_TAB*,uint,const POSITION*,POSITION*)" -> "alloc_root(MEM_ROOT*,size_t)"
"JOIN::setup_materialized_table(JOIN_TAB*,uint,const POSITION*,POSITION*)" -> "List<T>::List(const List<T>&) [with T = Item]"
"JOIN::setup_materialized_table(JOIN_TAB*,uint,const POSITION*,POSITION*)" -> "my_snprintf(char*,size_t,const char*,...)"
"JOIN::setup_materialized_table(JOIN_TAB*,uint,const POSITION*,POSITION*)" -> "Item_field::Item_field(Field*)"
"JOIN::setup_materialized_table(JOIN_TAB*,uint,const POSITION*,POSITION*)" -> "TMP_TABLE_PARAM::init()"
"JOIN::setup_materialized_table(JOIN_TAB*,uint,const POSITION*,POSITION*)" -> "TABLE_LIST::init_one_table(const char*,size_t,const char*,size_t,const char*,thr_lock_type)"
"JOIN::setup_materialized_table(JOIN_TAB*,uint,const POSITION*,POSITION*)" -> "create_tmp_table(THD*,TMP_TABLE_PARAM*,List<Item>&,ORDER*,bool,bool,ulonglong,ha_rows,const char*)"
"JOIN::setup_materialized_table(JOIN_TAB*,uint,const POSITION*,POSITION*)" -> "memcpy(void*,const void*,size_t)"
"JOIN::setup_materialized_table(JOIN_TAB*,uint,const POSITION*,POSITION*)" -> "TABLE_LIST::join_cond_ref()"
"JOIN::setup_materialized_table(JOIN_TAB*,uint,const POSITION*,POSITION*)" -> "st_position::set_prefix_costs(double,double)"
"JOIN::setup_materialized_table(JOIN_TAB*,uint,const POSITION*,POSITION*)" -> "List<T>::push_back(T*) [with T = TABLE]"
"JOIN::setup_materialized_table(JOIN_TAB*,uint,const POSITION*,POSITION*)" -> "strlen(const char*)"
"JOIN::setup_materialized_table(JOIN_TAB*,uint,const POSITION*,POSITION*)" -> "List<T>::push_back(T*) [with T = Semijoin_mat_exec]"
"JOIN::setup_materialized_table(JOIN_TAB*,uint,const POSITION*,POSITION*)" -> "has_trivial_destructor>::begin() [with Element_type = Key_use,bool has_trivial_destructor = true]"
"JOIN::setup_materialized_table(JOIN_TAB*,uint,const POSITION*,POSITION*)" -> "create_keyuse_for_table(THD*,TABLE*,uint,Item_field**,List<Item>)"
"JOIN::setup_materialized_table(JOIN_TAB*,uint,const POSITION*,POSITION*)" -> "Bitmap<64u>::set_all()"
"JOIN::setup_materialized_table(JOIN_TAB*,uint,const POSITION*,POSITION*)" -> "Bitmap<64u>::set_bit(uint)"
"JOIN::setup_materialized_table(JOIN_TAB*,uint,const POSITION*,POSITION*)" -> "Cost_estimate::total_cost() const"
"List<T>::push_back(T*) [with T = TABLE]" -> "base_list::push_back(void*)"
"List<T>::push_back(T*) [with T = Semijoin_mat_exec]" -> "base_list::push_back(void*)"
"create_keyuse_for_table(THD*,TABLE*,uint,Item_field**,List<Item>)" -> "has_trivial_destructor>::push_back(const Element_type&) [with Element_type = Key_use,bool has_trivial_destructor = true]"
"create_keyuse_for_table(THD*,TABLE*,uint,Item_field**,List<Item>)" -> "Query_arena::alloc(size_t)"
"create_keyuse_for_table(THD*,TABLE*,uint,Item_field**,List<Item>)" -> "has_trivial_destructor>::Mem_root_array(MEM_ROOT*) [with Element_type = Key_use,bool has_trivial_destructor = true,MEM_ROOT = st_mem_root]"
"create_keyuse_for_table(THD*,TABLE*,uint,Item_field**,List<Item>)" -> "List_iterator<T>::operator++(int) [with T = Item]"
"create_keyuse_for_table(THD*,TABLE*,uint,Item_field**,List<Item>)" -> "List_iterator<T>::List_iterator(List<T>&) [with T = Item]"
"create_keyuse_for_table(THD*,TABLE*,uint,Item_field**,List<Item>)" -> "add_key_part(Key_use_array*,Key_field*)"
"create_keyuse_for_table(THD*,TABLE*,uint,Item_field**,List<Item>)" -> "Key_field::Key_field(Field*,Item*,uint,uint,bool,bool,bool*,uint)"
"create_keyuse_for_table(THD*,TABLE*,uint,Item_field**,List<Item>)" -> "Key_use::Key_use(TABLE*,Item*,table_map,uint,uint,uint,key_part_map,ha_rows,bool,bool*,uint)"
"has_trivial_destructor>::push_back(const Element_type&) [with Element_type = Key_use,bool has_trivial_destructor = true]" -> "has_trivial_destructor>::reserve(size_t) [with Element_type = Key_use,bool has_trivial_destructor = true,size_t = long unsigned int]"
"has_trivial_destructor>::reserve(size_t) [with Element_type = Key_use,bool has_trivial_destructor = true,size_t = long unsigned int]" -> "alloc_root(MEM_ROOT*,size_t)"
"has_trivial_destructor>::reserve(size_t) [with Element_type = Key_use,bool has_trivial_destructor = true,size_t = long unsigned int]" -> "has_trivial_destructor>::element_size() const [with Element_type = Key_use,bool has_trivial_destructor = true,size_t = long unsigned int]"
"add_key_part(Key_use_array*,Key_field*)" -> "has_trivial_destructor>::push_back(const Element_type&) [with Element_type = Key_use,bool has_trivial_destructor = true]"
"add_key_part(Key_use_array*,Key_field*)" -> "Bitmap<64u>::is_set(uint) const"
"add_key_part(Key_use_array*,Key_field*)" -> "actual_key_parts(KEY*)"
"add_key_part(Key_use_array*,Key_field*)" -> "Key_use::Key_use(TABLE*,Item*,table_map,uint,uint,uint,key_part_map,ha_rows,bool,bool*,uint)"
"JOIN::update_equalities_for_sjm()" -> "List_iterator<T>::operator++(int) [with T = Semijoin_mat_exec]"
"JOIN::update_equalities_for_sjm()" -> "TABLE_LIST::outer_join_nest() const"
"JOIN::update_equalities_for_sjm()" -> "List_iterator<T>::List_iterator(List<T>&) [with T = Item]"
"JOIN::update_equalities_for_sjm()" -> "List_iterator<T>::List_iterator(List<T>&) [with T = Semijoin_mat_exec]"
"JOIN::update_equalities_for_sjm()" -> "TABLE_LIST::join_cond() const"
"JOIN::update_equalities_for_sjm()" -> "List_iterator<T>::operator++(int) [with T = Item]"
"JOIN::set_semijoin_info()" -> "base_list::is_empty() const"
"mark_as_null_row(TABLE*)" -> "memset(void*,int,size_t)"
"optimize_keyuse(JOIN*,Key_use_array*)" -> "has_trivial_destructor>::at(size_t) [with Element_type = Key_use,bool has_trivial_destructor = true,size_t = long unsigned int]"
"optimize_keyuse(JOIN*,Key_use_array*)" -> "std::max(const _Tp&,const _Tp&) [with _Tp = long long unsigned int]"
"optimize_keyuse(JOIN*,Key_use_array*)" -> "has_trivial_destructor>::size() const [with Element_type = Key_use,bool has_trivial_destructor = true,size_t = long unsigned int]"
"update_ref_and_keys(THD*,Key_use_array*,JOIN_TAB*,uint,Item*,COND_EQUAL*,table_map,SELECT_LEX*,SARGABLE_PARAM**)" -> "add_ft_keys(Key_use_array*,JOIN_TAB*,Item*,table_map)"
"update_ref_and_keys(THD*,Key_use_array*,JOIN_TAB*,uint,Item*,COND_EQUAL*,table_map,SELECT_LEX*,SARGABLE_PARAM**)" -> "add_key_part(Key_use_array*,Key_field*)"
"update_ref_and_keys(THD*,Key_use_array*,JOIN_TAB*,uint,Item*,COND_EQUAL*,table_map,SELECT_LEX*,SARGABLE_PARAM**)" -> "has_trivial_destructor>::size() const [with Element_type = Key_use,bool has_trivial_destructor = true,size_t = long unsigned int]"
"update_ref_and_keys(THD*,Key_use_array*,JOIN_TAB*,uint,Item*,COND_EQUAL*,table_map,SELECT_LEX*,SARGABLE_PARAM**)" -> "has_trivial_destructor>::begin() [with Element_type = Key_use,bool has_trivial_destructor = true]"
"update_ref_and_keys(THD*,Key_use_array*,JOIN_TAB*,uint,Item*,COND_EQUAL*,table_map,SELECT_LEX*,SARGABLE_PARAM**)" -> "Bitmap<64u>::set_bit(uint)"
"update_ref_and_keys(THD*,Key_use_array*,JOIN_TAB*,uint,Item*,COND_EQUAL*,table_map,SELECT_LEX*,SARGABLE_PARAM**)" -> "add_key_fields_for_nj(JOIN*,TABLE_LIST*,Key_field**,uint*,SARGABLE_PARAM**)"
"update_ref_and_keys(THD*,Key_use_array*,JOIN_TAB*,uint,Item*,COND_EQUAL*,table_map,SELECT_LEX*,SARGABLE_PARAM**)" -> "__builtin_memcpy(void*,const void*,long unsigned int)"
"update_ref_and_keys(THD*,Key_use_array*,JOIN_TAB*,uint,Item*,COND_EQUAL*,table_map,SELECT_LEX*,SARGABLE_PARAM**)" -> "List_iterator<T>::List_iterator(List<T>&) [with T = TABLE_LIST]"
"update_ref_and_keys(THD*,Key_use_array*,JOIN_TAB*,uint,Item*,COND_EQUAL*,table_map,SELECT_LEX*,SARGABLE_PARAM**)" -> "has_trivial_destructor>::push_back(const Element_type&) [with Element_type = Key_use,bool has_trivial_destructor = true]"
"update_ref_and_keys(THD*,Key_use_array*,JOIN_TAB*,uint,Item*,COND_EQUAL*,table_map,SELECT_LEX*,SARGABLE_PARAM**)" -> "has_trivial_destructor>::element_size() const [with Element_type = Key_use,bool has_trivial_destructor = true,size_t = long unsigned int]"
"update_ref_and_keys(THD*,Key_use_array*,JOIN_TAB*,uint,Item*,COND_EQUAL*,table_map,SELECT_LEX*,SARGABLE_PARAM**)" -> "has_trivial_destructor>::empty() const [with Element_type = Key_use,bool has_trivial_destructor = true]"
"update_ref_and_keys(THD*,Key_use_array*,JOIN_TAB*,uint,Item*,COND_EQUAL*,table_map,SELECT_LEX*,SARGABLE_PARAM**)" -> "std::max(const _Tp&,const _Tp&) [with _Tp = unsigned int]"
"update_ref_and_keys(THD*,Key_use_array*,JOIN_TAB*,uint,Item*,COND_EQUAL*,table_map,SELECT_LEX*,SARGABLE_PARAM**)" -> "my_qsort(void*,size_t,size_t,qsort_cmp)"
"update_ref_and_keys(THD*,Key_use_array*,JOIN_TAB*,uint,Item*,COND_EQUAL*,table_map,SELECT_LEX*,SARGABLE_PARAM**)" -> "List_iterator<T>::operator++(int) [with T = TABLE_LIST]"
"update_ref_and_keys(THD*,Key_use_array*,JOIN_TAB*,uint,Item*,COND_EQUAL*,table_map,SELECT_LEX*,SARGABLE_PARAM**)" -> "Key_use::Key_use(TABLE*,Item*,table_map,uint,uint,uint,key_part_map,ha_rows,bool,bool*,uint)"
"update_ref_and_keys(THD*,Key_use_array*,JOIN_TAB*,uint,Item*,COND_EQUAL*,table_map,SELECT_LEX*,SARGABLE_PARAM**)" -> "has_trivial_destructor>::at(size_t) [with Element_type = Key_use,bool has_trivial_destructor = true,size_t = long unsigned int]"
"update_ref_and_keys(THD*,Key_use_array*,JOIN_TAB*,uint,Item*,COND_EQUAL*,table_map,SELECT_LEX*,SARGABLE_PARAM**)" -> "Query_arena::alloc(size_t)"
"update_ref_and_keys(THD*,Key_use_array*,JOIN_TAB*,uint,Item*,COND_EQUAL*,table_map,SELECT_LEX*,SARGABLE_PARAM**)" -> "Field::real_maybe_null() const"
"update_ref_and_keys(THD*,Key_use_array*,JOIN_TAB*,uint,Item*,COND_EQUAL*,table_map,SELECT_LEX*,SARGABLE_PARAM**)" -> "add_key_fields(JOIN*,Key_field**,uint*,Item*,table_map,SARGABLE_PARAM**)"
"update_ref_and_keys(THD*,Key_use_array*,JOIN_TAB*,uint,Item*,COND_EQUAL*,table_map,SELECT_LEX*,SARGABLE_PARAM**)" -> "std::max(const _Tp&,const _Tp&) [with _Tp = long unsigned int]"
"update_ref_and_keys(THD*,Key_use_array*,JOIN_TAB*,uint,Item*,COND_EQUAL*,table_map,SELECT_LEX*,SARGABLE_PARAM**)" -> "print_keyuse_array(Opt_trace_context*,const Key_use_array*)"
"update_ref_and_keys(THD*,Key_use_array*,JOIN_TAB*,uint,Item*,COND_EQUAL*,table_map,SELECT_LEX*,SARGABLE_PARAM**)" -> "JOIN::generate_derived_keys()"
"update_ref_and_keys(THD*,Key_use_array*,JOIN_TAB*,uint,Item*,COND_EQUAL*,table_map,SELECT_LEX*,SARGABLE_PARAM**)" -> "has_trivial_destructor>::chop(size_t) [with Element_type = Key_use,bool has_trivial_destructor = true,size_t = long unsigned int]"
"add_ft_keys(Key_use_array*,JOIN_TAB*,Item*,table_map)" -> "List_iterator_fast<T>::List_iterator_fast(List<T>&) [with T = Item]"
"add_ft_keys(Key_use_array*,JOIN_TAB*,Item*,table_map)" -> "List_iterator_fast<T>::operator++(int) [with T = Item]"
"add_ft_keys(Key_use_array*,JOIN_TAB*,Item*,table_map)" -> "Key_use::Key_use(TABLE*,Item*,table_map,uint,uint,uint,key_part_map,ha_rows,bool,bool*,uint)"
"add_ft_keys(Key_use_array*,JOIN_TAB*,Item*,table_map)" -> "Item_cond::argument_list()"
"add_ft_keys(Key_use_array*,JOIN_TAB*,Item*,table_map)" -> "has_trivial_destructor>::push_back(const Element_type&) [with Element_type = Key_use,bool has_trivial_destructor = true]"
"add_ft_keys(Key_use_array*,JOIN_TAB*,Item*,table_map)" -> "add_ft_keys(Key_use_array*,JOIN_TAB*,Item*,table_map)"
"add_ft_keys(Key_use_array*,JOIN_TAB*,Item*,table_map)" -> "Item_func::arguments() const"
"add_key_fields_for_nj(JOIN*,TABLE_LIST*,Key_field**,uint*,SARGABLE_PARAM**)" -> "TABLE_LIST::join_cond() const"
"add_key_fields_for_nj(JOIN*,TABLE_LIST*,Key_field**,uint*,SARGABLE_PARAM**)" -> "List_iterator<T>::List_iterator(List<T>&) [with T = TABLE_LIST]"
"add_key_fields_for_nj(JOIN*,TABLE_LIST*,Key_field**,uint*,SARGABLE_PARAM**)" -> "add_key_fields_for_nj(JOIN*,TABLE_LIST*,Key_field**,uint*,SARGABLE_PARAM**)"
"add_key_fields_for_nj(JOIN*,TABLE_LIST*,Key_field**,uint*,SARGABLE_PARAM**)" -> "List_iterator<T>::operator++(int) [with T = TABLE_LIST]"
"add_key_fields_for_nj(JOIN*,TABLE_LIST*,Key_field**,uint*,SARGABLE_PARAM**)" -> "add_key_fields(JOIN*,Key_field**,uint*,Item*,table_map,SARGABLE_PARAM**)"
"add_key_fields(JOIN*,Key_field**,uint*,Item*,table_map,SARGABLE_PARAM**)" -> "Item_equal_iterator::operator++(int)"
"add_key_fields(JOIN*,Key_field**,uint*,Item*,table_map,SARGABLE_PARAM**)" -> "Item_func::argument_count() const"
"add_key_fields(JOIN*,Key_field**,uint*,Item*,table_map,SARGABLE_PARAM**)" -> "merge_key_fields(Key_field*,Key_field*,Key_field*,uint)"
"add_key_fields(JOIN*,Key_field**,uint*,Item*,table_map,SARGABLE_PARAM**)" -> "add_key_field(Key_field**,uint,Item_func*,Field*,bool,Item**,uint,table_map,SARGABLE_PARAM**)"
"add_key_fields(JOIN*,Key_field**,uint*,Item*,table_map,SARGABLE_PARAM**)" -> "Item_null::Item_null()"
"add_key_fields(JOIN*,Key_field**,uint*,Item*,table_map,SARGABLE_PARAM**)" -> "JOIN::ORDER_with_src::operator ORDER*()"
"add_key_fields(JOIN*,Key_field**,uint*,Item*,table_map,SARGABLE_PARAM**)" -> "Item_func_trig_cond::get_trig_var()"
"add_key_fields(JOIN*,Key_field**,uint*,Item*,table_map,SARGABLE_PARAM**)" -> "Item_equal::get_const()"
"add_key_fields(JOIN*,Key_field**,uint*,Item*,table_map,SARGABLE_PARAM**)" -> "List_iterator_fast<T>::operator++(int) [with T = Item]"
"add_key_fields(JOIN*,Key_field**,uint*,Item*,table_map,SARGABLE_PARAM**)" -> "st_select_lex_unit::is_union()"
"add_key_fields(JOIN*,Key_field**,uint*,Item*,table_map,SARGABLE_PARAM**)" -> "List_iterator_fast<T>::List_iterator_fast(List<T>&) [with T = Item]"
"add_key_fields(JOIN*,Key_field**,uint*,Item*,table_map,SARGABLE_PARAM**)" -> "__builtin_expect(long int,long int)"
"add_key_fields(JOIN*,Key_field**,uint*,Item*,table_map,SARGABLE_PARAM**)" -> "Item_equal_iterator::Item_equal_iterator(Item_equal&)"
"add_key_fields(JOIN*,Key_field**,uint*,Item*,table_map,SARGABLE_PARAM**)" -> "Item_func::arguments() const"
"add_key_fields(JOIN*,Key_field**,uint*,Item*,table_map,SARGABLE_PARAM**)" -> "add_key_equal_fields(Key_field**,uint,Item_func*,Item_field*,bool,Item**,uint,table_map,SARGABLE_PARAM**)"
"add_key_fields(JOIN*,Key_field**,uint*,Item*,table_map,SARGABLE_PARAM**)" -> "add_key_fields(JOIN*,Key_field**,uint*,Item*,table_map,SARGABLE_PARAM**)"
"add_key_fields(JOIN*,Key_field**,uint*,Item*,table_map,SARGABLE_PARAM**)" -> "Item_cond::argument_list()"
"add_key_fields(JOIN*,Key_field**,uint*,Item*,table_map,SARGABLE_PARAM**)" -> "Item_equal_iterator::rewind()"
"add_key_fields(JOIN*,Key_field**,uint*,Item*,table_map,SARGABLE_PARAM**)" -> "is_local_field(Item*)"
"merge_key_fields(Key_field*,Key_field*,Key_field*,uint)" -> "__builtin_memcpy(void*,const void*,long unsigned int)"
"merge_key_fields(Key_field*,Key_field*,Key_field*,uint)" -> "Item::eq_by_collation(Item*,bool,const CHARSET_INFO*)"
"add_key_field(Key_field**,uint,Item_func*,Field*,bool,Item**,uint,table_map,SARGABLE_PARAM**)" -> "Key_field::Key_field(Field*,Item*,uint,uint,bool,bool,bool*,uint)"
"add_key_field(Key_field**,uint,Item_func*,Field*,bool,Item**,uint,table_map,SARGABLE_PARAM**)" -> "Field::real_maybe_null() const"
"add_key_field(Key_field**,uint,Item_func*,Field*,bool,Item**,uint,table_map,SARGABLE_PARAM**)" -> "Field::is_temporal() const"
"add_key_field(Key_field**,uint,Item_func*,Field*,bool,Item**,uint,table_map,SARGABLE_PARAM**)" -> "TABLE_LIST::uses_materialization() const"
"add_key_field(Key_field**,uint,Item_func*,Field*,bool,Item**,uint,table_map,SARGABLE_PARAM**)" -> "Bitmap<64u>::merge(const Bitmap<64u>&)"
"add_key_field(Key_field**,uint,Item_func*,Field*,bool,Item**,uint,table_map,SARGABLE_PARAM**)" -> "Field::maybe_null() const"
"add_key_field(Key_field**,uint,Item_func*,Field*,bool,Item**,uint,table_map,SARGABLE_PARAM**)" -> "warn_index_not_applicable(THD*,const Field*,key_map)"
"add_key_field(Key_field**,uint,Item_func*,Field*,bool,Item**,uint,table_map,SARGABLE_PARAM**)" -> "get_semi_join_select_list_index(Field*)"
"add_key_field(Key_field**,uint,Item_func*,Field*,bool,Item**,uint,table_map,SARGABLE_PARAM**)" -> "Item::is_temporal() const"
"add_key_field(Key_field**,uint,Item_func*,Field*,bool,Item**,uint,table_map,SARGABLE_PARAM**)" -> "TABLE_LIST::update_derived_keys(Field*,Item**,uint)"
"add_key_field(Key_field**,uint,Item_func*,Field*,bool,Item**,uint,table_map,SARGABLE_PARAM**)" -> "TABLE::is_created() const"
"add_key_field(Key_field**,uint,Item_func*,Field*,bool,Item**,uint,table_map,SARGABLE_PARAM**)" -> "field_time_cmp_date(const Field*,const Item*)"
"add_key_field(Key_field**,uint,Item_func*,Field*,bool,Item**,uint,table_map,SARGABLE_PARAM**)" -> "Bitmap<64u>::intersect(const Bitmap<64u>&)"
"warn_index_not_applicable(THD*,const Field*,key_map)" -> "push_warning_printf(THD*,Sql_condition::enum_warning_level,uint,const char*,...)"
"warn_index_not_applicable(THD*,const Field*,key_map)" -> "Bitmap<64u>::is_set(uint) const"
"warn_index_not_applicable(THD*,const Field*,key_map)" -> "_current_thd()"
"get_semi_join_select_list_index(Field*)" -> "List_iterator<T>::List_iterator(List<T>&) [with T = Item]"
"get_semi_join_select_list_index(Field*)" -> "List_iterator<T>::operator++(int) [with T = Item]"
"TABLE_LIST::update_derived_keys(Field*,Item**,uint)" -> "Bitmap<64u>::set_all()"
"TABLE_LIST::update_derived_keys(Field*,Item**,uint)" -> "add_derived_key(List<Derived_key>&,Field*,table_map)"
"TABLE_LIST::update_derived_keys(Field*,Item**,uint)" -> "LEX::is_ps_or_view_context_analysis()"
"add_derived_key(List<Derived_key>&,Field*,table_map)" -> "Bitmap<64u>::set_bit(uint)"
"add_derived_key(List<Derived_key>&,Field*,table_map)" -> "Derived_key::Derived_key()"
"add_derived_key(List<Derived_key>&,Field*,table_map)" -> "List_iterator<T>::operator++(int) [with T = Derived_key]"
"add_derived_key(List<Derived_key>&,Field*,table_map)" -> "List<T>::push_back(T*,MEM_ROOT*) [with T = Derived_key,MEM_ROOT = st_mem_root]"
"add_derived_key(List<Derived_key>&,Field*,table_map)" -> "Bitmap<default_width>::set_bit(uint) [with unsigned int default_width = 4096u,uint = unsigned int]"
"add_derived_key(List<Derived_key>&,Field*,table_map)" -> "List_iterator<T>::List_iterator(List<T>&) [with T = Derived_key]"
"add_derived_key(List<Derived_key>&,Field*,table_map)" -> "Bitmap<default_width>::clear_all() [with unsigned int default_width = 4096u]"
"add_derived_key(List<Derived_key>&,Field*,table_map)" -> "Bitmap<default_width>::bits_set() const [with unsigned int default_width = 4096u,uint = unsigned int]"
"Derived_key::Derived_key()" -> "Sql_alloc::Sql_alloc()"
"Derived_key::Derived_key()" -> "Bitmap<default_width>::Bitmap() [with unsigned int default_width = 4096u]"
"List_iterator<T>::operator++(int) [with T = Derived_key]" -> "base_list_iterator::next()"
"List<T>::push_back(T*,MEM_ROOT*) [with T = Derived_key,MEM_ROOT = st_mem_root]" -> "base_list::push_back(void*,MEM_ROOT*)"
"List_iterator<T>::List_iterator(List<T>&) [with T = Derived_key]" -> "base_list_iterator::base_list_iterator(base_list&)"
"Bitmap<default_width>::clear_all() [with unsigned int default_width = 4096u]" -> "memset(void*,int,size_t)"
"Bitmap<default_width>::bits_set() const [with unsigned int default_width = 4096u,uint = unsigned int]" -> "bitmap_bits_set(const MY_BITMAP*)"
"add_key_equal_fields(Key_field**,uint,Item_func*,Item_field*,bool,Item**,uint,table_map,SARGABLE_PARAM**)" -> "add_key_field(Key_field**,uint,Item_func*,Field*,bool,Item**,uint,table_map,SARGABLE_PARAM**)"
"add_key_equal_fields(Key_field**,uint,Item_func*,Item_field*,bool,Item**,uint,table_map,SARGABLE_PARAM**)" -> "Item_equal_iterator::Item_equal_iterator(Item_equal&)"
"add_key_equal_fields(Key_field**,uint,Item_func*,Item_field*,bool,Item**,uint,table_map,SARGABLE_PARAM**)" -> "Item_equal_iterator::operator++(int)"
"Item_equal_iterator::rewind()" -> "List_iterator_fast<T>::rewind() [with T = Item_field]"
"List_iterator_fast<T>::rewind() [with T = Item_field]" -> "base_list_iterator::rewind()"
"print_keyuse_array(Opt_trace_context*,const Key_use_array*)" -> "Opt_trace_context::is_started() const"
"print_keyuse_array(Opt_trace_context*,const Key_use_array*)" -> "Opt_trace_object::Opt_trace_object(Opt_trace_context*,Opt_trace_context::feature_value)"
"print_keyuse_array(Opt_trace_context*,const Key_use_array*)" -> "has_trivial_destructor>::size() const [with Element_type = Key_use,bool has_trivial_destructor = true,size_t = long unsigned int]"
"print_keyuse_array(Opt_trace_context*,const Key_use_array*)" -> "__builtin_expect(long int,long int)"
"print_keyuse_array(Opt_trace_context*,const Key_use_array*)" -> "Opt_trace_array::Opt_trace_array(Opt_trace_context*,const char*,Opt_trace_context::feature_value)"
"print_keyuse_array(Opt_trace_context*,const Key_use_array*)" -> "Opt_trace_struct::add_utf8_table(const TABLE*)"
"print_keyuse_array(Opt_trace_context*,const Key_use_array*)" -> "Opt_trace_struct::add(const char*,bool)"
"print_keyuse_array(Opt_trace_context*,const Key_use_array*)" -> "Opt_trace_struct::add_utf8(const char*,const char*)"
"print_keyuse_array(Opt_trace_context*,const Key_use_array*)" -> "Opt_trace_struct::add(const char*,Item*)"
"print_keyuse_array(Opt_trace_context*,const Key_use_array*)" -> "has_trivial_destructor>::at(size_t) const [with Element_type = Key_use,bool has_trivial_destructor = true,size_t = long unsigned int]"
"JOIN::generate_derived_keys()" -> "TABLE_LIST::uses_materialization() const"
"JOIN::generate_derived_keys()" -> "TABLE_LIST::generate_keys()"
"JOIN::generate_derived_keys()" -> "TABLE::is_created() const"
"TABLE_LIST::generate_keys()" -> "TABLE::alloc_keys(uint)"
"TABLE_LIST::generate_keys()" -> "sprintf(char*,const char*,...)"
"TABLE_LIST::generate_keys()" -> "base_list::sort(Node_cmp_func,void*)"
"TABLE_LIST::generate_keys()" -> "List_iterator<T>::operator++(int) [with T = Derived_key]"
"TABLE_LIST::generate_keys()" -> "List_iterator<T>::List_iterator(List<T>&) [with T = Derived_key]"
"TABLE_LIST::generate_keys()" -> "Query_arena::strdup(const char*)"
"TABLE_LIST::generate_keys()" -> "TABLE::add_tmp_key(Field_map*,char*)"
"TABLE::alloc_keys(uint)" -> "alloc_root(MEM_ROOT*,size_t)"
"TABLE::alloc_keys(uint)" -> "memset(void*,int,size_t)"
"TABLE::add_tmp_key(Field_map*,char*)" -> "Bitmap<default_width>::is_set(uint) const [with unsigned int default_width = 4096u,my_bool = char,uint = unsigned int]"
"TABLE::add_tmp_key(Field_map*,char*)" -> "KEY_PART_INFO::init_from_field(Field*)"
"TABLE::add_tmp_key(Field_map*,char*)" -> "alloc_root(MEM_ROOT*,size_t)"
"TABLE::add_tmp_key(Field_map*,char*)" -> "memset(void*,int,size_t)"
"TABLE::add_tmp_key(Field_map*,char*)" -> "Bitmap<64u>::set_bit(uint)"
"TABLE::add_tmp_key(Field_map*,char*)" -> "Bitmap<default_width>::bits_set() const [with unsigned int default_width = 4096u,uint = unsigned int]"
"Bitmap<default_width>::is_set(uint) const [with unsigned int default_width = 4096u,my_bool = char,uint = unsigned int]" -> "bitmap_is_set(const MY_BITMAP*,uint)"
"TABLE_LIST::fetch_number_of_rows()" -> "st_select_lex_unit::get_result()"
"TABLE_LIST::fetch_number_of_rows()" -> "TABLE_LIST::uses_materialization() const"
"JOIN::decide_subquery_strategy()" -> "Item_in_subselect::finalize_materialization_transform(JOIN*)"
"JOIN::decide_subquery_strategy()" -> "JOIN::compare_costs_of_subquery_strategies(Item_exists_subselect::enum_exec_method*)"
"JOIN::decide_subquery_strategy()" -> "Item_in_subselect::finalize_exists_transform(SELECT_LEX*)"
"Item_in_subselect::finalize_materialization_transform(JOIN*)" -> "Item_in_subselect::remove_in2exists_conds(Item*)"
"Item_in_subselect::finalize_materialization_transform(JOIN*)" -> "st_select_lex_unit::get_unit_column_types()"
"Item_in_subselect::finalize_materialization_transform(JOIN*)" -> "Item_subselect::change_engine(subselect_engine*)"
"Item_in_subselect::finalize_materialization_transform(JOIN*)" -> "Opt_trace_struct::add(const char*,bool)"
"Item_in_subselect::finalize_materialization_transform(JOIN*)" -> "Opt_trace_struct::add_select_number(uint)"
"Item_in_subselect::finalize_materialization_transform(JOIN*)" -> "Opt_trace_object::Opt_trace_object(Opt_trace_context*,const char*,Opt_trace_context::feature_value)"
"Item_in_subselect::finalize_materialization_transform(JOIN*)" -> "subselect_hash_sj_engine::setup(List<Item>*)"
"Item_in_subselect::finalize_materialization_transform(JOIN*)" -> "Opt_trace_object::Opt_trace_object(Opt_trace_context*,Opt_trace_context::feature_value)"
"Item_in_subselect::finalize_materialization_transform(JOIN*)" -> "Opt_trace_struct::add_alnum(const char*,const char*)"
"Item_in_subselect::finalize_materialization_transform(JOIN*)" -> "subselect_hash_sj_engine::subselect_hash_sj_engine(THD*,Item_subselect*,subselect_single_select_engine*)"
"Item_in_subselect::remove_in2exists_conds(Item*)" -> "List_iterator<T>::operator++(int) [with T = Item]"
"Item_in_subselect::remove_in2exists_conds(Item*)" -> "List<T>::head() [with T = Item]"
"Item_in_subselect::remove_in2exists_conds(Item*)" -> "Item_cond::argument_list()"
"Item_in_subselect::remove_in2exists_conds(Item*)" -> "List_iterator<T>::remove() [with T = Item]"
"Item_in_subselect::remove_in2exists_conds(Item*)" -> "List_iterator<T>::List_iterator(List<T>&) [with T = Item]"
"st_select_lex_unit::get_unit_column_types()" -> "st_select_lex_unit::first_select()"
"st_select_lex_unit::get_unit_column_types()" -> "st_select_lex_unit::is_union()"
"subselect_hash_sj_engine::setup(List<Item>*)" -> "JOIN::change_result(select_result*)"
"subselect_hash_sj_engine::setup(List<Item>*)" -> "Name_resolution_context::Name_resolution_context()"
"subselect_hash_sj_engine::setup(List<Item>*)" -> "Query_arena::alloc(size_t)"
"subselect_hash_sj_engine::setup(List<Item>*)" -> "store_key_item::store_key_item(THD*,Field*,uchar*,uchar*,uint,Item*)"
"subselect_hash_sj_engine::setup(List<Item>*)" -> "select_union::select_union()"
"subselect_hash_sj_engine::setup(List<Item>*)" -> "Item_cond_and::Item_cond_and()"
"subselect_hash_sj_engine::setup(List<Item>*)" -> "select_union::create_result_table(THD*,List<Item>*,bool,ulonglong,const char*,bool,bool)"
"subselect_hash_sj_engine::setup(List<Item>*)" -> "Item_func_eq::Item_func_eq(Item*,Item*)"
"subselect_hash_sj_engine::setup(List<Item>*)" -> "free_tmp_table(THD*,TABLE*)"
"subselect_hash_sj_engine::setup(List<Item>*)" -> "Name_resolution_context::init()"
"subselect_hash_sj_engine::setup(List<Item>*)" -> "Query_arena::calloc(size_t)"
"subselect_hash_sj_engine::setup(List<Item>*)" -> "Item_in_subselect::is_top_level_item()"
"subselect_hash_sj_engine::setup(List<Item>*)" -> "Field::real_maybe_null() const"
"subselect_hash_sj_engine::setup(List<Item>*)" -> "TABLE_LIST::init_one_table(const char*,size_t,const char*,size_t,const char*,thr_lock_type)"
"subselect_hash_sj_engine::setup(List<Item>*)" -> "st_join_table::st_join_table()"
"subselect_hash_sj_engine::setup(List<Item>*)" -> "Item_field::Item_field(THD*,Name_resolution_context*,Field*)"
"subselect_hash_sj_engine::setup(List<Item>*)" -> "Item_cond::add(Item*)"
"Item_cond_and::Item_cond_and()" -> "COND_EQUAL::COND_EQUAL()"
"Item_cond_and::Item_cond_and()" -> "Item_cond::Item_cond()"
"Item_cond::Item_cond()" -> "List<T>::List() [with T = Item]"
"Item_cond::Item_cond()" -> "Item_bool_func::Item_bool_func()"
"subselect_hash_sj_engine::subselect_hash_sj_engine(THD*,Item_subselect*,subselect_single_select_engine*)" -> "subselect_indexsubquery_engine::subselect_indexsubquery_engine(THD*,st_join_table*,Item_subselect*,Item*,Item*,bool,bool)"
"subselect_indexsubquery_engine::subselect_indexsubquery_engine(THD*,st_join_table*,Item_subselect*,Item*,Item*,bool,bool)" -> "subselect_engine::subselect_engine(Item_subselect*,select_result_interceptor*)"
"JOIN::compare_costs_of_subquery_strategies(Item_exists_subselect::enum_exec_method*)" -> "Optimize_table_order::Optimize_table_order(THD*,JOIN*,TABLE_LIST*)"
"JOIN::compare_costs_of_subquery_strategies(Item_exists_subselect::enum_exec_method*)" -> "Opt_trace_struct::add_utf8_table(const TABLE*)"
"JOIN::compare_costs_of_subquery_strategies(Item_exists_subselect::enum_exec_method*)" -> "subquery_allows_materialization(Item_in_subselect*,THD*,SELECT_LEX*,const SELECT_LEX*)"
"JOIN::compare_costs_of_subquery_strategies(Item_exists_subselect::enum_exec_method*)" -> "Item_in_subselect::in2exists_added_to_where() const"
"JOIN::compare_costs_of_subquery_strategies(Item_exists_subselect::enum_exec_method*)" -> "Opt_trace_array::Opt_trace_array(Opt_trace_context*,const char*,Opt_trace_context::feature_value)"
"JOIN::compare_costs_of_subquery_strategies(Item_exists_subselect::enum_exec_method*)" -> "st_select_lex::is_cacheable() const"
"JOIN::compare_costs_of_subquery_strategies(Item_exists_subselect::enum_exec_method*)" -> "calculate_materialization_costs(JOIN*,TABLE_LIST*,uint,Semijoin_mat_optimize*)"
"JOIN::compare_costs_of_subquery_strategies(Item_exists_subselect::enum_exec_method*)" -> "Opt_trace_struct::add_select_number(uint)"
"JOIN::compare_costs_of_subquery_strategies(Item_exists_subselect::enum_exec_method*)" -> "Opt_trace_object::Opt_trace_object(Opt_trace_context*,Opt_trace_context::feature_value)"
"JOIN::compare_costs_of_subquery_strategies(Item_exists_subselect::enum_exec_method*)" -> "JOIN::plan_is_const() const"
"JOIN::compare_costs_of_subquery_strategies(Item_exists_subselect::enum_exec_method*)" -> "optimize_semijoin_nests_for_materialization(JOIN*)"
"JOIN::compare_costs_of_subquery_strategies(Item_exists_subselect::enum_exec_method*)" -> "Semijoin_mat_optimize::Semijoin_mat_optimize()"
"JOIN::compare_costs_of_subquery_strategies(Item_exists_subselect::enum_exec_method*)" -> "Opt_trace_object::Opt_trace_object(Opt_trace_context*,const char*,Opt_trace_context::feature_value)"
"JOIN::compare_costs_of_subquery_strategies(Item_exists_subselect::enum_exec_method*)" -> "Opt_trace_struct::add(const char*,double)"
"JOIN::compare_costs_of_subquery_strategies(Item_exists_subselect::enum_exec_method*)" -> "st_position::st_position()"
"JOIN::compare_costs_of_subquery_strategies(Item_exists_subselect::enum_exec_method*)" -> "sj_is_materialize_strategy(uint)"
"JOIN::compare_costs_of_subquery_strategies(Item_exists_subselect::enum_exec_method*)" -> "Optimize_table_order::choose_table_order()"
"JOIN::compare_costs_of_subquery_strategies(Item_exists_subselect::enum_exec_method*)" -> "THD::optimizer_switch_flag(ulonglong) const"
"JOIN::compare_costs_of_subquery_strategies(Item_exists_subselect::enum_exec_method*)" -> "Opt_trace_struct::add_alnum(const char*,const char*)"
"JOIN::compare_costs_of_subquery_strategies(Item_exists_subselect::enum_exec_method*)" -> "Cost_estimate::total_cost() const"
"JOIN::compare_costs_of_subquery_strategies(Item_exists_subselect::enum_exec_method*)" -> "Opt_trace_struct::add(const char*,bool)"
"JOIN::compare_costs_of_subquery_strategies(Item_exists_subselect::enum_exec_method*)" -> "Opt_trace_struct::end()"
"subquery_allows_materialization(Item_in_subselect*,THD*,SELECT_LEX*,const SELECT_LEX*)" -> "st_select_lex_unit::first_select()"
"subquery_allows_materialization(Item_in_subselect*,THD*,SELECT_LEX*,const SELECT_LEX*)" -> "Item_in_subselect::is_top_level_item()"
"subquery_allows_materialization(Item_in_subselect*,THD*,SELECT_LEX*,const SELECT_LEX*)" -> "Item::is_blob_field() const"
"subquery_allows_materialization(Item_in_subselect*,THD*,SELECT_LEX*,const SELECT_LEX*)" -> "st_select_lex::is_part_of_union()"
"subquery_allows_materialization(Item_in_subselect*,THD*,SELECT_LEX*,const SELECT_LEX*)" -> "List_iterator<T>::List_iterator(List<T>&) [with T = Item]"
"subquery_allows_materialization(Item_in_subselect*,THD*,SELECT_LEX*,const SELECT_LEX*)" -> "types_allow_materialization(Item*,Item*)"
"subquery_allows_materialization(Item_in_subselect*,THD*,SELECT_LEX*,const SELECT_LEX*)" -> "Item_in_subselect::originally_dependent() const"
"subquery_allows_materialization(Item_in_subselect*,THD*,SELECT_LEX*,const SELECT_LEX*)" -> "Opt_trace_object::Opt_trace_object(Opt_trace_context*,Opt_trace_context::feature_value)"
"subquery_allows_materialization(Item_in_subselect*,THD*,SELECT_LEX*,const SELECT_LEX*)" -> "Opt_trace_struct::add_select_number(uint)"
"subquery_allows_materialization(Item_in_subselect*,THD*,SELECT_LEX*,const SELECT_LEX*)" -> "Opt_trace_struct::add(const char*,bool)"
"subquery_allows_materialization(Item_in_subselect*,THD*,SELECT_LEX*,const SELECT_LEX*)" -> "List_iterator<T>::operator++(int) [with T = Item]"
"subquery_allows_materialization(Item_in_subselect*,THD*,SELECT_LEX*,const SELECT_LEX*)" -> "Opt_trace_struct::add_alnum(const char*,const char*)"
"subquery_allows_materialization(Item_in_subselect*,THD*,SELECT_LEX*,const SELECT_LEX*)" -> "Opt_trace_object::Opt_trace_object(Opt_trace_context*,const char*,Opt_trace_context::feature_value)"
"Semijoin_mat_optimize::Semijoin_mat_optimize()" -> "Cost_estimate::Cost_estimate()"
"Item_in_subselect::finalize_exists_transform(SELECT_LEX*)" -> "Item_int::Item_int(int32,uint)"
"Item_in_subselect::finalize_exists_transform(SELECT_LEX*)" -> "Query_arena::is_conventional() const"
"Item_in_subselect::finalize_exists_transform(SELECT_LEX*)" -> "Item_int::Item_int(const Name_string&,longlong,uint)"
"Item_in_subselect::finalize_exists_transform(SELECT_LEX*)" -> "Opt_trace_struct::add(const char*,bool)"
"Item_in_subselect::finalize_exists_transform(SELECT_LEX*)" -> "Name_string::Name_string(const char*,size_t)"
"Item_in_subselect::finalize_exists_transform(SELECT_LEX*)" -> "Opt_trace_object::Opt_trace_object(Opt_trace_context*,Opt_trace_context::feature_value)"
"Item_in_subselect::finalize_exists_transform(SELECT_LEX*)" -> "st_select_lex_unit::set_limit(st_select_lex*)"
"Item_in_subselect::finalize_exists_transform(SELECT_LEX*)" -> "base_list::empty()"
"Item_in_subselect::finalize_exists_transform(SELECT_LEX*)" -> "Opt_trace_struct::add_alnum(const char*,const char*)"
"Item_in_subselect::finalize_exists_transform(SELECT_LEX*)" -> "Opt_trace_struct::add_select_number(uint)"
"Item_in_subselect::finalize_exists_transform(SELECT_LEX*)" -> "List<T>::push_back(T*) [with T = Item]"
"Item_in_subselect::finalize_exists_transform(SELECT_LEX*)" -> "Opt_trace_object::Opt_trace_object(Opt_trace_context*,const char*,Opt_trace_context::feature_value)"
"join_read_const_table(JOIN_TAB*,POSITION*)" -> "memset(void*,int,size_t)"
"join_read_const_table(JOIN_TAB*,POSITION*)" -> "mark_as_null_row(TABLE*)"
"join_read_const_table(JOIN_TAB*,POSITION*)" -> "join_read_system(JOIN_TAB*)"
"join_read_const_table(JOIN_TAB*,POSITION*)" -> "Bitmap<64u>::is_set(uint) const"
"join_read_const_table(JOIN_TAB*,POSITION*)" -> "join_read_const(JOIN_TAB*)"
"join_read_const_table(JOIN_TAB*,POSITION*)" -> "update_const_equal_items(Item*,JOIN_TAB*)"
"join_read_const_table(JOIN_TAB*,POSITION*)" -> "TABLE::set_keyread(bool)"
"join_read_const_table(JOIN_TAB*,POSITION*)" -> "TABLE_LIST::join_cond() const"
"join_read_const_table(JOIN_TAB*,POSITION*)" -> "List<T>::head() [with T = TABLE_LIST]"
"join_read_system(JOIN_TAB*)" -> "memset(void*,int,size_t)"
"join_read_system(JOIN_TAB*)" -> "report_handler_error(TABLE*,int)"
"join_read_system(JOIN_TAB*)" -> "memcpy(void*,const void*,size_t)"
"join_read_system(JOIN_TAB*)" -> "mark_as_null_row(TABLE*)"
"report_handler_error(TABLE*,int)" -> "sql_print_error(const char*,...)"
"join_read_const(JOIN_TAB*)" -> "mark_as_null_row(TABLE*)"
"join_read_const(JOIN_TAB*)" -> "handler::ha_index_read_idx_map(uchar*,uint,const uchar*,key_part_map,ha_rkey_function)"
"join_read_const(JOIN_TAB*)" -> "memset(void*,int,size_t)"
"join_read_const(JOIN_TAB*)" -> "memcpy(void*,const void*,size_t)"
"join_read_const(JOIN_TAB*)" -> "cp_buffer_from_ref(THD*,TABLE*,TABLE_REF*)"
"join_read_const(JOIN_TAB*)" -> "report_handler_error(TABLE*,int)"
"cp_buffer_from_ref(THD*,TABLE*,TABLE_REF*)" -> "store_key::copy()"
"cp_buffer_from_ref(THD*,TABLE*,TABLE_REF*)" -> "dbug_tmp_use_all_columns(TABLE*,MY_BITMAP*)"
"cp_buffer_from_ref(THD*,TABLE*,TABLE_REF*)" -> "dbug_tmp_restore_column_map(MY_BITMAP*,my_bitmap_map*)"
"update_const_equal_items(Item*,JOIN_TAB*)" -> "Bitmap<64u>::merge(const Bitmap<64u>&)"
"update_const_equal_items(Item*,JOIN_TAB*)" -> "Item_cond::argument_list()"
"update_const_equal_items(Item*,JOIN_TAB*)" -> "Bitmap<64u>::is_set(uint) const"
"update_const_equal_items(Item*,JOIN_TAB*)" -> "Item_equal::get_const()"
"update_const_equal_items(Item*,JOIN_TAB*)" -> "Bitmap<64u>::intersect(const Bitmap<64u>&)"
"update_const_equal_items(Item*,JOIN_TAB*)" -> "Item_equal::update_const()"
"update_const_equal_items(Item*,JOIN_TAB*)" -> "List_iterator_fast<T>::List_iterator_fast(List<T>&) [with T = Item]"
"update_const_equal_items(Item*,JOIN_TAB*)" -> "update_const_equal_items(Item*,JOIN_TAB*)"
"update_const_equal_items(Item*,JOIN_TAB*)" -> "Bitmap<64u>::is_clear_all() const"
"update_const_equal_items(Item*,JOIN_TAB*)" -> "Item_equal_iterator::Item_equal_iterator(Item_equal&)"
"update_const_equal_items(Item*,JOIN_TAB*)" -> "List_iterator_fast<T>::operator++(int) [with T = Item]"
"update_const_equal_items(Item*,JOIN_TAB*)" -> "Item_equal_iterator::operator++(int)"
"Item_equal::update_const()" -> "List_iterator<T>::operator++(int) [with T = Item_field]"
"Item_equal::update_const()" -> "Item_equal::add(Item*)"
"Item_equal::update_const()" -> "List_iterator<T>::List_iterator(List<T>&) [with T = Item_field]"
"Item_equal::update_const()" -> "List_iterator<T>::remove() [with T = Item_field]"
"List_iterator<T>::remove() [with T = Item_field]" -> "base_list_iterator::remove()"
"get_quick_record_count(THD*,SQL_SELECT*,TABLE*,const key_map*,ha_rows)" -> "TABLE_LIST::uses_materialization() const"
"get_quick_record_count(THD*,SQL_SELECT*,TABLE*,const key_map*,ha_rows)" -> "st_select_lex_unit::get_result()"
"get_quick_record_count(THD*,SQL_SELECT*,TABLE*,const key_map*,ha_rows)" -> "TABLE_LIST::materializable_is_const() const"
"get_quick_record_count(THD*,SQL_SELECT*,TABLE*,const key_map*,ha_rows)" -> "TABLE_LIST::get_unit() const"
"get_quick_record_count(THD*,SQL_SELECT*,TABLE*,const key_map*,ha_rows)" -> "SQL_SELECT::test_quick_select(THD*,key_map,table_map,ha_rows,bool,st_order::enum_order)"
"get_quick_record_count(THD*,SQL_SELECT*,TABLE*,const key_map*,ha_rows)" -> "check_stack_overrun(THD*,long int,uchar*)"
"TABLE_LIST::materializable_is_const() const" -> "st_select_lex_unit::get_result()"
"TABLE_LIST::materializable_is_const() const" -> "TABLE_LIST::get_unit() const"
"SQL_SELECT::test_quick_select(THD*,key_map,table_map,ha_rows,bool,st_order::enum_order)" -> "Opt_trace_struct::add(const char*,ulonglong)"
"SQL_SELECT::test_quick_select(THD*,key_map,table_map,ha_rows,bool,st_order::enum_order)" -> "Opt_trace_struct::add(const char*,double)"
"SQL_SELECT::test_quick_select(THD*,key_map,table_map,ha_rows,bool,st_order::enum_order)" -> "free_root(MEM_ROOT*,myf)"
"SQL_SELECT::test_quick_select(THD*,key_map,table_map,ha_rows,bool,st_order::enum_order)" -> "Opt_trace_struct::add_utf8(const char*)"
"SQL_SELECT::test_quick_select(THD*,key_map,table_map,ha_rows,bool,st_order::enum_order)" -> "dbug_print_tree(const char*,SEL_TREE*,const RANGE_OPT_PARAM*)"
"SQL_SELECT::test_quick_select(THD*,key_map,table_map,ha_rows,bool,st_order::enum_order)" -> "List_iterator_fast<T>::List_iterator_fast(List<T>&) [with T = SEL_IMERGE]"
"SQL_SELECT::test_quick_select(THD*,key_map,table_map,ha_rows,bool,st_order::enum_order)" -> "Opt_trace_struct::add_alnum(const char*,const char*)"
"SQL_SELECT::test_quick_select(THD*,key_map,table_map,ha_rows,bool,st_order::enum_order)" -> "SQL_SELECT::set_quick(QUICK_SELECT_I*)"
"SQL_SELECT::test_quick_select(THD*,key_map,table_map,ha_rows,bool,st_order::enum_order)" -> "handler::ha_table_flags() const"
"SQL_SELECT::test_quick_select(THD*,key_map,table_map,ha_rows,bool,st_order::enum_order)" -> "base_list::is_empty() const"
"SQL_SELECT::test_quick_select(THD*,key_map,table_map,ha_rows,bool,st_order::enum_order)" -> "Opt_trace_context::is_started() const"
"SQL_SELECT::test_quick_select(THD*,key_map,table_map,ha_rows,bool,st_order::enum_order)" -> "actual_key_parts(KEY*)"
"SQL_SELECT::test_quick_select(THD*,key_map,table_map,ha_rows,bool,st_order::enum_order)" -> "Opt_trace_struct::add(const char*,bool)"
"SQL_SELECT::test_quick_select(THD*,key_map,table_map,ha_rows,bool,st_order::enum_order)" -> "check_stack_overrun(THD*,long int,uchar*)"
"SQL_SELECT::test_quick_select(THD*,key_map,table_map,ha_rows,bool,st_order::enum_order)" -> "THD::optimizer_switch_flag(ulonglong) const"
"SQL_SELECT::test_quick_select(THD*,key_map,table_map,ha_rows,bool,st_order::enum_order)" -> "Opt_trace_struct::add_utf8(const char*,const char*)"
"SQL_SELECT::test_quick_select(THD*,key_map,table_map,ha_rows,bool,st_order::enum_order)" -> "find_shortest_key(TABLE*,const key_map*)"
"SQL_SELECT::test_quick_select(THD*,key_map,table_map,ha_rows,bool,st_order::enum_order)" -> "fill_used_fields_bitmap(PARAM*)"
"SQL_SELECT::test_quick_select(THD*,key_map,table_map,ha_rows,bool,st_order::enum_order)" -> "init_sql_alloc(MEM_ROOT*,uint,uint)"
"SQL_SELECT::test_quick_select(THD*,key_map,table_map,ha_rows,bool,st_order::enum_order)" -> "get_best_disjunct_quick(PARAM*,SEL_IMERGE*,double)"
"SQL_SELECT::test_quick_select(THD*,key_map,table_map,ha_rows,bool,st_order::enum_order)" -> "List_iterator_fast<T>::operator++(int) [with T = SEL_IMERGE]"
"SQL_SELECT::test_quick_select(THD*,key_map,table_map,ha_rows,bool,st_order::enum_order)" -> "get_best_ror_intersect(const PARAM*,SEL_TREE*,double)"
"SQL_SELECT::test_quick_select(THD*,key_map,table_map,ha_rows,bool,st_order::enum_order)" -> "get_mm_tree(RANGE_OPT_PARAM*,Item*)"
"SQL_SELECT::test_quick_select(THD*,key_map,table_map,ha_rows,bool,st_order::enum_order)" -> "Bitmap<64u>::clear_all()"
"SQL_SELECT::test_quick_select(THD*,key_map,table_map,ha_rows,bool,st_order::enum_order)" -> "alloc_root(MEM_ROOT*,size_t)"
"SQL_SELECT::test_quick_select(THD*,key_map,table_map,ha_rows,bool,st_order::enum_order)" -> "Opt_trace_object::Opt_trace_object(Opt_trace_context*,Opt_trace_context::feature_value)"
"SQL_SELECT::test_quick_select(THD*,key_map,table_map,ha_rows,bool,st_order::enum_order)" -> "std::min(const _Tp&,const _Tp&) [with _Tp = long long unsigned int]"
"SQL_SELECT::test_quick_select(THD*,key_map,table_map,ha_rows,bool,st_order::enum_order)" -> "Bitmap<64u>::is_clear_all() const"
"SQL_SELECT::test_quick_select(THD*,key_map,table_map,ha_rows,bool,st_order::enum_order)" -> "Opt_trace_object::Opt_trace_object(Opt_trace_context*,const char*,Opt_trace_context::feature_value)"
"SQL_SELECT::test_quick_select(THD*,key_map,table_map,ha_rows,bool,st_order::enum_order)" -> "Opt_trace_array::Opt_trace_array(Opt_trace_context*,const char*,Opt_trace_context::feature_value)"
"SQL_SELECT::test_quick_select(THD*,key_map,table_map,ha_rows,bool,st_order::enum_order)" -> "Bitmap<64u>::is_set(uint) const"
"SQL_SELECT::test_quick_select(THD*,key_map,table_map,ha_rows,bool,st_order::enum_order)" -> "__builtin_expect(long int,long int)"
"SQL_SELECT::test_quick_select(THD*,key_map,table_map,ha_rows,bool,st_order::enum_order)" -> "get_key_scans_params(PARAM*,SEL_TREE*,bool,bool,double)"
"SQL_SELECT::test_quick_select(THD*,key_map,table_map,ha_rows,bool,st_order::enum_order)" -> "get_best_group_min_max(PARAM*,SEL_TREE*,double)"
"SQL_SELECT::test_quick_select(THD*,key_map,table_map,ha_rows,bool,st_order::enum_order)" -> "Bitmap<64u>::intersect(const Bitmap<64u>&)"
"Opt_trace_struct::add_utf8(const char*)" -> "__builtin_expect(long int,long int)"
"Opt_trace_struct::add_utf8(const char*)" -> "Opt_trace_struct::do_add(const char*,const char*,size_t,bool)"
"Opt_trace_struct::add_utf8(const char*)" -> "strlen(const char*)"
"List_iterator_fast<T>::List_iterator_fast(List<T>&) [with T = SEL_IMERGE]" -> "base_list_iterator::base_list_iterator(base_list&)"
"find_shortest_key(TABLE*,const key_map*)" -> "Bitmap<64u>::is_set(uint) const"
"find_shortest_key(TABLE*,const key_map*)" -> "Bitmap<64u>::is_clear_all() const"
"fill_used_fields_bitmap(PARAM*)" -> "bitmap_clear_bit(MY_BITMAP*,uint)"
"fill_used_fields_bitmap(PARAM*)" -> "bitmap_union(MY_BITMAP*,const MY_BITMAP*)"
"fill_used_fields_bitmap(PARAM*)" -> "bitmap_copy(MY_BITMAP*,const MY_BITMAP*)"
"fill_used_fields_bitmap(PARAM*)" -> "alloc_root(MEM_ROOT*,size_t)"
"fill_used_fields_bitmap(PARAM*)" -> "bitmap_init(MY_BITMAP*,my_bitmap_map*,uint,my_bool)"
"get_best_disjunct_quick(PARAM*,SEL_IMERGE*,double)" -> "Unique::get_use_cost(uint*,uint,uint,ulonglong)"
"get_best_disjunct_quick(PARAM*,SEL_IMERGE*,double)" -> "Opt_trace_struct::add(const char*,uint)"
"get_best_disjunct_quick(PARAM*,SEL_IMERGE*,double)" -> "Opt_trace_struct::add_utf8(const char*,const char*)"
"get_best_disjunct_quick(PARAM*,SEL_IMERGE*,double)" -> "get_sweep_read_cost(TABLE*,ha_rows,bool,Cost_estimate*)"
"get_best_disjunct_quick(PARAM*,SEL_IMERGE*,double)" -> "Opt_trace_array::Opt_trace_array(Opt_trace_context*,const char*,Opt_trace_context::feature_value)"
"get_best_disjunct_quick(PARAM*,SEL_IMERGE*,double)" -> "alloc_root(MEM_ROOT*,size_t)"
"get_best_disjunct_quick(PARAM*,SEL_IMERGE*,double)" -> "Opt_trace_struct::end()"
"get_best_disjunct_quick(PARAM*,SEL_IMERGE*,double)" -> "TRP_INDEX_MERGE::TRP_INDEX_MERGE()"
"get_best_disjunct_quick(PARAM*,SEL_IMERGE*,double)" -> "std::min(const _Tp&,const _Tp&) [with _Tp = long long unsigned int]"
"get_best_disjunct_quick(PARAM*,SEL_IMERGE*,double)" -> "Opt_trace_struct::add(const char*,double)"
"get_best_disjunct_quick(PARAM*,SEL_IMERGE*,double)" -> "Opt_trace_struct::add(const char*,bool)"
"get_best_disjunct_quick(PARAM*,SEL_IMERGE*,double)" -> "TRP_ROR_UNION::TRP_ROR_UNION()"
"get_best_disjunct_quick(PARAM*,SEL_IMERGE*,double)" -> "Opt_trace_context::is_started() const"
"get_best_disjunct_quick(PARAM*,SEL_IMERGE*,double)" -> "Cost_estimate::total_cost() const"
"get_best_disjunct_quick(PARAM*,SEL_IMERGE*,double)" -> "Cost_estimate::Cost_estimate()"
"get_best_disjunct_quick(PARAM*,SEL_IMERGE*,double)" -> "get_key_scans_params(PARAM*,SEL_TREE*,bool,bool,double)"
"get_best_disjunct_quick(PARAM*,SEL_IMERGE*,double)" -> "log(double)"
"get_best_disjunct_quick(PARAM*,SEL_IMERGE*,double)" -> "Opt_trace_struct::add_alnum(const char*,const char*)"
"get_best_disjunct_quick(PARAM*,SEL_IMERGE*,double)" -> "__builtin_expect(long int,long int)"
"get_best_disjunct_quick(PARAM*,SEL_IMERGE*,double)" -> "THD::optimizer_switch_flag(ulonglong) const"
"get_best_disjunct_quick(PARAM*,SEL_IMERGE*,double)" -> "get_best_ror_intersect(const PARAM*,SEL_TREE*,double)"
"get_best_disjunct_quick(PARAM*,SEL_IMERGE*,double)" -> "Unique::get_cost_calc_buff_size(ulong,uint,ulonglong)"
"get_best_disjunct_quick(PARAM*,SEL_IMERGE*,double)" -> "Opt_trace_object::Opt_trace_object(Opt_trace_context*,Opt_trace_context::feature_value)"
"Unique::get_use_cost(uint*,uint,uint,ulonglong)" -> "get_merge_many_buffs_cost(uint*,uint,uint,uint,int)"
"Unique::get_use_cost(uint*,uint,uint,ulonglong)" -> "ceil(double)"
"Unique::get_use_cost(uint*,uint,uint,ulonglong)" -> "log2_n_fact(double)"
"get_merge_many_buffs_cost(uint*,uint,uint,uint,int)" -> "get_merge_buffers_cost(uint*,uint,uint*,uint*)"
"get_merge_buffers_cost(uint*,uint,uint*,uint*)" -> "log(double)"
"log2_n_fact(double)" -> "log(double)"
"get_sweep_read_cost(TABLE*,ha_rows,bool,Cost_estimate*)" -> "Cost_estimate::add_io(double)"
"get_sweep_read_cost(TABLE*,ha_rows,bool,Cost_estimate*)" -> "Cost_estimate::IO_BLOCK_READ_COST()"
"get_sweep_read_cost(TABLE*,ha_rows,bool,Cost_estimate*)" -> "pow(double,double)"
"get_sweep_read_cost(TABLE*,ha_rows,bool,Cost_estimate*)" -> "ceil(double)"
"TRP_INDEX_MERGE::TRP_INDEX_MERGE()" -> "TABLE_READ_PLAN::TABLE_READ_PLAN()"
"TRP_ROR_UNION::TRP_ROR_UNION()" -> "TABLE_READ_PLAN::TABLE_READ_PLAN()"
"get_key_scans_params(PARAM*,SEL_TREE*,bool,bool,double)" -> "Opt_trace_struct::add(const char*,double)"
"get_key_scans_params(PARAM*,SEL_TREE*,bool,bool,double)" -> "append_range_all_keyparts(Opt_trace_array*,String*,String*,SEL_ARG*,const KEY_PART_INFO*)"
"get_key_scans_params(PARAM*,SEL_TREE*,bool,bool,double)" -> "check_quick_select(PARAM*,uint,bool,SEL_ARG*,bool,uint*,uint*,Cost_estimate*)"
"get_key_scans_params(PARAM*,SEL_TREE*,bool,bool,double)" -> "Cost_estimate::Cost_estimate()"
"get_key_scans_params(PARAM*,SEL_TREE*,bool,bool,double)" -> "String::set_charset(const CHARSET_INFO*)"
"get_key_scans_params(PARAM*,SEL_TREE*,bool,bool,double)" -> "Bitmap<64u>::clear_all()"
"get_key_scans_params(PARAM*,SEL_TREE*,bool,bool,double)" -> "Opt_trace_struct::add(const char*,bool)"
"get_key_scans_params(PARAM*,SEL_TREE*,bool,bool,double)" -> "Bitmap<64u>::set_bit(uint)"
"get_key_scans_params(PARAM*,SEL_TREE*,bool,bool,double)" -> "Opt_trace_struct::end()"
"get_key_scans_params(PARAM*,SEL_TREE*,bool,bool,double)" -> "Opt_trace_object::Opt_trace_object(Opt_trace_context*,Opt_trace_context::feature_value)"
"get_key_scans_params(PARAM*,SEL_TREE*,bool,bool,double)" -> "Cost_estimate::total_cost() const"
"get_key_scans_params(PARAM*,SEL_TREE*,bool,bool,double)" -> "Opt_trace_struct::add_utf8(const char*,const char*)"
"get_key_scans_params(PARAM*,SEL_TREE*,bool,bool,double)" -> "Opt_trace_context::is_started() const"
"get_key_scans_params(PARAM*,SEL_TREE*,bool,bool,double)" -> "Opt_trace_struct::add(const char*,ulonglong)"
"get_key_scans_params(PARAM*,SEL_TREE*,bool,bool,double)" -> "Bitmap<64u>::is_set(uint) const"
"get_key_scans_params(PARAM*,SEL_TREE*,bool,bool,double)" -> "Opt_trace_struct::add_alnum(const char*,const char*)"
"get_key_scans_params(PARAM*,SEL_TREE*,bool,bool,double)" -> "String::String()"
"get_key_scans_params(PARAM*,SEL_TREE*,bool,bool,double)" -> "Opt_trace_array::Opt_trace_array(Opt_trace_context*,const char*,Opt_trace_context::feature_value)"
"get_key_scans_params(PARAM*,SEL_TREE*,bool,bool,double)" -> "TRP_RANGE::TRP_RANGE(SEL_ARG*,uint,uint)"
"append_range_all_keyparts(Opt_trace_array*,String*,String*,SEL_ARG*,const KEY_PART_INFO*)" -> "String::length(uint32)"
"append_range_all_keyparts(Opt_trace_array*,String*,String*,SEL_ARG*,const KEY_PART_INFO*)" -> "String::length() const"
"append_range_all_keyparts(Opt_trace_array*,String*,String*,SEL_ARG*,const KEY_PART_INFO*)" -> "append_range(String*,const KEY_PART_INFO*,const uchar*,const uchar*,uint)"
"append_range_all_keyparts(Opt_trace_array*,String*,String*,SEL_ARG*,const KEY_PART_INFO*)" -> "String::append(const char*,uint32)"
"append_range_all_keyparts(Opt_trace_array*,String*,String*,SEL_ARG*,const KEY_PART_INFO*)" -> "append_range_all_keyparts(Opt_trace_array*,String*,String*,SEL_ARG*,const KEY_PART_INFO*)"
"append_range_all_keyparts(Opt_trace_array*,String*,String*,SEL_ARG*,const KEY_PART_INFO*)" -> "Opt_trace_struct::add_utf8(const char*,size_t)"
"append_range_all_keyparts(Opt_trace_array*,String*,String*,SEL_ARG*,const KEY_PART_INFO*)" -> "SEL_ARG::first()"
"append_range_all_keyparts(Opt_trace_array*,String*,String*,SEL_ARG*,const KEY_PART_INFO*)" -> "SEL_ARG::is_singlepoint() const"
"append_range_all_keyparts(Opt_trace_array*,String*,String*,SEL_ARG*,const KEY_PART_INFO*)" -> "String::ptr() const"
"append_range(String*,const KEY_PART_INFO*,const uchar*,const uchar*,uint)" -> "String::length() const"
"append_range(String*,const KEY_PART_INFO*,const uchar*,const uchar*,uint)" -> "String::append(const char*)"
"append_range(String*,const KEY_PART_INFO*,const uchar*,const uchar*,uint)" -> "String::append(const char*,uint32)"
"append_range(String*,const KEY_PART_INFO*,const uchar*,const uchar*,uint)" -> "print_key_value(String*,const KEY_PART_INFO*,const uchar*)"
"print_key_value(String*,const KEY_PART_INFO*,const uchar*)" -> "dbug_tmp_use_all_columns(TABLE*,my_bitmap_map**,MY_BITMAP*,MY_BITMAP*)"
"print_key_value(String*,const KEY_PART_INFO*,const uchar*)" -> "Field::real_maybe_null() const"
"print_key_value(String*,const KEY_PART_INFO*,const uchar*)" -> "dbug_tmp_restore_column_maps(MY_BITMAP*,MY_BITMAP*,my_bitmap_map**)"
"print_key_value(String*,const KEY_PART_INFO*,const uchar*)" -> "String::ptr() const"
"print_key_value(String*,const KEY_PART_INFO*,const uchar*)" -> "String::length() const"
"print_key_value(String*,const KEY_PART_INFO*,const uchar*)" -> "String::append(const char*,uint32)"
"print_key_value(String*,const KEY_PART_INFO*,const uchar*)" -> "String::append(const char*,uint32,const CHARSET_INFO*)"
"print_key_value(String*,const KEY_PART_INFO*,const uchar*)" -> "Field::val_int_as_str(String*,my_bool)"
"print_key_value(String*,const KEY_PART_INFO*,const uchar*)" -> "String::charset() const"
"print_key_value(String*,const KEY_PART_INFO*,const uchar*)" -> "String::length(uint32)"
"print_key_value(String*,const KEY_PART_INFO*,const uchar*)" -> "String::String(char*,uint32,const CHARSET_INFO*)"
"print_key_value(String*,const KEY_PART_INFO*,const uchar*)" -> "Field::val_str(String*)"
"Field::val_int_as_str(String*,my_bool)" -> "String::length(uint32)"
"Field::val_int_as_str(String*,my_bool)" -> "String::alloc(uint32)"
"Field::val_int_as_str(String*,my_bool)" -> "String::ptr() const"
"check_quick_select(PARAM*,uint,bool,SEL_ARG*,bool,uint*,uint*,Cost_estimate*)" -> "_current_thd()"
"check_quick_select(PARAM*,uint,bool,SEL_ARG*,bool,uint*,uint*,Cost_estimate*)" -> "Bitmap<64u>::set_bit(uint)"
"check_quick_select(PARAM*,uint,bool,SEL_ARG*,bool,uint*,uint*,Cost_estimate*)" -> "std::min(const _Tp&,const _Tp&) [with _Tp = long long unsigned int]"
"check_quick_select(PARAM*,uint,bool,SEL_ARG*,bool,uint*,uint*,Cost_estimate*)" -> "Sel_arg_range_sequence::Sel_arg_range_sequence(PARAM*)"
"check_quick_select(PARAM*,uint,bool,SEL_ARG*,bool,uint*,uint*,Cost_estimate*)" -> "eq_ranges_exceeds_limit(SEL_ARG*,uint*,uint)"
"Sel_arg_range_sequence::Sel_arg_range_sequence(PARAM*)" -> "Sel_arg_range_sequence::reset()"
"eq_ranges_exceeds_limit(SEL_ARG*,uint*,uint)" -> "SEL_ARG::is_null_interval()"
"eq_ranges_exceeds_limit(SEL_ARG*,uint*,uint)" -> "SEL_ARG::first()"
"eq_ranges_exceeds_limit(SEL_ARG*,uint*,uint)" -> "eq_ranges_exceeds_limit(SEL_ARG*,uint*,uint)"
"eq_ranges_exceeds_limit(SEL_ARG*,uint*,uint)" -> "SEL_ARG::cmp_max_to_min(const SEL_ARG*) const"
"TRP_RANGE::TRP_RANGE(SEL_ARG*,uint,uint)" -> "TABLE_READ_PLAN::TABLE_READ_PLAN()"
"get_best_ror_intersect(const PARAM*,SEL_TREE*,double)" -> "Opt_trace_struct::add_utf8(const char*,const char*)"
"get_best_ror_intersect(const PARAM*,SEL_TREE*,double)" -> "Opt_trace_array::Opt_trace_array(Opt_trace_context*,const char*,Opt_trace_context::feature_value)"
"get_best_ror_intersect(const PARAM*,SEL_TREE*,double)" -> "ror_intersect_cpy(ROR_INTERSECT_INFO*,const ROR_INTERSECT_INFO*)"
"get_best_ror_intersect(const PARAM*,SEL_TREE*,double)" -> "Opt_trace_object::Opt_trace_object(Opt_trace_context*,const char*,Opt_trace_context::feature_value)"
"get_best_ror_intersect(const PARAM*,SEL_TREE*,double)" -> "memcpy(void*,const void*,size_t)"
"get_best_ror_intersect(const PARAM*,SEL_TREE*,double)" -> "Opt_trace_struct::add(const char*,ulonglong)"
"get_best_ror_intersect(const PARAM*,SEL_TREE*,double)" -> "ror_intersect_init(const PARAM*)"
"get_best_ror_intersect(const PARAM*,SEL_TREE*,double)" -> "ror_intersect_add(ROR_INTERSECT_INFO*,ROR_SCAN_INFO*,bool,Opt_trace_object*)"
"get_best_ror_intersect(const PARAM*,SEL_TREE*,double)" -> "THD::optimizer_switch_flag(ulonglong) const"
"get_best_ror_intersect(const PARAM*,SEL_TREE*,double)" -> "Opt_trace_struct::add(const char*,bool)"
"get_best_ror_intersect(const PARAM*,SEL_TREE*,double)" -> "Opt_trace_object::Opt_trace_object(Opt_trace_context*,Opt_trace_context::feature_value)"
"get_best_ror_intersect(const PARAM*,SEL_TREE*,double)" -> "Bitmap<64u>::is_set(uint) const"
"get_best_ror_intersect(const PARAM*,SEL_TREE*,double)" -> "find_intersect_order(ROR_SCAN_INFO**,ROR_SCAN_INFO**,const PARAM*)"
"get_best_ror_intersect(const PARAM*,SEL_TREE*,double)" -> "alloc_root(MEM_ROOT*,size_t)"
"get_best_ror_intersect(const PARAM*,SEL_TREE*,double)" -> "Opt_trace_struct::add(const char*,double)"
"get_best_ror_intersect(const PARAM*,SEL_TREE*,double)" -> "Opt_trace_struct::add_alnum(const char*,const char*)"
"get_best_ror_intersect(const PARAM*,SEL_TREE*,double)" -> "make_ror_scan(const PARAM*,int,SEL_ARG*)"
"get_best_ror_intersect(const PARAM*,SEL_TREE*,double)" -> "Opt_trace_struct::end()"
"get_best_ror_intersect(const PARAM*,SEL_TREE*,double)" -> "TRP_ROR_INTERSECT::TRP_ROR_INTERSECT()"
"ror_intersect_cpy(ROR_INTERSECT_INFO*,const ROR_INTERSECT_INFO*)" -> "memcpy(void*,const void*,size_t)"
"ror_intersect_init(const PARAM*)" -> "alloc_root(MEM_ROOT*,size_t)"
"ror_intersect_init(const PARAM*)" -> "memset(void*,int,size_t)"
"ror_intersect_init(const PARAM*)" -> "bitmap_init(MY_BITMAP*,my_bitmap_map*,uint,my_bool)"
"ror_intersect_add(ROR_INTERSECT_INFO*,ROR_SCAN_INFO*,bool,Opt_trace_object*)" -> "get_sweep_read_cost(TABLE*,ha_rows,bool,Cost_estimate*)"
"ror_intersect_add(ROR_INTERSECT_INFO*,ROR_SCAN_INFO*,bool,Opt_trace_object*)" -> "Cost_estimate::Cost_estimate()"
"ror_intersect_add(ROR_INTERSECT_INFO*,ROR_SCAN_INFO*,bool,Opt_trace_object*)" -> "Opt_trace_struct::add(const char*,double)"
"ror_intersect_add(ROR_INTERSECT_INFO*,ROR_SCAN_INFO*,bool,Opt_trace_object*)" -> "ror_scan_selectivity(const ROR_INTERSECT_INFO*,const ROR_SCAN_INFO*)"
"ror_intersect_add(ROR_INTERSECT_INFO*,ROR_SCAN_INFO*,bool,Opt_trace_object*)" -> "bitmap_union(MY_BITMAP*,const MY_BITMAP*)"
"ror_intersect_add(ROR_INTERSECT_INFO*,ROR_SCAN_INFO*,bool,Opt_trace_object*)" -> "bitmap_is_subset(const MY_BITMAP*,const MY_BITMAP*)"
"ror_intersect_add(ROR_INTERSECT_INFO*,ROR_SCAN_INFO*,bool,Opt_trace_object*)" -> "Opt_trace_struct::add(const char*,int)"
"ror_intersect_add(ROR_INTERSECT_INFO*,ROR_SCAN_INFO*,bool,Opt_trace_object*)" -> "Cost_estimate::total_cost() const"
"ror_scan_selectivity(const ROR_INTERSECT_INFO*,const ROR_SCAN_INFO*)" -> "SEL_ARG::store_min(uint,uchar**,uint)"
"ror_scan_selectivity(const ROR_INTERSECT_INFO*,const ROR_SCAN_INFO*)" -> "SEL_ARG::is_null_interval()"
"ror_scan_selectivity(const ROR_INTERSECT_INFO*,const ROR_SCAN_INFO*)" -> "bitmap_is_set(const MY_BITMAP*,uint)"
"Opt_trace_struct::add(const char*,int)" -> "Opt_trace_struct::do_add(const char*,longlong)"
"Opt_trace_struct::add(const char*,int)" -> "__builtin_expect(long int,long int)"
"Opt_trace_struct::do_add(const char*,longlong)" -> "strlen(const char*)"
"Opt_trace_struct::do_add(const char*,longlong)" -> "llstr(longlong,char*)"
"Opt_trace_struct::do_add(const char*,longlong)" -> "Opt_trace_stmt::add(const char*,const char*,size_t,bool,bool)"
"find_intersect_order(ROR_SCAN_INFO**,ROR_SCAN_INFO**,const PARAM*)" -> "bitmap_is_clear_all(const MY_BITMAP*)"
"find_intersect_order(ROR_SCAN_INFO**,ROR_SCAN_INFO**,const PARAM*)" -> "bitmap_copy(MY_BITMAP*,const MY_BITMAP*)"
"find_intersect_order(ROR_SCAN_INFO**,ROR_SCAN_INFO**,const PARAM*)" -> "alloc_root(MEM_ROOT*,size_t)"
"find_intersect_order(ROR_SCAN_INFO**,ROR_SCAN_INFO**,const PARAM*)" -> "bitmap_init(MY_BITMAP*,my_bitmap_map*,uint,my_bool)"
"find_intersect_order(ROR_SCAN_INFO**,ROR_SCAN_INFO**,const PARAM*)" -> "is_better_intersect_match(const ROR_SCAN_INFO*,const ROR_SCAN_INFO*)"
"find_intersect_order(ROR_SCAN_INFO**,ROR_SCAN_INFO**,const PARAM*)" -> "bitmap_bits_set(const MY_BITMAP*)"
"find_intersect_order(ROR_SCAN_INFO**,ROR_SCAN_INFO**,const PARAM*)" -> "bitmap_intersect(MY_BITMAP*,const MY_BITMAP*)"
"find_intersect_order(ROR_SCAN_INFO**,ROR_SCAN_INFO**,const PARAM*)" -> "bitmap_subtract(MY_BITMAP*,const MY_BITMAP*)"
"make_ror_scan(const PARAM*,int,SEL_ARG*)" -> "bitmap_init(MY_BITMAP*,my_bitmap_map*,uint,my_bool)"
"make_ror_scan(const PARAM*,int,SEL_ARG*)" -> "bitmap_is_set(const MY_BITMAP*,uint)"
"make_ror_scan(const PARAM*,int,SEL_ARG*)" -> "bitmap_set_bit(MY_BITMAP*,uint)"
"make_ror_scan(const PARAM*,int,SEL_ARG*)" -> "memset(void*,int,size_t)"
"make_ror_scan(const PARAM*,int,SEL_ARG*)" -> "bitmap_copy(MY_BITMAP*,const MY_BITMAP*)"
"make_ror_scan(const PARAM*,int,SEL_ARG*)" -> "alloc_root(MEM_ROOT*,size_t)"
"TRP_ROR_INTERSECT::TRP_ROR_INTERSECT()" -> "TABLE_READ_PLAN::TABLE_READ_PLAN()"
"List_iterator_fast<T>::operator++(int) [with T = SEL_IMERGE]" -> "base_list_iterator::next_fast()"
"get_best_group_min_max(PARAM*,SEL_TREE*,double)" -> "List_iterator<T>::List_iterator(List<T>&) [with T = Item_field]"
"get_best_group_min_max(PARAM*,SEL_TREE*,double)" -> "String::set_charset(const CHARSET_INFO*)"
"get_best_group_min_max(PARAM*,SEL_TREE*,double)" -> "Opt_trace_struct::add_utf8(const char*,const char*)"
"get_best_group_min_max(PARAM*,SEL_TREE*,double)" -> "Opt_trace_object::Opt_trace_object(Opt_trace_context*,const char*,Opt_trace_context::feature_value)"
"get_best_group_min_max(PARAM*,SEL_TREE*,double)" -> "get_constant_key_infix(KEY*,SEL_ARG*,KEY_PART_INFO*,KEY_PART_INFO*,KEY_PART_INFO*,THD*,uchar*,uint*,KEY_PART_INFO**)"
"get_best_group_min_max(PARAM*,SEL_TREE*,double)" -> "Item_sum::get_arg(uint)"
"get_best_group_min_max(PARAM*,SEL_TREE*,double)" -> "Bitmap<64u>::to_ulonglong() const"
"get_best_group_min_max(PARAM*,SEL_TREE*,double)" -> "Cost_estimate::Cost_estimate()"
"get_best_group_min_max(PARAM*,SEL_TREE*,double)" -> "List<T>::List() [with T = Item_field]"
"get_best_group_min_max(PARAM*,SEL_TREE*,double)" -> "__builtin_expect(long int,long int)"
"get_best_group_min_max(PARAM*,SEL_TREE*,double)" -> "TRP_GROUP_MIN_MAX::TRP_GROUP_MIN_MAX(bool,bool,bool,KEY_PART_INFO*,uint,uint,uint,KEY*,uint,uint,uchar*,SEL_TREE*,SEL_ARG*,uint,ha_rows)"
"get_best_group_min_max(PARAM*,SEL_TREE*,double)" -> "Bitmap<64u>::Bitmap()"
"get_best_group_min_max(PARAM*,SEL_TREE*,double)" -> "bitmap_is_set(const MY_BITMAP*,uint)"
"get_best_group_min_max(PARAM*,SEL_TREE*,double)" -> "Opt_trace_array::Opt_trace_array(Opt_trace_context*,const char*,Opt_trace_context::feature_value)"
"get_best_group_min_max(PARAM*,SEL_TREE*,double)" -> "is_indexed_agg_distinct(JOIN*,List<Item_field>*)"
"get_best_group_min_max(PARAM*,SEL_TREE*,double)" -> "Opt_trace_struct::add_alnum(const char*,const char*)"
"get_best_group_min_max(PARAM*,SEL_TREE*,double)" -> "Bitmap<64u>::is_set(uint) const"
"get_best_group_min_max(PARAM*,SEL_TREE*,double)" -> "append_range_all_keyparts(Opt_trace_array*,String*,String*,SEL_ARG*,const KEY_PART_INFO*)"
"get_best_group_min_max(PARAM*,SEL_TREE*,double)" -> "check_quick_select(PARAM*,uint,bool,SEL_ARG*,bool,uint*,uint*,Cost_estimate*)"
"get_best_group_min_max(PARAM*,SEL_TREE*,double)" -> "Opt_trace_struct::add(const char*,double)"
"get_best_group_min_max(PARAM*,SEL_TREE*,double)" -> "Opt_trace_struct::end()"
"get_best_group_min_max(PARAM*,SEL_TREE*,double)" -> "JOIN::ORDER_with_src::operator ORDER*()"
"get_best_group_min_max(PARAM*,SEL_TREE*,double)" -> "Opt_trace_object::Opt_trace_object(Opt_trace_context*,Opt_trace_context::feature_value)"
"get_best_group_min_max(PARAM*,SEL_TREE*,double)" -> "cost_group_min_max(TABLE*,KEY*,uint,uint,SEL_TREE*,SEL_ARG*,ha_rows,bool,bool,double*,ha_rows*)"
"get_best_group_min_max(PARAM*,SEL_TREE*,double)" -> "std::max(const _Tp&,const _Tp&) [with _Tp = unsigned int]"
"get_best_group_min_max(PARAM*,SEL_TREE*,double)" -> "get_field_keypart(KEY*,Field*)"
"get_best_group_min_max(PARAM*,SEL_TREE*,double)" -> "TRP_GROUP_MIN_MAX::use_index_scan()"
"get_best_group_min_max(PARAM*,SEL_TREE*,double)" -> "actual_key_parts(KEY*)"
"get_best_group_min_max(PARAM*,SEL_TREE*,double)" -> "List_iterator<T>::List_iterator() [with T = Item]"
"get_best_group_min_max(PARAM*,SEL_TREE*,double)" -> "Opt_trace_struct::add(const char*,bool)"
"get_best_group_min_max(PARAM*,SEL_TREE*,double)" -> "get_sel_arg_for_keypart(Field*,SEL_ARG*,SEL_ARG**)"
"get_best_group_min_max(PARAM*,SEL_TREE*,double)" -> "List_iterator<T>::rewind() [with T = Item]"
"get_best_group_min_max(PARAM*,SEL_TREE*,double)" -> "Opt_trace_context::is_started() const"
"get_best_group_min_max(PARAM*,SEL_TREE*,double)" -> "String::String()"
"get_best_group_min_max(PARAM*,SEL_TREE*,double)" -> "Bitmap<64u>::set_bit(uint)"
"get_best_group_min_max(PARAM*,SEL_TREE*,double)" -> "List_iterator<T>::operator++(int) [with T = Item]"
"get_best_group_min_max(PARAM*,SEL_TREE*,double)" -> "handler::ha_table_flags() const"
"get_best_group_min_max(PARAM*,SEL_TREE*,double)" -> "List_iterator<T>::operator++(int) [with T = Item_field]"
"get_best_group_min_max(PARAM*,SEL_TREE*,double)" -> "Opt_trace_struct::add(const char*,ulonglong)"
"get_best_group_min_max(PARAM*,SEL_TREE*,double)" -> "get_index_range_tree(uint,SEL_TREE*,PARAM*,uint*)"
"get_best_group_min_max(PARAM*,SEL_TREE*,double)" -> "check_group_min_max_predicates(Item*,Item_field*,Field::imagetype)"
"get_best_group_min_max(PARAM*,SEL_TREE*,double)" -> "List_iterator<T>::List_iterator(List<T>&) [with T = Item]"
"get_constant_key_infix(KEY*,SEL_ARG*,KEY_PART_INFO*,KEY_PART_INFO*,KEY_PART_INFO*,THD*,uchar*,uint*,KEY_PART_INFO**)" -> "get_sel_arg_for_keypart(Field*,SEL_ARG*,SEL_ARG**)"
"get_constant_key_infix(KEY*,SEL_ARG*,KEY_PART_INFO*,KEY_PART_INFO*,KEY_PART_INFO*,THD*,uchar*,uint*,KEY_PART_INFO**)" -> "memcmp(const void*,const void*,size_t)"
"get_constant_key_infix(KEY*,SEL_ARG*,KEY_PART_INFO*,KEY_PART_INFO*,KEY_PART_INFO*,THD*,uchar*,uint*,KEY_PART_INFO**)" -> "memcpy(void*,const void*,size_t)"
"get_sel_arg_for_keypart(Field*,SEL_ARG*,SEL_ARG**)" -> "SEL_ARG::first()"
"get_sel_arg_for_keypart(Field*,SEL_ARG*,SEL_ARG**)" -> "get_sel_arg_for_keypart(Field*,SEL_ARG*,SEL_ARG**)"
"get_sel_arg_for_keypart(Field*,SEL_ARG*,SEL_ARG**)" -> "all_same(const SEL_ARG*,const SEL_ARG*)"
"all_same(const SEL_ARG*,const SEL_ARG*)" -> "SEL_ARG::all_same(const SEL_ARG*) const"
"SEL_ARG::all_same(const SEL_ARG*) const" -> "SEL_ARG::is_same(const SEL_ARG*) const"
"SEL_ARG::all_same(const SEL_ARG*) const" -> "SEL_ARG::first() const"
"SEL_ARG::first() const" -> "SEL_ARG::first()"
"TRP_GROUP_MIN_MAX::TRP_GROUP_MIN_MAX(bool,bool,bool,KEY_PART_INFO*,uint,uint,uint,KEY*,uint,uint,uchar*,SEL_TREE*,SEL_ARG*,uint,ha_rows)" -> "TABLE_READ_PLAN::TABLE_READ_PLAN()"
"TRP_GROUP_MIN_MAX::TRP_GROUP_MIN_MAX(bool,bool,bool,KEY_PART_INFO*,uint,uint,uint,KEY*,uint,uint,uchar*,SEL_TREE*,SEL_ARG*,uint,ha_rows)" -> "memcpy(void*,const void*,size_t)"
"cost_group_min_max(TABLE*,KEY*,uint,uint,SEL_TREE*,SEL_ARG*,ha_rows,bool,bool,double*,ha_rows*)" -> "std::min(const _Tp&,const _Tp&) [with _Tp = double]"
"cost_group_min_max(TABLE*,KEY*,uint,uint,SEL_TREE*,SEL_ARG*,ha_rows,bool,bool,double*,ha_rows*)" -> "rint(double)"
"cost_group_min_max(TABLE*,KEY*,uint,uint,SEL_TREE*,SEL_ARG*,ha_rows,bool,bool,double*,ha_rows*)" -> "log(double)"
"cost_group_min_max(TABLE*,KEY*,uint,uint,SEL_TREE*,SEL_ARG*,ha_rows,bool,bool,double*,ha_rows*)" -> "ceil(double)"
"get_field_keypart(KEY*,Field*)" -> "actual_key_parts(KEY*)"
"List_iterator<T>::List_iterator() [with T = Item]" -> "base_list_iterator::base_list_iterator()"
"check_group_min_max_predicates(Item*,Item_field*,Field::imagetype)" -> "memset(void*,int,size_t)"
"check_group_min_max_predicates(Item*,Item_field*,Field::imagetype)" -> "Item_func::arguments() const"
"check_group_min_max_predicates(Item*,Item_field*,Field::imagetype)" -> "check_group_min_max_predicates(Item*,Item_field*,Field::imagetype)"
"check_group_min_max_predicates(Item*,Item_field*,Field::imagetype)" -> "simple_pred(Item_func*,Item**,bool*)"
"check_group_min_max_predicates(Item*,Item_field*,Field::imagetype)" -> "List_iterator_fast<T>::operator++(int) [with T = Item]"
"check_group_min_max_predicates(Item*,Item_field*,Field::imagetype)" -> "Item_func::argument_count() const"
"check_group_min_max_predicates(Item*,Item_field*,Field::imagetype)" -> "Item_cond::argument_list()"
"check_group_min_max_predicates(Item*,Item_field*,Field::imagetype)" -> "List_iterator_fast<T>::List_iterator_fast(List<T>&) [with T = Item]"
"simple_pred(Item_func*,Item**,bool*)" -> "Item_equal_iterator::operator++(int)"
"simple_pred(Item_func*,Item**,bool*)" -> "Item_func::argument_count() const"
"simple_pred(Item_func*,Item**,bool*)" -> "Item_equal::get_const()"
"simple_pred(Item_func*,Item**,bool*)" -> "Item_func::arguments() const"
"simple_pred(Item_func*,Item**,bool*)" -> "Item_equal_iterator::Item_equal_iterator(Item_equal&)"
"add_group_and_distinct_keys(JOIN*,JOIN_TAB*)" -> "List_iterator<T>::operator++(int) [with T = Item]"
"add_group_and_distinct_keys(JOIN*,JOIN_TAB*)" -> "Bitmap<64u>::set_all()"
"add_group_and_distinct_keys(JOIN*,JOIN_TAB*)" -> "List_iterator<T>::List_iterator(List<T>&) [with T = Item_field]"
"add_group_and_distinct_keys(JOIN*,JOIN_TAB*)" -> "JOIN::ORDER_with_src::operator ORDER*()"
"add_group_and_distinct_keys(JOIN*,JOIN_TAB*)" -> "Bitmap<64u>::is_clear_all() const"
"add_group_and_distinct_keys(JOIN*,JOIN_TAB*)" -> "List<T>::List() [with T = Item_field]"
"add_group_and_distinct_keys(JOIN*,JOIN_TAB*)" -> "trace_indices_added_group_distinct(Opt_trace_context*,const JOIN_TAB*,key_map,const char*)"
"add_group_and_distinct_keys(JOIN*,JOIN_TAB*)" -> "Bitmap<64u>::intersect(const Bitmap<64u>&)"
"add_group_and_distinct_keys(JOIN*,JOIN_TAB*)" -> "List_iterator<T>::operator++(int) [with T = Item_field]"
"add_group_and_distinct_keys(JOIN*,JOIN_TAB*)" -> "is_indexed_agg_distinct(JOIN*,List<Item_field>*)"
"add_group_and_distinct_keys(JOIN*,JOIN_TAB*)" -> "Bitmap<64u>::is_subset(const Bitmap<64u>&) const"
"add_group_and_distinct_keys(JOIN*,JOIN_TAB*)" -> "Bitmap<64u>::Bitmap()"
"add_group_and_distinct_keys(JOIN*,JOIN_TAB*)" -> "List_iterator<T>::List_iterator(List<T>&) [with T = Item]"
"add_group_and_distinct_keys(JOIN*,JOIN_TAB*)" -> "Bitmap<64u>::merge(const Bitmap<64u>&)"
"trace_indices_added_group_distinct(Opt_trace_context*,const JOIN_TAB*,key_map,const char*)" -> "Opt_trace_array::Opt_trace_array(Opt_trace_context*,const char*,Opt_trace_context::feature_value)"
"trace_indices_added_group_distinct(Opt_trace_context*,const JOIN_TAB*,key_map,const char*)" -> "Bitmap<64u>::is_set(uint) const"
"trace_indices_added_group_distinct(Opt_trace_context*,const JOIN_TAB*,key_map,const char*)" -> "Opt_trace_object::Opt_trace_object(Opt_trace_context*,const char*,Opt_trace_context::feature_value)"
"trace_indices_added_group_distinct(Opt_trace_context*,const JOIN_TAB*,key_map,const char*)" -> "Opt_trace_struct::add_alnum(const char*,const char*)"
"trace_indices_added_group_distinct(Opt_trace_context*,const JOIN_TAB*,key_map,const char*)" -> "Opt_trace_context::is_started() const"
"trace_indices_added_group_distinct(Opt_trace_context*,const JOIN_TAB*,key_map,const char*)" -> "Opt_trace_struct::add_utf8(const char*)"
"trace_indices_added_group_distinct(Opt_trace_context*,const JOIN_TAB*,key_map,const char*)" -> "__builtin_expect(long int,long int)"
"make_select(TABLE*,table_map,table_map,Item*,bool,int*)" -> "SQL_SELECT::SQL_SELECT()"
"make_select(TABLE*,table_map,table_map,Item*,bool,int*)" -> "my_free(void*)"
"SQL_SELECT::SQL_SELECT()" -> "Sql_alloc::Sql_alloc()"
"SQL_SELECT::SQL_SELECT()" -> "Bitmap<64u>::Bitmap()"
"JOIN::refine_best_rowcount()" -> "JOIN::plan_is_const() const"
"JOIN::refine_best_rowcount()" -> "st_select_lex_unit::first_select()"
"JOIN::optimize_fts_limit_query()" -> "JOIN::ORDER_with_src::operator->() const"
"JOIN::optimize_fts_limit_query()" -> "JOIN::ORDER_with_src::operator ORDER*()"
"substitute_for_best_equal_field(Item*,COND_EQUAL*,void*)" -> "List<T>::disjoin(List<T>*) [with T = Item]"
"substitute_for_best_equal_field(Item*,COND_EQUAL*,void*)" -> "eliminate_item_equal(Item*,COND_EQUAL*,Item_equal*)"
"substitute_for_best_equal_field(Item*,COND_EQUAL*,void*)" -> "List_iterator_fast<T>::operator++(int) [with T = Item_equal]"
"substitute_for_best_equal_field(Item*,COND_EQUAL*,void*)" -> "List_iterator_fast<T>::List_iterator_fast(List<T>&) [with T = Item_equal]"
"substitute_for_best_equal_field(Item*,COND_EQUAL*,void*)" -> "Item_cond::argument_list()"
"substitute_for_best_equal_field(Item*,COND_EQUAL*,void*)" -> "List_iterator<T>::operator++(int) [with T = Item]"
"substitute_for_best_equal_field(Item*,COND_EQUAL*,void*)" -> "Item_int::Item_int(int32,uint)"
"substitute_for_best_equal_field(Item*,COND_EQUAL*,void*)" -> "List<T>::head() [with T = Item_equal]"
"substitute_for_best_equal_field(Item*,COND_EQUAL*,void*)" -> "List_iterator<T>::List_iterator(List<T>&) [with T = Item]"
"substitute_for_best_equal_field(Item*,COND_EQUAL*,void*)" -> "List_iterator<T>::replace(T*) [with T = Item]"
"substitute_for_best_equal_field(Item*,COND_EQUAL*,void*)" -> "Item_equal::sort(Item_field_cmpfunc,void*)"
"substitute_for_best_equal_field(Item*,COND_EQUAL*,void*)" -> "substitute_for_best_equal_field(Item*,COND_EQUAL*,void*)"
"List<T>::disjoin(List<T>*) [with T = Item]" -> "base_list::disjoin(base_list*)"
"eliminate_item_equal(Item*,COND_EQUAL*,Item_equal*)" -> "Item_field::find_item_equal(COND_EQUAL*)"
"eliminate_item_equal(Item*,COND_EQUAL*,Item_equal*)" -> "sj_is_materialize_strategy(uint)"
"eliminate_item_equal(Item*,COND_EQUAL*,Item_equal*)" -> "st_join_table::get_sj_strategy() const"
"eliminate_item_equal(Item*,COND_EQUAL*,Item_equal*)" -> "Item_equal_iterator::Item_equal_iterator(Item_equal&)"
"eliminate_item_equal(Item*,COND_EQUAL*,Item_equal*)" -> "List<T>::head() [with T = Item]"
"eliminate_item_equal(Item*,COND_EQUAL*,Item_equal*)" -> "List<T>::List() [with T = Item]"
"eliminate_item_equal(Item*,COND_EQUAL*,Item_equal*)" -> "Item_equal::get_const()"
"eliminate_item_equal(Item*,COND_EQUAL*,Item_equal*)" -> "Item_cond::add_at_head(List<Item>*)"
"eliminate_item_equal(Item*,COND_EQUAL*,Item_equal*)" -> "Item_equal_iterator::operator++(int)"
"eliminate_item_equal(Item*,COND_EQUAL*,Item_equal*)" -> "Item_int::Item_int(longlong,uint)"
"eliminate_item_equal(Item*,COND_EQUAL*,Item_equal*)" -> "Item::quick_fix_field()"
"eliminate_item_equal(Item*,COND_EQUAL*,Item_equal*)" -> "Item_bool_func2::set_cmp_func()"
"eliminate_item_equal(Item*,COND_EQUAL*,Item_equal*)" -> "Item_cond_and::Item_cond_and(List<Item>&)"
"eliminate_item_equal(Item*,COND_EQUAL*,Item_equal*)" -> "List<T>::push_back(T*) [with T = Item]"
"eliminate_item_equal(Item*,COND_EQUAL*,Item_equal*)" -> "Item_equal::get_subst_item(const Item_field*)"
"eliminate_item_equal(Item*,COND_EQUAL*,Item_equal*)" -> "Item_func_eq::Item_func_eq(Item*,Item*)"
"Item_field::find_item_equal(COND_EQUAL*)" -> "Item_equal::contains(Field*)"
"Item_field::find_item_equal(COND_EQUAL*)" -> "List_iterator_fast<T>::operator++(int) [with T = Item_equal]"
"Item_field::find_item_equal(COND_EQUAL*)" -> "List_iterator_fast<T>::List_iterator_fast(List<T>&) [with T = Item_equal]"
"List<T>::head() [with T = Item_equal]" -> "base_list::head()"
"Item_equal::sort(Item_field_cmpfunc,void*)" -> "base_list::sort(Node_cmp_func,void*)"
"save_index_subquery_explain_info(JOIN_TAB*,Item*)" -> "st_join_table::has_guarded_conds() const"
"save_index_subquery_explain_info(JOIN_TAB*,Item*)" -> "Bitmap<64u>::is_set(uint) const"
"st_join_table::has_guarded_conds() const" -> "st_table_ref::has_guarded_conds() const"
"remove_const(JOIN*,ORDER*,Item*,bool,bool*,const char*)" -> "Opt_trace_object::Opt_trace_object(Opt_trace_context*,const char*,Opt_trace_context::feature_value)"
"remove_const(JOIN*,ORDER*,Item*,bool,bool*,const char*)" -> "JOIN::plan_is_const() const"
"remove_const(JOIN*,ORDER*,Item*,bool,bool*,const char*)" -> "duplicate_order(const ORDER*,const ORDER*)"
"remove_const(JOIN*,ORDER*,Item*,bool,bool*,const char*)" -> "st_select_lex::print_order(String*,ORDER*,enum_query_type)"
"remove_const(JOIN*,ORDER*,Item*,bool,bool*,const char*)" -> "update_depend_map(JOIN*,ORDER*)"
"remove_const(JOIN*,ORDER*,Item*,bool,bool*,const char*)" -> "Opt_trace_struct::add(const char*,Item*)"
"remove_const(JOIN*,ORDER*,Item*,bool,bool*,const char*)" -> "Opt_trace_disable_I_S::Opt_trace_disable_I_S(Opt_trace_context*,bool)"
"remove_const(JOIN*,ORDER*,Item*,bool,bool*,const char*)" -> "Opt_trace_struct::add_alnum(const char*,const char*)"
"remove_const(JOIN*,ORDER*,Item*,bool,bool*,const char*)" -> "String::length() const"
"remove_const(JOIN*,ORDER*,Item*,bool,bool*,const char*)" -> "Opt_trace_struct::add_utf8(const char*,const char*,size_t)"
"remove_const(JOIN*,ORDER*,Item*,bool,bool*,const char*)" -> "String::String()"
"remove_const(JOIN*,ORDER*,Item*,bool,bool*,const char*)" -> "Opt_trace_struct::end()"
"remove_const(JOIN*,ORDER*,Item*,bool,bool*,const char*)" -> "Opt_trace_object::Opt_trace_object(Opt_trace_context*,Opt_trace_context::feature_value)"
"remove_const(JOIN*,ORDER*,Item*,bool,bool*,const char*)" -> "String::ptr() const"
"remove_const(JOIN*,ORDER*,Item*,bool,bool*,const char*)" -> "only_eq_ref_tables(JOIN*,ORDER*,table_map,table_map*,table_map*)"
"remove_const(JOIN*,ORDER*,Item*,bool,bool*,const char*)" -> "Opt_trace_context::is_started() const"
"remove_const(JOIN*,ORDER*,Item*,bool,bool*,const char*)" -> "Opt_trace_struct::add(const char*,bool)"
"remove_const(JOIN*,ORDER*,Item*,bool,bool*,const char*)" -> "const_expression_in_where(Item*,Item*,Field*,Item**)"
"remove_const(JOIN*,ORDER*,Item*,bool,bool*,const char*)" -> "Opt_trace_array::Opt_trace_array(Opt_trace_context*,const char*,Opt_trace_context::feature_value)"
"only_eq_ref_tables(JOIN*,ORDER*,table_map,table_map*,table_map*)" -> "eq_ref_table(JOIN*,ORDER*,JOIN_TAB*,table_map*,table_map*)"
"eq_ref_table(JOIN*,ORDER*,JOIN_TAB*,table_map*,table_map*)" -> "only_eq_ref_tables(JOIN*,ORDER*,table_map,table_map*,table_map*)"
"const_expression_in_where(Item*,Item*,Field*,Item**)" -> "List_iterator_fast<T>::operator++(int) [with T = Item]"
"const_expression_in_where(Item*,Item*,Field*,Item**)" -> "equal(Item*,Item*,Field*)"
"const_expression_in_where(Item*,Item*,Field*,Item**)" -> "const_expression_in_where(Item*,Item*,Field*,Item**)"
"const_expression_in_where(Item*,Item*,Field*,Item**)" -> "Item_cond::argument_list()"
"const_expression_in_where(Item*,Item*,Field*,Item**)" -> "Item_func::arguments() const"
"const_expression_in_where(Item*,Item*,Field*,Item**)" -> "List_iterator_fast<T>::List_iterator_fast(List<T>&) [with T = Item]"
"const_expression_in_where(Item*,Item*,Field*,Item**)" -> "test_if_equality_guarantees_uniqueness(Item*,Item*)"
"test_if_equality_guarantees_uniqueness(Item*,Item*)" -> "Arg_comparator::can_compare_as_dates(Item*,Item*,ulonglong*)"
"make_join_readinfo(JOIN*,ulonglong,uint)" -> "TABLE_LIST::uses_materialization() const"
"make_join_readinfo(JOIN*,ulonglong,uint)" -> "setup_join_buffering(JOIN_TAB*,JOIN*,ulonglong,uint,bool*)"
"make_join_readinfo(JOIN*,ulonglong,uint)" -> "THD::set_status_no_index_used()"
"make_join_readinfo(JOIN*,ulonglong,uint)" -> "THD::inc_status_select_full_join()"
"make_join_readinfo(JOIN*,ulonglong,uint)" -> "Opt_trace_array::Opt_trace_array(Opt_trace_context*,const char*,Opt_trace_context::feature_value)"
"make_join_readinfo(JOIN*,ulonglong,uint)" -> "Bitmap<64u>::is_clear_all() const"
"make_join_readinfo(JOIN*,ulonglong,uint)" -> "THD::inc_status_select_range()"
"make_join_readinfo(JOIN*,ulonglong,uint)" -> "Opt_trace_struct::add_utf8_table(const TABLE*)"
"make_join_readinfo(JOIN*,ulonglong,uint)" -> "Opt_trace_object::Opt_trace_object(Opt_trace_context*,Opt_trace_context::feature_value)"
"make_join_readinfo(JOIN*,ulonglong,uint)" -> "THD::inc_status_select_range_check()"
"make_join_readinfo(JOIN*,ulonglong,uint)" -> "Bitmap<64u>::is_set(uint) const"
"make_join_readinfo(JOIN*,ulonglong,uint)" -> "THD::inc_status_select_scan()"
"make_join_readinfo(JOIN*,ulonglong,uint)" -> "Opt_trace_struct::add_alnum(const char*,const char*)"
"make_join_readinfo(JOIN*,ulonglong,uint)" -> "push_index_cond(JOIN_TAB*,uint,bool,Opt_trace_object*)"
"make_join_readinfo(JOIN*,ulonglong,uint)" -> "JOIN::ORDER_with_src::operator ORDER*()"
"make_join_readinfo(JOIN*,ulonglong,uint)" -> "TABLE::set_keyread(bool)"
"make_join_readinfo(JOIN*,ulonglong,uint)" -> "abort()"
"make_join_readinfo(JOIN*,ulonglong,uint)" -> "Query_arena::alloc(size_t)"
"make_join_readinfo(JOIN*,ulonglong,uint)" -> "SQL_SELECT::set_quick(QUICK_SELECT_I*)"
"make_join_readinfo(JOIN*,ulonglong,uint)" -> "THD::set_status_no_good_index_used()"
"make_join_readinfo(JOIN*,ulonglong,uint)" -> "THD::inc_status_select_full_range_join()"
"make_join_readinfo(JOIN*,ulonglong,uint)" -> "find_shortest_key(TABLE*,const key_map*)"
"make_join_readinfo(JOIN*,ulonglong,uint)" -> "st_join_table::do_loosescan() const"
"make_join_readinfo(JOIN*,ulonglong,uint)" -> "setup_semijoin_dups_elimination(JOIN*,ulonglong,uint)"
"setup_join_buffering(JOIN_TAB*,JOIN*,ulonglong,uint,bool*)" -> "sj_is_materialize_strategy(uint)"
"setup_join_buffering(JOIN_TAB*,JOIN*,ulonglong,uint,bool*)" -> "THD::optimizer_switch_flag(ulonglong) const"
"setup_join_buffering(JOIN_TAB*,JOIN*,ulonglong,uint,bool*)" -> "revise_cache_usage(JOIN_TAB*)"
"setup_join_buffering(JOIN_TAB*,JOIN*,ulonglong,uint,bool*)" -> "JOIN_CACHE_BKA_UNIQUE::JOIN_CACHE_BKA_UNIQUE(JOIN*,JOIN_TAB*,uint,JOIN_CACHE*)"
"setup_join_buffering(JOIN_TAB*,JOIN*,ulonglong,uint,bool*)" -> "st_join_table::is_single_inner_of_semi_join()"
"setup_join_buffering(JOIN_TAB*,JOIN*,ulonglong,uint,bool*)" -> "JOIN_CACHE_BKA::JOIN_CACHE_BKA(JOIN*,JOIN_TAB*,uint,JOIN_CACHE*)"
"setup_join_buffering(JOIN_TAB*,JOIN*,ulonglong,uint,bool*)" -> "st_join_table::is_inner_table_of_outer_join()"
"setup_join_buffering(JOIN_TAB*,JOIN*,ulonglong,uint,bool*)" -> "st_join_table::has_guarded_conds() const"
"setup_join_buffering(JOIN_TAB*,JOIN*,ulonglong,uint,bool*)" -> "TABLE_LIST::uses_materialization() const"
"setup_join_buffering(JOIN_TAB*,JOIN*,ulonglong,uint,bool*)" -> "Cost_estimate::Cost_estimate()"
"setup_join_buffering(JOIN_TAB*,JOIN*,ulonglong,uint,bool*)" -> "JOIN_CACHE_BNL::JOIN_CACHE_BNL(JOIN*,JOIN_TAB*,JOIN_CACHE*)"
"setup_join_buffering(JOIN_TAB*,JOIN*,ulonglong,uint,bool*)" -> "st_join_table::get_sj_strategy() const"
"setup_join_buffering(JOIN_TAB*,JOIN*,ulonglong,uint,bool*)" -> "Bitmap<64u>::is_set(uint) const"
"revise_cache_usage(JOIN_TAB*)" -> "set_join_cache_denial(JOIN_TAB*)"
"revise_cache_usage(JOIN_TAB*)" -> "st_join_table::get_sj_strategy() const"
"JOIN_CACHE_BKA_UNIQUE::JOIN_CACHE_BKA_UNIQUE(JOIN*,JOIN_TAB*,uint,JOIN_CACHE*)" -> "JOIN_CACHE_BKA::JOIN_CACHE_BKA(JOIN*,JOIN_TAB*,uint,JOIN_CACHE*)"
"JOIN_CACHE_BKA::JOIN_CACHE_BKA(JOIN*,JOIN_TAB*,uint,JOIN_CACHE*)" -> "JOIN_CACHE::JOIN_CACHE(JOIN*,JOIN_TAB*,JOIN_CACHE*)"
"JOIN_CACHE::JOIN_CACHE(JOIN*,JOIN_TAB*,JOIN_CACHE*)" -> "QEP_operation::QEP_operation(JOIN_TAB*)"
"QEP_operation::QEP_operation(JOIN_TAB*)" -> "Sql_alloc::Sql_alloc()"
"JOIN_CACHE_BNL::JOIN_CACHE_BNL(JOIN*,JOIN_TAB*,JOIN_CACHE*)" -> "JOIN_CACHE::JOIN_CACHE(JOIN*,JOIN_TAB*,JOIN_CACHE*)"
"push_index_cond(JOIN_TAB*,uint,bool,Opt_trace_object*)" -> "make_cond_for_index(Item*,TABLE*,uint,bool)"
"push_index_cond(JOIN_TAB*,uint,bool,Opt_trace_object*)" -> "Opt_trace_struct::add(const char*,bool)"
"push_index_cond(JOIN_TAB*,uint,bool,Opt_trace_object*)" -> "and_conditions(Item**,Item*)"
"push_index_cond(JOIN_TAB*,uint,bool,Opt_trace_object*)" -> "THD::optimizer_switch_flag(ulonglong) const"
"push_index_cond(JOIN_TAB*,uint,bool,Opt_trace_object*)" -> "make_cond_remainder(Item*,bool)"
"push_index_cond(JOIN_TAB*,uint,bool,Opt_trace_object*)" -> "st_join_table::has_guarded_conds() const"
"push_index_cond(JOIN_TAB*,uint,bool,Opt_trace_object*)" -> "st_join_table::condition() const"
"push_index_cond(JOIN_TAB*,uint,bool,Opt_trace_object*)" -> "st_join_table::set_condition(Item*,uint)"
"push_index_cond(JOIN_TAB*,uint,bool,Opt_trace_object*)" -> "Opt_trace_struct::add(const char*,Item*)"
"make_cond_for_index(Item*,TABLE*,uint,bool)" -> "List<T>::push_back(T*) [with T = Item]"
"make_cond_for_index(Item*,TABLE*,uint,bool)" -> "List_iterator<T>::List_iterator(List<T>&) [with T = Item]"
"make_cond_for_index(Item*,TABLE*,uint,bool)" -> "Item_cond_and::Item_cond_and()"
"make_cond_for_index(Item*,TABLE*,uint,bool)" -> "make_cond_for_index(Item*,TABLE*,uint,bool)"
"make_cond_for_index(Item*,TABLE*,uint,bool)" -> "Item_func::set_used_tables(table_map)"
"make_cond_for_index(Item*,TABLE*,uint,bool)" -> "Item_cond_or::Item_cond_or()"
"make_cond_for_index(Item*,TABLE*,uint,bool)" -> "Item_cond::argument_list()"
"make_cond_for_index(Item*,TABLE*,uint,bool)" -> "List<T>::head() [with T = Item]"
"make_cond_for_index(Item*,TABLE*,uint,bool)" -> "uses_index_fields_only(Item*,TABLE*,uint,bool)"
"make_cond_for_index(Item*,TABLE*,uint,bool)" -> "Item::quick_fix_field()"
"make_cond_for_index(Item*,TABLE*,uint,bool)" -> "List_iterator<T>::operator++(int) [with T = Item]"
"Item_cond_or::Item_cond_or()" -> "Item_cond::Item_cond()"
"uses_index_fields_only(Item*,TABLE*,uint,bool)" -> "Item_func::arguments() const"
"uses_index_fields_only(Item*,TABLE*,uint,bool)" -> "Item_func::argument_count() const"
"uses_index_fields_only(Item*,TABLE*,uint,bool)" -> "uses_index_fields_only(Item*,TABLE*,uint,bool)"
"uses_index_fields_only(Item*,TABLE*,uint,bool)" -> "List_iterator<T>::List_iterator(List<T>&) [with T = Item]"
"uses_index_fields_only(Item*,TABLE*,uint,bool)" -> "List_iterator<T>::operator++(int) [with T = Item]"
"uses_index_fields_only(Item*,TABLE*,uint,bool)" -> "Item_cond::argument_list()"
"uses_index_fields_only(Item*,TABLE*,uint,bool)" -> "Bitmap<64u>::is_set(uint) const"
"and_conditions(Item**,Item*)" -> "Item::quick_fix_field()"
"and_conditions(Item**,Item*)" -> "Item_cond_and::Item_cond_and(Item*,Item*)"
"and_conditions(Item**,Item*)" -> "__builtin_expect(long int,long int)"
"make_cond_remainder(Item*,bool)" -> "make_cond_remainder(Item*,bool)"
"make_cond_remainder(Item*,bool)" -> "Item_cond_or::Item_cond_or()"
"make_cond_remainder(Item*,bool)" -> "List<T>::push_back(T*) [with T = Item]"
"make_cond_remainder(Item*,bool)" -> "Item_func::set_used_tables(table_map)"
"make_cond_remainder(Item*,bool)" -> "Item::quick_fix_field()"
"make_cond_remainder(Item*,bool)" -> "Item_cond::argument_list()"
"make_cond_remainder(Item*,bool)" -> "Item_cond_and::Item_cond_and()"
"make_cond_remainder(Item*,bool)" -> "List<T>::head() [with T = Item]"
"make_cond_remainder(Item*,bool)" -> "List_iterator<T>::operator++(int) [with T = Item]"
"make_cond_remainder(Item*,bool)" -> "List_iterator<T>::List_iterator(List<T>&) [with T = Item]"
"st_join_table::set_condition(Item*,uint)" -> "Bitmap<64u>::clear_all()"
"setup_semijoin_dups_elimination(JOIN*,ulonglong,uint)" -> "SQL_SELECT::set_quick(QUICK_SELECT_I*)"
"setup_semijoin_dups_elimination(JOIN*,ulonglong,uint)" -> "memcpy(void*,const void*,size_t)"
"setup_semijoin_dups_elimination(JOIN*,ulonglong,uint)" -> "sj_table_is_included(JOIN*,JOIN_TAB*)"
"setup_semijoin_dups_elimination(JOIN*,ulonglong,uint)" -> "join_buffer_alg(const THD*)"
"setup_semijoin_dups_elimination(JOIN*,ulonglong,uint)" -> "create_duplicate_weedout_tmp_table(THD*,uint,SJ_TMP_TABLE*)"
"setup_semijoin_dups_elimination(JOIN*,ulonglong,uint)" -> "Query_arena::alloc(size_t)"
"setup_semijoin_dups_elimination(JOIN*,ulonglong,uint)" -> "TABLE::prepare_for_position()"
"setup_semijoin_dups_elimination(JOIN*,ulonglong,uint)" -> "List<T>::push_back(T*) [with T = TABLE]"
"setup_semijoin_dups_elimination(JOIN*,ulonglong,uint)" -> "SJ_TMP_TABLE::SJ_TMP_TABLE()"
"setup_semijoin_dups_elimination(JOIN*,ulonglong,uint)" -> "might_do_join_buffering(uint,const JOIN_TAB*)"
"setup_semijoin_dups_elimination(JOIN*,ulonglong,uint)" -> "base_list::is_empty() const"
"sj_table_is_included(JOIN*,JOIN_TAB*)" -> "Table_map_iterator::next_bit()"
"sj_table_is_included(JOIN*,JOIN_TAB*)" -> "Table_map_iterator::Table_map_iterator(ulonglong)"
"join_buffer_alg(const THD*)" -> "THD::optimizer_switch_flag(ulonglong) const"
"create_duplicate_weedout_tmp_table(THD*,uint,SJ_TMP_TABLE*)" -> "alloc_root(MEM_ROOT*,size_t)"
"create_duplicate_weedout_tmp_table(THD*,uint,SJ_TMP_TABLE*)" -> "memset(void*,int,size_t)"
"create_duplicate_weedout_tmp_table(THD*,uint,SJ_TMP_TABLE*)" -> "my_tmpdir(MY_TMPDIR*)"
"create_duplicate_weedout_tmp_table(THD*,uint,SJ_TMP_TABLE*)" -> "Field::init(TABLE*)"
"create_duplicate_weedout_tmp_table(THD*,uint,SJ_TMP_TABLE*)" -> "free_tmp_table(THD*,TABLE*)"
"create_duplicate_weedout_tmp_table(THD*,uint,SJ_TMP_TABLE*)" -> "TABLE_SHARE::db_type() const"
"create_duplicate_weedout_tmp_table(THD*,uint,SJ_TMP_TABLE*)" -> "sprintf(char*,const char*,...)"
"create_duplicate_weedout_tmp_table(THD*,uint,SJ_TMP_TABLE*)" -> "get_new_handler(TABLE_SHARE*,MEM_ROOT*,handlerton*)"
"create_duplicate_weedout_tmp_table(THD*,uint,SJ_TMP_TABLE*)" -> "Field_varstring::Field_varstring(uint32,bool,const char*,TABLE_SHARE*,const CHARSET_INFO*)"
"create_duplicate_weedout_tmp_table(THD*,uint,SJ_TMP_TABLE*)" -> "strlen(const char*)"
"create_duplicate_weedout_tmp_table(THD*,uint,SJ_TMP_TABLE*)" -> "std::min(const _Tp&,const _Tp&) [with _Tp = long long unsigned int]"
"create_duplicate_weedout_tmp_table(THD*,uint,SJ_TMP_TABLE*)" -> "__builtin_strcpy(char*,const char*)"
"create_duplicate_weedout_tmp_table(THD*,uint,SJ_TMP_TABLE*)" -> "fn_format(char*,const char*,const char*,const char*,uint)"
"create_duplicate_weedout_tmp_table(THD*,uint,SJ_TMP_TABLE*)" -> "THD::inc_status_created_tmp_tables()"
"create_duplicate_weedout_tmp_table(THD*,uint,SJ_TMP_TABLE*)" -> "init_sql_alloc(MEM_ROOT*,uint,uint)"
"create_duplicate_weedout_tmp_table(THD*,uint,SJ_TMP_TABLE*)" -> "setup_tmp_table_column_bitmaps(TABLE*,uchar*)"
"create_duplicate_weedout_tmp_table(THD*,uint,SJ_TMP_TABLE*)" -> "Bitmap<64u>::init()"
"create_duplicate_weedout_tmp_table(THD*,uint,SJ_TMP_TABLE*)" -> "init_tmp_table_share(THD*,TABLE_SHARE*,const char*,uint,const char*,const char*)"
"create_duplicate_weedout_tmp_table(THD*,uint,SJ_TMP_TABLE*)" -> "Field::move_field(uchar*,uchar*,uchar)"
"create_duplicate_weedout_tmp_table(THD*,uint,SJ_TMP_TABLE*)" -> "Field::offset(uchar*)"
"create_duplicate_weedout_tmp_table(THD*,uint,SJ_TMP_TABLE*)" -> "Field::new_key_field(MEM_ROOT*,TABLE*,uchar*)"
"create_duplicate_weedout_tmp_table(THD*,uint,SJ_TMP_TABLE*)" -> "bitmap_lock_clear_bit(MY_BITMAP*,uint)"
"create_duplicate_weedout_tmp_table(THD*,uint,SJ_TMP_TABLE*)" -> "ha_lock_engine(THD*,const handlerton*)"
"create_duplicate_weedout_tmp_table(THD*,uint,SJ_TMP_TABLE*)" -> "multi_alloc_root(MEM_ROOT*,...)"
"create_duplicate_weedout_tmp_table(THD*,uint,SJ_TMP_TABLE*)" -> "bitmap_lock_set_next(MY_BITMAP*)"
"create_duplicate_weedout_tmp_table(THD*,uint,SJ_TMP_TABLE*)" -> "instantiate_tmp_table(TABLE*,KEY*,MI_COLUMNDEF*,MI_COLUMNDEF**,ulonglong,my_bool,Opt_trace_context*)"
"SJ_TMP_TABLE::SJ_TMP_TABLE()" -> "Sql_alloc::Sql_alloc()"
"opt_sum_query(THD*,TABLE_LIST*,List<Item>&,Item*)" -> "Diagnostics_area::sql_errno() const"
"opt_sum_query(THD*,TABLE_LIST*,List<Item>&,Item*)" -> "Item_sum::get_arg(uint)"
"opt_sum_query(THD*,TABLE_LIST*,List<Item>&,Item*)" -> "handler::ha_table_flags() const"
"opt_sum_query(THD*,TABLE_LIST*,List<Item>&,Item*)" -> "Item_func_match::init_search(bool)"
"opt_sum_query(THD*,TABLE_LIST*,List<Item>&,Item*)" -> "THD::get_stmt_da()"
"opt_sum_query(THD*,TABLE_LIST*,List<Item>&,Item*)" -> "TABLE_LIST::outer_join_nest() const"
"opt_sum_query(THD*,TABLE_LIST*,List<Item>&,Item*)" -> "handler::ha_index_init(uint,bool)"
"opt_sum_query(THD*,TABLE_LIST*,List<Item>&,Item*)" -> "Item_sum::make_const()"
"opt_sum_query(THD*,TABLE_LIST*,List<Item>&,Item*)" -> "List_iterator_fast<T>::operator++(int) [with T = Item]"
"opt_sum_query(THD*,TABLE_LIST*,List<Item>&,Item*)" -> "st_table_ref::st_table_ref()"
"opt_sum_query(THD*,TABLE_LIST*,List<Item>&,Item*)" -> "get_index_min_value(TABLE*,TABLE_REF*,Item_field*,uint,uint)"
"opt_sum_query(THD*,TABLE_LIST*,List<Item>&,Item*)" -> "Item_sum::reset_and_add()"
"opt_sum_query(THD*,TABLE_LIST*,List<Item>&,Item*)" -> "find_key_for_maxmin(bool,TABLE_REF*,Field*,Item*,uint*,uint*)"
"opt_sum_query(THD*,TABLE_LIST*,List<Item>&,Item*)" -> "handler::ha_index_end()"
"opt_sum_query(THD*,TABLE_LIST*,List<Item>&,Item*)" -> "Item_sum::set_aggregator(Aggregator::Aggregator_type)"
"opt_sum_query(THD*,TABLE_LIST*,List<Item>&,Item*)" -> "TABLE_LIST::uses_materialization() const"
"opt_sum_query(THD*,TABLE_LIST*,List<Item>&,Item*)" -> "TABLE_LIST::join_cond() const"
"opt_sum_query(THD*,TABLE_LIST*,List<Item>&,Item*)" -> "TABLE_LIST::fetch_number_of_rows()"
"opt_sum_query(THD*,TABLE_LIST*,List<Item>&,Item*)" -> "TABLE::set_keyread(bool)"
"opt_sum_query(THD*,TABLE_LIST*,List<Item>&,Item*)" -> "Item_sum::has_with_distinct() const"
"opt_sum_query(THD*,TABLE_LIST*,List<Item>&,Item*)" -> "reckey_in_range(bool,TABLE_REF*,Field*,Item*,uint,uint)"
"opt_sum_query(THD*,TABLE_LIST*,List<Item>&,Item*)" -> "Item_sum::aggregator_clear()"
"opt_sum_query(THD*,TABLE_LIST*,List<Item>&,Item*)" -> "get_exact_record_count(TABLE_LIST*)"
"opt_sum_query(THD*,TABLE_LIST*,List<Item>&,Item*)" -> "THD::is_error() const"
"opt_sum_query(THD*,TABLE_LIST*,List<Item>&,Item*)" -> "Item_sum_count::make_const(longlong)"
"opt_sum_query(THD*,TABLE_LIST*,List<Item>&,Item*)" -> "List_iterator_fast<T>::List_iterator_fast(List<T>&) [with T = Item]"
"opt_sum_query(THD*,TABLE_LIST*,List<Item>&,Item*)" -> "get_index_max_value(TABLE*,TABLE_REF*,uint)"
"opt_sum_query(THD*,TABLE_LIST*,List<Item>&,Item*)" -> "Item_func_match::get_count()"
"get_index_min_value(TABLE*,TABLE_REF*,Item_field*,uint,uint)" -> "Field::real_maybe_null() const"
"get_index_min_value(TABLE*,TABLE_REF*,Item_field*,uint,uint)" -> "key_cmp_if_same(TABLE*,const uchar*,uint,uint)"
"get_index_min_value(TABLE*,TABLE_REF*,Item_field*,uint,uint)" -> "handler::ha_index_read_map(uchar*,const uchar*,key_part_map,ha_rkey_function)"
"get_index_min_value(TABLE*,TABLE_REF*,Item_field*,uint,uint)" -> "handler::ha_index_first(uchar*)"
"key_cmp_if_same(TABLE*,const uchar*,uint,uint)" -> "std::min(const _Tp&,const _Tp&) [with _Tp = unsigned int]"
"key_cmp_if_same(TABLE*,const uchar*,uint,uint)" -> "memcmp(const void*,const void*,size_t)"
"Item_sum::reset_and_add()" -> "Item_sum::aggregator_add()"
"Item_sum::reset_and_add()" -> "Item_sum::aggregator_clear()"
"find_key_for_maxmin(bool,TABLE_REF*,Field*,Item*,uint*,uint*)" -> "TABLE::set_keyread(bool)"
"find_key_for_maxmin(bool,TABLE_REF*,Field*,Item*,uint*,uint*)" -> "matching_cond(bool,TABLE_REF*,KEY*,KEY_PART_INFO*,Item*,key_part_map*,uint*,uint*)"
"find_key_for_maxmin(bool,TABLE_REF*,Field*,Item*,uint*,uint*)" -> "Bitmap<64u>::is_set(uint) const"
"find_key_for_maxmin(bool,TABLE_REF*,Field*,Item*,uint*,uint*)" -> "actual_key_parts(KEY*)"
"matching_cond(bool,TABLE_REF*,KEY*,KEY_PART_INFO*,Item*,key_part_map*,uint*,uint*)" -> "Field::real_maybe_null() const"
"matching_cond(bool,TABLE_REF*,KEY*,KEY_PART_INFO*,Item*,key_part_map*,uint*,uint*)" -> "List_iterator_fast<T>::operator++(int) [with T = Item]"
"matching_cond(bool,TABLE_REF*,KEY*,KEY_PART_INFO*,Item*,key_part_map*,uint*,uint*)" -> "Field::set_null(my_ptrdiff_t)"
"matching_cond(bool,TABLE_REF*,KEY*,KEY_PART_INFO*,Item*,key_part_map*,uint*,uint*)" -> "matching_cond(bool,TABLE_REF*,KEY*,KEY_PART_INFO*,Item*,key_part_map*,uint*,uint*)"
"matching_cond(bool,TABLE_REF*,KEY*,KEY_PART_INFO*,Item*,key_part_map*,uint*,uint*)" -> "Item_cond::argument_list()"
"matching_cond(bool,TABLE_REF*,KEY*,KEY_PART_INFO*,Item*,key_part_map*,uint*,uint*)" -> "Field::is_null(my_ptrdiff_t) const"
"matching_cond(bool,TABLE_REF*,KEY*,KEY_PART_INFO*,Item*,key_part_map*,uint*,uint*)" -> "Item::save_in_field_no_warnings(Field*,bool)"
"matching_cond(bool,TABLE_REF*,KEY*,KEY_PART_INFO*,Item*,key_part_map*,uint*,uint*)" -> "simple_pred(Item_func*,Item**,bool*)"
"matching_cond(bool,TABLE_REF*,KEY*,KEY_PART_INFO*,Item*,key_part_map*,uint*,uint*)" -> "List_iterator_fast<T>::List_iterator_fast(List<T>&) [with T = Item]"
"Item_sum::set_aggregator(Aggregator::Aggregator_type)" -> "Aggregator_simple::Aggregator_simple(Item_sum*)"
"Item_sum::set_aggregator(Aggregator::Aggregator_type)" -> "Aggregator_distinct::Aggregator_distinct(Item_sum*)"
"Aggregator_simple::Aggregator_simple(Item_sum*)" -> "Aggregator::Aggregator(Item_sum*)"
"Aggregator::Aggregator(Item_sum*)" -> "Sql_alloc::Sql_alloc()"
"Aggregator_distinct::Aggregator_distinct(Item_sum*)" -> "Aggregator::Aggregator(Item_sum*)"
"reckey_in_range(bool,TABLE_REF*,Field*,Item*,uint,uint)" -> "key_cmp_if_same(TABLE*,const uchar*,uint,uint)"
"reckey_in_range(bool,TABLE_REF*,Field*,Item*,uint,uint)" -> "maxmin_in_range(bool,Field*,Item*)"
"maxmin_in_range(bool,Field*,Item*)" -> "Item_cond::argument_list()"
"maxmin_in_range(bool,Field*,Item*)" -> "List_iterator_fast<T>::operator++(int) [with T = Item]"
"maxmin_in_range(bool,Field*,Item*)" -> "Item_func::arguments() const"
"maxmin_in_range(bool,Field*,Item*)" -> "List_iterator_fast<T>::List_iterator_fast(List<T>&) [with T = Item]"
"maxmin_in_range(bool,Field*,Item*)" -> "maxmin_in_range(bool,Field*,Item*)"
"Item_sum_count::make_const(longlong)" -> "Item_sum::make_const()"
"get_index_max_value(TABLE*,TABLE_REF*,uint)" -> "handler::ha_index_last(uchar*)"
"get_index_max_value(TABLE*,TABLE_REF*,uint)" -> "handler::ha_index_read_map(uchar*,const uchar*,key_part_map,ha_rkey_function)"
"test_if_skip_sort_order(JOIN_TAB*,ORDER*,ha_rows,bool,const key_map*,const char*)" -> "Bitmap<64u>::intersect(const Bitmap<64u>&)"
"test_if_skip_sort_order(JOIN_TAB*,ORDER*,ha_rows,bool,const key_map*,const char*)" -> "__builtin_expect(long int,long int)"
"test_if_skip_sort_order(JOIN_TAB*,ORDER*,ha_rows,bool,const key_map*,const char*)" -> "Opt_trace_struct::add_utf8(const char*,const char*)"
"test_if_skip_sort_order(JOIN_TAB*,ORDER*,ha_rows,bool,const key_map*,const char*)" -> "Bitmap<64u>::set_bit(uint)"
"test_if_skip_sort_order(JOIN_TAB*,ORDER*,ha_rows,bool,const key_map*,const char*)" -> "SQL_SELECT::test_quick_select(THD*,key_map,table_map,ha_rows,bool,st_order::enum_order)"
"test_if_skip_sort_order(JOIN_TAB*,ORDER*,ha_rows,bool,const key_map*,const char*)" -> "Bitmap<64u>::is_clear_all() const"
"test_if_skip_sort_order(JOIN_TAB*,ORDER*,ha_rows,bool,const key_map*,const char*)" -> "Opt_trace_struct::add(const char*,bool)"
"test_if_skip_sort_order(JOIN_TAB*,ORDER*,ha_rows,bool,const key_map*,const char*)" -> "st_join_table::is_using_loose_index_scan()"
"test_if_skip_sort_order(JOIN_TAB*,ORDER*,ha_rows,bool,const key_map*,const char*)" -> "SQL_SELECT::set_quick(QUICK_SELECT_I*)"
"test_if_skip_sort_order(JOIN_TAB*,ORDER*,ha_rows,bool,const key_map*,const char*)" -> "st_join_table::set_jt_and_sel_condition(Item*,uint)"
"test_if_skip_sort_order(JOIN_TAB*,ORDER*,ha_rows,bool,const key_map*,const char*)" -> "Bitmap<64u>::clear_all()"
"test_if_skip_sort_order(JOIN_TAB*,ORDER*,ha_rows,bool,const key_map*,const char*)" -> "st_join_table::prefix_tables() const"
"test_if_skip_sort_order(JOIN_TAB*,ORDER*,ha_rows,bool,const key_map*,const char*)" -> "create_ref_for_key(JOIN*,JOIN_TAB*,Key_use*,table_map)"
"test_if_skip_sort_order(JOIN_TAB*,ORDER*,ha_rows,bool,const key_map*,const char*)" -> "Opt_trace_context::is_started() const"
"test_if_skip_sort_order(JOIN_TAB*,ORDER*,ha_rows,bool,const key_map*,const char*)" -> "test_if_subkey(ORDER*,JOIN_TAB*,uint,uint,const key_map*)"
"test_if_skip_sort_order(JOIN_TAB*,ORDER*,ha_rows,bool,const key_map*,const char*)" -> "Opt_trace_object::Opt_trace_object(Opt_trace_context*,Opt_trace_context::feature_value)"
"test_if_skip_sort_order(JOIN_TAB*,ORDER*,ha_rows,bool,const key_map*,const char*)" -> "Opt_trace_struct::add_alnum(const char*,const char*)"
"test_if_skip_sort_order(JOIN_TAB*,ORDER*,ha_rows,bool,const key_map*,const char*)" -> "test_if_order_by_key(ORDER*,TABLE*,uint,uint*)"
"test_if_skip_sort_order(JOIN_TAB*,ORDER*,ha_rows,bool,const key_map*,const char*)" -> "Opt_trace_object::Opt_trace_object(Opt_trace_context*,const char*,Opt_trace_context::feature_value)"
"test_if_skip_sort_order(JOIN_TAB*,ORDER*,ha_rows,bool,const key_map*,const char*)" -> "TABLE::set_keyread(bool)"
"test_if_skip_sort_order(JOIN_TAB*,ORDER*,ha_rows,bool,const key_map*,const char*)" -> "test_if_cheaper_ordering(const JOIN_TAB*,ORDER*,TABLE*,key_map,int,ha_rows,int*,int*,ha_rows*,uint*,uint*)"
"test_if_skip_sort_order(JOIN_TAB*,ORDER*,ha_rows,bool,const key_map*,const char*)" -> "Opt_trace_struct::add_utf8_table(const TABLE*)"
"test_if_skip_sort_order(JOIN_TAB*,ORDER*,ha_rows,bool,const key_map*,const char*)" -> "Bitmap<64u>::is_set(uint) const"
"test_if_skip_sort_order(JOIN_TAB*,ORDER*,ha_rows,bool,const key_map*,const char*)" -> "handler::ha_index_or_rnd_end()"
"test_if_skip_sort_order(JOIN_TAB*,ORDER*,ha_rows,bool,const key_map*,const char*)" -> "Bitmap<64u>::Bitmap()"
"test_if_skip_sort_order(JOIN_TAB*,ORDER*,ha_rows,bool,const key_map*,const char*)" -> "Plan_change_watchdog::Plan_change_watchdog(const JOIN_TAB*,bool)"
"test_if_skip_sort_order(JOIN_TAB*,ORDER*,ha_rows,bool,const key_map*,const char*)" -> "JOIN::ORDER_with_src::operator ORDER*()"
"st_join_table::set_jt_and_sel_condition(Item*,uint)" -> "st_join_table::set_condition(Item*,uint)"
"test_if_subkey(ORDER*,JOIN_TAB*,uint,uint,const key_map*)" -> "is_subkey(KEY_PART_INFO*,KEY_PART_INFO*,KEY_PART_INFO*)"
"test_if_subkey(ORDER*,JOIN_TAB*,uint,uint,const key_map*)" -> "Bitmap<64u>::is_set(uint) const"
"test_if_subkey(ORDER*,JOIN_TAB*,uint,uint,const key_map*)" -> "test_if_order_by_key(ORDER*,TABLE*,uint,uint*)"
"test_if_subkey(ORDER*,JOIN_TAB*,uint,uint,const key_map*)" -> "is_ref_or_null_optimized(const JOIN_TAB*,uint)"
"test_if_order_by_key(ORDER*,TABLE*,uint,uint*)" -> "handler::ha_table_flags() const"
"test_if_order_by_key(ORDER*,TABLE*,uint,uint*)" -> "Bitmap<64u>::is_set(uint) const"
"test_if_cheaper_ordering(const JOIN_TAB*,ORDER*,TABLE*,key_map,int,ha_rows,int*,int*,ha_rows*,uint*,uint*)" -> "actual_key_parts(KEY*)"
"test_if_cheaper_ordering(const JOIN_TAB*,ORDER*,TABLE*,key_map,int,ha_rows,int*,int*,ha_rows*,uint*,uint*)" -> "std::min(const _Tp&,const _Tp&) [with _Tp = long long unsigned int]"
"test_if_cheaper_ordering(const JOIN_TAB*,ORDER*,TABLE*,key_map,int,ha_rows,int*,int*,ha_rows*,uint*,uint*)" -> "Bitmap<64u>::merge(const Bitmap<64u>&)"
"test_if_cheaper_ordering(const JOIN_TAB*,ORDER*,TABLE*,key_map,int,ha_rows,int*,int*,ha_rows*,uint*,uint*)" -> "Bitmap<64u>::Bitmap()"
"test_if_cheaper_ordering(const JOIN_TAB*,ORDER*,TABLE*,key_map,int,ha_rows,int*,int*,ha_rows*,uint*,uint*)" -> "Bitmap<64u>::intersect(const Bitmap<64u>&)"
"test_if_cheaper_ordering(const JOIN_TAB*,ORDER*,TABLE*,key_map,int,ha_rows,int*,int*,ha_rows*,uint*,uint*)" -> "Bitmap<64u>::is_set(uint) const"
"test_if_cheaper_ordering(const JOIN_TAB*,ORDER*,TABLE*,key_map,int,ha_rows,int*,int*,ha_rows*,uint*,uint*)" -> "JOIN::ORDER_with_src::operator ORDER*()"
"test_if_cheaper_ordering(const JOIN_TAB*,ORDER*,TABLE*,key_map,int,ha_rows,int*,int*,ha_rows*,uint*,uint*)" -> "test_if_order_by_key(ORDER*,TABLE*,uint,uint*)"
"test_if_cheaper_ordering(const JOIN_TAB*,ORDER*,TABLE*,key_map,int,ha_rows,int*,int*,ha_rows*,uint*,uint*)" -> "std::min(const _Tp&,const _Tp&) [with _Tp = double]"
"list_contains_unique_index(JOIN_TAB*,bool (*)(Field*,void*),void*)" -> "Field::real_maybe_null() const"
"list_contains_unique_index(JOIN_TAB*,bool (*)(Field*,void*),void*)" -> "st_join_table::is_inner_table_of_outer_join()"
"JOIN::rollup_process_const_fields()" -> "List_iterator<T>::rewind() [with T = Item]"
"JOIN::rollup_process_const_fields()" -> "THD::change_item_tree(Item**,Item*)"
"JOIN::rollup_process_const_fields()" -> "JOIN::ORDER_with_src::operator ORDER*()"
"JOIN::rollup_process_const_fields()" -> "List_iterator<T>::operator++(int) [with T = Item]"
"JOIN::rollup_process_const_fields()" -> "List_iterator<T>::ref() [with T = Item]"
"JOIN::rollup_process_const_fields()" -> "Item_func_rollup_const::Item_func_rollup_const(Item*)"
"JOIN::rollup_process_const_fields()" -> "List_iterator<T>::List_iterator(List<T>&) [with T = Item]"
"Item_func_rollup_const::Item_func_rollup_const(Item*)" -> "Item_func::Item_func(Item*)"
"Item_func_rollup_const::Item_func_rollup_const(Item*)" -> "__builtin_memcpy(void*,const void*,long unsigned int)"
"JOIN::remove_subq_pushed_predicates(Item**)" -> "test_if_ref(Item*,Item_field*,Item*)"
"JOIN::remove_subq_pushed_predicates(Item**)" -> "Item_func::arguments() const"
"test_if_ref(Item*,Item_field*,Item*)" -> "Item_cache::eq_def(Field*)"
"test_if_ref(Item*,Item_field*,Item*)" -> "Item::save_in_field_no_warnings(Field*,bool)"
"test_if_ref(Item*,Item_field*,Item*)" -> "part_of_refkey(TABLE*,Field*)"
"part_of_refkey(TABLE*,Field*)" -> "st_join_table::has_guarded_conds() const"
"simplify_joins(JOIN*,List<TABLE_LIST>*,Item*,bool,bool,Item**,uint*)" -> "Opt_trace_object::Opt_trace_object(Opt_trace_context*,const char*,Opt_trace_context::feature_value)"
"simplify_joins(JOIN*,List<TABLE_LIST>*,Item*,bool,bool,Item**,uint*)" -> "Opt_trace_context::is_started() const"
"simplify_joins(JOIN*,List<TABLE_LIST>*,Item*,bool,bool,Item**,uint*)" -> "TABLE_LIST::set_join_cond(Item*)"
"simplify_joins(JOIN*,List<TABLE_LIST>*,Item*,bool,bool,Item**,uint*)" -> "TABLE_LIST::join_cond_ref()"
"simplify_joins(JOIN*,List<TABLE_LIST>*,Item*,bool,bool,Item**,uint*)" -> "List_iterator<T>::List_iterator(List<T>&) [with T = TABLE_LIST]"
"simplify_joins(JOIN*,List<TABLE_LIST>*,Item*,bool,bool,Item**,uint*)" -> "THD::change_item_tree_place(Item**,Item**)"
"simplify_joins(JOIN*,List<TABLE_LIST>*,Item*,bool,bool,Item**,uint*)" -> "opt_trace_print_expanded_query(THD*,st_select_lex*,Opt_trace_object*)"
"simplify_joins(JOIN*,List<TABLE_LIST>*,Item*,bool,bool,Item**,uint*)" -> "Opt_trace_struct::add_alnum(const char*)"
"simplify_joins(JOIN*,List<TABLE_LIST>*,Item*,bool,bool,Item**,uint*)" -> "TABLE_LIST::join_cond() const"
"simplify_joins(JOIN*,List<TABLE_LIST>*,Item*,bool,bool,Item**,uint*)" -> "simplify_joins(JOIN*,List<TABLE_LIST>*,Item*,bool,bool,Item**,uint*)"
"simplify_joins(JOIN*,List<TABLE_LIST>*,Item*,bool,bool,Item**,uint*)" -> "List_iterator<T>::operator++(int) [with T = Item]"
"simplify_joins(JOIN*,List<TABLE_LIST>*,Item*,bool,bool,Item**,uint*)" -> "List_iterator<T>::rewind() [with T = TABLE_LIST]"
"simplify_joins(JOIN*,List<TABLE_LIST>*,Item*,bool,bool,Item**,uint*)" -> "__builtin_expect(long int,long int)"
"simplify_joins(JOIN*,List<TABLE_LIST>*,Item*,bool,bool,Item**,uint*)" -> "List_iterator<T>::ref() [with T = Item]"
"simplify_joins(JOIN*,List<TABLE_LIST>*,Item*,bool,bool,Item**,uint*)" -> "and_conds(Item*,Item*)"
"simplify_joins(JOIN*,List<TABLE_LIST>*,Item*,bool,bool,Item**,uint*)" -> "List_iterator<T>::List_iterator(List<T>&) [with T = Item]"
"simplify_joins(JOIN*,List<TABLE_LIST>*,Item*,bool,bool,Item**,uint*)" -> "List_iterator<T>::replace(List<T>&) [with T = TABLE_LIST]"
"simplify_joins(JOIN*,List<TABLE_LIST>*,Item*,bool,bool,Item**,uint*)" -> "Opt_trace_object::Opt_trace_object(Opt_trace_context*,Opt_trace_context::feature_value)"
"simplify_joins(JOIN*,List<TABLE_LIST>*,Item*,bool,bool,Item**,uint*)" -> "Opt_trace_array::Opt_trace_array(Opt_trace_context*,const char*,Opt_trace_context::feature_value)"
"simplify_joins(JOIN*,List<TABLE_LIST>*,Item*,bool,bool,Item**,uint*)" -> "Item_cond::argument_list()"
"simplify_joins(JOIN*,List<TABLE_LIST>*,Item*,bool,bool,Item**,uint*)" -> "List_iterator<T>::operator++(int) [with T = TABLE_LIST]"
"THD::change_item_tree_place(Item**,Item**)" -> "I_List_iterator<T>::I_List_iterator(I_List<T>&) [with T = Item_change_record]"
"THD::change_item_tree_place(Item**,Item**)" -> "I_List_iterator<T>::operator++(int) [with T = Item_change_record]"
"I_List_iterator<T>::I_List_iterator(I_List<T>&) [with T = Item_change_record]" -> "base_ilist_iterator<T>::base_ilist_iterator(base_ilist<T>&) [with T = Item_change_record]"
"I_List_iterator<T>::operator++(int) [with T = Item_change_record]" -> "base_ilist_iterator<T>::next() [with T = Item_change_record]"
"List_iterator<T>::replace(List<T>&) [with T = TABLE_LIST]" -> "base_list_iterator::replace(base_list&)"
"base_list_iterator::replace(base_list&)" -> "base_list::is_empty() const"
"JOIN::set_prefix_tables()" -> "st_join_table::prefix_tables() const"
"JOIN::set_prefix_tables()" -> "st_join_table::get_sj_strategy() const"
"JOIN::set_prefix_tables()" -> "st_join_table::set_prefix_tables(table_map,table_map)"
"JOIN::set_prefix_tables()" -> "st_join_table::add_prefix_tables(table_map)"
"JOIN::set_prefix_tables()" -> "sj_is_materialize_strategy(uint)"
"JOIN::flatten_subqueries()" -> "has_trivial_destructor>::empty() const [with Element_type = Item_exists_subselect*,bool has_trivial_destructor = true]"
"JOIN::flatten_subqueries()" -> "has_trivial_destructor>::size() const [with Element_type = Item_exists_subselect*,bool has_trivial_destructor = true,size_t = long unsigned int]"
"JOIN::flatten_subqueries()" -> "Opt_trace_struct::add_select_number(uint)"
"JOIN::flatten_subqueries()" -> "Opt_trace_struct::add_alnum(const char*,const char*)"
"JOIN::flatten_subqueries()" -> "convert_subquery_to_semijoin(JOIN*,Item_exists_subselect*)"
"JOIN::flatten_subqueries()" -> "Opt_trace_object::Opt_trace_object(Opt_trace_context*,const char*,Opt_trace_context::feature_value)"
"JOIN::flatten_subqueries()" -> "Opt_trace_struct::add(const char*,bool)"
"JOIN::flatten_subqueries()" -> "has_trivial_destructor>::end() [with Element_type = Item_exists_subselect*,bool has_trivial_destructor = true]"
"JOIN::flatten_subqueries()" -> "Prepared_stmt_arena_holder::Prepared_stmt_arena_holder(THD*,bool)"
"JOIN::flatten_subqueries()" -> "Item_int::Item_int(int32,uint)"
"JOIN::flatten_subqueries()" -> "has_trivial_destructor>::clear() [with Element_type = Item_exists_subselect*,bool has_trivial_destructor = true]"
"JOIN::flatten_subqueries()" -> "TABLE_LIST::join_cond_ref()"
"JOIN::flatten_subqueries()" -> "Query_arena::is_conventional() const"
"JOIN::flatten_subqueries()" -> "has_trivial_destructor>::element_size() const [with Element_type = Item_exists_subselect*,bool has_trivial_destructor = true,size_t = long unsigned int]"
"JOIN::flatten_subqueries()" -> "st_select_lex_unit::first_select()"
"JOIN::flatten_subqueries()" -> "my_qsort(void*,size_t,size_t,qsort_cmp)"
"JOIN::flatten_subqueries()" -> "replace_subcondition(JOIN*,Item**,Item*,Item*,bool)"
"JOIN::flatten_subqueries()" -> "has_trivial_destructor>::begin() [with Element_type = Item_exists_subselect*,bool has_trivial_destructor = true]"
"JOIN::flatten_subqueries()" -> "Opt_trace_object::Opt_trace_object(Opt_trace_context*,Opt_trace_context::feature_value)"
"JOIN::flatten_subqueries()" -> "JOIN::flatten_subqueries()"
"has_trivial_destructor>::empty() const [with Element_type = Item_exists_subselect*,bool has_trivial_destructor = true]" -> "has_trivial_destructor>::size() const [with Element_type = Item_exists_subselect*,bool has_trivial_destructor = true,size_t = long unsigned int]"
"convert_subquery_to_semijoin(JOIN*,Item_exists_subselect*)" -> "TABLE_LIST::join_cond_ref()"
"convert_subquery_to_semijoin(JOIN*,Item_exists_subselect*)" -> "and_items(Item*,Item*)"
"convert_subquery_to_semijoin(JOIN*,Item_exists_subselect*)" -> "st_select_lex_unit::exclude_level()"
"convert_subquery_to_semijoin(JOIN*,Item_exists_subselect*)" -> "List_iterator_fast<T>::List_iterator_fast(List<T>&) [with T = TABLE_LIST]"
"convert_subquery_to_semijoin(JOIN*,Item_exists_subselect*)" -> "List_iterator_fast<T>::operator++(int) [with T = TABLE_LIST]"
"convert_subquery_to_semijoin(JOIN*,Item_exists_subselect*)" -> "st_select_lex_unit::first_select()"
"convert_subquery_to_semijoin(JOIN*,Item_exists_subselect*)" -> "List_iterator<T>::operator++(int) [with T = TABLE_LIST]"
"convert_subquery_to_semijoin(JOIN*,Item_exists_subselect*)" -> "List<T>::push_back(T*) [with T = TABLE_LIST]"
"convert_subquery_to_semijoin(JOIN*,Item_exists_subselect*)" -> "Item_row::Item_row(Item*,List<Item>&)"
"convert_subquery_to_semijoin(JOIN*,Item_exists_subselect*)" -> "fix_list_after_tbl_changes(st_select_lex*,st_select_lex*,List<TABLE_LIST>*)"
"convert_subquery_to_semijoin(JOIN*,Item_exists_subselect*)" -> "List<T>::push_back(T*) [with T = Item]"
"convert_subquery_to_semijoin(JOIN*,Item_exists_subselect*)" -> "List_iterator_fast<T>::List_iterator_fast(List<T>&) [with T = Item_func_match]"
"convert_subquery_to_semijoin(JOIN*,Item_exists_subselect*)" -> "Bounds_checked_array<Element_type>::operator[](size_t) [with Element_type = Item*,size_t = long unsigned int]"
"convert_subquery_to_semijoin(JOIN*,Item_exists_subselect*)" -> "TABLE_LIST::join_cond() const"
"convert_subquery_to_semijoin(JOIN*,Item_exists_subselect*)" -> "List_iterator<T>::replace(T*) [with T = TABLE_LIST]"
"convert_subquery_to_semijoin(JOIN*,Item_exists_subselect*)" -> "Opt_trace_array::Opt_trace_array(Opt_trace_context*,const char*,Opt_trace_context::feature_value)"
"convert_subquery_to_semijoin(JOIN*,Item_exists_subselect*)" -> "List<T>::push_front(T*) [with T = Item_func_match]"
"convert_subquery_to_semijoin(JOIN*,Item_exists_subselect*)" -> "List<T>::List() [with T = Item]"
"convert_subquery_to_semijoin(JOIN*,Item_exists_subselect*)" -> "TABLE_LIST::set_join_cond(Item*)"
"convert_subquery_to_semijoin(JOIN*,Item_exists_subselect*)" -> "base_list::empty()"
"convert_subquery_to_semijoin(JOIN*,Item_exists_subselect*)" -> "Item_func_eq::Item_func_eq(Item*,Item*)"
"convert_subquery_to_semijoin(JOIN*,Item_exists_subselect*)" -> "TABLE_LIST::new_nested_join(MEM_ROOT*,const char*,TABLE_LIST*,List<TABLE_LIST>*,st_select_lex*)"
"convert_subquery_to_semijoin(JOIN*,Item_exists_subselect*)" -> "List_iterator<T>::List_iterator(List<T>&) [with T = TABLE_LIST]"
"convert_subquery_to_semijoin(JOIN*,Item_exists_subselect*)" -> "List_iterator_fast<T>::operator++(int) [with T = Item_func_match]"
"and_items(Item*,Item*)" -> "Item_cond_and::Item_cond_and(Item*,Item*)"
"st_select_lex_unit::exclude_level()" -> "st_select_lex::first_inner_unit()"
"st_select_lex_unit::exclude_level()" -> "st_select_lex_unit::next_unit()"
"st_select_lex_unit::exclude_level()" -> "st_select_lex_unit::first_select()"
"st_select_lex_unit::exclude_level()" -> "st_select_lex::cleanup_level()"
"st_select_lex_unit::exclude_level()" -> "st_select_lex_unit::invalidate()"
"st_select_lex_unit::exclude_level()" -> "st_select_lex::invalidate()"
"st_select_lex_unit::exclude_level()" -> "st_select_lex::next_select()"
"st_select_lex_unit::exclude_level()" -> "st_select_lex_unit::cleanup_level()"
"Item_row::Item_row(Item*,List<Item>&)" -> "sql_alloc(size_t)"
"Item_row::Item_row(Item*,List<Item>&)" -> "List_iterator<T>::List_iterator(List<T>&) [with T = Item]"
"Item_row::Item_row(Item*,List<Item>&)" -> "Item::Item()"
"Item_row::Item_row(Item*,List<Item>&)" -> "List_iterator<T>::operator++(int) [with T = Item]"
"fix_list_after_tbl_changes(st_select_lex*,st_select_lex*,List<TABLE_LIST>*)" -> "List_iterator<T>::operator++(int) [with T = TABLE_LIST]"
"fix_list_after_tbl_changes(st_select_lex*,st_select_lex*,List<TABLE_LIST>*)" -> "List_iterator<T>::List_iterator(List<T>&) [with T = TABLE_LIST]"
"fix_list_after_tbl_changes(st_select_lex*,st_select_lex*,List<TABLE_LIST>*)" -> "fix_list_after_tbl_changes(st_select_lex*,st_select_lex*,List<TABLE_LIST>*)"
"fix_list_after_tbl_changes(st_select_lex*,st_select_lex*,List<TABLE_LIST>*)" -> "TABLE_LIST::join_cond() const"
"List_iterator<T>::replace(T*) [with T = TABLE_LIST]" -> "base_list_iterator::replace(void*)"
"has_trivial_destructor>::end() [with Element_type = Item_exists_subselect*,bool has_trivial_destructor = true]" -> "has_trivial_destructor>::size() const [with Element_type = Item_exists_subselect*,bool has_trivial_destructor = true,size_t = long unsigned int]"
"has_trivial_destructor>::clear() [with Element_type = Item_exists_subselect*,bool has_trivial_destructor = true]" -> "has_trivial_destructor>::empty() const [with Element_type = Item_exists_subselect*,bool has_trivial_destructor = true]"
"has_trivial_destructor>::clear() [with Element_type = Item_exists_subselect*,bool has_trivial_destructor = true]" -> "has_trivial_destructor>::chop(size_t) [with Element_type = Item_exists_subselect*,bool has_trivial_destructor = true,size_t = long unsigned int]"
"replace_subcondition(JOIN*,Item**,Item*,Item*,bool)" -> "List_iterator<T>::List_iterator(List<T>&) [with T = Item]"
"replace_subcondition(JOIN*,Item**,Item*,Item*,bool)" -> "List_iterator<T>::replace(T*) [with T = Item]"
"replace_subcondition(JOIN*,Item**,Item*,Item*,bool)" -> "List_iterator<T>::ref() [with T = Item]"
"replace_subcondition(JOIN*,Item**,Item*,Item*,bool)" -> "List_iterator<T>::operator++(int) [with T = Item]"
"replace_subcondition(JOIN*,Item**,Item*,Item*,bool)" -> "Item_cond::argument_list()"
"st_select_lex::handle_derived(LEX*,bool (*)(THD*,LEX*,TABLE_LIST*))" -> "TABLE_LIST::is_view_or_derived() const"
"st_select_lex::handle_derived(LEX*,bool (*)(THD*,LEX*,TABLE_LIST*))" -> "TABLE_LIST::handle_derived(LEX*,bool (*)(THD*,LEX*,TABLE_LIST*))"
"TABLE_LIST::handle_derived(LEX*,bool (*)(THD*,LEX*,TABLE_LIST*))" -> "TABLE_LIST::get_unit() const"
"TABLE_LIST::handle_derived(LEX*,bool (*)(THD*,LEX*,TABLE_LIST*))" -> "st_select_lex::next_select()"
"TABLE_LIST::handle_derived(LEX*,bool (*)(THD*,LEX*,TABLE_LIST*))" -> "TABLE_LIST::uses_materialization() const"
"TABLE_LIST::handle_derived(LEX*,bool (*)(THD*,LEX*,TABLE_LIST*))" -> "st_select_lex::handle_derived(LEX*,bool (*)(THD*,LEX*,TABLE_LIST*))"
"TABLE_LIST::handle_derived(LEX*,bool (*)(THD*,LEX*,TABLE_LIST*))" -> "st_select_lex_unit::first_select()"
"TABLE_LIST::handle_derived(LEX*,bool (*)(THD*,LEX*,TABLE_LIST*))" -> "mysql_handle_single_derived(LEX*,TABLE_LIST*,bool (*)(THD*,LEX*,TABLE_LIST*))"
"make_cond_for_table(Item*,table_map,table_map,bool)" -> "make_cond_for_table_from_pred(Item*,Item*,table_map,table_map,bool)"
"make_cond_for_table_from_pred(Item*,Item*,table_map,table_map,bool)" -> "Item_cond::argument_list()"
"make_cond_for_table_from_pred(Item*,Item*,table_map,table_map,bool)" -> "_current_thd()"
"make_cond_for_table_from_pred(Item*,Item*,table_map,table_map,bool)" -> "Item_func::arguments() const"
"make_cond_for_table_from_pred(Item*,Item*,table_map,table_map,bool)" -> "make_cond_for_table_from_pred(Item*,Item*,table_map,table_map,bool)"
"make_cond_for_table_from_pred(Item*,Item*,table_map,table_map,bool)" -> "test_if_ref(Item*,Item_field*,Item*)"
"make_cond_for_table_from_pred(Item*,Item*,table_map,table_map,bool)" -> "Item_cond_and::Item_cond_and()"
"make_cond_for_table_from_pred(Item*,Item*,table_map,table_map,bool)" -> "List<T>::push_back(T*) [with T = Item]"
"make_cond_for_table_from_pred(Item*,Item*,table_map,table_map,bool)" -> "List_iterator<T>::operator++(int) [with T = Item]"
"make_cond_for_table_from_pred(Item*,Item*,table_map,table_map,bool)" -> "Item_cond_or::Item_cond_or()"
"make_cond_for_table_from_pred(Item*,Item*,table_map,table_map,bool)" -> "List<T>::head() [with T = Item]"
"make_cond_for_table_from_pred(Item*,Item*,table_map,table_map,bool)" -> "List_iterator<T>::List_iterator(List<T>&) [with T = Item]"
"JOIN::optimize_fts_query()" -> "TABLE::set_keyread(bool)"
"JOIN::optimize_fts_query()" -> "JOIN::ORDER_with_src::operator=(JOIN::ORDER_with_src::null*)"
"JOIN::optimize_fts_query()" -> "List_iterator<T>::List_iterator(List<T>&) [with T = Item]"
"JOIN::optimize_fts_query()" -> "JOIN::replace_item_field(const char*,Item*)"
"JOIN::optimize_fts_query()" -> "Item_func_match::get_count()"
"JOIN::optimize_fts_query()" -> "JOIN::ORDER_with_src::operator ORDER*()"
"JOIN::optimize_fts_query()" -> "Bitmap<64u>::set_bit(uint)"
"JOIN::optimize_fts_query()" -> "JOIN::ORDER_with_src::operator->() const"
"JOIN::optimize_fts_query()" -> "strcmp(const char*,const char*)"
"JOIN::optimize_fts_query()" -> "Item_func_docid::Item_func_docid(FT_INFO_EXT*)"
"JOIN::optimize_fts_query()" -> "THD::inc_status_select_scan()"
"JOIN::optimize_fts_query()" -> "handler::ha_table_flags() const"
"JOIN::optimize_fts_query()" -> "THD::set_status_no_index_used()"
"JOIN::optimize_fts_query()" -> "Item_func_match::docid_in_result()"
"JOIN::optimize_fts_query()" -> "Item_func_match::ordered_result()"
"JOIN::optimize_fts_query()" -> "List_iterator<T>::operator++(int) [with T = Item]"
"JOIN::replace_item_field(const char*,Item*)" -> "List_iterator<T>::replace(T*) [with T = Item]"
"JOIN::replace_item_field(const char*,Item*)" -> "List_iterator<T>::operator++(int) [with T = Item]"
"JOIN::replace_item_field(const char*,Item*)" -> "List_iterator<T>::List_iterator(List<T>&) [with T = Item]"
"Item_func_docid::Item_func_docid(FT_INFO_EXT*)" -> "Item_int_func::Item_int_func()"
"Item_func_match::docid_in_result()" -> "handler::ha_table_flags() const"
"Item_func_match::ordered_result()" -> "handler::ha_table_flags() const"
"JOIN::drop_unused_derived_keys()" -> "TABLE_LIST::uses_materialization() const"
"JOIN::drop_unused_derived_keys()" -> "Bitmap<64u>::clear_all()"
"JOIN::drop_unused_derived_keys()" -> "Bitmap<64u>::set_bit(uint)"
"JOIN::drop_unused_derived_keys()" -> "TABLE::is_created() const"
"JOIN::drop_unused_derived_keys()" -> "TABLE::use_index(int)"
"JOIN::drop_unused_derived_keys()" -> "Bitmap<64u>::is_set(uint) const"
"TABLE::use_index(int)" -> "Bitmap<64u>::set_prefix(uint)"
"TABLE::use_index(int)" -> "Bitmap<64u>::is_set(uint) const"
"TABLE::use_index(int)" -> "Bitmap<64u>::clear_all()"
"create_distinct_group(THD*,Ref_ptr_array,ORDER*,List<Item>&,List<Item>&,bool*)" -> "List_iterator<T>::operator++(int) [with T = Item]"
"create_distinct_group(THD*,Ref_ptr_array,ORDER*,List<Item>&,List<Item>&,bool*)" -> "List_iterator<T>::rewind() [with T = Item]"
"create_distinct_group(THD*,Ref_ptr_array,ORDER*,List<Item>&,List<Item>&,bool*)" -> "List<T>::push_front(T*) [with T = Item]"
"create_distinct_group(THD*,Ref_ptr_array,ORDER*,List<Item>&,List<Item>&,bool*)" -> "Query_arena::memdup(const void*,size_t)"
"create_distinct_group(THD*,Ref_ptr_array,ORDER*,List<Item>&,List<Item>&,bool*)" -> "Bounds_checked_array<Element_type>::pop_front() [with Element_type = Item*]"
"create_distinct_group(THD*,Ref_ptr_array,ORDER*,List<Item>&,List<Item>&,bool*)" -> "List_iterator<T>::List_iterator(List<T>&) [with T = Item]"
"create_distinct_group(THD*,Ref_ptr_array,ORDER*,List<Item>&,List<Item>&,bool*)" -> "Query_arena::calloc(size_t)"
"create_distinct_group(THD*,Ref_ptr_array,ORDER*,List<Item>&,List<Item>&,bool*)" -> "Bounds_checked_array<Element_type>::operator[](size_t) [with Element_type = Item*,size_t = long unsigned int]"
"create_distinct_group(THD*,Ref_ptr_array,ORDER*,List<Item>&,List<Item>&,bool*)" -> "Item_field::Item_field(THD*,Item_field*)"
"add_ref_to_table_cond(THD*,JOIN_TAB*)" -> "st_join_table::set_jt_and_sel_condition(Item*,uint)"
"add_ref_to_table_cond(THD*,JOIN_TAB*)" -> "create_cond_for_const_ref(THD*,JOIN_TAB*)"
"add_ref_to_table_cond(THD*,JOIN_TAB*)" -> "make_select(TABLE*,table_map,table_map,Item*,bool,int*)"
"add_ref_to_table_cond(THD*,JOIN_TAB*)" -> "Opt_trace_struct::add(const char*,Item*)"
"add_ref_to_table_cond(THD*,JOIN_TAB*)" -> "Item_cond::add(Item*)"
"add_ref_to_table_cond(THD*,JOIN_TAB*)" -> "Opt_trace_object::Opt_trace_object(Opt_trace_context*,Opt_trace_context::feature_value)"
"add_ref_to_table_cond(THD*,JOIN_TAB*)" -> "st_join_table::set_condition(Item*,uint)"
"create_cond_for_const_ref(THD*,JOIN_TAB*)" -> "Item_func_equal::Item_func_equal(Item*,Item*)"
"create_cond_for_const_ref(THD*,JOIN_TAB*)" -> "Item_cond_and::Item_cond_and()"
"create_cond_for_const_ref(THD*,JOIN_TAB*)" -> "Item_cond::add(Item*)"
"create_cond_for_const_ref(THD*,JOIN_TAB*)" -> "Item_field::Item_field(Field*)"
"create_cond_for_const_ref(THD*,JOIN_TAB*)" -> "Item_func_eq::Item_func_eq(Item*,Item*)"
"JOIN::cache_const_exprs()" -> "st_join_table::set_condition(Item*,uint)"
"JOIN::cache_const_exprs()" -> "st_join_table::condition() const"
"build_bitmap_for_nested_joins(List<TABLE_LIST>*,uint)" -> "List_iterator<T>::List_iterator(List<T>&) [with T = TABLE_LIST]"
"build_bitmap_for_nested_joins(List<TABLE_LIST>*,uint)" -> "TABLE_LIST::join_cond() const"
"build_bitmap_for_nested_joins(List<TABLE_LIST>*,uint)" -> "List_iterator<T>::operator++(int) [with T = TABLE_LIST]"
"build_bitmap_for_nested_joins(List<TABLE_LIST>*,uint)" -> "build_bitmap_for_nested_joins(List<TABLE_LIST>*,uint)"
"AQP::Join_plan::Join_plan(const JOIN*)" -> "Sql_alloc::Sql_alloc()"
"AQP::Join_plan::Join_plan(const JOIN*)" -> "AQP::Table_access::Table_access()"
"AQP::Table_access::Table_access()" -> "Sql_alloc::Sql_alloc()"
"JOIN::make_tmp_tables_info()" -> "JOIN::ORDER_with_src::ORDER_with_src(JOIN::ORDER_with_src::null*)"
"JOIN::make_tmp_tables_info()" -> "count_field_types(SELECT_LEX*,TMP_TABLE_PARAM*,List<Item>&,bool)"
"JOIN::make_tmp_tables_info()" -> "make_cond_for_table(Item*,table_map,table_map,bool)"
"JOIN::make_tmp_tables_info()" -> "JOIN::ORDER_with_src::operator ORDER*()"
"JOIN::make_tmp_tables_info()" -> "(* setup_end_select_func(JOIN*,JOIN_TAB*))(JOIN*,st_join_table*,bool)"
"JOIN::make_tmp_tables_info()" -> "st_join_table::condition() const"
"JOIN::make_tmp_tables_info()" -> "test_if_subpart(ORDER*,ORDER*)"
"JOIN::make_tmp_tables_info()" -> "Explain_format_flags::set(Explain_sort_clause,Explain_sort_property)"
"JOIN::make_tmp_tables_info()" -> "setup_sum_funcs(THD*,Item_sum**)"
"JOIN::make_tmp_tables_info()" -> "JOIN::make_sum_func_list(List<Item>&,List<Item>&,bool,bool)"
"JOIN::make_tmp_tables_info()" -> "change_refs_to_tmp_fields(THD*,Ref_ptr_array,List<Item>&,List<Item>&,uint,List<Item>&)"
"JOIN::make_tmp_tables_info()" -> "make_group_fields(JOIN*,JOIN*)"
"JOIN::make_tmp_tables_info()" -> "calc_group_buffer(JOIN*,ORDER*)"
"JOIN::make_tmp_tables_info()" -> "JOIN::ORDER_with_src::ORDER_with_src()"
"JOIN::make_tmp_tables_info()" -> "JOIN::ref_ptr_array_slice(size_t)"
"JOIN::make_tmp_tables_info()" -> "JOIN::create_intermediate_table(JOIN_TAB*,List<Item>*,JOIN::ORDER_with_src&,bool)"
"JOIN::make_tmp_tables_info()" -> "JOIN::init_items_ref_array()"
"JOIN::make_tmp_tables_info()" -> "st_join_table::is_using_agg_loose_index_scan()"
"JOIN::make_tmp_tables_info()" -> "JOIN::plan_is_const() const"
"JOIN::make_tmp_tables_info()" -> "st_join_table::set_condition(Item*,uint)"
"JOIN::make_tmp_tables_info()" -> "setup_copy_fields(THD*,TMP_TABLE_PARAM*,Ref_ptr_array,List<Item>&,List<Item>&,uint,List<Item>&)"
"JOIN::make_tmp_tables_info()" -> "SQL_SELECT::SQL_SELECT()"
"JOIN::make_tmp_tables_info()" -> "THD::enter_stage(const PSI_stage_info*,PSI_stage_info*,const char*,const char*,unsigned int)"
"JOIN::make_tmp_tables_info()" -> "JOIN::add_sorting_to_table(JOIN_TAB*,JOIN::ORDER_with_src*)"
"JOIN::make_tmp_tables_info()" -> "prepare_sum_aggregators(Item_sum**,bool)"
"JOIN::make_tmp_tables_info()" -> "st_join_table::is_using_loose_index_scan()"
"JOIN::make_tmp_tables_info()" -> "Bounds_checked_array<Element_type>::is_null() const [with Element_type = Item*]"
"JOIN::make_tmp_tables_info()" -> "Item_cond_and::Item_cond_and(Item*,Item*)"
"JOIN::make_tmp_tables_info()" -> "JOIN::ORDER_with_src::operator=(JOIN::ORDER_with_src::null*)"
"JOIN::make_tmp_tables_info()" -> "JOIN::set_items_ref_array(Ref_ptr_array)"
"JOIN::make_tmp_tables_info()" -> "setup_tmptable_write_func(JOIN_TAB*)"
"JOIN::make_tmp_tables_info()" -> "JOIN::optimize_distinct()"
"JOIN::make_tmp_tables_info()" -> "change_to_use_tmp_fields(THD*,Ref_ptr_array,List<Item>&,List<Item>&,uint,List<Item>&)"
"JOIN::ORDER_with_src::ORDER_with_src(JOIN::ORDER_with_src::null*)" -> "JOIN::ORDER_with_src::clean()"
"setup_sum_funcs(THD*,Item_sum**)" -> "Item_sum::aggregator_setup(THD*)"
"change_refs_to_tmp_fields(THD*,Ref_ptr_array,List<Item>&,List<Item>&,uint,List<Item>&)" -> "List_iterator_fast<T>::List_iterator_fast(List<T>&) [with T = Item]"
"change_refs_to_tmp_fields(THD*,Ref_ptr_array,List<Item>&,List<Item>&,uint,List<Item>&)" -> "List_iterator_fast<T>::sublist(List<T>&,uint) [with T = Item,uint = unsigned int]"
"change_refs_to_tmp_fields(THD*,Ref_ptr_array,List<Item>&,List<Item>&,uint,List<Item>&)" -> "List<T>::push_back(T*) [with T = Item]"
"change_refs_to_tmp_fields(THD*,Ref_ptr_array,List<Item>&,List<Item>&,uint,List<Item>&)" -> "Bounds_checked_array<Element_type>::operator[](size_t) [with Element_type = Item*,size_t = long unsigned int]"
"change_refs_to_tmp_fields(THD*,Ref_ptr_array,List<Item>&,List<Item>&,uint,List<Item>&)" -> "base_list::empty()"
"change_refs_to_tmp_fields(THD*,Ref_ptr_array,List<Item>&,List<Item>&,uint,List<Item>&)" -> "List_iterator_fast<T>::operator++(int) [with T = Item]"
"List_iterator_fast<T>::sublist(List<T>&,uint) [with T = Item,uint = unsigned int]" -> "base_list_iterator::sublist(base_list&,uint)"
"make_group_fields(JOIN*,JOIN*)" -> "JOIN::ORDER_with_src::operator ORDER*()"
"make_group_fields(JOIN*,JOIN*)" -> "alloc_group_fields(JOIN*,ORDER*)"
"make_group_fields(JOIN*,JOIN*)" -> "__builtin_memcpy(void*,const void*,long unsigned int)"
"alloc_group_fields(JOIN*,ORDER*)" -> "List<T>::push_front(T*) [with T = Cached_item]"
"alloc_group_fields(JOIN*,ORDER*)" -> "new_Cached_item(THD*,Item*,bool)"
"List<T>::push_front(T*) [with T = Cached_item]" -> "base_list::push_front(void*)"
"new_Cached_item(THD*,Item*,bool)" -> "Cached_item_real::Cached_item_real(Item*)"
"new_Cached_item(THD*,Item*,bool)" -> "Cached_item_field::Cached_item_field(Field*)"
"new_Cached_item(THD*,Item*,bool)" -> "Cached_item_str::Cached_item_str(THD*,Item*)"
"new_Cached_item(THD*,Item*,bool)" -> "Cached_item_temporal::Cached_item_temporal(Item*)"
"new_Cached_item(THD*,Item*,bool)" -> "Cached_item_decimal::Cached_item_decimal(Item*)"
"new_Cached_item(THD*,Item*,bool)" -> "Item::is_temporal() const"
"new_Cached_item(THD*,Item*,bool)" -> "Cached_item_int::Cached_item_int(Item*)"
"Cached_item_real::Cached_item_real(Item*)" -> "Cached_item::Cached_item()"
"Cached_item::Cached_item()" -> "Sql_alloc::Sql_alloc()"
"Cached_item_field::Cached_item_field(Field*)" -> "Cached_item::Cached_item()"
"Cached_item_field::Cached_item_field(Field*)" -> "sql_calloc(size_t)"
"Cached_item_str::Cached_item_str(THD*,Item*)" -> "std::min(const _Tp&,const _Tp&) [with _Tp = unsigned int]"
"Cached_item_str::Cached_item_str(THD*,Item*)" -> "String::String(uint32)"
"Cached_item_str::Cached_item_str(THD*,Item*)" -> "String::String()"
"Cached_item_str::Cached_item_str(THD*,Item*)" -> "Cached_item::Cached_item()"
"Cached_item_temporal::Cached_item_temporal(Item*)" -> "Cached_item::Cached_item()"
"Cached_item_decimal::Cached_item_decimal(Item*)" -> "my_decimal_set_zero(my_decimal*)"
"Cached_item_decimal::Cached_item_decimal(Item*)" -> "my_decimal::my_decimal()"
"Cached_item_decimal::Cached_item_decimal(Item*)" -> "Cached_item::Cached_item()"
"Cached_item_int::Cached_item_int(Item*)" -> "Cached_item::Cached_item()"
"JOIN::create_intermediate_table(JOIN_TAB*,List<Item>*,JOIN::ORDER_with_src&,bool)" -> "Explain_format_flags::set(Explain_sort_clause,Explain_sort_property)"
"JOIN::create_intermediate_table(JOIN_TAB*,List<Item>*,JOIN::ORDER_with_src&,bool)" -> "prepare_sum_aggregators(Item_sum**,bool)"
"JOIN::create_intermediate_table(JOIN_TAB*,List<Item>*,JOIN::ORDER_with_src&,bool)" -> "create_tmp_table(THD*,TMP_TABLE_PARAM*,List<Item>&,ORDER*,bool,bool,ulonglong,ha_rows,const char*)"
"JOIN::create_intermediate_table(JOIN_TAB*,List<Item>*,JOIN::ORDER_with_src&,bool)" -> "QEP_tmp_table::QEP_tmp_table(JOIN_TAB*)"
"JOIN::create_intermediate_table(JOIN_TAB*,List<Item>*,JOIN::ORDER_with_src&,bool)" -> "THD::enter_stage(const PSI_stage_info*,PSI_stage_info*,const char*,const char*,unsigned int)"
"JOIN::create_intermediate_table(JOIN_TAB*,List<Item>*,JOIN::ORDER_with_src&,bool)" -> "JOIN::ORDER_with_src::operator ORDER*()"
"JOIN::create_intermediate_table(JOIN_TAB*,List<Item>*,JOIN::ORDER_with_src&,bool)" -> "TMP_TABLE_PARAM::TMP_TABLE_PARAM(const TMP_TABLE_PARAM&)"
"JOIN::create_intermediate_table(JOIN_TAB*,List<Item>*,JOIN::ORDER_with_src&,bool)" -> "free_tmp_table(THD*,TABLE*)"
"JOIN::create_intermediate_table(JOIN_TAB*,List<Item>*,JOIN::ORDER_with_src&,bool)" -> "alloc_group_fields(JOIN*,ORDER*)"
"JOIN::create_intermediate_table(JOIN_TAB*,List<Item>*,JOIN::ORDER_with_src&,bool)" -> "JOIN::make_sum_func_list(List<Item>&,List<Item>&,bool,bool)"
"JOIN::create_intermediate_table(JOIN_TAB*,List<Item>*,JOIN::ORDER_with_src&,bool)" -> "JOIN::ORDER_with_src::operator=(JOIN::ORDER_with_src::null*)"
"JOIN::create_intermediate_table(JOIN_TAB*,List<Item>*,JOIN::ORDER_with_src&,bool)" -> "setup_sum_funcs(THD*,Item_sum**)"
"JOIN::create_intermediate_table(JOIN_TAB*,List<Item>*,JOIN::ORDER_with_src&,bool)" -> "st_join_table::is_using_agg_loose_index_scan()"
"JOIN::create_intermediate_table(JOIN_TAB*,List<Item>*,JOIN::ORDER_with_src&,bool)" -> "JOIN::add_sorting_to_table(JOIN_TAB*,JOIN::ORDER_with_src*)"
"prepare_sum_aggregators(Item_sum**,bool)" -> "Item_sum::set_aggregator(Aggregator::Aggregator_type)"
"prepare_sum_aggregators(Item_sum**,bool)" -> "Item_sum::has_with_distinct() const"
"QEP_tmp_table::QEP_tmp_table(JOIN_TAB*)" -> "QEP_operation::QEP_operation(JOIN_TAB*)"
"TMP_TABLE_PARAM::TMP_TABLE_PARAM(const TMP_TABLE_PARAM&)" -> "List<T>::List(const List<T>&) [with T = Item]"
"st_join_table::is_using_agg_loose_index_scan()" -> "QUICK_GROUP_MIN_MAX_SELECT::is_agg_distinct()"
"JOIN::add_sorting_to_table(JOIN_TAB*,JOIN::ORDER_with_src*)" -> "JOIN::ORDER_with_src::operator ORDER*()"
"JOIN::add_sorting_to_table(JOIN_TAB*,JOIN::ORDER_with_src*)" -> "Explain_format_flags::set(Explain_sort_clause,Explain_sort_property)"
"JOIN::add_sorting_to_table(JOIN_TAB*,JOIN::ORDER_with_src*)" -> "st_join_table::set_condition(Item*,uint)"
"JOIN::add_sorting_to_table(JOIN_TAB*,JOIN::ORDER_with_src*)" -> "Filesort::Filesort(ORDER*,ha_rows,SQL_SELECT*)"
"JOIN::init_items_ref_array()" -> "JOIN::ref_ptr_array_slice(size_t)"
"JOIN::init_items_ref_array()" -> "JOIN::copy_ref_ptr_array(Ref_ptr_array,Ref_ptr_array)"
"setup_copy_fields(THD*,TMP_TABLE_PARAM*,Ref_ptr_array,List<Item>&,List<Item>&,uint,List<Item>&)" -> "Bounds_checked_array<Element_type>::operator[](size_t) [with Element_type = Item*,size_t = long unsigned int]"
"setup_copy_fields(THD*,TMP_TABLE_PARAM*,Ref_ptr_array,List<Item>&,List<Item>&,uint,List<Item>&)" -> "__builtin_memcpy(void*,const void*,long unsigned int)"
"setup_copy_fields(THD*,TMP_TABLE_PARAM*,Ref_ptr_array,List<Item>&,List<Item>&,uint,List<Item>&)" -> "Field::move_field(uchar*,uchar*,uchar)"
"setup_copy_fields(THD*,TMP_TABLE_PARAM*,Ref_ptr_array,List<Item>&,List<Item>&,uint,List<Item>&)" -> "sql_alloc(size_t)"
"setup_copy_fields(THD*,TMP_TABLE_PARAM*,Ref_ptr_array,List<Item>&,List<Item>&,uint,List<Item>&)" -> "base_list::empty()"
"setup_copy_fields(THD*,TMP_TABLE_PARAM*,Ref_ptr_array,List<Item>&,List<Item>&,uint,List<Item>&)" -> "List_iterator_fast<T>::sublist(List<T>&,uint) [with T = Item,uint = unsigned int]"
"setup_copy_fields(THD*,TMP_TABLE_PARAM*,Ref_ptr_array,List<Item>&,List<Item>&,uint,List<Item>&)" -> "List<T>::push_back(T*) [with T = Item]"
"setup_copy_fields(THD*,TMP_TABLE_PARAM*,Ref_ptr_array,List<Item>&,List<Item>&,uint,List<Item>&)" -> "Copy_field::set(uchar*,Field*)"
"setup_copy_fields(THD*,TMP_TABLE_PARAM*,Ref_ptr_array,List<Item>&,List<Item>&,uint,List<Item>&)" -> "Copy_field::Copy_field()"
"setup_copy_fields(THD*,TMP_TABLE_PARAM*,Ref_ptr_array,List<Item>&,List<Item>&,uint,List<Item>&)" -> "Item_copy::create(Item*)"
"setup_copy_fields(THD*,TMP_TABLE_PARAM*,Ref_ptr_array,List<Item>&,List<Item>&,uint,List<Item>&)" -> "List<T>::push_front(T*) [with T = Item]"
"setup_copy_fields(THD*,TMP_TABLE_PARAM*,Ref_ptr_array,List<Item>&,List<Item>&,uint,List<Item>&)" -> "List<T>::concat(List<T>*) [with T = Item]"
"setup_copy_fields(THD*,TMP_TABLE_PARAM*,Ref_ptr_array,List<Item>&,List<Item>&,uint,List<Item>&)" -> "List_iterator_fast<T>::operator++(int) [with T = Item]"
"setup_copy_fields(THD*,TMP_TABLE_PARAM*,Ref_ptr_array,List<Item>&,List<Item>&,uint,List<Item>&)" -> "List<T>::List() [with T = Item]"
"setup_copy_fields(THD*,TMP_TABLE_PARAM*,Ref_ptr_array,List<Item>&,List<Item>&,uint,List<Item>&)" -> "Item_field::Item_field(THD*,Item_field*)"
"setup_copy_fields(THD*,TMP_TABLE_PARAM*,Ref_ptr_array,List<Item>&,List<Item>&,uint,List<Item>&)" -> "List_iterator_fast<T>::List_iterator_fast(List<T>&) [with T = Item]"
"Copy_field::set(uchar*,Field*)" -> "Field::maybe_null() const"
"Item_copy::create(Item*)" -> "Item_copy_int::Item_copy_int(Item*)"
"Item_copy::create(Item*)" -> "Item_copy_uint::Item_copy_uint(Item*)"
"Item_copy::create(Item*)" -> "Item_copy_float::Item_copy_float(Item*)"
"Item_copy::create(Item*)" -> "Item_copy_decimal::Item_copy_decimal(Item*)"
"Item_copy::create(Item*)" -> "Item_copy_string::Item_copy_string(Item*)"
"Item_copy_int::Item_copy_int(Item*)" -> "Item_copy::Item_copy(Item*)"
"Item_copy::Item_copy(Item*)" -> "Item::Item()"
"Item_copy::Item_copy(Item*)" -> "__builtin_memcpy(void*,const void*,long unsigned int)"
"Item_copy::Item_copy(Item*)" -> "DTCollation::set(DTCollation&)"
"Item_copy_uint::Item_copy_uint(Item*)" -> "Item_copy_int::Item_copy_int(Item*)"
"Item_copy_float::Item_copy_float(Item*)" -> "Item_copy::Item_copy(Item*)"
"Item_copy_decimal::Item_copy_decimal(Item*)" -> "Item_copy::Item_copy(Item*)"
"Item_copy_decimal::Item_copy_decimal(Item*)" -> "my_decimal::my_decimal()"
"Item_copy_string::Item_copy_string(Item*)" -> "Item_copy::Item_copy(Item*)"
"setup_tmptable_write_func(JOIN_TAB*)" -> "QEP_tmp_table::set_write_func(Next_select_func)"
"setup_tmptable_write_func(JOIN_TAB*)" -> "memcpy(void*,const void*,size_t)"
"JOIN::optimize_distinct()" -> "JOIN::ORDER_with_src::operator ORDER*()"
"JOIN::optimize_distinct()" -> "JOIN::ORDER_with_src::operator=(JOIN::ORDER_with_src::null*)"
"change_to_use_tmp_fields(THD*,Ref_ptr_array,List<Item>&,List<Item>&,uint,List<Item>&)" -> "Item_func_set_user_var::Item_func_set_user_var(THD*,Item_func_set_user_var*)"
"change_to_use_tmp_fields(THD*,Ref_ptr_array,List<Item>&,List<Item>&,uint,List<Item>&)" -> "Item_func::set_arguments(List<Item>&)"
"change_to_use_tmp_fields(THD*,Ref_ptr_array,List<Item>&,List<Item>&,uint,List<Item>&)" -> "List<T>::List() [with T = Item]"
"change_to_use_tmp_fields(THD*,Ref_ptr_array,List<Item>&,List<Item>&,uint,List<Item>&)" -> "List_iterator_fast<T>::operator++(int) [with T = Item]"
"change_to_use_tmp_fields(THD*,Ref_ptr_array,List<Item>&,List<Item>&,uint,List<Item>&)" -> "List<T>::push_back(T*) [with T = Item]"
"change_to_use_tmp_fields(THD*,Ref_ptr_array,List<Item>&,List<Item>&,uint,List<Item>&)" -> "__builtin_memcpy(void*,const void*,long unsigned int)"
"change_to_use_tmp_fields(THD*,Ref_ptr_array,List<Item>&,List<Item>&,uint,List<Item>&)" -> "List_iterator_fast<T>::sublist(List<T>&,uint) [with T = Item,uint = unsigned int]"
"change_to_use_tmp_fields(THD*,Ref_ptr_array,List<Item>&,List<Item>&,uint,List<Item>&)" -> "base_list::empty()"
"change_to_use_tmp_fields(THD*,Ref_ptr_array,List<Item>&,List<Item>&,uint,List<Item>&)" -> "Bounds_checked_array<Element_type>::operator[](size_t) [with Element_type = Item*,size_t = long unsigned int]"
"change_to_use_tmp_fields(THD*,Ref_ptr_array,List<Item>&,List<Item>&,uint,List<Item>&)" -> "List_iterator_fast<T>::List_iterator_fast(List<T>&) [with T = Item]"
"change_to_use_tmp_fields(THD*,Ref_ptr_array,List<Item>&,List<Item>&,uint,List<Item>&)" -> "Item_field::Item_field(Field*)"
"Item_func_set_user_var::Item_func_set_user_var(THD*,Item_func_set_user_var*)" -> "String::String(const String&)"
"Item_func_set_user_var::Item_func_set_user_var(THD*,Item_func_set_user_var*)" -> "my_decimal::my_decimal(const my_decimal&)"
"Item_func_set_user_var::Item_func_set_user_var(THD*,Item_func_set_user_var*)" -> "Item_var_func::Item_var_func(THD*,Item_var_func*)"
"my_decimal::my_decimal(const my_decimal&)" -> "my_decimal::fix_buffer_pointer()"
"Item_var_func::Item_var_func(THD*,Item_var_func*)" -> "Item_func::Item_func(THD*,Item_func*)"
"Item_func::Item_func(THD*,Item_func*)" -> "memcpy(void*,const void*,size_t)"
"Item_func::Item_func(THD*,Item_func*)" -> "Query_arena::alloc(size_t)"
"Item_func::Item_func(THD*,Item_func*)" -> "Item_result_field::Item_result_field(THD*,Item_result_field*)"
"Item_result_field::Item_result_field(THD*,Item_result_field*)" -> "Item::Item(THD*,Item*)"
"make_join_select(JOIN*,Item*)" -> "Query_arena::memdup(const void*,size_t)"
"make_join_select(JOIN*,Item*)" -> "Opt_trace_struct::add_alnum(const char*,const char*)"
"make_join_select(JOIN*,Item*)" -> "st_join_table::added_tables() const"
"make_join_select(JOIN*,Item*)" -> "Item_int::Item_int(longlong,uint)"
"make_join_select(JOIN*,Item*)" -> "SQL_SELECT::SQL_SELECT()"
"make_join_select(JOIN*,Item*)" -> "Bitmap<64u>::merge(const Bitmap<64u>&)"
"make_join_select(JOIN*,Item*)" -> "add_not_null_conds(JOIN*)"
"make_join_select(JOIN*,Item*)" -> "Opt_trace_struct::add_utf8(const char*,const char*)"
"make_join_select(JOIN*,Item*)" -> "SQL_SELECT::test_quick_select(THD*,key_map,table_map,ha_rows,bool,st_order::enum_order)"
"make_join_select(JOIN*,Item*)" -> "Item::quick_fix_field()"
"make_join_select(JOIN*,Item*)" -> "Opt_trace_struct::add_utf8_table(const TABLE*)"
"make_join_select(JOIN*,Item*)" -> "Bitmap<64u>::clear_all()"
"make_join_select(JOIN*,Item*)" -> "Opt_trace_object::Opt_trace_object(Opt_trace_context*,const char*,Opt_trace_context::feature_value)"
"make_join_select(JOIN*,Item*)" -> "st_join_table::and_with_condition(Item*,uint)"
"make_join_select(JOIN*,Item*)" -> "test_if_order_by_key(ORDER*,TABLE*,uint,uint*)"
"make_join_select(JOIN*,Item*)" -> "Opt_trace_object::Opt_trace_object(Opt_trace_context*,Opt_trace_context::feature_value)"
"make_join_select(JOIN*,Item*)" -> "st_join_table::set_condition(Item*,uint)"
"make_join_select(JOIN*,Item*)" -> "Item_func_trig_cond::Item_func_trig_cond(Item*,bool*,st_join_table*,Item_func_trig_cond::enum_trig_type)"
"make_join_select(JOIN*,Item*)" -> "and_conditions(Item**,Item*)"
"make_join_select(JOIN*,Item*)" -> "pushdown_on_conditions(JOIN*,JOIN_TAB*)"
"make_join_select(JOIN*,Item*)" -> "JOIN::ORDER_with_src::operator ORDER*()"
"make_join_select(JOIN*,Item*)" -> "JOIN::plan_is_const() const"
"make_join_select(JOIN*,Item*)" -> "Opt_trace_struct::end()"
"make_join_select(JOIN*,Item*)" -> "Opt_trace_struct::add(const char*,bool)"
"make_join_select(JOIN*,Item*)" -> "Bitmap<64u>::operator!=(const Bitmap<64u>&) const"
"make_join_select(JOIN*,Item*)" -> "and_conds(Item*,Item*)"
"make_join_select(JOIN*,Item*)" -> "Bitmap<64u>::is_subset(const Bitmap<64u>&) const"
"make_join_select(JOIN*,Item*)" -> "st_join_table::prefix_tables() const"
"make_join_select(JOIN*,Item*)" -> "st_join_table::condition() const"
"make_join_select(JOIN*,Item*)" -> "Bitmap<64u>::is_clear_all() const"
"make_join_select(JOIN*,Item*)" -> "THD::optimizer_switch_flag(ulonglong) const"
"make_join_select(JOIN*,Item*)" -> "Opt_trace_struct::add(const char*,ulonglong)"
"make_join_select(JOIN*,Item*)" -> "add_found_match_trig_cond(JOIN_TAB*,Item*,JOIN_TAB*)"
"make_join_select(JOIN*,Item*)" -> "make_cond_for_table(Item*,table_map,table_map,bool)"
"make_join_select(JOIN*,Item*)" -> "Opt_trace_struct::add(const char*,Item*)"
"make_join_select(JOIN*,Item*)" -> "Opt_trace_array::Opt_trace_array(Opt_trace_context*,const char*,Opt_trace_context::feature_value)"
"make_join_select(JOIN*,Item*)" -> "Bitmap<64u>::is_set(uint) const"
"make_join_select(JOIN*,Item*)" -> "Bitmap<64u>::clear_bit(uint)"
"make_join_select(JOIN*,Item*)" -> "Opt_trace_struct::add(const char*,double)"
"add_not_null_conds(JOIN*)" -> "Item_func_isnotnull::Item_func_isnotnull(Item*)"
"add_not_null_conds(JOIN*)" -> "st_join_table::and_with_condition(Item*,uint)"
"st_join_table::and_with_condition(Item*,uint)" -> "and_conditions(Item**,Item*)"
"Item_func_trig_cond::Item_func_trig_cond(Item*,bool*,st_join_table*,Item_func_trig_cond::enum_trig_type)" -> "Item_bool_func::Item_bool_func(Item*)"
"pushdown_on_conditions(JOIN*,JOIN_TAB*)" -> "st_join_table::prefix_tables() const"
"pushdown_on_conditions(JOIN*,JOIN_TAB*)" -> "Item::quick_fix_field()"
"pushdown_on_conditions(JOIN*,JOIN_TAB*)" -> "add_found_match_trig_cond(JOIN_TAB*,Item*,JOIN_TAB*)"
"pushdown_on_conditions(JOIN*,JOIN_TAB*)" -> "st_join_table::and_with_jt_and_sel_condition(Item*,uint)"
"pushdown_on_conditions(JOIN*,JOIN_TAB*)" -> "make_cond_for_table(Item*,table_map,table_map,bool)"
"pushdown_on_conditions(JOIN*,JOIN_TAB*)" -> "st_join_table::added_tables() const"
"pushdown_on_conditions(JOIN*,JOIN_TAB*)" -> "Item_func_trig_cond::Item_func_trig_cond(Item*,bool*,st_join_table*,Item_func_trig_cond::enum_trig_type)"
"add_found_match_trig_cond(JOIN_TAB*,Item*,JOIN_TAB*)" -> "add_found_match_trig_cond(JOIN_TAB*,Item*,JOIN_TAB*)"
"add_found_match_trig_cond(JOIN_TAB*,Item*,JOIN_TAB*)" -> "Item::quick_fix_field()"
"add_found_match_trig_cond(JOIN_TAB*,Item*,JOIN_TAB*)" -> "Item_func_trig_cond::Item_func_trig_cond(Item*,bool*,st_join_table*,Item_func_trig_cond::enum_trig_type)"
"st_join_table::and_with_jt_and_sel_condition(Item*,uint)" -> "st_join_table::and_with_condition(Item*,uint)"
"Bitmap<64u>::operator!=(const Bitmap<64u>&) const" -> "Bitmap<64u>::operator==(const Bitmap<64u>&) const"
"st_select_lex_unit::explain()" -> "THD::is_error() const"
"st_select_lex_unit::explain()" -> "st_select_lex_unit::first_select()"
"st_select_lex_unit::explain()" -> "st_select_lex::next_select()"
"st_select_lex_unit::explain()" -> "st_select_lex_unit::init_prepare_fake_select_lex(THD*,bool)"
"st_select_lex_unit::explain()" -> "mysql_select(THD*,TABLE_LIST*,uint,List<Item>&,Item*,SQL_I_List<st_order>*,SQL_I_List<st_order>*,Item*,ulonglong,select_result*,SELECT_LEX_UNIT*,SELECT_LEX*)"
"st_select_lex_unit::explain()" -> "JOIN::explain()"
"mysql_select(THD*,TABLE_LIST*,uint,List<Item>&,Item*,SQL_I_List<st_order>*,SQL_I_List<st_order>*,Item*,ulonglong,select_result*,SELECT_LEX_UNIT*,SELECT_LEX*)" -> "mysql_prepare_select(THD*,TABLE_LIST*,uint,List<Item>&,Item*,uint,ORDER*,ORDER*,Item*,ulonglong,select_result*,SELECT_LEX_UNIT*,SELECT_LEX*,bool*)"
"mysql_select(THD*,TABLE_LIST*,uint,List<Item>&,Item*,SQL_I_List<st_order>*,SQL_I_List<st_order>*,Item*,ulonglong,select_result*,SELECT_LEX_UNIT*,SELECT_LEX*)" -> "mysql_execute_select(THD*,SELECT_LEX*,bool)"
"mysql_select(THD*,TABLE_LIST*,uint,List<Item>&,Item*,SQL_I_List<st_order>*,SQL_I_List<st_order>*,Item*,ulonglong,select_result*,SELECT_LEX_UNIT*,SELECT_LEX*)" -> "THD::enter_stage(const PSI_stage_info*,PSI_stage_info*,const char*,const char*,unsigned int)"
"mysql_select(THD*,TABLE_LIST*,uint,List<Item>&,Item*,SQL_I_List<st_order>*,SQL_I_List<st_order>*,Item*,ulonglong,select_result*,SELECT_LEX_UNIT*,SELECT_LEX*)" -> "st_select_lex::cleanup()"
"mysql_select(THD*,TABLE_LIST*,uint,List<Item>&,Item*,SQL_I_List<st_order>*,SQL_I_List<st_order>*,Item*,ulonglong,select_result*,SELECT_LEX_UNIT*,SELECT_LEX*)" -> "lock_tables(THD*,TABLE_LIST*,uint,uint)"
"mysql_select(THD*,TABLE_LIST*,uint,List<Item>&,Item*,SQL_I_List<st_order>*,SQL_I_List<st_order>*,Item*,ulonglong,select_result*,SELECT_LEX_UNIT*,SELECT_LEX*)" -> "Query_tables_list::is_query_tables_locked()"
"mysql_select(THD*,TABLE_LIST*,uint,List<Item>&,Item*,SQL_I_List<st_order>*,SQL_I_List<st_order>*,Item*,ulonglong,select_result*,SELECT_LEX_UNIT*,SELECT_LEX*)" -> "Query_cache::store_query(THD*,TABLE_LIST*)"
"mysql_prepare_select(THD*,TABLE_LIST*,uint,List<Item>&,Item*,uint,ORDER*,ORDER*,Item*,ulonglong,select_result*,SELECT_LEX_UNIT*,SELECT_LEX*,bool*)" -> "THD::enter_stage(const PSI_stage_info*,PSI_stage_info*,const char*,const char*,unsigned int)"
"mysql_prepare_select(THD*,TABLE_LIST*,uint,List<Item>&,Item*,uint,ORDER*,ORDER*,Item*,ulonglong,select_result*,SELECT_LEX_UNIT*,SELECT_LEX*,bool*)" -> "JOIN::JOIN(THD*,List<Item>&,ulonglong,select_result*)"
"mysql_prepare_select(THD*,TABLE_LIST*,uint,List<Item>&,Item*,uint,ORDER*,ORDER*,Item*,ulonglong,select_result*,SELECT_LEX_UNIT*,SELECT_LEX*,bool*)" -> "JOIN::reset()"
"mysql_prepare_select(THD*,TABLE_LIST*,uint,List<Item>&,Item*,uint,ORDER*,ORDER*,Item*,ulonglong,select_result*,SELECT_LEX_UNIT*,SELECT_LEX*,bool*)" -> "JOIN::prepare(TABLE_LIST*,uint,Item*,uint,ORDER*,ORDER*,Item*,SELECT_LEX*,SELECT_LEX_UNIT*)"
"mysql_prepare_select(THD*,TABLE_LIST*,uint,List<Item>&,Item*,uint,ORDER*,ORDER*,Item*,ulonglong,select_result*,SELECT_LEX_UNIT*,SELECT_LEX*,bool*)" -> "Item_subselect::is_uncacheable() const"
"mysql_prepare_select(THD*,TABLE_LIST*,uint,List<Item>&,Item*,uint,ORDER*,ORDER*,Item*,ulonglong,select_result*,SELECT_LEX_UNIT*,SELECT_LEX*,bool*)" -> "JOIN::change_result(select_result*)"
"mysql_execute_select(THD*,SELECT_LEX*,bool)" -> "JOIN::explain()"
"mysql_execute_select(THD*,SELECT_LEX*,bool)" -> "st_select_lex::cleanup()"
"mysql_execute_select(THD*,SELECT_LEX*,bool)" -> "THD::enter_stage(const PSI_stage_info*,PSI_stage_info*,const char*,const char*,unsigned int)"
"mysql_execute_select(THD*,SELECT_LEX*,bool)" -> "THD::is_error() const"
"mysql_execute_select(THD*,SELECT_LEX*,bool)" -> "JOIN::exec()"
"mysql_execute_select(THD*,SELECT_LEX*,bool)" -> "JOIN::optimize()"
"JOIN::explain()" -> "Opt_trace_object::Opt_trace_object(Opt_trace_context*,Opt_trace_context::feature_value)"
"JOIN::explain()" -> "Opt_trace_array::Opt_trace_array(Opt_trace_context*,const char*,Opt_trace_context::feature_value)"
"JOIN::explain()" -> "Opt_trace_struct::add_select_number(uint)"
"JOIN::explain()" -> "THD::set_examined_row_count(ha_rows)"
"JOIN::explain()" -> "JOIN::prepare_result(List<Item>**)"
"JOIN::explain()" -> "THD::enter_stage(const PSI_stage_info*,PSI_stage_info*,const char*,const char*,unsigned int)"
"JOIN::explain()" -> "explain_query_specification(THD*,JOIN*)"
"JOIN::explain()" -> "explain_no_table(THD*,JOIN*,const char*)"
"JOIN::explain()" -> "Opt_trace_object::Opt_trace_object(Opt_trace_context*,const char*,Opt_trace_context::feature_value)"
"JOIN::prepare_result(List<Item>**)" -> "get_schema_tables_result(JOIN*,enum_schema_table_state)"
"JOIN::prepare_result(List<Item>**)" -> "st_select_lex::handle_derived(LEX*,bool (*)(THD*,LEX*,TABLE_LIST*))"
"get_schema_tables_result(JOIN*,enum_schema_table_state)" -> "filesort_free_buffers(TABLE*,bool)"
"get_schema_tables_result(JOIN*,enum_schema_table_state)" -> "handler::ha_delete_all_rows()"
"get_schema_tables_result(JOIN*,enum_schema_table_state)" -> "do_fill_table(THD*,TABLE_LIST*,JOIN_TAB*)"
"get_schema_tables_result(JOIN*,enum_schema_table_state)" -> "THD::fill_information_schema_tables()"
"get_schema_tables_result(JOIN*,enum_schema_table_state)" -> "free_io_cache(TABLE*)"
"do_fill_table(THD*,TABLE_LIST*,JOIN_TAB*)" -> "st_join_table::unified_condition() const"
"do_fill_table(THD*,TABLE_LIST*,JOIN_TAB*)" -> "Diagnostics_area::push_warning_info(Warning_info*)"
"do_fill_table(THD*,TABLE_LIST*,JOIN_TAB*)" -> "Diagnostics_area::get_sqlstate() const"
"do_fill_table(THD*,TABLE_LIST*,JOIN_TAB*)" -> "Diagnostics_area::message() const"
"do_fill_table(THD*,TABLE_LIST*,JOIN_TAB*)" -> "Diagnostics_area::push_warning(THD*,uint,const char*,Sql_condition::enum_warning_level,const char*)"
"do_fill_table(THD*,TABLE_LIST*,JOIN_TAB*)" -> "Diagnostics_area::sql_errno() const"
"do_fill_table(THD*,TABLE_LIST*,JOIN_TAB*)" -> "THD::get_stmt_da()"
"do_fill_table(THD*,TABLE_LIST*,JOIN_TAB*)" -> "Diagnostics_area::copy_non_errors_from_wi(THD*,const Warning_info*)"
"do_fill_table(THD*,TABLE_LIST*,JOIN_TAB*)" -> "Diagnostics_area::pop_warning_info()"
"do_fill_table(THD*,TABLE_LIST*,JOIN_TAB*)" -> "Warning_info::Warning_info(ulonglong,bool)"
"do_fill_table(THD*,TABLE_LIST*,JOIN_TAB*)" -> "Diagnostics_area::is_error() const"
"st_join_table::unified_condition() const" -> "st_join_table::condition() const"
"Diagnostics_area::copy_non_errors_from_wi(THD*,const Warning_info*)" -> "Warning_info::is_marked_for_removal(const Sql_condition*) const"
"Diagnostics_area::copy_non_errors_from_wi(THD*,const Warning_info*)" -> "Diagnostics_area::get_warning_info()"
"Diagnostics_area::copy_non_errors_from_wi(THD*,const Warning_info*)" -> "Warning_info::mark_condition_for_removal(Sql_condition*)"
"Diagnostics_area::copy_non_errors_from_wi(THD*,const Warning_info*)" -> "Sql_condition::get_level() const"
"Diagnostics_area::copy_non_errors_from_wi(THD*,const Warning_info*)" -> "Warning_info::push_warning(THD*,const Sql_condition*)"
"Diagnostics_area::copy_non_errors_from_wi(THD*,const Warning_info*)" -> "L>::I_P_List_iterator(const L&) [with T = const Sql_condition,L = I_P_List<Sql_condition,I_P_List_adapter<Sql_condition,&Sql_condition::next_in_wi,&Sql_condition::prev_in_wi>,I_P_List_counter,I_P_List_fast_push_back<Sql_condition> >]"
"Diagnostics_area::copy_non_errors_from_wi(THD*,const Warning_info*)" -> "L>::operator++(int) [with T = const Sql_condition,L = I_P_List<Sql_condition,I_P_List_adapter<Sql_condition,&Sql_condition::next_in_wi,&Sql_condition::prev_in_wi>,I_P_List_counter,I_P_List_fast_push_back<Sql_condition> >]"
"THD::fill_information_schema_tables()" -> "Query_arena::is_stmt_prepare() const"
"explain_query_specification(THD*,JOIN*)" -> "Explain::send()"
"explain_query_specification(THD*,JOIN*)" -> "Explain_format_flags::any(Explain_sort_property) const"
"explain_query_specification(THD*,JOIN*)" -> "Explain_union_result::Explain_union_result(THD*,JOIN*)"
"explain_query_specification(THD*,JOIN*)" -> "Explain_format_flags::get(Explain_sort_clause,Explain_sort_property) const"
"explain_query_specification(THD*,JOIN*)" -> "Explain_join::Explain_join(THD*,JOIN*,bool,bool,bool)"
"Explain::send()" -> "select_send::select_send()"
"Explain::send()" -> "Explain::prepare(select_result*)"
"Explain::send()" -> "st_select_lex::first_inner_unit()"
"Explain::send()" -> "propagate_explain_option(THD*,SELECT_LEX_UNIT*)"
"Explain::send()" -> "Explain::explain_subqueries(select_result*)"
"Explain::send()" -> "select_result::reset_offset_limit_cnt()"
"Explain::send()" -> "Explain::select_lex() const"
"Explain::send()" -> "st_select_lex_unit::next_unit()"
"Explain::prepare(select_result*)" -> "List<T>::List() [with T = Item]"
"Explain::prepare(select_result*)" -> "Explain::select_lex() const"
"Explain::explain_subqueries(select_result*)" -> "qep_row::mem_root_str::set(const char*,size_t)"
"Explain::explain_subqueries(select_result*)" -> "st_select_lex_unit::first_select()"
"Explain::explain_subqueries(select_result*)" -> "st_select_lex::type(const THD*)"
"Explain::explain_subqueries(select_result*)" -> "subselect_hash_sj_engine::get_join_tab() const"
"Explain::explain_subqueries(select_result*)" -> "explain_ref_key(Explain_format*,uint,store_key**)"
"Explain::explain_subqueries(select_result*)" -> "List_iterator<T>::List_iterator(List<T>&) [with T = Item]"
"Explain::explain_subqueries(select_result*)" -> "st_select_lex_unit::next_unit()"
"Explain::explain_subqueries(select_result*)" -> "qep_row::column<T>::set(T) [with T = long long int]"
"Explain::explain_subqueries(select_result*)" -> "int2str(long int,char*,int,int)"
"Explain::explain_subqueries(select_result*)" -> "base_list::is_empty() const"
"Explain::explain_subqueries(select_result*)" -> "Explain::select_lex() const"
"Explain::explain_subqueries(select_result*)" -> "Explain::mark_subqueries(Item*,qep_row*,Explain_context_enum)"
"Explain::explain_subqueries(select_result*)" -> "mysql_explain_unit(THD*,SELECT_LEX_UNIT*,select_result*)"
"Explain::explain_subqueries(select_result*)" -> "List_iterator<T>::operator++(int) [with T = Item]"
"Explain::explain_subqueries(select_result*)" -> "Explain::mark_order_subqueries(const JOIN::ORDER_with_src&)"
"Explain::explain_subqueries(select_result*)" -> "Item_subselect::get_engine_for_explain() const"
"Explain::explain_subqueries(select_result*)" -> "st_select_lex::first_inner_unit()"
"Explain::explain_subqueries(select_result*)" -> "qep_row::mem_root_str::set_const(const char*)"
"qep_row::mem_root_str::set(const char*,size_t)" -> "_current_thd()"
"qep_row::mem_root_str::set(const char*,size_t)" -> "qep_row::mem_root_str::strndup_root(MEM_ROOT*,const char*,size_t)"
"qep_row::mem_root_str::strndup_root(MEM_ROOT*,const char*,size_t)" -> "alloc_root(MEM_ROOT*,size_t)"
"qep_row::mem_root_str::strndup_root(MEM_ROOT*,const char*,size_t)" -> "memdup_root(MEM_ROOT*,const void*,size_t)"
"qep_row::mem_root_str::strndup_root(MEM_ROOT*,const char*,size_t)" -> "memcpy(void*,const void*,size_t)"
"st_select_lex::type(const THD*)" -> "st_select_lex::next_select()"
"st_select_lex::type(const THD*)" -> "st_select_lex_unit::first_select()"
"st_select_lex::type(const THD*)" -> "st_select_lex::first_inner_unit()"
"explain_ref_key(Explain_format*,uint,store_key**)" -> "List<T>::push_back(T*) [with T = const char]"
"List<T>::push_back(T*) [with T = const char]" -> "base_list::push_back(void*)"
"Explain::mark_subqueries(Item*,qep_row*,Explain_context_enum)" -> "Explain_subquery_marker::Explain_subquery_marker(qep_row*,Explain_context_enum)"
"Explain::mark_order_subqueries(const JOIN::ORDER_with_src&)" -> "JOIN::ORDER_with_src::operator const ORDER*() const"
"Explain::mark_order_subqueries(const JOIN::ORDER_with_src&)" -> "Explain::mark_subqueries(Item*,qep_row*,Explain_context_enum)"
"qep_row::mem_root_str::set_const(const char*)" -> "strlen(const char*)"
"qep_row::mem_root_str::set_const(const char*)" -> "qep_row::mem_root_str::set_const(const char*,size_t)"
"Explain_union_result::Explain_union_result(THD*,JOIN*)" -> "Explain::Explain(Explain_context_enum,THD*,JOIN*)"
"Explain::Explain(Explain_context_enum,THD*,JOIN*)" -> "JOIN::ORDER_with_src::ORDER_with_src(JOIN::ORDER_with_src::null*)"
"Explain::Explain(Explain_context_enum,THD*,JOIN*)" -> "Explain::select_lex() const"
"Explain::Explain(Explain_context_enum,THD*,JOIN*)" -> "JOIN::ORDER_with_src::ORDER_with_src(ORDER*,Explain_sort_clause)"
"Explain_join::Explain_join(THD*,JOIN*,bool,bool,bool)" -> "Explain_table_base::Explain_table_base(Explain_context_enum,THD*,JOIN*)"
"Explain_table_base::Explain_table_base(Explain_context_enum,THD*,JOIN*)" -> "Bitmap<64u>::Bitmap()"
"Explain_table_base::Explain_table_base(Explain_context_enum,THD*,JOIN*)" -> "Explain::Explain(Explain_context_enum,THD*,JOIN*)"
"explain_no_table(THD*,JOIN*,const char*)" -> "Explain_no_table::Explain_no_table(THD*,JOIN*,const char*)"
"explain_no_table(THD*,JOIN*,const char*)" -> "Explain::send()"
"Explain_no_table::Explain_no_table(THD*,JOIN*,const char*)" -> "Explain::Explain(Explain_context_enum,THD*,JOIN*)"
"JOIN::exec()" -> "THD::get_sent_row_count() const"
"JOIN::exec()" -> "Opt_trace_struct::add_select_number(uint)"
"JOIN::exec()" -> "THD::enter_stage(const PSI_stage_info*,PSI_stage_info*,const char*,const char*,unsigned int)"
"JOIN::exec()" -> "JOIN::prepare_result(List<Item>**)"
"JOIN::exec()" -> "Opt_trace_object::Opt_trace_object(Opt_trace_context*,const char*,Opt_trace_context::feature_value)"
"JOIN::exec()" -> "THD::is_error() const"
"JOIN::exec()" -> "JOIN::ORDER_with_src::operator ORDER*()"
"JOIN::exec()" -> "return_zero_rows(JOIN*,List<Item>&)"
"JOIN::exec()" -> "THD::inc_examined_row_count(ha_rows)"
"JOIN::exec()" -> "Opt_trace_array::Opt_trace_array(Opt_trace_context*,const char*,Opt_trace_context::feature_value)"
"JOIN::exec()" -> "THD::set_examined_row_count(ha_rows)"
"JOIN::exec()" -> "Opt_trace_object::Opt_trace_object(Opt_trace_context*,Opt_trace_context::feature_value)"
"JOIN::exec()" -> "do_select(JOIN*)"
"JOIN::exec()" -> "init_ftfuncs(THD*,SELECT_LEX*,bool)"
"return_zero_rows(JOIN*,List<Item>&)" -> "THD::set_examined_row_count(ha_rows)"
"return_zero_rows(JOIN*,List<Item>&)" -> "JOIN::join_free()"
"return_zero_rows(JOIN*,List<Item>&)" -> "List_iterator_fast<T>::operator++(int) [with T = Item]"
"return_zero_rows(JOIN*,List<Item>&)" -> "List_iterator_fast<T>::List_iterator_fast(List<T>&) [with T = Item]"
"return_zero_rows(JOIN*,List<Item>&)" -> "JOIN::send_row_on_empty_set() const"
"return_zero_rows(JOIN*,List<Item>&)" -> "mark_as_null_row(TABLE*)"
"JOIN::join_free()" -> "st_select_lex::cleanup_all_joins(bool)"
"JOIN::join_free()" -> "Item_subselect::is_evaluated() const"
"JOIN::join_free()" -> "mysql_unlock_read_tables(THD*,MYSQL_LOCK*)"
"JOIN::join_free()" -> "st_select_lex_unit::next_unit()"
"JOIN::join_free()" -> "JOIN::cleanup(bool)"
"JOIN::join_free()" -> "st_select_lex::next_select()"
"JOIN::join_free()" -> "st_select_lex_unit::first_select()"
"JOIN::join_free()" -> "st_select_lex::first_inner_unit()"
"st_select_lex::cleanup_all_joins(bool)" -> "st_select_lex::cleanup_all_joins(bool)"
"st_select_lex::cleanup_all_joins(bool)" -> "JOIN::cleanup(bool)"
"st_select_lex::cleanup_all_joins(bool)" -> "st_select_lex::next_select()"
"st_select_lex::cleanup_all_joins(bool)" -> "st_select_lex::first_inner_unit()"
"st_select_lex::cleanup_all_joins(bool)" -> "st_select_lex_unit::first_select()"
"st_select_lex::cleanup_all_joins(bool)" -> "st_select_lex_unit::next_unit()"
"mysql_unlock_read_tables(THD*,MYSQL_LOCK*)" -> "unlock_external(THD*,TABLE**,uint)"
"mysql_unlock_read_tables(THD*,MYSQL_LOCK*)" -> "thr_multi_unlock(THR_LOCK_DATA**,uint)"
"JOIN::send_row_on_empty_set() const" -> "JOIN::ORDER_with_src::operator const ORDER*() const"
"do_select(JOIN*)" -> "JOIN::send_row_on_empty_set() const"
"do_select(JOIN*)" -> "(* setup_end_select_func(JOIN*,JOIN_TAB*))(JOIN*,st_join_table*,bool)"
"do_select(JOIN*)" -> "List_iterator_fast<T>::List_iterator_fast(List<T>&) [with T = Item]"
"do_select(JOIN*)" -> "restore_const_null_info(JOIN*,table_map)"
"do_select(JOIN*)" -> "List_iterator_fast<T>::operator++(int) [with T = Item]"
"do_select(JOIN*)" -> "JOIN::plan_is_const() const"
"do_select(JOIN*)" -> "JOIN::join_free()"
"do_select(JOIN*)" -> "save_const_null_info(JOIN*,table_map*)"
"do_select(JOIN*)" -> "THD::is_error() const"
"do_select(JOIN*)" -> "JOIN::clear()"
"do_select(JOIN*)" -> "JOIN::ORDER_with_src::operator ORDER*()"
"JOIN::clear()" -> "copy_fields(TMP_TABLE_PARAM*)"
"JOIN::clear()" -> "mark_as_null_row(TABLE*)"
"copy_fields(TMP_TABLE_PARAM*)" -> "List_iterator_fast<T>::operator++(int) [with T = Item]"
"copy_fields(TMP_TABLE_PARAM*)" -> "List_iterator_fast<T>::List_iterator_fast(List<T>&) [with T = Item]"
"Query_cache::store_query(THD*,TABLE_LIST*)" -> "Query_cache::register_all_tables(Query_cache_block*,TABLE_LIST*,uint)"
"Query_cache::store_query(THD*,TABLE_LIST*)" -> "ha_release_temporary_latches(THD*)"
"Query_cache::store_query(THD*,TABLE_LIST*)" -> "Query_cache_query::init_n_lock()"
"Query_cache::store_query(THD*,TABLE_LIST*)" -> "Query_cache::free_memory_block(Query_cache_block*)"
"Query_cache::store_query(THD*,TABLE_LIST*)" -> "Query_cache_query::tables_type(uint8)"
"Query_cache::store_query(THD*,TABLE_LIST*)" -> "Query_cache_query::unlock_writing()"
"Query_cache::store_query(THD*,TABLE_LIST*)" -> "Statement::query_length() const"
"Query_cache::store_query(THD*,TABLE_LIST*)" -> "Query_cache::write_block_data(ulong,uchar*,ulong,Query_cache_block::block_type,uint)"
"Query_cache::store_query(THD*,TABLE_LIST*)" -> "Statement::query() const"
"Query_cache::store_query(THD*,TABLE_LIST*)" -> "memcpy(void*,const void*,size_t)"
"Query_cache::store_query(THD*,TABLE_LIST*)" -> "Query_cache::double_linked_list_simple_include(Query_cache_block*,Query_cache_block**)"
"Query_cache::store_query(THD*,TABLE_LIST*)" -> "memset(void*,int,size_t)"
"Query_cache::store_query(THD*,TABLE_LIST*)" -> "Query_cache_query::writer(Query_cache_tls*)"
"Query_cache::store_query(THD*,TABLE_LIST*)" -> "Query_cache::is_cacheable(THD*,size_t,const char*,LEX*,TABLE_LIST*,uint8*)"
"Query_cache::store_query(THD*,TABLE_LIST*)" -> "Query_cache::try_lock(bool)"
"Query_cache::store_query(THD*,TABLE_LIST*)" -> "my_hash_delete(HASH*,uchar*)"
"Query_cache::store_query(THD*,TABLE_LIST*)" -> "Query_cache::ask_handler_allowance(THD*,TABLE_LIST*)"
"Query_cache::store_query(THD*,TABLE_LIST*)" -> "Query_cache::unlock()"
"Query_cache::store_query(THD*,TABLE_LIST*)" -> "my_hash_insert(HASH*,const uchar*)"
"Query_cache::store_query(THD*,TABLE_LIST*)" -> "Query_cache_block::query()"
"Query_cache::store_query(THD*,TABLE_LIST*)" -> "Query_cache_query::unlock_n_destroy()"
"Query_cache::store_query(THD*,TABLE_LIST*)" -> "THD::in_active_multi_stmt_transaction() const"
"Query_cache::store_query(THD*,TABLE_LIST*)" -> "my_hash_search(const HASH*,const uchar*,size_t)"
"Query_cache::register_all_tables(Query_cache_block*,TABLE_LIST*,uint)" -> "Query_cache_block::table(uint)"
"Query_cache::register_all_tables(Query_cache_block*,TABLE_LIST*,uint)" -> "Query_cache::unlink_table(Query_cache_block_table*)"
"Query_cache::register_all_tables(Query_cache_block*,TABLE_LIST*,uint)" -> "Query_cache::register_tables_from_list(TABLE_LIST*,uint,Query_cache_block_table*)"
"Query_cache::register_tables_from_list(TABLE_LIST*,uint,Query_cache_block_table*)" -> "TABLE_SHARE::db_type() const"
"Query_cache::register_tables_from_list(TABLE_LIST*,uint,Query_cache_block_table*)" -> "Query_cache::filename_2_table_key(char*,const char*,uint32*)"
"Query_cache::register_tables_from_list(TABLE_LIST*,uint,Query_cache_block_table*)" -> "Query_cache::insert_table(uint,const char*,Query_cache_block_table*,uint32,uint8,qc_engine_callback,ulonglong)"
"Query_cache::register_tables_from_list(TABLE_LIST*,uint,Query_cache_block_table*)" -> "get_table_def_key(const TABLE_LIST*,const char**)"
"Query_cache::register_tables_from_list(TABLE_LIST*,uint,Query_cache_block_table*)" -> "ha_myisammrg::myrg_info()"
"Query_cache::register_tables_from_list(TABLE_LIST*,uint,Query_cache_block_table*)" -> "TABLE_LIST::is_anonymous_derived_table() const"
"Query_cache::filename_2_table_key(char*,const char*,uint32*)" -> "std::min(const _Tp&,const _Tp&) [with _Tp = unsigned int]"
"Query_cache::filename_2_table_key(char*,const char*,uint32*)" -> "dirname_length(const char*)"
"Query_cache::filename_2_table_key(char*,const char*,uint32*)" -> "strmake(char*,const char*,size_t)"
"Query_cache::filename_2_table_key(char*,const char*,uint32*)" -> "fn_format(char*,const char*,const char*,const char*,uint)"
"Query_cache::insert_table(uint,const char*,Query_cache_block_table*,uint32,uint8,qc_engine_callback,ulonglong)" -> "Query_cache::invalidate_query_block_list(THD*,Query_cache_block_table*)"
"Query_cache::insert_table(uint,const char*,Query_cache_block_table*,uint32,uint8,qc_engine_callback,ulonglong)" -> "Query_cache_table::engine_data()"
"Query_cache::insert_table(uint,const char*,Query_cache_block_table*,uint32,uint8,qc_engine_callback,ulonglong)" -> "Query_cache_table::key_length(uint32)"
"Query_cache::insert_table(uint,const char*,Query_cache_block_table*,uint32,uint8,qc_engine_callback,ulonglong)" -> "Query_cache::free_memory_block(Query_cache_block*)"
"Query_cache::insert_table(uint,const char*,Query_cache_block_table*,uint32,uint8,qc_engine_callback,ulonglong)" -> "Query_cache_block::table()"
"Query_cache::insert_table(uint,const char*,Query_cache_block_table*,uint32,uint8,qc_engine_callback,ulonglong)" -> "my_hash_insert(HASH*,const uchar*)"
"Query_cache::insert_table(uint,const char*,Query_cache_block_table*,uint32,uint8,qc_engine_callback,ulonglong)" -> "Query_cache_table::callback(qc_engine_callback)"
"Query_cache::insert_table(uint,const char*,Query_cache_block_table*,uint32,uint8,qc_engine_callback,ulonglong)" -> "Query_cache_table::table(char*)"
"Query_cache::insert_table(uint,const char*,Query_cache_block_table*,uint32,uint8,qc_engine_callback,ulonglong)" -> "Query_cache_block::table(uint)"
"Query_cache::insert_table(uint,const char*,Query_cache_block_table*,uint32,uint8,qc_engine_callback,ulonglong)" -> "my_hash_search(const HASH*,const uchar*,size_t)"
"Query_cache::insert_table(uint,const char*,Query_cache_block_table*,uint32,uint8,qc_engine_callback,ulonglong)" -> "Query_cache_table::engine_data(ulonglong)"
"Query_cache::insert_table(uint,const char*,Query_cache_block_table*,uint32,uint8,qc_engine_callback,ulonglong)" -> "Query_cache::double_linked_list_simple_include(Query_cache_block*,Query_cache_block**)"
"Query_cache::insert_table(uint,const char*,Query_cache_block_table*,uint32,uint8,qc_engine_callback,ulonglong)" -> "_current_thd()"
"Query_cache::insert_table(uint,const char*,Query_cache_block_table*,uint32,uint8,qc_engine_callback,ulonglong)" -> "Query_cache_table::db()"
"Query_cache::insert_table(uint,const char*,Query_cache_block_table*,uint32,uint8,qc_engine_callback,ulonglong)" -> "Query_cache_table::type(uint8)"
"Query_cache::insert_table(uint,const char*,Query_cache_block_table*,uint32,uint8,qc_engine_callback,ulonglong)" -> "Query_cache::write_block_data(ulong,uchar*,ulong,Query_cache_block::block_type,uint)"
"Query_cache::write_block_data(ulong,uchar*,ulong,Query_cache_block::block_type,uint)" -> "memcpy(void*,const void*,size_t)"
"Query_cache::write_block_data(ulong,uchar*,ulong,Query_cache_block::block_type,uint)" -> "Query_cache::allocate_block(ulong,my_bool,ulong)"
"Query_cache::write_block_data(ulong,uchar*,ulong,Query_cache_block::block_type,uint)" -> "std::max(const _Tp&,const _Tp&) [with _Tp = long unsigned int]"
"Query_cache::allocate_block(ulong,my_bool,ulong)" -> "Query_cache::split_block(Query_cache_block*,ulong)"
"Query_cache::allocate_block(ulong,my_bool,ulong)" -> "Query_cache::get_free_block(ulong,my_bool,ulong)"
"Query_cache::allocate_block(ulong,my_bool,ulong)" -> "std::min(const _Tp&,const _Tp&) [with _Tp = long unsigned int]"
"Query_cache::allocate_block(ulong,my_bool,ulong)" -> "Query_cache::free_old_query()"
"Query_cache::free_old_query()" -> "Query_cache::free_query(Query_cache_block*)"
"Query_cache::free_old_query()" -> "Query_cache_block::query()"
"Query_cache::free_old_query()" -> "Query_cache_query::try_lock_writing()"
"Query_cache::free_old_query()" -> "Query_cache_query::result()"
"Query_cache_query::try_lock_writing()" -> "inline_mysql_rwlock_trywrlock(mysql_rwlock_t*)"
"inline_mysql_rwlock_trywrlock(mysql_rwlock_t*)" -> "pthread_rwlock_trywrlock(pthread_rwlock_t*)"
"Query_cache_query::init_n_lock()" -> "Query_cache_query::lock_writing()"
"Query_cache_query::init_n_lock()" -> "inline_mysql_rwlock_init(mysql_rwlock_t*)"
"Query_cache::is_cacheable(THD*,size_t,const char*,LEX*,TABLE_LIST*,uint8*)" -> "Query_cache::process_and_count_tables(THD*,TABLE_LIST*,uint8*)"
"Query_cache::is_cacheable(THD*,size_t,const char*,LEX*,TABLE_LIST*,uint8*)" -> "THD::in_multi_stmt_transaction_mode() const"
"Query_cache::process_and_count_tables(THD*,TABLE_LIST*,uint8*)" -> "ha_myisammrg::myrg_info()"
"Query_cache::process_and_count_tables(THD*,TABLE_LIST*,uint8*)" -> "TABLE_SHARE::db_type() const"
"Query_cache::ask_handler_allowance(THD*,TABLE_LIST*)" -> "TABLE_LIST::uses_materialization() const"
"Query_cache::ask_handler_allowance(THD*,TABLE_LIST*)" -> "TABLE_SHARE::get_table_ref_type() const"
"mysql_do(THD*,List<Item>&)" -> "List_iterator<T>::operator++(int) [with T = Item]"
"mysql_do(THD*,List<Item>&)" -> "THD::is_error() const"
"mysql_do(THD*,List<Item>&)" -> "Bounds_checked_array<Element_type>::Bounds_checked_array() [with Element_type = Item*]"
"mysql_do(THD*,List<Item>&)" -> "List_iterator<T>::List_iterator(List<T>&) [with T = Item]"
"mysql_do(THD*,List<Item>&)" -> "free_underlaid_joins(THD*,SELECT_LEX*)"
"mysql_do(THD*,List<Item>&)" -> "my_ok(THD*,ulonglong,ulonglong,const char*)"
"mysql_do(THD*,List<Item>&)" -> "trans_rollback_stmt(THD*)"
"mysql_do(THD*,List<Item>&)" -> "setup_fields(THD*,Ref_ptr_array,List<Item>&,enum_mark_columns,List<Item>*,bool)"
"mysql_do(THD*,List<Item>&)" -> "THD::clear_error()"
"free_underlaid_joins(THD*,SELECT_LEX*)" -> "st_select_lex_unit::cleanup()"
"free_underlaid_joins(THD*,SELECT_LEX*)" -> "st_select_lex::first_inner_unit()"
"free_underlaid_joins(THD*,SELECT_LEX*)" -> "st_select_lex_unit::next_unit()"
"handle_select(THD*,select_result*,ulong)" -> "THD::is_error() const"
"handle_select(THD*,select_result*,ulong)" -> "my_error(int,myf,...)"
"handle_select(THD*,select_result*,ulong)" -> "__builtin_expect(long int,long int)"
"handle_select(THD*,select_result*,ulong)" -> "mysql_union(THD*,LEX*,select_result*,SELECT_LEX_UNIT*,ulong)"
"handle_select(THD*,select_result*,ulong)" -> "st_select_lex_unit::is_union()"
"handle_select(THD*,select_result*,ulong)" -> "st_select_lex_unit::set_limit(st_select_lex*)"
"handle_select(THD*,select_result*,ulong)" -> "mysql_select(THD*,TABLE_LIST*,uint,List<Item>&,Item*,SQL_I_List<st_order>*,SQL_I_List<st_order>*,Item*,ulonglong,select_result*,SELECT_LEX_UNIT*,SELECT_LEX*)"
"mysql_union(THD*,LEX*,select_result*,SELECT_LEX_UNIT*,ulong)" -> "st_select_lex_unit::prepare(THD*,select_result*,ulong)"
"mysql_union(THD*,LEX*,select_result*,SELECT_LEX_UNIT*,ulong)" -> "st_select_lex_unit::exec()"
"mysql_union(THD*,LEX*,select_result*,SELECT_LEX_UNIT*,ulong)" -> "st_select_lex_unit::cleanup()"
"mysql_union(THD*,LEX*,select_result*,SELECT_LEX_UNIT*,ulong)" -> "st_select_lex_unit::optimize()"
"mysql_union(THD*,LEX*,select_result*,SELECT_LEX_UNIT*,ulong)" -> "lock_tables(THD*,TABLE_LIST*,uint,uint)"
"mysql_union(THD*,LEX*,select_result*,SELECT_LEX_UNIT*,ulong)" -> "Query_cache::store_query(THD*,TABLE_LIST*)"
"st_select_lex_unit::exec()" -> "st_select_lex_unit::set_limit(st_select_lex*)"
"st_select_lex_unit::exec()" -> "Item::val_uint()"
"st_select_lex_unit::exec()" -> "THD::get_examined_row_count() const"
"st_select_lex_unit::exec()" -> "st_select_lex::next_select()"
"st_select_lex_unit::exec()" -> "handler::ha_disable_indexes(uint)"
"st_select_lex_unit::exec()" -> "st_select_lex_unit::init_prepare_fake_select_lex(THD*,bool)"
"st_select_lex_unit::exec()" -> "Item_subselect::assigned(bool)"
"st_select_lex_unit::exec()" -> "base_list::empty()"
"st_select_lex_unit::exec()" -> "JOIN::exec()"
"st_select_lex_unit::exec()" -> "THD::inc_examined_row_count(ha_rows)"
"st_select_lex_unit::exec()" -> "handler::ha_delete_all_rows()"
"st_select_lex_unit::exec()" -> "select_union::flush()"
"st_select_lex_unit::exec()" -> "THD::set_examined_row_count(ha_rows)"
"st_select_lex_unit::exec()" -> "List<T>::List() [with T = Item_func_match]"
"st_select_lex_unit::exec()" -> "SQL_I_List<T>::empty() [with T = TABLE_LIST]"
"st_select_lex_unit::exec()" -> "mysql_select(THD*,TABLE_LIST*,uint,List<Item>&,Item*,SQL_I_List<st_order>*,SQL_I_List<st_order>*,Item*,ulonglong,select_result*,SELECT_LEX_UNIT*,SELECT_LEX*)"
"st_select_lex_unit::exec()" -> "handler::ha_enable_indexes(uint)"
"st_select_lex_unit::exec()" -> "st_select_lex_unit::first_select()"
"st_select_lex_unit::exec()" -> "Item_subselect::assigned() const"
"st_select_lex_unit::exec()" -> "JOIN::reset()"
"gtid_pre_statement_checks(const THD*)" -> "Checkable_rwlock::rdlock()"
"gtid_pre_statement_checks(const THD*)" -> "Query_tables_list::uses_stored_routines() const"
"gtid_pre_statement_checks(const THD*)" -> "is_already_logged_transaction(const THD*)"
"gtid_pre_statement_checks(const THD*)" -> "stmt_causes_implicit_commit(const THD*,uint)"
"gtid_pre_statement_checks(const THD*)" -> "skip_statement(const THD*)"
"gtid_pre_statement_checks(const THD*)" -> "Gtid_specification::to_string(const Sid_map*,char*) const"
"gtid_pre_statement_checks(const THD*)" -> "my_error(int,myf,...)"
"gtid_pre_statement_checks(const THD*)" -> "THD::get_gtid_next_list_const() const"
"gtid_pre_statement_checks(const THD*)" -> "THD::is_ddl_gtid_compatible() const"
"gtid_pre_statement_checks(const THD*)" -> "THD::in_active_multi_stmt_transaction() const"
"gtid_pre_statement_checks(const THD*)" -> "Checkable_rwlock::unlock()"
"is_already_logged_transaction(const THD*)" -> "THD::get_gtid_next_list_const() const"
"THD::get_gtid_next_list_const() const" -> "THD::get_gtid_next_list()"
"Gtid_specification::to_string(const Sid_map*,char*) const" -> "Sid_map::sidno_to_sid(rpl_sidno) const"
"Gtid_specification::to_string(const Sid_map*,char*) const" -> "Gtid_specification::to_string(const rpl_sid*,char*) const"
"Gtid_specification::to_string(const rpl_sid*,char*) const" -> "__builtin_memcpy(void*,const void*,long unsigned int)"
"Gtid_specification::to_string(const rpl_sid*,char*) const" -> "Gtid::to_string(const rpl_sid&,char*) const"
"Gtid::to_string(const rpl_sid&,char*) const" -> "format_gno(char*,rpl_gno)"
"Gtid::to_string(const rpl_sid&,char*) const" -> "Uuid::to_string(char*) const"
"format_gno(char*,rpl_gno)" -> "int2str(long int,char*,int,int)"
"Uuid::to_string(char*) const" -> "Uuid::to_string(const uchar*,char*)"
"THD::is_ddl_gtid_compatible() const" -> "THD::in_multi_stmt_transaction_mode() const"
"THD::is_ddl_gtid_compatible() const" -> "my_error(int,myf,...)"
"mysqld_show_warnings(THD*,ulong)" -> "Diagnostics_area::sql_conditions() const"
"mysqld_show_warnings(THD*,ulong)" -> "Sql_condition::get_message_octet_length() const"
"mysqld_show_warnings(THD*,ulong)" -> "st_select_lex_unit::set_limit(st_select_lex*)"
"mysqld_show_warnings(THD*,ulong)" -> "Item_return_int::Item_return_int(const char*,uint,enum_field_types,longlong)"
"mysqld_show_warnings(THD*,ulong)" -> "L>::operator++(int) [with T = const Sql_condition,L = I_P_List<Sql_condition,I_P_List_adapter<Sql_condition,&Sql_condition::next_in_wi,&Sql_condition::prev_in_wi>,I_P_List_counter,I_P_List_fast_push_back<Sql_condition> >]"
"mysqld_show_warnings(THD*,ulong)" -> "List<T>::push_back(T*) [with T = Item]"
"mysqld_show_warnings(THD*,ulong)" -> "Sql_condition::get_sql_errno() const"
"mysqld_show_warnings(THD*,ulong)" -> "Diagnostics_area::set_warning_info_read_only(bool)"
"mysqld_show_warnings(THD*,ulong)" -> "my_eof(THD*)"
"mysqld_show_warnings(THD*,ulong)" -> "List<T>::List() [with T = Item]"
"mysqld_show_warnings(THD*,ulong)" -> "Sql_condition::get_level() const"
"mysqld_show_warnings(THD*,ulong)" -> "Protocol::store(uint32)"
"mysqld_show_warnings(THD*,ulong)" -> "Item_empty_string::Item_empty_string(const char*,uint,const CHARSET_INFO*)"
"mysqld_show_warnings(THD*,ulong)" -> "Sql_condition::get_message_text() const"
"mysqld_show_warnings(THD*,ulong)" -> "THD::get_stmt_da()"
"Sql_condition::get_message_octet_length() const" -> "String::length() const"
"Item_return_int::Item_return_int(const char*,uint,enum_field_types,longlong)" -> "strlen(const char*)"
"Item_return_int::Item_return_int(const char*,uint,enum_field_types,longlong)" -> "Item_int::Item_int(const Name_string&,longlong,uint)"
"Item_return_int::Item_return_int(const char*,uint,enum_field_types,longlong)" -> "Name_string::Name_string(const char*,size_t)"
"Diagnostics_area::set_warning_info_read_only(bool)" -> "Diagnostics_area::get_warning_info()"
"Diagnostics_area::set_warning_info_read_only(bool)" -> "Warning_info::set_read_only(bool)"
"select_create::select_create(TABLE_LIST*,HA_CREATE_INFO*,Alter_info*,List<Item>&,enum_duplicates,bool,TABLE_LIST*)" -> "select_insert::select_insert(TABLE_LIST*,TABLE*,List<Item>*,List<Item>*,List<Item>*,List<Item>*,enum_duplicates,bool)"
"select_insert::select_insert(TABLE_LIST*,TABLE*,List<Item>*,List<Item>*,List<Item>*,List<Item>*,enum_duplicates,bool)" -> "COPY_INFO::COPY_INFO(COPY_INFO::operation_type,List<Item>*,List<Item>*)"
"select_insert::select_insert(TABLE_LIST*,TABLE*,List<Item>*,List<Item>*,List<Item>*,List<Item>*,enum_duplicates,bool)" -> "select_result_interceptor::select_result_interceptor()"
"select_insert::select_insert(TABLE_LIST*,TABLE*,List<Item>*,List<Item>*,List<Item>*,List<Item>*,enum_duplicates,bool)" -> "COPY_INFO::COPY_INFO(COPY_INFO::operation_type,List<Item>*,bool,enum_duplicates,bool)"
"COPY_INFO::COPY_INFO(COPY_INFO::operation_type,List<Item>*,List<Item>*)" -> "Sql_alloc::Sql_alloc()"
"COPY_INFO::COPY_INFO(COPY_INFO::operation_type,List<Item>*,List<Item>*)" -> "COPY_INFO::Statistics::Statistics()"
"COPY_INFO::COPY_INFO(COPY_INFO::operation_type,List<Item>*,bool,enum_duplicates,bool)" -> "COPY_INFO::Statistics::Statistics()"
"COPY_INFO::COPY_INFO(COPY_INFO::operation_type,List<Item>*,bool,enum_duplicates,bool)" -> "Sql_alloc::Sql_alloc()"
"mysqld_show_privileges(THD*)" -> "List<T>::List() [with T = Item]"
"mysqld_show_privileges(THD*)" -> "Item_empty_string::Item_empty_string(const char*,uint,const CHARSET_INFO*)"
"mysqld_show_privileges(THD*)" -> "Protocol::store(const char*,const CHARSET_INFO*)"
"mysqld_show_privileges(THD*)" -> "my_eof(THD*)"
"mysqld_show_privileges(THD*)" -> "List<T>::push_back(T*) [with T = Item]"
"sp_create_routine(THD*,sp_head*)" -> "strlen(const char*)"
"sp_create_routine(THD*,sp_head*)" -> "THD::is_current_stmt_binlog_format_row() const"
"sp_create_routine(THD*,sp_head*)" -> "memcpy(void*,const void*,size_t)"
"sp_create_routine(THD*,sp_head*)" -> "_current_thd()"
"sp_create_routine(THD*,sp_head*)" -> "String::String()"
"sp_create_routine(THD*,sp_head*)" -> "get_default_db_collation(THD*,const char*)"
"sp_create_routine(THD*,sp_head*)" -> "THD::clear_current_stmt_binlog_format_row()"
"sp_create_routine(THD*,sp_head*)" -> "String::ptr() const"
"sp_create_routine(THD*,sp_head*)" -> "sp_returns_type(THD*,String&,sp_head*)"
"sp_create_routine(THD*,sp_head*)" -> "sp_cache_invalidate()"
"sp_create_routine(THD*,sp_head*)" -> "handler::ha_write_row(uchar*)"
"sp_create_routine(THD*,sp_head*)" -> "String::set_charset(const CHARSET_INFO*)"
"sp_create_routine(THD*,sp_head*)" -> "Item_func_now_local::store_in(Field*)"
"sp_create_routine(THD*,sp_head*)" -> "MYSQL_LOG::is_open()"
"sp_create_routine(THD*,sp_head*)" -> "THD::clear_error()"
"sp_create_routine(THD*,sp_head*)" -> "strxnmov(char*,size_t,const char*,...)"
"sp_create_routine(THD*,sp_head*)" -> "THD::set_current_stmt_binlog_format_row()"
"sp_create_routine(THD*,sp_head*)" -> "THD::binlog_query(THD::enum_binlog_query_type,const char*,ulong,bool,bool,bool,int)"
"sp_create_routine(THD*,sp_head*)" -> "create_string(THD*,String*,enum_sp_type,const char*,ulong,const char*,ulong,const char*,ulong,const char*,ulong,const char*,ulong,st_sp_chistics*,const LEX_STRING*,const LEX_STRING*,sql_mode_t)"
"sp_create_routine(THD*,sp_head*)" -> "THD::charset()"
"sp_create_routine(THD*,sp_head*)" -> "String::length() const"
"sp_create_routine(THD*,sp_head*)" -> "String::String(uint32)"
"sp_create_routine(THD*,sp_head*)" -> "my_message(uint,const char*,myf)"
"sp_create_routine(THD*,sp_head*)" -> "THD::add_to_binlog_accessed_dbs(const char*)"
"sp_create_routine(THD*,sp_head*)" -> "Field::set_notnull(my_ptrdiff_t)"
"sp_create_routine(THD*,sp_head*)" -> "lock_object_name(THD*,MDL_key::enum_mdl_namespace,const char*,const char*)"
"sp_create_routine(THD*,sp_head*)" -> "String::c_ptr()"
"sp_create_routine(THD*,sp_head*)" -> "open_proc_table_for_update(THD*)"
"sp_returns_type(THD*,String&,sp_head*)" -> "String::append(const char*,uint32)"
"sp_returns_type(THD*,String&,sp_head*)" -> "String::append(const char*)"
"sp_returns_type(THD*,String&,sp_head*)" -> "TABLE::TABLE()"
"sp_returns_type(THD*,String&,sp_head*)" -> "memset(void*,int,size_t)"
"sp_returns_type(THD*,String&,sp_head*)" -> "TABLE_SHARE::TABLE_SHARE()"
"sp_returns_type(THD*,String&,sp_head*)" -> "sp_head::create_result_field(uint,const char*,TABLE*)"
"sp_head::create_result_field(uint,const char*,TABLE*)" -> "make_field(TABLE_SHARE*,uchar*,uint32,uchar*,uchar,uint,enum_field_types,const CHARSET_INFO*,Field::geometry_type,Field::utype,TYPELIB*,const char*,MEM_ROOT*)"
"sp_head::create_result_field(uint,const char*,TABLE*)" -> "Field::init(TABLE*)"
"sp_cache_invalidate()" -> "inline_mysql_mutex_unlock(mysql_mutex_t*)"
"sp_cache_invalidate()" -> "inline_mysql_mutex_lock(mysql_mutex_t*)"
"lock_object_name(THD*,MDL_key::enum_mdl_namespace,const char*,const char*)" -> "I>::push_front(T*) [with T = MDL_request,B = I_P_List_adapter<MDL_request,&MDL_request::next_in_list,&MDL_request::prev_in_list>,C = I_P_List_counter,I = I_P_List_no_push_back<MDL_request>]"
"lock_object_name(THD*,MDL_key::enum_mdl_namespace,const char*,const char*)" -> "Global_read_lock::can_acquire_protection() const"
"lock_object_name(THD*,MDL_key::enum_mdl_namespace,const char*,const char*)" -> "I>::I_P_List() [with T = MDL_request,B = I_P_List_adapter<MDL_request,&MDL_request::next_in_list,&MDL_request::prev_in_list>,C = I_P_List_counter,I = I_P_List_no_push_back<MDL_request>]"
"lock_object_name(THD*,MDL_key::enum_mdl_namespace,const char*,const char*)" -> "my_message(uint,const char*,myf)"
"lock_object_name(THD*,MDL_key::enum_mdl_namespace,const char*,const char*)" -> "_current_thd()"
"lock_object_name(THD*,MDL_key::enum_mdl_namespace,const char*,const char*)" -> "MDL_request::init(MDL_key::enum_mdl_namespace,const char*,const char*,enum_mdl_type,enum_mdl_duration)"
"lock_object_name(THD*,MDL_key::enum_mdl_namespace,const char*,const char*)" -> "MDL_context::acquire_locks(MDL_request_list*,ulong)"
"lock_object_name(THD*,MDL_key::enum_mdl_namespace,const char*,const char*)" -> "MDL_request::MDL_request()"
"open_proc_table_for_update(THD*)" -> "MDL_context::rollback_to_savepoint(const MDL_savepoint&)"
"open_proc_table_for_update(THD*)" -> "MDL_context::mdl_savepoint()"
"open_proc_table_for_update(THD*)" -> "open_system_table_for_update(THD*,TABLE_LIST*)"
"open_proc_table_for_update(THD*)" -> "close_thread_tables(THD*)"
"open_proc_table_for_update(THD*)" -> "Table_check_intact::check(TABLE*,const TABLE_FIELD_DEF*)"
"open_proc_table_for_update(THD*)" -> "TABLE_LIST::TABLE_LIST()"
"open_proc_table_for_update(THD*)" -> "TABLE_LIST::init_one_table(const char*,size_t,const char*,size_t,const char*,thr_lock_type)"
"open_system_table_for_update(THD*,TABLE_LIST*)" -> "TABLE::use_all_columns()"
"open_system_table_for_update(THD*,TABLE_LIST*)" -> "open_ltable(THD*,TABLE_LIST*,thr_lock_type,uint)"
"sp_process_definer(THD*)" -> "check_global_access(THD*,ulong)"
"sp_process_definer(THD*)" -> "my_error(int,myf,...)"
"sp_process_definer(THD*)" -> "strcmp(const char*,const char*)"
"sp_process_definer(THD*)" -> "create_default_definer(THD*)"
"sp_process_definer(THD*)" -> "Prepared_stmt_arena_holder::Prepared_stmt_arena_holder(THD*,bool)"
"mysqld_show_create(THD*,TABLE_LIST*)" -> "String::String(char*,uint32,const CHARSET_INFO*)"
"mysqld_show_create(THD*,TABLE_LIST*)" -> "view_store_create_info(THD*,TABLE_LIST*,String*)"
"mysqld_show_create(THD*,TABLE_LIST*)" -> "Show_create_error_handler::Show_create_error_handler(THD*,TABLE_LIST*)"
"mysqld_show_create(THD*,TABLE_LIST*)" -> "List<T>::push_back(T*) [with T = Item]"
"mysqld_show_create(THD*,TABLE_LIST*)" -> "mysql_handle_derived(LEX*,bool (*)(THD*,LEX*,TABLE_LIST*))"
"mysqld_show_create(THD*,TABLE_LIST*)" -> "THD::is_error() const"
"mysqld_show_create(THD*,TABLE_LIST*)" -> "MDL_context::rollback_to_savepoint(const MDL_savepoint&)"
"mysqld_show_create(THD*,TABLE_LIST*)" -> "Protocol::store(const char*,const CHARSET_INFO*)"
"mysqld_show_create(THD*,TABLE_LIST*)" -> "THD::push_internal_handler(Internal_error_handler*)"
"mysqld_show_create(THD*,TABLE_LIST*)" -> "String::set_charset(const CHARSET_INFO*)"
"mysqld_show_create(THD*,TABLE_LIST*)" -> "store_create_info(THD*,TABLE_LIST*,String*,HA_CREATE_INFO*,bool)"
"mysqld_show_create(THD*,TABLE_LIST*)" -> "THD::pop_internal_handler()"
"mysqld_show_create(THD*,TABLE_LIST*)" -> "Item_empty_string::Item_empty_string(const char*,uint,const CHARSET_INFO*)"
"mysqld_show_create(THD*,TABLE_LIST*)" -> "String::length(uint32)"
"mysqld_show_create(THD*,TABLE_LIST*)" -> "my_eof(THD*)"
"mysqld_show_create(THD*,TABLE_LIST*)" -> "close_thread_tables(THD*)"
"mysqld_show_create(THD*,TABLE_LIST*)" -> "Default_object_creation_ctx::get_client_cs()"
"mysqld_show_create(THD*,TABLE_LIST*)" -> "String::charset() const"
"mysqld_show_create(THD*,TABLE_LIST*)" -> "String::length() const"
"mysqld_show_create(THD*,TABLE_LIST*)" -> "List<T>::List() [with T = Item]"
"mysqld_show_create(THD*,TABLE_LIST*)" -> "open_tables(THD*,TABLE_LIST**,uint*,uint)"
"mysqld_show_create(THD*,TABLE_LIST*)" -> "std::max(const _Tp&,const _Tp&) [with _Tp = unsigned int]"
"mysqld_show_create(THD*,TABLE_LIST*)" -> "my_error(int,myf,...)"
"mysqld_show_create(THD*,TABLE_LIST*)" -> "MDL_context::mdl_savepoint()"
"mysqld_show_create(THD*,TABLE_LIST*)" -> "Default_object_creation_ctx::get_connection_cl()"
"mysqld_show_create(THD*,TABLE_LIST*)" -> "String::ptr() const"
"view_store_create_info(THD*,TABLE_LIST*,String*)" -> "st_select_lex_unit::print(String*,enum_query_type)"
"view_store_create_info(THD*,TABLE_LIST*,String*)" -> "view_store_options(THD*,TABLE_LIST*,String*)"
"view_store_create_info(THD*,TABLE_LIST*,String*)" -> "String::append(char)"
"view_store_create_info(THD*,TABLE_LIST*,String*)" -> "String::append(const char*,uint32)"
"view_store_create_info(THD*,TABLE_LIST*,String*)" -> "strcmp(const char*,const char*)"
"view_store_create_info(THD*,TABLE_LIST*,String*)" -> "append_identifier(THD*,String*,const char*,uint)"
"view_store_options(THD*,TABLE_LIST*,String*)" -> "append_algorithm(TABLE_LIST*,String*)"
"view_store_options(THD*,TABLE_LIST*,String*)" -> "String::append(const char*,uint32)"
"view_store_options(THD*,TABLE_LIST*,String*)" -> "append_definer(THD*,String*,const LEX_STRING*,const LEX_STRING*)"
"append_algorithm(TABLE_LIST*,String*)" -> "String::append(const char*,uint32)"
"Show_create_error_handler::Show_create_error_handler(THD*,TABLE_LIST*)" -> "Internal_error_handler::Internal_error_handler()"
"store_create_info(THD*,TABLE_LIST*,String*,HA_CREATE_INFO*,bool)" -> "print_default_clause(THD*,Field*,String*,bool)"
"store_create_info(THD*,TABLE_LIST*,String*,HA_CREATE_INFO*,bool)" -> "strlen(const char*)"
"store_create_info(THD*,TABLE_LIST*,String*,HA_CREATE_INFO*,bool)" -> "String::set_charset(const CHARSET_INFO*)"
"store_create_info(THD*,TABLE_LIST*,String*,HA_CREATE_INFO*,bool)" -> "String::append(const String&)"
"store_create_info(THD*,TABLE_LIST*,String*,HA_CREATE_INFO*,bool)" -> "strcmp(const char*,const char*)"
"store_create_info(THD*,TABLE_LIST*,String*,HA_CREATE_INFO*,bool)" -> "generate_partition_syntax(partition_info*,uint*,bool,bool,HA_CREATE_INFO*,Alter_info*,const char*)"
"store_create_info(THD*,TABLE_LIST*,String*,HA_CREATE_INFO*,bool)" -> "String::append(const char*,uint32,const CHARSET_INFO*)"
"store_create_info(THD*,TABLE_LIST*,String*,HA_CREATE_INFO*,bool)" -> "append_unescaped(String*,const char*,uint)"
"store_create_info(THD*,TABLE_LIST*,String*,HA_CREATE_INFO*,bool)" -> "append_directory(THD*,String*,const char*,const char*)"
"store_create_info(THD*,TABLE_LIST*,String*,HA_CREATE_INFO*,bool)" -> "String::append_parenthesized(long int,int)"
"store_create_info(THD*,TABLE_LIST*,String*,HA_CREATE_INFO*,bool)" -> "String::append(const char*)"
"store_create_info(THD*,TABLE_LIST*,String*,HA_CREATE_INFO*,bool)" -> "String::String(char*,uint32,const CHARSET_INFO*)"
"store_create_info(THD*,TABLE_LIST*,String*,HA_CREATE_INFO*,bool)" -> "memcpy(void*,const void*,size_t)"
"store_create_info(THD*,TABLE_LIST*,String*,HA_CREATE_INFO*,bool)" -> "tmp_restore_column_map(MY_BITMAP*,my_bitmap_map*)"
"store_create_info(THD*,TABLE_LIST*,String*,HA_CREATE_INFO*,bool)" -> "String::set(char*,uint32,const CHARSET_INFO*)"
"store_create_info(THD*,TABLE_LIST*,String*,HA_CREATE_INFO*,bool)" -> "List<T>::List() [with T = Item]"
"store_create_info(THD*,TABLE_LIST*,String*,HA_CREATE_INFO*,bool)" -> "String::append(const char*,uint32)"
"store_create_info(THD*,TABLE_LIST*,String*,HA_CREATE_INFO*,bool)" -> "print_on_update_clause(Field*,String*,bool)"
"store_create_info(THD*,TABLE_LIST*,String*,HA_CREATE_INFO*,bool)" -> "String::length() const"
"store_create_info(THD*,TABLE_LIST*,String*,HA_CREATE_INFO*,bool)" -> "String::c_ptr()"
"store_create_info(THD*,TABLE_LIST*,String*,HA_CREATE_INFO*,bool)" -> "store_key_options(THD*,String*,TABLE*,KEY*)"
"store_create_info(THD*,TABLE_LIST*,String*,HA_CREATE_INFO*,bool)" -> "ha_resolve_storage_engine_name(const handlerton*)"
"store_create_info(THD*,TABLE_LIST*,String*,HA_CREATE_INFO*,bool)" -> "Field::column_format() const"
"store_create_info(THD*,TABLE_LIST*,String*,HA_CREATE_INFO*,bool)" -> "append_identifier(THD*,String*,const char*,uint)"
"store_create_info(THD*,TABLE_LIST*,String*,HA_CREATE_INFO*,bool)" -> "tmp_use_all_columns(TABLE*,MY_BITMAP*)"
"store_create_info(THD*,TABLE_LIST*,String*,HA_CREATE_INFO*,bool)" -> "partition_info::set_show_version_string(String*)"
"store_create_info(THD*,TABLE_LIST*,String*,HA_CREATE_INFO*,bool)" -> "memset(void*,int,size_t)"
"store_create_info(THD*,TABLE_LIST*,String*,HA_CREATE_INFO*,bool)" -> "Field::field_storage_type() const"
"store_create_info(THD*,TABLE_LIST*,String*,HA_CREATE_INFO*,bool)" -> "st_ha_create_information::st_ha_create_information()"
"store_create_info(THD*,TABLE_LIST*,String*,HA_CREATE_INFO*,bool)" -> "TABLE_SHARE::db_type() const"
"store_create_info(THD*,TABLE_LIST*,String*,HA_CREATE_INFO*,bool)" -> "String::String()"
"store_create_info(THD*,TABLE_LIST*,String*,HA_CREATE_INFO*,bool)" -> "String::append(char)"
"store_create_info(THD*,TABLE_LIST*,String*,HA_CREATE_INFO*,bool)" -> "int10_to_str(long int,char*,int)"
"store_create_info(THD*,TABLE_LIST*,String*,HA_CREATE_INFO*,bool)" -> "my_free(void*)"
"store_create_info(THD*,TABLE_LIST*,String*,HA_CREATE_INFO*,bool)" -> "String::ptr() const"
"print_default_clause(THD*,Field*,String*,bool)" -> "String::length() const"
"print_default_clause(THD*,Field*,String*,bool)" -> "String::append(const char*,uint32)"
"print_default_clause(THD*,Field*,String*,bool)" -> "String::length(uint32)"
"print_default_clause(THD*,Field*,String*,bool)" -> "String::copy(const char*,uint32,const CHARSET_INFO*,const CHARSET_INFO*,uint*)"
"print_default_clause(THD*,Field*,String*,bool)" -> "String::String()"
"print_default_clause(THD*,Field*,String*,bool)" -> "Field::val_str(String*)"
"print_default_clause(THD*,Field*,String*,bool)" -> "int2str(long int,char*,int,int)"
"print_default_clause(THD*,Field*,String*,bool)" -> "Field::is_null(my_ptrdiff_t) const"
"print_default_clause(THD*,Field*,String*,bool)" -> "String::String(char*,uint32,const CHARSET_INFO*)"
"print_default_clause(THD*,Field*,String*,bool)" -> "Field::maybe_null() const"
"print_default_clause(THD*,Field*,String*,bool)" -> "append_unescaped(String*,const char*,uint)"
"print_default_clause(THD*,Field*,String*,bool)" -> "Field::has_insert_default_function() const"
"print_default_clause(THD*,Field*,String*,bool)" -> "String::append_parenthesized(long int,int)"
"print_default_clause(THD*,Field*,String*,bool)" -> "String::ptr() const"
"String::append_parenthesized(long int,int)" -> "int10_to_str(long int,char*,int)"
"String::append_parenthesized(long int,int)" -> "String::append(const char*,uint32)"
"append_directory(THD*,String*,const char*,const char*)" -> "String::append(const char*,uint32)"
"append_directory(THD*,String*,const char*,const char*)" -> "String::append(const char*)"
"append_directory(THD*,String*,const char*,const char*)" -> "String::append(char)"
"append_directory(THD*,String*,const char*,const char*)" -> "dirname_length(const char*)"
"print_on_update_clause(Field*,String*,bool)" -> "String::charset() const"
"print_on_update_clause(Field*,String*,bool)" -> "Field::has_update_default_function() const"
"print_on_update_clause(Field*,String*,bool)" -> "String::append(const char*,uint32)"
"print_on_update_clause(Field*,String*,bool)" -> "String::length(uint32)"
"print_on_update_clause(Field*,String*,bool)" -> "String::append_parenthesized(long int,int)"
"print_on_update_clause(Field*,String*,bool)" -> "String::copy(const char*,uint32,const CHARSET_INFO*)"
"store_key_options(THD*,String*,TABLE*,KEY*)" -> "append_unescaped(String*,const char*,uint)"
"store_key_options(THD*,String*,TABLE*,KEY*)" -> "int10_to_str(long int,char*,int)"
"store_key_options(THD*,String*,TABLE*,KEY*)" -> "String::append(const char*,uint32)"
"partition_info::set_show_version_string(String*)" -> "int10_to_str(long int,char*,int)"
"partition_info::set_show_version_string(String*)" -> "String::append(const char*,uint32)"
"open_tables(THD*,TABLE_LIST**,uint*,uint)" -> "open_tables(THD*,TABLE_LIST**,uint*,uint,Prelocking_strategy*)"
"open_tables(THD*,TABLE_LIST**,uint*,uint)" -> "DML_prelocking_strategy::DML_prelocking_strategy()"
"sql_set_variables(THD*,List<set_var_base>*)" -> "List_iterator_fast<T>::operator++(int) [with T = set_var_base]"
"sql_set_variables(THD*,List<set_var_base>*)" -> "List_iterator_fast<T>::List_iterator_fast(List<T>&) [with T = set_var_base]"
"sql_set_variables(THD*,List<set_var_base>*)" -> "free_underlaid_joins(THD*,SELECT_LEX*)"
"sql_set_variables(THD*,List<set_var_base>*)" -> "THD::is_error() const"
"sql_set_variables(THD*,List<set_var_base>*)" -> "List_iterator_fast<T>::rewind() [with T = set_var_base]"
"List_iterator_fast<T>::rewind() [with T = set_var_base]" -> "base_list_iterator::rewind()"
"mysql_create_or_drop_trigger(THD*,TABLE_LIST*,bool)" -> "find_temporary_table(THD*,const TABLE_LIST*)"
"mysql_create_or_drop_trigger(THD*,TABLE_LIST*,bool)" -> "sp_cache_invalidate()"
"mysql_create_or_drop_trigger(THD*,TABLE_LIST*,bool)" -> "my_ok(THD*,ulonglong,ulonglong,const char*)"
"mysql_create_or_drop_trigger(THD*,TABLE_LIST*,bool)" -> "Query_tables_list::Query_tables_list()"
"mysql_create_or_drop_trigger(THD*,TABLE_LIST*,bool)" -> "THD::add_to_binlog_accessed_dbs(const char*)"
"mysql_create_or_drop_trigger(THD*,TABLE_LIST*,bool)" -> "String::length() const"
"mysql_create_or_drop_trigger(THD*,TABLE_LIST*,bool)" -> "wait_while_table_is_used(THD*,TABLE*,ha_extra_function)"
"mysql_create_or_drop_trigger(THD*,TABLE_LIST*,bool)" -> "String::set_charset(const CHARSET_INFO*)"
"mysql_create_or_drop_trigger(THD*,TABLE_LIST*,bool)" -> "Table_triggers_list::drop_trigger(THD*,TABLE_LIST*,String*)"
"mysql_create_or_drop_trigger(THD*,TABLE_LIST*,bool)" -> "add_table_for_trigger(THD*,const sp_name*,bool,TABLE_LIST**)"
"mysql_create_or_drop_trigger(THD*,TABLE_LIST*,bool)" -> "write_bin_log(THD*,bool,const char*,ulong,bool)"
"mysql_create_or_drop_trigger(THD*,TABLE_LIST*,bool)" -> "my_error(int,myf,...)"
"mysql_create_or_drop_trigger(THD*,TABLE_LIST*,bool)" -> "close_all_tables_for_name(THD*,TABLE_SHARE*,bool,TABLE*)"
"mysql_create_or_drop_trigger(THD*,TABLE_LIST*,bool)" -> "Statement::query_length() const"
"mysql_create_or_drop_trigger(THD*,TABLE_LIST*,bool)" -> "TABLE::use_all_columns()"
"mysql_create_or_drop_trigger(THD*,TABLE_LIST*,bool)" -> "LEX::reset_n_backup_query_tables_list(Query_tables_list*)"
"mysql_create_or_drop_trigger(THD*,TABLE_LIST*,bool)" -> "String::String()"
"mysql_create_or_drop_trigger(THD*,TABLE_LIST*,bool)" -> "check_table_access(THD*,ulong,TABLE_LIST*,bool,uint,bool)"
"mysql_create_or_drop_trigger(THD*,TABLE_LIST*,bool)" -> "mysql_ha_rm_tables(THD*,TABLE_LIST*)"
"mysql_create_or_drop_trigger(THD*,TABLE_LIST*,bool)" -> "Table_triggers_list::create_trigger(THD*,TABLE_LIST*,String*)"
"mysql_create_or_drop_trigger(THD*,TABLE_LIST*,bool)" -> "Statement::query() const"
"mysql_create_or_drop_trigger(THD*,TABLE_LIST*,bool)" -> "open_n_lock_single_table(THD*,TABLE_LIST*,thr_lock_type,uint)"
"mysql_create_or_drop_trigger(THD*,TABLE_LIST*,bool)" -> "MYSQL_LOG::is_open()"
"mysql_create_or_drop_trigger(THD*,TABLE_LIST*,bool)" -> "String::ptr() const"
"mysql_create_or_drop_trigger(THD*,TABLE_LIST*,bool)" -> "Locked_tables_list::reopen_tables(THD*)"
"mysql_create_or_drop_trigger(THD*,TABLE_LIST*,bool)" -> "LEX::restore_backup_query_tables_list(Query_tables_list*)"
"mysql_create_or_drop_trigger(THD*,TABLE_LIST*,bool)" -> "MDL_ticket::downgrade_lock(enum_mdl_type)"
"mysql_create_or_drop_trigger(THD*,TABLE_LIST*,bool)" -> "Table_triggers_list::Table_triggers_list(TABLE*)"
"mysql_create_or_drop_trigger(THD*,TABLE_LIST*,bool)" -> "find_table_for_mdl_upgrade(THD*,const char*,const char*,bool)"
"mysql_create_or_drop_trigger(THD*,TABLE_LIST*,bool)" -> "String::append(const char*,uint32)"
"Table_triggers_list::drop_trigger(THD*,TABLE_LIST*,String*)" -> "rm_trigger_file(char*,const char*,const char*)"
"Table_triggers_list::drop_trigger(THD*,TABLE_LIST*,String*)" -> "my_message(uint,const char*,myf)"
"Table_triggers_list::drop_trigger(THD*,TABLE_LIST*,String*)" -> "List_iterator_fast<T>::List_iterator_fast(List<T>&) [with T = st_mysql_lex_string]"
"Table_triggers_list::drop_trigger(THD*,TABLE_LIST*,String*)" -> "Statement::query() const"
"Table_triggers_list::drop_trigger(THD*,TABLE_LIST*,String*)" -> "_current_thd()"
"Table_triggers_list::drop_trigger(THD*,TABLE_LIST*,String*)" -> "List_iterator<T>::remove() [with T = st_mysql_lex_string]"
"Table_triggers_list::drop_trigger(THD*,TABLE_LIST*,String*)" -> "List_iterator<T>::operator++(int) [with T = st_mysql_lex_string]"
"Table_triggers_list::drop_trigger(THD*,TABLE_LIST*,String*)" -> "List_iterator<T>::List_iterator(List<T>&) [with T = long long unsigned int]"
"Table_triggers_list::drop_trigger(THD*,TABLE_LIST*,String*)" -> "String::append(const char*,uint32)"
"Table_triggers_list::drop_trigger(THD*,TABLE_LIST*,String*)" -> "rm_trigname_file(char*,const char*,const char*)"
"Table_triggers_list::drop_trigger(THD*,TABLE_LIST*,String*)" -> "List_iterator<T>::operator++(int) [with T = long long unsigned int]"
"Table_triggers_list::drop_trigger(THD*,TABLE_LIST*,String*)" -> "base_list::is_empty() const"
"Table_triggers_list::drop_trigger(THD*,TABLE_LIST*,String*)" -> "List_iterator_fast<T>::operator++(int) [with T = st_mysql_lex_string]"
"Table_triggers_list::drop_trigger(THD*,TABLE_LIST*,String*)" -> "List_iterator<T>::List_iterator(List<T>&) [with T = st_mysql_lex_string]"
"Table_triggers_list::drop_trigger(THD*,TABLE_LIST*,String*)" -> "save_trigger_file(Table_triggers_list*,const char*,const char*)"
"Table_triggers_list::drop_trigger(THD*,TABLE_LIST*,String*)" -> "Statement::query_length() const"
"Table_triggers_list::drop_trigger(THD*,TABLE_LIST*,String*)" -> "List_iterator<T>::remove() [with T = long long unsigned int]"
"List_iterator<T>::remove() [with T = st_mysql_lex_string]" -> "base_list_iterator::remove()"
"List_iterator<T>::operator++(int) [with T = st_mysql_lex_string]" -> "base_list_iterator::next()"
"List_iterator<T>::List_iterator(List<T>&) [with T = long long unsigned int]" -> "base_list_iterator::base_list_iterator(base_list&)"
"List_iterator<T>::operator++(int) [with T = long long unsigned int]" -> "base_list_iterator::next()"
"List_iterator<T>::List_iterator(List<T>&) [with T = st_mysql_lex_string]" -> "base_list_iterator::base_list_iterator(base_list&)"
"List_iterator<T>::remove() [with T = long long unsigned int]" -> "base_list_iterator::remove()"
"add_table_for_trigger(THD*,const sp_name*,bool,TABLE_LIST**)" -> "check_trn_exists(const LEX_STRING*)"
"add_table_for_trigger(THD*,const sp_name*,bool,TABLE_LIST**)" -> "my_error(int,myf,...)"
"add_table_for_trigger(THD*,const sp_name*,bool,TABLE_LIST**)" -> "load_table_name_for_trigger(THD*,const sp_name*,const LEX_STRING*,LEX_STRING*)"
"add_table_for_trigger(THD*,const sp_name*,bool,TABLE_LIST**)" -> "push_warning_printf(THD*,Sql_condition::enum_warning_level,uint,const char*,...)"
"add_table_for_trigger(THD*,const sp_name*,bool,TABLE_LIST**)" -> "build_trn_path(THD*,const sp_name*,LEX_STRING*)"
"add_table_for_trigger(THD*,const sp_name*,bool,TABLE_LIST**)" -> "_current_thd()"
"add_table_for_trigger(THD*,const sp_name*,bool,TABLE_LIST**)" -> "sp_add_to_query_tables(THD*,LEX*,const char*,const char*,thr_lock_type,enum_mdl_type)"
"check_trn_exists(const LEX_STRING*)" -> "access(const char*,int)"
"load_table_name_for_trigger(THD*,const sp_name*,const LEX_STRING*,LEX_STRING*)" -> "is_equal(const LEX_STRING*,const LEX_STRING*)"
"load_table_name_for_trigger(THD*,const sp_name*,const LEX_STRING*,LEX_STRING*)" -> "sql_parse_prepare(const LEX_STRING*,MEM_ROOT*,bool)"
"load_table_name_for_trigger(THD*,const sp_name*,const LEX_STRING*,LEX_STRING*)" -> "File_parser::type() const"
"load_table_name_for_trigger(THD*,const sp_name*,const LEX_STRING*,LEX_STRING*)" -> "my_error(int,myf,...)"
"load_table_name_for_trigger(THD*,const sp_name*,const LEX_STRING*,LEX_STRING*)" -> "File_parser::parse(uchar*,MEM_ROOT*,File_option*,uint,Unknown_key_hook*) const"
"load_table_name_for_trigger(THD*,const sp_name*,const LEX_STRING*,LEX_STRING*)" -> "Handle_old_incorrect_trigger_table_hook::Handle_old_incorrect_trigger_table_hook(char*,LEX_STRING*)"
"Handle_old_incorrect_trigger_table_hook::Handle_old_incorrect_trigger_table_hook(char*,LEX_STRING*)" -> "Unknown_key_hook::Unknown_key_hook()"
"build_trn_path(THD*,const sp_name*,LEX_STRING*)" -> "build_table_filename(char*,size_t,const char*,const char*,const char*,uint)"
"sp_add_to_query_tables(THD*,LEX*,const char*,const char*,thr_lock_type,enum_mdl_type)" -> "strlen(const char*)"
"sp_add_to_query_tables(THD*,LEX*,const char*,const char*,thr_lock_type,enum_mdl_type)" -> "Query_arena::strdup(const char*)"
"sp_add_to_query_tables(THD*,LEX*,const char*,const char*,thr_lock_type,enum_mdl_type)" -> "MDL_request::init(MDL_key::enum_mdl_namespace,const char*,const char*,enum_mdl_type,enum_mdl_duration)"
"sp_add_to_query_tables(THD*,LEX*,const char*,const char*,thr_lock_type,enum_mdl_type)" -> "Query_tables_list::add_to_query_tables(TABLE_LIST*)"
"sp_add_to_query_tables(THD*,LEX*,const char*,const char*,thr_lock_type,enum_mdl_type)" -> "Query_arena::calloc(size_t)"
"sp_add_to_query_tables(THD*,LEX*,const char*,const char*,thr_lock_type,enum_mdl_type)" -> "Query_arena::strmake(const char*,size_t)"
"Table_triggers_list::create_trigger(THD*,TABLE_LIST*,String*)" -> "strcmp(const char*,const char*)"
"Table_triggers_list::create_trigger(THD*,TABLE_LIST*,String*)" -> "get_default_db_collation(THD*,const char*)"
"Table_triggers_list::create_trigger(THD*,TABLE_LIST*,String*)" -> "Table_triggers_list::check_for_broken_triggers()"
"Table_triggers_list::create_trigger(THD*,TABLE_LIST*,String*)" -> "alloc_type(MEM_ROOT*) [with T = long long unsigned int,MEM_ROOT = st_mem_root]"
"Table_triggers_list::create_trigger(THD*,TABLE_LIST*,String*)" -> "my_error(int,myf,...)"
"Table_triggers_list::create_trigger(THD*,TABLE_LIST*,String*)" -> "List<T>::push_back(T*,MEM_ROOT*) [with T = st_mysql_lex_string,MEM_ROOT = st_mem_root]"
"Table_triggers_list::create_trigger(THD*,TABLE_LIST*,String*)" -> "build_table_filename(char*,size_t,const char*,const char*,const char*,uint)"
"Table_triggers_list::create_trigger(THD*,TABLE_LIST*,String*)" -> "check_global_access(THD*,ulong)"
"Table_triggers_list::create_trigger(THD*,TABLE_LIST*,String*)" -> "String::append(const char*,uint32)"
"Table_triggers_list::create_trigger(THD*,TABLE_LIST*,String*)" -> "sql_create_definition_file(const LEX_STRING*,const LEX_STRING*,const LEX_STRING*,uchar*,File_option*)"
"Table_triggers_list::create_trigger(THD*,TABLE_LIST*,String*)" -> "append_definer(THD*,String*,const LEX_STRING*,const LEX_STRING*)"
"Table_triggers_list::create_trigger(THD*,TABLE_LIST*,String*)" -> "alloc_lex_string(MEM_ROOT*)"
"Table_triggers_list::create_trigger(THD*,TABLE_LIST*,String*)" -> "build_table_filename(char*,size_t,const char*,const char*,const char*,uint,bool*)"
"Table_triggers_list::create_trigger(THD*,TABLE_LIST*,String*)" -> "access(const char*,int)"
"Table_triggers_list::create_trigger(THD*,TABLE_LIST*,String*)" -> "List<T>::push_back(T*,MEM_ROOT*) [with T = long long unsigned int,MEM_ROOT = st_mem_root]"
"Table_triggers_list::create_trigger(THD*,TABLE_LIST*,String*)" -> "strxmov(char*,const char*,...)"
"Table_triggers_list::create_trigger(THD*,TABLE_LIST*,String*)" -> "Item_trigger_field::setup_field(THD*,TABLE*,GRANT_INFO*)"
"Table_triggers_list::create_trigger(THD*,TABLE_LIST*,String*)" -> "inline_mysql_file_delete(const char*,myf)"
"Table_triggers_list::create_trigger(THD*,TABLE_LIST*,String*)" -> "trim_whitespace(const CHARSET_INFO*,LEX_STRING*)"
"Table_triggers_list::create_trigger(THD*,TABLE_LIST*,String*)" -> "THD::charset()"
"Table_triggers_list::create_trigger(THD*,TABLE_LIST*,String*)" -> "create_default_definer(THD*)"
"Table_triggers_list::create_trigger(THD*,TABLE_LIST*,String*)" -> "lex_string_set(LEX_STRING*,const char*)"
"Table_triggers_list::create_trigger(THD*,TABLE_LIST*,String*)" -> "String::c_ptr()"
"Table_triggers_list::create_trigger(THD*,TABLE_LIST*,String*)" -> "String::length() const"
"mysql_uninstall_plugin(THD*,const LEX_STRING*)" -> "my_error(int,myf,...)"
"mysql_uninstall_plugin(THD*,const LEX_STRING*)" -> "TABLE::use_all_columns()"
"mysql_uninstall_plugin(THD*,const LEX_STRING*)" -> "push_warning(THD*,Sql_condition::enum_warning_level,uint,const char*)"
"mysql_uninstall_plugin(THD*,const LEX_STRING*)" -> "plugin_find_internal(const LEX_STRING*,int)"
"mysql_uninstall_plugin(THD*,const LEX_STRING*)" -> "_current_thd()"
"mysql_uninstall_plugin(THD*,const LEX_STRING*)" -> "handler::ha_index_read_idx_map(uchar*,uint,const uchar*,key_part_map,ha_rkey_function)"
"mysql_uninstall_plugin(THD*,const LEX_STRING*)" -> "handler::ha_delete_row(const uchar*)"
"mysql_uninstall_plugin(THD*,const LEX_STRING*)" -> "mysql_audit_acquire_plugins(THD*,uint)"
"mysql_uninstall_plugin(THD*,const LEX_STRING*)" -> "check_table_access(THD*,ulong,TABLE_LIST*,bool,uint,bool)"
"mysql_uninstall_plugin(THD*,const LEX_STRING*)" -> "key_copy(uchar*,uchar*,KEY*,uint)"
"mysql_uninstall_plugin(THD*,const LEX_STRING*)" -> "reap_plugins()"
"mysql_uninstall_plugin(THD*,const LEX_STRING*)" -> "inline_mysql_mutex_unlock(mysql_mutex_t*)"
"mysql_uninstall_plugin(THD*,const LEX_STRING*)" -> "TABLE_LIST::TABLE_LIST()"
"mysql_uninstall_plugin(THD*,const LEX_STRING*)" -> "open_ltable(THD*,TABLE_LIST*,thr_lock_type,uint)"
"mysql_uninstall_plugin(THD*,const LEX_STRING*)" -> "inline_mysql_mutex_lock(mysql_mutex_t*)"
"mysql_uninstall_plugin(THD*,const LEX_STRING*)" -> "TABLE_LIST::init_one_table(const char*,size_t,const char*,size_t,const char*,thr_lock_type)"
"some_non_temp_table_to_be_updated(THD*,TABLE_LIST*)" -> "find_temporary_table(THD*,const TABLE_LIST*)"
"lock_tables_precheck(THD*,TABLE_LIST*)" -> "is_temporary_table(TABLE_LIST*)"
"lock_tables_precheck(THD*,TABLE_LIST*)" -> "Query_tables_list::first_not_own_table()"
"lock_tables_precheck(THD*,TABLE_LIST*)" -> "check_table_access(THD*,ulong,TABLE_LIST*,bool,uint,bool)"
"sp_head::execute_procedure(THD*,List<Item>*)" -> "MDL_context::release_transactional_locks()"
"sp_head::execute_procedure(THD*,List<Item>*)" -> "List_iterator<T>::List_iterator(List<T>&) [with T = Item]"
"sp_head::execute_procedure(THD*,List<Item>*)" -> "trans_commit_stmt(THD*)"
"sp_head::execute_procedure(THD*,List<Item>*)" -> "sp_rcontext::set_variable(THD*,uint,Item**)"
"sp_head::execute_procedure(THD*,List<Item>*)" -> "sp_pcontext::find_variable(uint) const"
"sp_head::execute_procedure(THD*,List<Item>*)" -> "trans_rollback_implicit(THD*)"
"sp_head::execute_procedure(THD*,List<Item>*)" -> "Item_null::Item_null()"
"sp_head::execute_procedure(THD*,List<Item>*)" -> "sp_pcontext::context_var_count() const"
"sp_head::execute_procedure(THD*,List<Item>*)" -> "Send_field::Send_field()"
"sp_head::execute_procedure(THD*,List<Item>*)" -> "THD::is_error() const"
"sp_head::execute_procedure(THD*,List<Item>*)" -> "close_thread_tables(THD*)"
"sp_head::execute_procedure(THD*,List<Item>*)" -> "sp_rcontext::get_item(uint) const"
"sp_head::execute_procedure(THD*,List<Item>*)" -> "sp_rcontext::get_item_addr(uint) const"
"sp_head::execute_procedure(THD*,List<Item>*)" -> "List_iterator<T>::operator++(int) [with T = Item]"
"sp_head::execute_procedure(THD*,List<Item>*)" -> "THD::is_current_stmt_binlog_format_row() const"
"sp_head::execute_procedure(THD*,List<Item>*)" -> "THD::issue_unsafe_warnings()"
"sp_head::execute_procedure(THD*,List<Item>*)" -> "List_iterator<T>::ref() [with T = Item]"
"sp_head::execute_procedure(THD*,List<Item>*)" -> "opt_trace_disable_if_no_stored_proc_func_access(THD*,sp_head*)"
"sp_head::execute_procedure(THD*,List<Item>*)" -> "set_thd_proc_info(void*,const char*,const char*,const char*,unsigned int)"
"sp_head::execute_procedure(THD*,List<Item>*)" -> "trans_rollback_stmt(THD*)"
"sp_head::execute_procedure(THD*,List<Item>*)" -> "Diagnostics_area::set_overwrite_status(bool)"
"sp_head::execute_procedure(THD*,List<Item>*)" -> "MDL_context::release_statement_locks()"
"sp_head::execute_procedure(THD*,List<Item>*)" -> "sp_rcontext::create(THD*,const sp_pcontext*,Field*)"
"sp_head::execute_procedure(THD*,List<Item>*)" -> "my_error(int,myf,...)"
"sp_head::execute_procedure(THD*,List<Item>*)" -> "sp_head::execute(THD*,bool)"
"sp_head::execute_procedure(THD*,List<Item>*)" -> "THD::in_multi_stmt_transaction_mode() const"
"sp_head::execute_procedure(THD*,List<Item>*)" -> "st_select_lex_unit::cleanup()"
"sp_head::execute_procedure(THD*,List<Item>*)" -> "THD::rollback_item_tree_changes()"
"sp_head::execute_procedure(THD*,List<Item>*)" -> "THD::get_stmt_da()"
"sp_head::execute_procedure(THD*,List<Item>*)" -> "MYSQL_LOG::is_open()"
"sp_rcontext::set_variable(THD*,uint,Item**)" -> "sp_rcontext::set_variable(THD*,Field*,Item**)"
"sp_rcontext::set_variable(THD*,Field*,Item**)" -> "sp_eval_expr(THD*,Field*,Item**)"
"sp_rcontext::set_variable(THD*,Field*,Item**)" -> "Field::set_null(my_ptrdiff_t)"
"sp_eval_expr(THD*,Field*,Item**)" -> "Field::set_null(my_ptrdiff_t)"
"sp_eval_expr(THD*,Field*,Item**)" -> "THD::is_error() const"
"sp_eval_expr(THD*,Field*,Item**)" -> "THD_TRANS::reset_unsafe_rollback_flags()"
"sp_eval_expr(THD*,Field*,Item**)" -> "THD::is_strict_mode() const"
"sp_eval_expr(THD*,Field*,Item**)" -> "sp_prepare_func_item(THD*,Item**)"
"sp_eval_expr(THD*,Field*,Item**)" -> "THD_TRANS::get_unsafe_rollback_flags() const"
"sp_eval_expr(THD*,Field*,Item**)" -> "THD_TRANS::set_unsafe_rollback_flags(unsigned int)"
"Send_field::Send_field()" -> "Sql_alloc::Sql_alloc()"
"sp_rcontext::get_item(uint) const" -> "Bounds_checked_array<Element_type>::operator[](size_t) const [with Element_type = Item*,size_t = long unsigned int]"
"sp_rcontext::get_item_addr(uint) const" -> "Bounds_checked_array<Element_type>::array() const [with Element_type = Item*]"
"THD::rollback_item_tree_changes()" -> "I_List_iterator<T>::operator++(int) [with T = Item_change_record]"
"THD::rollback_item_tree_changes()" -> "base_ilist<T>::empty() [with T = Item_change_record]"
"THD::rollback_item_tree_changes()" -> "I_List_iterator<T>::I_List_iterator(I_List<T>&) [with T = Item_change_record]"
"mysql_rm_db(THD*,char*,bool,bool)" -> "mysql_rm_table_no_locks(THD*,TABLE_LIST*,bool,bool,bool,bool)"
"mysql_rm_db(THD*,char*,bool,bool)" -> "my_strmov_quoted_identifier(THD*,char*,const char*,uint)"
"mysql_rm_db(THD*,char*,bool,bool)" -> "THD::add_to_binlog_accessed_dbs(const char*)"
"mysql_rm_db(THD*,char*,bool,bool)" -> "Query_arena::alloc(size_t)"
"mysql_rm_db(THD*,char*,bool,bool)" -> "my_ok(THD*,ulonglong,ulonglong,const char*)"
"mysql_rm_db(THD*,char*,bool,bool)" -> "lock_schema_name(THD*,const char*)"
"mysql_rm_db(THD*,char*,bool,bool)" -> "_current_thd()"
"mysql_rm_db(THD*,char*,bool,bool)" -> "sp_drop_db_routines(THD*,char*)"
"mysql_rm_db(THD*,char*,bool,bool)" -> "THD::clear_error()"
"mysql_rm_db(THD*,char*,bool,bool)" -> "push_warning_printf(THD*,Sql_condition::enum_warning_level,uint,const char*,...)"
"mysql_rm_db(THD*,char*,bool,bool)" -> "find_db_tables_and_rm_known_files(THD*,MY_DIR*,const char*,const char*,TABLE_LIST**,bool*)"
"mysql_rm_db(THD*,char*,bool,bool)" -> "Statement::query() const"
"mysql_rm_db(THD*,char*,bool,bool)" -> "Query_log_event::Query_log_event(THD*,const char*,ulong,bool,bool,bool,int,bool)"
"mysql_rm_db(THD*,char*,bool,bool)" -> "THD::push_internal_handler(Internal_error_handler*)"
"mysql_rm_db(THD*,char*,bool,bool)" -> "my_error(int,myf,...)"
"mysql_rm_db(THD*,char*,bool,bool)" -> "lock_table_names(THD*,TABLE_LIST*,TABLE_LIST*,ulong,uint)"
"mysql_rm_db(THD*,char*,bool,bool)" -> "my_dirend(MY_DIR*)"
"mysql_rm_db(THD*,char*,bool,bool)" -> "my_dir(const char*,myf)"
"mysql_rm_db(THD*,char*,bool,bool)" -> "check_if_table_exists(THD*,TABLE_LIST*,bool*)"
"mysql_rm_db(THD*,char*,bool,bool)" -> "Query_cache::invalidate(char*)"
"mysql_rm_db(THD*,char*,bool,bool)" -> "query_error_code(THD*,bool)"
"mysql_rm_db(THD*,char*,bool,bool)" -> "THD::pop_internal_handler()"
"mysql_rm_db(THD*,char*,bool,bool)" -> "MYSQL_LOG::is_open()"
"mysql_rm_db(THD*,char*,bool,bool)" -> "strxmov(char*,const char*,...)"
"mysql_rm_db(THD*,char*,bool,bool)" -> "Drop_table_error_handler::Drop_table_error_handler()"
"mysql_rm_db(THD*,char*,bool,bool)" -> "ha_drop_database(char*)"
"mysql_rm_db(THD*,char*,bool,bool)" -> "strlen(const char*)"
"mysql_rm_db(THD*,char*,bool,bool)" -> "MYSQL_BIN_LOG::write_event(Log_event*)"
"mysql_rm_db(THD*,char*,bool,bool)" -> "__builtin_memcpy(void*,const void*,long unsigned int)"
"mysql_rm_db(THD*,char*,bool,bool)" -> "build_table_filename(char*,size_t,const char*,const char*,const char*,uint)"
"mysql_rm_db(THD*,char*,bool,bool)" -> "check_if_log_table(size_t,const char*,size_t,const char*,bool)"
"mysql_rm_db(THD*,char*,bool,bool)" -> "__builtin_stpcpy(char*,const char*)"
"mysql_rm_db(THD*,char*,bool,bool)" -> "Statement::query_length() const"
"mysql_rm_db(THD*,char*,bool,bool)" -> "mysql_change_db_impl(THD*,LEX_STRING*,ulong,const CHARSET_INFO*)"
"mysql_rm_db(THD*,char*,bool,bool)" -> "lock_db_routines(THD*,char*)"
"mysql_rm_db(THD*,char*,bool,bool)" -> "tdc_remove_table(THD*,enum_tdc_remove_table_type,const char*,const char*,bool)"
"mysql_rm_db(THD*,char*,bool,bool)" -> "del_dbopt(const char*)"
"mysql_rm_db(THD*,char*,bool,bool)" -> "rm_dir_w_symlink(const char*,my_bool)"
"mysql_rm_db(THD*,char*,bool,bool)" -> "mysql_ha_rm_tables(THD*,TABLE_LIST*)"
"mysql_rm_db(THD*,char*,bool,bool)" -> "write_to_binlog(THD*,char*,uint,char*,uint)"
"mysql_rm_db(THD*,char*,bool,bool)" -> "strcmp(const char*,const char*)"
"my_strmov_quoted_identifier(THD*,char*,const char*,uint)" -> "get_quote_char_for_identifier(THD*,const char*,uint)"
"my_strmov_quoted_identifier(THD*,char*,const char*,uint)" -> "my_strmov_quoted_identifier_helper(int,char*,const char*,uint)"
"my_strmov_quoted_identifier_helper(int,char*,const char*,uint)" -> "strncpy(char*,const char*,size_t)"
"my_strmov_quoted_identifier_helper(int,char*,const char*,uint)" -> "strlen(const char*)"
"lock_schema_name(THD*,const char*)" -> "MDL_request::init(MDL_key::enum_mdl_namespace,const char*,const char*,enum_mdl_type,enum_mdl_duration)"
"lock_schema_name(THD*,const char*)" -> "I>::I_P_List() [with T = MDL_request,B = I_P_List_adapter<MDL_request,&MDL_request::next_in_list,&MDL_request::prev_in_list>,C = I_P_List_counter,I = I_P_List_no_push_back<MDL_request>]"
"lock_schema_name(THD*,const char*)" -> "my_message(uint,const char*,myf)"
"lock_schema_name(THD*,const char*)" -> "MDL_request::MDL_request()"
"lock_schema_name(THD*,const char*)" -> "I>::push_front(T*) [with T = MDL_request,B = I_P_List_adapter<MDL_request,&MDL_request::next_in_list,&MDL_request::prev_in_list>,C = I_P_List_counter,I = I_P_List_no_push_back<MDL_request>]"
"lock_schema_name(THD*,const char*)" -> "MDL_context::acquire_locks(MDL_request_list*,ulong)"
"lock_schema_name(THD*,const char*)" -> "_current_thd()"
"lock_schema_name(THD*,const char*)" -> "Global_read_lock::can_acquire_protection() const"
"sp_drop_db_routines(THD*,char*)" -> "handler::ha_index_end()"
"sp_drop_db_routines(THD*,char*)" -> "handler::ha_index_next_same(uchar*,const uchar*,uint)"
"sp_drop_db_routines(THD*,char*)" -> "MDL_context::mdl_savepoint()"
"sp_drop_db_routines(THD*,char*)" -> "close_thread_tables(THD*)"
"sp_drop_db_routines(THD*,char*)" -> "MDL_context::rollback_to_savepoint(const MDL_savepoint&)"
"sp_drop_db_routines(THD*,char*)" -> "open_proc_table_for_update(THD*)"
"sp_drop_db_routines(THD*,char*)" -> "strlen(const char*)"
"sp_drop_db_routines(THD*,char*)" -> "handler::ha_index_init(uint,bool)"
"sp_drop_db_routines(THD*,char*)" -> "handler::ha_delete_row(const uchar*)"
"sp_drop_db_routines(THD*,char*)" -> "handler::ha_index_read_map(uchar*,const uchar*,key_part_map,ha_rkey_function)"
"sp_drop_db_routines(THD*,char*)" -> "sp_cache_invalidate()"
"find_db_tables_and_rm_known_files(THD*,MY_DIR*,const char*,const char*,TABLE_LIST**,bool*)" -> "unpack_filename(char*,const char*)"
"find_db_tables_and_rm_known_files(THD*,MY_DIR*,const char*,const char*,TABLE_LIST**,bool*)" -> "my_strerror(char*,size_t,int)"
"find_db_tables_and_rm_known_files(THD*,MY_DIR*,const char*,const char*,TABLE_LIST**,bool*)" -> "strrchr(char*,int)"
"find_db_tables_and_rm_known_files(THD*,MY_DIR*,const char*,const char*,TABLE_LIST**,bool*)" -> "MDL_request::init(MDL_key::enum_mdl_namespace,const char*,const char*,enum_mdl_type,enum_mdl_duration)"
"find_db_tables_and_rm_known_files(THD*,MY_DIR*,const char*,const char*,TABLE_LIST**,bool*)" -> "filename_to_tablename(const char*,char*,uint)"
"find_db_tables_and_rm_known_files(THD*,MY_DIR*,const char*,const char*,TABLE_LIST**,bool*)" -> "find_type(const char*,const TYPELIB*,unsigned int)"
"find_db_tables_and_rm_known_files(THD*,MY_DIR*,const char*,const char*,TABLE_LIST**,bool*)" -> "my_error(int,myf,...)"
"find_db_tables_and_rm_known_files(THD*,MY_DIR*,const char*,const char*,TABLE_LIST**,bool*)" -> "strxmov(char*,const char*,...)"
"find_db_tables_and_rm_known_files(THD*,MY_DIR*,const char*,const char*,TABLE_LIST**,bool*)" -> "my_dir(const char*,myf)"
"find_db_tables_and_rm_known_files(THD*,MY_DIR*,const char*,const char*,TABLE_LIST**,bool*)" -> "__builtin_stpcpy(char*,const char*)"
"find_db_tables_and_rm_known_files(THD*,MY_DIR*,const char*,const char*,TABLE_LIST**,bool*)" -> "mysql_rm_arc_files(THD*,MY_DIR*,const char*)"
"find_db_tables_and_rm_known_files(THD*,MY_DIR*,const char*,const char*,TABLE_LIST**,bool*)" -> "strend(const char*)"
"find_db_tables_and_rm_known_files(THD*,MY_DIR*,const char*,const char*,TABLE_LIST**,bool*)" -> "ha_known_exts()"
"find_db_tables_and_rm_known_files(THD*,MY_DIR*,const char*,const char*,TABLE_LIST**,bool*)" -> "_my_thread_var()"
"find_db_tables_and_rm_known_files(THD*,MY_DIR*,const char*,const char*,TABLE_LIST**,bool*)" -> "strlen(const char*)"
"find_db_tables_and_rm_known_files(THD*,MY_DIR*,const char*,const char*,TABLE_LIST**,bool*)" -> "Query_arena::calloc(size_t)"
"find_db_tables_and_rm_known_files(THD*,MY_DIR*,const char*,const char*,TABLE_LIST**,bool*)" -> "is_prefix(const char*,const char*)"
"find_db_tables_and_rm_known_files(THD*,MY_DIR*,const char*,const char*,TABLE_LIST**,bool*)" -> "my_delete_with_symlink(const char*,myf)"
"mysql_rm_arc_files(THD*,MY_DIR*,const char*)" -> "rm_dir_w_symlink(const char*,my_bool)"
"mysql_rm_arc_files(THD*,MY_DIR*,const char*)" -> "fn_ext(const char*)"
"mysql_rm_arc_files(THD*,MY_DIR*,const char*)" -> "my_dirend(MY_DIR*)"
"mysql_rm_arc_files(THD*,MY_DIR*,const char*)" -> "strxmov(char*,const char*,...)"
"mysql_rm_arc_files(THD*,MY_DIR*,const char*)" -> "inline_mysql_file_delete_with_symlink(const char*,myf)"
"rm_dir_w_symlink(const char*,my_bool)" -> "strend(const char*)"
"rm_dir_w_symlink(const char*,my_bool)" -> "inline_mysql_file_delete(const char*,myf)"
"rm_dir_w_symlink(const char*,my_bool)" -> "my_readlink(char*,const char*,myf)"
"rm_dir_w_symlink(const char*,my_bool)" -> "unpack_filename(char*,const char*)"
"rm_dir_w_symlink(const char*,my_bool)" -> "rmdir(const char*)"
"rm_dir_w_symlink(const char*,my_bool)" -> "__errno_location()"
"rm_dir_w_symlink(const char*,my_bool)" -> "my_error(int,myf,...)"
"inline_mysql_file_delete_with_symlink(const char*,myf)" -> "my_delete_with_symlink(const char*,myf)"
"ha_known_exts()" -> "sql_alloc(size_t)"
"ha_known_exts()" -> "List<T>::push_back(T*) [with T = char]"
"ha_known_exts()" -> "List_iterator_fast<T>::operator++(int) [with T = char]"
"ha_known_exts()" -> "plugin_foreach_with_mask(THD*,my_bool (*)(THD*,plugin_ref,void*),int,uint,void*)"
"ha_known_exts()" -> "List_iterator_fast<T>::List_iterator_fast(List<T>&) [with T = char]"
"ha_known_exts()" -> "List<T>::List() [with T = char]"
"List_iterator_fast<T>::operator++(int) [with T = char]" -> "base_list_iterator::next_fast()"
"List_iterator_fast<T>::List_iterator_fast(List<T>&) [with T = char]" -> "base_list_iterator::base_list_iterator(base_list&)"
"Query_cache::invalidate(char*)" -> "Query_cache_table::db()"
"Query_cache::invalidate(char*)" -> "Query_cache_block::table(uint)"
"Query_cache::invalidate(char*)" -> "Query_cache::unlock()"
"Query_cache::invalidate(char*)" -> "_current_thd()"
"Query_cache::invalidate(char*)" -> "Query_cache::is_disabled()"
"Query_cache::invalidate(char*)" -> "Query_cache::lock()"
"Query_cache::invalidate(char*)" -> "strcmp(const char*,const char*)"
"Query_cache::invalidate(char*)" -> "Query_cache_block::table()"
"Query_cache::invalidate(char*)" -> "Query_cache::invalidate_query_block_list(THD*,Query_cache_block_table*)"
"ha_drop_database(char*)" -> "plugin_foreach_with_mask(THD*,my_bool (*)(THD*,plugin_ref,void*),int,uint,void*)"
"lock_db_routines(THD*,char*)" -> "handler::ha_index_read_map(uchar*,const uchar*,key_part_map,ha_rkey_function)"
"lock_db_routines(THD*,char*)" -> "I>::push_front(T*) [with T = MDL_request,B = I_P_List_adapter<MDL_request,&MDL_request::next_in_list,&MDL_request::prev_in_list>,C = I_P_List_counter,I = I_P_List_no_push_back<MDL_request>]"
"lock_db_routines(THD*,char*)" -> "handler::ha_index_end()"
"lock_db_routines(THD*,char*)" -> "strlen(const char*)"
"lock_db_routines(THD*,char*)" -> "THD::is_error() const"
"lock_db_routines(THD*,char*)" -> "MDL_request::MDL_request()"
"lock_db_routines(THD*,char*)" -> "get_field(MEM_ROOT*,Field*)"
"lock_db_routines(THD*,char*)" -> "MDL_context::acquire_locks(MDL_request_list*,ulong)"
"lock_db_routines(THD*,char*)" -> "I>::I_P_List() [with T = MDL_request,B = I_P_List_adapter<MDL_request,&MDL_request::next_in_list,&MDL_request::prev_in_list>,C = I_P_List_counter,I = I_P_List_no_push_back<MDL_request>]"
"lock_db_routines(THD*,char*)" -> "THD::pop_internal_handler()"
"lock_db_routines(THD*,char*)" -> "handler::ha_index_init(uint,bool)"
"lock_db_routines(THD*,char*)" -> "Lock_db_routines_error_handler::Lock_db_routines_error_handler()"
"lock_db_routines(THD*,char*)" -> "THD::push_internal_handler(Internal_error_handler*)"
"lock_db_routines(THD*,char*)" -> "handler::ha_index_next_same(uchar*,const uchar*,uint)"
"lock_db_routines(THD*,char*)" -> "close_system_tables(THD*,Open_tables_backup*)"
"lock_db_routines(THD*,char*)" -> "MDL_request::init(MDL_key::enum_mdl_namespace,const char*,const char*,enum_mdl_type,enum_mdl_duration)"
"lock_db_routines(THD*,char*)" -> "Open_tables_backup::Open_tables_backup()"
"lock_db_routines(THD*,char*)" -> "open_proc_table_for_read(THD*,Open_tables_backup*)"
"Lock_db_routines_error_handler::Lock_db_routines_error_handler()" -> "Internal_error_handler::Internal_error_handler()"
"del_dbopt(const char*)" -> "my_hash_search(const HASH*,const uchar*,size_t)"
"del_dbopt(const char*)" -> "strlen(const char*)"
"del_dbopt(const char*)" -> "inline_mysql_rwlock_unlock(mysql_rwlock_t*)"
"del_dbopt(const char*)" -> "inline_mysql_rwlock_wrlock(mysql_rwlock_t*)"
"del_dbopt(const char*)" -> "my_hash_delete(HASH*,uchar*)"
"write_to_binlog(THD*,char*,uint,char*,uint)" -> "Query_log_event::Query_log_event(THD*,const char*,ulong,bool,bool,bool,int,bool)"
"write_to_binlog(THD*,char*,uint,char*,uint)" -> "MYSQL_BIN_LOG::write_event(Log_event*)"
"mysql_create_table(THD*,TABLE_LIST*,HA_CREATE_INFO*,Alter_info*)" -> "write_bin_log(THD*,bool,const char*,ulong,bool)"
"mysql_create_table(THD*,TABLE_LIST*,HA_CREATE_INFO*,Alter_info*)" -> "THD::is_current_stmt_binlog_format_row() const"
"mysql_create_table(THD*,TABLE_LIST*,HA_CREATE_INFO*,Alter_info*)" -> "mysql_create_table_no_lock(THD*,const char*,const char*,HA_CREATE_INFO*,Alter_info*,uint,bool*)"
"mysql_create_table(THD*,TABLE_LIST*,HA_CREATE_INFO*,Alter_info*)" -> "Statement::query() const"
"mysql_create_table(THD*,TABLE_LIST*,HA_CREATE_INFO*,Alter_info*)" -> "promote_first_timestamp_column(List<Create_field>*)"
"mysql_create_table(THD*,TABLE_LIST*,HA_CREATE_INFO*,Alter_info*)" -> "Statement::query_length() const"
"mysql_create_table(THD*,TABLE_LIST*,HA_CREATE_INFO*,Alter_info*)" -> "open_tables(THD*,TABLE_LIST**,uint*,uint)"
"mysql_create_table(THD*,TABLE_LIST*,HA_CREATE_INFO*,Alter_info*)" -> "THD::add_to_binlog_accessed_dbs(const char*)"
"mysql_create_table(THD*,TABLE_LIST*,HA_CREATE_INFO*,Alter_info*)" -> "THD::is_strict_mode() const"
"mysql_create_table(THD*,TABLE_LIST*,HA_CREATE_INFO*,Alter_info*)" -> "THD_TRANS::mark_created_temp_table()"
"mysql_create_table_no_lock(THD*,const char*,const char*,HA_CREATE_INFO*,Alter_info*,uint,bool*)" -> "my_error(int,myf,...)"
"mysql_create_table_no_lock(THD*,const char*,const char*,HA_CREATE_INFO*,Alter_info*,uint,bool*)" -> "create_table_impl(THD*,const char*,const char*,const char*,HA_CREATE_INFO*,Alter_info*,bool,uint,bool,bool*,KEY**,uint*)"
"mysql_create_table_no_lock(THD*,const char*,const char*,HA_CREATE_INFO*,Alter_info*,uint,bool*)" -> "build_tmptable_filename(THD*,char*,size_t)"
"mysql_create_table_no_lock(THD*,const char*,const char*,HA_CREATE_INFO*,Alter_info*,uint,bool*)" -> "table_case_name(HA_CREATE_INFO*,const char*)"
"mysql_create_table_no_lock(THD*,const char*,const char*,HA_CREATE_INFO*,Alter_info*,uint,bool*)" -> "build_table_filename(char*,size_t,const char*,const char*,const char*,uint,bool*)"
"mysql_multi_update(THD*,TABLE_LIST*,List<Item>*,List<Item>*,Item*,ulonglong,enum_duplicates,bool,SELECT_LEX_UNIT*,SELECT_LEX*,multi_update**)" -> "mysql_select(THD*,TABLE_LIST*,uint,List<Item>&,Item*,SQL_I_List<st_order>*,SQL_I_List<st_order>*,Item*,ulonglong,select_result*,SELECT_LEX_UNIT*,SELECT_LEX*)"
"mysql_multi_update(THD*,TABLE_LIST*,List<Item>*,List<Item>*,Item*,ulonglong,enum_duplicates,bool,SELECT_LEX_UNIT*,SELECT_LEX*,multi_update**)" -> "__builtin_expect(long int,long int)"
"mysql_multi_update(THD*,TABLE_LIST*,List<Item>*,List<Item>*,Item*,ulonglong,enum_duplicates,bool,SELECT_LEX_UNIT*,SELECT_LEX*,multi_update**)" -> "multi_update::multi_update(TABLE_LIST*,TABLE_LIST*,List<Item>*,List<Item>*,enum_duplicates,bool)"
"mysql_multi_update(THD*,TABLE_LIST*,List<Item>*,List<Item>*,Item*,ulonglong,enum_duplicates,bool,SELECT_LEX_UNIT*,SELECT_LEX*,multi_update**)" -> "_current_thd()"
"mysql_multi_update(THD*,TABLE_LIST*,List<Item>*,List<Item>*,Item*,ulonglong,enum_duplicates,bool,SELECT_LEX_UNIT*,SELECT_LEX*,multi_update**)" -> "THD::is_strict_mode() const"
"mysql_multi_update(THD*,TABLE_LIST*,List<Item>*,List<Item>*,Item*,ulonglong,enum_duplicates,bool,SELECT_LEX_UNIT*,SELECT_LEX*,multi_update**)" -> "THD::is_error() const"
"mysql_multi_update(THD*,TABLE_LIST*,List<Item>*,List<Item>*,Item*,ulonglong,enum_duplicates,bool,SELECT_LEX_UNIT*,SELECT_LEX*,multi_update**)" -> "List<T>::List() [with T = Item]"
"mysql_multi_update(THD*,TABLE_LIST*,List<Item>*,List<Item>*,Item*,ulonglong,enum_duplicates,bool,SELECT_LEX_UNIT*,SELECT_LEX*,multi_update**)" -> "explain_multi_table_modification(THD*,select_result_interceptor*)"
"multi_update::multi_update(TABLE_LIST*,TABLE_LIST*,List<Item>*,List<Item>*,enum_duplicates,bool)" -> "List<T>::List() [with T = TABLE]"
"multi_update::multi_update(TABLE_LIST*,TABLE_LIST*,List<Item>*,List<Item>*,enum_duplicates,bool)" -> "select_result_interceptor::select_result_interceptor()"
"Query_cache::invalidate_locked_for_write(TABLE_LIST*)" -> "_current_thd()"
"Query_cache::invalidate_locked_for_write(TABLE_LIST*)" -> "Query_cache::is_disabled()"
"Query_cache::invalidate_locked_for_write(TABLE_LIST*)" -> "Query_cache::invalidate_table(THD*,TABLE*)"
"Query_cache::invalidate_locked_for_write(TABLE_LIST*)" -> "THD::enter_stage(const PSI_stage_info*,PSI_stage_info*,const char*,const char*,unsigned int)"
"trans_savepoint(THD*,LEX_STRING)" -> "strmake_root(MEM_ROOT*,const char*,size_t)"
"trans_savepoint(THD*,LEX_STRING)" -> "ha_release_savepoint(THD*,SAVEPOINT*)"
"trans_savepoint(THD*,LEX_STRING)" -> "THD::in_multi_stmt_transaction_mode() const"
"trans_savepoint(THD*,LEX_STRING)" -> "alloc_root(MEM_ROOT*,size_t)"
"trans_savepoint(THD*,LEX_STRING)" -> "my_error(int,myf,...)"
"trans_savepoint(THD*,LEX_STRING)" -> "ha_savepoint(THD*,SAVEPOINT*)"
"trans_savepoint(THD*,LEX_STRING)" -> "find_savepoint(THD*,LEX_STRING)"
"trans_savepoint(THD*,LEX_STRING)" -> "MDL_context::mdl_savepoint()"
"ha_savepoint(THD*,SAVEPOINT*)" -> "my_error(int,myf,...)"
"ha_savepoint(THD*,SAVEPOINT*)" -> "Ha_trx_info::next() const"
"ha_savepoint(THD*,SAVEPOINT*)" -> "Ha_trx_info::ht() const"
"TRACE_END(int)" -> "clock_gettime(clockid_t,timespec*)"
"TRACE_END(int)" -> "TraceTool::get_instance()"
"TRACE_END(int)" -> "TraceTool::add_record(int,long int)"
"TRACE_END(int)" -> "TraceTool::difftime(timespec,timespec)"
"mysqld_list_processes(THD*,const char*,bool)" -> "CSET_STRING::charset() const"
"mysqld_list_processes(THD*,const char*,bool)" -> "std::_Rb_tree_const_iterator<_Tp>::operator++() [with _Tp = THD*,std::_Rb_tree_const_iterator<_Tp>::_Self = std::_Rb_tree_const_iterator<THD*>]"
"mysqld_list_processes(THD*,const char*,bool)" -> "List<T>::push_back(T*) [with T = Item]"
"mysqld_list_processes(THD*,const char*,bool)" -> "Statement::query_length() const"
"mysqld_list_processes(THD*,const char*,bool)" -> "inline_mysql_mutex_unlock(mysql_mutex_t*)"
"mysqld_list_processes(THD*,const char*,bool)" -> "my_eof(THD*)"
"mysqld_list_processes(THD*,const char*,bool)" -> "CSET_STRING::str() const"
"mysqld_list_processes(THD*,const char*,bool)" -> "Item_empty_string::Item_empty_string(const char*,uint,const CHARSET_INFO*)"
"mysqld_list_processes(THD*,const char*,bool)" -> "String::ptr() const"
"mysqld_list_processes(THD*,const char*,bool)" -> "std::min(const _Tp&,const _Tp&) [with _Tp = unsigned int]"
"mysqld_list_processes(THD*,const char*,bool)" -> "CSET_STRING::CSET_STRING(char*,size_t,const CHARSET_INFO*)"
"mysqld_list_processes(THD*,const char*,bool)" -> "has_trivial_destructor>::at(size_t) [with Element_type = thread_info*,bool has_trivial_destructor = true,size_t = long unsigned int]"
"mysqld_list_processes(THD*,const char*,bool)" -> "std::sort(_RAIter,_RAIter,_Compare) [with _RAIter = thread_info**,_Compare = thread_info_compare]"
"mysqld_list_processes(THD*,const char*,bool)" -> "inline_mysql_mutex_lock(mysql_mutex_t*)"
"mysqld_list_processes(THD*,const char*,bool)" -> "Name_string::Name_string(const char*,size_t)"
"mysqld_list_processes(THD*,const char*,bool)" -> "Item_return_int::Item_return_int(const char*,uint,enum_field_types,longlong)"
"mysqld_list_processes(THD*,const char*,bool)" -> "has_trivial_destructor>::reserve(size_t) [with Element_type = thread_info*,bool has_trivial_destructor = true,size_t = long unsigned int]"
"mysqld_list_processes(THD*,const char*,bool)" -> "std::_Rb_tree_const_iterator<_Tp>::operator!=(const _Self&) const [with _Tp = THD*,std::_Rb_tree_const_iterator<_Tp>::_Self = std::_Rb_tree_const_iterator<THD*>]"
"mysqld_list_processes(THD*,const char*,bool)" -> "Query_arena::strmake(const char*,size_t)"
"mysqld_list_processes(THD*,const char*,bool)" -> "Query_arena::strdup(const char*)"
"mysqld_list_processes(THD*,const char*,bool)" -> "Query_arena::alloc(size_t)"
"mysqld_list_processes(THD*,const char*,bool)" -> "has_trivial_destructor>::end() [with Element_type = thread_info*,bool has_trivial_destructor = true]"
"mysqld_list_processes(THD*,const char*,bool)" -> "get_thread_count()"
"mysqld_list_processes(THD*,const char*,bool)" -> "strcmp(const char*,const char*)"
"mysqld_list_processes(THD*,const char*,bool)" -> "THD::get_command() const"
"mysqld_list_processes(THD*,const char*,bool)" -> "Statement::query_charset() const"
"mysqld_list_processes(THD*,const char*,bool)" -> "my_snprintf(char*,size_t,const char*,...)"
"mysqld_list_processes(THD*,const char*,bool)" -> "has_trivial_destructor>::size() const [with Element_type = thread_info*,bool has_trivial_destructor = true,size_t = long unsigned int]"
"mysqld_list_processes(THD*,const char*,bool)" -> "has_trivial_destructor>::Mem_root_array(MEM_ROOT*) [with Element_type = thread_info*,bool has_trivial_destructor = true,MEM_ROOT = st_mem_root]"
"mysqld_list_processes(THD*,const char*,bool)" -> "copy_global_thread_list(std::set<THD*>*)"
"mysqld_list_processes(THD*,const char*,bool)" -> "has_trivial_destructor>::push_back(const Element_type&) [with Element_type = thread_info*,bool has_trivial_destructor = true]"
"mysqld_list_processes(THD*,const char*,bool)" -> "THD::vio_ok() const"
"mysqld_list_processes(THD*,const char*,bool)" -> "Security_context::get_ip()"
"mysqld_list_processes(THD*,const char*,bool)" -> "Protocol::store(ulonglong)"
"mysqld_list_processes(THD*,const char*,bool)" -> "Protocol::store(const char*,const CHARSET_INFO*)"
"mysqld_list_processes(THD*,const char*,bool)" -> "my_time(myf)"
"mysqld_list_processes(THD*,const char*,bool)" -> "String::length() const"
"mysqld_list_processes(THD*,const char*,bool)" -> "List<T>::List() [with T = Item]"
"mysqld_list_processes(THD*,const char*,bool)" -> "thread_info::thread_info()"
"mysqld_list_processes(THD*,const char*,bool)" -> "has_trivial_destructor>::begin() [with Element_type = thread_info*,bool has_trivial_destructor = true]"
"mysqld_list_processes(THD*,const char*,bool)" -> "Item_int::Item_int(const Name_string&,longlong,uint)"
"mysqld_list_processes(THD*,const char*,bool)" -> "thread_state_info(THD*)"
"mysqld_list_processes(THD*,const char*,bool)" -> "std::_Rb_tree_const_iterator<_Tp>::operator*() const [with _Tp = THD*,std::_Rb_tree_const_iterator<_Tp>::reference = THD* const&]"
"mysqld_list_processes(THD*,const char*,bool)" -> "Security_context::get_host()"
"mysqld_list_processes(THD*,const char*,bool)" -> "Statement::query() const"
"mysqld_list_processes(THD*,const char*,bool)" -> "_Alloc>::begin() const [with _Key = THD*,_Compare = std::less<THD*>,_Alloc = std::allocator<THD*>,std::set<_Key,_Compare,_Alloc>::iterator = std::_Rb_tree_const_iterator<THD*>]"
"mysqld_list_processes(THD*,const char*,bool)" -> "_Alloc>::set() [with _Key = THD*,_Compare = std::less<THD*>,_Alloc = std::allocator<THD*>]"
"mysqld_list_processes(THD*,const char*,bool)" -> "_Alloc>::end() const [with _Key = THD*,_Compare = std::less<THD*>,_Alloc = std::allocator<THD*>,std::set<_Key,_Compare,_Alloc>::iterator = std::_Rb_tree_const_iterator<THD*>]"
"std::sort(_RAIter,_RAIter,_Compare) [with _RAIter = thread_info**,_Compare = thread_info_compare]" -> "std::__final_insertion_sort(_RandomAccessIterator,_RandomAccessIterator,_Compare) [with _RandomAccessIterator = thread_info**,_Compare = thread_info_compare]"
"std::sort(_RAIter,_RAIter,_Compare) [with _RAIter = thread_info**,_Compare = thread_info_compare]" -> "std::__lg(long int)"
"std::sort(_RAIter,_RAIter,_Compare) [with _RAIter = thread_info**,_Compare = thread_info_compare]" -> "std::__introsort_loop(_RandomAccessIterator,_RandomAccessIterator,_Size,_Compare) [with _RandomAccessIterator = thread_info**,_Size = long int,_Compare = thread_info_compare]"
"std::__final_insertion_sort(_RandomAccessIterator,_RandomAccessIterator,_Compare) [with _RandomAccessIterator = thread_info**,_Compare = thread_info_compare]" -> "std::__insertion_sort(_RandomAccessIterator,_RandomAccessIterator,_Compare) [with _RandomAccessIterator = thread_info**,_Compare = thread_info_compare]"
"std::__final_insertion_sort(_RandomAccessIterator,_RandomAccessIterator,_Compare) [with _RandomAccessIterator = thread_info**,_Compare = thread_info_compare]" -> "std::__unguarded_insertion_sort(_RandomAccessIterator,_RandomAccessIterator,_Compare) [with _RandomAccessIterator = thread_info**,_Compare = thread_info_compare]"
"std::__insertion_sort(_RandomAccessIterator,_RandomAccessIterator,_Compare) [with _RandomAccessIterator = thread_info**,_Compare = thread_info_compare]" -> "std::__unguarded_linear_insert(_RandomAccessIterator,_Compare) [with _RandomAccessIterator = thread_info**,_Compare = thread_info_compare]"
"std::__insertion_sort(_RandomAccessIterator,_RandomAccessIterator,_Compare) [with _RandomAccessIterator = thread_info**,_Compare = thread_info_compare]" -> "std::copy_backward(_BI1,_BI1,_BI2) [with _BI1 = thread_info**,_BI2 = thread_info**]"
"std::__insertion_sort(_RandomAccessIterator,_RandomAccessIterator,_Compare) [with _RandomAccessIterator = thread_info**,_Compare = thread_info_compare]" -> "thread_info_compare::operator()(const thread_info*,const thread_info*)"
"std::__unguarded_linear_insert(_RandomAccessIterator,_Compare) [with _RandomAccessIterator = thread_info**,_Compare = thread_info_compare]" -> "thread_info_compare::operator()(const thread_info*,const thread_info*)"
"std::copy_backward(_BI1,_BI1,_BI2) [with _BI1 = thread_info**,_BI2 = thread_info**]" -> "std::__copy_move_backward_a2(_BI1,_BI1,_BI2) [with bool _IsMove = false,_BI1 = thread_info**,_BI2 = thread_info**]"
"std::copy_backward(_BI1,_BI1,_BI2) [with _BI1 = thread_info**,_BI2 = thread_info**]" -> "std::__miter_base(_Iterator) [with _Iterator = thread_info**,typename std::_Miter_base<_Iterator>::iterator_type = thread_info**]"
"std::__copy_move_backward_a2(_BI1,_BI1,_BI2) [with bool _IsMove = false,_BI1 = thread_info**,_BI2 = thread_info**]" -> "std::__niter_base(_Iterator) [with _Iterator = thread_info**,typename std::_Niter_base<_Iterator>::iterator_type = thread_info**]"
"std::__copy_move_backward_a2(_BI1,_BI1,_BI2) [with bool _IsMove = false,_BI1 = thread_info**,_BI2 = thread_info**]" -> "std::__copy_move_backward_a(_BI1,_BI1,_BI2) [with bool _IsMove = false,_BI1 = thread_info**,_BI2 = thread_info**]"
"std::__niter_base(_Iterator) [with _Iterator = thread_info**,typename std::_Niter_base<_Iterator>::iterator_type = thread_info**]" -> "_HasBase>::_S_base(_Iterator) [with _Iterator = thread_info**,bool _HasBase = false,std::_Iter_base<_Iterator,_HasBase>::iterator_type = thread_info**]"
"std::__copy_move_backward_a(_BI1,_BI1,_BI2) [with bool _IsMove = false,_BI1 = thread_info**,_BI2 = thread_info**]" -> "std::random_access_iterator_tag>::__copy_move_b(const _Tp*,const _Tp*,_Tp*) [with _Tp = thread_info*,bool _IsMove = false]"
"std::random_access_iterator_tag>::__copy_move_b(const _Tp*,const _Tp*,_Tp*) [with _Tp = thread_info*,bool _IsMove = false]" -> "__builtin_memmove(void*,const void*,long unsigned int)"
"std::__miter_base(_Iterator) [with _Iterator = thread_info**,typename std::_Miter_base<_Iterator>::iterator_type = thread_info**]" -> "_HasBase>::_S_base(_Iterator) [with _Iterator = thread_info**,bool _HasBase = false,std::_Iter_base<_Iterator,_HasBase>::iterator_type = thread_info**]"
"std::__unguarded_insertion_sort(_RandomAccessIterator,_RandomAccessIterator,_Compare) [with _RandomAccessIterator = thread_info**,_Compare = thread_info_compare]" -> "std::__unguarded_linear_insert(_RandomAccessIterator,_Compare) [with _RandomAccessIterator = thread_info**,_Compare = thread_info_compare]"
"std::__lg(long int)" -> "__builtin_clzl(long unsigned int)"
"std::__introsort_loop(_RandomAccessIterator,_RandomAccessIterator,_Size,_Compare) [with _RandomAccessIterator = thread_info**,_Size = long int,_Compare = thread_info_compare]" -> "std::partial_sort(_RAIter,_RAIter,_RAIter,_Compare) [with _RAIter = thread_info**,_Compare = thread_info_compare]"
"std::__introsort_loop(_RandomAccessIterator,_RandomAccessIterator,_Size,_Compare) [with _RandomAccessIterator = thread_info**,_Size = long int,_Compare = thread_info_compare]" -> "std::__unguarded_partition_pivot(_RandomAccessIterator,_RandomAccessIterator,_Compare) [with _RandomAccessIterator = thread_info**,_Compare = thread_info_compare]"
"std::__introsort_loop(_RandomAccessIterator,_RandomAccessIterator,_Size,_Compare) [with _RandomAccessIterator = thread_info**,_Size = long int,_Compare = thread_info_compare]" -> "std::__introsort_loop(_RandomAccessIterator,_RandomAccessIterator,_Size,_Compare) [with _RandomAccessIterator = thread_info**,_Size = long int,_Compare = thread_info_compare]"
"std::partial_sort(_RAIter,_RAIter,_RAIter,_Compare) [with _RAIter = thread_info**,_Compare = thread_info_compare]" -> "std::sort_heap(_RAIter,_RAIter,_Compare) [with _RAIter = thread_info**,_Compare = thread_info_compare]"
"std::partial_sort(_RAIter,_RAIter,_RAIter,_Compare) [with _RAIter = thread_info**,_Compare = thread_info_compare]" -> "std::__heap_select(_RandomAccessIterator,_RandomAccessIterator,_RandomAccessIterator,_Compare) [with _RandomAccessIterator = thread_info**,_Compare = thread_info_compare]"
"std::sort_heap(_RAIter,_RAIter,_Compare) [with _RAIter = thread_info**,_Compare = thread_info_compare]" -> "std::__pop_heap(_RandomAccessIterator,_RandomAccessIterator,_RandomAccessIterator,_Compare) [with _RandomAccessIterator = thread_info**,_Compare = thread_info_compare]"
"std::__pop_heap(_RandomAccessIterator,_RandomAccessIterator,_RandomAccessIterator,_Compare) [with _RandomAccessIterator = thread_info**,_Compare = thread_info_compare]" -> "std::__adjust_heap(_RandomAccessIterator,_Distance,_Distance,_Tp,_Compare) [with _RandomAccessIterator = thread_info**,_Distance = long int,_Tp = thread_info*,_Compare = thread_info_compare]"
"std::__adjust_heap(_RandomAccessIterator,_Distance,_Distance,_Tp,_Compare) [with _RandomAccessIterator = thread_info**,_Distance = long int,_Tp = thread_info*,_Compare = thread_info_compare]" -> "thread_info_compare::operator()(const thread_info*,const thread_info*)"
"std::__adjust_heap(_RandomAccessIterator,_Distance,_Distance,_Tp,_Compare) [with _RandomAccessIterator = thread_info**,_Distance = long int,_Tp = thread_info*,_Compare = thread_info_compare]" -> "std::__push_heap(_RandomAccessIterator,_Distance,_Distance,_Tp,_Compare) [with _RandomAccessIterator = thread_info**,_Distance = long int,_Tp = thread_info*,_Compare = thread_info_compare]"
"std::__push_heap(_RandomAccessIterator,_Distance,_Distance,_Tp,_Compare) [with _RandomAccessIterator = thread_info**,_Distance = long int,_Tp = thread_info*,_Compare = thread_info_compare]" -> "thread_info_compare::operator()(const thread_info*,const thread_info*)"
"std::__heap_select(_RandomAccessIterator,_RandomAccessIterator,_RandomAccessIterator,_Compare) [with _RandomAccessIterator = thread_info**,_Compare = thread_info_compare]" -> "std::__pop_heap(_RandomAccessIterator,_RandomAccessIterator,_RandomAccessIterator,_Compare) [with _RandomAccessIterator = thread_info**,_Compare = thread_info_compare]"
"std::__heap_select(_RandomAccessIterator,_RandomAccessIterator,_RandomAccessIterator,_Compare) [with _RandomAccessIterator = thread_info**,_Compare = thread_info_compare]" -> "thread_info_compare::operator()(const thread_info*,const thread_info*)"
"std::__heap_select(_RandomAccessIterator,_RandomAccessIterator,_RandomAccessIterator,_Compare) [with _RandomAccessIterator = thread_info**,_Compare = thread_info_compare]" -> "std::make_heap(_RAIter,_RAIter,_Compare) [with _RAIter = thread_info**,_Compare = thread_info_compare]"
"std::make_heap(_RAIter,_RAIter,_Compare) [with _RAIter = thread_info**,_Compare = thread_info_compare]" -> "std::__adjust_heap(_RandomAccessIterator,_Distance,_Distance,_Tp,_Compare) [with _RandomAccessIterator = thread_info**,_Distance = long int,_Tp = thread_info*,_Compare = thread_info_compare]"
"std::__unguarded_partition_pivot(_RandomAccessIterator,_RandomAccessIterator,_Compare) [with _RandomAccessIterator = thread_info**,_Compare = thread_info_compare]" -> "std::__unguarded_partition(_RandomAccessIterator,_RandomAccessIterator,const _Tp&,_Compare) [with _RandomAccessIterator = thread_info**,_Tp = thread_info*,_Compare = thread_info_compare]"
"std::__unguarded_partition_pivot(_RandomAccessIterator,_RandomAccessIterator,_Compare) [with _RandomAccessIterator = thread_info**,_Compare = thread_info_compare]" -> "std::__move_median_first(_Iterator,_Iterator,_Iterator,_Compare) [with _Iterator = thread_info**,_Compare = thread_info_compare]"
"std::__unguarded_partition(_RandomAccessIterator,_RandomAccessIterator,const _Tp&,_Compare) [with _RandomAccessIterator = thread_info**,_Tp = thread_info*,_Compare = thread_info_compare]" -> "thread_info_compare::operator()(const thread_info*,const thread_info*)"
"std::__unguarded_partition(_RandomAccessIterator,_RandomAccessIterator,const _Tp&,_Compare) [with _RandomAccessIterator = thread_info**,_Tp = thread_info*,_Compare = thread_info_compare]" -> "std::iter_swap(_ForwardIterator1,_ForwardIterator2) [with _ForwardIterator1 = thread_info**,_ForwardIterator2 = thread_info**]"
"std::iter_swap(_ForwardIterator1,_ForwardIterator2) [with _ForwardIterator1 = thread_info**,_ForwardIterator2 = thread_info**]" -> "std::__iter_swap<true>::iter_swap(_ForwardIterator1,_ForwardIterator2) [with _ForwardIterator1 = thread_info**,_ForwardIterator2 = thread_info**]"
"std::__iter_swap<true>::iter_swap(_ForwardIterator1,_ForwardIterator2) [with _ForwardIterator1 = thread_info**,_ForwardIterator2 = thread_info**]" -> "std::swap(_Tp&,_Tp&) [with _Tp = thread_info*]"
"std::__move_median_first(_Iterator,_Iterator,_Iterator,_Compare) [with _Iterator = thread_info**,_Compare = thread_info_compare]" -> "std::iter_swap(_ForwardIterator1,_ForwardIterator2) [with _ForwardIterator1 = thread_info**,_ForwardIterator2 = thread_info**]"
"std::__move_median_first(_Iterator,_Iterator,_Iterator,_Compare) [with _Iterator = thread_info**,_Compare = thread_info_compare]" -> "thread_info_compare::operator()(const thread_info*,const thread_info*)"
"has_trivial_destructor>::reserve(size_t) [with Element_type = thread_info*,bool has_trivial_destructor = true,size_t = long unsigned int]" -> "alloc_root(MEM_ROOT*,size_t)"
"has_trivial_destructor>::reserve(size_t) [with Element_type = thread_info*,bool has_trivial_destructor = true,size_t = long unsigned int]" -> "has_trivial_destructor>::element_size() const [with Element_type = thread_info*,bool has_trivial_destructor = true,size_t = long unsigned int]"
"has_trivial_destructor>::end() [with Element_type = thread_info*,bool has_trivial_destructor = true]" -> "has_trivial_destructor>::size() const [with Element_type = thread_info*,bool has_trivial_destructor = true,size_t = long unsigned int]"
"Statement::query_charset() const" -> "CSET_STRING::charset() const"
"copy_global_thread_list(std::set<THD*>*)" -> "inline_mysql_mutex_lock(mysql_mutex_t*)"
"copy_global_thread_list(std::set<THD*>*)" -> "inline_mysql_mutex_unlock(mysql_mutex_t*)"
"copy_global_thread_list(std::set<THD*>*)" -> "_Alloc>::operator=(const std::set<_Key,_Compare,_Alloc>&) [with _Key = THD*,_Compare = std::less<THD*>,_Alloc = std::allocator<THD*>,std::set<_Key,_Compare,_Alloc> = std::set<THD*>]"
"copy_global_thread_list(std::set<THD*>*)" -> "inline_mysql_mutex_lock(mysql_mutex_t*,const char*,uint)"
"_Alloc>::operator=(const std::set<_Key,_Compare,_Alloc>&) [with _Key = THD*,_Compare = std::less<THD*>,_Alloc = std::allocator<THD*>,std::set<_Key,_Compare,_Alloc> = std::set<THD*>]" -> "_Alloc>::operator=(const std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>&) [with _Key = THD*,_Val = THD*,_KeyOfValue = std::_Identity<THD*>,_Compare = std::less<THD*>,_Alloc = std::allocator<THD*>]"
"_Alloc>::operator=(const std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>&) [with _Key = THD*,_Val = THD*,_KeyOfValue = std::_Identity<THD*>,_Compare = std::less<THD*>,_Alloc = std::allocator<THD*>]" -> "_Alloc>::_M_root() const [with _Key = THD*,_Val = THD*,_KeyOfValue = std::_Identity<THD*>,_Compare = std::less<THD*>,_Alloc = std::allocator<THD*>,std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::_Const_Base_ptr = const std::_Rb_tree_node_base*]"
"_Alloc>::operator=(const std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>&) [with _Key = THD*,_Val = THD*,_KeyOfValue = std::_Identity<THD*>,_Compare = std::less<THD*>,_Alloc = std::allocator<THD*>]" -> "_Alloc>::_M_begin() const [with _Key = THD*,_Val = THD*,_KeyOfValue = std::_Identity<THD*>,_Compare = std::less<THD*>,_Alloc = std::allocator<THD*>,std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::_Const_Link_type = const std::_Rb_tree_node<THD*>*]"
"_Alloc>::operator=(const std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>&) [with _Key = THD*,_Val = THD*,_KeyOfValue = std::_Identity<THD*>,_Compare = std::less<THD*>,_Alloc = std::allocator<THD*>]" -> "_Alloc>::_M_rightmost() [with _Key = THD*,_Val = THD*,_KeyOfValue = std::_Identity<THD*>,_Compare = std::less<THD*>,_Alloc = std::allocator<THD*>,std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::_Base_ptr = std::_Rb_tree_node_base*]"
"_Alloc>::operator=(const std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>&) [with _Key = THD*,_Val = THD*,_KeyOfValue = std::_Identity<THD*>,_Compare = std::less<THD*>,_Alloc = std::allocator<THD*>]" -> "_Alloc>::clear() [with _Key = THD*,_Val = THD*,_KeyOfValue = std::_Identity<THD*>,_Compare = std::less<THD*>,_Alloc = std::allocator<THD*>]"
"_Alloc>::operator=(const std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>&) [with _Key = THD*,_Val = THD*,_KeyOfValue = std::_Identity<THD*>,_Compare = std::less<THD*>,_Alloc = std::allocator<THD*>]" -> "_Alloc>::_M_leftmost() [with _Key = THD*,_Val = THD*,_KeyOfValue = std::_Identity<THD*>,_Compare = std::less<THD*>,_Alloc = std::allocator<THD*>,std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::_Base_ptr = std::_Rb_tree_node_base*]"
"_Alloc>::operator=(const std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>&) [with _Key = THD*,_Val = THD*,_KeyOfValue = std::_Identity<THD*>,_Compare = std::less<THD*>,_Alloc = std::allocator<THD*>]" -> "_Alloc>::_M_end() [with _Key = THD*,_Val = THD*,_KeyOfValue = std::_Identity<THD*>,_Compare = std::less<THD*>,_Alloc = std::allocator<THD*>,std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::_Link_type = std::_Rb_tree_node<THD*>*]"
"_Alloc>::operator=(const std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>&) [with _Key = THD*,_Val = THD*,_KeyOfValue = std::_Identity<THD*>,_Compare = std::less<THD*>,_Alloc = std::allocator<THD*>]" -> "_Alloc>::_S_maximum(std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::_Base_ptr) [with _Key = THD*,_Val = THD*,_KeyOfValue = std::_Identity<THD*>,_Compare = std::less<THD*>,_Alloc = std::allocator<THD*>,std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::_Base_ptr = std::_Rb_tree_node_base*]"
"_Alloc>::operator=(const std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>&) [with _Key = THD*,_Val = THD*,_KeyOfValue = std::_Identity<THD*>,_Compare = std::less<THD*>,_Alloc = std::allocator<THD*>]" -> "_Alloc>::_S_minimum(std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::_Base_ptr) [with _Key = THD*,_Val = THD*,_KeyOfValue = std::_Identity<THD*>,_Compare = std::less<THD*>,_Alloc = std::allocator<THD*>,std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::_Base_ptr = std::_Rb_tree_node_base*]"
"_Alloc>::operator=(const std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>&) [with _Key = THD*,_Val = THD*,_KeyOfValue = std::_Identity<THD*>,_Compare = std::less<THD*>,_Alloc = std::allocator<THD*>]" -> "_Alloc>::_M_copy(std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::_Const_Link_type,std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::_Link_type) [with _Key = THD*,_Val = THD*,_KeyOfValue = std::_Identity<THD*>,_Compare = std::less<THD*>,_Alloc = std::allocator<THD*>,std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::_Link_type = std::_Rb_tree_node<THD*>*,std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::_Const_Link_type = const std::_Rb_tree_node<THD*>*]"
"_Alloc>::operator=(const std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>&) [with _Key = THD*,_Val = THD*,_KeyOfValue = std::_Identity<THD*>,_Compare = std::less<THD*>,_Alloc = std::allocator<THD*>]" -> "_Alloc>::_M_root() [with _Key = THD*,_Val = THD*,_KeyOfValue = std::_Identity<THD*>,_Compare = std::less<THD*>,_Alloc = std::allocator<THD*>,std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::_Base_ptr = std::_Rb_tree_node_base*]"
"_Alloc>::clear() [with _Key = THD*,_Val = THD*,_KeyOfValue = std::_Identity<THD*>,_Compare = std::less<THD*>,_Alloc = std::allocator<THD*>]" -> "_Alloc>::_M_end() [with _Key = THD*,_Val = THD*,_KeyOfValue = std::_Identity<THD*>,_Compare = std::less<THD*>,_Alloc = std::allocator<THD*>,std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::_Link_type = std::_Rb_tree_node<THD*>*]"
"_Alloc>::clear() [with _Key = THD*,_Val = THD*,_KeyOfValue = std::_Identity<THD*>,_Compare = std::less<THD*>,_Alloc = std::allocator<THD*>]" -> "_Alloc>::_M_begin() [with _Key = THD*,_Val = THD*,_KeyOfValue = std::_Identity<THD*>,_Compare = std::less<THD*>,_Alloc = std::allocator<THD*>,std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::_Link_type = std::_Rb_tree_node<THD*>*]"
"_Alloc>::clear() [with _Key = THD*,_Val = THD*,_KeyOfValue = std::_Identity<THD*>,_Compare = std::less<THD*>,_Alloc = std::allocator<THD*>]" -> "_Alloc>::_M_rightmost() [with _Key = THD*,_Val = THD*,_KeyOfValue = std::_Identity<THD*>,_Compare = std::less<THD*>,_Alloc = std::allocator<THD*>,std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::_Base_ptr = std::_Rb_tree_node_base*]"
"_Alloc>::clear() [with _Key = THD*,_Val = THD*,_KeyOfValue = std::_Identity<THD*>,_Compare = std::less<THD*>,_Alloc = std::allocator<THD*>]" -> "_Alloc>::_M_erase(std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::_Link_type) [with _Key = THD*,_Val = THD*,_KeyOfValue = std::_Identity<THD*>,_Compare = std::less<THD*>,_Alloc = std::allocator<THD*>,std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::_Link_type = std::_Rb_tree_node<THD*>*]"
"_Alloc>::clear() [with _Key = THD*,_Val = THD*,_KeyOfValue = std::_Identity<THD*>,_Compare = std::less<THD*>,_Alloc = std::allocator<THD*>]" -> "_Alloc>::_M_root() [with _Key = THD*,_Val = THD*,_KeyOfValue = std::_Identity<THD*>,_Compare = std::less<THD*>,_Alloc = std::allocator<THD*>,std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::_Base_ptr = std::_Rb_tree_node_base*]"
"_Alloc>::clear() [with _Key = THD*,_Val = THD*,_KeyOfValue = std::_Identity<THD*>,_Compare = std::less<THD*>,_Alloc = std::allocator<THD*>]" -> "_Alloc>::_M_leftmost() [with _Key = THD*,_Val = THD*,_KeyOfValue = std::_Identity<THD*>,_Compare = std::less<THD*>,_Alloc = std::allocator<THD*>,std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::_Base_ptr = std::_Rb_tree_node_base*]"
"_Alloc>::_M_erase(std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::_Link_type) [with _Key = THD*,_Val = THD*,_KeyOfValue = std::_Identity<THD*>,_Compare = std::less<THD*>,_Alloc = std::allocator<THD*>,std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::_Link_type = std::_Rb_tree_node<THD*>*]" -> "_Alloc>::_S_left(std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::_Base_ptr) [with _Key = THD*,_Val = THD*,_KeyOfValue = std::_Identity<THD*>,_Compare = std::less<THD*>,_Alloc = std::allocator<THD*>,std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::_Link_type = std::_Rb_tree_node<THD*>*,std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::_Base_ptr = std::_Rb_tree_node_base*]"
"_Alloc>::_M_erase(std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::_Link_type) [with _Key = THD*,_Val = THD*,_KeyOfValue = std::_Identity<THD*>,_Compare = std::less<THD*>,_Alloc = std::allocator<THD*>,std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::_Link_type = std::_Rb_tree_node<THD*>*]" -> "_Alloc>::_M_destroy_node(std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::_Link_type) [with _Key = THD*,_Val = THD*,_KeyOfValue = std::_Identity<THD*>,_Compare = std::less<THD*>,_Alloc = std::allocator<THD*>,std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::_Link_type = std::_Rb_tree_node<THD*>*]"
"_Alloc>::_M_erase(std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::_Link_type) [with _Key = THD*,_Val = THD*,_KeyOfValue = std::_Identity<THD*>,_Compare = std::less<THD*>,_Alloc = std::allocator<THD*>,std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::_Link_type = std::_Rb_tree_node<THD*>*]" -> "_Alloc>::_S_right(std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::_Base_ptr) [with _Key = THD*,_Val = THD*,_KeyOfValue = std::_Identity<THD*>,_Compare = std::less<THD*>,_Alloc = std::allocator<THD*>,std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::_Link_type = std::_Rb_tree_node<THD*>*,std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::_Base_ptr = std::_Rb_tree_node_base*]"
"_Alloc>::_M_erase(std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::_Link_type) [with _Key = THD*,_Val = THD*,_KeyOfValue = std::_Identity<THD*>,_Compare = std::less<THD*>,_Alloc = std::allocator<THD*>,std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::_Link_type = std::_Rb_tree_node<THD*>*]" -> "_Alloc>::_M_erase(std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::_Link_type) [with _Key = THD*,_Val = THD*,_KeyOfValue = std::_Identity<THD*>,_Compare = std::less<THD*>,_Alloc = std::allocator<THD*>,std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::_Link_type = std::_Rb_tree_node<THD*>*]"
"_Alloc>::_M_destroy_node(std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::_Link_type) [with _Key = THD*,_Val = THD*,_KeyOfValue = std::_Identity<THD*>,_Compare = std::less<THD*>,_Alloc = std::allocator<THD*>,std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::_Link_type = std::_Rb_tree_node<THD*>*]" -> "_Alloc>::_M_put_node(std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::_Link_type) [with _Key = THD*,_Val = THD*,_KeyOfValue = std::_Identity<THD*>,_Compare = std::less<THD*>,_Alloc = std::allocator<THD*>,std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::_Link_type = std::_Rb_tree_node<THD*>*]"
"_Alloc>::_M_destroy_node(std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::_Link_type) [with _Key = THD*,_Val = THD*,_KeyOfValue = std::_Identity<THD*>,_Compare = std::less<THD*>,_Alloc = std::allocator<THD*>,std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::_Link_type = std::_Rb_tree_node<THD*>*]" -> "_Alloc>::get_allocator() const [with _Key = THD*,_Val = THD*,_KeyOfValue = std::_Identity<THD*>,_Compare = std::less<THD*>,_Alloc = std::allocator<THD*>,std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::allocator_type = std::allocator<THD*>]"
"_Alloc>::_M_destroy_node(std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::_Link_type) [with _Key = THD*,_Val = THD*,_KeyOfValue = std::_Identity<THD*>,_Compare = std::less<THD*>,_Alloc = std::allocator<THD*>,std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::_Link_type = std::_Rb_tree_node<THD*>*]" -> "__gnu_cxx::new_allocator<_Tp>::destroy(__gnu_cxx::new_allocator<_Tp>::pointer) [with _Tp = THD*,__gnu_cxx::new_allocator<_Tp>::pointer = THD**]"
"_Alloc>::_M_destroy_node(std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::_Link_type) [with _Key = THD*,_Val = THD*,_KeyOfValue = std::_Identity<THD*>,_Compare = std::less<THD*>,_Alloc = std::allocator<THD*>,std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::_Link_type = std::_Rb_tree_node<THD*>*]" -> "std::__addressof(_Tp&) [with _Tp = THD*]"
"_Alloc>::_M_put_node(std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::_Link_type) [with _Key = THD*,_Val = THD*,_KeyOfValue = std::_Identity<THD*>,_Compare = std::less<THD*>,_Alloc = std::allocator<THD*>,std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::_Link_type = std::_Rb_tree_node<THD*>*]" -> "__gnu_cxx::new_allocator<_Tp>::deallocate(__gnu_cxx::new_allocator<_Tp>::pointer,__gnu_cxx::new_allocator<_Tp>::size_type) [with _Tp = std::_Rb_tree_node<THD*>,__gnu_cxx::new_allocator<_Tp>::pointer = std::_Rb_tree_node<THD*>*,__gnu_cxx::new_allocator<_Tp>::size_type = long unsigned int]"
"_Alloc>::get_allocator() const [with _Key = THD*,_Val = THD*,_KeyOfValue = std::_Identity<THD*>,_Compare = std::less<THD*>,_Alloc = std::allocator<THD*>,std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::allocator_type = std::allocator<THD*>]" -> "std::allocator<_Tp>::allocator(const std::allocator<_Tp1>&) [with _Tp1 = std::_Rb_tree_node<THD*>,_Tp = THD*]"
"_Alloc>::get_allocator() const [with _Key = THD*,_Val = THD*,_KeyOfValue = std::_Identity<THD*>,_Compare = std::less<THD*>,_Alloc = std::allocator<THD*>,std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::allocator_type = std::allocator<THD*>]" -> "_Alloc>::_M_get_Node_allocator() const [with _Key = THD*,_Val = THD*,_KeyOfValue = std::_Identity<THD*>,_Compare = std::less<THD*>,_Alloc = std::allocator<THD*>,std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::_Node_allocator = std::allocator<std::_Rb_tree_node<THD*> >]"
"std::allocator<_Tp>::allocator(const std::allocator<_Tp1>&) [with _Tp1 = std::_Rb_tree_node<THD*>,_Tp = THD*]" -> "__gnu_cxx::new_allocator<_Tp>::new_allocator() [with _Tp = THD*]"
"_Alloc>::_S_maximum(std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::_Base_ptr) [with _Key = THD*,_Val = THD*,_KeyOfValue = std::_Identity<THD*>,_Compare = std::less<THD*>,_Alloc = std::allocator<THD*>,std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::_Base_ptr = std::_Rb_tree_node_base*]" -> "std::_Rb_tree_node_base::_S_maximum(std::_Rb_tree_node_base::_Base_ptr)"
"_Alloc>::_S_minimum(std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::_Base_ptr) [with _Key = THD*,_Val = THD*,_KeyOfValue = std::_Identity<THD*>,_Compare = std::less<THD*>,_Alloc = std::allocator<THD*>,std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::_Base_ptr = std::_Rb_tree_node_base*]" -> "std::_Rb_tree_node_base::_S_minimum(std::_Rb_tree_node_base::_Base_ptr)"
"_Alloc>::_M_copy(std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::_Const_Link_type,std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::_Link_type) [with _Key = THD*,_Val = THD*,_KeyOfValue = std::_Identity<THD*>,_Compare = std::less<THD*>,_Alloc = std::allocator<THD*>,std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::_Link_type = std::_Rb_tree_node<THD*>*,std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::_Const_Link_type = const std::_Rb_tree_node<THD*>*]" -> "_Alloc>::_M_clone_node(std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::_Const_Link_type) [with _Key = THD*,_Val = THD*,_KeyOfValue = std::_Identity<THD*>,_Compare = std::less<THD*>,_Alloc = std::allocator<THD*>,std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::_Link_type = std::_Rb_tree_node<THD*>*,std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::_Const_Link_type = const std::_Rb_tree_node<THD*>*]"
"_Alloc>::_M_copy(std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::_Const_Link_type,std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::_Link_type) [with _Key = THD*,_Val = THD*,_KeyOfValue = std::_Identity<THD*>,_Compare = std::less<THD*>,_Alloc = std::allocator<THD*>,std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::_Link_type = std::_Rb_tree_node<THD*>*,std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::_Const_Link_type = const std::_Rb_tree_node<THD*>*]" -> "_Alloc>::_M_erase(std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::_Link_type) [with _Key = THD*,_Val = THD*,_KeyOfValue = std::_Identity<THD*>,_Compare = std::less<THD*>,_Alloc = std::allocator<THD*>,std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::_Link_type = std::_Rb_tree_node<THD*>*]"
"_Alloc>::_M_copy(std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::_Const_Link_type,std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::_Link_type) [with _Key = THD*,_Val = THD*,_KeyOfValue = std::_Identity<THD*>,_Compare = std::less<THD*>,_Alloc = std::allocator<THD*>,std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::_Link_type = std::_Rb_tree_node<THD*>*,std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::_Const_Link_type = const std::_Rb_tree_node<THD*>*]" -> "__cxa_rethrow()"
"_Alloc>::_M_copy(std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::_Const_Link_type,std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::_Link_type) [with _Key = THD*,_Val = THD*,_KeyOfValue = std::_Identity<THD*>,_Compare = std::less<THD*>,_Alloc = std::allocator<THD*>,std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::_Link_type = std::_Rb_tree_node<THD*>*,std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::_Const_Link_type = const std::_Rb_tree_node<THD*>*]" -> "__cxa_begin_catch(void*)"
"_Alloc>::_M_copy(std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::_Const_Link_type,std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::_Link_type) [with _Key = THD*,_Val = THD*,_KeyOfValue = std::_Identity<THD*>,_Compare = std::less<THD*>,_Alloc = std::allocator<THD*>,std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::_Link_type = std::_Rb_tree_node<THD*>*,std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::_Const_Link_type = const std::_Rb_tree_node<THD*>*]" -> "__builtin_eh_pointer(int)"
"_Alloc>::_M_copy(std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::_Const_Link_type,std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::_Link_type) [with _Key = THD*,_Val = THD*,_KeyOfValue = std::_Identity<THD*>,_Compare = std::less<THD*>,_Alloc = std::allocator<THD*>,std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::_Link_type = std::_Rb_tree_node<THD*>*,std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::_Const_Link_type = const std::_Rb_tree_node<THD*>*]" -> "_Alloc>::_S_left(std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::_Const_Base_ptr) [with _Key = THD*,_Val = THD*,_KeyOfValue = std::_Identity<THD*>,_Compare = std::less<THD*>,_Alloc = std::allocator<THD*>,std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::_Const_Link_type = const std::_Rb_tree_node<THD*>*,std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::_Const_Base_ptr = const std::_Rb_tree_node_base*]"
"_Alloc>::_M_copy(std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::_Const_Link_type,std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::_Link_type) [with _Key = THD*,_Val = THD*,_KeyOfValue = std::_Identity<THD*>,_Compare = std::less<THD*>,_Alloc = std::allocator<THD*>,std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::_Link_type = std::_Rb_tree_node<THD*>*,std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::_Const_Link_type = const std::_Rb_tree_node<THD*>*]" -> "_Alloc>::_M_copy(std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::_Const_Link_type,std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::_Link_type) [with _Key = THD*,_Val = THD*,_KeyOfValue = std::_Identity<THD*>,_Compare = std::less<THD*>,_Alloc = std::allocator<THD*>,std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::_Link_type = std::_Rb_tree_node<THD*>*,std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::_Const_Link_type = const std::_Rb_tree_node<THD*>*]"
"_Alloc>::_M_copy(std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::_Const_Link_type,std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::_Link_type) [with _Key = THD*,_Val = THD*,_KeyOfValue = std::_Identity<THD*>,_Compare = std::less<THD*>,_Alloc = std::allocator<THD*>,std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::_Link_type = std::_Rb_tree_node<THD*>*,std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::_Const_Link_type = const std::_Rb_tree_node<THD*>*]" -> "_Alloc>::_S_right(std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::_Const_Base_ptr) [with _Key = THD*,_Val = THD*,_KeyOfValue = std::_Identity<THD*>,_Compare = std::less<THD*>,_Alloc = std::allocator<THD*>,std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::_Const_Link_type = const std::_Rb_tree_node<THD*>*,std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::_Const_Base_ptr = const std::_Rb_tree_node_base*]"
"_Alloc>::_M_copy(std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::_Const_Link_type,std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::_Link_type) [with _Key = THD*,_Val = THD*,_KeyOfValue = std::_Identity<THD*>,_Compare = std::less<THD*>,_Alloc = std::allocator<THD*>,std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::_Link_type = std::_Rb_tree_node<THD*>*,std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::_Const_Link_type = const std::_Rb_tree_node<THD*>*]" -> "__cxa_end_catch()"
"_Alloc>::_M_clone_node(std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::_Const_Link_type) [with _Key = THD*,_Val = THD*,_KeyOfValue = std::_Identity<THD*>,_Compare = std::less<THD*>,_Alloc = std::allocator<THD*>,std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::_Link_type = std::_Rb_tree_node<THD*>*,std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::_Const_Link_type = const std::_Rb_tree_node<THD*>*]" -> "_Alloc>::_M_create_node(const value_type&) [with _Key = THD*,_Val = THD*,_KeyOfValue = std::_Identity<THD*>,_Compare = std::less<THD*>,_Alloc = std::allocator<THD*>,std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::_Link_type = std::_Rb_tree_node<THD*>*,std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::value_type = THD*]"
"_Alloc>::_M_create_node(const value_type&) [with _Key = THD*,_Val = THD*,_KeyOfValue = std::_Identity<THD*>,_Compare = std::less<THD*>,_Alloc = std::allocator<THD*>,std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::_Link_type = std::_Rb_tree_node<THD*>*,std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::value_type = THD*]" -> "_Alloc>::get_allocator() const [with _Key = THD*,_Val = THD*,_KeyOfValue = std::_Identity<THD*>,_Compare = std::less<THD*>,_Alloc = std::allocator<THD*>,std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::allocator_type = std::allocator<THD*>]"
"_Alloc>::_M_create_node(const value_type&) [with _Key = THD*,_Val = THD*,_KeyOfValue = std::_Identity<THD*>,_Compare = std::less<THD*>,_Alloc = std::allocator<THD*>,std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::_Link_type = std::_Rb_tree_node<THD*>*,std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::value_type = THD*]" -> "std::__addressof(_Tp&) [with _Tp = THD*]"
"_Alloc>::_M_create_node(const value_type&) [with _Key = THD*,_Val = THD*,_KeyOfValue = std::_Identity<THD*>,_Compare = std::less<THD*>,_Alloc = std::allocator<THD*>,std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::_Link_type = std::_Rb_tree_node<THD*>*,std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::value_type = THD*]" -> "_Alloc>::_M_get_node() [with _Key = THD*,_Val = THD*,_KeyOfValue = std::_Identity<THD*>,_Compare = std::less<THD*>,_Alloc = std::allocator<THD*>,std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::_Link_type = std::_Rb_tree_node<THD*>*]"
"_Alloc>::_M_create_node(const value_type&) [with _Key = THD*,_Val = THD*,_KeyOfValue = std::_Identity<THD*>,_Compare = std::less<THD*>,_Alloc = std::allocator<THD*>,std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::_Link_type = std::_Rb_tree_node<THD*>*,std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::value_type = THD*]" -> "__cxa_end_catch()"
"_Alloc>::_M_create_node(const value_type&) [with _Key = THD*,_Val = THD*,_KeyOfValue = std::_Identity<THD*>,_Compare = std::less<THD*>,_Alloc = std::allocator<THD*>,std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::_Link_type = std::_Rb_tree_node<THD*>*,std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::value_type = THD*]" -> "__cxa_begin_catch(void*)"
"_Alloc>::_M_create_node(const value_type&) [with _Key = THD*,_Val = THD*,_KeyOfValue = std::_Identity<THD*>,_Compare = std::less<THD*>,_Alloc = std::allocator<THD*>,std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::_Link_type = std::_Rb_tree_node<THD*>*,std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::value_type = THD*]" -> "__gnu_cxx::new_allocator<_Tp>::construct(__gnu_cxx::new_allocator<_Tp>::pointer,const _Tp&) [with _Tp = THD*,__gnu_cxx::new_allocator<_Tp>::pointer = THD**]"
"_Alloc>::_M_create_node(const value_type&) [with _Key = THD*,_Val = THD*,_KeyOfValue = std::_Identity<THD*>,_Compare = std::less<THD*>,_Alloc = std::allocator<THD*>,std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::_Link_type = std::_Rb_tree_node<THD*>*,std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::value_type = THD*]" -> "_Alloc>::_M_put_node(std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::_Link_type) [with _Key = THD*,_Val = THD*,_KeyOfValue = std::_Identity<THD*>,_Compare = std::less<THD*>,_Alloc = std::allocator<THD*>,std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::_Link_type = std::_Rb_tree_node<THD*>*]"
"_Alloc>::_M_create_node(const value_type&) [with _Key = THD*,_Val = THD*,_KeyOfValue = std::_Identity<THD*>,_Compare = std::less<THD*>,_Alloc = std::allocator<THD*>,std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::_Link_type = std::_Rb_tree_node<THD*>*,std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::value_type = THD*]" -> "__builtin_eh_pointer(int)"
"_Alloc>::_M_create_node(const value_type&) [with _Key = THD*,_Val = THD*,_KeyOfValue = std::_Identity<THD*>,_Compare = std::less<THD*>,_Alloc = std::allocator<THD*>,std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::_Link_type = std::_Rb_tree_node<THD*>*,std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::value_type = THD*]" -> "__cxa_rethrow()"
"_Alloc>::_M_get_node() [with _Key = THD*,_Val = THD*,_KeyOfValue = std::_Identity<THD*>,_Compare = std::less<THD*>,_Alloc = std::allocator<THD*>,std::_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::_Link_type = std::_Rb_tree_node<THD*>*]" -> "__gnu_cxx::new_allocator<_Tp>::allocate(__gnu_cxx::new_allocator<_Tp>::size_type,const void*) [with _Tp = std::_Rb_tree_node<THD*>,__gnu_cxx::new_allocator<_Tp>::pointer = std::_Rb_tree_node<THD*>*,__gnu_cxx::new_allocator<_Tp>::size_type = long unsigned int]"
"__gnu_cxx::new_allocator<_Tp>::allocate(__gnu_cxx::new_allocator<_Tp>::size_type,const void*) [with _Tp = std::_Rb_tree_node<THD*>,__gnu_cxx::new_allocator<_Tp>::pointer = std::_Rb_tree_node<THD*>*,__gnu_cxx::new_allocator<_Tp>::size_type = long unsigned int]" -> "std::__throw_bad_alloc()"
"__gnu_cxx::new_allocator<_Tp>::allocate(__gnu_cxx::new_allocator<_Tp>::size_type,const void*) [with _Tp = std::_Rb_tree_node<THD*>,__gnu_cxx::new_allocator<_Tp>::pointer = std::_Rb_tree_node<THD*>*,__gnu_cxx::new_allocator<_Tp>::size_type = long unsigned int]" -> "__gnu_cxx::new_allocator<_Tp>::max_size() const [with _Tp = std::_Rb_tree_node<THD*>,__gnu_cxx::new_allocator<_Tp>::size_type = long unsigned int]"
"has_trivial_destructor>::push_back(const Element_type&) [with Element_type = thread_info*,bool has_trivial_destructor = true]" -> "has_trivial_destructor>::reserve(size_t) [with Element_type = thread_info*,bool has_trivial_destructor = true,size_t = long unsigned int]"
"thread_info::thread_info()" -> "CSET_STRING::CSET_STRING()"
"_Alloc>::set() [with _Key = THD*,_Compare = std::less<THD*>,_Alloc = std::allocator<THD*>]" -> "_Alloc>::_Rb_tree() [with _Key = THD*,_Val = THD*,_KeyOfValue = std::_Identity<THD*>,_Compare = std::less<THD*>,_Alloc = std::allocator<THD*>]"
"_Alloc>::_Rb_tree() [with _Key = THD*,_Val = THD*,_KeyOfValue = std::_Identity<THD*>,_Compare = std::less<THD*>,_Alloc = std::allocator<THD*>]" -> "_Is_pod_comparator>::_Rb_tree_impl() [with _Key_compare = std::less<THD*>,bool _Is_pod_comparator = false,_Key = THD*,_Val = THD*,_KeyOfValue = std::_Identity<THD*>,_Compare = std::less<THD*>,_Alloc = std::allocator<THD*>]"
"_Is_pod_comparator>::_Rb_tree_impl() [with _Key_compare = std::less<THD*>,bool _Is_pod_comparator = false,_Key = THD*,_Val = THD*,_KeyOfValue = std::_Identity<THD*>,_Compare = std::less<THD*>,_Alloc = std::allocator<THD*>]" -> "std::allocator<_Tp>::allocator() [with _Tp = std::_Rb_tree_node<THD*>]"
"_Is_pod_comparator>::_Rb_tree_impl() [with _Key_compare = std::less<THD*>,bool _Is_pod_comparator = false,_Key = THD*,_Val = THD*,_KeyOfValue = std::_Identity<THD*>,_Compare = std::less<THD*>,_Alloc = std::allocator<THD*>]" -> "_Is_pod_comparator>::_M_initialize() [with _Key_compare = std::less<THD*>,bool _Is_pod_comparator = false,_Key = THD*,_Val = THD*,_KeyOfValue = std::_Identity<THD*>,_Compare = std::less<THD*>,_Alloc = std::allocator<THD*>]"
"std::allocator<_Tp>::allocator() [with _Tp = std::_Rb_tree_node<THD*>]" -> "__gnu_cxx::new_allocator<_Tp>::new_allocator() [with _Tp = std::_Rb_tree_node<THD*>]"
"multi_delete::multi_delete(TABLE_LIST*,uint)" -> "sql_calloc(size_t)"
"multi_delete::multi_delete(TABLE_LIST*,uint)" -> "select_result_interceptor::select_result_interceptor()"
"Alter_info::Alter_info(const Alter_info&,MEM_ROOT*)" -> "List<T>::List(const List<T>&,MEM_ROOT*) [with T = Alter_drop,MEM_ROOT = st_mem_root]"
"Alter_info::Alter_info(const Alter_info&,MEM_ROOT*)" -> "List<T>::List(const List<T>&,MEM_ROOT*) [with T = Alter_column,MEM_ROOT = st_mem_root]"
"Alter_info::Alter_info(const Alter_info&,MEM_ROOT*)" -> "List<T>::List(const List<T>&,MEM_ROOT*) [with T = char,MEM_ROOT = st_mem_root]"
"Alter_info::Alter_info(const Alter_info&,MEM_ROOT*)" -> "List<T>::List(const List<T>&,MEM_ROOT*) [with T = Create_field,MEM_ROOT = st_mem_root]"
"Alter_info::Alter_info(const Alter_info&,MEM_ROOT*)" -> "list_copy_and_replace_each_value(List<T>&,MEM_ROOT*) [with T = Alter_drop,MEM_ROOT = st_mem_root]"
"Alter_info::Alter_info(const Alter_info&,MEM_ROOT*)" -> "list_copy_and_replace_each_value(List<T>&,MEM_ROOT*) [with T = Key,MEM_ROOT = st_mem_root]"
"Alter_info::Alter_info(const Alter_info&,MEM_ROOT*)" -> "list_copy_and_replace_each_value(List<T>&,MEM_ROOT*) [with T = Alter_column,MEM_ROOT = st_mem_root]"
"Alter_info::Alter_info(const Alter_info&,MEM_ROOT*)" -> "list_copy_and_replace_each_value(List<T>&,MEM_ROOT*) [with T = Create_field,MEM_ROOT = st_mem_root]"
"Alter_info::Alter_info(const Alter_info&,MEM_ROOT*)" -> "List<T>::List(const List<T>&,MEM_ROOT*) [with T = Key,MEM_ROOT = st_mem_root]"
"List<T>::List(const List<T>&,MEM_ROOT*) [with T = Alter_drop,MEM_ROOT = st_mem_root]" -> "base_list::base_list(const base_list&,MEM_ROOT*)"
"base_list::base_list(const base_list&,MEM_ROOT*)" -> "alloc_root(MEM_ROOT*,size_t)"
"base_list::base_list(const base_list&,MEM_ROOT*)" -> "Sql_alloc::Sql_alloc()"
"List<T>::List(const List<T>&,MEM_ROOT*) [with T = Alter_column,MEM_ROOT = st_mem_root]" -> "base_list::base_list(const base_list&,MEM_ROOT*)"
"List<T>::List(const List<T>&,MEM_ROOT*) [with T = char,MEM_ROOT = st_mem_root]" -> "base_list::base_list(const base_list&,MEM_ROOT*)"
"List<T>::List(const List<T>&,MEM_ROOT*) [with T = Create_field,MEM_ROOT = st_mem_root]" -> "base_list::base_list(const base_list&,MEM_ROOT*)"
"list_copy_and_replace_each_value(List<T>&,MEM_ROOT*) [with T = Alter_drop,MEM_ROOT = st_mem_root]" -> "List_iterator<T>::List_iterator(List<T>&) [with T = Alter_drop]"
"list_copy_and_replace_each_value(List<T>&,MEM_ROOT*) [with T = Alter_drop,MEM_ROOT = st_mem_root]" -> "List_iterator<T>::operator++(int) [with T = Alter_drop]"
"list_copy_and_replace_each_value(List<T>&,MEM_ROOT*) [with T = Alter_drop,MEM_ROOT = st_mem_root]" -> "List_iterator<T>::replace(T*) [with T = Alter_drop]"
"list_copy_and_replace_each_value(List<T>&,MEM_ROOT*) [with T = Alter_drop,MEM_ROOT = st_mem_root]" -> "Alter_drop::clone(MEM_ROOT*) const"
"List_iterator<T>::replace(T*) [with T = Alter_drop]" -> "base_list_iterator::replace(void*)"
"list_copy_and_replace_each_value(List<T>&,MEM_ROOT*) [with T = Key,MEM_ROOT = st_mem_root]" -> "List_iterator<T>::List_iterator(List<T>&) [with T = Key]"
"list_copy_and_replace_each_value(List<T>&,MEM_ROOT*) [with T = Key,MEM_ROOT = st_mem_root]" -> "List_iterator<T>::operator++(int) [with T = Key]"
"list_copy_and_replace_each_value(List<T>&,MEM_ROOT*) [with T = Key,MEM_ROOT = st_mem_root]" -> "List_iterator<T>::replace(T*) [with T = Key]"
"List_iterator<T>::replace(T*) [with T = Key]" -> "base_list_iterator::replace(void*)"
"list_copy_and_replace_each_value(List<T>&,MEM_ROOT*) [with T = Alter_column,MEM_ROOT = st_mem_root]" -> "List_iterator<T>::replace(T*) [with T = Alter_column]"
"list_copy_and_replace_each_value(List<T>&,MEM_ROOT*) [with T = Alter_column,MEM_ROOT = st_mem_root]" -> "List_iterator<T>::operator++(int) [with T = Alter_column]"
"list_copy_and_replace_each_value(List<T>&,MEM_ROOT*) [with T = Alter_column,MEM_ROOT = st_mem_root]" -> "Alter_column::clone(MEM_ROOT*) const"
"list_copy_and_replace_each_value(List<T>&,MEM_ROOT*) [with T = Alter_column,MEM_ROOT = st_mem_root]" -> "List_iterator<T>::List_iterator(List<T>&) [with T = Alter_column]"
"List_iterator<T>::replace(T*) [with T = Alter_column]" -> "base_list_iterator::replace(void*)"
"list_copy_and_replace_each_value(List<T>&,MEM_ROOT*) [with T = Create_field,MEM_ROOT = st_mem_root]" -> "List_iterator<T>::operator++(int) [with T = Create_field]"
"list_copy_and_replace_each_value(List<T>&,MEM_ROOT*) [with T = Create_field,MEM_ROOT = st_mem_root]" -> "Create_field::clone(MEM_ROOT*) const"
"list_copy_and_replace_each_value(List<T>&,MEM_ROOT*) [with T = Create_field,MEM_ROOT = st_mem_root]" -> "List_iterator<T>::replace(T*) [with T = Create_field]"
"list_copy_and_replace_each_value(List<T>&,MEM_ROOT*) [with T = Create_field,MEM_ROOT = st_mem_root]" -> "List_iterator<T>::List_iterator(List<T>&) [with T = Create_field]"
"Create_field::clone(MEM_ROOT*) const" -> "Create_field::Create_field(const Create_field&)"
"Create_field::Create_field(const Create_field&)" -> "List<T>::List(const List<T>&) [with T = String]"
"List<T>::List(const List<T>&) [with T = String]" -> "base_list::base_list(const base_list&)"
"List<T>::List(const List<T>&,MEM_ROOT*) [with T = Key,MEM_ROOT = st_mem_root]" -> "base_list::base_list(const base_list&,MEM_ROOT*)"
"sp_find_routine(THD*,enum_sp_type,sp_name*,sp_cache**,bool)" -> "recursion_level_error(THD*,sp_head*)"
"sp_find_routine(THD*,enum_sp_type,sp_name*,sp_cache**,bool)" -> "db_find_routine(THD*,enum_sp_type,sp_name*,sp_head**)"
"sp_find_routine(THD*,enum_sp_type,sp_name*,sp_cache**,bool)" -> "sp_returns_type(THD*,String&,sp_head*)"
"sp_find_routine(THD*,enum_sp_type,sp_name*,sp_cache**,bool)" -> "String::String(uint32)"
"sp_find_routine(THD*,enum_sp_type,sp_name*,sp_cache**,bool)" -> "Default_object_creation_ctx::get_client_cs()"
"sp_find_routine(THD*,enum_sp_type,sp_name*,sp_cache**,bool)" -> "strxmov(char*,const char*,...)"
"sp_find_routine(THD*,enum_sp_type,sp_name*,sp_cache**,bool)" -> "sp_cache_lookup(sp_cache**,sp_name*)"
"sp_find_routine(THD*,enum_sp_type,sp_name*,sp_cache**,bool)" -> "String::ptr() const"
"sp_find_routine(THD*,enum_sp_type,sp_name*,sp_cache**,bool)" -> "db_load_routine(THD*,enum_sp_type,sp_name*,sp_head**,sql_mode_t,const char*,const char*,const char*,st_sp_chistics&,const char*,longlong,longlong,Stored_program_creation_ctx*)"
"sp_find_routine(THD*,enum_sp_type,sp_name*,sp_cache**,bool)" -> "sp_cache_insert(sp_cache**,sp_head*)"
"sp_find_routine(THD*,enum_sp_type,sp_name*,sp_cache**,bool)" -> "String::set_charset(const CHARSET_INFO*)"
"sp_find_routine(THD*,enum_sp_type,sp_name*,sp_cache**,bool)" -> "sp_head::get_creation_ctx()"
"recursion_level_error(THD*,sp_head*)" -> "my_error(int,myf,...)"
"sp_show_create_routine(THD*,enum_sp_type,sp_name*)" -> "sp_cache_routine(THD*,enum_sp_type,sp_name*,bool,sp_head**)"
"sp_show_create_routine(THD*,enum_sp_type,sp_name*)" -> "my_error(int,myf,...)"
"sp_show_create_routine(THD*,enum_sp_type,sp_name*)" -> "sp_head::show_create_routine(THD*,enum_sp_type)"
"sp_head::show_create_routine(THD*,enum_sp_type)" -> "std::max(const _Tp&,const _Tp&) [with _Tp = long unsigned int]"
"sp_head::show_create_routine(THD*,enum_sp_type)" -> "sp_head::check_show_access(THD*,bool*)"
"sp_head::show_create_routine(THD*,enum_sp_type)" -> "List<T>::push_back(T*) [with T = Item]"
"sp_head::show_create_routine(THD*,enum_sp_type)" -> "my_eof(THD*)"
"sp_head::show_create_routine(THD*,enum_sp_type)" -> "sql_mode_string_representation(THD*,sql_mode_t,LEX_STRING*)"
"sp_head::show_create_routine(THD*,enum_sp_type)" -> "Default_object_creation_ctx::get_connection_cl()"
"sp_head::show_create_routine(THD*,enum_sp_type)" -> "Protocol::store(const char*,const CHARSET_INFO*)"
"sp_head::show_create_routine(THD*,enum_sp_type)" -> "List<T>::List() [with T = Item]"
"sp_head::show_create_routine(THD*,enum_sp_type)" -> "Item_empty_string::Item_empty_string(const char*,uint,const CHARSET_INFO*)"
"sp_head::show_create_routine(THD*,enum_sp_type)" -> "Default_object_creation_ctx::get_client_cs()"
"sp_head::show_create_routine(THD*,enum_sp_type)" -> "Stored_program_creation_ctx::get_db_cl()"
"sp_head::check_show_access(THD*,bool*)" -> "memset(void*,int,size_t)"
"sp_head::check_show_access(THD*,bool*)" -> "TABLE_LIST::TABLE_LIST()"
"sp_head::check_show_access(THD*,bool*)" -> "strcmp(const char*,const char*)"
"sp_head::check_show_access(THD*,bool*)" -> "check_some_routine_access(THD*,const char*,const char*,bool)"
"sp_head::check_show_access(THD*,bool*)" -> "check_table_access(THD*,ulong,TABLE_LIST*,bool,uint,bool)"
"sql_mode_string_representation(THD*,sql_mode_t,LEX_STRING*)" -> "set_to_string(THD*,LEX_STRING*,ulonglong,const char**)"
"set_to_string(THD*,LEX_STRING*,ulonglong,const char**)" -> "String::length() const"
"set_to_string(THD*,LEX_STRING*,ulonglong,const char**)" -> "String::String(char*,uint32,const CHARSET_INFO*)"
"set_to_string(THD*,LEX_STRING*,ulonglong,const char**)" -> "String::append(char)"
"set_to_string(THD*,LEX_STRING*,ulonglong,const char**)" -> "String::length(uint32)"
"set_to_string(THD*,LEX_STRING*,ulonglong,const char**)" -> "Query_arena::strmake(const char*,size_t)"
"set_to_string(THD*,LEX_STRING*,ulonglong,const char**)" -> "String::ptr() const"
"set_to_string(THD*,LEX_STRING*,ulonglong,const char**)" -> "String::append(const char*)"
"mysql_preload_keys(THD*,TABLE_LIST*)" -> "mysql_admin_table(THD*,TABLE_LIST*,HA_CHECK_OPT*,const char*,thr_lock_type,bool,bool,uint,int (*)(THD*,TABLE_LIST*,HA_CHECK_OPT*),int (handler::*)(THD*,HA_CHECK_OPT*),int (*)(THD*,TABLE_LIST*))"
"mysql_insert(THD*,TABLE_LIST*,List<Item>&,List<List<Item> >&,List<Item>&,List<Item>&,enum_duplicates,bool)" -> "create_insert_stmt_from_insert_delayed(THD*,String*)"
"mysql_insert(THD*,TABLE_LIST*,List<Item>&,List<List<Item> >&,List<Item>&,List<Item>&,enum_duplicates,bool)" -> "Diagnostics_area::current_statement_warn_count() const"
"mysql_insert(THD*,TABLE_LIST*,List<Item>&,List<List<Item> >&,List<Item>&,List<Item>&,enum_duplicates,bool)" -> "String::length() const"
"mysql_insert(THD*,TABLE_LIST*,List<Item>&,List<List<Item> >&,List<Item>&,List<Item>&,enum_duplicates,bool)" -> "List<T>::head() [with T = List<Item>]"
"mysql_insert(THD*,TABLE_LIST*,List<Item>&,List<List<Item> >&,List<Item>&,List<Item>&,enum_duplicates,bool)" -> "THD_TRANS::cannot_safely_rollback() const"
"mysql_insert(THD*,TABLE_LIST*,List<Item>&,List<List<Item> >&,List<Item>&,List<Item>&,enum_duplicates,bool)" -> "free_underlaid_joins(THD*,SELECT_LEX*)"
"mysql_insert(THD*,TABLE_LIST*,List<Item>&,List<List<Item> >&,List<Item>&,List<Item>&,enum_duplicates,bool)" -> "THD::get_stmt_da()"
"mysql_insert(THD*,TABLE_LIST*,List<Item>&,List<List<Item> >&,List<Item>&,List<Item>&,enum_duplicates,bool)" -> "lock_tables(THD*,TABLE_LIST*,uint,uint)"
"mysql_insert(THD*,TABLE_LIST*,List<Item>&,List<List<Item> >&,List<Item>&,List<Item>&,enum_duplicates,bool)" -> "TABLE_LIST::prepare_where(THD*,Item**,bool)"
"mysql_insert(THD*,TABLE_LIST*,List<Item>&,List<List<Item> >&,List<Item>&,List<Item>&,enum_duplicates,bool)" -> "my_error(int,myf,...)"
"mysql_insert(THD*,TABLE_LIST*,List<Item>&,List<List<Item> >&,List<Item>&,List<Item>&,enum_duplicates,bool)" -> "open_and_lock_for_insert_delayed(THD*,TABLE_LIST*)"
"mysql_insert(THD*,TABLE_LIST*,List<Item>&,List<List<Item> >&,List<Item>&,List<Item>&,enum_duplicates,bool)" -> "fill_record_n_invoke_before_triggers(THD*,List<Item>&,List<Item>&,bool,Table_triggers_list*,trg_event_type)"
"mysql_insert(THD*,TABLE_LIST*,List<Item>&,List<List<Item> >&,List<Item>&,List<Item>&,enum_duplicates,bool)" -> "sql_print_error(const char*,...)"
"mysql_insert(THD*,TABLE_LIST*,List<Item>&,List<List<Item> >&,List<Item>&,List<Item>&,enum_duplicates,bool)" -> "bitmap_intersect(MY_BITMAP*,const MY_BITMAP*)"
"mysql_insert(THD*,TABLE_LIST*,List<Item>&,List<List<Item> >&,List<Item>&,List<Item>&,enum_duplicates,bool)" -> "handler::has_transactions()"
"mysql_insert(THD*,TABLE_LIST*,List<Item>&,List<List<Item> >&,List<Item>&,List<Item>&,enum_duplicates,bool)" -> "explain_no_table(THD*,const char*,ha_rows)"
"mysql_insert(THD*,TABLE_LIST*,List<Item>&,List<List<Item> >&,List<Item>&,List<Item>&,enum_duplicates,bool)" -> "Query_cache::invalidate(THD*,TABLE_LIST*,my_bool)"
"mysql_insert(THD*,TABLE_LIST*,List<Item>&,List<List<Item> >&,List<Item>&,List<Item>&,enum_duplicates,bool)" -> "_current_thd()"
"mysql_insert(THD*,TABLE_LIST*,List<Item>&,List<List<Item> >&,List<Item>&,List<Item>&,enum_duplicates,bool)" -> "my_ok(THD*,ulonglong,ulonglong,const char*)"
"mysql_insert(THD*,TABLE_LIST*,List<Item>&,List<List<Item> >&,List<Item>&,List<Item>&,enum_duplicates,bool)" -> "THD::clear_error()"
"mysql_insert(THD*,TABLE_LIST*,List<Item>&,List<List<Item> >&,List<Item>&,List<Item>&,enum_duplicates,bool)" -> "List_iterator_fast<T>::List_iterator_fast(List<T>&) [with T = List<Item>]"
"mysql_insert(THD*,TABLE_LIST*,List<Item>&,List<List<Item> >&,List<Item>&,List<Item>&,enum_duplicates,bool)" -> "COPY_INFO::COPY_INFO(COPY_INFO::operation_type,List<Item>*,List<Item>*)"
"mysql_insert(THD*,TABLE_LIST*,List<Item>&,List<List<Item> >&,List<Item>&,List<Item>&,enum_duplicates,bool)" -> "find_locked_table(TABLE*,const char*,const char*)"
"mysql_insert(THD*,TABLE_LIST*,List<Item>&,List<List<Item> >&,List<Item>&,List<Item>&,enum_duplicates,bool)" -> "bitmap_is_set_all(const MY_BITMAP*)"
"mysql_insert(THD*,TABLE_LIST*,List<Item>&,List<List<Item> >&,List<Item>&,List<Item>&,enum_duplicates,bool)" -> "COPY_INFO::COPY_INFO(COPY_INFO::operation_type,List<Item>*,bool,enum_duplicates,bool)"
"mysql_insert(THD*,TABLE_LIST*,List<Item>&,List<List<Item> >&,List<Item>&,List<Item>&,enum_duplicates,bool)" -> "MYSQL_LOG::is_open()"
"mysql_insert(THD*,TABLE_LIST*,List<Item>&,List<List<Item> >&,List<Item>&,List<Item>&,enum_duplicates,bool)" -> "_my_thread_var()"
"mysql_insert(THD*,TABLE_LIST*,List<Item>&,List<List<Item> >&,List<Item>&,List<Item>&,enum_duplicates,bool)" -> "Name_resolution_context::resolve_in_table_list_only(TABLE_LIST*)"
"mysql_insert(THD*,TABLE_LIST*,List<Item>&,List<List<Item> >&,List<Item>&,List<Item>&,enum_duplicates,bool)" -> "String::c_ptr()"
"mysql_insert(THD*,TABLE_LIST*,List<Item>&,List<List<Item> >&,List<Item>&,List<Item>&,enum_duplicates,bool)" -> "Name_resolution_context_state::save_state(Name_resolution_context*,TABLE_LIST*)"
"mysql_insert(THD*,TABLE_LIST*,List<Item>&,List<List<Item> >&,List<Item>&,List<Item>&,enum_duplicates,bool)" -> "partition_info::set_used_partition(List<Item>&,List<Item>&,COPY_INFO&,bool,MY_BITMAP*)"
"mysql_insert(THD*,TABLE_LIST*,List<Item>&,List<List<Item> >&,List<Item>&,List<Item>&,enum_duplicates,bool)" -> "prepare_triggers_for_insert_stmt(TABLE*)"
"mysql_insert(THD*,TABLE_LIST*,List<Item>&,List<List<Item> >&,List<Item>&,List<Item>&,enum_duplicates,bool)" -> "THD::binlog_query(THD::enum_binlog_query_type,const char*,ulong,bool,bool,bool,int)"
"mysql_insert(THD*,TABLE_LIST*,List<Item>&,List<List<Item> >&,List<Item>&,List<Item>&,enum_duplicates,bool)" -> "THD::is_strict_mode() const"
"mysql_insert(THD*,TABLE_LIST*,List<Item>&,List<List<Item> >&,List<Item>&,List<Item>&,enum_duplicates,bool)" -> "String::String()"
"mysql_insert(THD*,TABLE_LIST*,List<Item>&,List<List<Item> >&,List<Item>&,List<Item>&,enum_duplicates,bool)" -> "fill_record_n_invoke_before_triggers(THD*,Field**,List<Item>&,bool,Table_triggers_list*,trg_event_type)"
"mysql_insert(THD*,TABLE_LIST*,List<Item>&,List<List<Item> >&,List<Item>&,List<Item>&,enum_duplicates,bool)" -> "List_iterator_fast<T>::rewind() [with T = List<Item>]"
"mysql_insert(THD*,TABLE_LIST*,List<Item>&,List<List<Item> >&,List<Item>&,List<Item>&,enum_duplicates,bool)" -> "query_error_code(THD*,bool)"
"mysql_insert(THD*,TABLE_LIST*,List<Item>&,List<List<Item> >&,List<Item>&,List<Item>&,enum_duplicates,bool)" -> "handler::ha_release_auto_increment()"
"mysql_insert(THD*,TABLE_LIST*,List<Item>&,List<List<Item> >&,List<Item>&,List<Item>&,enum_duplicates,bool)" -> "THD::enter_stage(const PSI_stage_info*,PSI_stage_info*,const char*,const char*,unsigned int)"
"mysql_insert(THD*,TABLE_LIST*,List<Item>&,List<List<Item> >&,List<Item>&,List<Item>&,enum_duplicates,bool)" -> "memcpy(void*,const void*,size_t)"
"mysql_insert(THD*,TABLE_LIST*,List<Item>&,List<List<Item> >&,List<Item>&,List<Item>&,enum_duplicates,bool)" -> "Table_triggers_list::has_delete_triggers()"
"mysql_insert(THD*,TABLE_LIST*,List<Item>&,List<List<Item> >&,List<Item>&,List<Item>&,enum_duplicates,bool)" -> "Statement::query_length() const"
"mysql_insert(THD*,TABLE_LIST*,List<Item>&,List<List<Item> >&,List<Item>&,List<Item>&,enum_duplicates,bool)" -> "Name_resolution_context_state::restore_state(Name_resolution_context*,TABLE_LIST*)"
"mysql_insert(THD*,TABLE_LIST*,List<Item>&,List<List<Item> >&,List<Item>&,List<Item>&,enum_duplicates,bool)" -> "Statement::query() const"
"mysql_insert(THD*,TABLE_LIST*,List<Item>&,List<List<Item> >&,List<Item>&,List<Item>&,enum_duplicates,bool)" -> "write_record(THD*,TABLE*,COPY_INFO*,COPY_INFO*)"
"mysql_insert(THD*,TABLE_LIST*,List<Item>&,List<List<Item> >&,List<Item>&,List<Item>&,enum_duplicates,bool)" -> "Diagnostics_area::inc_current_row_for_warning()"
"mysql_insert(THD*,TABLE_LIST*,List<Item>&,List<List<Item> >&,List<Item>&,List<Item>&,enum_duplicates,bool)" -> "TABLE_LIST::prepare_check_option(THD*)"
"mysql_insert(THD*,TABLE_LIST*,List<Item>&,List<List<Item> >&,List<Item>&,List<Item>&,enum_duplicates,bool)" -> "THD::is_error() const"
"mysql_insert(THD*,TABLE_LIST*,List<Item>&,List<List<Item> >&,List<Item>&,List<Item>&,enum_duplicates,bool)" -> "mysql_prepare_insert(THD*,TABLE_LIST*,TABLE*,List<Item>&,List_item*,List<Item>&,List<Item>&,enum_duplicates,Item**,bool,bool,bool)"
"mysql_insert(THD*,TABLE_LIST*,List<Item>&,List<List<Item> >&,List<Item>&,List<Item>&,enum_duplicates,bool)" -> "TABLE_LIST::view_check_option(THD*,bool) const"
"mysql_insert(THD*,TABLE_LIST*,List<Item>&,List<List<Item> >&,List<Item>&,List<Item>&,enum_duplicates,bool)" -> "open_normal_and_derived_tables(THD*,TABLE_LIST*,uint)"
"mysql_insert(THD*,TABLE_LIST*,List<Item>&,List<List<Item> >&,List<Item>&,List<Item>&,enum_duplicates,bool)" -> "validate_default_values_of_unset_fields(THD*,TABLE*)"
"mysql_insert(THD*,TABLE_LIST*,List<Item>&,List<List<Item> >&,List<Item>&,List<Item>&,enum_duplicates,bool)" -> "handler::ha_start_bulk_insert(ha_rows)"
"mysql_insert(THD*,TABLE_LIST*,List<Item>&,List<List<Item> >&,List<Item>&,List<Item>&,enum_duplicates,bool)" -> "upgrade_lock_type(THD*,thr_lock_type*,enum_duplicates)"
"mysql_insert(THD*,TABLE_LIST*,List<Item>&,List<List<Item> >&,List<Item>&,List<Item>&,enum_duplicates,bool)" -> "partition_info::can_prune_insert(THD*,enum_duplicates,COPY_INFO&,List<Item>&,List<Item>&,bool,partition_info::enum_can_prune*,bool*,MY_BITMAP*)"
"mysql_insert(THD*,TABLE_LIST*,List<Item>&,List<List<Item> >&,List<Item>&,List<Item>&,enum_duplicates,bool)" -> "my_snprintf(char*,size_t,const char*,...)"
"mysql_insert(THD*,TABLE_LIST*,List<Item>&,List<List<Item> >&,List<Item>&,List<Item>&,enum_duplicates,bool)" -> "List_iterator_fast<T>::operator++(int) [with T = List<Item>]"
"mysql_insert(THD*,TABLE_LIST*,List<Item>&,List<List<Item> >&,List<Item>&,List<Item>&,enum_duplicates,bool)" -> "handler::ha_end_bulk_insert()"
"mysql_insert(THD*,TABLE_LIST*,List<Item>&,List<List<Item> >&,List<Item>&,List<Item>&,enum_duplicates,bool)" -> "Bounds_checked_array<Element_type>::Bounds_checked_array() [with Element_type = Item*]"
"mysql_insert(THD*,TABLE_LIST*,List<Item>&,List<List<Item> >&,List<Item>&,List<Item>&,enum_duplicates,bool)" -> "setup_fields(THD*,Ref_ptr_array,List<Item>&,enum_mark_columns,List<Item>*,bool)"
"mysql_insert(THD*,TABLE_LIST*,List<Item>&,List<List<Item> >&,List<Item>&,List<Item>&,enum_duplicates,bool)" -> "Name_resolution_context_state::Name_resolution_context_state()"
"mysql_insert(THD*,TABLE_LIST*,List<Item>&,List<List<Item> >&,List<Item>&,List<Item>&,enum_duplicates,bool)" -> "COPY_INFO::add_function_default_columns(TABLE*,MY_BITMAP*)"
"create_insert_stmt_from_insert_delayed(THD*,String*)" -> "String::replace(uint32,uint32,const String&)"
"create_insert_stmt_from_insert_delayed(THD*,String*)" -> "Statement::query() const"
"create_insert_stmt_from_insert_delayed(THD*,String*)" -> "String::append(const char*)"
"create_insert_stmt_from_insert_delayed(THD*,String*)" -> "String::String(uint32)"
"String::replace(uint32,uint32,const String&)" -> "String::ptr() const"
"String::replace(uint32,uint32,const String&)" -> "String::length() const"
"String::replace(uint32,uint32,const String&)" -> "String::replace(uint32,uint32,const char*,uint32)"
"List<T>::head() [with T = List<Item>]" -> "base_list::head()"
"open_and_lock_for_insert_delayed(THD*,TABLE_LIST*)" -> "MDL_request::MDL_request()"
"open_and_lock_for_insert_delayed(THD*,TABLE_LIST*)" -> "open_and_lock_tables(THD*,TABLE_LIST*,bool,uint)"
"explain_no_table(THD*,const char*,ha_rows)" -> "Explain::send()"
"explain_no_table(THD*,const char*,ha_rows)" -> "Explain_no_table::Explain_no_table(THD*,const char*,ha_rows)"
"Explain_no_table::Explain_no_table(THD*,const char*,ha_rows)" -> "Explain::Explain(Explain_context_enum,THD*,JOIN*)"
"partition_info::set_used_partition(List<Item>&,List<Item>&,COPY_INFO&,bool,MY_BITMAP*)" -> "Dummy_error_handler::Dummy_error_handler()"
"partition_info::set_used_partition(List<Item>&,List<Item>&,COPY_INFO&,bool,MY_BITMAP*)" -> "bitmap_set_bit(MY_BITMAP*,uint)"
"partition_info::set_used_partition(List<Item>&,List<Item>&,COPY_INFO&,bool,MY_BITMAP*)" -> "THD::pop_internal_handler()"
"partition_info::set_used_partition(List<Item>&,List<Item>&,COPY_INFO&,bool,MY_BITMAP*)" -> "fill_record(THD*,List<Item>&,List<Item>&,bool,MY_BITMAP*)"
"partition_info::set_used_partition(List<Item>&,List<Item>&,COPY_INFO&,bool,MY_BITMAP*)" -> "List_iterator_fast<T>::List_iterator_fast(List<T>&) [with T = Item]"
"partition_info::set_used_partition(List<Item>&,List<Item>&,COPY_INFO&,bool,MY_BITMAP*)" -> "List_iterator_fast<T>::operator++(int) [with T = Item]"
"partition_info::set_used_partition(List<Item>&,List<Item>&,COPY_INFO&,bool,MY_BITMAP*)" -> "fill_record(THD*,Field**,List<Item>&,bool,MY_BITMAP*)"
"partition_info::set_used_partition(List<Item>&,List<Item>&,COPY_INFO&,bool,MY_BITMAP*)" -> "THD::push_internal_handler(Internal_error_handler*)"
"partition_info::set_used_partition(List<Item>&,List<Item>&,COPY_INFO&,bool,MY_BITMAP*)" -> "dbug_tmp_use_all_columns(TABLE*,MY_BITMAP*)"
"partition_info::set_used_partition(List<Item>&,List<Item>&,COPY_INFO&,bool,MY_BITMAP*)" -> "memcpy(void*,const void*,size_t)"
"partition_info::set_used_partition(List<Item>&,List<Item>&,COPY_INFO&,bool,MY_BITMAP*)" -> "dbug_tmp_restore_column_map(MY_BITMAP*,my_bitmap_map*)"
"partition_info::set_used_partition(List<Item>&,List<Item>&,COPY_INFO&,bool,MY_BITMAP*)" -> "COPY_INFO::function_defaults_apply_on_columns(MY_BITMAP*)"
"Dummy_error_handler::Dummy_error_handler()" -> "Internal_error_handler::Internal_error_handler()"
"fill_record(THD*,Field**,List<Item>&,bool,MY_BITMAP*)" -> "THD::is_error() const"
"fill_record(THD*,Field**,List<Item>&,bool,MY_BITMAP*)" -> "bitmap_is_set(const MY_BITMAP*,uint)"
"fill_record(THD*,Field**,List<Item>&,bool,MY_BITMAP*)" -> "List_iterator_fast<T>::List_iterator_fast(List<T>&) [with T = Item]"
"fill_record(THD*,Field**,List<Item>&,bool,MY_BITMAP*)" -> "List_iterator_fast<T>::operator++(int) [with T = Item]"
"COPY_INFO::function_defaults_apply_on_columns(MY_BITMAP*)" -> "bitmap_is_overlapping(const MY_BITMAP*,const MY_BITMAP*)"
"fill_record_n_invoke_before_triggers(THD*,Field**,List<Item>&,bool,Table_triggers_list*,trg_event_type)" -> "fill_record(THD*,Field**,List<Item>&,bool,MY_BITMAP*)"
"fill_record_n_invoke_before_triggers(THD*,Field**,List<Item>&,bool,Table_triggers_list*,trg_event_type)" -> "Table_triggers_list::process_triggers(THD*,trg_event_type,trg_action_time_type,bool)"
"upgrade_lock_type(THD*,thr_lock_type*,enum_duplicates)" -> "Query_tables_list::uses_stored_routines() const"
"upgrade_lock_type(THD*,thr_lock_type*,enum_duplicates)" -> "MYSQL_LOG::is_open()"
"partition_info::can_prune_insert(THD*,enum_duplicates,COPY_INFO&,List<Item>&,List<Item>&,bool,partition_info::enum_can_prune*,bool*,MY_BITMAP*)" -> "bitmap_is_set(const MY_BITMAP*,uint)"
"partition_info::can_prune_insert(THD*,enum_duplicates,COPY_INFO&,List<Item>&,List<Item>&,bool,partition_info::enum_can_prune*,bool*,MY_BITMAP*)" -> "Table_triggers_list::has_triggers(trg_event_type,trg_action_time_type)"
"partition_info::can_prune_insert(THD*,enum_duplicates,COPY_INFO&,List<Item>&,List<Item>&,bool,partition_info::enum_can_prune*,bool*,MY_BITMAP*)" -> "Query_arena::alloc(size_t)"
"partition_info::can_prune_insert(THD*,enum_duplicates,COPY_INFO&,List<Item>&,List<Item>&,bool,partition_info::enum_can_prune*,bool*,MY_BITMAP*)" -> "mem_alloc_error(size_t)"
"partition_info::can_prune_insert(THD*,enum_duplicates,COPY_INFO&,List<Item>&,List<Item>&,bool,partition_info::enum_can_prune*,bool*,MY_BITMAP*)" -> "partition_info::is_full_part_expr_in_fields(List<Item>&)"
"partition_info::can_prune_insert(THD*,enum_duplicates,COPY_INFO&,List<Item>&,List<Item>&,bool,partition_info::enum_can_prune*,bool*,MY_BITMAP*)" -> "TABLE_SHARE::db_type() const"
"partition_info::can_prune_insert(THD*,enum_duplicates,COPY_INFO&,List<Item>&,List<Item>&,bool,partition_info::enum_can_prune*,bool*,MY_BITMAP*)" -> "COPY_INFO::function_defaults_apply_on_columns(MY_BITMAP*)"
"partition_info::can_prune_insert(THD*,enum_duplicates,COPY_INFO&,List<Item>&,List<Item>&,bool,partition_info::enum_can_prune*,bool*,MY_BITMAP*)" -> "partition_info::is_field_in_part_expr(List<Item>&)"
"partition_info::can_prune_insert(THD*,enum_duplicates,COPY_INFO&,List<Item>&,List<Item>&,bool,partition_info::enum_can_prune*,bool*,MY_BITMAP*)" -> "Table_triggers_list::is_fields_updated_in_trigger(MY_BITMAP*,trg_event_type,trg_action_time_type)"
"partition_info::can_prune_insert(THD*,enum_duplicates,COPY_INFO&,List<Item>&,List<Item>&,bool,partition_info::enum_can_prune*,bool*,MY_BITMAP*)" -> "bitmap_init(MY_BITMAP*,my_bitmap_map*,uint,my_bool)"
"partition_info::is_full_part_expr_in_fields(List<Item>&)" -> "List_iterator<T>::operator++(int) [with T = Item]"
"partition_info::is_full_part_expr_in_fields(List<Item>&)" -> "List_iterator<T>::List_iterator(List<T>&) [with T = Item]"
"partition_info::is_field_in_part_expr(List<Item>&)" -> "bitmap_is_set(const MY_BITMAP*,uint)"
"partition_info::is_field_in_part_expr(List<Item>&)" -> "List_iterator<T>::List_iterator(List<T>&) [with T = Item]"
"partition_info::is_field_in_part_expr(List<Item>&)" -> "List_iterator<T>::operator++(int) [with T = Item]"
"Table_triggers_list::is_fields_updated_in_trigger(MY_BITMAP*,trg_event_type,trg_action_time_type)" -> "bitmap_is_set(const MY_BITMAP*,uint)"
"trans_begin(THD*,uint)" -> "trans_check_state(THD*)"
"trans_begin(THD*,uint)" -> "ha_commit_trans(THD*,bool,bool)"
"trans_begin(THD*,uint)" -> "my_error(int,myf,...)"
"trans_begin(THD*,uint)" -> "THD_TRANS::reset_unsafe_rollback_flags()"
"trans_begin(THD*,uint)" -> "Locked_tables_list::unlock_locked_tables(THD*)"
"trans_begin(THD*,uint)" -> "MDL_context::release_transactional_locks()"
"trans_begin(THD*,uint)" -> "ha_start_consistent_snapshot(THD*)"
"trans_begin(THD*,uint)" -> "THD::in_multi_stmt_transaction_mode() const"
"ha_start_consistent_snapshot(THD*)" -> "plugin_foreach_with_mask(THD*,my_bool (*)(THD*,plugin_ref,void*),int,uint,void*)"
"ha_start_consistent_snapshot(THD*)" -> "push_warning(THD*,Sql_condition::enum_warning_level,uint,const char*)"
"PROFILING::show_profiles()" -> "strlen(const char*)"
"PROFILING::show_profiles()" -> "String::String()"
"PROFILING::show_profiles()" -> "Queue<T>::iterator_next(void*) [with T = QUERY_PROFILE]"
"PROFILING::show_profiles()" -> "List<T>::push_back(T*) [with T = Item]"
"PROFILING::show_profiles()" -> "Protocol::store(uint32)"
"PROFILING::show_profiles()" -> "Queue<T>::new_iterator() [with T = QUERY_PROFILE]"
"PROFILING::show_profiles()" -> "Queue<T>::iterator_value(void*) [with T = QUERY_PROFILE]"
"PROFILING::show_profiles()" -> "List<T>::List() [with T = Item]"
"PROFILING::show_profiles()" -> "Item_empty_string::Item_empty_string(const char*,uint,const CHARSET_INFO*)"
"PROFILING::show_profiles()" -> "Item_return_int::Item_return_int(const char*,uint,enum_field_types,longlong)"
"PROFILING::show_profiles()" -> "my_eof(THD*)"
"PROFILING::show_profiles()" -> "st_select_lex_unit::set_limit(st_select_lex*)"
"trans_rollback_to_savepoint(THD*,LEX_STRING)" -> "find_savepoint(THD*,LEX_STRING)"
"trans_rollback_to_savepoint(THD*,LEX_STRING)" -> "MDL_context::rollback_to_savepoint(const MDL_savepoint&)"
"trans_rollback_to_savepoint(THD*,LEX_STRING)" -> "ha_rollback_to_savepoint(THD*,SAVEPOINT*)"
"trans_rollback_to_savepoint(THD*,LEX_STRING)" -> "THD_TRANS::cannot_safely_rollback() const"
"trans_rollback_to_savepoint(THD*,LEX_STRING)" -> "my_error(int,myf,...)"
"trans_rollback_to_savepoint(THD*,LEX_STRING)" -> "MYSQL_LOG::is_open()"
"trans_rollback_to_savepoint(THD*,LEX_STRING)" -> "THD::st_transactions::push_unsafe_rollback_warnings(THD*)"
"trans_rollback_to_savepoint(THD*,LEX_STRING)" -> "ha_rollback_to_savepoint_can_release_mdl(THD*)"
"ha_rollback_to_savepoint(THD*,SAVEPOINT*)" -> "Ha_trx_info::next() const"
"ha_rollback_to_savepoint(THD*,SAVEPOINT*)" -> "Ha_trx_info::ht() const"
"ha_rollback_to_savepoint(THD*,SAVEPOINT*)" -> "Ha_trx_info::reset()"
"ha_rollback_to_savepoint(THD*,SAVEPOINT*)" -> "my_error(int,myf,...)"
"ha_rollback_to_savepoint_can_release_mdl(THD*)" -> "Ha_trx_info::ht() const"
"ha_rollback_to_savepoint_can_release_mdl(THD*)" -> "Ha_trx_info::next() const"
"mysql_drop_function(THD*,const LEX_STRING*)" -> "Statement::query() const"
"mysql_drop_function(THD*,const LEX_STRING*)" -> "handler::ha_index_read_idx_map(uchar*,uint,const uchar*,key_part_map,ha_rkey_function)"
"mysql_drop_function(THD*,const LEX_STRING*)" -> "inline_mysql_rwlock_unlock(mysql_rwlock_t*)"
"mysql_drop_function(THD*,const LEX_STRING*)" -> "find_udf_dl(const char*)"
"mysql_drop_function(THD*,const LEX_STRING*)" -> "Statement::query_length() const"
"mysql_drop_function(THD*,const LEX_STRING*)" -> "my_hash_search(const HASH*,const uchar*,size_t)"
"mysql_drop_function(THD*,const LEX_STRING*)" -> "my_error(int,myf,...)"
"mysql_drop_function(THD*,const LEX_STRING*)" -> "handler::ha_delete_row(const uchar*)"
"mysql_drop_function(THD*,const LEX_STRING*)" -> "THD::clear_current_stmt_binlog_format_row()"
"mysql_drop_function(THD*,const LEX_STRING*)" -> "inline_mysql_rwlock_wrlock(mysql_rwlock_t*)"
"mysql_drop_function(THD*,const LEX_STRING*)" -> "my_message(uint,const char*,myf)"
"mysql_drop_function(THD*,const LEX_STRING*)" -> "del_udf(udf_func*)"
"mysql_drop_function(THD*,const LEX_STRING*)" -> "TABLE::use_all_columns()"
"mysql_drop_function(THD*,const LEX_STRING*)" -> "write_bin_log(THD*,bool,const char*,ulong,bool)"
"mysql_drop_function(THD*,const LEX_STRING*)" -> "THD::is_current_stmt_binlog_format_row() const"
"mysql_drop_function(THD*,const LEX_STRING*)" -> "TABLE_LIST::init_one_table(const char*,size_t,const char*,size_t,const char*,thr_lock_type)"
"mysql_drop_function(THD*,const LEX_STRING*)" -> "dlclose(void*)"
"mysql_drop_function(THD*,const LEX_STRING*)" -> "open_ltable(THD*,TABLE_LIST*,thr_lock_type,uint)"
"mysql_drop_function(THD*,const LEX_STRING*)" -> "_current_thd()"
"mysql_drop_function(THD*,const LEX_STRING*)" -> "TABLE_LIST::TABLE_LIST()"
"mysql_drop_function(THD*,const LEX_STRING*)" -> "THD::set_current_stmt_binlog_format_row()"
"find_udf_dl(const char*)" -> "my_hash_element(HASH*,ulong)"
"find_udf_dl(const char*)" -> "strcmp(const char*,const char*)"
"del_udf(udf_func*)" -> "my_hash_update(HASH*,uchar*,uchar*,size_t)"
"del_udf(udf_func*)" -> "my_hash_delete(HASH*,uchar*)"
"mysql_create_view(THD*,TABLE_LIST*,enum_view_create_mode)" -> "open_normal_and_derived_tables(THD*,TABLE_LIST*,uint)"
"mysql_create_view(THD*,TABLE_LIST*,enum_view_create_mode)" -> "open_temporary_tables(THD*,TABLE_LIST*)"
"mysql_create_view(THD*,TABLE_LIST*,enum_view_create_mode)" -> "THD::binlog_query(THD::enum_binlog_query_type,const char*,ulong,bool,bool,bool,int)"
"mysql_create_view(THD*,TABLE_LIST*,enum_view_create_mode)" -> "String::append(const char*)"
"mysql_create_view(THD*,TABLE_LIST*,enum_view_create_mode)" -> "my_error(int,myf,...)"
"mysql_create_view(THD*,TABLE_LIST*,enum_view_create_mode)" -> "List_iterator_fast<T>::List_iterator_fast(List<T>&) [with T = st_mysql_lex_string]"
"mysql_create_view(THD*,TABLE_LIST*,enum_view_create_mode)" -> "Query_cache::invalidate(THD*,TABLE_LIST*,my_bool)"
"mysql_create_view(THD*,TABLE_LIST*,enum_view_create_mode)" -> "THD::is_error() const"
"mysql_create_view(THD*,TABLE_LIST*,enum_view_create_mode)" -> "Item_name_string::copy(const char*,size_t,const CHARSET_INFO*,bool)"
"mysql_create_view(THD*,TABLE_LIST*,enum_view_create_mode)" -> "LEX::unlink_first_table(bool*)"
"mysql_create_view(THD*,TABLE_LIST*,enum_view_create_mode)" -> "THD::add_to_binlog_accessed_dbs(const char*)"
"mysql_create_view(THD*,TABLE_LIST*,enum_view_create_mode)" -> "view_store_options(THD*,TABLE_LIST*,String*)"
"mysql_create_view(THD*,TABLE_LIST*,enum_view_create_mode)" -> "String::append(char)"
"mysql_create_view(THD*,TABLE_LIST*,enum_view_create_mode)" -> "my_ok(THD*,ulonglong,ulonglong,const char*)"
"mysql_create_view(THD*,TABLE_LIST*,enum_view_create_mode)" -> "List_iterator_fast<T>::operator++(int) [with T = Item]"
"mysql_create_view(THD*,TABLE_LIST*,enum_view_create_mode)" -> "create_default_definer(THD*)"
"mysql_create_view(THD*,TABLE_LIST*,enum_view_create_mode)" -> "Prepared_stmt_arena_holder::Prepared_stmt_arena_holder(THD*,bool)"
"mysql_create_view(THD*,TABLE_LIST*,enum_view_create_mode)" -> "LEX::link_first_table_back(TABLE_LIST*,bool)"
"mysql_create_view(THD*,TABLE_LIST*,enum_view_create_mode)" -> "check_db_dir_existence(const char*)"
"mysql_create_view(THD*,TABLE_LIST*,enum_view_create_mode)" -> "String::String()"
"mysql_create_view(THD*,TABLE_LIST*,enum_view_create_mode)" -> "make_valid_column_names(LEX*)"
"mysql_create_view(THD*,TABLE_LIST*,enum_view_create_mode)" -> "sp_cache_invalidate()"
"mysql_create_view(THD*,TABLE_LIST*,enum_view_create_mode)" -> "String::append(const char*,uint32)"
"mysql_create_view(THD*,TABLE_LIST*,enum_view_create_mode)" -> "st_select_lex_unit::prepare(THD*,select_result*,ulong)"
"mysql_create_view(THD*,TABLE_LIST*,enum_view_create_mode)" -> "fill_defined_view_parts(THD*,TABLE_LIST*)"
"mysql_create_view(THD*,TABLE_LIST*,enum_view_create_mode)" -> "query_error_code(THD*,bool)"
"mysql_create_view(THD*,TABLE_LIST*,enum_view_create_mode)" -> "String::length() const"
"mysql_create_view(THD*,TABLE_LIST*,enum_view_create_mode)" -> "tdc_remove_table(THD*,enum_tdc_remove_table_type,const char*,const char*,bool)"
"mysql_create_view(THD*,TABLE_LIST*,enum_view_create_mode)" -> "List_iterator_fast<T>::List_iterator_fast(List<T>&) [with T = Item]"
"mysql_create_view(THD*,TABLE_LIST*,enum_view_create_mode)" -> "st_select_lex_unit::cleanup()"
"mysql_create_view(THD*,TABLE_LIST*,enum_view_create_mode)" -> "create_view_precheck(THD*,TABLE_LIST*,TABLE_LIST*,enum_view_create_mode)"
"mysql_create_view(THD*,TABLE_LIST*,enum_view_create_mode)" -> "append_identifier(THD*,String*,const char*,uint)"
"mysql_create_view(THD*,TABLE_LIST*,enum_view_create_mode)" -> "_current_thd()"
"mysql_create_view(THD*,TABLE_LIST*,enum_view_create_mode)" -> "String::ptr() const"
"mysql_create_view(THD*,TABLE_LIST*,enum_view_create_mode)" -> "my_message(uint,const char*,myf)"
"mysql_create_view(THD*,TABLE_LIST*,enum_view_create_mode)" -> "strcmp(const char*,const char*)"
"mysql_create_view(THD*,TABLE_LIST*,enum_view_create_mode)" -> "MYSQL_LOG::is_open()"
"mysql_create_view(THD*,TABLE_LIST*,enum_view_create_mode)" -> "List_iterator_fast<T>::operator++(int) [with T = st_mysql_lex_string]"
"mysql_create_view(THD*,TABLE_LIST*,enum_view_create_mode)" -> "mysql_register_view(THD*,TABLE_LIST*,enum_view_create_mode)"
"mysql_create_view(THD*,TABLE_LIST*,enum_view_create_mode)" -> "THD::enter_stage(const PSI_stage_info*,PSI_stage_info*,const char*,const char*,unsigned int)"
"make_valid_column_names(LEX*)" -> "Name_string::copy(const char*,size_t)"
"make_valid_column_names(LEX*)" -> "st_select_lex::next_select()"
"make_valid_column_names(LEX*)" -> "Item_name_string::is_autogenerated() const"
"make_valid_column_names(LEX*)" -> "List_iterator_fast<T>::operator++(int) [with T = Item]"
"make_valid_column_names(LEX*)" -> "check_duplicate_names(List<Item>&,bool)"
"make_valid_column_names(LEX*)" -> "__builtin_memcpy(void*,const void*,long unsigned int)"
"make_valid_column_names(LEX*)" -> "check_column_name(const char*)"
"make_valid_column_names(LEX*)" -> "Simple_cstring::ptr() const"
"make_valid_column_names(LEX*)" -> "my_snprintf(char*,size_t,const char*,...)"
"make_valid_column_names(LEX*)" -> "List_iterator_fast<T>::List_iterator_fast(List<T>&) [with T = Item]"
"check_duplicate_names(List<Item>&,bool)" -> "List_iterator_fast<T>::rewind() [with T = Item]"
"check_duplicate_names(List<Item>&,bool)" -> "my_error(int,myf,...)"
"check_duplicate_names(List<Item>&,bool)" -> "Simple_cstring::ptr() const"
"check_duplicate_names(List<Item>&,bool)" -> "Item_name_string::set_autogenerated(bool)"
"check_duplicate_names(List<Item>&,bool)" -> "Name_string::eq(Name_string) const"
"check_duplicate_names(List<Item>&,bool)" -> "List_iterator_fast<T>::operator++(int) [with T = Item]"
"check_duplicate_names(List<Item>&,bool)" -> "make_unique_view_field_name(Item*,List<Item>&,Item*)"
"check_duplicate_names(List<Item>&,bool)" -> "List_iterator_fast<T>::List_iterator_fast(List<T>&) [with T = Item]"
"check_duplicate_names(List<Item>&,bool)" -> "Item_name_string::is_autogenerated() const"
"make_unique_view_field_name(Item*,List<Item>&,Item*)" -> "__builtin_memcpy(void*,const void*,long unsigned int)"
"make_unique_view_field_name(Item*,List<Item>&,Item*)" -> "Simple_cstring::ptr() const"
"make_unique_view_field_name(Item*,List<Item>&,Item*)" -> "my_snprintf(char*,size_t,const char*,...)"
"make_unique_view_field_name(Item*,List<Item>&,Item*)" -> "Name_string::eq(const char*) const"
"make_unique_view_field_name(Item*,List<Item>&,Item*)" -> "List_iterator_fast<T>::operator++(int) [with T = Item]"
"make_unique_view_field_name(Item*,List<Item>&,Item*)" -> "List_iterator_fast<T>::List_iterator_fast(List<T>&) [with T = Item]"
"make_unique_view_field_name(Item*,List<Item>&,Item*)" -> "Simple_cstring::is_set() const"
"make_unique_view_field_name(Item*,List<Item>&,Item*)" -> "List_iterator_fast<T>::rewind() [with T = Item]"
"make_unique_view_field_name(Item*,List<Item>&,Item*)" -> "Name_string::copy(const char*,size_t)"
"fill_defined_view_parts(THD*,TABLE_LIST*)" -> "get_table_def_key(const TABLE_LIST*,const char**)"
"fill_defined_view_parts(THD*,TABLE_LIST*)" -> "TABLE_LIST::TABLE_LIST()"
"fill_defined_view_parts(THD*,TABLE_LIST*)" -> "memcpy(void*,const void*,size_t)"
"fill_defined_view_parts(THD*,TABLE_LIST*)" -> "tdc_open_view(THD*,TABLE_LIST*,const char*,const char*,uint,uint)"
"mysql_register_view(THD*,TABLE_LIST*,enum_view_create_mode)" -> "LEX::can_be_merged()"
"mysql_register_view(THD*,TABLE_LIST*,enum_view_create_mode)" -> "find_table_in_global_list(TABLE_LIST*,const char*,const char*)"
"mysql_register_view(THD*,TABLE_LIST*,enum_view_create_mode)" -> "String::length() const"
"mysql_register_view(THD*,TABLE_LIST*,enum_view_create_mode)" -> "fn_format(char*,const char*,const char*,const char*,uint)"
"mysql_register_view(THD*,TABLE_LIST*,enum_view_create_mode)" -> "Default_object_creation_ctx::get_client_cs()"
"mysql_register_view(THD*,TABLE_LIST*,enum_view_create_mode)" -> "sql_parse_prepare(const LEX_STRING*,MEM_ROOT*,bool)"
"mysql_register_view(THD*,TABLE_LIST*,enum_view_create_mode)" -> "build_table_filename(char*,size_t,const char*,const char*,const char*,uint,bool*)"
"mysql_register_view(THD*,TABLE_LIST*,enum_view_create_mode)" -> "build_table_filename(char*,size_t,const char*,const char*,const char*,uint)"
"mysql_register_view(THD*,TABLE_LIST*,enum_view_create_mode)" -> "String::ptr() const"
"mysql_register_view(THD*,TABLE_LIST*,enum_view_create_mode)" -> "TABLE_LIST::calc_md5(char*)"
"mysql_register_view(THD*,TABLE_LIST*,enum_view_create_mode)" -> "st_select_lex_unit::print(String*,enum_query_type)"
"mysql_register_view(THD*,TABLE_LIST*,enum_view_create_mode)" -> "st_select_lex_unit::is_union()"
"mysql_register_view(THD*,TABLE_LIST*,enum_view_create_mode)" -> "my_error(int,myf,...)"
"mysql_register_view(THD*,TABLE_LIST*,enum_view_create_mode)" -> "THD::is_error() const"
"mysql_register_view(THD*,TABLE_LIST*,enum_view_create_mode)" -> "push_warning(THD*,Sql_condition::enum_warning_level,uint,const char*)"
"mysql_register_view(THD*,TABLE_LIST*,enum_view_create_mode)" -> "String::String(char*,uint32,const CHARSET_INFO*)"
"mysql_register_view(THD*,TABLE_LIST*,enum_view_create_mode)" -> "THD::make_lex_string(LEX_STRING*,const char*,uint,bool)"
"mysql_register_view(THD*,TABLE_LIST*,enum_view_create_mode)" -> "lex_string_set(LEX_STRING*,const char*)"
"mysql_register_view(THD*,TABLE_LIST*,enum_view_create_mode)" -> "File_parser::type() const"
"mysql_register_view(THD*,TABLE_LIST*,enum_view_create_mode)" -> "strlen(const char*)"
"mysql_register_view(THD*,TABLE_LIST*,enum_view_create_mode)" -> "st_select_lex::master_unit()"
"mysql_register_view(THD*,TABLE_LIST*,enum_view_create_mode)" -> "is_equal(const LEX_STRING*,const LEX_STRING*)"
"mysql_register_view(THD*,TABLE_LIST*,enum_view_create_mode)" -> "Default_object_creation_ctx::get_connection_cl()"
"mysql_register_view(THD*,TABLE_LIST*,enum_view_create_mode)" -> "_current_thd()"
"mysql_register_view(THD*,TABLE_LIST*,enum_view_create_mode)" -> "Query_arena::memdup(const void*,size_t)"
"mysql_register_view(THD*,TABLE_LIST*,enum_view_create_mode)" -> "access(const char*,int)"
"mysql_register_view(THD*,TABLE_LIST*,enum_view_create_mode)" -> "sql_create_definition_file(const LEX_STRING*,const LEX_STRING*,const LEX_STRING*,uchar*,File_option*)"
"mysql_register_view(THD*,TABLE_LIST*,enum_view_create_mode)" -> "String::length(uint32)"
"mysql_register_view(THD*,TABLE_LIST*,enum_view_create_mode)" -> "THD::charset()"
"mysql_register_view(THD*,TABLE_LIST*,enum_view_create_mode)" -> "File_parser::ok()"
"mysql_register_view(THD*,TABLE_LIST*,enum_view_create_mode)" -> "View_creation_ctx::create(THD*)"
"View_creation_ctx::create(THD*)" -> "View_creation_ctx::View_creation_ctx(THD*)"
"mysql_checksum_table(THD*,TABLE_LIST*,HA_CHECK_OPT*)" -> "Field::val_str(String*)"
"mysql_checksum_table(THD*,TABLE_LIST*,HA_CHECK_OPT*)" -> "strxmov(char*,const char*,...)"
"mysql_checksum_table(THD*,TABLE_LIST*,HA_CHECK_OPT*)" -> "THD::clear_error()"
"mysql_checksum_table(THD*,TABLE_LIST*,HA_CHECK_OPT*)" -> "Item_int::Item_int(const Name_string&,longlong,uint)"
"mysql_checksum_table(THD*,TABLE_LIST*,HA_CHECK_OPT*)" -> "TABLE::use_all_columns()"
"mysql_checksum_table(THD*,TABLE_LIST*,HA_CHECK_OPT*)" -> "Item_empty_string::Item_empty_string(const char*,uint,const CHARSET_INFO*)"
"mysql_checksum_table(THD*,TABLE_LIST*,HA_CHECK_OPT*)" -> "Name_string::Name_string(const char*,size_t)"
"mysql_checksum_table(THD*,TABLE_LIST*,HA_CHECK_OPT*)" -> "handler::ha_rnd_next(uchar*)"
"mysql_checksum_table(THD*,TABLE_LIST*,HA_CHECK_OPT*)" -> "close_thread_tables(THD*)"
"mysql_checksum_table(THD*,TABLE_LIST*,HA_CHECK_OPT*)" -> "handler::ha_rnd_end()"
"mysql_checksum_table(THD*,TABLE_LIST*,HA_CHECK_OPT*)" -> "String::ptr() const"
"mysql_checksum_table(THD*,TABLE_LIST*,HA_CHECK_OPT*)" -> "open_temporary_tables(THD*,TABLE_LIST*)"
"mysql_checksum_table(THD*,TABLE_LIST*,HA_CHECK_OPT*)" -> "my_checksum(ha_checksum,const uchar*,size_t)"
"mysql_checksum_table(THD*,TABLE_LIST*,HA_CHECK_OPT*)" -> "String::String()"
"mysql_checksum_table(THD*,TABLE_LIST*,HA_CHECK_OPT*)" -> "__builtin_expect(long int,long int)"
"mysql_checksum_table(THD*,TABLE_LIST*,HA_CHECK_OPT*)" -> "List<T>::List() [with T = Item]"
"mysql_checksum_table(THD*,TABLE_LIST*,HA_CHECK_OPT*)" -> "trans_rollback_stmt(THD*)"
"mysql_checksum_table(THD*,TABLE_LIST*,HA_CHECK_OPT*)" -> "Protocol::store(ulonglong)"
"mysql_checksum_table(THD*,TABLE_LIST*,HA_CHECK_OPT*)" -> "String::length() const"
"mysql_checksum_table(THD*,TABLE_LIST*,HA_CHECK_OPT*)" -> "open_and_lock_tables(THD*,TABLE_LIST*,bool,uint)"
"mysql_checksum_table(THD*,TABLE_LIST*,HA_CHECK_OPT*)" -> "handler::ha_table_flags() const"
"mysql_checksum_table(THD*,TABLE_LIST*,HA_CHECK_OPT*)" -> "my_eof(THD*)"
"mysql_checksum_table(THD*,TABLE_LIST*,HA_CHECK_OPT*)" -> "List<T>::push_back(T*) [with T = Item]"
"mysql_checksum_table(THD*,TABLE_LIST*,HA_CHECK_OPT*)" -> "Protocol::store(const char*,const CHARSET_INFO*)"
"mysql_checksum_table(THD*,TABLE_LIST*,HA_CHECK_OPT*)" -> "handler::ha_rnd_init(bool)"
"mysql_sql_stmt_execute(THD*)" -> "Statement_map::find_by_name(LEX_STRING*)"
"mysql_sql_stmt_execute(THD*)" -> "String::String()"
"mysql_sql_stmt_execute(THD*)" -> "my_error(int,myf,...)"
"mysql_sql_stmt_execute(THD*)" -> "Prepared_statement::execute_loop(String*,bool,uchar*,uchar*)"
"Prepared_statement::execute_loop(String*,bool,uchar*,uchar*)" -> "my_message(uint,const char*,myf)"
"Prepared_statement::execute_loop(String*,bool,uchar*,uchar*)" -> "THD::clear_error()"
"Prepared_statement::execute_loop(String*,bool,uchar*,uchar*)" -> "Reprepare_observer::is_invalidated() const"
"Prepared_statement::execute_loop(String*,bool,uchar*,uchar*)" -> "__builtin_expect(long int,long int)"
"Prepared_statement::execute_loop(String*,bool,uchar*,uchar*)" -> "Prepared_statement::reprepare()"
"Prepared_statement::execute_loop(String*,bool,uchar*,uchar*)" -> "Open_tables_state::pop_reprepare_observer()"
"Prepared_statement::execute_loop(String*,bool,uchar*,uchar*)" -> "reset_stmt_params(Prepared_statement*)"
"Prepared_statement::execute_loop(String*,bool,uchar*,uchar*)" -> "my_error(int,myf,...)"
"Prepared_statement::execute_loop(String*,bool,uchar*,uchar*)" -> "Open_tables_state::push_reprepare_observer(Reprepare_observer*)"
"Prepared_statement::execute_loop(String*,bool,uchar*,uchar*)" -> "Reprepare_observer::reset_reprepare_observer()"
"Prepared_statement::execute_loop(String*,bool,uchar*,uchar*)" -> "Prepared_statement::execute(String*,bool)"
"Prepared_statement::execute_loop(String*,bool,uchar*,uchar*)" -> "THD::is_error() const"
"Prepared_statement::execute_loop(String*,bool,uchar*,uchar*)" -> "Prepared_statement::set_parameters(String*,uchar*,uchar*)"
"Prepared_statement::reprepare()" -> "Prepared_statement::swap_prepared_statement(Prepared_statement*)"
"Prepared_statement::reprepare()" -> "Diagnostics_area::clear_warning_info(ulonglong)"
"Prepared_statement::reprepare()" -> "Statement::query() const"
"Prepared_statement::reprepare()" -> "Prepared_statement::validate_metadata(Prepared_statement*)"
"Prepared_statement::reprepare()" -> "Prepared_statement::set_name(LEX_STRING*)"
"Prepared_statement::reprepare()" -> "Prepared_statement::prepare(const char*,uint)"
"Prepared_statement::reprepare()" -> "swap_parameter_array(Item_param**,Item_param**,uint)"
"Prepared_statement::reprepare()" -> "mysql_change_db(THD*,const LEX_STRING*,bool)"
"Prepared_statement::reprepare()" -> "THD::get_stmt_da()"
"Prepared_statement::reprepare()" -> "Prepared_statement::Prepared_statement(THD*)"
"Prepared_statement::reprepare()" -> "Prepared_statement::set_sql_prepare()"
"Prepared_statement::reprepare()" -> "mysql_opt_change_db(THD*,const LEX_STRING*,LEX_STRING*,bool,bool*)"
"Prepared_statement::reprepare()" -> "Statement::query_length() const"
"Prepared_statement::swap_prepared_statement(Prepared_statement*)" -> "Query_arena::set_query_arena(Query_arena*)"
"Prepared_statement::swap_prepared_statement(Prepared_statement*)" -> "Statement::Statement()"
"Prepared_statement::swap_prepared_statement(Prepared_statement*)" -> "Statement::set_statement(Statement*)"
"Prepared_statement::validate_metadata(Prepared_statement*)" -> "Prepared_statement::is_sql_prepare() const"
"Prepared_statement::set_name(LEX_STRING*)" -> "memdup_root(MEM_ROOT*,const void*,size_t)"
"swap_parameter_array(Item_param**,Item_param**,uint)" -> "Item_param::set_param_type_and_swap_value(Item_param*)"
"Item_param::set_param_type_and_swap_value(Item_param*)" -> "String::swap(String&)"
"Item_param::set_param_type_and_swap_value(Item_param*)" -> "DTCollation::set(DTCollation&)"
"Item_param::set_param_type_and_swap_value(Item_param*)" -> "my_decimal::swap(my_decimal&)"
"my_decimal::swap(my_decimal&)" -> "my_decimal::operator=(const my_decimal&)"
"my_decimal::swap(my_decimal&)" -> "my_decimal::my_decimal()"
"Prepared_statement::execute(String*,bool)" -> "Prepared_statement::is_sql_prepare() const"
"Prepared_statement::execute(String*,bool)" -> "Statement::query_length() const"
"Prepared_statement::execute(String*,bool)" -> "log_execute_line(THD*)"
"Prepared_statement::execute(String*,bool)" -> "String::ptr() const"
"Prepared_statement::execute(String*,bool)" -> "mysql_opt_change_db(THD*,const LEX_STRING*,LEX_STRING*,bool,bool*)"
"Prepared_statement::execute(String*,bool)" -> "String::length() const"
"Prepared_statement::execute(String*,bool)" -> "Statement::set_n_backup_statement(Statement*,Statement*)"
"Prepared_statement::execute(String*,bool)" -> "mysql_execute_command(THD*)"
"Prepared_statement::execute(String*,bool)" -> "Query_cache::send_result_to_client(THD*,char*,uint)"
"Prepared_statement::execute(String*,bool)" -> "reinit_stmt_before_use(THD*,LEX*)"
"Prepared_statement::execute(String*,bool)" -> "mysql_change_db(THD*,const LEX_STRING*,bool)"
"Prepared_statement::execute(String*,bool)" -> "Protocol_text::send_out_parameters(List<Item_param>*)"
"Prepared_statement::execute(String*,bool)" -> "mysql_open_cursor(THD*,select_result*,Server_side_cursor**)"
"Prepared_statement::execute(String*,bool)" -> "alloc_query(THD*,const char*,uint)"
"Prepared_statement::execute(String*,bool)" -> "Statement::Statement()"
"Prepared_statement::execute(String*,bool)" -> "Prepared_statement::close_cursor()"
"Prepared_statement::execute(String*,bool)" -> "Statement::set_query_inner(const CSET_STRING&)"
"Prepared_statement::execute(String*,bool)" -> "rewrite_query_if_needed(THD*)"
"Prepared_statement::execute(String*,bool)" -> "Statement::query() const"
"Prepared_statement::execute(String*,bool)" -> "my_error(int,myf,...)"
"log_execute_line(THD*)" -> "String::length() const"
"log_execute_line(THD*)" -> "String::c_ptr_safe()"
"log_execute_line(THD*)" -> "Statement::query() const"
"log_execute_line(THD*)" -> "LOGGER::general_log_write(THD*,enum_server_command,const char*,uint)"
"log_execute_line(THD*)" -> "Statement::query_length() const"
"Query_cache::send_result_to_client(THD*,char*,uint)" -> "Query_cache_query::lock_reading()"
"Query_cache::send_result_to_client(THD*,char*,uint)" -> "has_no_cache_directive(char*)"
"Query_cache::send_result_to_client(THD*,char*,uint)" -> "THD::in_multi_stmt_transaction_mode() const"
"Query_cache::send_result_to_client(THD*,char*,uint)" -> "Query_cache_block::query()"
"Query_cache::send_result_to_client(THD*,char*,uint)" -> "Query_cache_table::key_length()"
"Query_cache::send_result_to_client(THD*,char*,uint)" -> "THD::enter_stage(const PSI_stage_info*,PSI_stage_info*,const char*,const char*,unsigned int)"
"Query_cache::send_result_to_client(THD*,char*,uint)" -> "Statement::query_length() const"
"Query_cache::send_result_to_client(THD*,char*,uint)" -> "Query_cache_query::result()"
"Query_cache::send_result_to_client(THD*,char*,uint)" -> "Opt_trace_struct::add(const char*,bool)"
"Query_cache::send_result_to_client(THD*,char*,uint)" -> "Query_cache::is_disabled()"
"Query_cache::send_result_to_client(THD*,char*,uint)" -> "Querycache_stream::Querycache_stream(Query_cache_block*,uint)"
"Query_cache::send_result_to_client(THD*,char*,uint)" -> "Query_cache_query::unlock_reading()"
"Query_cache::send_result_to_client(THD*,char*,uint)" -> "my_hash_search(const HASH*,const uchar*,size_t)"
"Query_cache::send_result_to_client(THD*,char*,uint)" -> "trans_commit_stmt(THD*)"
"Query_cache::send_result_to_client(THD*,char*,uint)" -> "Opt_trace_object::Opt_trace_object(Opt_trace_context*,Opt_trace_context::feature_value)"
"Query_cache::send_result_to_client(THD*,char*,uint)" -> "memcpy(void*,const void*,size_t)"
"Query_cache::send_result_to_client(THD*,char*,uint)" -> "Opt_trace_start::Opt_trace_start(THD*,TABLE_LIST*,enum_sql_command,List<set_var_base>*,const char*,size_t,sp_printable*,const CHARSET_INFO*)"
"Query_cache::send_result_to_client(THD*,char*,uint)" -> "memset(void*,int,size_t)"
"Query_cache::send_result_to_client(THD*,char*,uint)" -> "Query_cache_block::table(uint)"
"Query_cache::send_result_to_client(THD*,char*,uint)" -> "Query_cache_query::tables_type()"
"Query_cache::send_result_to_client(THD*,char*,uint)" -> "THD::get_stmt_da()"
"Query_cache::send_result_to_client(THD*,char*,uint)" -> "trans_rollback_stmt(THD*)"
"Query_cache::send_result_to_client(THD*,char*,uint)" -> "build_table_filename(char*,size_t,const char*,const char*,const char*,uint)"
"Query_cache::send_result_to_client(THD*,char*,uint)" -> "Query_cache_table::data()"
"Query_cache::send_result_to_client(THD*,char*,uint)" -> "Query_cache_block::headers_len()"
"Query_cache::send_result_to_client(THD*,char*,uint)" -> "Diagnostics_area::is_set() const"
"Query_cache::send_result_to_client(THD*,char*,uint)" -> "emb_load_querycache_result(THD*,Querycache_stream*)"
"Query_cache::send_result_to_client(THD*,char*,uint)" -> "Query_cache::try_lock(bool)"
"Query_cache::send_result_to_client(THD*,char*,uint)" -> "Query_cache::unlock()"
"Query_cache::send_result_to_client(THD*,char*,uint)" -> "TABLE_LIST::TABLE_LIST()"
"Query_cache::send_result_to_client(THD*,char*,uint)" -> "Query_cache_table::db()"
"Query_cache::send_result_to_client(THD*,char*,uint)" -> "Query_cache_table::engine_data()"
"Query_cache::send_result_to_client(THD*,char*,uint)" -> "(* Query_cache_table::callback())(THD*,char*,uint,ulonglong*)"
"Query_cache::send_result_to_client(THD*,char*,uint)" -> "Query_cache_query::found_rows()"
"Query_cache::send_result_to_client(THD*,char*,uint)" -> "memcmp(const void*,const void*,size_t)"
"Query_cache::send_result_to_client(THD*,char*,uint)" -> "Diagnostics_area::disable_status()"
"Query_cache::send_result_to_client(THD*,char*,uint)" -> "Query_cache::move_to_query_list_end(Query_cache_block*)"
"Query_cache::send_result_to_client(THD*,char*,uint)" -> "THD::in_active_multi_stmt_transaction() const"
"Query_cache::send_result_to_client(THD*,char*,uint)" -> "Statement::query() const"
"Query_cache::send_result_to_client(THD*,char*,uint)" -> "Query_cache::invalidate_table_internal(THD*,uchar*,uint32)"
"Query_cache::send_result_to_client(THD*,char*,uint)" -> "Query_cache_table::table()"
"Query_cache_query::lock_reading()" -> "inline_mysql_rwlock_rdlock(mysql_rwlock_t*)"
"Query_cache_query::unlock_reading()" -> "inline_mysql_rwlock_unlock(mysql_rwlock_t*)"
"emb_load_querycache_result(THD*,Querycache_stream*)" -> "Querycache_stream::load_column(MEM_ROOT*,char**)"
"emb_load_querycache_result(THD*,Querycache_stream*)" -> "Querycache_stream::load_str(MEM_ROOT*,uint*)"
"emb_load_querycache_result(THD*,Querycache_stream*)" -> "Querycache_stream::load_int()"
"emb_load_querycache_result(THD*,Querycache_stream*)" -> "Querycache_stream::load_uchar()"
"emb_load_querycache_result(THD*,Querycache_stream*)" -> "alloc_root(MEM_ROOT*,size_t)"
"emb_load_querycache_result(THD*,Querycache_stream*)" -> "init_alloc_root(MEM_ROOT*,size_t,size_t)"
"emb_load_querycache_result(THD*,Querycache_stream*)" -> "Querycache_stream::load_ll()"
"emb_load_querycache_result(THD*,Querycache_stream*)" -> "THD::get_stmt_da()"
"emb_load_querycache_result(THD*,Querycache_stream*)" -> "THD::alloc_new_dataset()"
"emb_load_querycache_result(THD*,Querycache_stream*)" -> "Querycache_stream::load_safe_str(MEM_ROOT*,char**,uint*)"
"emb_load_querycache_result(THD*,Querycache_stream*)" -> "Querycache_stream::load_short()"
"emb_load_querycache_result(THD*,Querycache_stream*)" -> "Diagnostics_area::current_statement_warn_count() const"
"emb_load_querycache_result(THD*,Querycache_stream*)" -> "net_send_eof(THD*,uint,uint)"
"Querycache_stream::load_column(MEM_ROOT*,char**)" -> "Querycache_stream::load_str_only(char*,uint)"
"Querycache_stream::load_column(MEM_ROOT*,char**)" -> "Querycache_stream::load_int()"
"Querycache_stream::load_column(MEM_ROOT*,char**)" -> "alloc_root(MEM_ROOT*,size_t)"
"Querycache_stream::load_str_only(char*,uint)" -> "memcpy(void*,const void*,size_t)"
"Querycache_stream::load_str_only(char*,uint)" -> "Querycache_stream::use_next_block(bool)"
"Querycache_stream::load_int()" -> "Querycache_stream::use_next_block(bool)"
"Querycache_stream::load_int()" -> "memcpy(void*,const void*,size_t)"
"Querycache_stream::load_str(MEM_ROOT*,uint*)" -> "alloc_root(MEM_ROOT*,size_t)"
"Querycache_stream::load_str(MEM_ROOT*,uint*)" -> "Querycache_stream::load_str_only(char*,uint)"
"Querycache_stream::load_str(MEM_ROOT*,uint*)" -> "Querycache_stream::load_int()"
"Querycache_stream::load_uchar()" -> "Querycache_stream::use_next_block(bool)"
"Querycache_stream::load_ll()" -> "memcpy(void*,const void*,size_t)"
"Querycache_stream::load_ll()" -> "Querycache_stream::use_next_block(bool)"
"THD::alloc_new_dataset()" -> "my_multi_malloc(myf,...)"
"Querycache_stream::load_safe_str(MEM_ROOT*,char**,uint*)" -> "alloc_root(MEM_ROOT*,size_t)"
"Querycache_stream::load_safe_str(MEM_ROOT*,char**,uint*)" -> "Querycache_stream::load_int()"
"Querycache_stream::load_safe_str(MEM_ROOT*,char**,uint*)" -> "Querycache_stream::load_str_only(char*,uint)"
"Querycache_stream::load_short()" -> "Querycache_stream::use_next_block(bool)"
"net_send_eof(THD*,uint,uint)" -> "write_eof_packet(THD*,uint,uint)"
"write_eof_packet(THD*,uint,uint)" -> "std::min(const _Tp&,const _Tp&) [with _Tp = unsigned int]"
"Query_cache::move_to_query_list_end(Query_cache_block*)" -> "Query_cache::double_linked_list_simple_include(Query_cache_block*,Query_cache_block**)"
"Query_cache::move_to_query_list_end(Query_cache_block*)" -> "Query_cache::double_linked_list_exclude(Query_cache_block*,Query_cache_block**)"
"reinit_stmt_before_use(THD*,LEX*)" -> "select_result::set_thd(THD*)"
"reinit_stmt_before_use(THD*,LEX*)" -> "st_select_lex_unit::set_thd(THD*)"
"reinit_stmt_before_use(THD*,LEX*)" -> "TABLE_LIST::reinit_before_use(THD*)"
"reinit_stmt_before_use(THD*,LEX*)" -> "st_select_lex::next_select_in_list()"
"reinit_stmt_before_use(THD*,LEX*)" -> "has_trivial_destructor>::at(size_t) [with Element_type = st_order*,bool has_trivial_destructor = true,size_t = long unsigned int]"
"reinit_stmt_before_use(THD*,LEX*)" -> "st_select_lex_unit::reinit_exec_mechanism()"
"reinit_stmt_before_use(THD*,LEX*)" -> "st_select_lex_unit::unclean()"
"reinit_stmt_before_use(THD*,LEX*)" -> "base_list::empty()"
"reinit_stmt_before_use(THD*,LEX*)" -> "has_trivial_destructor>::size() const [with Element_type = st_order*,bool has_trivial_destructor = true,size_t = long unsigned int]"
"TABLE_LIST::reinit_before_use(THD*)" -> "TABLE_LIST::set_join_cond(Item*)"
"TABLE_LIST::reinit_before_use(THD*)" -> "strlen(const char*)"
"TABLE_LIST::reinit_before_use(THD*)" -> "List<T>::head() [with T = TABLE_LIST]"
"Protocol_text::send_out_parameters(List<Item_param>*)" -> "Name_string::Name_string(LEX_STRING)"
"Protocol_text::send_out_parameters(List<Item_param>*)" -> "Item_func_set_user_var::check(bool)"
"Protocol_text::send_out_parameters(List<Item_param>*)" -> "List_iterator_fast<T>::operator++(int) [with T = Item_param]"
"Protocol_text::send_out_parameters(List<Item_param>*)" -> "Item_func_set_user_var::Item_func_set_user_var(Name_string,Item*,bool)"
"Protocol_text::send_out_parameters(List<Item_param>*)" -> "List_iterator_fast<T>::operator++(int) [with T = st_mysql_lex_string]"
"Protocol_text::send_out_parameters(List<Item_param>*)" -> "List_iterator_fast<T>::List_iterator_fast(List<T>&) [with T = Item_param]"
"Protocol_text::send_out_parameters(List<Item_param>*)" -> "List_iterator_fast<T>::List_iterator_fast(List<T>&) [with T = st_mysql_lex_string]"
"Protocol_text::send_out_parameters(List<Item_param>*)" -> "Item_func_set_user_var::update()"
"Item_func_set_user_var::check(bool)" -> "Field::val_str(String*)"
"List_iterator_fast<T>::operator++(int) [with T = Item_param]" -> "base_list_iterator::next_fast()"
"List_iterator_fast<T>::List_iterator_fast(List<T>&) [with T = Item_param]" -> "base_list_iterator::base_list_iterator(base_list&)"
"Item_func_set_user_var::update()" -> "Item::default_charset()"
"Item_func_set_user_var::update()" -> "String::ptr() const"
"Item_func_set_user_var::update()" -> "String::charset() const"
"Item_func_set_user_var::update()" -> "String::length() const"
"Item_func_set_user_var::update()" -> "Item_func_set_user_var::update_hash(void*,uint,Item_result,const CHARSET_INFO*,Derivation,bool)"
"Item::default_charset()" -> "_current_thd()"
"Item_func_set_user_var::update_hash(void*,uint,Item_result,const CHARSET_INFO*,Derivation,bool)" -> "Field::is_null(my_ptrdiff_t) const"
"Item_func_set_user_var::update_hash(void*,uint,Item_result,const CHARSET_INFO*,Derivation,bool)" -> "user_var_entry::set_null_value(Item_result)"
"Item_func_set_user_var::update_hash(void*,uint,Item_result,const CHARSET_INFO*,Derivation,bool)" -> "user_var_entry::type() const"
"Item_func_set_user_var::update_hash(void*,uint,Item_result,const CHARSET_INFO*,Derivation,bool)" -> "user_var_entry::store(void*,uint,Item_result,const CHARSET_INFO*,Derivation,bool)"
"mysql_open_cursor(THD*,select_result*,Server_side_cursor**)" -> "Select_materialize::Select_materialize(select_result*)"
"mysql_open_cursor(THD*,select_result*,Server_side_cursor**)" -> "mysql_execute_command(THD*)"
"Select_materialize::Select_materialize(select_result*)" -> "select_union::select_union()"
"Prepared_statement::set_parameters(String*,uchar*,uchar*)" -> "my_error(int,myf,...)"
"Prepared_statement::set_parameters(String*,uchar*,uchar*)" -> "reset_stmt_params(Prepared_statement*)"
"TABLE_LIST::operator=(const TABLE_LIST&)" -> "__builtin_memcpy(void*,const void*,long unsigned int)"
"TABLE_LIST::operator=(const TABLE_LIST&)" -> "MDL_request::operator=(const MDL_request&)"
"TABLE_LIST::operator=(const TABLE_LIST&)" -> "Table_id::operator=(const Table_id&)"
"mysql_xa_recover(THD*)" -> "Item_int::Item_int(const Name_string&,longlong,uint)"
"mysql_xa_recover(THD*)" -> "List<T>::List() [with T = Item]"
"mysql_xa_recover(THD*)" -> "Name_string::Name_string(const char*,size_t)"
"mysql_xa_recover(THD*)" -> "Item_empty_string::Item_empty_string(const char*,uint,const CHARSET_INFO*)"
"mysql_xa_recover(THD*)" -> "inline_mysql_mutex_lock(mysql_mutex_t*)"
"mysql_xa_recover(THD*)" -> "List<T>::push_back(T*) [with T = Item]"
"mysql_xa_recover(THD*)" -> "inline_mysql_mutex_unlock(mysql_mutex_t*)"
"mysql_xa_recover(THD*)" -> "my_eof(THD*)"
"mysql_xa_recover(THD*)" -> "my_hash_element(HASH*,ulong)"
"trans_release_savepoint(THD*,LEX_STRING)" -> "my_error(int,myf,...)"
"trans_release_savepoint(THD*,LEX_STRING)" -> "ha_release_savepoint(THD*,SAVEPOINT*)"
"trans_release_savepoint(THD*,LEX_STRING)" -> "find_savepoint(THD*,LEX_STRING)"
"sp_drop_routine(THD*,enum_sp_type,sp_name*)" -> "Statement::query_length() const"
"sp_drop_routine(THD*,enum_sp_type,sp_name*)" -> "write_bin_log(THD*,bool,const char*,ulong,bool)"
"sp_drop_routine(THD*,enum_sp_type,sp_name*)" -> "sp_cache_flush_obsolete(sp_cache**,sp_head**)"
"sp_drop_routine(THD*,enum_sp_type,sp_name*)" -> "THD::is_current_stmt_binlog_format_row() const"
"sp_drop_routine(THD*,enum_sp_type,sp_name*)" -> "Statement::query() const"
"sp_drop_routine(THD*,enum_sp_type,sp_name*)" -> "sp_cache_invalidate()"
"sp_drop_routine(THD*,enum_sp_type,sp_name*)" -> "lock_object_name(THD*,MDL_key::enum_mdl_namespace,const char*,const char*)"
"sp_drop_routine(THD*,enum_sp_type,sp_name*)" -> "sp_cache_lookup(sp_cache**,sp_name*)"
"sp_drop_routine(THD*,enum_sp_type,sp_name*)" -> "THD::set_current_stmt_binlog_format_row()"
"sp_drop_routine(THD*,enum_sp_type,sp_name*)" -> "THD::add_to_binlog_accessed_dbs(const char*)"
"sp_drop_routine(THD*,enum_sp_type,sp_name*)" -> "open_proc_table_for_update(THD*)"
"sp_drop_routine(THD*,enum_sp_type,sp_name*)" -> "handler::ha_delete_row(const uchar*)"
"sp_drop_routine(THD*,enum_sp_type,sp_name*)" -> "THD::clear_current_stmt_binlog_format_row()"
"sp_drop_routine(THD*,enum_sp_type,sp_name*)" -> "db_find_routine_aux(THD*,enum_sp_type,sp_name*,TABLE*)"
"deny_updates_if_read_only_option(THD*,TABLE_LIST*)" -> "some_non_temp_table_to_be_updated(THD*,TABLE_LIST*)"
"mysql_delete(THD*,TABLE_LIST*,Item*,SQL_I_List<st_order>*,ha_rows,ulonglong)" -> "st_select_lex::setup_ref_array(THD*,uint)"
"mysql_delete(THD*,TABLE_LIST*,Item*,SQL_I_List<st_order>*,ha_rows,ulonglong)" -> "get_index_for_order(ORDER*,TABLE*,SQL_SELECT*,ha_rows,bool*,bool*)"
"mysql_delete(THD*,TABLE_LIST*,Item*,SQL_I_List<st_order>*,ha_rows,ulonglong)" -> "Filesort::Filesort(ORDER*,ha_rows,SQL_SELECT*)"
"mysql_delete(THD*,TABLE_LIST*,Item*,SQL_I_List<st_order>*,ha_rows,ulonglong)" -> "explain_single_table_modification(THD*,TABLE*,const SQL_SELECT*,uint,ha_rows,bool,bool,bool,bool)"
"mysql_delete(THD*,TABLE_LIST*,Item*,SQL_I_List<st_order>*,ha_rows,ulonglong)" -> "Query_cache::invalidate(THD*,TABLE_LIST*,my_bool)"
"mysql_delete(THD*,TABLE_LIST*,Item*,SQL_I_List<st_order>*,ha_rows,ulonglong)" -> "Table_triggers_list::has_delete_triggers()"
"mysql_delete(THD*,TABLE_LIST*,Item*,SQL_I_List<st_order>*,ha_rows,ulonglong)" -> "TABLE_LIST::TABLE_LIST()"
"mysql_delete(THD*,TABLE_LIST*,Item*,SQL_I_List<st_order>*,ha_rows,ulonglong)" -> "Opt_trace_object::Opt_trace_object(Opt_trace_context*,Opt_trace_context::feature_value)"
"mysql_delete(THD*,TABLE_LIST*,Item*,SQL_I_List<st_order>*,ha_rows,ulonglong)" -> "prune_partitions(THD*,TABLE*,Item*)"
"mysql_delete(THD*,TABLE_LIST*,Item*,SQL_I_List<st_order>*,ha_rows,ulonglong)" -> "THD::clear_error()"
"mysql_delete(THD*,TABLE_LIST*,Item*,SQL_I_List<st_order>*,ha_rows,ulonglong)" -> "TABLE::set_keyread(bool)"
"mysql_delete(THD*,TABLE_LIST*,Item*,SQL_I_List<st_order>*,ha_rows,ulonglong)" -> "THD::is_current_stmt_binlog_format_row() const"
"mysql_delete(THD*,TABLE_LIST*,Item*,SQL_I_List<st_order>*,ha_rows,ulonglong)" -> "TABLE::check_read_removal(uint)"
"mysql_delete(THD*,TABLE_LIST*,Item*,SQL_I_List<st_order>*,ha_rows,ulonglong)" -> "Opt_trace_struct::add_utf8_table(const TABLE*)"
"mysql_delete(THD*,TABLE_LIST*,Item*,SQL_I_List<st_order>*,ha_rows,ulonglong)" -> "my_malloc(size_t,myf)"
"mysql_delete(THD*,TABLE_LIST*,Item*,SQL_I_List<st_order>*,ha_rows,ulonglong)" -> "handler::ha_table_flags() const"
"mysql_delete(THD*,TABLE_LIST*,Item*,SQL_I_List<st_order>*,ha_rows,ulonglong)" -> "my_error(int,myf,...)"
"mysql_delete(THD*,TABLE_LIST*,Item*,SQL_I_List<st_order>*,ha_rows,ulonglong)" -> "THD::enter_stage(const PSI_stage_info*,PSI_stage_info*,const char*,const char*,unsigned int)"
"mysql_delete(THD*,TABLE_LIST*,Item*,SQL_I_List<st_order>*,ha_rows,ulonglong)" -> "handler::has_transactions()"
"mysql_delete(THD*,TABLE_LIST*,Item*,SQL_I_List<st_order>*,ha_rows,ulonglong)" -> "Table_triggers_list::has_triggers(trg_event_type,trg_action_time_type)"
"mysql_delete(THD*,TABLE_LIST*,Item*,SQL_I_List<st_order>*,ha_rows,ulonglong)" -> "init_read_record_idx(READ_RECORD*,THD*,TABLE*,bool,uint,bool)"
"mysql_delete(THD*,TABLE_LIST*,Item*,SQL_I_List<st_order>*,ha_rows,ulonglong)" -> "TABLE::mark_columns_needed_for_delete()"
"mysql_delete(THD*,TABLE_LIST*,Item*,SQL_I_List<st_order>*,ha_rows,ulonglong)" -> "query_error_code(THD*,bool)"
"mysql_delete(THD*,TABLE_LIST*,Item*,SQL_I_List<st_order>*,ha_rows,ulonglong)" -> "filesort(THD*,TABLE*,Filesort*,bool,ha_rows*,ha_rows*)"
"mysql_delete(THD*,TABLE_LIST*,Item*,SQL_I_List<st_order>*,ha_rows,ulonglong)" -> "MYSQL_LOG::is_open()"
"mysql_delete(THD*,TABLE_LIST*,Item*,SQL_I_List<st_order>*,ha_rows,ulonglong)" -> "mysql_prepare_delete(THD*,TABLE_LIST*,Item**)"
"mysql_delete(THD*,TABLE_LIST*,Item*,SQL_I_List<st_order>*,ha_rows,ulonglong)" -> "simple_remove_const(ORDER*,Item*)"
"mysql_delete(THD*,TABLE_LIST*,Item*,SQL_I_List<st_order>*,ha_rows,ulonglong)" -> "List<T>::List() [with T = Item]"
"mysql_delete(THD*,TABLE_LIST*,Item*,SQL_I_List<st_order>*,ha_rows,ulonglong)" -> "Bitmap<64u>::clear_all()"
"mysql_delete(THD*,TABLE_LIST*,Item*,SQL_I_List<st_order>*,ha_rows,ulonglong)" -> "setup_order(THD*,Ref_ptr_array,TABLE_LIST*,List<Item>&,List<Item>&,ORDER*)"
"mysql_delete(THD*,TABLE_LIST*,Item*,SQL_I_List<st_order>*,ha_rows,ulonglong)" -> "Bitmap<64u>::is_clear_all() const"
"mysql_delete(THD*,TABLE_LIST*,Item*,SQL_I_List<st_order>*,ha_rows,ulonglong)" -> "handler::ha_delete_all_rows()"
"mysql_delete(THD*,TABLE_LIST*,Item*,SQL_I_List<st_order>*,ha_rows,ulonglong)" -> "explain_no_table(THD*,const char*,ha_rows)"
"mysql_delete(THD*,TABLE_LIST*,Item*,SQL_I_List<st_order>*,ha_rows,ulonglong)" -> "init_read_record(READ_RECORD*,THD*,TABLE*,SQL_SELECT*,int,bool,bool)"
"mysql_delete(THD*,TABLE_LIST*,Item*,SQL_I_List<st_order>*,ha_rows,ulonglong)" -> "_current_thd()"
"mysql_delete(THD*,TABLE_LIST*,Item*,SQL_I_List<st_order>*,ha_rows,ulonglong)" -> "substitute_for_best_equal_field(Item*,COND_EQUAL*,void*)"
"mysql_delete(THD*,TABLE_LIST*,Item*,SQL_I_List<st_order>*,ha_rows,ulonglong)" -> "THD_TRANS::cannot_safely_rollback() const"
"mysql_delete(THD*,TABLE_LIST*,Item*,SQL_I_List<st_order>*,ha_rows,ulonglong)" -> "memset(void*,int,size_t)"
"mysql_delete(THD*,TABLE_LIST*,Item*,SQL_I_List<st_order>*,ha_rows,ulonglong)" -> "free_underlaid_joins(THD*,SELECT_LEX*)"
"mysql_delete(THD*,TABLE_LIST*,Item*,SQL_I_List<st_order>*,ha_rows,ulonglong)" -> "Statement::query_length() const"
"mysql_delete(THD*,TABLE_LIST*,Item*,SQL_I_List<st_order>*,ha_rows,ulonglong)" -> "THD::inc_examined_row_count(ha_rows)"
"mysql_delete(THD*,TABLE_LIST*,Item*,SQL_I_List<st_order>*,ha_rows,ulonglong)" -> "open_normal_and_derived_tables(THD*,TABLE_LIST*,uint)"
"mysql_delete(THD*,TABLE_LIST*,Item*,SQL_I_List<st_order>*,ha_rows,ulonglong)" -> "lock_tables(THD*,TABLE_LIST*,uint,uint)"
"mysql_delete(THD*,TABLE_LIST*,Item*,SQL_I_List<st_order>*,ha_rows,ulonglong)" -> "THD::binlog_query(THD::enum_binlog_query_type,const char*,ulong,bool,bool,bool,int)"
"mysql_delete(THD*,TABLE_LIST*,Item*,SQL_I_List<st_order>*,ha_rows,ulonglong)" -> "init_ftfuncs(THD*,SELECT_LEX*,bool)"
"mysql_delete(THD*,TABLE_LIST*,Item*,SQL_I_List<st_order>*,ha_rows,ulonglong)" -> "Statement::query() const"
"mysql_delete(THD*,TABLE_LIST*,Item*,SQL_I_List<st_order>*,ha_rows,ulonglong)" -> "SQL_SELECT::skip_record(THD*,bool*)"
"mysql_delete(THD*,TABLE_LIST*,Item*,SQL_I_List<st_order>*,ha_rows,ulonglong)" -> "THD_TRANS::mark_modified_non_trans_table()"
"mysql_delete(THD*,TABLE_LIST*,Item*,SQL_I_List<st_order>*,ha_rows,ulonglong)" -> "make_select(TABLE*,table_map,table_map,Item*,bool,int*)"
"mysql_delete(THD*,TABLE_LIST*,Item*,SQL_I_List<st_order>*,ha_rows,ulonglong)" -> "READ_RECORD::READ_RECORD()"
"mysql_delete(THD*,TABLE_LIST*,Item*,SQL_I_List<st_order>*,ha_rows,ulonglong)" -> "end_read_record(READ_RECORD*)"
"mysql_delete(THD*,TABLE_LIST*,Item*,SQL_I_List<st_order>*,ha_rows,ulonglong)" -> "SQL_SELECT::check_quick(THD*,bool,ha_rows)"
"mysql_delete(THD*,TABLE_LIST*,Item*,SQL_I_List<st_order>*,ha_rows,ulonglong)" -> "Table_triggers_list::process_triggers(THD*,trg_event_type,trg_action_time_type,bool)"
"mysql_delete(THD*,TABLE_LIST*,Item*,SQL_I_List<st_order>*,ha_rows,ulonglong)" -> "my_message(uint,const char*,myf)"
"mysql_delete(THD*,TABLE_LIST*,Item*,SQL_I_List<st_order>*,ha_rows,ulonglong)" -> "my_ok(THD*,ulonglong,ulonglong,const char*)"
"mysql_delete(THD*,TABLE_LIST*,Item*,SQL_I_List<st_order>*,ha_rows,ulonglong)" -> "THD::is_error() const"
"mysql_delete(THD*,TABLE_LIST*,Item*,SQL_I_List<st_order>*,ha_rows,ulonglong)" -> "handler::ha_delete_row(const uchar*)"
"mysql_delete(THD*,TABLE_LIST*,Item*,SQL_I_List<st_order>*,ha_rows,ulonglong)" -> "TABLE::update_const_key_parts(Item*)"
"mysql_delete(THD*,TABLE_LIST*,Item*,SQL_I_List<st_order>*,ha_rows,ulonglong)" -> "optimize_cond(THD*,Item*,COND_EQUAL**,List<TABLE_LIST>*,bool,Item::cond_result*)"
"get_index_for_order(ORDER*,TABLE*,SQL_SELECT*,ha_rows,bool*,bool*)" -> "test_if_cheaper_ordering(const JOIN_TAB*,ORDER*,TABLE*,key_map,int,ha_rows,int*,int*,ha_rows*,uint*,uint*)"
"get_index_for_order(ORDER*,TABLE*,SQL_SELECT*,ha_rows,bool*,bool*)" -> "SQL_SELECT::set_quick(QUICK_SELECT_I*)"
"get_index_for_order(ORDER*,TABLE*,SQL_SELECT*,ha_rows,bool*,bool*)" -> "is_key_used(TABLE*,uint,const MY_BITMAP*)"
"get_index_for_order(ORDER*,TABLE*,SQL_SELECT*,ha_rows,bool*,bool*)" -> "test_if_order_by_key(ORDER*,TABLE*,uint,uint*)"
"get_index_for_order(ORDER*,TABLE*,SQL_SELECT*,ha_rows,bool*,bool*)" -> "is_simple_order(ORDER*)"
"is_key_used(TABLE*,uint,const MY_BITMAP*)" -> "handler::ha_table_flags() const"
"is_key_used(TABLE*,uint,const MY_BITMAP*)" -> "bitmap_is_overlapping(const MY_BITMAP*,const MY_BITMAP*)"
"is_key_used(TABLE*,uint,const MY_BITMAP*)" -> "memset(void*,int,size_t)"
"is_key_used(TABLE*,uint,const MY_BITMAP*)" -> "is_key_used(TABLE*,uint,const MY_BITMAP*)"
"is_key_used(TABLE*,uint,const MY_BITMAP*)" -> "TABLE::mark_columns_used_by_index_no_reset(uint,MY_BITMAP*)"
"explain_single_table_modification(THD*,TABLE*,const SQL_SELECT*,uint,ha_rows,bool,bool,bool,bool)" -> "Explain::send()"
"explain_single_table_modification(THD*,TABLE*,const SQL_SELECT*,uint,ha_rows,bool,bool,bool,bool)" -> "Explain_table::Explain_table(THD*,TABLE*,const SQL_SELECT*,uint,ha_rows,bool,bool,bool,bool)"
"Explain_table::Explain_table(THD*,TABLE*,const SQL_SELECT*,uint,ha_rows,bool,bool,bool,bool)" -> "Explain_table_base::Explain_table_base(Explain_context_enum,THD*,TABLE*)"
"Explain_table_base::Explain_table_base(Explain_context_enum,THD*,TABLE*)" -> "Explain::Explain(Explain_context_enum,THD*,JOIN*)"
"Explain_table_base::Explain_table_base(Explain_context_enum,THD*,TABLE*)" -> "Bitmap<64u>::Bitmap()"
"TABLE::check_read_removal(uint)" -> "TABLE::mark_columns_used_by_index_no_reset(uint,MY_BITMAP*)"
"TABLE::check_read_removal(uint)" -> "bitmap_cmp(const MY_BITMAP*,const MY_BITMAP*)"
"TABLE::check_read_removal(uint)" -> "memset(void*,int,size_t)"
"init_read_record_idx(READ_RECORD*,THD*,TABLE*,bool,uint,bool)" -> "memcpy(void*,const void*,size_t)"
"init_read_record_idx(READ_RECORD*,THD*,TABLE*,bool,uint,bool)" -> "memset(void*,int,size_t)"
"init_read_record_idx(READ_RECORD*,THD*,TABLE*,bool,uint,bool)" -> "handler::ha_index_init(uint,bool)"
"TABLE::mark_columns_needed_for_delete()" -> "THD::is_current_stmt_binlog_format_row() const"
"TABLE::mark_columns_needed_for_delete()" -> "MYSQL_LOG::is_open()"
"TABLE::mark_columns_needed_for_delete()" -> "TABLE::mark_columns_per_binlog_row_image()"
"TABLE::mark_columns_needed_for_delete()" -> "handler::ha_table_flags() const"
"TABLE::mark_columns_needed_for_delete()" -> "TABLE::mark_columns_used_by_index_no_reset(uint,MY_BITMAP*)"
"TABLE::mark_columns_needed_for_delete()" -> "Table_triggers_list::mark_fields_used(trg_event_type)"
"TABLE::mark_columns_needed_for_delete()" -> "bitmap_set_bit(MY_BITMAP*,uint)"
"simple_remove_const(ORDER*,Item*)" -> "const_expression_in_where(Item*,Item*,Field*,Item**)"
"SQL_SELECT::check_quick(THD*,bool,ha_rows)" -> "SQL_SELECT::test_quick_select(THD*,key_map,table_map,ha_rows,bool,st_order::enum_order)"
"SQL_SELECT::check_quick(THD*,bool,ha_rows)" -> "Bitmap<64u>::Bitmap(uint)"
"Bitmap<64u>::Bitmap(uint)" -> "Bitmap<64u>::set_prefix(uint)"
"TABLE::update_const_key_parts(Item*)" -> "const_expression_in_where(Item*,Item*,Field*,Item**)"
"TABLE::update_const_key_parts(Item*)" -> "memset(void*,int,size_t)"
"mysql_create_function(THD*,udf_func*)" -> "check_string_char_length(LEX_STRING*,const char*,uint,const CHARSET_INFO*,bool)"
"mysql_create_function(THD*,udf_func*)" -> "TABLE::use_all_columns()"
"mysql_create_function(THD*,udf_func*)" -> "dlclose(void*)"
"mysql_create_function(THD*,udf_func*)" -> "del_udf(udf_func*)"
"mysql_create_function(THD*,udf_func*)" -> "handler::ha_write_row(uchar*)"
"mysql_create_function(THD*,udf_func*)" -> "my_message(uint,const char*,myf)"
"mysql_create_function(THD*,udf_func*)" -> "TABLE_LIST::TABLE_LIST()"
"mysql_create_function(THD*,udf_func*)" -> "dlopen(const char*,int)"
"mysql_create_function(THD*,udf_func*)" -> "write_bin_log(THD*,bool,const char*,ulong,bool)"
"mysql_create_function(THD*,udf_func*)" -> "open_ltable(THD*,TABLE_LIST*,thr_lock_type,uint)"
"mysql_create_function(THD*,udf_func*)" -> "my_strerror(char*,size_t,int)"
"mysql_create_function(THD*,udf_func*)" -> "Statement::query() const"
"mysql_create_function(THD*,udf_func*)" -> "unpack_filename(char*,const char*)"
"mysql_create_function(THD*,udf_func*)" -> "my_hash_search(const HASH*,const uchar*,size_t)"
"mysql_create_function(THD*,udf_func*)" -> "check_valid_path(const char*,size_t)"
"mysql_create_function(THD*,udf_func*)" -> "strlen(const char*)"
"mysql_create_function(THD*,udf_func*)" -> "THD::clear_current_stmt_binlog_format_row()"
"mysql_create_function(THD*,udf_func*)" -> "init_syms(udf_func*,char*)"
"mysql_create_function(THD*,udf_func*)" -> "memcpy(void*,const void*,size_t)"
"mysql_create_function(THD*,udf_func*)" -> "THD::set_current_stmt_binlog_format_row()"
"mysql_create_function(THD*,udf_func*)" -> "__errno_location()"
"mysql_create_function(THD*,udf_func*)" -> "inline_mysql_rwlock_wrlock(mysql_rwlock_t*)"
"mysql_create_function(THD*,udf_func*)" -> "_current_thd()"
"mysql_create_function(THD*,udf_func*)" -> "TABLE_LIST::init_one_table(const char*,size_t,const char*,size_t,const char*,thr_lock_type)"
"mysql_create_function(THD*,udf_func*)" -> "add_udf(LEX_STRING*,Item_result,char*,Item_udftype)"
"mysql_create_function(THD*,udf_func*)" -> "my_error(int,myf,...)"
"mysql_create_function(THD*,udf_func*)" -> "dlerror()"
"mysql_create_function(THD*,udf_func*)" -> "inline_mysql_rwlock_unlock(mysql_rwlock_t*)"
"mysql_create_function(THD*,udf_func*)" -> "strxnmov(char*,size_t,const char*,...)"
"mysql_create_function(THD*,udf_func*)" -> "strdup_root(MEM_ROOT*,const char*)"
"mysql_create_function(THD*,udf_func*)" -> "find_udf_dl(const char*)"
"mysql_create_function(THD*,udf_func*)" -> "THD::is_current_stmt_binlog_format_row() const"
"mysql_create_function(THD*,udf_func*)" -> "Statement::query_length() const"
"check_valid_path(const char*,size_t)" -> "my_strcspn(const CHARSET_INFO*,const char*,const char*,const char*)"
"init_syms(udf_func*,char*)" -> "__builtin_stpcpy(char*,const char*)"
"init_syms(udf_func*,char*)" -> "_current_thd()"
"init_syms(udf_func*,char*)" -> "__builtin_memcpy(void*,const void*,long unsigned int)"
"init_syms(udf_func*,char*)" -> "sql_print_warning(const char*,...)"
"init_syms(udf_func*,char*)" -> "dlsym(void*,const char*)"
"add_udf(LEX_STRING*,Item_result,char*,Item_udftype)" -> "alloc_root(MEM_ROOT*,size_t)"
"add_udf(LEX_STRING*,Item_result,char*,Item_udftype)" -> "memset(void*,int,size_t)"
"add_udf(LEX_STRING*,Item_result,char*,Item_udftype)" -> "my_hash_insert(HASH*,const uchar*)"
"st_ha_create_information::st_ha_create_information(const st_ha_create_information&)" -> "SQL_I_List<T>::SQL_I_List(const SQL_I_List<T>&) [with T = TABLE_LIST,SQL_I_List<T> = SQL_I_List<TABLE_LIST>]"
"SQL_I_List<T>::SQL_I_List(const SQL_I_List<T>&) [with T = TABLE_LIST,SQL_I_List<T> = SQL_I_List<TABLE_LIST>]" -> "Sql_alloc::Sql_alloc()"
"mysql_multi_update_prepare(THD*)" -> "setup_fields_with_no_wrap(THD*,Ref_ptr_array,List<Item>&,enum_mark_columns,List<Item>*,bool)"
"mysql_multi_update_prepare(THD*)" -> "Query_arena::is_stmt_prepare() const"
"mysql_multi_update_prepare(THD*)" -> "get_table_map(List<Item>*)"
"mysql_multi_update_prepare(THD*)" -> "Bounds_checked_array<Element_type>::Bounds_checked_array() [with Element_type = Item*]"
"mysql_multi_update_prepare(THD*)" -> "my_error(int,myf,...)"
"mysql_multi_update_prepare(THD*)" -> "check_fields(THD*,List<Item>&)"
"mysql_multi_update_prepare(THD*)" -> "setup_tables(THD*,Name_resolution_context*,List<TABLE_LIST>*,TABLE_LIST*,TABLE_LIST**,bool)"
"mysql_multi_update_prepare(THD*)" -> "unique_table(THD*,TABLE_LIST*,TABLE_LIST*,bool)"
"mysql_multi_update_prepare(THD*)" -> "read_lock_type_for_table(THD*,Query_tables_list*,TABLE_LIST*,bool)"
"mysql_multi_update_prepare(THD*)" -> "TABLE_LIST::placeholder()"
"mysql_multi_update_prepare(THD*)" -> "open_normal_and_derived_tables(THD*,TABLE_LIST*,uint)"
"mysql_multi_update_prepare(THD*)" -> "TABLE_LIST::check_single_table(TABLE_LIST**,table_map,TABLE_LIST*)"
"mysql_multi_update_prepare(THD*)" -> "update_non_unique_table_error(TABLE_LIST*,const char*,TABLE_LIST*)"
"mysql_multi_update_prepare(THD*)" -> "check_key_in_view(THD*,TABLE_LIST*)"
"mysql_multi_update_prepare(THD*)" -> "multi_update_check_table_access(THD*,TABLE_LIST*,table_map,bool*)"
"mysql_multi_update_prepare(THD*)" -> "unsafe_key_update(TABLE_LIST*,table_map)"
"setup_fields_with_no_wrap(THD*,Ref_ptr_array,List<Item>&,enum_mark_columns,List<Item>*,bool)" -> "setup_fields(THD*,Ref_ptr_array,List<Item>&,enum_mark_columns,List<Item>*,bool)"
"get_table_map(List<Item>*)" -> "List_iterator_fast<T>::List_iterator_fast(List<T>&) [with T = Item]"
"get_table_map(List<Item>*)" -> "List_iterator_fast<T>::operator++(int) [with T = Item]"
"check_fields(THD*,List<Item>&)" -> "THD::change_item_tree(Item**,Item*)"
"check_fields(THD*,List<Item>&)" -> "Simple_cstring::ptr() const"
"check_fields(THD*,List<Item>&)" -> "Item_field::Item_field(THD*,Item_field*)"
"check_fields(THD*,List<Item>&)" -> "List_iterator<T>::ref() [with T = Item]"
"check_fields(THD*,List<Item>&)" -> "List_iterator<T>::List_iterator(List<T>&) [with T = Item]"
"check_fields(THD*,List<Item>&)" -> "my_error(int,myf,...)"
"check_fields(THD*,List<Item>&)" -> "List_iterator<T>::operator++(int) [with T = Item]"
"multi_update_check_table_access(THD*,TABLE_LIST*,table_map,bool*)" -> "check_table_access(THD*,ulong,TABLE_LIST*,bool,uint,bool)"
"multi_update_check_table_access(THD*,TABLE_LIST*,table_map,bool*)" -> "multi_update_check_table_access(THD*,TABLE_LIST*,table_map,bool*)"
"unsafe_key_update(TABLE_LIST*,table_map)" -> "bitmap_is_set(const MY_BITMAP*,uint)"
"unsafe_key_update(TABLE_LIST*,table_map)" -> "partition_key_modified(TABLE*,const MY_BITMAP*)"
"unsafe_key_update(TABLE_LIST*,table_map)" -> "my_error(int,myf,...)"
"ha_show_status(THD*,handlerton*,ha_stat_type)" -> "plugin_foreach_with_mask(THD*,my_bool (*)(THD*,plugin_ref,void*),int,uint,void*)"
"ha_show_status(THD*,handlerton*,ha_stat_type)" -> "my_eof(THD*)"
"ha_show_status(THD*,handlerton*,ha_stat_type)" -> "Item_empty_string::Item_empty_string(const char*,uint,const CHARSET_INFO*)"
"ha_show_status(THD*,handlerton*,ha_stat_type)" -> "List<T>::List() [with T = Item]"
"ha_show_status(THD*,handlerton*,ha_stat_type)" -> "List<T>::push_back(T*) [with T = Item]"
"ha_show_status(THD*,handlerton*,ha_stat_type)" -> "stat_print(THD*,const char*,uint,const char*,uint,const char*,uint)"
"sp_update_routine(THD*,enum_sp_type,sp_name*,st_sp_chistics*)" -> "db_find_routine_aux(THD*,enum_sp_type,sp_name*,TABLE*)"
"sp_update_routine(THD*,enum_sp_type,sp_name*,st_sp_chistics*)" -> "write_bin_log(THD*,bool,const char*,ulong,bool)"
"sp_update_routine(THD*,enum_sp_type,sp_name*,st_sp_chistics*)" -> "_current_thd()"
"sp_update_routine(THD*,enum_sp_type,sp_name*,st_sp_chistics*)" -> "MYSQL_LOG::is_open()"
"sp_update_routine(THD*,enum_sp_type,sp_name*,st_sp_chistics*)" -> "Statement::query_length() const"
"sp_update_routine(THD*,enum_sp_type,sp_name*,st_sp_chistics*)" -> "THD::clear_current_stmt_binlog_format_row()"
"sp_update_routine(THD*,enum_sp_type,sp_name*,st_sp_chistics*)" -> "memcpy(void*,const void*,size_t)"
"sp_update_routine(THD*,enum_sp_type,sp_name*,st_sp_chistics*)" -> "lock_object_name(THD*,MDL_key::enum_mdl_namespace,const char*,const char*)"
"sp_update_routine(THD*,enum_sp_type,sp_name*,st_sp_chistics*)" -> "THD::set_current_stmt_binlog_format_row()"
"sp_update_routine(THD*,enum_sp_type,sp_name*,st_sp_chistics*)" -> "my_message(uint,const char*,myf)"
"sp_update_routine(THD*,enum_sp_type,sp_name*,st_sp_chistics*)" -> "THD::is_current_stmt_binlog_format_row() const"
"sp_update_routine(THD*,enum_sp_type,sp_name*,st_sp_chistics*)" -> "Statement::query() const"
"sp_update_routine(THD*,enum_sp_type,sp_name*,st_sp_chistics*)" -> "open_proc_table_for_update(THD*)"
"sp_update_routine(THD*,enum_sp_type,sp_name*,st_sp_chistics*)" -> "sp_cache_invalidate()"
"sp_update_routine(THD*,enum_sp_type,sp_name*,st_sp_chistics*)" -> "handler::ha_update_row(const uchar*,uchar*)"
"sp_update_routine(THD*,enum_sp_type,sp_name*,st_sp_chistics*)" -> "get_field(MEM_ROOT*,Field*)"
"sp_update_routine(THD*,enum_sp_type,sp_name*,st_sp_chistics*)" -> "Item_func_now_local::store_in(Field*)"
"mysql_alter_db(THD*,const char*,HA_CREATE_INFO*)" -> "build_table_filename(char*,size_t,const char*,const char*,const char*,uint)"
"mysql_alter_db(THD*,const char*,HA_CREATE_INFO*)" -> "query_error_code(THD*,bool)"
"mysql_alter_db(THD*,const char*,HA_CREATE_INFO*)" -> "write_db_opt(THD*,const char*,HA_CREATE_INFO*)"
"mysql_alter_db(THD*,const char*,HA_CREATE_INFO*)" -> "MYSQL_BIN_LOG::write_event(Log_event*)"
"mysql_alter_db(THD*,const char*,HA_CREATE_INFO*)" -> "Statement::query_length() const"
"mysql_alter_db(THD*,const char*,HA_CREATE_INFO*)" -> "Statement::query() const"
"mysql_alter_db(THD*,const char*,HA_CREATE_INFO*)" -> "my_ok(THD*,ulonglong,ulonglong,const char*)"
"mysql_alter_db(THD*,const char*,HA_CREATE_INFO*)" -> "lock_schema_name(THD*,const char*)"
"mysql_alter_db(THD*,const char*,HA_CREATE_INFO*)" -> "Query_log_event::Query_log_event(THD*,const char*,ulong,bool,bool,bool,int,bool)"
"mysql_alter_db(THD*,const char*,HA_CREATE_INFO*)" -> "MYSQL_LOG::is_open()"
"mysql_alter_db(THD*,const char*,HA_CREATE_INFO*)" -> "strlen(const char*)"
"mysql_alter_db(THD*,const char*,HA_CREATE_INFO*)" -> "strcmp(const char*,const char*)"
"write_db_opt(THD*,const char*,HA_CREATE_INFO*)" -> "inline_mysql_file_create(const char*,int,int,myf)"
"write_db_opt(THD*,const char*,HA_CREATE_INFO*)" -> "inline_mysql_file_close(File,myf)"
"write_db_opt(THD*,const char*,HA_CREATE_INFO*)" -> "inline_mysql_file_write(File,const uchar*,size_t,myf)"
"write_db_opt(THD*,const char*,HA_CREATE_INFO*)" -> "strxnmov(char*,size_t,const char*,...)"
"write_db_opt(THD*,const char*,HA_CREATE_INFO*)" -> "put_dbopt(const char*,HA_CREATE_INFO*)"
"mysql_install_plugin(THD*,const LEX_STRING*,const LEX_STRING*)" -> "plugin_add(MEM_ROOT*,const LEX_STRING*,const LEX_STRING*,int*,char**,int)"
"mysql_install_plugin(THD*,const LEX_STRING*,const LEX_STRING*)" -> "my_load_defaults(const char*,const char**,int*,char***,const char***)"
"mysql_install_plugin(THD*,const LEX_STRING*,const LEX_STRING*)" -> "plugin_initialize(st_plugin_int*)"
"mysql_install_plugin(THD*,const LEX_STRING*,const LEX_STRING*)" -> "TABLE_LIST::init_one_table(const char*,size_t,const char*,size_t,const char*,thr_lock_type)"
"mysql_install_plugin(THD*,const LEX_STRING*,const LEX_STRING*)" -> "push_warning_printf(THD*,Sql_condition::enum_warning_level,uint,const char*,...)"
"mysql_install_plugin(THD*,const LEX_STRING*,const LEX_STRING*)" -> "plugin_find_internal(const LEX_STRING*,int)"
"mysql_install_plugin(THD*,const LEX_STRING*,const LEX_STRING*)" -> "open_ltable(THD*,TABLE_LIST*,thr_lock_type,uint)"
"mysql_install_plugin(THD*,const LEX_STRING*,const LEX_STRING*)" -> "_current_thd()"
"mysql_install_plugin(THD*,const LEX_STRING*,const LEX_STRING*)" -> "reap_plugins()"
"mysql_install_plugin(THD*,const LEX_STRING*,const LEX_STRING*)" -> "inline_mysql_rwlock_wrlock(mysql_rwlock_t*)"
"mysql_install_plugin(THD*,const LEX_STRING*,const LEX_STRING*)" -> "memcpy(void*,const void*,size_t)"
"mysql_install_plugin(THD*,const LEX_STRING*,const LEX_STRING*)" -> "inline_mysql_rwlock_unlock(mysql_rwlock_t*)"
"mysql_install_plugin(THD*,const LEX_STRING*,const LEX_STRING*)" -> "inline_mysql_mutex_lock(mysql_mutex_t*)"
"mysql_install_plugin(THD*,const LEX_STRING*,const LEX_STRING*)" -> "free_defaults(char**)"
"mysql_install_plugin(THD*,const LEX_STRING*,const LEX_STRING*)" -> "mysql_audit_acquire_plugins(THD*,uint)"
"mysql_install_plugin(THD*,const LEX_STRING*,const LEX_STRING*)" -> "report_error(int,uint,...)"
"mysql_install_plugin(THD*,const LEX_STRING*,const LEX_STRING*)" -> "inline_mysql_mutex_unlock(mysql_mutex_t*)"
"mysql_install_plugin(THD*,const LEX_STRING*,const LEX_STRING*)" -> "my_error(int,myf,...)"
"mysql_install_plugin(THD*,const LEX_STRING*,const LEX_STRING*)" -> "TABLE::use_all_columns()"
"mysql_install_plugin(THD*,const LEX_STRING*,const LEX_STRING*)" -> "handler::ha_write_row(uchar*)"
"mysql_install_plugin(THD*,const LEX_STRING*,const LEX_STRING*)" -> "check_table_access(THD*,ulong,TABLE_LIST*,bool,uint,bool)"
"mysql_install_plugin(THD*,const LEX_STRING*,const LEX_STRING*)" -> "TABLE_LIST::TABLE_LIST()"
"plugin_add(MEM_ROOT*,const LEX_STRING*,const LEX_STRING*,int*,char**,int)" -> "strlen(const char*)"
"plugin_add(MEM_ROOT*,const LEX_STRING*,const LEX_STRING*,int*,char**,int)" -> "restore_pluginvar_names(sys_var*)"
"plugin_add(MEM_ROOT*,const LEX_STRING*,const LEX_STRING*,int*,char**,int)" -> "test_plugin_options(MEM_ROOT*,st_plugin_int*,int*,char**)"
"plugin_add(MEM_ROOT*,const LEX_STRING*,const LEX_STRING*,int*,char**,int)" -> "plugin_dl_del(const LEX_STRING*)"
"plugin_add(MEM_ROOT*,const LEX_STRING*,const LEX_STRING*,int*,char**,int)" -> "plugin_insert_or_reuse(st_plugin_int*)"
"plugin_add(MEM_ROOT*,const LEX_STRING*,const LEX_STRING*,int*,char**,int)" -> "memset(void*,int,size_t)"
"plugin_add(MEM_ROOT*,const LEX_STRING*,const LEX_STRING*,int*,char**,int)" -> "plugin_dl_add(const LEX_STRING*,int)"
"plugin_add(MEM_ROOT*,const LEX_STRING*,const LEX_STRING*,int*,char**,int)" -> "init_alloc_root(MEM_ROOT*,size_t,size_t)"
"plugin_add(MEM_ROOT*,const LEX_STRING*,const LEX_STRING*,int*,char**,int)" -> "strxnmov(char*,size_t,const char*,...)"
"plugin_add(MEM_ROOT*,const LEX_STRING*,const LEX_STRING*,int*,char**,int)" -> "report_error(int,uint,...)"
"plugin_add(MEM_ROOT*,const LEX_STRING*,const LEX_STRING*,int*,char**,int)" -> "mysql_del_sys_var_chain(sys_var*)"
"plugin_add(MEM_ROOT*,const LEX_STRING*,const LEX_STRING*,int*,char**,int)" -> "my_hash_insert(HASH*,const uchar*)"
"plugin_add(MEM_ROOT*,const LEX_STRING*,const LEX_STRING*,int*,char**,int)" -> "plugin_find_internal(const LEX_STRING*,int)"
"test_plugin_options(MEM_ROOT*,st_plugin_int*,int*,char**)" -> "sql_print_information(const char*,...)"
"test_plugin_options(MEM_ROOT*,st_plugin_int*,int*,char**)" -> "alloc_root(MEM_ROOT*,size_t)"
"test_plugin_options(MEM_ROOT*,st_plugin_int*,int*,char**)" -> "mysql_add_sys_var_chain(sys_var*)"
"test_plugin_options(MEM_ROOT*,st_plugin_int*,int*,char**)" -> "sql_print_error(const char*,...)"
"test_plugin_options(MEM_ROOT*,st_plugin_int*,int*,char**)" -> "strlen(const char*)"
"test_plugin_options(MEM_ROOT*,st_plugin_int*,int*,char**)" -> "memset(void*,int,size_t)"
"test_plugin_options(MEM_ROOT*,st_plugin_int*,int*,char**)" -> "strxmov(char*,const char*,...)"
"test_plugin_options(MEM_ROOT*,st_plugin_int*,int*,char**)" -> "handle_options(int*,char***,const my_option*,my_get_one_option)"
"test_plugin_options(MEM_ROOT*,st_plugin_int*,int*,char**)" -> "my_cleanup_options(const my_option*)"
"test_plugin_options(MEM_ROOT*,st_plugin_int*,int*,char**)" -> "sys_var_pluginvar::sys_var_pluginvar(sys_var_chain*,const char*,st_mysql_sys_var*)"
"test_plugin_options(MEM_ROOT*,st_plugin_int*,int*,char**)" -> "convert_dash_to_underscore(char*,int)"
"test_plugin_options(MEM_ROOT*,st_plugin_int*,int*,char**)" -> "construct_options(MEM_ROOT*,st_plugin_int*,my_option*)"
"test_plugin_options(MEM_ROOT*,st_plugin_int*,int*,char**)" -> "find_bookmark(const char*,const char*,int)"
"mysql_add_sys_var_chain(sys_var*)" -> "my_hash_delete(HASH*,uchar*)"
"mysql_add_sys_var_chain(sys_var*)" -> "my_hash_insert(HASH*,const uchar*)"
"mysql_add_sys_var_chain(sys_var*)" -> "fprintf(FILE*,const char*,...)"
"handle_options(int*,char***,const my_option*,my_get_one_option)" -> "my_handle_options(int*,char***,const my_option*,my_get_one_option,const char**)"
"my_handle_options(int*,char***,const my_option*,my_get_one_option,const char**)" -> "findopt(char*,uint,const my_option**,const char**)"
"my_handle_options(int*,char***,const my_option*,my_get_one_option,const char**)" -> "fprintf(FILE*,const char*,...)"
"my_handle_options(int*,char***,const my_option*,my_get_one_option,const char**)" -> "get_bool_argument(const my_option*,const char*,bool*)"
"my_handle_options(int*,char***,const my_option*,my_get_one_option,const char**)" -> "setval(const my_option*,void*,char*,my_bool)"
"my_handle_options(int*,char***,const my_option*,my_get_one_option,const char**)" -> "getopt_compare_strings(const char*,const char*,uint)"
"my_handle_options(int*,char***,const my_option*,my_get_one_option,const char**)" -> "strcend(const char*,pchar)"
"my_handle_options(int*,char***,const my_option*,my_get_one_option,const char**)" -> "strlen(const char*)"
"my_handle_options(int*,char***,const my_option*,my_get_one_option,const char**)" -> "strcmp(const char*,const char*)"
"my_handle_options(int*,char***,const my_option*,my_get_one_option,const char**)" -> "print_cmdline_password_warning()"
"my_handle_options(int*,char***,const my_option*,my_get_one_option,const char**)" -> "my_getopt_is_args_separator(const char*)"
"my_handle_options(int*,char***,const my_option*,my_get_one_option,const char**)" -> "check_struct_option(char*,char*)"
"my_handle_options(int*,char***,const my_option*,my_get_one_option,const char**)" -> "init_variables(const my_option*,init_func_p)"
"findopt(char*,uint,const my_option**,const char**)" -> "getopt_compare_strings(const char*,const char*,uint)"
"findopt(char*,uint,const my_option**,const char**)" -> "strcmp(const char*,const char*)"
"setval(const my_option*,void*,char*,my_bool)" -> "getopt_double(char*,const my_option*,int*)"
"setval(const my_option*,void*,char*,my_bool)" -> "getopt_ll(char*,const my_option*,int*)"
"setval(const my_option*,void*,char*,my_bool)" -> "strtoul(const char*,char**,int)"
"setval(const my_option*,void*,char*,my_bool)" -> "strtol(const char*,char**,int)"
"setval(const my_option*,void*,char*,my_bool)" -> "my_strdup(const char*,myf)"
"setval(const my_option*,void*,char*,my_bool)" -> "find_type(const char*,const TYPELIB*,unsigned int)"
"setval(const my_option*,void*,char*,my_bool)" -> "strlen(const char*)"
"setval(const my_option*,void*,char*,my_bool)" -> "getopt_ull(char*,const my_option*,int*)"
"setval(const my_option*,void*,char*,my_bool)" -> "my_free(void*)"
"setval(const my_option*,void*,char*,my_bool)" -> "find_set_from_flags(const TYPELIB*,unsigned int,my_ulonglong,my_ulonglong,const char*,unsigned int,char**,unsigned int*)"
"setval(const my_option*,void*,char*,my_bool)" -> "find_typeset(char*,TYPELIB*,int*)"
"setval(const my_option*,void*,char*,my_bool)" -> "get_bool_argument(const my_option*,const char*,bool*)"
"getopt_double(char*,const my_option*,int*)" -> "getopt_double_limit_value(double,const my_option*,my_bool*)"
"getopt_double(char*,const my_option*,int*)" -> "my_strtod(const char*,char**,int*)"
"getopt_double_limit_value(double,const my_option*,my_bool*)" -> "getopt_ulonglong2double(ulonglong)"
"getopt_ll(char*,const my_option*,int*)" -> "eval_num_suffix(char*,int*,char*)"
"getopt_ll(char*,const my_option*,int*)" -> "getopt_ll_limit_value(longlong,const my_option*,my_bool*)"
"eval_num_suffix(char*,int*,char*)" -> "__errno_location()"
"eval_num_suffix(char*,int*,char*)" -> "fprintf(FILE*,const char*,...)"
"eval_num_suffix(char*,int*,char*)" -> "strtol(const char*,char**,int)"
"getopt_ll_limit_value(longlong,const my_option*,my_bool*)" -> "max_of_int_range(int)"
"getopt_ll_limit_value(longlong,const my_option*,my_bool*)" -> "llstr(longlong,char*)"
"getopt_ull(char*,const my_option*,int*)" -> "eval_num_suffix(char*,int*,char*)"
"getopt_ull(char*,const my_option*,int*)" -> "getopt_ull_limit_value(ulonglong,const my_option*,my_bool*)"
"getopt_ull_limit_value(ulonglong,const my_option*,my_bool*)" -> "ullstr(longlong,char*)"
"getopt_ull_limit_value(ulonglong,const my_option*,my_bool*)" -> "max_of_int_range(int)"
"print_cmdline_password_warning()" -> "fflush(FILE*)"
"print_cmdline_password_warning()" -> "__builtin_fwrite(const void*,size_t,size_t,FILE*)"
"check_struct_option(char*,char*)" -> "strcend(const char*,pchar)"
"check_struct_option(char*,char*)" -> "strmake(char*,const char*,size_t)"
"my_cleanup_options(const my_option*)" -> "init_variables(const my_option*,init_func_p)"
"sys_var_pluginvar::sys_var_pluginvar(sys_var_chain*,const char*,st_mysql_sys_var*)" -> "pluginvar_show_type(st_mysql_sys_var*)"
"sys_var_pluginvar::sys_var_pluginvar(sys_var_chain*,const char*,st_mysql_sys_var*)" -> "sys_var::sys_var(sys_var_chain*,const char*,const char*,int,ptrdiff_t,int,get_opt_arg_type,SHOW_TYPE,longlong,PolyLock*,sys_var::binlog_status_enum,sys_var::on_check_function,sys_var::on_update_function,const char*,int)"
"sys_var::sys_var(sys_var_chain*,const char*,const char*,int,ptrdiff_t,int,get_opt_arg_type,SHOW_TYPE,longlong,PolyLock*,sys_var::binlog_status_enum,sys_var::on_check_function,sys_var::on_update_function,const char*,int)" -> "strlen(const char*)"
"sys_var::sys_var(sys_var_chain*,const char*,const char*,int,ptrdiff_t,int,get_opt_arg_type,SHOW_TYPE,longlong,PolyLock*,sys_var::binlog_status_enum,sys_var::on_check_function,sys_var::on_update_function,const char*,int)" -> "memset(void*,int,size_t)"
"sys_var::sys_var(sys_var_chain*,const char*,const char*,int,ptrdiff_t,int,get_opt_arg_type,SHOW_TYPE,longlong,PolyLock*,sys_var::binlog_status_enum,sys_var::on_check_function,sys_var::on_update_function,const char*,int)" -> "sys_var::global_var_ptr()"
"construct_options(MEM_ROOT*,st_plugin_int*,my_option*)" -> "strxnmov(char*,size_t,const char*,...)"
"construct_options(MEM_ROOT*,st_plugin_int*,my_option*)" -> "sql_print_warning(const char*,...)"
"construct_options(MEM_ROOT*,st_plugin_int*,my_option*)" -> "find_bookmark(const char*,const char*,int)"
"construct_options(MEM_ROOT*,st_plugin_int*,my_option*)" -> "sql_print_error(const char*,...)"
"construct_options(MEM_ROOT*,st_plugin_int*,my_option*)" -> "strcpy(char*,const char*)"
"construct_options(MEM_ROOT*,st_plugin_int*,my_option*)" -> "strlen(const char*)"
"construct_options(MEM_ROOT*,st_plugin_int*,my_option*)" -> "strxmov(char*,const char*,...)"
"construct_options(MEM_ROOT*,st_plugin_int*,my_option*)" -> "memdup_root(MEM_ROOT*,const void*,size_t)"
"construct_options(MEM_ROOT*,st_plugin_int*,my_option*)" -> "plugin_opt_set_limits(my_option*,const st_mysql_sys_var*)"
"construct_options(MEM_ROOT*,st_plugin_int*,my_option*)" -> "alloc_root(MEM_ROOT*,size_t)"
"construct_options(MEM_ROOT*,st_plugin_int*,my_option*)" -> "register_var(const char*,const char*,int)"
"construct_options(MEM_ROOT*,st_plugin_int*,my_option*)" -> "convert_underscore_to_dash(char*,int)"
"find_bookmark(const char*,const char*,int)" -> "memcpy(void*,const void*,size_t)"
"find_bookmark(const char*,const char*,int)" -> "__builtin_alloca(long unsigned int)"
"find_bookmark(const char*,const char*,int)" -> "strlen(const char*)"
"find_bookmark(const char*,const char*,int)" -> "my_hash_search(const HASH*,const uchar*,size_t)"
"find_bookmark(const char*,const char*,int)" -> "strxmov(char*,const char*,...)"
"plugin_opt_set_limits(my_option*,const st_mysql_sys_var*)" -> "getopt_double2ulonglong(double)"
"register_var(const char*,const char*,int)" -> "my_realloc(void*,size_t,myf)"
"register_var(const char*,const char*,int)" -> "memset(void*,int,size_t)"
"register_var(const char*,const char*,int)" -> "__builtin_fwrite(const void*,size_t,size_t,FILE*)"
"register_var(const char*,const char*,int)" -> "strlen(const char*)"
"register_var(const char*,const char*,int)" -> "find_bookmark(const char*,const char*,int)"
"register_var(const char*,const char*,int)" -> "strxmov(char*,const char*,...)"
"register_var(const char*,const char*,int)" -> "memcpy(void*,const void*,size_t)"
"register_var(const char*,const char*,int)" -> "__builtin_alloca(long unsigned int)"
"register_var(const char*,const char*,int)" -> "my_hash_insert(HASH*,const uchar*)"
"register_var(const char*,const char*,int)" -> "alloc_root(MEM_ROOT*,size_t)"
"plugin_insert_or_reuse(st_plugin_int*)" -> "memcpy(void*,const void*,size_t)"
"plugin_insert_or_reuse(st_plugin_int*)" -> "insert_dynamic(DYNAMIC_ARRAY*,const void*)"
"plugin_insert_or_reuse(st_plugin_int*)" -> "memdup_root(MEM_ROOT*,const void*,size_t)"
"plugin_dl_add(const LEX_STRING*,int)" -> "plugin_dl_find(const LEX_STRING*)"
"plugin_dl_add(const LEX_STRING*,int)" -> "check_string_char_length(LEX_STRING*,const char*,uint,const CHARSET_INFO*,bool)"
"plugin_dl_add(const LEX_STRING*,int)" -> "memcpy(void*,const void*,size_t)"
"plugin_dl_add(const LEX_STRING*,int)" -> "my_snprintf(char*,size_t,const char*,...)"
"plugin_dl_add(const LEX_STRING*,int)" -> "unpack_filename(char*,const char*)"
"plugin_dl_add(const LEX_STRING*,int)" -> "check_valid_path(const char*,size_t)"
"plugin_dl_add(const LEX_STRING*,int)" -> "strxnmov(char*,size_t,const char*,...)"
"plugin_dl_add(const LEX_STRING*,int)" -> "__errno_location()"
"plugin_dl_add(const LEX_STRING*,int)" -> "dlopen(const char*,int)"
"plugin_dl_add(const LEX_STRING*,int)" -> "dlsym(void*,const char*)"
"plugin_dl_add(const LEX_STRING*,int)" -> "memset(void*,int,size_t)"
"plugin_dl_add(const LEX_STRING*,int)" -> "my_malloc(size_t,myf)"
"plugin_dl_add(const LEX_STRING*,int)" -> "plugin_dl_insert_or_reuse(st_plugin_dl*)"
"plugin_dl_add(const LEX_STRING*,int)" -> "strncmp(const char*,const char*,size_t)"
"plugin_dl_add(const LEX_STRING*,int)" -> "free_plugin_mem(st_plugin_dl*)"
"plugin_dl_add(const LEX_STRING*,int)" -> "copy_and_convert(char*,uint32,const CHARSET_INFO*,const char*,uint32,const CHARSET_INFO*,uint*)"
"plugin_dl_add(const LEX_STRING*,int)" -> "report_error(int,uint,...)"
"plugin_dl_add(const LEX_STRING*,int)" -> "std::min(const _Tp&,const _Tp&) [with _Tp = long unsigned int]"
"plugin_dl_add(const LEX_STRING*,int)" -> "dlerror()"
"plugin_dl_add(const LEX_STRING*,int)" -> "strlen(const char*)"
"plugin_dl_insert_or_reuse(st_plugin_dl*)" -> "memcpy(void*,const void*,size_t)"
"plugin_dl_insert_or_reuse(st_plugin_dl*)" -> "insert_dynamic(DYNAMIC_ARRAY*,const void*)"
"plugin_dl_insert_or_reuse(st_plugin_dl*)" -> "memdup_root(MEM_ROOT*,const void*,size_t)"
"report_error(int,uint,...)" -> "error_log_print(loglevel,const char*,__va_list_tag*)"
"report_error(int,uint,...)" -> "__builtin_va_end(__va_list_tag*)"
"report_error(int,uint,...)" -> "_current_thd()"
"report_error(int,uint,...)" -> "__builtin_va_start(__va_list_tag*,...)"
"report_error(int,uint,...)" -> "my_printv_error(uint,const char*,myf,__va_list_tag*)"
"my_load_defaults(const char*,const char**,int*,char***,const char***)" -> "my_default_get_login_file(char*,size_t)"
"my_load_defaults(const char*,const char**,int*,char***,const char***)" -> "my_getopt_is_args_separator(const char*)"
"my_load_defaults(const char*,const char**,int*,char***,const char***)" -> "alloc_root(MEM_ROOT*,size_t)"
"my_load_defaults(const char*,const char**,int*,char***,const char***)" -> "delete_dynamic(DYNAMIC_ARRAY*)"
"my_load_defaults(const char*,const char**,int*,char***,const char***)" -> "strcmp(const char*,const char*)"
"my_load_defaults(const char*,const char**,int*,char***,const char***)" -> "memcpy(void*,const void*,size_t)"
"my_load_defaults(const char*,const char**,int*,char***,const char***)" -> "free_root(MEM_ROOT*,myf)"
"my_load_defaults(const char*,const char**,int*,char***,const char***)" -> "init_dynamic_array2(DYNAMIC_ARRAY*,uint,void*,uint,uint)"
"my_load_defaults(const char*,const char**,int*,char***,const char***)" -> "__builtin_fwrite(const void*,size_t,size_t,FILE*)"
"my_load_defaults(const char*,const char**,int*,char***,const char***)" -> "my_search_option_files(const char*,int*,char***,uint*,Process_option_func,void*,const char**)"
"my_load_defaults(const char*,const char**,int*,char***,const char***)" -> "printf(const char*,...)"
"my_load_defaults(const char*,const char**,int*,char***,const char***)" -> "init_alloc_root(MEM_ROOT*,size_t,size_t)"
"my_load_defaults(const char*,const char**,int*,char***,const char***)" -> "init_default_directories(MEM_ROOT*)"
"my_load_defaults(const char*,const char**,int*,char***,const char***)" -> "set_args_separator(char**)"
"my_load_defaults(const char*,const char**,int*,char***,const char***)" -> "exit(int)"
"my_load_defaults(const char*,const char**,int*,char***,const char***)" -> "puts(const char*)"
"my_default_get_login_file(char*,size_t)" -> "memset(void*,int,size_t)"
"my_default_get_login_file(char*,size_t)" -> "my_snprintf(char*,size_t,const char*,...)"
"my_default_get_login_file(char*,size_t)" -> "getenv(const char*)"
"my_search_option_files(const char*,int*,char***,uint*,Process_option_func,void*,const char**)" -> "strlen(const char*)"
"my_search_option_files(const char*,int*,char***,uint*,Process_option_func,void*,const char**)" -> "memcpy(void*,const void*,size_t)"
"my_search_option_files(const char*,int*,char***,uint*,Process_option_func,void*,const char**)" -> "get_defaults_options(int,char**,char**,char**,char**,char**)"
"my_search_option_files(const char*,int*,char***,uint*,Process_option_func,void*,const char**)" -> "alloc_root(MEM_ROOT*,size_t)"
"my_search_option_files(const char*,int*,char***,uint*,Process_option_func,void*,const char**)" -> "__builtin_fwrite(const void*,size_t,size_t,FILE*)"
"my_search_option_files(const char*,int*,char***,uint*,Process_option_func,void*,const char**)" -> "fn_expand(const char*,char*)"
"my_search_option_files(const char*,int*,char***,uint*,Process_option_func,void*,const char**)" -> "search_default_file_with_ext(Process_option_func,void*,const char*,const char*,const char*,int)"
"my_search_option_files(const char*,int*,char***,uint*,Process_option_func,void*,const char**)" -> "fprintf(FILE*,const char*,...)"
"my_search_option_files(const char*,int*,char***,uint*,Process_option_func,void*,const char**)" -> "search_default_file(Process_option_func,void*,const char*,const char*)"
"my_search_option_files(const char*,int*,char***,uint*,Process_option_func,void*,const char**)" -> "getenv(const char*)"
"my_search_option_files(const char*,int*,char***,uint*,Process_option_func,void*,const char**)" -> "dirname_length(const char*)"
"get_defaults_options(int,char**,char**,char**,char**,char**)" -> "is_prefix(const char*,const char*)"
"fn_expand(const char*,char*)" -> "fn_format(char*,const char*,const char*,const char*,uint)"
"fn_expand(const char*,char*)" -> "my_getwd(char*,size_t,myf)"
"search_default_file_with_ext(Process_option_func,void*,const char*,const char*,const char*,int)" -> "strchr(char*,int)"
"search_default_file_with_ext(Process_option_func,void*,const char*,const char*,const char*,int)" -> "strlen(const char*)"
"search_default_file_with_ext(Process_option_func,void*,const char*,const char*,const char*,int)" -> "fn_ext(const char*)"
"search_default_file_with_ext(Process_option_func,void*,const char*,const char*,const char*,int)" -> "search_default_file_with_ext(Process_option_func,void*,const char*,const char*,const char*,int)"
"search_default_file_with_ext(Process_option_func,void*,const char*,const char*,const char*,int)" -> "inline_mysql_file_fopen(PSI_file_key,const char*,uint,const char*,int,myf)"
"search_default_file_with_ext(Process_option_func,void*,const char*,const char*,const char*,int)" -> "remove_end_comment(char*)"
"search_default_file_with_ext(Process_option_func,void*,const char*,const char*,const char*,int)" -> "__builtin_memcpy(void*,const void*,long unsigned int)"
"search_default_file_with_ext(Process_option_func,void*,const char*,const char*,const char*,int)" -> "get_argument(const char*,size_t,char*,char*,uint)"
"search_default_file_with_ext(Process_option_func,void*,const char*,const char*,const char*,int)" -> "inline_mysql_file_fclose(const char*,uint,MYSQL_FILE*,myf)"
"search_default_file_with_ext(Process_option_func,void*,const char*,const char*,const char*,int)" -> "strnmov(char*,const char*,size_t)"
"search_default_file_with_ext(Process_option_func,void*,const char*,const char*,const char*,int)" -> "__builtin_strcpy(char*,const char*)"
"search_default_file_with_ext(Process_option_func,void*,const char*,const char*,const char*,int)" -> "strend(const char*)"
"search_default_file_with_ext(Process_option_func,void*,const char*,const char*,const char*,int)" -> "strncmp(const char*,const char*,size_t)"
"search_default_file_with_ext(Process_option_func,void*,const char*,const char*,const char*,int)" -> "my_dir(const char*,myf)"
"search_default_file_with_ext(Process_option_func,void*,const char*,const char*,const char*,int)" -> "my_dirend(MY_DIR*)"
"search_default_file_with_ext(Process_option_func,void*,const char*,const char*,const char*,int)" -> "strcmp(const char*,const char*)"
"search_default_file_with_ext(Process_option_func,void*,const char*,const char*,const char*,int)" -> "strxmov(char*,const char*,...)"
"search_default_file_with_ext(Process_option_func,void*,const char*,const char*,const char*,int)" -> "fprintf(FILE*,const char*,...)"
"search_default_file_with_ext(Process_option_func,void*,const char*,const char*,const char*,int)" -> "convert_dirname(char*,const char*,const char*)"
"search_default_file_with_ext(Process_option_func,void*,const char*,const char*,const char*,int)" -> "fn_format(char*,const char*,const char*,const char*,uint)"
"search_default_file_with_ext(Process_option_func,void*,const char*,const char*,const char*,int)" -> "check_file_permissions(const char*)"
"search_default_file_with_ext(Process_option_func,void*,const char*,const char*,const char*,int)" -> "mysql_file_getline(char*,int,MYSQL_FILE*)"
"search_default_file_with_ext(Process_option_func,void*,const char*,const char*,const char*,int)" -> "strmake(char*,const char*,size_t)"
"inline_mysql_file_fopen(PSI_file_key,const char*,uint,const char*,int,myf)" -> "my_malloc(size_t,myf)"
"inline_mysql_file_fopen(PSI_file_key,const char*,uint,const char*,int,myf)" -> "my_fopen(const char*,int,myf)"
"inline_mysql_file_fopen(PSI_file_key,const char*,uint,const char*,int,myf)" -> "my_free(void*)"
"inline_mysql_file_fopen(PSI_file_key,const char*,uint,const char*,int,myf)" -> "__builtin_expect(long int,long int)"
"get_argument(const char*,size_t,char*,char*,uint)" -> "strlen(const char*)"
"get_argument(const char*,size_t,char*,char*,uint)" -> "fprintf(FILE*,const char*,...)"
"inline_mysql_file_fclose(const char*,uint,MYSQL_FILE*,myf)" -> "my_free(void*)"
"inline_mysql_file_fclose(const char*,uint,MYSQL_FILE*,myf)" -> "__builtin_expect(long int,long int)"
"inline_mysql_file_fclose(const char*,uint,MYSQL_FILE*,myf)" -> "my_fclose(FILE*,myf)"
"check_file_permissions(const char*)" -> "my_stat(const char*,stat*,myf)"
"check_file_permissions(const char*)" -> "fprintf(FILE*,const char*,...)"
"mysql_file_getline(char*,int,MYSQL_FILE*)" -> "inline_mysql_file_fgets(const char*,uint,char*,int,MYSQL_FILE*)"
"mysql_file_getline(char*,int,MYSQL_FILE*)" -> "inline_mysql_file_fread(const char*,uint,MYSQL_FILE*,uchar*,size_t,myf)"
"mysql_file_getline(char*,int,MYSQL_FILE*)" -> "my_aes_decrypt(const unsigned char*,uint32,unsigned char*,const unsigned char*,uint32,my_aes_opmode,const unsigned char*)"
"mysql_file_getline(char*,int,MYSQL_FILE*)" -> "inline_mysql_file_ftell(const char*,uint,MYSQL_FILE*,myf)"
"mysql_file_getline(char*,int,MYSQL_FILE*)" -> "inline_mysql_file_fseek(const char*,uint,MYSQL_FILE*,my_off_t,int,myf)"
"inline_mysql_file_fgets(const char*,uint,char*,int,MYSQL_FILE*)" -> "fgets(char*,int,FILE*)"
"inline_mysql_file_fgets(const char*,uint,char*,int,MYSQL_FILE*)" -> "__builtin_expect(long int,long int)"
"inline_mysql_file_fgets(const char*,uint,char*,int,MYSQL_FILE*)" -> "strlen(const char*)"
"inline_mysql_file_fread(const char*,uint,MYSQL_FILE*,uchar*,size_t,myf)" -> "my_fread(FILE*,uchar*,size_t,myf)"
"inline_mysql_file_fread(const char*,uint,MYSQL_FILE*,uchar*,size_t,myf)" -> "__builtin_expect(long int,long int)"
"my_aes_decrypt(const unsigned char*,uint32,unsigned char*,const unsigned char*,uint32,my_aes_opmode,const unsigned char*)" -> "MyCipherCtx<DIR>::SetKey(const unsigned char*,uint,const unsigned char*) [with TaoCrypt::CipherDir DIR = (TaoCrypt::CipherDir)1u,uint = unsigned int]"
"my_aes_decrypt(const unsigned char*,uint32,unsigned char*,const unsigned char*,uint32,my_aes_opmode,const unsigned char*)" -> "memcpy(void*,const void*,size_t)"
"my_aes_decrypt(const unsigned char*,uint32,unsigned char*,const unsigned char*,uint32,my_aes_opmode,const unsigned char*)" -> "MyCipherCtx<DIR>::MyCipherCtx(my_aes_opmode) [with TaoCrypt::CipherDir DIR = (TaoCrypt::CipherDir)1u]"
"my_aes_decrypt(const unsigned char*,uint32,unsigned char*,const unsigned char*,uint32,my_aes_opmode,const unsigned char*)" -> "my_aes_create_key(const unsigned char*,uint,uint8*,my_aes_opmode)"
"my_aes_decrypt(const unsigned char*,uint32,unsigned char*,const unsigned char*,uint32,my_aes_opmode,const unsigned char*)" -> "MyCipherCtx<DIR>::Process(unsigned char*,const unsigned char*,uint) [with TaoCrypt::CipherDir DIR = (TaoCrypt::CipherDir)1u,uint = unsigned int]"
"MyCipherCtx<DIR>::SetKey(const unsigned char*,uint,const unsigned char*) [with TaoCrypt::CipherDir DIR = (TaoCrypt::CipherDir)1u,uint = unsigned int]" -> "MODE>::SetKey(const byte*,TaoCrypt::word32,const byte*) [with TaoCrypt::CipherDir DIR = (TaoCrypt::CipherDir)1u,T = TaoCrypt::AES,TaoCrypt::Mode MODE = (TaoCrypt::Mode)1u,TaoCrypt::byte = unsigned char,TaoCrypt::word32 = unsigned int]"
"MyCipherCtx<DIR>::SetKey(const unsigned char*,uint,const unsigned char*) [with TaoCrypt::CipherDir DIR = (TaoCrypt::CipherDir)1u,uint = unsigned int]" -> "MODE>::SetKey(const byte*,TaoCrypt::word32) [with TaoCrypt::CipherDir DIR = (TaoCrypt::CipherDir)1u,T = TaoCrypt::AES,TaoCrypt::Mode MODE = (TaoCrypt::Mode)0u,TaoCrypt::byte = unsigned char,TaoCrypt::word32 = unsigned int]"
"MODE>::SetKey(const byte*,TaoCrypt::word32,const byte*) [with TaoCrypt::CipherDir DIR = (TaoCrypt::CipherDir)1u,T = TaoCrypt::AES,TaoCrypt::Mode MODE = (TaoCrypt::Mode)1u,TaoCrypt::byte = unsigned char,TaoCrypt::word32 = unsigned int]" -> "TaoCrypt::AES::SetKey(const byte*,TaoCrypt::word32,TaoCrypt::CipherDir)"
"MODE>::SetKey(const byte*,TaoCrypt::word32,const byte*) [with TaoCrypt::CipherDir DIR = (TaoCrypt::CipherDir)1u,T = TaoCrypt::AES,TaoCrypt::Mode MODE = (TaoCrypt::Mode)1u,TaoCrypt::byte = unsigned char,TaoCrypt::word32 = unsigned int]" -> "TaoCrypt::AES::SetIV(const byte*)"
"TaoCrypt::AES::SetKey(const byte*,TaoCrypt::word32,TaoCrypt::CipherDir)" -> "TaoCrypt::GetUserKey(TaoCrypt::ByteOrder,T*,TaoCrypt::word32,const byte*,TaoCrypt::word32) [with T = unsigned int,TaoCrypt::word32 = unsigned int,TaoCrypt::byte = unsigned char]"
"TaoCrypt::GetUserKey(TaoCrypt::ByteOrder,T*,TaoCrypt::word32,const byte*,TaoCrypt::word32) [with T = unsigned int,TaoCrypt::word32 = unsigned int,TaoCrypt::byte = unsigned char]" -> "memcpy(void*,const void*,size_t)"
"TaoCrypt::GetUserKey(TaoCrypt::ByteOrder,T*,TaoCrypt::word32,const byte*,TaoCrypt::word32) [with T = unsigned int,TaoCrypt::word32 = unsigned int,TaoCrypt::byte = unsigned char]" -> "memset(void*,int,size_t)"
"TaoCrypt::GetUserKey(TaoCrypt::ByteOrder,T*,TaoCrypt::word32,const byte*,TaoCrypt::word32) [with T = unsigned int,TaoCrypt::word32 = unsigned int,TaoCrypt::byte = unsigned char]" -> "TaoCrypt::RoundUpToMultipleOf(T,T) [with T = unsigned int]"
"TaoCrypt::GetUserKey(TaoCrypt::ByteOrder,T*,TaoCrypt::word32,const byte*,TaoCrypt::word32) [with T = unsigned int,TaoCrypt::word32 = unsigned int,TaoCrypt::byte = unsigned char]" -> "TaoCrypt::ByteReverseIf(T*,const T*,TaoCrypt::word32,TaoCrypt::ByteOrder) [with T = unsigned int,TaoCrypt::word32 = unsigned int]"
"TaoCrypt::RoundUpToMultipleOf(T,T) [with T = unsigned int]" -> "TaoCrypt::RoundDownToMultipleOf(T,T) [with T = unsigned int]"
"TaoCrypt::RoundDownToMultipleOf(T,T) [with T = unsigned int]" -> "TaoCrypt::ModPowerOf2(T1,T2) [with T1 = unsigned int,T2 = unsigned int]"
"TaoCrypt::RoundDownToMultipleOf(T,T) [with T = unsigned int]" -> "TaoCrypt::IsPowerOf2(T) [with T = unsigned int]"
"TaoCrypt::AES::SetIV(const byte*)" -> "memcpy(void*,const void*,size_t)"
"MODE>::SetKey(const byte*,TaoCrypt::word32) [with TaoCrypt::CipherDir DIR = (TaoCrypt::CipherDir)1u,T = TaoCrypt::AES,TaoCrypt::Mode MODE = (TaoCrypt::Mode)0u,TaoCrypt::byte = unsigned char,TaoCrypt::word32 = unsigned int]" -> "TaoCrypt::AES::SetKey(const byte*,TaoCrypt::word32,TaoCrypt::CipherDir)"
"MyCipherCtx<DIR>::MyCipherCtx(my_aes_opmode) [with TaoCrypt::CipherDir DIR = (TaoCrypt::CipherDir)1u]" -> "MODE>::BlockCipher() [with TaoCrypt::CipherDir DIR = (TaoCrypt::CipherDir)1u,T = TaoCrypt::AES,TaoCrypt::Mode MODE = (TaoCrypt::Mode)0u]"
"MyCipherCtx<DIR>::MyCipherCtx(my_aes_opmode) [with TaoCrypt::CipherDir DIR = (TaoCrypt::CipherDir)1u]" -> "MODE>::BlockCipher() [with TaoCrypt::CipherDir DIR = (TaoCrypt::CipherDir)1u,T = TaoCrypt::AES,TaoCrypt::Mode MODE = (TaoCrypt::Mode)1u]"
"MODE>::BlockCipher() [with TaoCrypt::CipherDir DIR = (TaoCrypt::CipherDir)1u,T = TaoCrypt::AES,TaoCrypt::Mode MODE = (TaoCrypt::Mode)0u]" -> "TaoCrypt::AES::AES(TaoCrypt::CipherDir,TaoCrypt::Mode)"
"TaoCrypt::AES::AES(TaoCrypt::CipherDir,TaoCrypt::Mode)" -> "TaoCrypt::Mode_BASE::Mode_BASE(int,TaoCrypt::CipherDir,TaoCrypt::Mode)"
"TaoCrypt::Mode_BASE::Mode_BASE(int,TaoCrypt::CipherDir,TaoCrypt::Mode)" -> "TaoCrypt::virtual_base::virtual_base()"
"MODE>::BlockCipher() [with TaoCrypt::CipherDir DIR = (TaoCrypt::CipherDir)1u,T = TaoCrypt::AES,TaoCrypt::Mode MODE = (TaoCrypt::Mode)1u]" -> "TaoCrypt::AES::AES(TaoCrypt::CipherDir,TaoCrypt::Mode)"
"my_aes_create_key(const unsigned char*,uint,uint8*,my_aes_opmode)" -> "memset(void*,int,size_t)"
"MyCipherCtx<DIR>::Process(unsigned char*,const unsigned char*,uint) [with TaoCrypt::CipherDir DIR = (TaoCrypt::CipherDir)1u,uint = unsigned int]" -> "MODE>::Process(TaoCrypt::byte*,const byte*,TaoCrypt::word32) [with TaoCrypt::CipherDir DIR = (TaoCrypt::CipherDir)1u,T = TaoCrypt::AES,TaoCrypt::Mode MODE = (TaoCrypt::Mode)1u,TaoCrypt::byte = unsigned char,TaoCrypt::word32 = unsigned int]"
"MyCipherCtx<DIR>::Process(unsigned char*,const unsigned char*,uint) [with TaoCrypt::CipherDir DIR = (TaoCrypt::CipherDir)1u,uint = unsigned int]" -> "MODE>::Process(TaoCrypt::byte*,const byte*,TaoCrypt::word32) [with TaoCrypt::CipherDir DIR = (TaoCrypt::CipherDir)1u,T = TaoCrypt::AES,TaoCrypt::Mode MODE = (TaoCrypt::Mode)0u,TaoCrypt::byte = unsigned char,TaoCrypt::word32 = unsigned int]"
"MODE>::Process(TaoCrypt::byte*,const byte*,TaoCrypt::word32) [with TaoCrypt::CipherDir DIR = (TaoCrypt::CipherDir)1u,T = TaoCrypt::AES,TaoCrypt::Mode MODE = (TaoCrypt::Mode)1u,TaoCrypt::byte = unsigned char,TaoCrypt::word32 = unsigned int]" -> "TaoCrypt::Mode_BASE::Process(TaoCrypt::byte*,const byte*,TaoCrypt::word32)"
"TaoCrypt::Mode_BASE::Process(TaoCrypt::byte*,const byte*,TaoCrypt::word32)" -> "TaoCrypt::Mode_BASE::CBC_Decrypt(TaoCrypt::byte*,const byte*,TaoCrypt::word32)"
"TaoCrypt::Mode_BASE::Process(TaoCrypt::byte*,const byte*,TaoCrypt::word32)" -> "TaoCrypt::Mode_BASE::CBC_Encrypt(TaoCrypt::byte*,const byte*,TaoCrypt::word32)"
"TaoCrypt::Mode_BASE::Process(TaoCrypt::byte*,const byte*,TaoCrypt::word32)" -> "TaoCrypt::Mode_BASE::ECB_Process(TaoCrypt::byte*,const byte*,TaoCrypt::word32)"
"TaoCrypt::Mode_BASE::CBC_Decrypt(TaoCrypt::byte*,const byte*,TaoCrypt::word32)" -> "memcpy(void*,const void*,size_t)"
"TaoCrypt::Mode_BASE::CBC_Decrypt(TaoCrypt::byte*,const byte*,TaoCrypt::word32)" -> "TaoCrypt::xorbuf(TaoCrypt::byte*,const byte*,unsigned int)"
"TaoCrypt::xorbuf(TaoCrypt::byte*,const byte*,unsigned int)" -> "TaoCrypt::XorWords(TaoCrypt::word*,const word*,unsigned int)"
"TaoCrypt::Mode_BASE::CBC_Encrypt(TaoCrypt::byte*,const byte*,TaoCrypt::word32)" -> "TaoCrypt::xorbuf(TaoCrypt::byte*,const byte*,unsigned int)"
"TaoCrypt::Mode_BASE::CBC_Encrypt(TaoCrypt::byte*,const byte*,TaoCrypt::word32)" -> "memcpy(void*,const void*,size_t)"
"MODE>::Process(TaoCrypt::byte*,const byte*,TaoCrypt::word32) [with TaoCrypt::CipherDir DIR = (TaoCrypt::CipherDir)1u,T = TaoCrypt::AES,TaoCrypt::Mode MODE = (TaoCrypt::Mode)0u,TaoCrypt::byte = unsigned char,TaoCrypt::word32 = unsigned int]" -> "TaoCrypt::Mode_BASE::Process(TaoCrypt::byte*,const byte*,TaoCrypt::word32)"
"inline_mysql_file_ftell(const char*,uint,MYSQL_FILE*,myf)" -> "my_ftell(FILE*,myf)"
"inline_mysql_file_ftell(const char*,uint,MYSQL_FILE*,myf)" -> "__builtin_expect(long int,long int)"
"inline_mysql_file_fseek(const char*,uint,MYSQL_FILE*,my_off_t,int,myf)" -> "__builtin_expect(long int,long int)"
"inline_mysql_file_fseek(const char*,uint,MYSQL_FILE*,my_off_t,int,myf)" -> "my_fseek(FILE*,my_off_t,int,myf)"
"search_default_file(Process_option_func,void*,const char*,const char*)" -> "search_default_file_with_ext(Process_option_func,void*,const char*,const char*,const char*,int)"
"search_default_file(Process_option_func,void*,const char*,const char*)" -> "fn_ext(const char*)"
"init_default_directories(MEM_ROOT*)" -> "alloc_root(MEM_ROOT*,size_t)"
"init_default_directories(MEM_ROOT*)" -> "memset(void*,int,size_t)"
"init_default_directories(MEM_ROOT*)" -> "getenv(const char*)"
"init_default_directories(MEM_ROOT*)" -> "add_directory(MEM_ROOT*,const char*,const char**)"
"add_directory(MEM_ROOT*,const char*,const char**)" -> "strmake_root(MEM_ROOT*,const char*,size_t)"
"add_directory(MEM_ROOT*,const char*,const char**)" -> "normalize_dirname(char*,const char*)"
"add_directory(MEM_ROOT*,const char*,const char**)" -> "array_append_string_unique(const char*,const char**,size_t)"
"plugin_initialize(st_plugin_int*)" -> "add_status_vars(SHOW_VAR*)"
"plugin_initialize(st_plugin_int*)" -> "sql_print_error(const char*,...)"
"plugin_initialize(st_plugin_int*)" -> "strcmp(const char*,const char*)"
"plugin_initialize(st_plugin_int*)" -> "inline_mysql_mutex_unlock(mysql_mutex_t*)"
"plugin_initialize(st_plugin_int*)" -> "inline_mysql_mutex_lock(mysql_mutex_t*)"
"add_status_vars(SHOW_VAR*)" -> "init_dynamic_array2(DYNAMIC_ARRAY*,uint,void*,uint,uint)"
"add_status_vars(SHOW_VAR*)" -> "insert_dynamic(DYNAMIC_ARRAY*,const void*)"
"add_status_vars(SHOW_VAR*)" -> "my_qsort(void*,size_t,size_t,qsort_cmp)"
"add_status_vars(SHOW_VAR*)" -> "inline_mysql_mutex_lock(mysql_mutex_t*)"
"add_status_vars(SHOW_VAR*)" -> "inline_mysql_mutex_unlock(mysql_mutex_t*)"
"free_defaults(char**)" -> "memcpy(void*,const void*,size_t)"
"free_defaults(char**)" -> "free_root(MEM_ROOT*,myf)"
"mysql_alter_tablespace(THD*,st_alter_tablespace*)" -> "ha_resolve_storage_engine_name(const handlerton*)"
"mysql_alter_tablespace(THD*,st_alter_tablespace*)" -> "Statement::query_length() const"
"mysql_alter_tablespace(THD*,st_alter_tablespace*)" -> "ha_default_handlerton(THD*)"
"mysql_alter_tablespace(THD*,st_alter_tablespace*)" -> "my_error(int,myf,...)"
"mysql_alter_tablespace(THD*,st_alter_tablespace*)" -> "push_warning_printf(THD*,Sql_condition::enum_warning_level,uint,const char*,...)"
"mysql_alter_tablespace(THD*,st_alter_tablespace*)" -> "write_bin_log(THD*,bool,const char*,ulong,bool)"
"mysql_alter_tablespace(THD*,st_alter_tablespace*)" -> "_current_thd()"
"mysql_alter_tablespace(THD*,st_alter_tablespace*)" -> "Statement::query() const"
"TRACE_FUNCTION_START()" -> "clock_gettime(clockid_t,timespec*)"
"mysql_insert_select_prepare(THD*)" -> "mysql_prepare_insert(THD*,TABLE_LIST*,TABLE*,List<Item>&,List_item*,List<Item>&,List<Item>&,enum_duplicates,Item**,bool,bool,bool)"
"TRACE_START()" -> "clock_gettime(clockid_t,timespec*)"
"create_server(THD*,LEX_SERVER_OPTIONS*)" -> "inline_mysql_rwlock_wrlock(mysql_rwlock_t*)"
"create_server(THD*,LEX_SERVER_OPTIONS*)" -> "insert_server(THD*,FOREIGN_SERVER*)"
"create_server(THD*,LEX_SERVER_OPTIONS*)" -> "prepare_server_struct_for_insert(LEX_SERVER_OPTIONS*)"
"create_server(THD*,LEX_SERVER_OPTIONS*)" -> "my_error(int,myf,...)"
"create_server(THD*,LEX_SERVER_OPTIONS*)" -> "inline_mysql_rwlock_unlock(mysql_rwlock_t*)"
"create_server(THD*,LEX_SERVER_OPTIONS*)" -> "my_hash_search(const HASH*,const uchar*,size_t)"
"insert_server(THD*,FOREIGN_SERVER*)" -> "close_mysql_tables(THD*)"
"insert_server(THD*,FOREIGN_SERVER*)" -> "open_ltable(THD*,TABLE_LIST*,thr_lock_type,uint)"
"insert_server(THD*,FOREIGN_SERVER*)" -> "insert_server_record(TABLE*,FOREIGN_SERVER*)"
"insert_server(THD*,FOREIGN_SERVER*)" -> "TABLE_LIST::TABLE_LIST()"
"insert_server(THD*,FOREIGN_SERVER*)" -> "TABLE_LIST::init_one_table(const char*,size_t,const char*,size_t,const char*,thr_lock_type)"
"insert_server(THD*,FOREIGN_SERVER*)" -> "insert_server_record_into_cache(FOREIGN_SERVER*)"
"insert_server_record(TABLE*,FOREIGN_SERVER*)" -> "store_server_fields(TABLE*,FOREIGN_SERVER*)"
"insert_server_record(TABLE*,FOREIGN_SERVER*)" -> "my_error(int,myf,...)"
"insert_server_record(TABLE*,FOREIGN_SERVER*)" -> "memset(void*,int,size_t)"
"insert_server_record(TABLE*,FOREIGN_SERVER*)" -> "TABLE::use_all_columns()"
"insert_server_record(TABLE*,FOREIGN_SERVER*)" -> "handler::ha_index_read_idx_map(uchar*,uint,const uchar*,key_part_map,ha_rkey_function)"
"insert_server_record(TABLE*,FOREIGN_SERVER*)" -> "memcpy(void*,const void*,size_t)"
"insert_server_record(TABLE*,FOREIGN_SERVER*)" -> "handler::ha_write_row(uchar*)"
"store_server_fields(TABLE*,FOREIGN_SERVER*)" -> "TABLE::use_all_columns()"
"store_server_fields(TABLE*,FOREIGN_SERVER*)" -> "strlen(const char*)"
"insert_server_record_into_cache(FOREIGN_SERVER*)" -> "my_error(int,myf,...)"
"insert_server_record_into_cache(FOREIGN_SERVER*)" -> "my_hash_insert(HASH*,const uchar*)"
"prepare_server_struct_for_insert(LEX_SERVER_OPTIONS*)" -> "alloc_root(MEM_ROOT*,size_t)"
"prepare_server_struct_for_insert(LEX_SERVER_OPTIONS*)" -> "strdup_root(MEM_ROOT*,const char*)"
"reset_one_shot_variables(THD*)" -> "THD::update_charset()"
"alter_server(THD*,LEX_SERVER_OPTIONS*)" -> "push_warning_printf(THD*,Sql_condition::enum_warning_level,uint,const char*,...)"
"alter_server(THD*,LEX_SERVER_OPTIONS*)" -> "inline_mysql_rwlock_unlock(mysql_rwlock_t*)"
"alter_server(THD*,LEX_SERVER_OPTIONS*)" -> "my_hash_search(const HASH*,const uchar*,size_t)"
"alter_server(THD*,LEX_SERVER_OPTIONS*)" -> "my_error(int,myf,...)"
"alter_server(THD*,LEX_SERVER_OPTIONS*)" -> "inline_mysql_rwlock_wrlock(mysql_rwlock_t*)"
"alter_server(THD*,LEX_SERVER_OPTIONS*)" -> "update_server(THD*,FOREIGN_SERVER*,FOREIGN_SERVER*)"
"alter_server(THD*,LEX_SERVER_OPTIONS*)" -> "close_cached_connection_tables(THD*,LEX_STRING*)"
"alter_server(THD*,LEX_SERVER_OPTIONS*)" -> "alloc_root(MEM_ROOT*,size_t)"
"alter_server(THD*,LEX_SERVER_OPTIONS*)" -> "prepare_server_struct_for_update(LEX_SERVER_OPTIONS*,FOREIGN_SERVER*,FOREIGN_SERVER*)"
"update_server(THD*,FOREIGN_SERVER*,FOREIGN_SERVER*)" -> "servers_load(THD*,TABLE_LIST*)"
"update_server(THD*,FOREIGN_SERVER*,FOREIGN_SERVER*)" -> "close_mysql_tables(THD*)"
"update_server(THD*,FOREIGN_SERVER*,FOREIGN_SERVER*)" -> "open_ltable(THD*,TABLE_LIST*,thr_lock_type,uint)"
"update_server(THD*,FOREIGN_SERVER*,FOREIGN_SERVER*)" -> "update_server_record(TABLE*,FOREIGN_SERVER*)"
"update_server(THD*,FOREIGN_SERVER*,FOREIGN_SERVER*)" -> "TABLE_LIST::init_one_table(const char*,size_t,const char*,size_t,const char*,thr_lock_type)"
"update_server(THD*,FOREIGN_SERVER*,FOREIGN_SERVER*)" -> "TABLE_LIST::TABLE_LIST()"
"update_server(THD*,FOREIGN_SERVER*,FOREIGN_SERVER*)" -> "update_server_record_in_cache(FOREIGN_SERVER*,FOREIGN_SERVER*)"
"servers_load(THD*,TABLE_LIST*)" -> "free_root(MEM_ROOT*,myf)"
"servers_load(THD*,TABLE_LIST*)" -> "init_sql_alloc(MEM_ROOT*,uint,uint)"
"servers_load(THD*,TABLE_LIST*)" -> "end_read_record(READ_RECORD*)"
"servers_load(THD*,TABLE_LIST*)" -> "my_hash_reset(HASH*)"
"servers_load(THD*,TABLE_LIST*)" -> "init_read_record(READ_RECORD*,THD*,TABLE*,SQL_SELECT*,int,bool,bool)"
"servers_load(THD*,TABLE_LIST*)" -> "READ_RECORD::READ_RECORD()"
"servers_load(THD*,TABLE_LIST*)" -> "get_server_from_table_to_cache(TABLE*)"
"get_server_from_table_to_cache(TABLE*)" -> "get_field(MEM_ROOT*,Field*)"
"get_server_from_table_to_cache(TABLE*)" -> "my_hash_insert(HASH*,const uchar*)"
"get_server_from_table_to_cache(TABLE*)" -> "strlen(const char*)"
"get_server_from_table_to_cache(TABLE*)" -> "TABLE::use_all_columns()"
"get_server_from_table_to_cache(TABLE*)" -> "alloc_root(MEM_ROOT*,size_t)"
"get_server_from_table_to_cache(TABLE*)" -> "atoi(const char*)"
"update_server_record(TABLE*,FOREIGN_SERVER*)" -> "handler::ha_update_row(const uchar*,uchar*)"
"update_server_record(TABLE*,FOREIGN_SERVER*)" -> "TABLE::use_all_columns()"
"update_server_record(TABLE*,FOREIGN_SERVER*)" -> "store_server_fields(TABLE*,FOREIGN_SERVER*)"
"update_server_record(TABLE*,FOREIGN_SERVER*)" -> "memcpy(void*,const void*,size_t)"
"update_server_record(TABLE*,FOREIGN_SERVER*)" -> "my_error(int,myf,...)"
"update_server_record(TABLE*,FOREIGN_SERVER*)" -> "handler::ha_index_read_idx_map(uchar*,uint,const uchar*,key_part_map,ha_rkey_function)"
"update_server_record_in_cache(FOREIGN_SERVER*,FOREIGN_SERVER*)" -> "my_error(int,myf,...)"
"update_server_record_in_cache(FOREIGN_SERVER*,FOREIGN_SERVER*)" -> "my_hash_delete(HASH*,uchar*)"
"update_server_record_in_cache(FOREIGN_SERVER*,FOREIGN_SERVER*)" -> "merge_server_struct(FOREIGN_SERVER*,FOREIGN_SERVER*)"
"update_server_record_in_cache(FOREIGN_SERVER*,FOREIGN_SERVER*)" -> "my_hash_insert(HASH*,const uchar*)"
"merge_server_struct(FOREIGN_SERVER*,FOREIGN_SERVER*)" -> "strdup_root(MEM_ROOT*,const char*)"
"prepare_server_struct_for_update(LEX_SERVER_OPTIONS*,FOREIGN_SERVER*,FOREIGN_SERVER*)" -> "strcmp(const char*,const char*)"
"prepare_server_struct_for_update(LEX_SERVER_OPTIONS*,FOREIGN_SERVER*,FOREIGN_SERVER*)" -> "strdup_root(MEM_ROOT*,const char*)"
"execute_sqlcom_select(THD*,TABLE_LIST*)" -> "explain_query_expression(THD*,select_result*)"
"execute_sqlcom_select(THD*,TABLE_LIST*)" -> "Item_int::Item_int(ulonglong,uint)"
"execute_sqlcom_select(THD*,TABLE_LIST*)" -> "open_normal_and_derived_tables(THD*,TABLE_LIST*,uint)"
"execute_sqlcom_select(THD*,TABLE_LIST*)" -> "handle_select(THD*,select_result*,ulong)"
"execute_sqlcom_select(THD*,TABLE_LIST*)" -> "select_analyse::select_analyse(select_result*,const Proc_analyse_params*)"
"execute_sqlcom_select(THD*,TABLE_LIST*)" -> "select_send::select_send()"
"Item_int::Item_int(ulonglong,uint)" -> "Item_num::Item_num()"
"mysql_create_like_table(THD*,TABLE_LIST*,TABLE_LIST*,HA_CREATE_INFO*)" -> "THD::is_current_stmt_binlog_format_row() const"
"mysql_create_like_table(THD*,TABLE_LIST*,TABLE_LIST*,HA_CREATE_INFO*)" -> "Open_table_context::Open_table_context(THD*,uint)"
"mysql_create_like_table(THD*,TABLE_LIST*,TABLE_LIST*,HA_CREATE_INFO*)" -> "Alter_info::Alter_info()"
"mysql_create_like_table(THD*,TABLE_LIST*,TABLE_LIST*,HA_CREATE_INFO*)" -> "TABLE_SHARE::db_type() const"
"mysql_create_like_table(THD*,TABLE_LIST*,TABLE_LIST*,HA_CREATE_INFO*)" -> "write_bin_log(THD*,bool,const char*,ulong,bool)"
"mysql_create_like_table(THD*,TABLE_LIST*,TABLE_LIST*,HA_CREATE_INFO*)" -> "mysql_create_table_no_lock(THD*,const char*,const char*,HA_CREATE_INFO*,Alter_info*,uint,bool*)"
"mysql_create_like_table(THD*,TABLE_LIST*,TABLE_LIST*,HA_CREATE_INFO*)" -> "store_create_info(THD*,TABLE_LIST*,String*,HA_CREATE_INFO*,bool)"
"mysql_create_like_table(THD*,TABLE_LIST*,TABLE_LIST*,HA_CREATE_INFO*)" -> "THD_TRANS::mark_created_temp_table()"
"mysql_create_like_table(THD*,TABLE_LIST*,TABLE_LIST*,HA_CREATE_INFO*)" -> "Statement::query() const"
"mysql_create_like_table(THD*,TABLE_LIST*,TABLE_LIST*,HA_CREATE_INFO*)" -> "open_table(THD*,TABLE_LIST*,Open_table_context*)"
"mysql_create_like_table(THD*,TABLE_LIST*,TABLE_LIST*,HA_CREATE_INFO*)" -> "Alter_table_ctx::Alter_table_ctx()"
"mysql_create_like_table(THD*,TABLE_LIST*,TABLE_LIST*,HA_CREATE_INFO*)" -> "String::ptr() const"
"mysql_create_like_table(THD*,TABLE_LIST*,TABLE_LIST*,HA_CREATE_INFO*)" -> "open_tables(THD*,TABLE_LIST**,uint*,uint)"
"mysql_create_like_table(THD*,TABLE_LIST*,TABLE_LIST*,HA_CREATE_INFO*)" -> "TABLE::use_all_columns()"
"mysql_create_like_table(THD*,TABLE_LIST*,TABLE_LIST*,HA_CREATE_INFO*)" -> "st_ha_create_information::st_ha_create_information()"
"mysql_create_like_table(THD*,TABLE_LIST*,TABLE_LIST*,HA_CREATE_INFO*)" -> "String::length() const"
"mysql_create_like_table(THD*,TABLE_LIST*,TABLE_LIST*,HA_CREATE_INFO*)" -> "String::length(uint32)"
"mysql_create_like_table(THD*,TABLE_LIST*,TABLE_LIST*,HA_CREATE_INFO*)" -> "Statement::query_length() const"
"mysql_create_like_table(THD*,TABLE_LIST*,TABLE_LIST*,HA_CREATE_INFO*)" -> "mysql_prepare_alter_table(THD*,TABLE*,HA_CREATE_INFO*,Alter_info*,Alter_table_ctx*)"
"mysql_create_like_table(THD*,TABLE_LIST*,TABLE_LIST*,HA_CREATE_INFO*)" -> "String::String(char*,uint32,const CHARSET_INFO*)"
"mysql_create_like_table(THD*,TABLE_LIST*,TABLE_LIST*,HA_CREATE_INFO*)" -> "memset(void*,int,size_t)"
"mysql_create_like_table(THD*,TABLE_LIST*,TABLE_LIST*,HA_CREATE_INFO*)" -> "partition_info::get_clone()"
"mysql_create_like_table(THD*,TABLE_LIST*,TABLE_LIST*,HA_CREATE_INFO*)" -> "close_thread_table(THD*,TABLE**)"
"mysql_create_db(THD*,char*,HA_CREATE_INFO*,bool)" -> "my_ok(THD*,ulonglong,ulonglong,const char*)"
"mysql_create_db(THD*,char*,HA_CREATE_INFO*,bool)" -> "MYSQL_BIN_LOG::write_event(Log_event*)"
"mysql_create_db(THD*,char*,HA_CREATE_INFO*,bool)" -> "my_strerror(char*,size_t,int)"
"mysql_create_db(THD*,char*,HA_CREATE_INFO*,bool)" -> "my_strmov_quoted_identifier(THD*,char*,const char*,uint)"
"mysql_create_db(THD*,char*,HA_CREATE_INFO*,bool)" -> "THD::add_to_binlog_accessed_dbs(const char*)"
"mysql_create_db(THD*,char*,HA_CREATE_INFO*,bool)" -> "Query_log_event::Query_log_event(THD*,const char*,ulong,bool,bool,bool,int,bool)"
"mysql_create_db(THD*,char*,HA_CREATE_INFO*,bool)" -> "is_infoschema_db(const char*)"
"mysql_create_db(THD*,char*,HA_CREATE_INFO*,bool)" -> "my_mkdir(const char*,int,myf)"
"mysql_create_db(THD*,char*,HA_CREATE_INFO*,bool)" -> "inline_mysql_file_stat(const char*,stat*,myf)"
"mysql_create_db(THD*,char*,HA_CREATE_INFO*,bool)" -> "MYSQL_LOG::is_open()"
"mysql_create_db(THD*,char*,HA_CREATE_INFO*,bool)" -> "push_warning_printf(THD*,Sql_condition::enum_warning_level,uint,const char*,...)"
"mysql_create_db(THD*,char*,HA_CREATE_INFO*,bool)" -> "build_table_filename(char*,size_t,const char*,const char*,const char*,uint,bool*)"
"mysql_create_db(THD*,char*,HA_CREATE_INFO*,bool)" -> "strmake(char*,const char*,size_t)"
"mysql_create_db(THD*,char*,HA_CREATE_INFO*,bool)" -> "Statement::query_length() const"
"mysql_create_db(THD*,char*,HA_CREATE_INFO*,bool)" -> "write_db_opt(THD*,const char*,HA_CREATE_INFO*)"
"mysql_create_db(THD*,char*,HA_CREATE_INFO*,bool)" -> "_current_thd()"
"mysql_create_db(THD*,char*,HA_CREATE_INFO*,bool)" -> "strxmov(char*,const char*,...)"
"mysql_create_db(THD*,char*,HA_CREATE_INFO*,bool)" -> "_my_thread_var()"
"mysql_create_db(THD*,char*,HA_CREATE_INFO*,bool)" -> "query_error_code(THD*,bool)"
"mysql_create_db(THD*,char*,HA_CREATE_INFO*,bool)" -> "strlen(const char*)"
"mysql_create_db(THD*,char*,HA_CREATE_INFO*,bool)" -> "THD::clear_error()"
"mysql_create_db(THD*,char*,HA_CREATE_INFO*,bool)" -> "lock_schema_name(THD*,const char*)"
"mysql_create_db(THD*,char*,HA_CREATE_INFO*,bool)" -> "rmdir(const char*)"
"mysql_create_db(THD*,char*,HA_CREATE_INFO*,bool)" -> "my_error(int,myf,...)"
"mysql_create_db(THD*,char*,HA_CREATE_INFO*,bool)" -> "Statement::query() const"
"show_create_trigger(THD*,const sp_name*)" -> "my_error(int,myf,...)"
"show_create_trigger(THD*,const sp_name*)" -> "open_tables(THD*,TABLE_LIST**,uint*,uint)"
"show_create_trigger(THD*,const sp_name*)" -> "get_trigger_table(THD*,const sp_name*)"
"show_create_trigger(THD*,const sp_name*)" -> "check_table_access(THD*,ulong,TABLE_LIST*,bool,uint,bool)"
"show_create_trigger(THD*,const sp_name*)" -> "MDL_context::mdl_savepoint()"
"show_create_trigger(THD*,const sp_name*)" -> "MDL_context::rollback_to_savepoint(const MDL_savepoint&)"
"show_create_trigger(THD*,const sp_name*)" -> "close_thread_tables(THD*)"
"show_create_trigger(THD*,const sp_name*)" -> "show_create_trigger_impl(THD*,Table_triggers_list*,int)"
"show_create_trigger(THD*,const sp_name*)" -> "Table_triggers_list::find_trigger_by_name(const LEX_STRING*)"
"get_trigger_table(THD*,const sp_name*)" -> "Query_arena::strmake(const char*,size_t)"
"get_trigger_table(THD*,const sp_name*)" -> "my_error(int,myf,...)"
"get_trigger_table(THD*,const sp_name*)" -> "Query_arena::alloc(size_t)"
"get_trigger_table(THD*,const sp_name*)" -> "load_table_name_for_trigger(THD*,const sp_name*,const LEX_STRING*,LEX_STRING*)"
"get_trigger_table(THD*,const sp_name*)" -> "check_trn_exists(const LEX_STRING*)"
"get_trigger_table(THD*,const sp_name*)" -> "build_trn_path(THD*,const sp_name*,LEX_STRING*)"
"get_trigger_table(THD*,const sp_name*)" -> "TABLE_LIST::init_one_table(const char*,size_t,const char*,size_t,const char*,thr_lock_type)"
"show_create_trigger_impl(THD*,Table_triggers_list*,int)" -> "std::max(const _Tp&,const _Tp&) [with _Tp = long unsigned int]"
"show_create_trigger_impl(THD*,Table_triggers_list*,int)" -> "List<T>::push_back(T*) [with T = Item]"
"show_create_trigger_impl(THD*,Table_triggers_list*,int)" -> "List<T>::List() [with T = Item]"
"show_create_trigger_impl(THD*,Table_triggers_list*,int)" -> "Table_triggers_list::get_trigger_info(THD*,int,LEX_STRING*,sql_mode_t*,LEX_STRING*,LEX_STRING*,LEX_STRING*,LEX_STRING*)"
"show_create_trigger_impl(THD*,Table_triggers_list*,int)" -> "sql_mode_string_representation(THD*,sql_mode_t,LEX_STRING*)"
"show_create_trigger_impl(THD*,Table_triggers_list*,int)" -> "resolve_charset(const char*,const CHARSET_INFO*,const CHARSET_INFO**)"
"show_create_trigger_impl(THD*,Table_triggers_list*,int)" -> "Item_empty_string::Item_empty_string(const char*,uint,const CHARSET_INFO*)"
"show_create_trigger_impl(THD*,Table_triggers_list*,int)" -> "my_eof(THD*)"
"Table_triggers_list::get_trigger_info(THD*,int,LEX_STRING*,sql_mode_t*,LEX_STRING*,LEX_STRING*,LEX_STRING*,LEX_STRING*)" -> "List_iterator_fast<T>::operator++(int) [with T = st_mysql_lex_string]"
"Table_triggers_list::get_trigger_info(THD*,int,LEX_STRING*,sql_mode_t*,LEX_STRING*,LEX_STRING*,LEX_STRING*,LEX_STRING*)" -> "List_iterator_fast<T>::List_iterator_fast(List<T>&) [with T = st_mysql_lex_string]"
"Table_triggers_list::get_trigger_info(THD*,int,LEX_STRING*,sql_mode_t*,LEX_STRING*,LEX_STRING*,LEX_STRING*,LEX_STRING*)" -> "List_iterator_fast<T>::List_iterator_fast(List<T>&) [with T = long long unsigned int]"
"Table_triggers_list::get_trigger_info(THD*,int,LEX_STRING*,sql_mode_t*,LEX_STRING*,LEX_STRING*,LEX_STRING*,LEX_STRING*)" -> "base_list_iterator::next_fast()"
"Table_triggers_list::get_trigger_info(THD*,int,LEX_STRING*,sql_mode_t*,LEX_STRING*,LEX_STRING*,LEX_STRING*,LEX_STRING*)" -> "List_iterator_fast<T>::operator++(int) [with T = long long unsigned int]"
"Table_triggers_list::find_trigger_by_name(const LEX_STRING*)" -> "strcmp(const char*,const char*)"
"Table_triggers_list::find_trigger_by_name(const LEX_STRING*)" -> "List_iterator_fast<T>::List_iterator_fast(List<T>&) [with T = st_mysql_lex_string]"
"Table_triggers_list::find_trigger_by_name(const LEX_STRING*)" -> "List_iterator_fast<T>::operator++(int) [with T = st_mysql_lex_string]"
"mysql_update(THD*,TABLE_LIST*,List<Item>&,List<Item>&,Item*,uint,ORDER*,ha_rows,enum_duplicates,bool,ha_rows*,ha_rows*)" -> "fill_record_n_invoke_before_triggers(THD*,List<Item>&,List<Item>&,bool,Table_triggers_list*,trg_event_type)"
"mysql_update(THD*,TABLE_LIST*,List<Item>&,List<Item>&,Item*,uint,ORDER*,ha_rows,enum_duplicates,bool,ha_rows*,ha_rows*)" -> "THD::is_strict_mode() const"
"mysql_update(THD*,TABLE_LIST*,List<Item>&,List<Item>&,Item*,uint,ORDER*,ha_rows,enum_duplicates,bool,ha_rows*,ha_rows*)" -> "query_error_code(THD*,bool)"
"mysql_update(THD*,TABLE_LIST*,List<Item>&,List<Item>&,Item*,uint,ORDER*,ha_rows,enum_duplicates,bool,ha_rows*,ha_rows*)" -> "THD::clear_error()"
"mysql_update(THD*,TABLE_LIST*,List<Item>&,List<Item>&,Item*,uint,ORDER*,ha_rows,enum_duplicates,bool,ha_rows*,ha_rows*)" -> "Diagnostics_area::inc_current_row_for_warning()"
"mysql_update(THD*,TABLE_LIST*,List<Item>&,List<Item>&,Item*,uint,ORDER*,ha_rows,enum_duplicates,bool,ha_rows*,ha_rows*)" -> "init_read_record(READ_RECORD*,THD*,TABLE*,SQL_SELECT*,int,bool,bool)"
"mysql_update(THD*,TABLE_LIST*,List<Item>&,List<Item>&,Item*,uint,ORDER*,ha_rows,enum_duplicates,bool,ha_rows*,ha_rows*)" -> "SQL_SELECT::skip_record(THD*,bool*)"
"mysql_update(THD*,TABLE_LIST*,List<Item>&,List<Item>&,Item*,uint,ORDER*,ha_rows,enum_duplicates,bool,ha_rows*,ha_rows*)" -> "handler::ha_bulk_update_row(const uchar*,uchar*,uint*)"
"mysql_update(THD*,TABLE_LIST*,List<Item>&,List<Item>&,Item*,uint,ORDER*,ha_rows,enum_duplicates,bool,ha_rows*,ha_rows*)" -> "init_read_record_idx(READ_RECORD*,THD*,TABLE*,bool,uint,bool)"
"mysql_update(THD*,TABLE_LIST*,List<Item>&,List<Item>&,Item*,uint,ORDER*,ha_rows,enum_duplicates,bool,ha_rows*,ha_rows*)" -> "memcpy(void*,const void*,size_t)"
"mysql_update(THD*,TABLE_LIST*,List<Item>&,List<Item>&,Item*,uint,ORDER*,ha_rows,enum_duplicates,bool,ha_rows*,ha_rows*)" -> "List<T>::List() [with T = Item]"
"mysql_update(THD*,TABLE_LIST*,List<Item>&,List<Item>&,Item*,uint,ORDER*,ha_rows,enum_duplicates,bool,ha_rows*,ha_rows*)" -> "THD::is_error() const"
"mysql_update(THD*,TABLE_LIST*,List<Item>&,List<Item>&,Item*,uint,ORDER*,ha_rows,enum_duplicates,bool,ha_rows*,ha_rows*)" -> "my_snprintf(char*,size_t,const char*,...)"
"mysql_update(THD*,TABLE_LIST*,List<Item>&,List<Item>&,Item*,uint,ORDER*,ha_rows,enum_duplicates,bool,ha_rows*,ha_rows*)" -> "TABLE::check_read_removal(uint)"
"mysql_update(THD*,TABLE_LIST*,List<Item>&,List<Item>&,Item*,uint,ORDER*,ha_rows,enum_duplicates,bool,ha_rows*,ha_rows*)" -> "open_cached_file(IO_CACHE*,const char*,const char*,size_t,myf)"
"mysql_update(THD*,TABLE_LIST*,List<Item>&,List<Item>&,Item*,uint,ORDER*,ha_rows,enum_duplicates,bool,ha_rows*,ha_rows*)" -> "end_read_record(READ_RECORD*)"
"mysql_update(THD*,TABLE_LIST*,List<Item>&,List<Item>&,Item*,uint,ORDER*,ha_rows,enum_duplicates,bool,ha_rows*,ha_rows*)" -> "Statement::query_length() const"
"mysql_update(THD*,TABLE_LIST*,List<Item>&,List<Item>&,Item*,uint,ORDER*,ha_rows,enum_duplicates,bool,ha_rows*,ha_rows*)" -> "Bitmap<64u>::is_set(uint) const"
"mysql_update(THD*,TABLE_LIST*,List<Item>&,List<Item>&,Item*,uint,ORDER*,ha_rows,enum_duplicates,bool,ha_rows*,ha_rows*)" -> "init_ftfuncs(THD*,SELECT_LEX*,bool)"
"mysql_update(THD*,TABLE_LIST*,List<Item>&,List<Item>&,Item*,uint,ORDER*,ha_rows,enum_duplicates,bool,ha_rows*,ha_rows*)" -> "make_select(TABLE*,table_map,table_map,Item*,bool,int*)"
"mysql_update(THD*,TABLE_LIST*,List<Item>&,List<Item>&,Item*,uint,ORDER*,ha_rows,enum_duplicates,bool,ha_rows*,ha_rows*)" -> "setup_fields(THD*,Ref_ptr_array,List<Item>&,enum_mark_columns,List<Item>*,bool)"
"mysql_update(THD*,TABLE_LIST*,List<Item>&,List<Item>&,Item*,uint,ORDER*,ha_rows,enum_duplicates,bool,ha_rows*,ha_rows*)" -> "my_error(int,myf,...)"
"mysql_update(THD*,TABLE_LIST*,List<Item>&,List<Item>&,Item*,uint,ORDER*,ha_rows,enum_duplicates,bool,ha_rows*,ha_rows*)" -> "check_fields(THD*,List<Item>&)"
"mysql_update(THD*,TABLE_LIST*,List<Item>&,List<Item>&,Item*,uint,ORDER*,ha_rows,enum_duplicates,bool,ha_rows*,ha_rows*)" -> "SQL_SELECT::SQL_SELECT()"
"mysql_update(THD*,TABLE_LIST*,List<Item>&,List<Item>&,Item*,uint,ORDER*,ha_rows,enum_duplicates,bool,ha_rows*,ha_rows*)" -> "THD_TRANS::mark_modified_non_trans_table()"
"mysql_update(THD*,TABLE_LIST*,List<Item>&,List<Item>&,Item*,uint,ORDER*,ha_rows,enum_duplicates,bool,ha_rows*,ha_rows*)" -> "records_are_comparable(const TABLE*)"
"mysql_update(THD*,TABLE_LIST*,List<Item>&,List<Item>&,Item*,uint,ORDER*,ha_rows,enum_duplicates,bool,ha_rows*,ha_rows*)" -> "check_key_in_view(THD*,TABLE_LIST*)"
"mysql_update(THD*,TABLE_LIST*,List<Item>&,List<Item>&,Item*,uint,ORDER*,ha_rows,enum_duplicates,bool,ha_rows*,ha_rows*)" -> "COPY_INFO::set_function_defaults(TABLE*)"
"mysql_update(THD*,TABLE_LIST*,List<Item>&,List<Item>&,Item*,uint,ORDER*,ha_rows,enum_duplicates,bool,ha_rows*,ha_rows*)" -> "Opt_trace_struct::add_utf8_table(const TABLE*)"
"mysql_update(THD*,TABLE_LIST*,List<Item>&,List<Item>&,Item*,uint,ORDER*,ha_rows,enum_duplicates,bool,ha_rows*,ha_rows*)" -> "my_ok(THD*,ulonglong,ulonglong,const char*)"
"mysql_update(THD*,TABLE_LIST*,List<Item>&,List<Item>&,Item*,uint,ORDER*,ha_rows,enum_duplicates,bool,ha_rows*,ha_rows*)" -> "Bitmap<64u>::is_clear_all() const"
"mysql_update(THD*,TABLE_LIST*,List<Item>&,List<Item>&,Item*,uint,ORDER*,ha_rows,enum_duplicates,bool,ha_rows*,ha_rows*)" -> "build_equal_items(THD*,Item*,COND_EQUAL*,bool,List<TABLE_LIST>*,COND_EQUAL**)"
"mysql_update(THD*,TABLE_LIST*,List<Item>&,List<Item>&,Item*,uint,ORDER*,ha_rows,enum_duplicates,bool,ha_rows*,ha_rows*)" -> "COPY_INFO::add_function_default_columns(TABLE*,MY_BITMAP*)"
"mysql_update(THD*,TABLE_LIST*,List<Item>&,List<Item>&,Item*,uint,ORDER*,ha_rows,enum_duplicates,bool,ha_rows*,ha_rows*)" -> "free_underlaid_joins(THD*,SELECT_LEX*)"
"mysql_update(THD*,TABLE_LIST*,List<Item>&,List<Item>&,Item*,uint,ORDER*,ha_rows,enum_duplicates,bool,ha_rows*,ha_rows*)" -> "close_cached_file(IO_CACHE*)"
"mysql_update(THD*,TABLE_LIST*,List<Item>&,List<Item>&,Item*,uint,ORDER*,ha_rows,enum_duplicates,bool,ha_rows*,ha_rows*)" -> "handler::ha_table_flags() const"
"mysql_update(THD*,TABLE_LIST*,List<Item>&,List<Item>&,Item*,uint,ORDER*,ha_rows,enum_duplicates,bool,ha_rows*,ha_rows*)" -> "my_message(uint,const char*,myf)"
"mysql_update(THD*,TABLE_LIST*,List<Item>&,List<Item>&,Item*,uint,ORDER*,ha_rows,enum_duplicates,bool,ha_rows*,ha_rows*)" -> "THD::inc_examined_row_count(ha_rows)"
"mysql_update(THD*,TABLE_LIST*,List<Item>&,List<Item>&,Item*,uint,ORDER*,ha_rows,enum_duplicates,bool,ha_rows*,ha_rows*)" -> "Bounds_checked_array<Element_type>::Bounds_checked_array() [with Element_type = Item*]"
"mysql_update(THD*,TABLE_LIST*,List<Item>&,List<Item>&,Item*,uint,ORDER*,ha_rows,enum_duplicates,bool,ha_rows*,ha_rows*)" -> "MYSQL_LOG::is_open()"
"mysql_update(THD*,TABLE_LIST*,List<Item>&,List<Item>&,Item*,uint,ORDER*,ha_rows,enum_duplicates,bool,ha_rows*,ha_rows*)" -> "check_constant_expressions(List<Item>&)"
"mysql_update(THD*,TABLE_LIST*,List<Item>&,List<Item>&,Item*,uint,ORDER*,ha_rows,enum_duplicates,bool,ha_rows*,ha_rows*)" -> "handler::ha_update_row(const uchar*,uchar*)"
"mysql_update(THD*,TABLE_LIST*,List<Item>&,List<Item>&,Item*,uint,ORDER*,ha_rows,enum_duplicates,bool,ha_rows*,ha_rows*)" -> "mysql_prepare_update(THD*,TABLE_LIST*,Item**,uint,ORDER*)"
"mysql_update(THD*,TABLE_LIST*,List<Item>&,List<Item>&,Item*,uint,ORDER*,ha_rows,enum_duplicates,bool,ha_rows*,ha_rows*)" -> "open_normal_and_derived_tables(THD*,TABLE_LIST*,uint)"
"mysql_update(THD*,TABLE_LIST*,List<Item>&,List<Item>&,Item*,uint,ORDER*,ha_rows,enum_duplicates,bool,ha_rows*,ha_rows*)" -> "Query_cache::invalidate(THD*,TABLE_LIST*,my_bool)"
"mysql_update(THD*,TABLE_LIST*,List<Item>&,List<Item>&,Item*,uint,ORDER*,ha_rows,enum_duplicates,bool,ha_rows*,ha_rows*)" -> "get_index_for_order(ORDER*,TABLE*,SQL_SELECT*,ha_rows,bool*,bool*)"
"mysql_update(THD*,TABLE_LIST*,List<Item>&,List<Item>&,Item*,uint,ORDER*,ha_rows,enum_duplicates,bool,ha_rows*,ha_rows*)" -> "READ_RECORD::READ_RECORD()"
"mysql_update(THD*,TABLE_LIST*,List<Item>&,List<Item>&,Item*,uint,ORDER*,ha_rows,enum_duplicates,bool,ha_rows*,ha_rows*)" -> "Bitmap<64u>::clear_all()"
"mysql_update(THD*,TABLE_LIST*,List<Item>&,List<Item>&,Item*,uint,ORDER*,ha_rows,enum_duplicates,bool,ha_rows*,ha_rows*)" -> "handler::has_transactions()"
"mysql_update(THD*,TABLE_LIST*,List<Item>&,List<Item>&,Item*,uint,ORDER*,ha_rows,enum_duplicates,bool,ha_rows*,ha_rows*)" -> "THD::binlog_query(THD::enum_binlog_query_type,const char*,ulong,bool,bool,bool,int)"
"mysql_update(THD*,TABLE_LIST*,List<Item>&,List<Item>&,Item*,uint,ORDER*,ha_rows,enum_duplicates,bool,ha_rows*,ha_rows*)" -> "Opt_trace_object::Opt_trace_object(Opt_trace_context*,Opt_trace_context::feature_value)"
"mysql_update(THD*,TABLE_LIST*,List<Item>&,List<Item>&,Item*,uint,ORDER*,ha_rows,enum_duplicates,bool,ha_rows*,ha_rows*)" -> "partition_key_modified(TABLE*,const MY_BITMAP*)"
"mysql_update(THD*,TABLE_LIST*,List<Item>&,List<Item>&,Item*,uint,ORDER*,ha_rows,enum_duplicates,bool,ha_rows*,ha_rows*)" -> "Bitmap<64u>::Bitmap()"
"mysql_update(THD*,TABLE_LIST*,List<Item>&,List<Item>&,Item*,uint,ORDER*,ha_rows,enum_duplicates,bool,ha_rows*,ha_rows*)" -> "_current_thd()"
"mysql_update(THD*,TABLE_LIST*,List<Item>&,List<Item>&,Item*,uint,ORDER*,ha_rows,enum_duplicates,bool,ha_rows*,ha_rows*)" -> "substitute_for_best_equal_field(Item*,COND_EQUAL*,void*)"
"mysql_update(THD*,TABLE_LIST*,List<Item>&,List<Item>&,Item*,uint,ORDER*,ha_rows,enum_duplicates,bool,ha_rows*,ha_rows*)" -> "Table_triggers_list::mark_fields_used(trg_event_type)"
"mysql_update(THD*,TABLE_LIST*,List<Item>&,List<Item>&,Item*,uint,ORDER*,ha_rows,enum_duplicates,bool,ha_rows*,ha_rows*)" -> "reinit_io_cache(IO_CACHE*,cache_type,my_off_t,pbool,pbool)"
"mysql_update(THD*,TABLE_LIST*,List<Item>&,List<Item>&,Item*,uint,ORDER*,ha_rows,enum_duplicates,bool,ha_rows*,ha_rows*)" -> "bitmap_union(MY_BITMAP*,const MY_BITMAP*)"
"mysql_update(THD*,TABLE_LIST*,List<Item>&,List<Item>&,Item*,uint,ORDER*,ha_rows,enum_duplicates,bool,ha_rows*,ha_rows*)" -> "explain_single_table_modification(THD*,TABLE*,const SQL_SELECT*,uint,ha_rows,bool,bool,bool,bool)"
"mysql_update(THD*,TABLE_LIST*,List<Item>&,List<Item>&,Item*,uint,ORDER*,ha_rows,enum_duplicates,bool,ha_rows*,ha_rows*)" -> "Diagnostics_area::current_statement_warn_count() const"
"mysql_update(THD*,TABLE_LIST*,List<Item>&,List<Item>&,Item*,uint,ORDER*,ha_rows,enum_duplicates,bool,ha_rows*,ha_rows*)" -> "COPY_INFO::COPY_INFO(COPY_INFO::operation_type,List<Item>*,List<Item>*)"
"mysql_update(THD*,TABLE_LIST*,List<Item>&,List<Item>&,Item*,uint,ORDER*,ha_rows,enum_duplicates,bool,ha_rows*,ha_rows*)" -> "SQL_SELECT::set_quick(QUICK_SELECT_I*)"
"mysql_update(THD*,TABLE_LIST*,List<Item>&,List<Item>&,Item*,uint,ORDER*,ha_rows,enum_duplicates,bool,ha_rows*,ha_rows*)" -> "THD::get_stmt_da()"
"mysql_update(THD*,TABLE_LIST*,List<Item>&,List<Item>&,Item*,uint,ORDER*,ha_rows,enum_duplicates,bool,ha_rows*,ha_rows*)" -> "Statement::query() const"
"mysql_update(THD*,TABLE_LIST*,List<Item>&,List<Item>&,Item*,uint,ORDER*,ha_rows,enum_duplicates,bool,ha_rows*,ha_rows*)" -> "THD_TRANS::cannot_safely_rollback() const"
"mysql_update(THD*,TABLE_LIST*,List<Item>&,List<Item>&,Item*,uint,ORDER*,ha_rows,enum_duplicates,bool,ha_rows*,ha_rows*)" -> "my_malloc(size_t,myf)"
"mysql_update(THD*,TABLE_LIST*,List<Item>&,List<Item>&,Item*,uint,ORDER*,ha_rows,enum_duplicates,bool,ha_rows*,ha_rows*)" -> "fix_inner_refs(THD*,List<Item>&,SELECT_LEX*,Ref_ptr_array,ORDER*)"
"mysql_update(THD*,TABLE_LIST*,List<Item>&,List<Item>&,Item*,uint,ORDER*,ha_rows,enum_duplicates,bool,ha_rows*,ha_rows*)" -> "setup_fields_with_no_wrap(THD*,Ref_ptr_array,List<Item>&,enum_mark_columns,List<Item>*,bool)"
"mysql_update(THD*,TABLE_LIST*,List<Item>&,List<Item>&,Item*,uint,ORDER*,ha_rows,enum_duplicates,bool,ha_rows*,ha_rows*)" -> "filesort(THD*,TABLE*,Filesort*,bool,ha_rows*,ha_rows*)"
"mysql_update(THD*,TABLE_LIST*,List<Item>&,List<Item>&,Item*,uint,ORDER*,ha_rows,enum_duplicates,bool,ha_rows*,ha_rows*)" -> "compare_records(const TABLE*)"
"mysql_update(THD*,TABLE_LIST*,List<Item>&,List<Item>&,Item*,uint,ORDER*,ha_rows,enum_duplicates,bool,ha_rows*,ha_rows*)" -> "Table_triggers_list::process_triggers(THD*,trg_event_type,trg_action_time_type,bool)"
"mysql_update(THD*,TABLE_LIST*,List<Item>&,List<Item>&,Item*,uint,ORDER*,ha_rows,enum_duplicates,bool,ha_rows*,ha_rows*)" -> "THD::enter_stage(const PSI_stage_info*,PSI_stage_info*,const char*,const char*,unsigned int)"
"mysql_update(THD*,TABLE_LIST*,List<Item>&,List<Item>&,Item*,uint,ORDER*,ha_rows,enum_duplicates,bool,ha_rows*,ha_rows*)" -> "remove_eq_conds(THD*,Item*,Item::cond_result*)"
"mysql_update(THD*,TABLE_LIST*,List<Item>&,List<Item>&,Item*,uint,ORDER*,ha_rows,enum_duplicates,bool,ha_rows*,ha_rows*)" -> "lock_tables(THD*,TABLE_LIST*,uint,uint)"
"mysql_update(THD*,TABLE_LIST*,List<Item>&,List<Item>&,Item*,uint,ORDER*,ha_rows,enum_duplicates,bool,ha_rows*,ha_rows*)" -> "TABLE::update_const_key_parts(Item*)"
"mysql_update(THD*,TABLE_LIST*,List<Item>&,List<Item>&,Item*,uint,ORDER*,ha_rows,enum_duplicates,bool,ha_rows*,ha_rows*)" -> "TABLE::set_keyread(bool)"
"mysql_update(THD*,TABLE_LIST*,List<Item>&,List<Item>&,Item*,uint,ORDER*,ha_rows,enum_duplicates,bool,ha_rows*,ha_rows*)" -> "my_tmpdir(MY_TMPDIR*)"
"mysql_update(THD*,TABLE_LIST*,List<Item>&,List<Item>&,Item*,uint,ORDER*,ha_rows,enum_duplicates,bool,ha_rows*,ha_rows*)" -> "optimize_cond(THD*,Item*,COND_EQUAL**,List<TABLE_LIST>*,bool,Item::cond_result*)"
"mysql_update(THD*,TABLE_LIST*,List<Item>&,List<Item>&,Item*,uint,ORDER*,ha_rows,enum_duplicates,bool,ha_rows*,ha_rows*)" -> "explain_no_table(THD*,const char*,ha_rows)"
"mysql_update(THD*,TABLE_LIST*,List<Item>&,List<Item>&,Item*,uint,ORDER*,ha_rows,enum_duplicates,bool,ha_rows*,ha_rows*)" -> "COPY_INFO::function_defaults_apply(const TABLE*) const"
"mysql_update(THD*,TABLE_LIST*,List<Item>&,List<Item>&,Item*,uint,ORDER*,ha_rows,enum_duplicates,bool,ha_rows*,ha_rows*)" -> "SQL_SELECT::check_quick(THD*,bool,ha_rows)"
"mysql_update(THD*,TABLE_LIST*,List<Item>&,List<Item>&,Item*,uint,ORDER*,ha_rows,enum_duplicates,bool,ha_rows*,ha_rows*)" -> "is_key_used(TABLE*,uint,const MY_BITMAP*)"
"mysql_update(THD*,TABLE_LIST*,List<Item>&,List<Item>&,Item*,uint,ORDER*,ha_rows,enum_duplicates,bool,ha_rows*,ha_rows*)" -> "TABLE_LIST::view_check_option(THD*,bool) const"
"mysql_update(THD*,TABLE_LIST*,List<Item>&,List<Item>&,Item*,uint,ORDER*,ha_rows,enum_duplicates,bool,ha_rows*,ha_rows*)" -> "Table_triggers_list::has_triggers(trg_event_type,trg_action_time_type)"
"mysql_update(THD*,TABLE_LIST*,List<Item>&,List<Item>&,Item*,uint,ORDER*,ha_rows,enum_duplicates,bool,ha_rows*,ha_rows*)" -> "simple_remove_const(ORDER*,Item*)"
"mysql_update(THD*,TABLE_LIST*,List<Item>&,List<Item>&,Item*,uint,ORDER*,ha_rows,enum_duplicates,bool,ha_rows*,ha_rows*)" -> "prune_partitions(THD*,TABLE*,Item*)"
"mysql_update(THD*,TABLE_LIST*,List<Item>&,List<Item>&,Item*,uint,ORDER*,ha_rows,enum_duplicates,bool,ha_rows*,ha_rows*)" -> "Filesort::Filesort(ORDER*,ha_rows,SQL_SELECT*)"
"mysql_update(THD*,TABLE_LIST*,List<Item>&,List<Item>&,Item*,uint,ORDER*,ha_rows,enum_duplicates,bool,ha_rows*,ha_rows*)" -> "TABLE::prepare_for_position()"
"mysql_update(THD*,TABLE_LIST*,List<Item>&,List<Item>&,Item*,uint,ORDER*,ha_rows,enum_duplicates,bool,ha_rows*,ha_rows*)" -> "TABLE::mark_columns_needed_for_update()"
"handler::ha_bulk_update_row(const uchar*,uchar*,uint*)" -> "handler::mark_trx_read_write()"
"COPY_INFO::set_function_defaults(TABLE*)" -> "bitmap_is_clear_all(const MY_BITMAP*)"
"COPY_INFO::set_function_defaults(TABLE*)" -> "Field::evaluate_insert_default_function()"
"COPY_INFO::set_function_defaults(TABLE*)" -> "bitmap_is_set(const MY_BITMAP*,uint)"
"COPY_INFO::set_function_defaults(TABLE*)" -> "Field::evaluate_update_default_function()"
"Field::evaluate_update_default_function()" -> "Field::has_update_default_function() const"
"Field::evaluate_update_default_function()" -> "Item_func_now_local::store_in(Field*)"
"check_constant_expressions(List<Item>&)" -> "List_iterator_fast<T>::operator++(int) [with T = Item]"
"check_constant_expressions(List<Item>&)" -> "List_iterator_fast<T>::List_iterator_fast(List<T>&) [with T = Item]"
"COPY_INFO::function_defaults_apply(const TABLE*) const" -> "bitmap_is_clear_all(const MY_BITMAP*)"
"TABLE::mark_columns_needed_for_update()" -> "MYSQL_LOG::is_open()"
"TABLE::mark_columns_needed_for_update()" -> "THD::is_current_stmt_binlog_format_row() const"
"TABLE::mark_columns_needed_for_update()" -> "Bitmap<64u>::is_overlapping(const Bitmap<64u>&) const"
"TABLE::mark_columns_needed_for_update()" -> "TABLE::mark_columns_per_binlog_row_image()"
"TABLE::mark_columns_needed_for_update()" -> "TABLE::mark_columns_used_by_index_no_reset(uint,MY_BITMAP*)"
"TABLE::mark_columns_needed_for_update()" -> "bitmap_set_bit(MY_BITMAP*,uint)"
"TABLE::mark_columns_needed_for_update()" -> "handler::ha_table_flags() const"
"mysqld_show_create_db(THD*,char*,HA_CREATE_INFO*)" -> "String::String(char*,uint32,const CHARSET_INFO*)"
"mysqld_show_create_db(THD*,char*,HA_CREATE_INFO*)" -> "List<T>::push_back(T*) [with T = Item]"
"mysqld_show_create_db(THD*,char*,HA_CREATE_INFO*)" -> "load_db_opt_by_name(THD*,const char*,HA_CREATE_INFO*)"
"mysqld_show_create_db(THD*,char*,HA_CREATE_INFO*)" -> "check_db_dir_existence(const char*)"
"mysqld_show_create_db(THD*,char*,HA_CREATE_INFO*)" -> "String::length(uint32)"
"mysqld_show_create_db(THD*,char*,HA_CREATE_INFO*)" -> "Item_empty_string::Item_empty_string(const char*,uint,const CHARSET_INFO*)"
"mysqld_show_create_db(THD*,char*,HA_CREATE_INFO*)" -> "String::length() const"
"mysqld_show_create_db(THD*,char*,HA_CREATE_INFO*)" -> "append_identifier(THD*,String*,const char*,uint)"
"mysqld_show_create_db(THD*,char*,HA_CREATE_INFO*)" -> "strlen(const char*)"
"mysqld_show_create_db(THD*,char*,HA_CREATE_INFO*)" -> "st_ha_create_information::st_ha_create_information()"
"mysqld_show_create_db(THD*,char*,HA_CREATE_INFO*)" -> "my_eof(THD*)"
"mysqld_show_create_db(THD*,char*,HA_CREATE_INFO*)" -> "strcpy(char*,const char*)"
"mysqld_show_create_db(THD*,char*,HA_CREATE_INFO*)" -> "String::append(const char*)"
"mysqld_show_create_db(THD*,char*,HA_CREATE_INFO*)" -> "String::charset() const"
"mysqld_show_create_db(THD*,char*,HA_CREATE_INFO*)" -> "is_infoschema_db(const char*)"
"mysqld_show_create_db(THD*,char*,HA_CREATE_INFO*)" -> "my_error(int,myf,...)"
"mysqld_show_create_db(THD*,char*,HA_CREATE_INFO*)" -> "List<T>::List() [with T = Item]"
"mysqld_show_create_db(THD*,char*,HA_CREATE_INFO*)" -> "String::ptr() const"
"mysqld_show_create_db(THD*,char*,HA_CREATE_INFO*)" -> "String::append(const char*,uint32)"
"trans_xa_commit(THD*)" -> "xid_cache_search(XID*)"
"trans_xa_commit(THD*)" -> "my_error(int,myf,...)"
"trans_xa_commit(THD*)" -> "MDL_request::init(MDL_key::enum_mdl_namespace,const char*,const char*,enum_mdl_type,enum_mdl_duration)"
"trans_xa_commit(THD*)" -> "xid_t::eq(xid_t*)"
"trans_xa_commit(THD*)" -> "THD::is_error() const"
"trans_xa_commit(THD*)" -> "xa_trans_rolled_back(XID_STATE*)"
"trans_xa_commit(THD*)" -> "xid_cache_delete(XID_STATE*)"
"trans_xa_commit(THD*)" -> "ha_commit_trans(THD*,bool,bool)"
"trans_xa_commit(THD*)" -> "MDL_context::acquire_lock(MDL_request*,ulong)"
"trans_xa_commit(THD*)" -> "xa_trans_force_rollback(THD*)"
"trans_xa_commit(THD*)" -> "ha_commit_low(THD*,bool,bool)"
"trans_xa_commit(THD*)" -> "ha_rollback_trans(THD*,bool)"
"trans_xa_commit(THD*)" -> "MDL_request::MDL_request()"
"trans_xa_commit(THD*)" -> "THD_TRANS::reset_unsafe_rollback_flags()"
"trans_xa_commit(THD*)" -> "ha_commit_or_rollback_by_xid(THD*,XID*,bool)"
"mysql_rename_tables(THD*,TABLE_LIST*,bool)" -> "LOGGER::is_log_table_enabled(uint)"
"mysql_rename_tables(THD*,TABLE_LIST*,bool)" -> "check_if_log_table(size_t,const char*,size_t,const char*,bool)"
"mysql_rename_tables(THD*,TABLE_LIST*,bool)" -> "lock_table_names(THD*,TABLE_LIST*,TABLE_LIST*,ulong,uint)"
"mysql_rename_tables(THD*,TABLE_LIST*,bool)" -> "Statement::query_length() const"
"mysql_rename_tables(THD*,TABLE_LIST*,bool)" -> "THD::in_active_multi_stmt_transaction() const"
"mysql_rename_tables(THD*,TABLE_LIST*,bool)" -> "my_message(uint,const char*,myf)"
"mysql_rename_tables(THD*,TABLE_LIST*,bool)" -> "write_bin_log(THD*,bool,const char*,ulong,bool)"
"mysql_rename_tables(THD*,TABLE_LIST*,bool)" -> "reverse_table_list(TABLE_LIST*)"
"mysql_rename_tables(THD*,TABLE_LIST*,bool)" -> "rename_tables(THD*,TABLE_LIST*,bool)"
"mysql_rename_tables(THD*,TABLE_LIST*,bool)" -> "Statement::query() const"
"mysql_rename_tables(THD*,TABLE_LIST*,bool)" -> "my_error(int,myf,...)"
"mysql_rename_tables(THD*,TABLE_LIST*,bool)" -> "mysql_ha_rm_tables(THD*,TABLE_LIST*)"
"mysql_rename_tables(THD*,TABLE_LIST*,bool)" -> "Query_cache::invalidate(THD*,TABLE_LIST*,my_bool)"
"mysql_rename_tables(THD*,TABLE_LIST*,bool)" -> "_current_thd()"
"mysql_rename_tables(THD*,TABLE_LIST*,bool)" -> "my_ok(THD*,ulonglong,ulonglong,const char*)"
"mysql_rename_tables(THD*,TABLE_LIST*,bool)" -> "tdc_remove_table(THD*,enum_tdc_remove_table_type,const char*,const char*,bool)"
"rename_tables(THD*,TABLE_LIST*,bool)" -> "do_rename(THD*,TABLE_LIST*,char*,char*,char*,bool)"
"do_rename(THD*,TABLE_LIST*,char*,char*,char*,bool)" -> "my_error(int,myf,...)"
"do_rename(THD*,TABLE_LIST*,char*,char*,char*,bool)" -> "access(const char*,int)"
"do_rename(THD*,TABLE_LIST*,char*,char*,char*,bool)" -> "mysql_rename_view(THD*,const char*,const char*,TABLE_LIST*)"
"do_rename(THD*,TABLE_LIST*,char*,char*,char*,bool)" -> "ha_resolve_by_legacy_type(THD*,legacy_db_type)"
"do_rename(THD*,TABLE_LIST*,char*,char*,char*,bool)" -> "Table_triggers_list::change_table_name(THD*,const char*,const char*,const char*,const char*,const char*)"
"do_rename(THD*,TABLE_LIST*,char*,char*,char*,bool)" -> "my_strerror(char*,size_t,int)"
"do_rename(THD*,TABLE_LIST*,char*,char*,char*,bool)" -> "dd_frm_type(THD*,char*,legacy_db_type*)"
"do_rename(THD*,TABLE_LIST*,char*,char*,char*,bool)" -> "strcmp(const char*,const char*)"
"do_rename(THD*,TABLE_LIST*,char*,char*,char*,bool)" -> "mysql_rename_table(handlerton*,const char*,const char*,const char*,const char*,uint)"
"do_rename(THD*,TABLE_LIST*,char*,char*,char*,bool)" -> "build_table_filename(char*,size_t,const char*,const char*,const char*,uint)"
"do_rename(THD*,TABLE_LIST*,char*,char*,char*,bool)" -> "_my_thread_var()"
"do_rename(THD*,TABLE_LIST*,char*,char*,char*,bool)" -> "THD::add_to_binlog_accessed_dbs(const char*)"
"mysql_rename_view(THD*,const char*,const char*,TABLE_LIST*)" -> "Query_cache::invalidate(THD*,TABLE_LIST*,my_bool)"
"mysql_rename_view(THD*,const char*,const char*,TABLE_LIST*)" -> "memset(void*,int,size_t)"
"mysql_rename_view(THD*,const char*,const char*,TABLE_LIST*)" -> "TABLE_LIST::TABLE_LIST()"
"mysql_rename_view(THD*,const char*,const char*,TABLE_LIST*)" -> "sql_parse_prepare(const LEX_STRING*,MEM_ROOT*,bool)"
"mysql_rename_view(THD*,const char*,const char*,TABLE_LIST*)" -> "rename_in_schema_file(THD*,const char*,const char*,const char*,const char*)"
"mysql_rename_view(THD*,const char*,const char*,TABLE_LIST*)" -> "File_parser::type() const"
"mysql_rename_view(THD*,const char*,const char*,TABLE_LIST*)" -> "File_parser::parse(uchar*,MEM_ROOT*,File_option*,uint,Unknown_key_hook*) const"
"mysql_rename_view(THD*,const char*,const char*,TABLE_LIST*)" -> "is_equal(const LEX_STRING*,const LEX_STRING*)"
"mysql_rename_view(THD*,const char*,const char*,TABLE_LIST*)" -> "my_error(int,myf,...)"
"mysql_rename_view(THD*,const char*,const char*,TABLE_LIST*)" -> "build_table_filename(char*,size_t,const char*,const char*,const char*,uint)"
"mysql_rename_view(THD*,const char*,const char*,TABLE_LIST*)" -> "sp_cache_invalidate()"
"mysql_rename_view(THD*,const char*,const char*,TABLE_LIST*)" -> "sql_create_definition_file(const LEX_STRING*,const LEX_STRING*,const LEX_STRING*,uchar*,File_option*)"
"mysql_rename_view(THD*,const char*,const char*,TABLE_LIST*)" -> "build_table_filename(char*,size_t,const char*,const char*,const char*,uint,bool*)"
"rename_in_schema_file(THD*,const char*,const char*,const char*,const char*)" -> "my_dir(const char*,myf)"
"rename_in_schema_file(THD*,const char*,const char*,const char*,const char*)" -> "build_table_filename(char*,size_t,const char*,const char*,const char*,uint)"
"rename_in_schema_file(THD*,const char*,const char*,const char*,const char*)" -> "inline_mysql_file_rename(const char*,const char*,myf)"
"rename_in_schema_file(THD*,const char*,const char*,const char*,const char*)" -> "mysql_rm_arc_files(THD*,MY_DIR*,const char*)"
"mysqld_help(THD*,const char*)" -> "my_eof(THD*)"
"mysqld_help(THD*,const char*)" -> "String::String()"
"mysqld_help(THD*,const char*)" -> "Item_func_equal::Item_func_equal(Item*,Item*)"
"mysqld_help(THD*,const char*)" -> "prepare_simple_select(THD*,Item*,TABLE*,int*)"
"mysqld_help(THD*,const char*)" -> "get_all_items_for_category(THD*,TABLE*,Field*,SQL_SELECT*,List<String>*)"
"mysqld_help(THD*,const char*)" -> "TABLE_LIST::TABLE_LIST()"
"mysqld_help(THD*,const char*)" -> "List<T>::head() [with T = String]"
"mysqld_help(THD*,const char*)" -> "Open_tables_backup::Open_tables_backup()"
"mysqld_help(THD*,const char*)" -> "search_topics(THD*,TABLE*,st_find_field*,SQL_SELECT*,List<String>*,String*,String*,String*)"
"mysqld_help(THD*,const char*)" -> "open_system_tables_for_read(THD*,TABLE_LIST*,Open_tables_backup*)"
"mysqld_help(THD*,const char*)" -> "send_header_2(Protocol*,bool)"
"mysqld_help(THD*,const char*)" -> "search_categories(THD*,TABLE*,st_find_field*,SQL_SELECT*,List<String>*,int16*)"
"mysqld_help(THD*,const char*)" -> "get_topics_for_keyword(THD*,TABLE*,TABLE*,st_find_field*,int16,List<String>*,String*,String*,String*)"
"mysqld_help(THD*,const char*)" -> "setup_tables(THD*,Name_resolution_context*,List<TABLE_LIST>*,TABLE_LIST*,TABLE_LIST**,bool)"
"mysqld_help(THD*,const char*)" -> "Item_field::Item_field(Field*)"
"mysqld_help(THD*,const char*)" -> "List<T>::List() [with T = String]"
"mysqld_help(THD*,const char*)" -> "strlen(const char*)"
"mysqld_help(THD*,const char*)" -> "Item_int::Item_int(int32,uint)"
"mysqld_help(THD*,const char*)" -> "TABLE_LIST::init_one_table(const char*,size_t,const char*,size_t,const char*,thr_lock_type)"
"mysqld_help(THD*,const char*)" -> "send_variant_2_list(MEM_ROOT*,Protocol*,List<String>*,const char*,String*)"
"mysqld_help(THD*,const char*)" -> "prepare_select_for_name(THD*,const char*,uint,TABLE_LIST*,TABLE*,Field*,int*)"
"mysqld_help(THD*,const char*)" -> "search_keyword(THD*,TABLE*,st_find_field*,SQL_SELECT*,int*)"
"mysqld_help(THD*,const char*)" -> "close_system_tables(THD*,Open_tables_backup*)"
"mysqld_help(THD*,const char*)" -> "init_fields(THD*,TABLE_LIST*,st_find_field*,uint)"
"mysqld_help(THD*,const char*)" -> "send_answer_1(Protocol*,String*,String*,String*)"
"prepare_simple_select(THD*,Item*,TABLE*,int*)" -> "SQL_SELECT::check_quick(THD*,bool,ha_rows)"
"prepare_simple_select(THD*,Item*,TABLE*,int*)" -> "Bitmap<64u>::clear_all()"
"prepare_simple_select(THD*,Item*,TABLE*,int*)" -> "make_select(TABLE*,table_map,table_map,Item*,bool,int*)"
"prepare_simple_select(THD*,Item*,TABLE*,int*)" -> "Opt_trace_object::Opt_trace_object(Opt_trace_context*,Opt_trace_context::feature_value)"
"get_all_items_for_category(THD*,TABLE*,Field*,SQL_SELECT*,List<String>*)" -> "init_read_record(READ_RECORD*,THD*,TABLE*,SQL_SELECT*,int,bool,bool)"
"get_all_items_for_category(THD*,TABLE*,Field*,SQL_SELECT*,List<String>*)" -> "List<T>::push_back(T*) [with T = String]"
"get_all_items_for_category(THD*,TABLE*,Field*,SQL_SELECT*,List<String>*)" -> "get_field(MEM_ROOT*,Field*,String*)"
"get_all_items_for_category(THD*,TABLE*,Field*,SQL_SELECT*,List<String>*)" -> "String::String()"
"get_all_items_for_category(THD*,TABLE*,Field*,SQL_SELECT*,List<String>*)" -> "end_read_record(READ_RECORD*)"
"get_all_items_for_category(THD*,TABLE*,Field*,SQL_SELECT*,List<String>*)" -> "READ_RECORD::READ_RECORD()"
"List<T>::head() [with T = String]" -> "base_list::head()"
"search_topics(THD*,TABLE*,st_find_field*,SQL_SELECT*,List<String>*,String*,String*,String*)" -> "end_read_record(READ_RECORD*)"
"search_topics(THD*,TABLE*,st_find_field*,SQL_SELECT*,List<String>*,String*,String*,String*)" -> "init_read_record(READ_RECORD*,THD*,TABLE*,SQL_SELECT*,int,bool,bool)"
"search_topics(THD*,TABLE*,st_find_field*,SQL_SELECT*,List<String>*,String*,String*,String*)" -> "memorize_variant_topic(THD*,TABLE*,int,st_find_field*,List<String>*,String*,String*,String*)"
"search_topics(THD*,TABLE*,st_find_field*,SQL_SELECT*,List<String>*,String*,String*,String*)" -> "READ_RECORD::READ_RECORD()"
"memorize_variant_topic(THD*,TABLE*,int,st_find_field*,List<String>*,String*,String*,String*)" -> "get_field(MEM_ROOT*,Field*,String*)"
"memorize_variant_topic(THD*,TABLE*,int,st_find_field*,List<String>*,String*,String*,String*)" -> "List<T>::push_back(T*) [with T = String]"
"memorize_variant_topic(THD*,TABLE*,int,st_find_field*,List<String>*,String*,String*,String*)" -> "String::String()"
"send_header_2(Protocol*,bool)" -> "Item_empty_string::Item_empty_string(const char*,uint,const CHARSET_INFO*)"
"send_header_2(Protocol*,bool)" -> "List<T>::push_back(T*) [with T = Item]"
"send_header_2(Protocol*,bool)" -> "List<T>::List() [with T = Item]"
"search_categories(THD*,TABLE*,st_find_field*,SQL_SELECT*,List<String>*,int16*)" -> "end_read_record(READ_RECORD*)"
"search_categories(THD*,TABLE*,st_find_field*,SQL_SELECT*,List<String>*,int16*)" -> "String::String()"
"search_categories(THD*,TABLE*,st_find_field*,SQL_SELECT*,List<String>*,int16*)" -> "init_read_record(READ_RECORD*,THD*,TABLE*,SQL_SELECT*,int,bool,bool)"
"search_categories(THD*,TABLE*,st_find_field*,SQL_SELECT*,List<String>*,int16*)" -> "List<T>::push_back(T*) [with T = String]"
"search_categories(THD*,TABLE*,st_find_field*,SQL_SELECT*,List<String>*,int16*)" -> "READ_RECORD::READ_RECORD()"
"search_categories(THD*,TABLE*,st_find_field*,SQL_SELECT*,List<String>*,int16*)" -> "get_field(MEM_ROOT*,Field*,String*)"
"get_topics_for_keyword(THD*,TABLE*,TABLE*,st_find_field*,int16,List<String>*,String*,String*,String*)" -> "handler::ha_index_init(uint,bool)"
"get_topics_for_keyword(THD*,TABLE*,TABLE*,st_find_field*,int16,List<String>*,String*,String*,String*)" -> "handler::ha_index_end()"
"get_topics_for_keyword(THD*,TABLE*,TABLE*,st_find_field*,int16,List<String>*,String*,String*,String*)" -> "handler::ha_index_next(uchar*)"
"get_topics_for_keyword(THD*,TABLE*,TABLE*,st_find_field*,int16,List<String>*,String*,String*,String*)" -> "find_type(const char*,const TYPELIB*,unsigned int)"
"get_topics_for_keyword(THD*,TABLE*,TABLE*,st_find_field*,int16,List<String>*,String*,String*,String*)" -> "handler::ha_index_read_map(uchar*,const uchar*,key_part_map,ha_rkey_function)"
"get_topics_for_keyword(THD*,TABLE*,TABLE*,st_find_field*,int16,List<String>*,String*,String*,String*)" -> "memorize_variant_topic(THD*,TABLE*,int,st_find_field*,List<String>*,String*,String*,String*)"
"get_topics_for_keyword(THD*,TABLE*,TABLE*,st_find_field*,int16,List<String>*,String*,String*,String*)" -> "_current_thd()"
"get_topics_for_keyword(THD*,TABLE*,TABLE*,st_find_field*,int16,List<String>*,String*,String*,String*)" -> "my_message(uint,const char*,myf)"
"send_variant_2_list(MEM_ROOT*,Protocol*,List<String>*,const char*,String*)" -> "my_qsort(void*,size_t,size_t,qsort_cmp)"
"send_variant_2_list(MEM_ROOT*,Protocol*,List<String>*,const char*,String*)" -> "List_iterator<T>::List_iterator(List<T>&) [with T = String]"
"send_variant_2_list(MEM_ROOT*,Protocol*,List<String>*,const char*,String*)" -> "List_iterator<T>::operator++(int) [with T = String]"
"send_variant_2_list(MEM_ROOT*,Protocol*,List<String>*,const char*,String*)" -> "alloc_root(MEM_ROOT*,size_t)"
"send_variant_2_list(MEM_ROOT*,Protocol*,List<String>*,const char*,String*)" -> "Protocol::store(String*)"
"Protocol::store(String*)" -> "String::ptr() const"
"Protocol::store(String*)" -> "String::length() const"
"Protocol::store(String*)" -> "String::charset() const"
"prepare_select_for_name(THD*,const char*,uint,TABLE_LIST*,TABLE*,Field*,int*)" -> "Item_func_like::Item_func_like(Item*,Item*,Item*,bool)"
"prepare_select_for_name(THD*,const char*,uint,TABLE_LIST*,TABLE*,Field*,int*)" -> "Item_string::Item_string(const char*,uint,const CHARSET_INFO*,Derivation,uint)"
"prepare_select_for_name(THD*,const char*,uint,TABLE_LIST*,TABLE*,Field*,int*)" -> "prepare_simple_select(THD*,Item*,TABLE*,int*)"
"prepare_select_for_name(THD*,const char*,uint,TABLE_LIST*,TABLE*,Field*,int*)" -> "Item_field::Item_field(Field*)"
"search_keyword(THD*,TABLE*,st_find_field*,SQL_SELECT*,int*)" -> "READ_RECORD::READ_RECORD()"
"search_keyword(THD*,TABLE*,st_find_field*,SQL_SELECT*,int*)" -> "end_read_record(READ_RECORD*)"
"search_keyword(THD*,TABLE*,st_find_field*,SQL_SELECT*,int*)" -> "init_read_record(READ_RECORD*,THD*,TABLE*,SQL_SELECT*,int,bool,bool)"
"init_fields(THD*,TABLE_LIST*,st_find_field*,uint)" -> "find_field_in_tables(THD*,Item_ident*,TABLE_LIST*,TABLE_LIST*,Item**,find_item_error_report_type,bool,bool)"
"init_fields(THD*,TABLE_LIST*,st_find_field*,uint)" -> "Name_resolution_context::resolve_in_table_list_only(TABLE_LIST*)"
"init_fields(THD*,TABLE_LIST*,st_find_field*,uint)" -> "Item_field::Item_field(Name_resolution_context*,const char*,const char*,const char*)"
"init_fields(THD*,TABLE_LIST*,st_find_field*,uint)" -> "bitmap_set_bit(MY_BITMAP*,uint)"
"send_answer_1(Protocol*,String*,String*,String*)" -> "Item_empty_string::Item_empty_string(const char*,uint,const CHARSET_INFO*)"
"send_answer_1(Protocol*,String*,String*,String*)" -> "List<T>::List() [with T = Item]"
"send_answer_1(Protocol*,String*,String*,String*)" -> "Protocol::store(String*)"
"send_answer_1(Protocol*,String*,String*,String*)" -> "List<T>::push_back(T*) [with T = Item]"
"flush_tables_with_read_lock(THD*,TABLE_LIST*)" -> "tdc_remove_table(THD*,enum_tdc_remove_table_type,const char*,const char*,bool)"
"flush_tables_with_read_lock(THD*,TABLE_LIST*)" -> "my_error(int,myf,...)"
"flush_tables_with_read_lock(THD*,TABLE_LIST*)" -> "open_and_lock_tables(THD*,TABLE_LIST*,bool,uint,Prelocking_strategy*)"
"flush_tables_with_read_lock(THD*,TABLE_LIST*)" -> "lock_table_names(THD*,TABLE_LIST*,TABLE_LIST*,ulong,uint)"
"flush_tables_with_read_lock(THD*,TABLE_LIST*)" -> "Lock_tables_prelocking_strategy::Lock_tables_prelocking_strategy()"
"flush_tables_with_read_lock(THD*,TABLE_LIST*)" -> "Locked_tables_list::init_locked_tables(THD*)"
"Lock_tables_prelocking_strategy::Lock_tables_prelocking_strategy()" -> "DML_prelocking_strategy::DML_prelocking_strategy()"
"Locked_tables_list::init_locked_tables(THD*)" -> "TABLE_LIST::init_one_table(const char*,size_t,const char*,size_t,const char*,thr_lock_type)"
"Locked_tables_list::init_locked_tables(THD*)" -> "Locked_tables_list::unlock_locked_tables(THD*)"
"Locked_tables_list::init_locked_tables(THD*)" -> "alloc_root(MEM_ROOT*,size_t)"
"Locked_tables_list::init_locked_tables(THD*)" -> "memcpy(void*,const void*,size_t)"
"Locked_tables_list::init_locked_tables(THD*)" -> "THD::enter_locked_tables_mode(enum_locked_tables_mode)"
"Locked_tables_list::init_locked_tables(THD*)" -> "strlen(const char*)"
"Locked_tables_list::init_locked_tables(THD*)" -> "multi_alloc_root(MEM_ROOT*,...)"
"trans_xa_end(THD*)" -> "THD::is_error() const"
"trans_xa_end(THD*)" -> "my_error(int,myf,...)"
"trans_xa_end(THD*)" -> "xa_trans_rolled_back(XID_STATE*)"
"trans_xa_end(THD*)" -> "xid_t::eq(xid_t*)"
"mysql_upgrade_db(THD*,LEX_STRING*)" -> "fn_rext(char*)"
"mysql_upgrade_db(THD*,LEX_STRING*)" -> "Statement::query() const"
"mysql_upgrade_db(THD*,LEX_STRING*)" -> "MYSQL_BIN_LOG::write_event(Log_event*)"
"mysql_upgrade_db(THD*,LEX_STRING*)" -> "MYSQL_LOG::is_open()"
"mysql_upgrade_db(THD*,LEX_STRING*)" -> "st_ha_create_information::st_ha_create_information()"
"mysql_upgrade_db(THD*,LEX_STRING*)" -> "query_error_code(THD*,bool)"
"mysql_upgrade_db(THD*,LEX_STRING*)" -> "rmdir(const char*)"
"mysql_upgrade_db(THD*,LEX_STRING*)" -> "inline_mysql_file_delete(const char*,myf)"
"mysql_upgrade_db(THD*,LEX_STRING*)" -> "inline_mysql_file_rename(const char*,const char*,myf)"
"mysql_upgrade_db(THD*,LEX_STRING*)" -> "build_table_filename(char*,size_t,const char*,const char*,const char*,uint)"
"mysql_upgrade_db(THD*,LEX_STRING*)" -> "mysql_create_db(THD*,char*,HA_CREATE_INFO*,bool)"
"mysql_upgrade_db(THD*,LEX_STRING*)" -> "mysql_change_db(THD*,const LEX_STRING*,bool)"
"mysql_upgrade_db(THD*,LEX_STRING*)" -> "strcmp(const char*,const char*)"
"mysql_upgrade_db(THD*,LEX_STRING*)" -> "load_db_opt(THD*,const char*,HA_CREATE_INFO*)"
"mysql_upgrade_db(THD*,LEX_STRING*)" -> "lock_schema_name(THD*,const char*)"
"mysql_upgrade_db(THD*,LEX_STRING*)" -> "sql_memdup(const void*,size_t)"
"mysql_upgrade_db(THD*,LEX_STRING*)" -> "THD::clear_error()"
"mysql_upgrade_db(THD*,LEX_STRING*)" -> "Table_ident::Table_ident(THD*,LEX_STRING,LEX_STRING,bool)"
"mysql_upgrade_db(THD*,LEX_STRING*)" -> "strncmp(const char*,const char*,size_t)"
"mysql_upgrade_db(THD*,LEX_STRING*)" -> "my_error(int,myf,...)"
"mysql_upgrade_db(THD*,LEX_STRING*)" -> "Query_log_event::Query_log_event(THD*,const char*,ulong,bool,bool,bool,int,bool)"
"mysql_upgrade_db(THD*,LEX_STRING*)" -> "my_dir(const char*,myf)"
"mysql_upgrade_db(THD*,LEX_STRING*)" -> "access(const char*,int)"
"mysql_upgrade_db(THD*,LEX_STRING*)" -> "my_dirend(MY_DIR*)"
"mysql_upgrade_db(THD*,LEX_STRING*)" -> "filename_to_tablename(const char*,char*,uint)"
"mysql_upgrade_db(THD*,LEX_STRING*)" -> "Statement::query_length() const"
"mysql_upgrade_db(THD*,LEX_STRING*)" -> "mysql_rename_tables(THD*,TABLE_LIST*,bool)"
"mysql_upgrade_db(THD*,LEX_STRING*)" -> "mysql_rm_db(THD*,char*,bool,bool)"
"fn_rext(char*)" -> "strlen(const char*)"
"fn_rext(char*)" -> "strcmp(const char*,const char*)"
"fn_rext(char*)" -> "strrchr(char*,int)"
"mysql_sql_stmt_prepare(THD*)" -> "Statement_map::find_by_name(LEX_STRING*)"
"mysql_sql_stmt_prepare(THD*)" -> "my_error(int,myf,...)"
"mysql_sql_stmt_prepare(THD*)" -> "my_ok(THD*,ulonglong,ulonglong,const char*)"
"mysql_sql_stmt_prepare(THD*)" -> "Prepared_statement::set_name(LEX_STRING*)"
"mysql_sql_stmt_prepare(THD*)" -> "Prepared_statement::Prepared_statement(THD*)"
"mysql_sql_stmt_prepare(THD*)" -> "get_dynamic_sql_string(LEX*,uint*)"
"mysql_sql_stmt_prepare(THD*)" -> "Prepared_statement::prepare(const char*,uint)"
"mysql_sql_stmt_prepare(THD*)" -> "Prepared_statement::set_sql_prepare()"
"mysql_sql_stmt_prepare(THD*)" -> "Prepared_statement::is_in_use()"
"mysql_sql_stmt_prepare(THD*)" -> "Statement_map::insert(THD*,Statement*)"
"mysql_sql_stmt_prepare(THD*)" -> "Prepared_statement::deallocate()"
"mysql_sql_stmt_prepare(THD*)" -> "Statement_map::erase(Statement*)"
"get_dynamic_sql_string(LEX*,uint*)" -> "String::length() const"
"get_dynamic_sql_string(LEX*,uint*)" -> "String::charset() const"
"get_dynamic_sql_string(LEX*,uint*)" -> "String::String()"
"get_dynamic_sql_string(LEX*,uint*)" -> "memcpy(void*,const void*,size_t)"
"get_dynamic_sql_string(LEX*,uint*)" -> "alloc_root(MEM_ROOT*,size_t)"
"get_dynamic_sql_string(LEX*,uint*)" -> "String::needs_conversion(uint32,const CHARSET_INFO*,const CHARSET_INFO*,uint32*)"
"get_dynamic_sql_string(LEX*,uint*)" -> "String::ptr() const"
"get_dynamic_sql_string(LEX*,uint*)" -> "my_hash_search(const HASH*,const uchar*,size_t)"
"get_dynamic_sql_string(LEX*,uint*)" -> "copy_and_convert(char*,uint32,const CHARSET_INFO*,const char*,uint32,const CHARSET_INFO*,uint*)"
"get_dynamic_sql_string(LEX*,uint*)" -> "user_var_entry::val_str(my_bool*,String*,uint)"
"get_dynamic_sql_string(LEX*,uint*)" -> "user_var_entry::ptr() const"
"get_dynamic_sql_string(LEX*,uint*)" -> "String::set(const char*,uint32,const CHARSET_INFO*)"
"user_var_entry::val_str(my_bool*,String*,uint)" -> "str_set_decimal(const my_decimal*,String*,const CHARSET_INFO*)"
"user_var_entry::val_str(my_bool*,String*,uint)" -> "String::set_real(double,uint,const CHARSET_INFO*)"
"user_var_entry::val_str(my_bool*,String*,uint)" -> "String::copy(const char*,uint32,const CHARSET_INFO*)"
"user_var_entry::val_str(my_bool*,String*,uint)" -> "String::set(ulonglong,const CHARSET_INFO*)"
"user_var_entry::val_str(my_bool*,String*,uint)" -> "String::set(longlong,const CHARSET_INFO*)"
"str_set_decimal(const my_decimal*,String*,const CHARSET_INFO*)" -> "str_set_decimal(uint,const my_decimal*,uint,uint,char,String*,const CHARSET_INFO*)"
"str_set_decimal(uint,const my_decimal*,uint,uint,char,String*,const CHARSET_INFO*)" -> "String::ptr() const"
"str_set_decimal(uint,const my_decimal*,uint,uint,char,String*,const CHARSET_INFO*)" -> "my_decimal2string(uint,const my_decimal*,uint,uint,char,String*)"
"str_set_decimal(uint,const my_decimal*,uint,uint,char,String*,const CHARSET_INFO*)" -> "String::set_charset(const CHARSET_INFO*)"
"str_set_decimal(uint,const my_decimal*,uint,uint,char,String*,const CHARSET_INFO*)" -> "String::String(char*,uint32,const CHARSET_INFO*)"
"str_set_decimal(uint,const my_decimal*,uint,uint,char,String*,const CHARSET_INFO*)" -> "String::length() const"
"str_set_decimal(uint,const my_decimal*,uint,uint,char,String*,const CHARSET_INFO*)" -> "String::copy(const char*,uint32,const CHARSET_INFO*,const CHARSET_INFO*,uint*)"
"my_decimal2string(uint,const my_decimal*,uint,uint,char,String*)" -> "String::length(uint32)"
"my_decimal2string(uint,const my_decimal*,uint,uint,char,String*)" -> "String::alloc(uint32)"
"my_decimal2string(uint,const my_decimal*,uint,uint,char,String*)" -> "String::set_charset(const CHARSET_INFO*)"
"my_decimal2string(uint,const my_decimal*,uint,uint,char,String*)" -> "decimal2string(const decimal_t*,char*,int*,int,int,char)"
"my_decimal2string(uint,const my_decimal*,uint,uint,char,String*)" -> "my_decimal_string_length(const my_decimal*)"
"my_decimal2string(uint,const my_decimal*,uint,uint,char,String*)" -> "check_result(uint,int)"
"my_decimal2string(uint,const my_decimal*,uint,uint,char,String*)" -> "String::ptr() const"
"decimal2string(const decimal_t*,char*,int*,int,int,char)" -> "remove_leading_zeroes(const decimal_t*,int*)"
"decimal2string(const decimal_t*,char*,int*,int,int,char)" -> "__builtin_expect(long int,long int)"
"String::set_real(double,uint,const CHARSET_INFO*)" -> "my_fcvt(double,int,char*,my_bool*)"
"String::set_real(double,uint,const CHARSET_INFO*)" -> "String::copy(const char*,uint32,const CHARSET_INFO*,const CHARSET_INFO*,uint*)"
"String::set_real(double,uint,const CHARSET_INFO*)" -> "my_gcvt(double,my_gcvt_arg_type,int,char*,my_bool*)"
"mysql_drop_view(THD*,TABLE_LIST*,enum_drop_mode)" -> "access(const char*,int)"
"mysql_drop_view(THD*,TABLE_LIST*,enum_drop_mode)" -> "push_warning_printf(THD*,Sql_condition::enum_warning_level,uint,const char*,...)"
"mysql_drop_view(THD*,TABLE_LIST*,enum_drop_mode)" -> "my_ok(THD*,ulonglong,ulonglong,const char*)"
"mysql_drop_view(THD*,TABLE_LIST*,enum_drop_mode)" -> "String::String(const char*,const CHARSET_INFO*)"
"mysql_drop_view(THD*,TABLE_LIST*,enum_drop_mode)" -> "String::String()"
"mysql_drop_view(THD*,TABLE_LIST*,enum_drop_mode)" -> "Statement::query() const"
"mysql_drop_view(THD*,TABLE_LIST*,enum_drop_mode)" -> "_current_thd()"
"mysql_drop_view(THD*,TABLE_LIST*,enum_drop_mode)" -> "String::length() const"
"mysql_drop_view(THD*,TABLE_LIST*,enum_drop_mode)" -> "my_error(int,myf,...)"
"mysql_drop_view(THD*,TABLE_LIST*,enum_drop_mode)" -> "String::append(const String&)"
"mysql_drop_view(THD*,TABLE_LIST*,enum_drop_mode)" -> "sp_cache_invalidate()"
"mysql_drop_view(THD*,TABLE_LIST*,enum_drop_mode)" -> "tdc_remove_table(THD*,enum_tdc_remove_table_type,const char*,const char*,bool)"
"mysql_drop_view(THD*,TABLE_LIST*,enum_drop_mode)" -> "write_bin_log(THD*,bool,const char*,ulong,bool)"
"mysql_drop_view(THD*,TABLE_LIST*,enum_drop_mode)" -> "dd_frm_type(THD*,char*,legacy_db_type*)"
"mysql_drop_view(THD*,TABLE_LIST*,enum_drop_mode)" -> "lock_table_names(THD*,TABLE_LIST*,TABLE_LIST*,ulong,uint)"
"mysql_drop_view(THD*,TABLE_LIST*,enum_drop_mode)" -> "build_table_filename(char*,size_t,const char*,const char*,const char*,uint)"
"mysql_drop_view(THD*,TABLE_LIST*,enum_drop_mode)" -> "inline_mysql_file_delete(const char*,myf)"
"mysql_drop_view(THD*,TABLE_LIST*,enum_drop_mode)" -> "String::append(char)"
"mysql_drop_view(THD*,TABLE_LIST*,enum_drop_mode)" -> "THD::add_to_binlog_accessed_dbs(const char*)"
"mysql_drop_view(THD*,TABLE_LIST*,enum_drop_mode)" -> "String::c_ptr()"
"mysql_drop_view(THD*,TABLE_LIST*,enum_drop_mode)" -> "Statement::query_length() const"
"mysql_drop_view(THD*,TABLE_LIST*,enum_drop_mode)" -> "Query_cache::invalidate(THD*,TABLE_LIST*,my_bool)"
"trans_xa_start(THD*)" -> "xid_t::null()"
"trans_xa_start(THD*)" -> "xid_cache_insert(XID_STATE*)"
"trans_xa_start(THD*)" -> "THD::in_active_multi_stmt_transaction() const"
"trans_xa_start(THD*)" -> "trans_begin(THD*,uint)"
"trans_xa_start(THD*)" -> "xid_t::set(xid_t*)"
"trans_xa_start(THD*)" -> "xid_t::eq(xid_t*)"
"trans_xa_start(THD*)" -> "my_error(int,myf,...)"
"trans_xa_start(THD*)" -> "trans_rollback(THD*)"
"xid_cache_insert(XID_STATE*)" -> "xid_t::key_length()"
"xid_cache_insert(XID_STATE*)" -> "xid_t::key()"
"xid_cache_insert(XID_STATE*)" -> "inline_mysql_mutex_unlock(mysql_mutex_t*)"
"xid_cache_insert(XID_STATE*)" -> "inline_mysql_mutex_lock(mysql_mutex_t*)"
"xid_cache_insert(XID_STATE*)" -> "my_hash_search(const HASH*,const uchar*,size_t)"
"xid_cache_insert(XID_STATE*)" -> "my_hash_insert(HASH*,const uchar*)"
"xid_cache_insert(XID_STATE*)" -> "my_error(int,myf,...)"
"xid_t::set(xid_t*)" -> "xid_t::length()"
"xid_t::set(xid_t*)" -> "memcpy(void*,const void*,size_t)"
"lock_tables_open_and_lock_tables(THD*,TABLE_LIST*)" -> "TABLE_LIST::placeholder()"
"lock_tables_open_and_lock_tables(THD*,TABLE_LIST*)" -> "close_thread_tables(THD*)"
"lock_tables_open_and_lock_tables(THD*,TABLE_LIST*)" -> "Lock_tables_prelocking_strategy::Lock_tables_prelocking_strategy()"
"lock_tables_open_and_lock_tables(THD*,TABLE_LIST*)" -> "Locked_tables_list::init_locked_tables(THD*)"
"lock_tables_open_and_lock_tables(THD*,TABLE_LIST*)" -> "lock_tables(THD*,TABLE_LIST*,uint,uint)"
"lock_tables_open_and_lock_tables(THD*,TABLE_LIST*)" -> "MDL_context::release_transactional_locks()"
"lock_tables_open_and_lock_tables(THD*,TABLE_LIST*)" -> "open_tables(THD*,TABLE_LIST**,uint*,uint,Prelocking_strategy*)"
"lock_tables_open_and_lock_tables(THD*,TABLE_LIST*)" -> "trans_rollback(THD*)"
"lock_tables_open_and_lock_tables(THD*,TABLE_LIST*)" -> "trans_rollback_stmt(THD*)"
"flush_tables_for_export(THD*,TABLE_LIST*)" -> "my_error(int,myf,...)"
"flush_tables_for_export(THD*,TABLE_LIST*)" -> "handler::ha_table_flags() const"
"flush_tables_for_export(THD*,TABLE_LIST*)" -> "open_and_lock_tables(THD*,TABLE_LIST*,bool,uint,Prelocking_strategy*)"
"flush_tables_for_export(THD*,TABLE_LIST*)" -> "Locked_tables_list::init_locked_tables(THD*)"
"flush_tables_for_export(THD*,TABLE_LIST*)" -> "Lock_tables_prelocking_strategy::Lock_tables_prelocking_strategy()"
"gtid_empty_group_log_and_cleanup(THD*)" -> "MYSQL_BIN_LOG::commit(THD*,bool)"
"gtid_empty_group_log_and_cleanup(THD*)" -> "thd_get_cache_mngr(const THD*)"
"gtid_empty_group_log_and_cleanup(THD*)" -> "gtid_before_write_cache(THD*,binlog_cache_data*)"
"gtid_empty_group_log_and_cleanup(THD*)" -> "binlog_cache_data::write_event(THD*,Log_event*)"
"gtid_empty_group_log_and_cleanup(THD*)" -> "Query_log_event::Query_log_event(THD*,const char*,ulong,bool,bool,bool,int,bool)"
"gtid_empty_group_log_and_cleanup(THD*)" -> "THD::binlog_setup_trx_data()"
"mysqld_stmt_fetch(THD*,char*,uint)" -> "Statement::set_n_backup_statement(Statement*,Statement*)"
"mysqld_stmt_fetch(THD*,char*,uint)" -> "llstr(longlong,char*)"
"mysqld_stmt_fetch(THD*,char*,uint)" -> "my_error(int,myf,...)"
"mysqld_stmt_fetch(THD*,char*,uint)" -> "reset_stmt_params(Prepared_statement*)"
"mysqld_stmt_fetch(THD*,char*,uint)" -> "mysql_reset_thd_for_next_command(THD*)"
"mysqld_stmt_fetch(THD*,char*,uint)" -> "find_prepared_statement(THD*,ulong)"
"mysqld_stmt_fetch(THD*,char*,uint)" -> "Prepared_statement::close_cursor()"
"mysqld_stmt_fetch(THD*,char*,uint)" -> "Statement::restore_backup_statement(Statement*,Statement*)"
"mysqld_stmt_fetch(THD*,char*,uint)" -> "Statement::Statement()"
"log_slow_statement(THD*)" -> "log_slow_applicable(THD*)"
"log_slow_statement(THD*)" -> "log_slow_do(THD*)"
"log_slow_applicable(THD*)" -> "__builtin_expect(long int,long int)"
"log_slow_applicable(THD*)" -> "THD::get_examined_row_count() const"
"log_slow_applicable(THD*)" -> "Slow_log_throttle::log(THD*,bool)"
"Slow_log_throttle::log(THD*,bool)" -> "Slow_log_throttle::print_summary(THD*,ulong,ulonglong,ulonglong)"
"Slow_log_throttle::log(THD*,bool)" -> "Log_throttle::inc_log_count(ulong)"
"Slow_log_throttle::log(THD*,bool)" -> "inline_mysql_mutex_lock(mysql_mutex_t*)"
"Slow_log_throttle::log(THD*,bool)" -> "Log_throttle::prepare_summary(ulong)"
"Slow_log_throttle::log(THD*,bool)" -> "Log_throttle::in_window(ulonglong) const"
"Slow_log_throttle::log(THD*,bool)" -> "Slow_log_throttle::new_window(ulonglong)"
"Slow_log_throttle::log(THD*,bool)" -> "THD::current_utime()"
"Slow_log_throttle::log(THD*,bool)" -> "inline_mysql_mutex_unlock(mysql_mutex_t*)"
"Slow_log_throttle::print_summary(THD*,ulong,ulonglong,ulonglong)" -> "strlen(const char*)"
"Slow_log_throttle::print_summary(THD*,ulong,ulonglong,ulonglong)" -> "snprintf(char*,size_t,const char*,...)"
"Slow_log_throttle::print_summary(THD*,ulong,ulonglong,ulonglong)" -> "THD::current_utime()"
"Slow_log_throttle::print_summary(THD*,ulong,ulonglong,ulonglong)" -> "inline_mysql_mutex_lock(mysql_mutex_t*)"
"Slow_log_throttle::print_summary(THD*,ulong,ulonglong,ulonglong)" -> "inline_mysql_mutex_unlock(mysql_mutex_t*)"
"Slow_log_throttle::new_window(ulonglong)" -> "Log_throttle::new_window(ulonglong)"
"log_slow_do(THD*)" -> "THD::enter_stage(const PSI_stage_info*,PSI_stage_info*,const char*,const char*,unsigned int)"
"log_slow_do(THD*)" -> "Statement::query() const"
"log_slow_do(THD*)" -> "slow_log_print(THD*,const char*,uint)"
"log_slow_do(THD*)" -> "Statement::query_length() const"
"log_slow_do(THD*)" -> "String::length() const"
"log_slow_do(THD*)" -> "String::c_ptr_safe()"
"slow_log_print(THD*,const char*,uint)" -> "LOGGER::slow_log_print(THD*,const char*,uint)"
"LOGGER::slow_log_print(THD*,const char*,uint)" -> "String::length() const"
"LOGGER::slow_log_print(THD*,const char*,uint)" -> "my_time_possible_from_micro(ulonglong)"
"LOGGER::slow_log_print(THD*,const char*,uint)" -> "Security_context::get_ip()"
"LOGGER::slow_log_print(THD*,const char*,uint)" -> "Security_context::get_host()"
"LOGGER::slow_log_print(THD*,const char*,uint)" -> "String::ptr() const"
"LOGGER::slow_log_print(THD*,const char*,uint)" -> "strxnmov(char*,size_t,const char*,...)"
"LOGGER::slow_log_print(THD*,const char*,uint)" -> "THD::get_command() const"
"LOGGER::slow_log_print(THD*,const char*,uint)" -> "THD::current_utime()"
"LOGGER::slow_log_print(THD*,const char*,uint)" -> "LOGGER::unlock()"
"LOGGER::slow_log_print(THD*,const char*,uint)" -> "LOGGER::lock_shared()"
"Security_context::Security_context(const Security_context&)" -> "String::String(const String&)"
"mysqld_stmt_execute(THD*,char*,uint)" -> "PROFILING::set_query_source(char*,uint)"
"mysqld_stmt_execute(THD*,char*,uint)" -> "String::String()"
"mysqld_stmt_execute(THD*,char*,uint)" -> "Statement::query_length() const"
"mysqld_stmt_execute(THD*,char*,uint)" -> "sp_cache_enforce_limit(sp_cache*,ulong)"
"mysqld_stmt_execute(THD*,char*,uint)" -> "Statement::query() const"
"mysqld_stmt_execute(THD*,char*,uint)" -> "Prepared_statement::execute_loop(String*,bool,uchar*,uchar*)"
"mysqld_stmt_execute(THD*,char*,uint)" -> "mysql_reset_thd_for_next_command(THD*)"
"mysqld_stmt_execute(THD*,char*,uint)" -> "my_error(int,myf,...)"
"mysqld_stmt_execute(THD*,char*,uint)" -> "find_prepared_statement(THD*,ulong)"
"mysqld_stmt_execute(THD*,char*,uint)" -> "llstr(longlong,char*)"
"Parser_state::reset(char*,unsigned int)" -> "Lex_input_stream::reset(char*,unsigned int)"
"Parser_state::reset(char*,unsigned int)" -> "Yacc_state::reset()"
"Security_context::operator=(const Security_context&)" -> "String::operator=(const String&)"
"String::operator=(const String&)" -> "String::free()"
"mysqld_list_fields(THD*,TABLE_LIST*,const char*)" -> "open_normal_and_derived_tables(THD*,TABLE_LIST*,uint)"
"mysqld_list_fields(THD*,TABLE_LIST*,const char*)" -> "List<T>::push_back(T*) [with T = Item]"
"mysqld_list_fields(THD*,TABLE_LIST*,const char*)" -> "Item_field::Item_field(Field*)"
"mysqld_list_fields(THD*,TABLE_LIST*,const char*)" -> "memcpy(void*,const void*,size_t)"
"mysqld_list_fields(THD*,TABLE_LIST*,const char*)" -> "wild_case_compare(CHARSET_INFO*,const char*,const char*)"
"mysqld_list_fields(THD*,TABLE_LIST*,const char*)" -> "mysql_handle_single_derived(LEX*,TABLE_LIST*,bool (*)(THD*,LEX*,TABLE_LIST*))"
"mysqld_list_fields(THD*,TABLE_LIST*,const char*)" -> "my_eof(THD*)"
"mysqld_list_fields(THD*,TABLE_LIST*,const char*)" -> "List<T>::List() [with T = Item]"
"mysqld_list_fields(THD*,TABLE_LIST*,const char*)" -> "TABLE::use_all_columns()"
"mysqld_list_fields(THD*,TABLE_LIST*,const char*)" -> "Item_ident_for_show::Item_ident_for_show(Field*,const char*,const char*)"
"wild_case_compare(CHARSET_INFO*,const char*,const char*)" -> "wild_case_compare(CHARSET_INFO*,const char*,const char*)"
"Item_ident_for_show::Item_ident_for_show(Field*,const char*,const char*)" -> "Item::Item()"
"acl_authenticate(THD*,uint)" -> "strcmp(const char*,const char*)"
"acl_authenticate(THD*,uint)" -> "Diagnostics_area::disable_status()"
"acl_authenticate(THD*,uint)" -> "THD::get_stmt_da()"
"acl_authenticate(THD*,uint)" -> "my_error(int,myf,...)"
"acl_authenticate(THD*,uint)" -> "release_user_connection(THD*)"
"acl_authenticate(THD*,uint)" -> "Security_context::set_external_user(const char*)"
"acl_authenticate(THD*,uint)" -> "check_for_max_user_connections(THD*,const USER_CONN*)"
"acl_authenticate(THD*,uint)" -> "THD::get_user_connect()"
"acl_authenticate(THD*,uint)" -> "Security_context::skip_grants()"
"acl_authenticate(THD*,uint)" -> "my_ok(THD*,ulonglong,ulonglong,const char*)"
"acl_authenticate(THD*,uint)" -> "login_failed_error(MPVIO_EXT*,int)"
"acl_authenticate(THD*,uint)" -> "parse_com_change_user_packet(MPVIO_EXT*,uint)"
"acl_authenticate(THD*,uint)" -> "general_log_print(THD*,enum_server_command,const char*,...)"
"acl_authenticate(THD*,uint)" -> "my_strdup(const char*,myf)"
"acl_authenticate(THD*,uint)" -> "inline_mysql_mutex_unlock(mysql_mutex_t*)"
"acl_authenticate(THD*,uint)" -> "strlen(const char*)"
"acl_authenticate(THD*,uint)" -> "inline_mysql_mutex_lock(mysql_mutex_t*)"
"acl_authenticate(THD*,uint)" -> "server_mpvio_update_thd(THD*,MPVIO_EXT*)"
"acl_authenticate(THD*,uint)" -> "server_mpvio_initialize(THD*,MPVIO_EXT*,Thd_charset_adapter*)"
"acl_authenticate(THD*,uint)" -> "Thd_charset_adapter::Thd_charset_adapter(THD*)"
"acl_authenticate(THD*,uint)" -> "THD::reset_db(char*,size_t)"
"acl_authenticate(THD*,uint)" -> "do_auth_once(THD*,LEX_STRING*,MPVIO_EXT*)"
"acl_authenticate(THD*,uint)" -> "THD::is_error() const"
"acl_authenticate(THD*,uint)" -> "mysql_change_db(THD*,const LEX_STRING*,bool)"
"acl_authenticate(THD*,uint)" -> "MPVIO_EXT::can_authenticate()"
"acl_authenticate(THD*,uint)" -> "inc_host_errors(const char*,Host_errors*)"
"acl_authenticate(THD*,uint)" -> "THD::set_user_connect(USER_CONN*)"
"acl_authenticate(THD*,uint)" -> "Host_errors::Host_errors()"
"release_user_connection(THD*)" -> "THD::set_user_connect(USER_CONN*)"
"release_user_connection(THD*)" -> "THD::get_user_connect()"
"Security_context::set_external_user(const char*)" -> "strlen(const char*)"
"Security_context::set_external_user(const char*)" -> "String::set(const char*,uint32,const CHARSET_INFO*)"
"login_failed_error(MPVIO_EXT*,int)" -> "general_log_print(THD*,enum_server_command,const char*,...)"
"login_failed_error(MPVIO_EXT*,int)" -> "sql_print_warning(const char*,...)"
"login_failed_error(MPVIO_EXT*,int)" -> "_current_thd()"
"login_failed_error(MPVIO_EXT*,int)" -> "my_error(int,myf,...)"
"parse_com_change_user_packet(MPVIO_EXT*,uint)" -> "strend(const char*)"
"parse_com_change_user_packet(MPVIO_EXT*,uint)" -> "sql_print_warning(const char*,...)"
"parse_com_change_user_packet(MPVIO_EXT*,uint)" -> "copy_and_convert(char*,uint32,const CHARSET_INFO*,const char*,uint32,const CHARSET_INFO*,uint*)"
"parse_com_change_user_packet(MPVIO_EXT*,uint)" -> "strlen(const char*)"
"parse_com_change_user_packet(MPVIO_EXT*,uint)" -> "Thd_charset_adapter::init_client_charset(uint)"
"parse_com_change_user_packet(MPVIO_EXT*,uint)" -> "my_strndup(const char*,size_t,myf)"
"parse_com_change_user_packet(MPVIO_EXT*,uint)" -> "strmake(char*,const char*,size_t)"
"parse_com_change_user_packet(MPVIO_EXT*,uint)" -> "Thd_charset_adapter::charset()"
"parse_com_change_user_packet(MPVIO_EXT*,uint)" -> "my_message(uint,const char*,myf)"
"parse_com_change_user_packet(MPVIO_EXT*,uint)" -> "make_lex_string_root(MEM_ROOT*,LEX_STRING*,const char*,uint,bool)"
"parse_com_change_user_packet(MPVIO_EXT*,uint)" -> "_current_thd()"
"Thd_charset_adapter::init_client_charset(uint)" -> "THD::is_error() const"
"Thd_charset_adapter::init_client_charset(uint)" -> "THD::update_charset()"
"Thd_charset_adapter::init_client_charset(uint)" -> "thd_init_client_charset(THD*,uint)"
"thd_init_client_charset(THD*,uint)" -> "my_error(int,myf,...)"
"thd_init_client_charset(THD*,uint)" -> "is_supported_parser_charset(const CHARSET_INFO*)"
"thd_init_client_charset(THD*,uint)" -> "get_charset(uint,myf)"
"Thd_charset_adapter::charset()" -> "THD::charset()"
"server_mpvio_initialize(THD*,MPVIO_EXT*,Thd_charset_adapter*)" -> "String::ptr() const"
"server_mpvio_initialize(THD*,MPVIO_EXT*,Thd_charset_adapter*)" -> "memset(void*,int,size_t)"
"server_mpvio_initialize(THD*,MPVIO_EXT*,Thd_charset_adapter*)" -> "strlen(const char*)"
"server_mpvio_initialize(THD*,MPVIO_EXT*,Thd_charset_adapter*)" -> "Security_context::get_host()"
"server_mpvio_initialize(THD*,MPVIO_EXT*,Thd_charset_adapter*)" -> "Security_context::get_ip()"
"do_auth_once(THD*,LEX_STRING*,MPVIO_EXT*)" -> "inc_host_errors(const char*,Host_errors*)"
"do_auth_once(THD*,LEX_STRING*,MPVIO_EXT*)" -> "my_error(int,myf,...)"
"do_auth_once(THD*,LEX_STRING*,MPVIO_EXT*)" -> "plugin_unlock(THD*,plugin_ref)"
"do_auth_once(THD*,LEX_STRING*,MPVIO_EXT*)" -> "Host_errors::Host_errors()"
"inc_host_errors(const char*,Host_errors*)" -> "Host_errors::aggregate(const Host_errors*)"
"inc_host_errors(const char*,Host_errors*)" -> "hostname_cache_search(const char*)"
"inc_host_errors(const char*,Host_errors*)" -> "Host_entry::set_error_timestamps(ulonglong)"
"inc_host_errors(const char*,Host_errors*)" -> "Host_errors::clear_connect_errors()"
"inc_host_errors(const char*,Host_errors*)" -> "my_micro_time()"
"inc_host_errors(const char*,Host_errors*)" -> "inline_mysql_mutex_lock(mysql_mutex_t*)"
"inc_host_errors(const char*,Host_errors*)" -> "inline_mysql_mutex_unlock(mysql_mutex_t*)"
"inc_host_errors(const char*,Host_errors*)" -> "prepare_hostname_cache_key(const char*,char*)"
"inc_host_errors(const char*,Host_errors*)" -> "Host_errors::sum_connect_errors()"
"hostname_cache_search(const char*)" -> "hash_filo::search(uchar*,size_t)"
"hash_filo::search(uchar*,size_t)" -> "my_hash_search(const HASH*,const uchar*,size_t)"
"prepare_hostname_cache_key(const char*,char*)" -> "strlen(const char*)"
"prepare_hostname_cache_key(const char*,char*)" -> "memcpy(void*,const void*,size_t)"
"prepare_hostname_cache_key(const char*,char*)" -> "memset(void*,int,size_t)"
"THD::set_time()" -> "my_micro_time()"
"THD::set_time()" -> "my_micro_time_to_timeval(ulonglong,timeval*)"
"inc_thread_running()" -> "my_atomic_add32(volatile int32*,int32)"
"Query_cache::end_of_result(THD*)" -> "THD::is_error() const"
"Query_cache::end_of_result(THD*)" -> "Query_cache_query::unlock_writing()"
"Query_cache::end_of_result(THD*)" -> "emb_count_querycache_size(THD*)"
"Query_cache::end_of_result(THD*)" -> "Query_cache::split_block(Query_cache_block*,ulong)"
"Query_cache::end_of_result(THD*)" -> "Query_cache_query::result()"
"Query_cache::end_of_result(THD*)" -> "Query_cache::insert(Query_cache_tls*,const char*,ulong,unsigned int)"
"Query_cache::end_of_result(THD*)" -> "THD::enter_stage(const PSI_stage_info*,PSI_stage_info*,const char*,const char*,unsigned int)"
"Query_cache::end_of_result(THD*)" -> "Query_cache::try_lock(bool)"
"Query_cache::end_of_result(THD*)" -> "Query_cache::free_query(Query_cache_block*)"
"Query_cache::end_of_result(THD*)" -> "Query_cache::abort(Query_cache_tls*)"
"Query_cache::end_of_result(THD*)" -> "Query_cache_query::writer(Query_cache_tls*)"
"Query_cache::end_of_result(THD*)" -> "Query_cache_query::lock_writing()"
"Query_cache::end_of_result(THD*)" -> "Query_cache_block::query()"
"Query_cache::end_of_result(THD*)" -> "Query_cache::unlock()"
"Query_cache::end_of_result(THD*)" -> "std::max(const _Tp&,const _Tp&) [with _Tp = long unsigned int]"
"Query_cache::end_of_result(THD*)" -> "Query_cache_query::found_rows(ulonglong)"
"Query_cache::insert(Query_cache_tls*,const char*,ulong,unsigned int)" -> "Query_cache_block::query()"
"Query_cache::insert(Query_cache_tls*,const char*,ulong,unsigned int)" -> "Query_cache::unlock()"
"Query_cache::insert(Query_cache_tls*,const char*,ulong,unsigned int)" -> "Query_cache_query::result()"
"Query_cache::insert(Query_cache_tls*,const char*,ulong,unsigned int)" -> "Query_cache::append_result_data(Query_cache_block**,ulong,uchar*,Query_cache_block*)"
"Query_cache::insert(Query_cache_tls*,const char*,ulong,unsigned int)" -> "Query_cache::is_disabled()"
"Query_cache::insert(Query_cache_tls*,const char*,ulong,unsigned int)" -> "Query_cache_query::unlock_writing()"
"Query_cache::insert(Query_cache_tls*,const char*,ulong,unsigned int)" -> "Query_cache::free_query(Query_cache_block*)"
"Query_cache::insert(Query_cache_tls*,const char*,ulong,unsigned int)" -> "Query_cache_query::result(Query_cache_block*)"
"Query_cache::insert(Query_cache_tls*,const char*,ulong,unsigned int)" -> "Query_cache_query::lock_writing()"
"Query_cache::insert(Query_cache_tls*,const char*,ulong,unsigned int)" -> "Query_cache::try_lock(bool)"
"Query_cache::append_result_data(Query_cache_block**,ulong,uchar*,Query_cache_block*)" -> "Query_cache_query::add(ulong)"
"Query_cache::append_result_data(Query_cache_block**,ulong,uchar*,Query_cache_block*)" -> "Query_cache::double_linked_list_join(Query_cache_block*,Query_cache_block*)"
"Query_cache::append_result_data(Query_cache_block**,ulong,uchar*,Query_cache_block*)" -> "Query_cache::unlock()"
"Query_cache::append_result_data(Query_cache_block**,ulong,uchar*,Query_cache_block*)" -> "Query_cache::get_min_append_result_data_size()"
"Query_cache::append_result_data(Query_cache_block**,ulong,uchar*,Query_cache_block*)" -> "std::max(const _Tp&,const _Tp&) [with _Tp = long unsigned int]"
"Query_cache::append_result_data(Query_cache_block**,ulong,uchar*,Query_cache_block*)" -> "memcpy(void*,const void*,size_t)"
"Query_cache::append_result_data(Query_cache_block**,ulong,uchar*,Query_cache_block*)" -> "Query_cache_block::query()"
"Query_cache::append_result_data(Query_cache_block**,ulong,uchar*,Query_cache_block*)" -> "std::min(const _Tp&,const _Tp&) [with _Tp = long unsigned int]"
"Query_cache::append_result_data(Query_cache_block**,ulong,uchar*,Query_cache_block*)" -> "Query_cache::write_result_data(Query_cache_block**,ulong,uchar*,Query_cache_block*,Query_cache_block::block_type)"
"Query_cache::append_result_data(Query_cache_block**,ulong,uchar*,Query_cache_block*)" -> "Query_cache::append_next_free_block(Query_cache_block*,ulong)"
"Query_cache::write_result_data(Query_cache_block**,ulong,uchar*,Query_cache_block*,Query_cache_block::block_type)" -> "Query_cache::unlock()"
"Query_cache::write_result_data(Query_cache_block**,ulong,uchar*,Query_cache_block*,Query_cache_block::block_type)" -> "Query_cache::allocate_data_chain(Query_cache_block**,ulong,Query_cache_block*,my_bool)"
"Query_cache::write_result_data(Query_cache_block**,ulong,uchar*,Query_cache_block*,Query_cache_block::block_type)" -> "Querycache_stream::Querycache_stream(Query_cache_block*,uint)"
"Query_cache::write_result_data(Query_cache_block**,ulong,uchar*,Query_cache_block*,Query_cache_block::block_type)" -> "emb_store_querycache_result(Querycache_stream*,THD*)"
"Query_cache::write_result_data(Query_cache_block**,ulong,uchar*,Query_cache_block*,Query_cache_block::block_type)" -> "Query_cache::free_memory_block(Query_cache_block*)"
"Query_cache::allocate_data_chain(Query_cache_block**,ulong,Query_cache_block*,my_bool)" -> "Query_cache_result::parent(Query_cache_block*)"
"Query_cache::allocate_data_chain(Query_cache_block**,ulong,Query_cache_block*,my_bool)" -> "std::min(const _Tp&,const _Tp&) [with _Tp = long unsigned int]"
"Query_cache::allocate_data_chain(Query_cache_block**,ulong,Query_cache_block*,my_bool)" -> "Query_cache_block::result()"
"Query_cache::allocate_data_chain(Query_cache_block**,ulong,Query_cache_block*,my_bool)" -> "std::max(const _Tp&,const _Tp&) [with _Tp = long unsigned int]"
"Query_cache::allocate_data_chain(Query_cache_block**,ulong,Query_cache_block*,my_bool)" -> "Query_cache::get_min_append_result_data_size()"
"Query_cache::allocate_data_chain(Query_cache_block**,ulong,Query_cache_block*,my_bool)" -> "Query_cache::get_min_first_result_data_size()"
"Query_cache::allocate_data_chain(Query_cache_block**,ulong,Query_cache_block*,my_bool)" -> "Query_cache::double_linked_list_join(Query_cache_block*,Query_cache_block*)"
"Query_cache::allocate_data_chain(Query_cache_block**,ulong,Query_cache_block*,my_bool)" -> "Query_cache::allocate_block(ulong,my_bool,ulong)"
"Query_cache::get_min_first_result_data_size()" -> "std::max(const _Tp&,const _Tp&) [with _Tp = long unsigned int]"
"Query_cache::get_min_first_result_data_size()" -> "std::min(const _Tp&,const _Tp&) [with _Tp = long unsigned int]"
"emb_store_querycache_result(Querycache_stream*,THD*)" -> "Querycache_stream::store_short(ushort)"
"emb_store_querycache_result(Querycache_stream*,THD*)" -> "Querycache_stream::store_int(uint)"
"emb_store_querycache_result(Querycache_stream*,THD*)" -> "Querycache_stream::store_safe_str(const char*,uint)"
"emb_store_querycache_result(Querycache_stream*,THD*)" -> "Querycache_stream::store_ll(ulonglong)"
"emb_store_querycache_result(Querycache_stream*,THD*)" -> "Querycache_stream::store_uchar(uchar)"
"emb_store_querycache_result(Querycache_stream*,THD*)" -> "Querycache_stream::store_str(const char*,uint)"
"Querycache_stream::store_short(ushort)" -> "Querycache_stream::use_next_block(bool)"
"Querycache_stream::store_int(uint)" -> "Querycache_stream::use_next_block(bool)"
"Querycache_stream::store_int(uint)" -> "memcpy(void*,const void*,size_t)"
"Querycache_stream::store_safe_str(const char*,uint)" -> "Querycache_stream::store_int(uint)"
"Querycache_stream::store_safe_str(const char*,uint)" -> "Querycache_stream::store_str_only(const char*,uint)"
"Querycache_stream::store_str_only(const char*,uint)" -> "Querycache_stream::use_next_block(bool)"
"Querycache_stream::store_str_only(const char*,uint)" -> "memcpy(void*,const void*,size_t)"
"Querycache_stream::store_ll(ulonglong)" -> "memcpy(void*,const void*,size_t)"
"Querycache_stream::store_ll(ulonglong)" -> "Querycache_stream::use_next_block(bool)"
"Querycache_stream::store_uchar(uchar)" -> "Querycache_stream::use_next_block(bool)"
"Querycache_stream::store_str(const char*,uint)" -> "Querycache_stream::store_str_only(const char*,uint)"
"Querycache_stream::store_str(const char*,uint)" -> "Querycache_stream::store_int(uint)"
"Query_cache::append_next_free_block(Query_cache_block*,ulong)" -> "Query_cache::exclude_from_free_memory_list(Query_cache_block*)"
"Query_cache::append_next_free_block(Query_cache_block*,ulong)" -> "Query_cache::split_block(Query_cache_block*,ulong)"
"Query_cache::append_next_free_block(Query_cache_block*,ulong)" -> "Query_cache_block::destroy()"
"Query_cache::append_next_free_block(Query_cache_block*,ulong)" -> "Query_cache_block::is_free()"
"TraceTool::end_transaction()" -> "_Alloc>::push_back(const value_type&) [with _Tp = long int,_Alloc = std::allocator<long int>,std::vector<_Tp,_Alloc>::value_type = long int]"
"TraceTool::end_transaction()" -> "pthread_mutex_unlock(pthread_mutex_t*)"
"TraceTool::end_transaction()" -> "_Container>::operator*() const [with _Iterator = std::vector<long int>*,_Container = std::vector<std::vector<long int> >,__gnu_cxx::__normal_iterator<_Iterator,_Container>::reference = std::vector<long int>&]"
"TraceTool::end_transaction()" -> "_Alloc>::end() [with _Tp = std::vector<long int>,_Alloc = std::allocator<std::vector<long int> >,std::vector<_Tp,_Alloc>::iterator = __gnu_cxx::__normal_iterator<std::vector<long int>*,std::vector<std::vector<long int> > >,typename std::_Vector_base<_Tp,_Alloc>::_Tp_alloc_type::pointer = std::vector<long int>*]"
"TraceTool::end_transaction()" -> "_Container>::operator++() [with _Iterator = std::vector<long int>*,_Container = std::vector<std::vector<long int> >,__gnu_cxx::__normal_iterator<_Iterator,_Container> = __gnu_cxx::__normal_iterator<std::vector<long int>*,std::vector<std::vector<long int> > >]"
"TraceTool::end_transaction()" -> "__gnu_cxx::operator!=(const __gnu_cxx::__normal_iterator<_Iterator,_Container>&,const __gnu_cxx::__normal_iterator<_Iterator,_Container>&) [with _Iterator = std::vector<long int>*,_Container = std::vector<std::vector<long int> >]"
"TraceTool::end_transaction()" -> "pthread_mutex_lock(pthread_mutex_t*)"
"TraceTool::end_transaction()" -> "_Alloc>::begin() [with _Tp = std::vector<long int>,_Alloc = std::allocator<std::vector<long int> >,std::vector<_Tp,_Alloc>::iterator = __gnu_cxx::__normal_iterator<std::vector<long int>*,std::vector<std::vector<long int> > >,typename std::_Vector_base<_Tp,_Alloc>::_Tp_alloc_type::pointer = std::vector<long int>*]"
"__gnu_cxx::operator!=(const __gnu_cxx::__normal_iterator<_Iterator,_Container>&,const __gnu_cxx::__normal_iterator<_Iterator,_Container>&) [with _Iterator = std::vector<long int>*,_Container = std::vector<std::vector<long int> >]" -> "_Container>::base() const [with _Iterator = std::vector<long int>*,_Container = std::vector<std::vector<long int> >]"
"READ_RECORD::READ_RECORD()" -> "rr_quick(READ_RECORD*)"
"rr_quick(READ_RECORD*)" -> "rr_handle_error(READ_RECORD*,int)"
"rr_quick(READ_RECORD*)" -> "QUICK_RANGE_SELECT::get_next()"
"rr_handle_error(READ_RECORD*,int)" -> "THD::send_kill_message() const"
"THD::send_kill_message() const" -> "Diagnostics_area::is_set() const"
"THD::send_kill_message() const" -> "my_message(uint,const char*,myf)"
"THD::send_kill_message() const" -> "_current_thd()"
"THD::send_kill_message() const" -> "THD::get_stmt_da() const"
"THD::send_kill_message() const" -> "THD::killed_errno() const"
"_current_thd()" -> "pthread_getspecific(pthread_key_t)"
"QUICK_RANGE_SELECT::get_next()" -> "TABLE::column_bitmaps_set_no_signal(MY_BITMAP*,MY_BITMAP*)"
"QUICK_RANGE_SELECT::get_next()" -> "multi_range_read_next(char**)"
"multi_range_read_next(char**)" -> "read_range_first(const key_range*,const key_range*,bool,bool)"
"multi_range_read_next(char**)" -> "was_semi_consistent_read()"
"multi_range_read_next(char**)" -> "next(range_seq_t,KEY_MULTI_RANGE *)"
"read_range_first(const key_range*,const key_range*,bool,bool)" -> "set_end_range(const key_range*,enum_range_scan_direction)"
"read_range_first(const key_range*,const key_range*,bool,bool)" -> "ha_index_read_map(uchar*,const uchar*,key_part_map,enum ha_rkey_function)"
"read_range_first(const key_range*,const key_range*,bool,bool)" -> "compare_key(key_range*)"
"ha_index_read_map(uchar*,const uchar*,key_part_map,enum ha_rkey_function)" -> "ha_innobase::index_read(uchar*,const uchar*,uint,ha_rkey_function)"