#include "WrapperGenerator.h"

using namespace std;

void WrapperGenerator::initOpToGenMap() {
    shared_ptr<TracingInnerWrapperGenerator> traceGen;
    shared_ptr<CachingIPCInnerWrapperGenerator> cachingIPCGen;
    shared_ptr<NonCachingIPCInnerWrapperGenerator> nonCachingIPCGen;

    traceGen = make_shared<TracingInnerWrapperGenerator>(operationMap);
    cachingIPCGen = make_shared<CachingIPCInnerWrapperGenerator>();
    nonCachingIPCGen = make_shared<NonCachingIPCInnerWrapperGenerator>();

    operationToGenerator = WrapperGenMap({{"MUTEX_LOCK", traceGen}, 
                                          {"MUTEX_UNLOCK", traceGen},
                                          {"CV_WAIT", traceGen},
                                          {"CV_BROADCAST", traceGen},
                                          {"CV_SIGNAL", traceGen},
                                          {"QUEUE_ENQUEUE", traceGen},
                                          {"QUEUE_DEQUEUE", traceGen},
                                          {"MESSAGE_SEND", traceGen},
                                          {"MESSAGE_RECEIVE", traceGen},
                                          {"MKNOD", cachingIPCGen},
                                          {"OPEN", cachingIPCGen},
                                          {"PIPE", cachingIPCGen},
                                          {"MSGGET", cachingIPCGen},
                                          {"READ", nonCachingIPCGen},
                                          {"WRITE", nonCachingIPCGen},
                                          {"MSGRCV", nonCachingIPCGen},
                                          {"MSGSND", nonCachingIPCGen}});
}

WrapperGenerator::WrapperGenerator(shared_ptr<unordered_map<string, 
                                   FunctionPrototype>> _prototypeMap,
                                   std::shared_ptr<std::unordered_map<std::string, 
                                   std::string>> _operationMap,
                                   string pathPrefix):
                                   prototypeMap(_prototypeMap),
                                   operationMap(_operationMap) {
    initOpToGenMap();

    headerFile.open(pathPrefix + "VProfEventWrappers.h");
    implementationFile.open(pathPrefix + "VProfEventWrappers.cpp");

    const string generatedFileMessage = 
        " ///////////////////////////////////////////////////// \n"
        " // Note that this file was generated by VProfiler. // \n"
        " // Please do not change the contents of this file! // \n"
        " ///////////////////////////////////////////////////// \n\n";

    headerFile << generatedFileMessage; 
    implementationFile << generatedFileMessage;
}

vector<string> WrapperGenerator::getFilenames() {
    vector<string> result;

    for (auto kv : *prototypeMap) {
        result.push_back(kv.second.filename);
    }

    sort(result.begin(), result.end());
    result.erase(unique(result.begin(), result.end()), result.end());
    return result;
}

void WrapperGenerator::GenerateHeader() {
    vector<string> includeNames = getFilenames();
    headerFile << "#ifndef VPROFEVENTWRAPPERS_H\n#define VPROFEVENTWRAPPERS_H\n";
    for (string &includeName : includeNames) {
        headerFile << "#include \"" + includeName + "\"\n";
    }
    headerFile << "#include \"trace_tool.h\"\n\n"
                  "#ifdef __cplusplus\nextern \"C\" {\n#endif";

    for (auto kv : *prototypeMap) {
        headerFile << kv.second.functionPrototype + ";\n\n";
    }

    headerFile << "#ifdef __cplusplus\n}\n#endif\n\n#endif";

    headerFile.close();
}

void WrapperGenerator::GenerateImplementations() {
    string operation;
    implementationFile << "#include \"VProfEventWrappers.h\"\n\n";

    for (auto kv : *prototypeMap) {
        operation = (*operationMap)[kv.first];
        
        implementationFile << kv.second.functionPrototype + " {\n\t";

        if (kv.second.returnType != "void") {
            implementationFile << kv.second.returnType + " result;\n\t";
        }

        operationToGenerator[operation]->GenerateWrapperPrologue(kv.first, kv.second);

        if (kv.second.returnType != "void") {
            implementationFile << "result = ";
        }

        implementationFile << kv.second.innerCallPrefix + "(";

        for (int i = 0, j = kv.second.paramVars.size(); i < j; i++) {
            implementationFile << kv.second.paramVars[i];

            if (i != (j - 1)) {
                implementationFile << ", ";
            }
        }

        implementationFile <<");\n\t";

        operationToGenerator[operation]->GenerateWrapperEpilogue(kv.first, kv.second);

        if (kv.second.returnType != "void") {
            implementationFile << "\treturn result;\n";
        }

        implementationFile << "}\n\n";
    }

    implementationFile.close();
}

void WrapperGenerator::GenerateWrappers() {
    GenerateHeader();
    GenerateImplementations();
}
