#ifndef CLANGBASE_H
#define CLANGBASE_H

// Clang libs
#include "clang/Frontend/FrontendAction.h"
#include "clang/Frontend/CompilerInstance.h"
#include "clang/AST/RecursiveASTVisitor.h"
#include "clang/AST/ASTConsumer.h"
#include "clang/AST/ASTContext.h"
#include "clang/AST/Expr.h"
#include "clang/AST/ExprCXX.h"
#include "clang/AST/Type.h"
#include "clang/AST/Decl.h"
#include "clang/Rewrite/Core/Rewriter.h"

// LLVM libs
//#include "llvm/Support/raw_ostream.h"

// VProf libs
#include "FunctionPrototype.h"

// STL libs
#include <memory>
#include <unordered_map>
#include <string>
#include <vector>

class VProfVisitor : public clang::RecursiveASTVisitor<VProfVisitor> {
    private:
        // Context storing additional state
        clang::ASTContext *astContext;

        // Client to rewrite source
        std::shared_ptr<clang::Rewriter> rewriter;

        // Hash map of fully qualified function names to the function
        // name to which the key functions should be converted to in the source.
        std::unordered_map<std::string, std::string> functions;

        // Hash map of fully qualified function names to the new function prototypes
        // to be generated by the wrapper generator.  After ParseAST is called on
        // a source file, newPrototypes should have an entry for each function
        // provided by the user which is in the expanded source file (i.e. after 
        // #includes are processed).
        std::shared_ptr<std::unordered_map<std::string, FunctionPrototype>> prototypeMap;

        void fixFunction(const clang::CallExpr *call, const std::string &functionName,
                         bool  isMemberCall);

        void appendNonObjArgs(std::string &newCall, std::vector<const clang::Expr*> &args);

        bool shouldCreatePrototype(const std::string &functionName);

        // Creates the wrapper prototype based on function decl.
        void createNewPrototype(const clang::FunctionDecl *decl);

    public:
        // Not sure how I should break the last line up style-wise
        explicit VProfVisitor(std::shared_ptr<clang::CompilerInstance> ci, 
                              std::shared_ptr<clang::Rewriter> _rewriter,
                              std::unordered_map<std::string, std::string> &_functions,
                              std::shared_ptr<std::unordered_map<std::string, FunctionProtoype>> 
                              prototypeMap);

        ~VProfVisitor(); 

        // Override trigger for when a CallExpr is found in the AST
        virtual bool VisitCallExpr(const clang::CallExpr *call);

        // Override trigger for when a CXXMemberCallExpr is found in the AST
        virtual bool VisitCXXMemberCallExpr(const clang::CXXMemberCallExpr *call);
};

class VProfASTConsumer : public clang::ASTConsumer {
    private:
        std::unique_ptr<VProfVisitor> visitor;
    public:
        // Override ctor to pass hash map of fully qualified function names to the function
        // name to which the key functions should be converted to in the source.
        explicit VProfASTConsumer(std::shared_ptr<clang::CompilerInstance> ci, std::shared_ptr<clang::Rewriter> rewriter,
                               std::unordered_map<std::string, std::string> &functions): 
                               visitor(std::unique_ptr<VProfVisitor>(new VProfVisitor(ci, rewriter, functions))) {}

        //virtual ~VProfASTConsumer() {}

        virtual void HandleTranslationUnit(clang::ASTContext &context) {
            visitor->TraverseDecl(context.getTranslationUnitDecl());
        }
};

/* Don't think this is needed
 * class VProfFrontendAction : public clang::ASTFrontendAction {
    public:
        virtual std::unique_ptr<clang::ASTConsumer> CreateASTConsumer(clang::CompilerInstance &ci, llvm::StringRef file) {
            return std::unique_ptr<VProfASTConsumer>(new VProfASTConsumer(&ci));
        }
};*/

#endif
